{"index":"<h1 class=\"post-title\">Quick start</h1>\n\n<p>Let’s get started by building a simple web application with TypeScript.</p>\n<h2 id=\"installing-typescript\">Installing TypeScript</h2>\n<p>There are two main ways to get the TypeScript tools:</p>\n<ul>\n<li>Via npm (the Node.js package manager)</li>\n<li>By installing TypeScript’s Visual Studio plugins</li>\n</ul>\n<p>Visual Studio 2015 and Visual Studio 2013 Update 2 include TypeScript by default. If you didn’t install TypeScript with Visual Studio, you can still <a href=\"https://www.typescriptlang.org/#download-links\">download it</a>.</p>\n<p>For NPM users:</p>\n<pre data-language=\"shell\">npm install -g typescript\r\n</pre>\n<h2 id=\"building-your-first-typescript-file\">Building your first TypeScript file</h2>\n<p>In your editor, type the following JavaScript code in <code>greeter.ts</code>:</p>\n<pre data-language=\"typescript\">function greeter(person) {\r\n  return \"Hello, \" + person;\r\n}\r\n\r\nvar user = \"Jane User\";\r\n\r\ndocument.body.innerHTML = greeter(user);          \r\n</pre>\n<h2 id=\"compiling-your-code\">Compiling your code</h2>\n<p>We used a <code>.ts</code> extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.</p>\n<p>At the command line, run the TypeScript compiler:</p>\n<pre data-language=\"shell\">tsc greeter.ts          \r\n</pre>\n<p>The result will be a file <code>greeter.js</code> which contains the same JavaScript that you fed in. We’re up and running using TypeScript in our JavaScript app!</p>\n<p>Now we can start taking advantage of some of the new tools TypeScript offers. Add a <code>: string</code> type annotation to the ‘person’ function argument as shown here:</p>\n<pre data-language=\"typescript\">function greeter(person: string) {\r\n  return \"Hello, \" + person;\r\n}\r\n\r\nvar user = \"Jane User\";\r\n\r\ndocument.body.innerHTML = greeter(user);        \r\n</pre>\n<h2 id=\"type-annotations\">Type annotations</h2>\n<p>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:</p>\n<pre data-language=\"typescript\">function greeter(person: string) {\r\n  return \"Hello, \" + person;\r\n}\r\n\r\nvar user = [0, 1, 2];\r\n\r\ndocument.body.innerHTML = greeter(user); \r\n</pre>\n<p>Re-compiling, you’ll now see an error:</p>\n<pre data-language=\"shell\">greeter.ts(7,26): Supplied parameters do not match any signature of call target\r\n</pre>\n<p>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.</p>\n<p>Notice that although there were errors, the <code>greeter.js</code> file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</p>\n<h2 id=\"interfaces\">Interfaces</h2>\n<p>Let’s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit <code>implements</code> clause.</p>\n<pre data-language=\"typescript\">interface Person {\r\n  firstName: string;\r\n  lastName: string;\r\n}\r\n\r\nfunction greeter(person: Person) {\r\n  return \"Hello, \" + person.firstName + \" \" + person.lastName;\r\n}\r\n\r\nvar user = { firstName: \"Jane\", lastName: \"User\" };\r\n\r\ndocument.body.innerHTML = greeter(user);\r\n</pre>\n<h2 id=\"classes\">Classes</h2>\n<p>Finally, let’s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.</p>\n<p>Here we’re going to create a <code>Student</code> class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.</p>\n<p>Also of note, the use of <code>public</code> on arguments to the constructor is a shorthand that allows us to automatically create properties with that name.</p>\n<pre data-language=\"typescript\">class Student {\r\n  fullName: string;\r\n  constructor(public firstName, public middleInitial, public lastName) {\r\n    this.fullName = firstName + \" \" + middleInitial + \" \" + lastName;\r\n  }\r\n}\r\n\r\ninterface Person {\r\n  firstName: string;\r\n  lastName: string;\r\n}\r\n\r\nfunction greeter(person : Person) {\r\n  return \"Hello, \" + person.firstName + \" \" + person.lastName;\r\n}\r\n\r\nvar user = new Student(\"Jane\", \"M.\", \"User\");\r\n\r\ndocument.body.innerHTML = greeter(user);\r\n</pre>\n<p>Re-run <code>tsc greeter.ts</code> and you’ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.</p>\n<h2 id=\"running-your-typescript-web-app\">Running your TypeScript web app</h2>\n<p>Now type the following in <code>greeter.html</code>:</p>\n<pre data-language=\"html\">&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n  &lt;head&gt;&lt;title&gt;TypeScript Greeter&lt;/title&gt;&lt;/head&gt;\r\n  &lt;body&gt;\r\n    &lt;script src=\"greeter.js\"&gt;&lt;/script&gt;\r\n  &lt;/body&gt;\r\n&lt;/html&gt;\r\n</pre>\n<p>Open <code>greeter.html</code> in the browser to run your first simple TypeScript web application!</p>\n<p>Optional: Open <code>greeter.ts</code> in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.</p>\n<p>The type information provided works together with the tools to work with JavaScript at application scale. For more examples of what’s possible in TypeScript, see the Samples section of the website.</p>\n<p><img src=\"https://www.typescriptlang.org/assets/images/docs/greet_person.png\" alt=\"Visual Studio picture\"></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/tutorial.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/tutorial.html</a>\n  </p>\n</div>\n","release-notes/typescript-1.8":"<h1 class=\"post-title\">TypeScript 1.8</h1>\n\n<h2 id=\"type-parameters-as-constraints\">Type parameters as constraints</h2>\n<p>With TypeScript 1.8 it becomes possible for a type parameter constraint to reference type parameters from the same type parameter list. Previously this was an error. This capability is usually referred to as <a href=\"https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification\">F-Bounded Polymorphism</a>.</p>\n<h5 id=\"example\">Example</h5>\n<pre data-language=\"typescript\">function assign&lt;T extends U, U&gt;(target: T, source: U): T {\r\n  for (let id in source) {\r\n    target[id] = source[id];\r\n  }\r\n  return target;\r\n}\r\n\r\nlet x = { a: 1, b: 2, c: 3, d: 4 };\r\nassign(x, { b: 10, d: 20 });\r\nassign(x, { e: 0 });  // Error\r\n</pre>\n<h2 id=\"control-flow-analysis-errors\">Control flow analysis errors</h2>\n<p>TypeScript 1.8 introduces control flow analysis to help catch common errors that users tend to run into. Read on to get more details, and check out these errors in action:</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/8052307/5210657/c5ae0f28-7585-11e4-97d8-86169ef2a160.gif\" alt=\"cfa\"></p>\n<h3 id=\"unreachable-code\">Unreachable code</h3>\n<p>Statements guaranteed to not be executed at run time are now correctly flagged as unreachable code errors. For instance, statements following unconditional <code>return</code>, <code>throw</code>, <code>break</code> or <code>continue</code> statements are considered unreachable. Use <code>--allowUnreachableCode</code> to disable unreachable code detection and reporting.</p>\n<h5 id=\"example-1\">Example</h5>\n<p>Here’s a simple example of an unreachable code error:</p>\n<pre data-language=\"typescript\">function f(x) {\r\n  if (x) {\r\n     return true;\r\n  }\r\n  else {\r\n     return false;\r\n  }\r\n\r\n  x = 0; // Error: Unreachable code detected.\r\n}\r\n</pre>\n<p>A more common error that this feature catches is adding a newline after a <code>return</code> statement:</p>\n<pre data-language=\"typescript\">function f() {\r\n  return      // Automatic Semicolon Insertion triggered at newline\r\n  {\r\n    x: \"string\"   // Error: Unreachable code detected.\r\n  }\r\n}\r\n</pre>\n<p>Since JavaScript automatically terminates the <code>return</code> statement at the end of the line, the object literal becomes a block.</p>\n<h3 id=\"unused-labels\">Unused labels</h3>\n<p>Unused labels are also flagged. Just like unreachable code checks, these are turned on by default; use <code>--allowUnusedLabels</code> to stop reporting these errors.</p>\n<h5 id=\"example-2\">Example</h5>\n<pre data-language=\"typescript\">loop: while (x &gt; 0) {  // Error: Unused label.\r\n  x++;\r\n}\r\n</pre>\n<h3 id=\"implicit-returns\">Implicit returns</h3>\n<p>Functions with code paths that do not return a value in JS implicitly return <code>undefined</code>. These can now be flagged by the compiler as implicit returns. The check is turned <em>off</em> by default; use <code>--noImplicitReturns</code> to turn it on.</p>\n<h5 id=\"example-3\">Example</h5>\n<pre data-language=\"typescript\">function f(x) { // Error: Not all code paths return a value.\r\n  if (x) {\r\n    return false;\r\n  }\r\n\r\n  // implicitly returns `undefined`\r\n}\r\n</pre>\n<h3 id=\"case-clause-fall-throughs\">Case clause fall-throughs</h3>\n<p>TypeScript can reports errors for fall-through cases in switch statement where the case clause is non-empty. This check is turned <em>off</em> by default, and can be enabled using <code>--noFallthroughCasesInSwitch</code>.</p>\n<h5 id=\"example-4\">Example</h5>\n<p>With <code>--noFallthroughCasesInSwitch</code>, this example will trigger an error:</p>\n<pre data-language=\"typescript\">switch (x % 2) {\r\n  case 0: // Error: Fallthrough case in switch.\r\n    console.log(\"even\");\r\n\r\n  case 1:\r\n    console.log(\"odd\");\r\n    break;\r\n}\r\n</pre>\n<p>However, in the following example, no error will be reported because the fall-through case is empty:</p>\n<pre data-language=\"typescript\">switch (x % 3) {\r\n  case 0:\r\n  case 1:\r\n    console.log(\"Acceptable\");\r\n    break;\r\n\r\n  case 2:\r\n    console.log(\"This is *two much*!\");\r\n    break;\r\n}\r\n</pre>\n<h2 id=\"stateless-function-components-in-react\">Stateless Function Components in React</h2>\n<p>TypeScript now supports <a href=\"https://facebook.github.io/react/docs/reusable-components.html#stateless-functions\">Stateless Function components</a>. These are lightweight components that easily compose other components:</p>\n<pre data-language=\"typescript\">// Use parameter destructuring and defaults for easy definition of 'props' type\r\nconst Greeter = ({name = 'world'}) =&gt; &lt;div&gt;Hello, {name}!&lt;/div&gt;;\r\n\r\n// Properties get validated\r\nlet example = &lt;Greeter name='TypeScript 1.8' /&gt;;\r\n</pre>\n<p>For this feature and simplified props, be sure to be use the <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react\">latest version of react.d.ts</a>.</p>\n<h2 id=\"simplified-props-type-management-in-react\">Simplified <code>props</code> type management in React</h2>\n<p>In TypeScript 1.8 with the latest version of react.d.ts (see above), we’ve also greatly simplified the declaration of <code>props</code> types.</p>\n<p>Specifically:</p>\n<ul>\n<li>You no longer need to either explicitly declare <code>ref</code> and <code>key</code> or <code>extend React.Props</code>\n</li>\n<li>The <code>ref</code> and <code>key</code> properties will appear with correct types on all components</li>\n<li>The <code>ref</code> property is correctly disallowed on instances of Stateless Function components</li>\n</ul>\n<h2 id=\"augmenting-globalmodule-scope-from-modules\">Augmenting global/module scope from modules</h2>\n<p>Users can now declare any augmentations that they want to make, or that any other consumers already have made, to an existing module. Module augmentations look like plain old ambient module declarations (i.e. the <code>declare module \"foo\" { }</code> syntax), and are directly nested either your own modules, or in another top level ambient external module.</p>\n<p>Furthermore, TypeScript also has the notion of <em>global</em> augmentations of the form <code>declare global { }</code>. This allows modules to augment global types such as <code>Array</code> if necessary.</p>\n<p>The name of a module augmentation is resolved using the same set of rules as module specifiers in <code>import</code> and <code>export</code> declarations. The declarations in a module augmentation are merged with any existing declarations the same way they would if they were declared in the same file.</p>\n<p>Neither module augmentations nor global augmentations can add new items to the top level scope - they can only “patch” existing declarations.</p>\n<h5 id=\"example-5\">Example</h5>\n<p>Here <code>map.ts</code> can declare that it will internally patch the <code>Observable</code> type from <code>observable.ts</code> and add the <code>map</code> method to it.</p>\n<pre data-language=\"typescript\">// observable.ts\r\nexport class Observable&lt;T&gt; {\r\n  // ...\r\n}\r\n</pre>\n<pre data-language=\"typescript\">// map.ts\r\nimport { Observable } from \"./observable\";\r\n\r\n// Create an augmentation for \"./observable\"\r\ndeclare module \"./observable\" {\r\n\r\n  // Augment the 'Observable' class definition with interface merging\r\n  interface Observable&lt;T&gt; {\r\n    map&lt;U&gt;(proj: (el: T) =&gt; U): Observable&lt;U&gt;;\r\n  }\r\n\r\n}\r\n\r\nObservable.prototype.map = /*...*/;\r\n</pre>\n<pre data-language=\"typescript\">// consumer.ts\r\nimport { Observable } from \"./observable\";\r\nimport \"./map\";\r\n\r\nlet o: Observable&lt;number&gt;;\r\no.map(x =&gt; x.toFixed());\r\n</pre>\n<p>Similarly, the global scope can be augmented from modules using a <code>declare global</code> declarations:</p>\n<h5 id=\"example-6\">Example</h5>\n<pre data-language=\"typescript\">// Ensure this is treated as a module.\r\nexport {};\r\n\r\ndeclare global {\r\n  interface Array&lt;T&gt; {\r\n    mapToNumbers(): number[];\r\n  }\r\n}\r\n\r\nArray.prototype.mapToNumbers = function () { /* ... */ }\r\n</pre>\n<h2 id=\"string-literal-types\">String literal types</h2>\n<p>It’s not uncommon for an API to expect a specific set of strings for certain values. For instance, consider a UI library that can move elements across the screen while controlling the <a href=\"https://en.wikipedia.org/wiki/Inbetweening\">“easing” of the animation.</a></p>\n<pre data-language=\"typescript\">declare class UIElement {\r\n  animate(options: AnimationOptions): void;\r\n}\r\n\r\ninterface AnimationOptions {\r\n  deltaX: number;\r\n  deltaY: number;\r\n  easing: string; // Can be \"ease-in\", \"ease-out\", \"ease-in-out\"\r\n}\r\n</pre>\n<p>However, this is error prone - there is nothing stopping a user from accidentally misspelling one of the valid easing values:</p>\n<pre data-language=\"typescript\">// No errors\r\nnew UIElement().animate({ deltaX: 100, deltaY: 100, easing: \"ease-inout\" });\r\n</pre>\n<p>With TypeScript 1.8, we’ve introduced string literal types. These types are written the same way string literals are, but in type positions.</p>\n<p>Users can now ensure that the type system will catch such errors. Here’s our new <code>AnimationOptions</code> using string literal types:</p>\n<pre data-language=\"typescript\">interface AnimationOptions {\r\n  deltaX: number;\r\n  deltaY: number;\r\n  easing: \"ease-in\" | \"ease-out\" | \"ease-in-out\";\r\n}\r\n\r\n// Error: Type '\"ease-inout\"' is not assignable to type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\r\nnew UIElement().animate({ deltaX: 100, deltaY: 100, easing: \"ease-inout\" });\r\n</pre>\n<h2 id=\"improved-unionintersection-type-inference\">Improved union/intersection type inference</h2>\n<p>TypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types. For example, when inferring from <code>string | string[]</code> to <code>string | T</code>, we reduce the types to <code>string[]</code> and <code>T</code>, thus inferring <code>string[]</code> for <code>T</code>.</p>\n<h5 id=\"example-7\">Example</h5>\n<pre data-language=\"typescript\">type Maybe&lt;T&gt; = T | void;\r\n\r\nfunction isDefined&lt;T&gt;(x: Maybe&lt;T&gt;): x is T {\r\n  return x !== undefined &amp;&amp; x !== null;\r\n}\r\n\r\nfunction isUndefined&lt;T&gt;(x: Maybe&lt;T&gt;): x is void {\r\n  return x === undefined || x === null;\r\n}\r\n\r\nfunction getOrElse&lt;T&gt;(x: Maybe&lt;T&gt;, defaultValue: T): T {\r\n  return isDefined(x) ? x : defaultValue;\r\n}\r\n\r\nfunction test1(x: Maybe&lt;string&gt;) {\r\n  let x1 = getOrElse(x, \"Undefined\");     // string\r\n  let x2 = isDefined(x) ? x : \"Undefined\";  // string\r\n  let x3 = isUndefined(x) ? \"Undefined\" : x;  // string\r\n}\r\n\r\nfunction test2(x: Maybe&lt;number&gt;) {\r\n  let x1 = getOrElse(x, -1);     // number\r\n  let x2 = isDefined(x) ? x : -1;  // number\r\n  let x3 = isUndefined(x) ? -1 : x;  // number\r\n}\r\n</pre>\n<h2 id=\"concatenate-amd-and-system-modules-with---outfile\">Concatenate <code>AMD</code> and <code>System</code> modules with <code>--outFile</code>\n</h2>\n<p>Specifying <code>--outFile</code> in conjunction with <code>--module amd</code> or <code>--module system</code> will concatenate all modules in the compilation into a single output file containing multiple module closures.</p>\n<p>A module name will be computed for each module based on its relative location to <code>rootDir</code>.</p>\n<h5 id=\"example-8\">Example</h5>\n<pre data-language=\"typescript\">// file src/a.ts\r\nimport * as B from \"./lib/b\";\r\nexport function createA() {\r\n  return B.createB();\r\n}\r\n</pre>\n<pre data-language=\"typescript\">// file src/lib/b.ts\r\nexport function createB() {\r\n  return { };\r\n}\r\n</pre>\n<p>Results in:</p>\n<pre data-language=\"javascript\">define(\"lib/b\", [\"require\", \"exports\"], function (require, exports) {\r\n  \"use strict\";\r\n  function createB() {\r\n    return {};\r\n  }\r\n  exports.createB = createB;\r\n});\r\ndefine(\"a\", [\"require\", \"exports\", \"lib/b\"], function (require, exports, B) {\r\n  \"use strict\";\r\n  function createA() {\r\n    return B.createB();\r\n  }\r\n  exports.createA = createA;\r\n});\r\n</pre>\n<h2 id=\"support-for-default-import-interop-with-systemjs\">Support for <code>default</code> import interop with SystemJS</h2>\n<p>Module loaders like SystemJS wrap CommonJS modules and expose then as a <code>default</code> ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.</p>\n<p>Setting the new compiler flag <code>--allowSyntheticDefaultImports</code> indicates that the module loader performs some kind of synthetic default import member creation not indicated in the imported .ts or .d.ts. The compiler will infer the existence of a <code>default</code> export that has the shape of the entire module itself.</p>\n<p>System modules have this flag on by default.</p>\n<h2 id=\"allow-captured-letconst-in-loops\">Allow captured <code>let</code>/<code>const</code> in loops</h2>\n<p>Previously an error, now supported in TypeScript 1.8. <code>let</code>/<code>const</code> declarations within loops and captured in functions are now emitted to correctly match <code>let</code>/<code>const</code> freshness semantics.</p>\n<h5 id=\"example-9\">Example</h5>\n<pre data-language=\"typescript\">let list = [];\r\nfor (let i = 0; i &lt; 5; i++) {\r\n  list.push(() =&gt; i);\r\n}\r\n\r\nlist.forEach(f =&gt; console.log(f()));\r\n</pre>\n<p>is compiled to:</p>\n<pre data-language=\"javascript\">var list = [];\r\nvar _loop_1 = function(i) {\r\n  list.push(function () { return i; });\r\n};\r\nfor (var i = 0; i &lt; 5; i++) {\r\n  _loop_1(i);\r\n}\r\nlist.forEach(function (f) { return console.log(f()); });\r\n</pre>\n<p>And results in</p>\n<pre data-language=\"cmd\">0\r\n1\r\n2\r\n3\r\n4\r\n</pre>\n<h2 id=\"improved-checking-for-forin-statements\">Improved checking for <code>for..in</code> statements</h2>\n<p>Previously the type of a <code>for..in</code> variable is inferred to <code>any</code>; that allowed the compiler to ignore invalid uses within the <code>for..in</code> body.</p>\n<p>Starting with TypeScript 1.8:</p>\n<ul>\n<li>The type of a variable declared in a <code>for..in</code> statement is implicitly <code>string</code>.</li>\n<li>When an object with a numeric index signature of type <code>T</code> (such as an array) is indexed by a <code>for..in</code> variable of a containing <code>for..in</code> statement for an object <em>with</em> a numeric index signature and <em>without</em> a string index signature (again such as an array), the value produced is of type <code>T</code>.</li>\n</ul>\n<h5 id=\"example-10\">Example</h5>\n<pre data-language=\"typescript\">var a: MyObject[];\r\nfor (var x in a) {   // Type of x is implicitly string\r\n  var obj = a[x];  // Type of obj is MyObject\r\n}\r\n</pre>\n<h2 id=\"modules-are-now-emitted-with-a-use-strict-prologue\">Modules are now emitted with a <code>\"use strict\";</code> prologue</h2>\n<p>Modules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn’t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to <code>NaN</code>, will now loudly fail. You can reference the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\">MDN Article</a> on strict mode for a detailed list of the differences between strict mode and non-strict mode.</p>\n<h2 id=\"including-js-files-with---allowjs\">Including <code>.js</code> files with <code>--allowJs</code>\n</h2>\n<p>Often there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</p>\n<p><code>.js</code> files are now allowed as input to <code>tsc</code>. The TypeScript compiler checks the input <code>.js</code> files for syntax errors, and emits valid output based on the <code>--target</code> and <code>--module</code> flags. The output can be combined with other <code>.ts</code> files as well. Source maps are still generated for <code>.js</code> files just like with <code>.ts</code> files.</p>\n<h2 id=\"custom-jsx-factories-using---reactnamespace\">Custom JSX factories using <code>--reactNamespace</code>\n</h2>\n<p>Passing <code>--reactNamespace &lt;JSX factory Name&gt;</code> along with <code>--jsx react</code> allows for using a different JSX factory from the default <code>React</code>.</p>\n<p>The new factory name will be used to call <code>createElement</code> and <code>__spread</code> functions.</p>\n<h5 id=\"example-11\">Example</h5>\n<pre data-language=\"typescript\">import {jsxFactory} from \"jsxFactory\";\r\n\r\nvar div = &lt;div&gt;Hello JSX!&lt;/div&gt;\r\n</pre>\n<p>Compiled with:</p>\n<pre data-language=\"shell\">tsc --jsx react --reactNamespace jsxFactory --m commonJS\r\n</pre>\n<p>Results in:</p>\n<pre data-language=\"javascript\">\"use strict\";\r\nvar jsxFactory_1 = require(\"jsxFactory\");\r\nvar div = jsxFactory_1.jsxFactory.createElement(\"div\", null, \"Hello JSX!\");\r\n</pre>\n<h2 id=\"this-based-type-guards\">\n<code>this</code>-based type guards</h2>\n<p>TypeScript 1.8 extends <a href=\"#user-defined-type-guard-functions\">user-defined type guard functions</a> to class and interface methods.</p>\n<p><code>this is T</code> is now valid return type annotation for methods in classes and interfaces. When used in a type narowing position (e.g. <code>if</code> statement), the type of the call expression target object would be narrowed to <code>T</code>.</p>\n<h5 id=\"example-12\">Example</h5>\n<pre data-language=\"typescript\">class FileSystemObject {\r\n  isFile(): this is File { return this instanceof File; }\r\n  isDirectory(): this is Directory { return this instanceof Directory;}\r\n  isNetworked(): this is (Networked &amp; this) { return this.networked; }\r\n  constructor(public path: string, private networked: boolean) {}\r\n}\r\n\r\nclass File extends FileSystemObject {\r\n  constructor(path: string, public content: string) { super(path, false); }\r\n}\r\nclass Directory extends FileSystemObject {\r\n  children: FileSystemObject[];\r\n}\r\ninterface Networked {\r\n  host: string;\r\n}\r\n\r\nlet fso: FileSystemObject = new File(\"foo/bar.txt\", \"foo\");\r\nif (fso.isFile()) {\r\n  fso.content; // fso is File\r\n}\r\nelse if (fso.isDirectory()) {\r\n  fso.children; // fso is Directory\r\n}\r\nelse if (fso.isNetworked()) {\r\n  fso.host; // fso is networked\r\n}\r\n</pre>\n<h2 id=\"official-typescript-nuget-package\">Official TypeScript NuGet package</h2>\n<p>Starting with TypeScript 1.8, official NuGet packages are available for the Typescript Compiler (<code>tsc.exe</code>) as well as the MSBuild integration (<code>Microsoft.TypeScript.targets</code> and <code>Microsoft.TypeScript.Tasks.dll</code>).</p>\n<p>Stable packages are available here:</p>\n<ul>\n<li><a href=\"https://www.nuget.org/packages/Microsoft.TypeScript.Compiler/\">Microsoft.TypeScript.Compiler</a></li>\n<li><a href=\"https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild/\">Microsoft.TypeScript.MSBuild</a></li>\n</ul>\n<p>Also, a nightly NuGet package to match the <a href=\"http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx\">nightly npm package</a> is available on <a href=\"https://myget.org\">myget</a>:</p>\n<ul><li><a href=\"https://www.myget.org/gallery/typescript-preview\">TypeScript-Preview</a></li></ul>\n<h2 id=\"prettier-error-messages-from-tsc\">Prettier error messages from <code>tsc</code>\n</h2>\n<p>We understand that a ton of monochrome output can be a little difficult on the eyes. Colors can help discern where a message starts and ends, and these visual clues are important when error output gets overwhelming.</p>\n<p>By just passing the <code>--pretty</code> command line option, TypeScript gives more colorful output with context about where things are going wrong.</p>\n<p><img src=\"https://raw.githubusercontent.com/wiki/Microsoft/TypeScript/images/new-in-typescript/pretty01.png\" alt=\"Showing off pretty error messages in ConEmu\"></p>\n<h2 id=\"colorization-of-jsx-code-in-vs-2015\">Colorization of JSX code in VS 2015</h2>\n<p>With TypeScript 1.8, JSX tags are now classified and colorized in Visual Studio 2015.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/8052307/12271404/b875c502-b90f-11e5-93d8-c6740be354d1.png\" alt=\"jsx\"></p>\n<p>The classification can be further customized by changing the font and color settings for the <code>VB XML</code> color and font settings through <code>Tools</code>-&gt;<code>Options</code>-&gt;<code>Environment</code>-&gt;<code>Fonts and Colors</code> page.</p>\n<h2 id=\"the---project--p-flag-can-now-take-any-file-path\">The <code>--project</code> (<code>-p</code>) flag can now take any file path</h2>\n<p>The <code>--project</code> command line option originally could only take paths to a folder containing a <code>tsconfig.json</code>. Given the different scenarios for build configurations, it made sense to allow <code>--project</code> to point to any other compatible JSON file. For instance, a user might want to target ES2015 with CommonJS modules for Node 5, but ES5 with AMD modules for the browser. With this new work, users can easily manage two separate build targets using <code>tsc</code> alone without having to perform hacky workarounds like placing <code>tsconfig.json</code> files in separate directories.</p>\n<p>The old behavior still remains the same if given a directory - the compiler will try to find a file in the directory named <code>tsconfig.json</code>.</p>\n<h2 id=\"allow-comments-in-tsconfigjson\">Allow comments in tsconfig.json</h2>\n<p>It’s always nice to be able to document your configuration! <code>tsconfig.json</code> now accepts single and multi-line comments.</p>\n<pre data-language=\"typescript\">{\r\n  \"compilerOptions\": {\r\n    \"target\": \"ES2015\", // running on node v5, yaay!\r\n    \"sourceMap\": true   // makes debugging easier\r\n  },\r\n  /*\r\n   * Excluded files\r\n    */\r\n  \"exclude\": [\r\n    \"file.d.ts\"\r\n  ]\r\n}\r\n</pre>\n<h2 id=\"support-output-to-ipc-driven-files\">Support output to IPC-driven files</h2>\n<p>TypeScript 1.8 allows users to use the <code>--outFile</code> argument with special file system entities like named pipes, devices, etc.</p>\n<p>As an example, on many Unix-like systems, the standard output stream is accessible by the file <code>/dev/stdout</code>.</p>\n<pre data-language=\"shell\">tsc foo.ts --outFile /dev/stdout\r\n</pre>\n<p>This can be used to pipe output between commands as well.</p>\n<p>As an example, we can pipe our emitted JavaScript into a pretty printer like <a href=\"https://www.npmjs.com/package/pretty-js\">pretty-js</a>:</p>\n<pre data-language=\"shell\">tsc foo.ts --outFile /dev/stdout | pretty-js\r\n</pre>\n<h2 id=\"improved-support-for-tsconfigjson-in-visual-studio-2015\">Improved support for <code>tsconfig.json</code> in Visual Studio 2015</h2>\n<p>TypeScript 1.8 allows <code>tsconfig.json</code> files in all project types. This includes ASP.NET v4 projects, <em>Console Application</em>, and the <em>Html Application with TypeScript</em> project types. Further, you are no longer limited to a single <code>tsconfig.json</code> file but can add multiple, and each will be built as part of the project. This allows you to separate the configuration for different parts of your application without having to use multiple different projects.</p>\n<p><img src=\"https://raw.githubusercontent.com/wiki/Microsoft/TypeScript/images/new-in-typescript/tsconfig-in-vs.png\" alt=\"Showing off tsconfig.json in Visual Studio\"></p>\n<p>We also disable the project properties page when you add a <code>tsconfig.json</code> file. This means that all configuration changes have to be made in the <code>tsconfig.json</code> file itself.</p>\n<h3 id=\"a-couple-of-limitations\">A couple of limitations</h3>\n<ul>\n<li>If you add a <code>tsconfig.json</code> file, TypeScript files that are not considered part of that context are not compiled.</li>\n<li>Apache Cordova Apps still have the existing limitation of a single <code>tsconfig.json</code> file, which must be in either the root or the <code>scripts</code> folder.</li>\n<li>There is no template for <code>tsconfig.json</code> in most project types.</li>\n</ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/release-notes/typescript-1.8.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/release-notes/typescript-1.8.html</a>\n  </p>\n</div>\n","handbook/namespaces":"<h1 class=\"post-title\">Namespaces</h1>\n\n<blockquote><p><strong>A note about terminology:</strong> It’s important to note that in TypeScript 1.5, the nomenclature has changed. “Internal modules” are now “namespaces”. “External modules” are now simply “modules”, as to align with <a href=\"http://www.ecma-international.org/ecma-262/6.0/\">ECMAScript 2015</a>’s terminology, (namely that <code>module X {</code> is equivalent to the now-preferred <code>namespace X {</code>).</p></blockquote>\n<h2 id=\"introduction\">Introduction</h2>\n<p>This post outlines the various ways to organize your code using namespaces (previously “internal modules”) in TypeScript. As we alluded in our note about terminology, “internal modules” are now referred to as “namespaces”. Additionally, anywhere the <code>module</code> keyword was used when declaring an internal module, the <code>namespace</code> keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.</p>\n<h2 id=\"first-steps\">First steps</h2>\n<p>Let’s start with the program we’ll be using as our example throughout this page. We’ve written a small set of simplistic string validators, as you might write to check a user’s input on a form in a webpage or check the format of an externally-provided data file.</p>\n<h2 id=\"validators-in-a-single-file\">Validators in a single file</h2>\n<pre data-language=\"typescript\">interface StringValidator {\r\n  isAcceptable(s: string): boolean;\r\n}\r\n\r\nlet lettersRegexp = /^[A-Za-z]+$/;\r\nlet numberRegexp = /^[0-9]+$/;\r\n\r\nclass LettersOnlyValidator implements StringValidator {\r\n  isAcceptable(s: string) {\r\n    return lettersRegexp.test(s);\r\n  }\r\n}\r\n\r\nclass ZipCodeValidator implements StringValidator {\r\n  isAcceptable(s: string) {\r\n    return s.length === 5 &amp;&amp; numberRegexp.test(s);\r\n  }\r\n}\r\n\r\n// Some samples to try\r\nlet strings = [\"Hello\", \"98052\", \"101\"];\r\n\r\n// Validators to use\r\nlet validators: { [s: string]: StringValidator; } = {};\r\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\r\nvalidators[\"Letters only\"] = new LettersOnlyValidator();\r\n\r\n// Show whether each string passed each validator\r\nfor (let s of strings) {\r\n  for (let name in validators) {\r\n    let isMatch = validators[name].isAcceptable(s);\r\n    console.log(`'${ s }' ${ isMatch ? \"matches\" : \"does not match\" } '${ name }'.`);\r\n  }\r\n}\r\n</pre>\n<h2 id=\"namespacing\">Namespacing</h2>\n<p>As we add more validators, we’re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let’s wrap up our objects into a namespace.</p>\n<p>In this example, we’ll move all validator-related entities into a namespace called <code>Validation</code>. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with <code>export</code>. Conversely, the variables <code>lettersRegexp</code> and <code>numberRegexp</code> are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. <code>Validation.LettersOnlyValidator</code>.</p>\n<h2 id=\"namespaced-validators\">Namespaced Validators</h2>\n<pre data-language=\"typescript\">namespace Validation {\r\n  export interface StringValidator {\r\n    isAcceptable(s: string): boolean;\r\n  }\r\n\r\n  const lettersRegexp = /^[A-Za-z]+$/;\r\n  const numberRegexp = /^[0-9]+$/;\r\n\r\n  export class LettersOnlyValidator implements StringValidator {\r\n    isAcceptable(s: string) {\r\n      return lettersRegexp.test(s);\r\n    }\r\n  }\r\n\r\n  export class ZipCodeValidator implements StringValidator {\r\n    isAcceptable(s: string) {\r\n      return s.length === 5 &amp;&amp; numberRegexp.test(s);\r\n    }\r\n  }\r\n}\r\n\r\n// Some samples to try\r\nlet strings = [\"Hello\", \"98052\", \"101\"];\r\n\r\n// Validators to use\r\nlet validators: { [s: string]: Validation.StringValidator; } = {};\r\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\r\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\r\n\r\n// Show whether each string passed each validator\r\nfor (let s of strings) {\r\n  for (var name in validators) {\r\n    console.log(`\"${ s }\" - ${ validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" } ${ name }`);\r\n  }\r\n}\r\n</pre>\n<h2 id=\"splitting-across-files\">Splitting Across Files</h2>\n<p>As our application grows, we’ll want to split the code across multiple files to make it easier to maintain.</p>\n<h2 id=\"multi-file-namespaces\">Multi-file namespaces</h2>\n<p>Here, we’ll split our <code>Validation</code> namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we’ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.</p>\n<h5 id=\"validationts\">Validation.ts</h5>\n<pre data-language=\"typescript\">namespace Validation {\r\n  export interface StringValidator {\r\n    isAcceptable(s: string): boolean;\r\n  }\r\n}\r\n</pre>\n<h5 id=\"lettersonlyvalidatorts\">LettersOnlyValidator.ts</h5>\n<pre data-language=\"typescript\">/// &lt;reference path=\"Validation.ts\" /&gt;\r\nnamespace Validation {\r\n  const lettersRegexp = /^[A-Za-z]+$/;\r\n  export class LettersOnlyValidator implements StringValidator {\r\n    isAcceptable(s: string) {\r\n      return lettersRegexp.test(s);\r\n    }\r\n  }\r\n}\r\n</pre>\n<h5 id=\"zipcodevalidatorts\">ZipCodeValidator.ts</h5>\n<pre data-language=\"typescript\">/// &lt;reference path=\"Validation.ts\" /&gt;\r\nnamespace Validation {\r\n  const numberRegexp = /^[0-9]+$/;\r\n  export class ZipCodeValidator implements StringValidator {\r\n    isAcceptable(s: string) {\r\n      return s.length === 5 &amp;&amp; numberRegexp.test(s);\r\n    }\r\n  }\r\n}\r\n</pre>\n<h5 id=\"testts\">Test.ts</h5>\n<pre data-language=\"typescript\">/// &lt;reference path=\"Validation.ts\" /&gt;\r\n/// &lt;reference path=\"LettersOnlyValidator.ts\" /&gt;\r\n/// &lt;reference path=\"ZipCodeValidator.ts\" /&gt;\r\n\r\n// Some samples to try\r\nlet strings = [\"Hello\", \"98052\", \"101\"];\r\n\r\n// Validators to use\r\nlet validators: { [s: string]: Validation.StringValidator; } = {};\r\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\r\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\r\n\r\n// Show whether each string passed each validator\r\nfor (let s of strings) {\r\n  for (let name in validators) {\r\n    console.log(\"\"\" + s + \"\" \" + (validators[name].isAcceptable(s) ? \" matches \" : \" does not match \") + name);\r\n  }\r\n}\r\n</pre>\n<p>Once there are multiple files involved, we’ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.</p>\n<p>First, we can use concatenated output using the <code>--outFile</code> flag to compile all of the input files into a single JavaScript output file:</p>\n<pre data-language=\"Shell\">tsc --outFile sample.js Test.ts\r\n</pre>\n<p>The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:</p>\n<pre data-language=\"Shell\">tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts\r\n</pre>\n<p>Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we’ll need to use <code>&lt;script&gt;</code> tags on our webpage to load each emitted file in the appropriate order, for example:</p>\n<h5 id=\"mytestpagehtml-excerpt\">MyTestPage.html (excerpt)</h5>\n<pre data-language=\"typescript\">  &lt;script src=\"Validation.js\" type=\"text/javascript\" /&gt;\r\n  &lt;script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" /&gt;\r\n  &lt;script src=\"ZipCodeValidator.js\" type=\"text/javascript\" /&gt;\r\n  &lt;script src=\"Test.js\" type=\"text/javascript\" /&gt;\r\n</pre>\n<h2 id=\"aliases\">Aliases</h2>\n<p>Another way that you can simplify working with of namespaces is to use <code>import q = x.y.z</code> to create shorter names for commonly-used objects. Not to be confused with the <code>import x = require(\"name\")</code> syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.</p>\n<pre data-language=\"typescript\">namespace Shapes {\r\n  export namespace Polygons {\r\n    export class Triangle { }\r\n    export class Square { }\r\n  }\r\n}\r\n\r\nimport polygons = Shapes.Polygons;\r\nlet sq = new polygons.Square(); // Same as \"new Shapes.Polygons.Square()\"\r\n</pre>\n<p>Notice that we don’t use the <code>require</code> keyword; instead we assign directly from the qualified name of the symbol we’re importing. This is similar to using <code>var</code>, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, <code>import</code> is a distinct reference from the original symbol, so changes to an aliased <code>var</code> will not be reflected in the original variable.</p>\n<h2 id=\"working-with-other-javascript-libraries\">Working with Other JavaScript Libraries</h2>\n<p>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.</p>\n<p>We call declarations that don’t define an implementation “ambient”. Typically these are defined in <code>.d.ts</code> files. If you’re familiar with C/C++, you can think of these as <code>.h</code> files. Let’s look at a few examples.</p>\n<h2 id=\"ambient-namespaces\">Ambient Namespaces</h2>\n<p>The popular library D3 defines its functionality in a global object called <code>d3</code>. Because this library is loaded through a <code>&lt;script&gt;</code> tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:</p>\n<h5 id=\"d3dts-simplified-excerpt\">D3.d.ts (simplified excerpt)</h5>\n<pre data-language=\"typescript\">declare namespace D3 {\r\n  export interface Selectors {\r\n    select: {\r\n      (selector: string): Selection;\r\n      (element: EventTarget): Selection;\r\n    };\r\n  }\r\n\r\n  export interface Event {\r\n    x: number;\r\n    y: number;\r\n  }\r\n\r\n  export interface Base extends Selectors {\r\n    event: Event;\r\n  }\r\n}\r\n\r\ndeclare var d3: D3.Base;\r\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/namespaces.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/namespaces.html</a>\n  </p>\n</div>\n","release-notes/typescript-1.3":"<h1 class=\"post-title\">TypeScript 1.3</h1>\n\n<h2 id=\"protected\">Protected</h2>\n<p>The new <code>protected</code> modifier in classes works like it does in familiar languages like C++, C#, and Java. A <code>protected</code> member of a class is visible only inside subclasses of the class in which it is declared:</p>\n<pre data-language=\"typescript\">class Thing {\r\n  protected doSomething() { /* ... */ }\r\n}\r\n\r\nclass MyThing extends Thing {\r\n  public myMethod() {\r\n  // OK, can access protected member from subclass\r\n  this.doSomething();\r\n  }\r\n}\r\nvar t = new MyThing();\r\nt.doSomething(); // Error, cannot call protected member from outside class\r\n</pre>\n<h2 id=\"tuple-types\">Tuple types</h2>\n<p>Tuple types express an array where the type of certain elements is known, but need not be the same. For example, you may want to represent an array with a <code>string</code> at position 0 and a <code>number</code> at position 1:</p>\n<pre data-language=\"typescript\">// Declare a tuple type\r\nvar x: [string, number];\r\n// Initialize it\r\nx = ['hello', 10]; // OK\r\n// Initialize it incorrectly\r\nx = [10, 'hello']; // Error\r\n</pre>\n<p>When accessing an element with a known index, the correct type is retrieved:</p>\n<pre data-language=\"typescript\">console.log(x[0].substr(1)); // OK\r\nconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr'\r\n</pre>\n<p>Note that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:</p>\n<pre data-language=\"typescript\">x[3] = 'world'; // OK\r\nconsole.log(x[5].toString()); // OK, 'string' and 'number' both have toString\r\nx[6] = true; // Error, boolean isn't number or string\r\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/release-notes/typescript-1.3.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/release-notes/typescript-1.3.html</a>\n  </p>\n</div>\n","release-notes/typescript-1.4":"<h1 class=\"post-title\">TypeScript 1.4</h1>\n\n<h2 id=\"union-types\">Union types</h2>\n<h3 id=\"overview\">Overview</h3>\n<p>Union types are a powerful way to express a value that can be one of several types. For example, you might have an API for running a program that takes a commandline as either a <code>string</code>, a <code>string[]</code> or a function that returns a <code>string</code>. You can now write:</p>\n<pre data-language=\"typescript\">interface RunOptions {\r\n   program: string;\r\n   commandline: string[]|string|(() =&gt; string);\r\n}\r\n</pre>\n<p>Assignment to union types works very intuitively – anything you could assign to one of the union type’s members is assignable to the union:</p>\n<pre data-language=\"typescript\">var opts: RunOptions = /* ... */;\r\nopts.commandline = '-hello world'; // OK\r\nopts.commandline = ['-hello', 'world']; // OK\r\nopts.commandline = [42]; // Error, number is not string or string[]\r\n</pre>\n<p>When reading from a union type, you can see any properties that are shared by them:</p>\n<pre data-language=\"typescript\">if (opts.length === 0) { // OK, string and string[] both have 'length' property\r\n  console.log(\"it's empty\");\r\n}\r\n</pre>\n<p>Using Type Guards, you can easily work with a variable of a union type:</p>\n<pre data-language=\"typescript\">function formatCommandline(c: string|string[]) {\r\n  if (typeof c === 'string') {\r\n    return c.trim();\r\n  }\r\n  else {\r\n    return c.join(' ');\r\n  }\r\n}\r\n</pre>\n<h3 id=\"stricter-generics\">Stricter Generics</h3>\n<p>With union types able to represent a wide range of type scenarios, we’ve decided to improve the strictness of certain generic calls. Previously, code like this would (surprisingly) compile without error:</p>\n<pre data-language=\"typescript\">function equal&lt;T&gt;(lhs: T, rhs: T): boolean {\r\n  return lhs === rhs;\r\n}\r\n\r\n// Previously: No error\r\n// New behavior: Error, no best common type between 'string' and 'number'\r\nvar e = equal(42, 'hello');\r\n</pre>\n<p>With union types, you can now specify the desired behavior at both the function declaration site and the call site:</p>\n<pre data-language=\"typescript\">// 'choose' function where types must match\r\nfunction choose1&lt;T&gt;(a: T, b: T): T { return Math.random() &gt; 0.5 ? a : b }\r\nvar a = choose1('hello', 42); // Error\r\nvar b = choose1&lt;string|number&gt;('hello', 42); // OK\r\n\r\n// 'choose' function where types need not match\r\nfunction choose2&lt;T, U&gt;(a: T, b: U): T|U { return Math.random() &gt; 0.5 ? a : b }\r\nvar c = choose2('bar', 'foo'); // OK, c: string\r\nvar d = choose2('hello', 42); // OK, d: string|number\r\n</pre>\n<h3 id=\"better-type-inference\">Better Type Inference</h3>\n<p>Union types also allow for better type inference in arrays and other places where you might have multiple kinds of values in a collection:</p>\n<pre data-language=\"typescript\">var x = [1, 'hello']; // x: Array&lt;string|number&gt;\r\nx[0] = 'world'; // OK\r\nx[0] = false; // Error, boolean is not string or number\r\n</pre>\n<h2 id=\"let-declarations\">\n<code>let</code> declarations</h2>\n<p>In JavaScript, <code>var</code> declarations are “hoisted” to the top of their enclosing scope. This can result in confusing bugs:</p>\n<pre data-language=\"typescript\">console.log(x); // meant to write 'y' here\r\n/* later in the same block */\r\nvar x = 'hello';\r\n</pre>\n<p>The new ES6 keyword <code>let</code>, now supported in TypeScript, declares a variable with more intuitive “block” semantics. A <code>let</code> variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:</p>\n<pre data-language=\"typescript\">if (foo) {\r\n  console.log(x); // Error, cannot refer to x before its declaration\r\n  let x = 'hello';\r\n}\r\nelse {\r\n  console.log(x); // Error, x is not declared in this block\r\n}\r\n</pre>\n<p><code>let</code> is only available when targeting ECMAScript 6 (<code>--target ES6</code>).</p>\n<h2 id=\"const-declarations\">\n<code>const</code> declarations</h2>\n<p>The other new ES6 declaration type supported in TypeScript is <code>const</code>. A <code>const</code> variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don’t want to change the value after its initialization:</p>\n<pre data-language=\"typescript\">const halfPi = Math.PI / 2;\r\nhalfPi = 2; // Error, can't assign to a `const`\r\n</pre>\n<p><code>const</code> is only available when targeting ECMAScript 6 (<code>--target ES6</code>).</p>\n<h2 id=\"template-strings\">Template strings</h2>\n<p>TypeScript now supports ES6 template strings. These are an easy way to embed arbitrary expressions in strings:</p>\n<pre data-language=\"typescript\">var name = \"TypeScript\";\r\nvar greeting  = `Hello, ${name}! Your name has ${name.length} characters`;\r\n</pre>\n<p>When compiling to pre-ES6 targets, the string is decomposed:</p>\n<pre data-language=\"javascript\">var name = \"TypeScript!\";\r\nvar greeting = \"Hello, \" + name + \"! Your name has \" + name.length + \" characters\";\r\n</pre>\n<h2 id=\"type-guards\">Type Guards</h2>\n<p>A common pattern in JavaScript is to use <code>typeof</code> or <code>instanceof</code> to examine the type of an expression at runtime. TypeScript now understands these conditions and will change type inference accordingly when used in an <code>if</code> block.</p>\n<p>Using <code>typeof</code> to test a variable:</p>\n<pre data-language=\"typescript\">var x: any = /* ... */;\r\nif(typeof x === 'string') {\r\n  console.log(x.subtr(1)); // Error, 'subtr' does not exist on 'string'\r\n}\r\n// x is still any here\r\nx.unknown(); // OK\r\n</pre>\n<p>Using <code>typeof</code> with union types and <code>else</code>:</p>\n<pre data-language=\"typescript\">var x: string | HTMLElement = /* ... */;\r\nif(typeof x === 'string') {\r\n  // x is string here, as shown above\r\n}\r\nelse {\r\n  // x is HTMLElement here\r\n  console.log(x.innerHTML);\r\n}\r\n</pre>\n<p>Using <code>instanceof</code> with classes and union types:</p>\n<pre data-language=\"typescript\">class Dog { woof() { } }\r\nclass Cat { meow() { } }\r\nvar pet: Dog|Cat = /* ... */;\r\nif (pet instanceof Dog) {\r\n  pet.woof(); // OK\r\n}\r\nelse {\r\n  pet.woof(); // Error\r\n}\r\n</pre>\n<h2 id=\"type-aliases\">Type Aliases</h2>\n<p>You can now define an <em>alias</em> for a type using the <code>type</code> keyword:</p>\n<pre data-language=\"typescript\">type PrimitiveArray = Array&lt;string|number|boolean&gt;;\r\ntype MyNumber = number;\r\ntype NgScope = ng.IScope;\r\ntype Callback = () =&gt; void;\r\n</pre>\n<p>Type aliases are exactly the same as their original types; they are simply alternative names.</p>\n<h2 id=\"const-enum-completely-inlined-enums\">\n<code>const enum</code> (completely inlined enums)</h2>\n<p>Enums are very useful, but some programs don’t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new <code>const enum</code> declaration works just like a regular <code>enum</code> for type safety, but erases completely at compile time.</p>\n<pre data-language=\"typescript\">const enum Suit { Clubs, Diamonds, Hearts, Spades }\r\nvar d = Suit.Diamonds;\r\n</pre>\n<p>Compiles to exactly:</p>\n<pre data-language=\"javascript\">var d = 1;\r\n</pre>\n<p>TypeScript will also now compute enum values when possible:</p>\n<pre data-language=\"typescript\">enum MyFlags {\r\n  None = 0,\r\n  Neat = 1,\r\n  Cool = 2,\r\n  Awesome = 4,\r\n  Best = Neat | Cool | Awesome\r\n}\r\nvar b = MyFlags.Best; // emits var b = 7;\r\n</pre>\n<h2 id=\"noemitonerror-commandline-option\">\n<code>-noEmitOnError</code> commandline option</h2>\n<p>The default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a <code>string</code> to a <code>number</code>). This can be undesirable on build servers or other scenarios where only output from a “clean” build is desired. The new flag <code>noEmitOnError</code> prevents the compiler from emitting .js code if there were any errors.</p>\n<p>This is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.</p>\n<h2 id=\"amd-module-names\">AMD Module names</h2>\n<p>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules like a bundlers (e.g. <code>r.js</code>).</p>\n<p>The new <code>amd-module name</code> tag allows passing an optional module name to the compiler:</p>\n<pre data-language=\"typescript\">//// [amdModule.ts]\r\n///&lt;amd-module name='NamedModule'/&gt;\r\nexport class C {\r\n}\r\n</pre>\n<p>Will result in assigning the name <code>NamedModule</code> to the module as part of calling the AMD <code>define</code>:</p>\n<pre data-language=\"javascript\">//// [amdModule.js]\r\ndefine(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) {\r\n  var C = (function () {\r\n    function C() {\r\n    }\r\n    return C;\r\n  })();\r\n  exports.C = C;\r\n});\r\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/release-notes/typescript-1.4.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/release-notes/typescript-1.4.html</a>\n  </p>\n</div>\n","release-notes/typescript-1.1":"<h1 class=\"post-title\">TypeScript 1.1</h1>\n\n<h2 id=\"performance-improvements\">Performance Improvements</h2>\n<p>The 1.1 compiler is typically around 4x faster than any previous release. See <a href=\"http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx\">this blog post for some impressive charts.</a></p>\n<h2 id=\"better-module-visibility-rules\">Better Module Visibility Rules</h2>\n<p>TypeScript now only strictly enforces the visibility of types in modules if the <code>--declaration</code> flag is provided. This is very useful for Angular scenarios, for example:</p>\n<pre data-language=\"typescript\">module MyControllers {\r\n  interface ZooScope extends ng.IScope {\r\n  animals: Animal[];\r\n  }\r\n  export class ZooController {\r\n  // Used to be an error (cannot expose ZooScope), but now is only\r\n  // an error when trying to generate .d.ts files\r\n  constructor(public $scope: ZooScope) { }\r\n  /* more code */\r\n  }\r\n}\r\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/release-notes/typescript-1.1.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/release-notes/typescript-1.1.html</a>\n  </p>\n</div>\n","release-notes/typescript-1.6":"<h1 class=\"post-title\">TypeScript 1.6</h1>\n\n<h2 id=\"jsx-support\">JSX support</h2>\n<p>JSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.</p>\n<h4 id=\"new-tsx-file-extension-and-as-operator\">New <code>.tsx</code> file extension and <code>as</code> operator</h4>\n<p>TypeScript 1.6 introduces a new <code>.tsx</code> file extension. This extension does two things: it enables JSX inside of TypeScript files, and it makes the new <code>as</code> operator the default way to cast (removing any ambiguity between JSX expressions and the TypeScript prefix cast operator). For example:</p>\n<pre data-language=\"typescript\">var x = &lt;any&gt; foo;\r\n// is equivalent to:\r\nvar x = foo as any;\r\n</pre>\n<h4 id=\"using-react\">Using React</h4>\n<p>To use JSX-support with React you should use the <a href=\"https://github.com/borisyankov/DefinitelyTyped/tree/master/react\">React typings</a>. These typings define the <code>JSX</code> namespace so that TypeScript can correctly check JSX expressions for React. For example:</p>\n<pre data-language=\"typescript\">/// &lt;reference path=\"react.d.ts\" /&gt;\r\n\r\ninterface Props {\r\n  name: string;\r\n}\r\n\r\nclass MyComponent extends React.Component&lt;Props, {}&gt; {\r\n  render() {\r\n  return &lt;span&gt;{this.props.foo}&lt;/span&gt;\r\n  }\r\n}\r\n\r\n&lt;MyComponent name=\"bar\" /&gt;; // OK\r\n&lt;MyComponent name={0} /&gt;; // error, `name` is not a number\r\n</pre>\n<h4 id=\"using-other-jsx-framworks\">Using other JSX framworks</h4>\n<p>JSX element names and properties are validated against the <code>JSX</code> namespace. Please see the [[JSX]] wiki page for defining the <code>JSX</code> namespace for your framework.</p>\n<h4 id=\"output-generation\">Output generation</h4>\n<p>TypeScript ships with two JSX modes: <code>preserve</code> and <code>react</code>.</p>\n<ul>\n<li>The <code>preserve</code> mode will keep JSX expressions as part of the output to be further consumed by another transform step. <em>Additionally the output will have a <code>.jsx</code> file extension.</em>\n</li>\n<li>The <code>react</code> mode will emit <code>React.createElement</code>, does not need to go through a JSX transformation before use, and the output will have a <code>.js</code> file extension.</li>\n</ul>\n<p>See the [[JSX]] wiki page for more information on using JSX in TypeScript.</p>\n<h2 id=\"intersection-types\">Intersection types</h2>\n<p>TypeScript 1.6 introduces intersection types, the logical complement of union types. A union type <code>A | B</code> represents an entity that is either of type <code>A</code> or type <code>B</code>, whereas an intersection type <code>A &amp; B</code> represents an entity that is both of type <code>A</code> <em>and</em> type <code>B</code>.</p>\n<h5 id=\"example\">Example</h5>\n<pre data-language=\"typescript\">function extend&lt;T, U&gt;(first: T, second: U): T &amp; U {\r\n  let result = &lt;T &amp; U&gt; {};\r\n  for (let id in first) {\r\n    result[id] = first[id];\r\n  }\r\n  for (let id in second) {\r\n    if (!result.hasOwnProperty(id)) {\r\n      result[id] = second[id];\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nvar x = extend({ a: \"hello\" }, { b: 42 });\r\nvar s = x.a;\r\nvar n = x.b;\r\n</pre>\n<pre data-language=\"typescript\">type LinkedList&lt;T&gt; = T &amp; { next: LinkedList&lt;T&gt; };\r\n\r\ninterface Person {\r\n  name: string;\r\n}\r\n\r\nvar people: LinkedList&lt;Person&gt;;\r\nvar s = people.name;\r\nvar s = people.next.name;\r\nvar s = people.next.next.name;\r\nvar s = people.next.next.next.name;\r\n</pre>\n<pre data-language=\"typescript\">interface A { a: string }\r\ninterface B { b: string }\r\ninterface C { c: string }\r\n\r\nvar abc: A &amp; B &amp; C;\r\nabc.a = \"hello\";\r\nabc.b = \"hello\";\r\nabc.c = \"hello\";\r\n</pre>\n<p>See <a href=\"https://github.com/Microsoft/TypeScript/issues/1256\">issue #1256</a> for more information.</p>\n<h2 id=\"local-type-declarations\">Local type declarations</h2>\n<p>Local class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with <code>let</code> and <code>const</code>. For example:</p>\n<pre data-language=\"typescript\">function f() {\r\n  if (true) {\r\n    interface T { x: number }\r\n    let v: T;\r\n    v.x = 5;\r\n  }\r\n  else {\r\n    interface T { x: string }\r\n    let v: T;\r\n    v.x = \"hello\";\r\n  }\r\n}\r\n</pre>\n<p>The inferred return type of a function may be a type declared locally within the function. It is not possible for callers of the function to reference such a local type, but it can of course be matched structurally. For example:</p>\n<pre data-language=\"typescript\">interface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nfunction getPointFactory(x: number, y: number) {\r\n  class P {\r\n    x = x;\r\n    y = y;\r\n  }\r\n  return P;\r\n}\r\n\r\nvar PointZero = getPointFactory(0, 0);\r\nvar PointOne = getPointFactory(1, 1);\r\nvar p1 = new PointZero();\r\nvar p2 = new PointZero();\r\nvar p3 = new PointOne();\r\n</pre>\n<p>Local types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:</p>\n<pre data-language=\"typescript\">function f3() {\r\n  function f&lt;X, Y&gt;(x: X, y: Y) {\r\n    class C {\r\n      public x = x;\r\n      public y = y;\r\n    }\r\n    return C;\r\n  }\r\n  let C = f(10, \"hello\");\r\n  let v = new C();\r\n  let x = v.x;  // number\r\n  let y = v.y;  // string\r\n}\r\n</pre>\n<h2 id=\"class-expressions\">Class expressions</h2>\n<p>TypeScript 1.6 adds support for ES6 class expressions. In a class expression, the class name is optional and, if specified, is only in scope in the class expression itself. This is similar to the optional name of a function expression. It is not possible to refer to the class instance type of a class expression outside the class expression, but the type can of course be matched structurally. For example:</p>\n<pre data-language=\"typescript\">let Point = class {\r\n  constructor(public x: number, public y: number) { }\r\n  public length() {\r\n    return Math.sqrt(this.x * this.x + this.y * this.y);\r\n  }\r\n};\r\nvar p = new Point(3, 4);  // p has anonymous class type\r\nconsole.log(p.length());\r\n</pre>\n<h2 id=\"extending-expressions\">Extending expressions</h2>\n<p>TypeScript 1.6 adds support for classes extending arbitrary expression that computes a constructor function. This means that built-in types can now be extended in class declarations.</p>\n<p>The <code>extends</code> clause of a class previously required a type reference to be specified. It now accepts an expression optionally followed by a type argument list. The type of the expression must be a constructor function type with at least one construct signature that has the same number of type parameters as the number of type arguments specified in the <code>extends</code> clause. The return type of the matching construct signature(s) is the base type from which the class instance type inherits. Effectively, this allows both real classes and “class-like” expressions to be specified in the <code>extends</code> clause.</p>\n<p>Some examples:</p>\n<pre data-language=\"typescript\">// Extend built-in types\r\n\r\nclass MyArray extends Array&lt;number&gt; { }\r\nclass MyError extends Error { }\r\n\r\n// Extend computed base class\r\n\r\nclass ThingA {\r\n  getGreeting() { return \"Hello from A\"; }\r\n}\r\n\r\nclass ThingB {\r\n  getGreeting() { return \"Hello from B\"; }\r\n}\r\n\r\ninterface Greeter {\r\n  getGreeting(): string;\r\n}\r\n\r\ninterface GreeterConstructor {\r\n  new (): Greeter;\r\n}\r\n\r\nfunction getGreeterBase(): GreeterConstructor {\r\n  return Math.random() &gt;= 0.5 ? ThingA : ThingB;\r\n}\r\n\r\nclass Test extends getGreeterBase() {\r\n  sayHello() {\r\n    console.log(this.getGreeting());\r\n  }\r\n}\r\n</pre>\n<h2 id=\"abstract-classes-and-methods\">\n<code>abstract</code> classes and methods</h2>\n<p>TypeScript 1.6 adds support for <code>abstract</code> keyword for classes and their methods. An abstract class is allowed to have methods with no implementation, and cannot be constructed.</p>\n<h5 id=\"examples\">Examples</h5>\n<pre data-language=\"typescript\">abstract class Base {\r\n  abstract getThing(): string;\r\n  getOtherThing() { return 'hello'; }\r\n}\r\n\r\nlet x = new Base(); // Error, 'Base' is abstract\r\n\r\n// Error, must either be 'abstract' or implement concrete 'getThing'\r\nclass Derived1 extends Base { }\r\n\r\nclass Derived2 extends Base {\r\n  getThing() { return 'hello'; }\r\n  foo() {\r\n    super.getThing();// Error: cannot invoke abstract members through 'super'\r\n  }\r\n}\r\n\r\nvar x = new Derived2(); // OK\r\nvar y: Base = new Derived2(); // Also OK\r\ny.getThing(); // OK\r\ny.getOtherThing(); // OK\r\n</pre>\n<h2 id=\"generic-type-aliases\">Generic type aliases</h2>\n<p>With TypeScript 1.6, type aliases can be generic. For example:</p>\n<pre data-language=\"typescript\">type Lazy&lt;T&gt; = T | (() =&gt; T);\r\n\r\nvar s: Lazy&lt;string&gt;;\r\ns = \"eager\";\r\ns = () =&gt; \"lazy\";\r\n\r\ninterface Tuple&lt;A, B&gt; {\r\n  a: A;\r\n  b: B;\r\n}\r\n\r\ntype Pair&lt;T&gt; = Tuple&lt;T, T&gt;;\r\n</pre>\n<h2 id=\"stricter-object-literal-assignment-checks\">Stricter object literal assignment checks</h2>\n<p>TypeScript 1.6 enforces stricter object literal assignment checks for the purpose of catching excess or misspelled properties. Specifically, when a fresh object literal is assigned to a variable or passed as an argument for a non-empty target type, it is an error for the object literal to specify properties that don’t exist in the target type.</p>\n<h5 id=\"examples-1\">Examples</h5>\n<pre data-language=\"typescript\">var x: { foo: number };\r\nx = { foo: 1, baz: 2 };  // Error, excess property `baz`\r\n\r\nvar y: { foo: number, bar?: number };\r\ny = { foo: 1, baz: 2 };  // Error, excess or misspelled property `baz`\r\n</pre>\n<p>A type can include an index signature to explicitly indicate that excess properties are permitted:</p>\n<pre data-language=\"typescript\">var x: { foo: number, [x: string]: any };\r\nx = { foo: 1, baz: 2 };  // Ok, `baz` matched by index signature\r\n</pre>\n<h2 id=\"es6-generators\">ES6 generators</h2>\n<p>TypeScript 1.6 adds support for generators when targeting ES6.</p>\n<p>A generator function can have a return type annotation, just like a function. The annotation represents the type of the generator returned by the function. Here is an example:</p>\n<pre data-language=\"typescript\">function *g(): Iterable&lt;string&gt; {\r\n  for (var i = 0; i &lt; 100; i++) {\r\n    yield \"\"; // string is assignable to string\r\n  }\r\n  yield * otherStringGenerator(); // otherStringGenerator must be iterable and element type assignable to string\r\n}\r\n</pre>\n<p>A generator function with no type annotation can have the type annotation inferred. So in the following case, the type will be inferred from the yield statements:</p>\n<pre data-language=\"typescript\">function *g() {\r\n  for (var i = 0; i &lt; 100; i++) {\r\n    yield \"\"; // infer string\r\n  }\r\n  yield * otherStringGenerator(); // infer element type of otherStringGenerator\r\n}\r\n</pre>\n<h2 id=\"experimental-support-for-async-functions\">Experimental support for <code>async</code> functions</h2>\n<p>TypeScript 1.6 introduces experimental support of <code>async</code> functions when targeting ES6. Async functions are expected to invoke an asynchronous operation and await its result without blocking normal execution of the program. This accomplished through the use of an ES6-compatible <code>Promise</code> implementation, and transposition of the function body into a compatible form to resume execution when the awaited asynchronous operation completes.</p>\n<p>An <em>async function</em> is a function or method that has been prefixed with the <code>async</code> modifier. This modifier informs the compiler that function body transposition is required, and that the keyword <code>await</code> should be treated as a unary expression instead of an identifier. An <em>Async Function</em> must provide a return type annotation that points to a compatible <code>Promise</code> type. Return type inference can only be used if there is a globally defined, compatible <code>Promise</code> type.</p>\n<h5 id=\"example-1\">Example</h5>\n<pre data-language=\"typescript\">var p: Promise&lt;number&gt; = /* ... */;\r\nasync function fn(): Promise&lt;number&gt; {\r\n  var i = await p; // suspend execution until 'p' is settled. 'i' has type \"number\"\r\n  return 1 + i;\r\n}\r\n\r\nvar a = async (): Promise&lt;number&gt; =&gt; 1 + await p; // suspends execution.\r\nvar a = async () =&gt; 1 + await p; // suspends execution. return type is inferred as \"Promise&lt;number&gt;\" when compiling with --target ES6\r\nvar fe = async function(): Promise&lt;number&gt; {\r\n  var i = await p; // suspend execution until 'p' is settled. 'i' has type \"number\"\r\n  return 1 + i;\r\n}\r\n\r\nclass C {\r\n  async m(): Promise&lt;number&gt; {\r\n  var i = await p; // suspend execution until 'p' is settled. 'i' has type \"number\"\r\n  return 1 + i;\r\n  }\r\n\r\n  async get p(): Promise&lt;number&gt; {\r\n  var i = await p; // suspend execution until 'p' is settled. 'i' has type \"number\"\r\n  return 1 + i;\r\n  }\r\n}\r\n</pre>\n<h2 id=\"nightly-builds\">Nightly builds</h2>\n<p>While not strictly a language change, nightly builds are now available by installing with the following command:</p>\n<pre data-language=\"Shell\">npm install -g typescript@next\r\n</pre>\n<h2 id=\"adjustments-in-module-resolution-logic\">Adjustments in module resolution logic</h2>\n<p>Starting from release 1.6 TypeScript compiler will use different set of rules to resolve module names when targeting ‘commonjs’. These <a href=\"https://github.com/Microsoft/TypeScript/issues/2338\">rules</a> attempted to model module lookup procedure used by Node. This effectively mean that node modules can include information about its typings and TypeScript compiler will be able to find it. User however can override module resolution rules picked by the compiler by using <code>--moduleResolution</code> command line option. Possible values are:</p>\n<ul>\n<li>‘classic’ - module resolution rules used by pre 1.6 TypeScript compiler</li>\n<li>‘node’ - node-like module resolution</li>\n</ul>\n<h2 id=\"merging-ambient-class-and-interface-declaration\">Merging ambient class and interface declaration</h2>\n<p>The instance side of an ambient class declaration can be extended using an interface declaration The class constructor object is unmodified. For example:</p>\n<pre data-language=\"typescript\">declare class Foo {\r\n  public x : number;\r\n}\r\n\r\ninterface Foo {\r\n  y : string;\r\n}\r\n\r\nfunction bar(foo : Foo)  {\r\n  foo.x = 1; // OK, declared in the class Foo\r\n  foo.y = \"1\"; // OK, declared in the interface Foo\r\n}\r\n</pre>\n<h2 id=\"user-defined-type-guard-functions\">User-defined type guard functions</h2>\n<p>TypeScript 1.6 adds a new way to narrow a variable type inside an <code>if</code> block, in addition to <code>typeof</code> and <code>instanceof</code>. A user-defined type guard functions is one with a return type annotation of the form <code>x is T</code>, where <code>x</code> is a declared parameter in the signature, and <code>T</code> is any type. When a user-defined type guard function is invoked on a variable in an <code>if</code> block, the type of the variable will be narrowed to <code>T</code>.</p>\n<h5 id=\"examples-2\">Examples</h5>\n<pre data-language=\"typescript\">function isCat(a: any): a is Cat {\r\n  return a.name === 'kitty';\r\n}\r\n\r\nvar x: Cat | Dog;\r\nif(isCat(x)) {\r\n  x.meow(); // OK, x is Cat in this block\r\n}\r\n</pre>\n<h2 id=\"exclude-property-support-in-tsconfigjson\">\n<code>exclude</code> property support in tsconfig.json</h2>\n<p>A tsconfig.json file that doesn’t specify a files property (and therefore implicitly references all *.ts files in all subdirectories) can now contain an exclude property that specifies a list of files and/or directories to exclude from the compilation. The exclude property must be an array of strings that each specify a file or folder name relative to the location of the tsconfig.json file. For example:</p>\n<pre data-language=\"javascripton\">{\r\n  \"compilerOptions\": {\r\n    \"out\": \"test.js\"\r\n  },\r\n  \"exclude\": [\r\n    \"node_modules\",\r\n    \"test.ts\",\r\n    \"utils/t2.ts\"\r\n  ]\r\n}\r\n</pre>\n<p>The <code>exclude</code> list does not support wilcards. It must simply be a list of files and/or directories.</p>\n<h2 id=\"init-command-line-option\">\n<code>--init</code> command line option</h2>\n<p>Run <code>tsc --init</code> in a directory to create an initial <code>tsconfig.json</code> in this directory with preset defaults. Optionally pass command line arguments along with <code>--init</code> to be stored in your initial tsconfig.json on creation.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/release-notes/typescript-1.6.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/release-notes/typescript-1.6.html</a>\n  </p>\n</div>\n","handbook/variable-declarations":"<h1 class=\"post-title\">Variable Declarations</h1>\n\n<h2 id=\"variable-declarations\">Variable Declarations</h2>\n<p><code>let</code> and <code>const</code> are two relatively new types of variable declarations in JavaScript. As we mentioned earlier, <code>let</code> is similar to <code>var</code> in some respects, but allows users to avoid some of the common “gotchas” that users run into in JavaScript. <code>const</code> is an augmentation of <code>let</code> in that it prevents re-assignment to a variable.</p>\n<p>With TypeScript being a superset of JavaScript, the language naturally supports <code>let</code> and <code>const</code>. Here we’ll elaborate more on these new declarations and why they’re preferable to <code>var</code>.</p>\n<p>If you’ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you’re intimately familiar with all the quirks of <code>var</code> declarations in JavaScript, you might find it easier to skip ahead.</p>\n<h2 id=\"var-declarations\">\n<code>var</code> declarations</h2>\n<p>Declaring a variable in JavaScript has always traditionally been done with the <code>var</code> keyword.</p>\n<pre data-language=\"typescript\">var a = 10;\r\n</pre>\n<p>As you might’ve figured out, we just declared a variable named <code>a</code> with the value <code>10</code>.</p>\n<p>We can also declare a variable inside of a function:</p>\n<pre data-language=\"typescript\">function f() {\r\n  var message = \"Hello, world!\";\r\n\r\n  return message;\r\n}\r\n</pre>\n<p>and we can also access those same variables within other functions:</p>\n<pre data-language=\"typescript\">function f() {\r\n  var a = 10;\r\n  return function g() {\r\n    var b = a + 1;\r\n    return b;\r\n  }\r\n}\r\n\r\nvar g = f();\r\ng(); // returns 11;\r\n</pre>\n<p>In this above example, <code>g</code> captured the variable <code>a</code> declared in <code>f</code>. At any point that <code>g</code> gets called, the value of <code>a</code> will be tied to the value of <code>a</code> in <code>f</code>. Even if <code>g</code> is called once <code>f</code> is done running, it will be able to access and modify <code>a</code>.</p>\n<pre data-language=\"typescript\">function f() {\r\n  var a = 1;\r\n\r\n  a = 2;\r\n  var b = g();\r\n  a = 3;\r\n\r\n  return b;\r\n\r\n  function g() {\r\n    return a;\r\n  }\r\n}\r\n\r\nf(); // returns 2\r\n</pre>\n<h2 id=\"scoping-rules\">Scoping rules</h2>\n<p><code>var</code> declarations have some odd scoping rules for those used to other languages. Take the following example:</p>\n<pre data-language=\"typescript\">function f(shouldInitialize: boolean) {\r\n  if (shouldInitialize) {\r\n    var x = 10;\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\nf(true);  // returns '10'\r\nf(false); // returns 'undefined'\r\n</pre>\n<p>Some readers might do a double-take at this example. The variable <code>x</code> was declared <em>within the <code>if</code> block</em>, and yet we were able to access it from outside that block. That’s because <code>var</code> declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we’ll go over later on - regardless of the containing block. Some people call this <em><code>var</code>-scoping</em> or <em>function-scoping</em>. Parameters are also function scoped.</p>\n<p>These scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:</p>\n<pre data-language=\"typescript\">function sumMatrix(matrix: number[][]) {\r\n  var sum = 0;\r\n  for (var i = 0; i &lt; matrix.length; i++) {\r\n    var currentRow = matrix[i];\r\n    for (var i = 0; i &lt; currentRow.length; i++) {\r\n      sum += currentRow[i];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n</pre>\n<p>Maybe it was easy to spot out for some, but the inner <code>for</code>-loop will accidentally overwrite the variable <code>i</code> because <code>i</code> refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</p>\n<h2 id=\"variable-capturing-quirks\">Variable capturing quirks</h2>\n<p>Take a quick second to guess what the output of the following snippet is:</p>\n<pre data-language=\"typescript\">for (var i = 0; i &lt; 10; i++) {\r\n  setTimeout(function() {console.log(i); }, 100 * i);\r\n}\r\n</pre>\n<p>For those unfamiliar, <code>setTimeout</code> will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).</p>\n<p>Ready? Take a look:</p>\n<pre data-language=\"text\">10\r\n10\r\n10\r\n10\r\n10\r\n10\r\n10\r\n10\r\n10\r\n10\r\n</pre>\n<p>Many JavaScript developers are intimately familiar with this behavior, but if you’re surprised, you’re certainly not alone. Most people expect the output to be</p>\n<pre data-language=\"text\">0\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n</pre>\n<p>Remember what we mentioned earlier about variable capturing?</p>\n<blockquote><p>At any point that <code>g</code> gets called, the value of <code>a</code> will be tied to the value of <code>a</code> in <code>f</code>.</p></blockquote>\n<p>Let’s take a minute to consider that in this context. <code>setTimeout</code> will run a function after some number of milliseconds, and also after the <code>for</code> loop has stopped executing. By the time the <code>for</code> loop has stopped executing, the value of <code>i</code> is <code>10</code>. So each time the given function gets called, it will print out <code>10</code>!</p>\n<p>A common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture <code>i</code> at each iteration:</p>\n<pre data-language=\"typescript\">for (var i = 0; i &lt; 10; i++) {\r\n  // capture the current state of 'i'\r\n  // by invoking a function with its current value\r\n  (function(i) {\r\n    setTimeout(function() { console.log(i); }, 100 * i);\r\n  })(i);\r\n}\r\n</pre>\n<p>This odd-looking pattern is actually a commonplace. The <code>i</code> in the parameter actually shadows the <code>i</code> declared in the <code>for</code> loop, but since we named it the same, we didn’t have to modify the loop body too much.</p>\n<h2 id=\"let-declarations\">\n<code>let</code> declarations</h2>\n<p>By now you’ve figured out that <code>var</code> has some problems, which is precisely why <code>let</code> statements are a new way to declare variables. Apart from the keyword used, <code>let</code> statements are written the same way <code>var</code> statements are.</p>\n<pre data-language=\"typescript\">let hello = \"Hello!\";\r\n</pre>\n<p>The key difference is not in the syntax, but in the semantics, which we’ll now dive into.</p>\n<h2 id=\"block-scoping\">Block-scoping</h2>\n<p>When a variable is declared using <code>let</code>, it uses what some call <em>lexical-scoping</em> or <em>block-scoping</em>. Unlike variables declared with <code>var</code> whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block or <code>for</code>-loop.</p>\n<pre data-language=\"typescript\">function f(input: boolean) {\r\n  let a = 100;\r\n\r\n  if (input) {\r\n    // Still okay to reference 'a'\r\n    let b = a + 1;\r\n    return b;\r\n  }\r\n\r\n  // Error: 'b' doesn't exist here\r\n  return b;\r\n}\r\n</pre>\n<p>Here, we have two local variables <code>a</code> and <code>b</code>. <code>a</code>’s scope is limited to the body of <code>f</code> while <code>b</code>’s scope is limited to the containing <code>if</code> statement’s block.</p>\n<p>Variables declared in a <code>catch</code> clause also have similar scoping rules.</p>\n<pre data-language=\"typescript\">try {\r\n  throw \"oh no!\";\r\n}\r\ncatch (e) {\r\n  console.log(\"Oh well.\");\r\n}\r\n\r\n// Error: 'e' doesn't exist here\r\nconsole.log(e);\r\n</pre>\n<p>Another property of block-scoped variables is that they can’t be read or written to before they’re actually declared. While these variables are “present” throughout their scope, all points up until their declaration are part of their <em>temporal dead zone</em>. This is just a sophisticated way of saying you can’t access them before the <code>let</code> statement, and luckily TypeScript will let you know that.</p>\n<pre data-language=\"typescript\">a++; // illegal to use 'a' before it's declared;\r\nlet a;\r\n</pre>\n<p>Something to note is that you can still <em>capture</em> a block-scoped variable before it’s declared. The only catch is that it’s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won’t report this as an error.</p>\n<pre data-language=\"typescript\">function foo() {\r\n  // okay to capture 'a'\r\n  return a;\r\n}\r\n\r\n// illegal call 'foo' before 'a' is declared\r\n// runtimes should throw an error here\r\nfoo();\r\n\r\nlet a;\r\n</pre>\n<p>For more information on temporal dead zones, see relevant content on the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\">Mozilla Developer Network</a>.</p>\n<h2 id=\"re-declarations-and-shadowing\">Re-declarations and Shadowing</h2>\n<p>With <code>var</code> declarations, we mentioned that it didn’t matter how many times you declared your variables; you just got one.</p>\n<pre data-language=\"typescript\">function f(x) {\r\n  var x;\r\n  var x;\r\n\r\n  if (true) {\r\n    var x;\r\n  }\r\n}\r\n</pre>\n<p>In the above example, all declarations of <code>x</code> actually refer to the <em>same</em> <code>x</code>, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, <code>let</code> declarations are not as forgiving.</p>\n<pre data-language=\"typescript\">let x = 10;\r\nlet x = 20; // error: can't re-declare 'x' in the same scope\r\n</pre>\n<p>The variables don’t necessarily need to both be block-scoped for TypeScript to tell us that there’s a problem.</p>\n<pre data-language=\"typescript\">function f(x) {\r\n  let x = 100; // error: interferes with parameter declaration\r\n}\r\n\r\nfunction g() {\r\n  let x = 100;\r\n  var x = 100; // error: can't have both declarations of 'x'\r\n}\r\n</pre>\n<p>That’s not to say that block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.</p>\n<pre data-language=\"typescript\">function f(condition, x) {\r\n  if (condition) {\r\n    let x = 100;\r\n    return x;\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\nf(false, 0); // returns 0\r\nf(true, 0);  // returns 100\r\n</pre>\n<p>The act of introducing a new name in a more nested scope is called <em>shadowing</em>. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier <code>sumMatrix</code> function using <code>let</code> variables.</p>\n<pre data-language=\"typescript\">function sumMatrix(matrix: number[][]) {\r\n  let sum = 0;\r\n  for (let i = 0; i &lt; matrix.length; i++) {\r\n    var currentRow = matrix[i];\r\n    for (let i = 0; i &lt; currentRow.length; i++) {\r\n      sum += currentRow[i];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n</pre>\n<p>This version of the loop will actually perform the summation correctly because the inner loop’s <code>i</code> shadows <code>i</code> from the outer loop.</p>\n<p>Shadowing should <em>usually</em> be avoided in the interest of write clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.</p>\n<h2 id=\"block-scoped-variable-capturing\">Block-scoped variable capturing</h2>\n<p>When we first touched on the idea of variable capturing with <code>var</code> declaration, we briefly went into how variables act once captured. To give a better intuition of this, each time a scope is run, it creates an “environment” of variables. That environment and its can exist even after everything within its scope has finished executing.</p>\n<pre data-language=\"typescript\">function theCityThatAlwaysSleeps() {\r\n  let getCity;\r\n\r\n  if (true) {\r\n    let city = \"Seattle\";\r\n    getCity = function() {\r\n      return city;\r\n    }\r\n  }\r\n\r\n  return getCity();\r\n}\r\n</pre>\n<p>Because we’ve captured <code>city</code> from within its environment, we’re still able to access it despite the fact that the <code>if</code> block finished executing.</p>\n<p>Recall that with our earlier <code>setTimeout</code> example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the <code>for</code> loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you’ll never have to do that again in TypeScript.</p>\n<p><code>let</code> declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope <em>per iteration</em>. Since this is what we were doing anyway with our IIFE, we can change our old <code>setTimeout</code> example to just use a <code>let</code> declaration.</p>\n<pre data-language=\"typescript\">for (let i = 0; i &lt; 10 ; i++) {\r\n  setTimeout(function() {console.log(i); }, 100 * i);\r\n}\r\n</pre>\n<p>and as expected, this will print out</p>\n<pre data-language=\"text\">0\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n</pre>\n<h2 id=\"const-declarations\">\n<code>const</code> declarations</h2>\n<p><code>const</code> declarations are another way of declaring variables.</p>\n<pre data-language=\"typescript\">const numLivesForCat = 9;\r\n</pre>\n<p>They are like <code>let</code> declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as <code>let</code>, but you can’t re-assign to them.</p>\n<p>This should not be confused with the idea that the values they refer to are <em>immutable</em>.</p>\n<pre data-language=\"typescript\">const numLivesForCat = 9;\r\nconst kitty = {\r\n  name: \"Aurora\",\r\n  numLives: numLivesForCat,\r\n}\r\n\r\n// Error\r\nkitty = {\r\n  name: \"Danielle\",\r\n  numLives: numLivesForCat\r\n};\r\n\r\n// all \"okay\"\r\nkitty.name = \"Rory\";\r\nkitty.name = \"Kitty\";\r\nkitty.name = \"Cat\";\r\nkitty.numLives--;\r\n</pre>\n<p>Unless you take specific measures to avoid it, the internal state of a <code>const</code> variable is still modifiable.</p>\n<h2 id=\"let-vs-const\">\n<code>let</code> vs. <code>const</code>\n</h2>\n<p>Given that we have two types of declarations with similar scoping semantics, it’s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.</p>\n<p>Applying the <a href=\"https://en.wikipedia.org/wiki/Principle_of_least_privilege\">principle of least privilege</a>, all declarations other than those you plan to modify should use <code>const</code>. The rationale is that if a variable didn’t need to get written to, others working on the same codebase shouldn’t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using <code>const</code> also makes code more predictable when reasoning about flow of data.</p>\n<p>On the other hand, <code>let</code> is not any longer to write out than <code>var</code>, and many users will prefer its brevity. The majority of this handbook uses <code>let</code> declarations in that interest.</p>\n<p>Use your best judgement, and if applicable, consult the matter with the rest of your team.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/variable-declarations.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/variable-declarations.html</a>\n  </p>\n</div>\n","release-notes/typescript-1.5":"<h1 class=\"post-title\">TypeScript 1.5</h1>\n\n<h2 id=\"es6-modules\">ES6 Modules</h2>\n<p>TypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are effectively TypeScript external modules with a new syntax: ES6 modules are separately loaded source files that possibly import other modules and provide a number of externally accessible exports. ES6 modules feature several new export and import declarations. It is recommended that TypeScript libraries and applications be updated to use the new syntax, but this is not a requirement. The new ES6 module syntax coexists with TypeScript’s original internal and external module constructs and the constructs can be mixed and matched at will.</p>\n<h4 id=\"export-declarations\">Export Declarations</h4>\n<p>In addition to the existing TypeScript support for decorating declarations with <code>export</code>, module members can also be exported using separate export declarations, optionally specifying different names for exports using <code>as</code> clauses.</p>\n<pre data-language=\"typescript\">interface Stream { ... }\r\nfunction writeToStream(stream: Stream, data: string) { ... }\r\nexport { Stream, writeToStream as write };  // writeToStream exported as write\r\n</pre>\n<p>Import declarations, as well, can optionally use <code>as</code> clauses to specify different local names for the imports. For example:</p>\n<pre data-language=\"typescript\">import { read, write, standardOutput as stdout } from \"./inout\";\r\nvar s = read(stdout);\r\nwrite(stdout, s);\r\n</pre>\n<p>As an alternative to individual imports, a namespace import can be used to import an entire module:</p>\n<pre data-language=\"typescript\">import * as io from \"./inout\";\r\nvar s = io.read(io.standardOutput);\r\nio.write(io.standardOutput, s);\r\n</pre>\n<h4 id=\"re-exporting\">Re-exporting</h4>\n<p>Using <code>from</code> clause a module can copy the exports of a given module to the current module without introducing local names.</p>\n<pre data-language=\"typescript\">export { read, write, standardOutput as stdout } from \"./inout\";\r\n</pre>\n<p><code>export *</code> can be used to re-export all exports of another module. This is useful for creating modules that aggregate the exports of several other modules.</p>\n<pre data-language=\"typescript\">export function transform(s: string): string { ... }\r\nexport * from \"./mod1\";\r\nexport * from \"./mod2\";\r\n</pre>\n<h4 id=\"default-export\">Default Export</h4>\n<p>An export default declaration specifies an expression that becomes the default export of a module:</p>\n<pre data-language=\"typescript\">export default class Greeter {\r\n  sayHello() {\r\n    console.log(\"Greetings!\");\r\n  }\r\n}\r\n</pre>\n<p>Which in tern can be imported using default imports:</p>\n<pre data-language=\"typescript\">import Greeter from \"./greeter\";\r\nvar g = new Greeter();\r\ng.sayHello();\r\n</pre>\n<h4 id=\"bare-import\">Bare Import</h4>\n<p>A “bare import” can be used to import a module only for its side-effects.</p>\n<pre data-language=\"typescript\">import \"./polyfills\";\r\n</pre>\n<p>For more information about module, please see the <a href=\"https://github.com/Microsoft/TypeScript/issues/2242\">ES6 module support spec</a>.</p>\n<h2 id=\"destructuring-in-declarations-and-assignments\">Destructuring in declarations and assignments</h2>\n<p>TypeScript 1.5 adds support to ES6 destructuring declarations and assignments.</p>\n<h4 id=\"declarations\">Declarations</h4>\n<p>A destructuring declaration introduces one or more named variables and initializes them with values extracted from properties of an object or elements of an array.</p>\n<p>For example, the following sample declares variables <code>x</code>, <code>y</code>, and <code>z</code>, and initializes them to <code>getSomeObject().x</code>, <code>getSomeObject().y</code> and <code>getSomeObject().z</code> respectively:</p>\n<pre data-language=\"typescript\">var { x, y, z} = getSomeObject();\r\n</pre>\n<p>Destructuring declarations also works for extracting values from arrays:</p>\n<pre data-language=\"typescript\">var [x, y, z = 10] = getSomeArray();\r\n</pre>\n<p>Similarly, destructuring can be used in function parameter declarations:</p>\n<pre data-language=\"typescript\">function drawText({ text = \"\", location: [x, y] = [0, 0], bold = false }) {\r\n  // Draw text\r\n}\r\n\r\n// Call drawText with an object literal\r\nvar item = { text: \"someText\", location: [1,2,3], style: \"italics\" };\r\ndrawText(item);\r\n</pre>\n<h4 id=\"assignments\">Assignments</h4>\n<p>Destructuring patterns can also be used in regular assignment expressions. For instance, swapping two variables can be written as a single destructuring assignment:</p>\n<pre data-language=\"typescript\">var x = 1;\r\nvar y = 2;\r\n[x, y] = [y, x];\r\n</pre>\n<h2 id=\"namespace-keyword\">\n<code>namespace</code> keyword</h2>\n<p>TypeScript used the <code>module</code> keyword to define both “internal modules” and “external modules”; this has been a bit of confusion for developers new to TypeScript. “Internal modules” are closer to what most people would call a namespace; likewise, “external modules” in JS speak really just are modules now.</p>\n<blockquote><p>Note: Previous syntax defining internal modules are still supported.</p></blockquote>\n<p><strong>Before</strong>:</p>\n<pre data-language=\"typescript\">module Math {\r\n  export function add(x, y) { ... }\r\n}\r\n</pre>\n<p><strong>After</strong>:</p>\n<pre data-language=\"typescript\">namespace Math {\r\n  export function add(x, y) { ... }\r\n}\r\n</pre>\n<h2 id=\"let-and-const-support\">\n<code>let</code> and <code>const</code> support</h2>\n<p>ES6 <code>let</code> and <code>const</code> declarations are now supported when targeting ES3 and ES5.</p>\n<h4 id=\"const\">Const</h4>\n<pre data-language=\"typescript\">const MAX = 100;\r\n\r\n++MAX; // Error: The operand of an increment or decrement\r\n     //    operator cannot be a constant.\r\n</pre>\n<h4 id=\"block-scoped\">Block scoped</h4>\n<pre data-language=\"typescript\">if (true) {\r\n  let a = 4;\r\n  // use a\r\n}\r\nelse {\r\n  let a = \"string\";\r\n  // use a\r\n}\r\n\r\nalert(a); // Error: a is not defined in this scope\r\n</pre>\n<h2 id=\"forof-support\">for..of support</h2>\n<p>TypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well as full support for Iterator interfaces when targetting ES6.</p>\n<h5 id=\"example\">Example</h5>\n<p>The TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5 JavaScript when targeting those versions:</p>\n<pre data-language=\"typescript\">for (var v of expr) { }\r\n</pre>\n<p>will be emitted as:</p>\n<pre data-language=\"javascript\">for (var _i = 0, _a = expr; _i &lt; _a.length; _i++) {\r\n  var v = _a[_i];\r\n}\r\n</pre>\n<h2 id=\"decorators\">Decorators</h2>\n<blockquote><p>TypeScript decorators are based on the <a href=\"https://github.com/wycats/javascript-decorators\">ES7 decorator proposal</a>.</p></blockquote>\n<p>A decorator is:</p>\n<ul>\n<li>an expression</li>\n<li>that evaluates to a function</li>\n<li>that takes the target, name, and property descriptor as arguments</li>\n<li>and optionally returns a property descriptor to install on the target object</li>\n</ul>\n<blockquote><p>For more information, please see the <a href=\"https://github.com/Microsoft/TypeScript/issues/2249\">Decorators</a> proposal.</p></blockquote>\n<h5 id=\"example-1\">Example</h5>\n<p>Decorators <code>readonly</code> and <code>enumerable(false)</code> will be applied to the property <code>method</code> before it is installed on class <code>C</code>. This allows the decorator to change the implementation, and in this case, augment the descriptor to be writable: false and enumerable: false.</p>\n<pre data-language=\"typescript\">class C {\r\n  @readonly\r\n  @enumerable(false)\r\n  method() { }\r\n}\r\n\r\nfunction readonly(target, key, descriptor) {\r\n  descriptor.writable = false;\r\n}\r\n\r\nfunction enumerable(value) {\r\n  return function (target, key, descriptor) {\r\n   descriptor.enumerable = value;\r\n  }\r\n}\r\n</pre>\n<h2 id=\"computed-properties\">Computed properties</h2>\n<p>Initializing an object with dynamic properties can be a bit of a burden. Take the following example:</p>\n<pre data-language=\"typescript\">type NeighborMap = { [name: string]: Node };\r\ntype Node = { name: string; neighbors: NeighborMap;}\r\n\r\nfunction makeNode(name: string, initialNeighbor: Node): Node {\r\n  var neighbors: NeighborMap = {};\r\n  neighbors[initialNeighbor.name] = initialNeighbor;\r\n  return { name: name, neighbors: neighbors };\r\n}\r\n</pre>\n<p>Here we need to create a variable to hold on to the neighbor-map so that we can initialize it. With TypeScript 1.5, we can let the compiler do the heavy lifting:</p>\n<pre data-language=\"typescript\">function makeNode(name: string, initialNeighbor: Node): Node {\r\n  return {\r\n    name: name,\r\n    neighbors: {\r\n      [initialNeighbor.name]: initialNeighbor\r\n    }\r\n  }\r\n}\r\n</pre>\n<h2 id=\"support-for-umd-and-system-module-output\">Support for <code>UMD</code> and <code>System</code> module output</h2>\n<p>In addition to <code>AMD</code> and <code>CommonJS</code> module loaders, TypeScript now supports emitting modules <code>UMD</code> (<a href=\"https://github.com/umdjs/umd\">Universal Module Definition</a>) and <a href=\"https://github.com/systemjs/systemjs\"><code>System</code></a> module formats.</p>\n<p><strong>Usage</strong>: &gt; tsc –module umd</p>\n<p>and</p>\n<blockquote><p>tsc –module system</p></blockquote>\n<h2 id=\"unicode-codepoint-escapes-in-strings\">Unicode codepoint escapes in strings</h2>\n<p>ES6 introduces escapes that allow users to represent a Unicode codepoint using just a single escape.</p>\n<p>As an example, consider the need to escape a string that contains the character ‘𠮷’. In UTF-16/UCS2, ‘𠮷’ is represented as a surrogate pair, meaning that it’s encoded using a pair of 16-bit code units of values, specifically <code>0xD842</code> and <code>0xDFB7</code>. Previously this meant that you’d have to escape the codepoint as <code>\"\\uD842\\uDFB7\"</code>. This has the major downside that it’s difficult to discern two independent characters from a surrogate pair.</p>\n<p>With ES6’s codepoint escapes, you can cleanly represent that exact character in strings and template strings with a single escape: <code>\"\\u{20bb7}\"</code>. TypeScript will emit the string in ES3/ES5 as <code>\"\\uD842\\uDFB7\"</code>.</p>\n<h2 id=\"tagged-template-strings-in-es3es5\">Tagged template strings in ES3/ES5</h2>\n<p>In TypeScript 1.4, we added support for template strings for all targets, and tagged templates for just ES6. Thanks to some considerable work done by <a href=\"https://github.com/ivogabe\">@ivogabe</a>, we bridged the gap for for tagged templates in ES3 and ES5.</p>\n<p>When targeting ES3/ES5, the following code</p>\n<pre data-language=\"typescript\">function oddRawStrings(strs: TemplateStringsArray, n1, n2) {\r\n  return strs.raw.filter((raw, index) =&gt; index % 2 === 1);\r\n}\r\n\r\noddRawStrings `Hello \\n${123} \\t ${456}\\n world`\r\n</pre>\n<p>will be emitted as</p>\n<pre data-language=\"javascript\">function oddRawStrings(strs, n1, n2) {\r\n  return strs.raw.filter(function (raw, index) {\r\n    return index % 2 === 1;\r\n  });\r\n}\r\n(_a = [\"Hello \\n\", \" \\t \", \"\\n world\"], _a.raw = [\"Hello \\\\n\", \" \\\\t \", \"\\\\n world\"], oddRawStrings(_a, 123, 456));\r\nvar _a;\r\n</pre>\n<h2 id=\"amd-dependency-optional-names\">AMD-dependency optional names</h2>\n<p><code>/// &lt;amd-dependency path=\"x\" /&gt;</code> informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call; however, there was no way to consume this module in the TS code.</p>\n<p>The new <code>amd-dependency name</code> property allows passing an optional name for an amd-dependency:</p>\n<pre data-language=\"typescript\">/// &lt;amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/&gt;\r\ndeclare var moduleA:MyType\r\nmoduleA.callStuff()\r\n</pre>\n<p>Generated JS code:</p>\n<pre data-language=\"javascript\">define([\"require\", \"exports\", \"legacy/moduleA\"], function (require, exports, moduleA) {\r\n  moduleA.callStuff()\r\n});\r\n</pre>\n<h2 id=\"project-support-through-tsconfigjson\">Project support through <code>tsconfig.json</code>\n</h2>\n<p>Adding a <code>tsconfig.json</code> file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</p>\n<ul>\n<li>By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.</li>\n<li>By invoking tsc with no input files and a -project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file.</li>\n</ul>\n<h5 id=\"example-2\">Example</h5>\n<pre data-language=\"javascripton\">{\r\n  \"compilerOptions\": {\r\n    \"module\": \"commonjs\",\r\n    \"noImplicitAny\": true,\r\n    \"sourceMap\": true,\r\n  }\r\n}\r\n</pre>\n<p>See the <a href=\"https://github.com/Microsoft/TypeScript/wiki/tsconfig.json\">tsconfig.json wiki page</a> for more details.</p>\n<h2 id=\"rootdir-command-line-option\">\n<code>--rootDir</code> command line option</h2>\n<p>Option <code>--outDir</code> duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.</p>\n<p>Sometimes this is not desirable, for instance inputs <code>FolderA\\FolderB\\1.ts</code> and <code>FolderA\\FolderB\\2.ts</code> would result in output structure mirroring <code>FolderA\\FolderB\\</code>. Now if a new file <code>FolderA\\3.ts</code> is added to the input, the output structure will pop out to mirror <code>FolderA\\</code>.</p>\n<p><code>--rootDir</code> specifies the input directory to be mirrored in output instead of computing it.</p>\n<h2 id=\"noemithelpers-command-line-option\">\n<code>--noEmitHelpers</code> command line option</h2>\n<p>The TypeSript compiler emits a few helpers like <code>__extends</code> when needed. The helpers are emitted in every file they are referenced in. If you want to consolidate all helpers in one place, or override the default behavior, use <code>--noEmitHelpers</code> to instructs the compiler not to emit them.</p>\n<h2 id=\"newline-command-line-option\">\n<code>--newLine</code> command line option</h2>\n<p>By default the output new line character is <code>\\r\\n</code> on Windows based systems and <code>\\n</code> on *nix based systems. <code>--newLine</code> command line flag allows overriding this behavior and specifying the new line character to be used in generated output files.</p>\n<h2 id=\"inlinesourcemap-and-inlinesources-command-line-options\">\n<code>--inlineSourceMap</code> and <code>inlineSources</code> command line options</h2>\n<p><code>--inlineSourceMap</code> causes source map files to be written inline in the generated <code>.js</code> files instead of in a independent <code>.js.map</code> file. <code>--inlineSources</code> allows for additionally inlining the source <code>.ts</code> file into the <code>.js</code> file.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/release-notes/typescript-1.5.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/release-notes/typescript-1.5.html</a>\n  </p>\n</div>\n","handbook/generics":"<h1 class=\"post-title\">Generics</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.</p>\n<p>In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is ‘generics’, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.</p>\n<h2 id=\"hello-world-of-generics\">Hello World of Generics</h2>\n<p>To start off, let’s do the “hello world” of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the ‘echo’ command.</p>\n<p>Without generics, we would either have to give the identity function a specific type:</p>\n<pre data-language=\"typescript\">function identity(arg: number): number {\r\n  return arg;\r\n}\r\n</pre>\n<p>Or, we could describe the identity function using the <code>any</code> type:</p>\n<pre data-language=\"typescript\">function identity(arg: any): any {\r\n  return arg;\r\n}\r\n</pre>\n<p>While using <code>any</code> is certainly generic in that will accept any and all types for the type of <code>arg</code>, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.</p>\n<p>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a <em>type variable</em>, a special kind of variable that works on types rather than values.</p>\n<pre data-language=\"typescript\">function identity&lt;T&gt;(arg: T): T {\r\n  return arg;\r\n}\r\n</pre>\n<p>We’ve now added a type variable <code>T</code> to the identity function. This <code>T</code> allows us to capture the type the user provides (e.g. <code>number</code>), so that we can use that information later. Here, we use <code>T</code> again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.</p>\n<p>We say that this version of the <code>identity</code> function is generic, as it works over a range of types. Unlike using <code>any</code>, it’s also just as precise (ie, it doesn’t lose any information) as the first <code>identity</code> function that used numbers for the argument and return type.</p>\n<p>Once we’ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</p>\n<pre data-language=\"typescript\">let output = identity&lt;string&gt;(\"myString\");  // type of output will be 'string'\r\n</pre>\n<p>Here we explicitly set <code>T</code> to be string as one of the arguments to the function call, denoted using the <code>&lt;&gt;</code> around the arguments rather than <code>()</code>.</p>\n<p>The second way is also perhaps the most common. Here we use <em>type argument inference</em>, that is, we want the compiler to set the value of <code>T</code> for us automatically based on the type of the argument we pass in:</p>\n<pre data-language=\"typescript\">let output = identity(\"myString\");  // type of output will be 'string'\r\n</pre>\n<p>Notice that we didn’t have explicitly pass the type in the angle brackets (<code>&lt;&gt;</code>), the compiler just looked at the value <code>\"myString\"</code>, and set <code>T</code> to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.</p>\n<h2 id=\"working-with-generic-type-variables\">Working with Generic Type Variables</h2>\n<p>When you begin to use generics, you’ll notice that when you create generic functions like <code>identity</code>, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.</p>\n<p>Let’s take our <code>identity</code> function from earlier:</p>\n<pre data-language=\"typescript\">function identity&lt;T&gt;(arg: T): T {\r\n  return arg;\r\n}\r\n</pre>\n<p>What if we want to also log the length of the argument <code>arg</code> to the console with each call? We might be tempted to write this:</p>\n<pre data-language=\"typescript\">function loggingIdentity&lt;T&gt;(arg: T): T {\r\n  console.log(arg.length);  // Error: T doesn't have .length\r\n  return arg;\r\n}\r\n</pre>\n<p>When we do, the compiler will give us an error that we’re using the <code>.length</code> member of <code>arg</code>, but nowhere have we said that <code>arg</code> has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a <code>number</code> instead, which does not have a <code>.length</code> member.</p>\n<p>Let’s say that we’ve actually intended this function to work on arrays of <code>T</code> rather that <code>T</code> directly. Since we’re working with arrays, the <code>.length</code> member should be available. We can describe this just like we would create arrays of other types:</p>\n<pre data-language=\"typescript\">function loggingIdentity&lt;T&gt;(arg: T[]): T[] {\r\n  console.log(arg.length);  // Array has a .length, so no more error\r\n  return arg;\r\n}\r\n</pre>\n<p>You can read the type of <code>loggingIdentity</code> as “the generic function <code>loggingIdentity</code> takes a type parameter <code>T</code>, and an argument <code>arg</code> which is an array of <code>T</code>s, and returns an array of <code>T</code>s.” If we passed in an array of numbers, we’d get an array of numbers back out, as <code>T</code> would bind to <code>number</code>. This allows us to use our generic type variable <code>T</code> as part of the types we’re working with, rather than the whole type, giving us greater flexibility.</p>\n<p>We can alternatively write the sample example this way:</p>\n<pre data-language=\"typescript\">function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; {\r\n  console.log(arg.length);  // Array has a .length, so no more error\r\n  return arg;\r\n}\r\n</pre>\n<p>You may already be familiar with this style of type from other languages. In the next section, we’ll cover how you can create your own generic types like <code>Array&lt;T&gt;</code>.</p>\n<h2 id=\"generic-types\">Generic Types</h2>\n<p>In previous sections, we created generic identity functions that worked over a range of types. In this section, we’ll explore the type of the functions themselves and how to create generic interfaces.</p>\n<p>The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:</p>\n<pre data-language=\"typescript\">function identity&lt;T&gt;(arg: T): T {\r\n  return arg;\r\n}\r\n\r\nlet myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;\r\n</pre>\n<p>We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.</p>\n<pre data-language=\"typescript\">function identity&lt;T&gt;(arg: T): T {\r\n  return arg;\r\n}\r\n\r\nlet myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity;\r\n</pre>\n<p>We can also write the generic type as a call signature of an object literal type:</p>\n<pre data-language=\"typescript\">function identity&lt;T&gt;(arg: T): T {\r\n  return arg;\r\n}\r\n\r\nlet myIdentity: {&lt;T&gt;(arg: T): T} = identity;\r\n</pre>\n<p>Which leads us to writing our first generic interface. Let’s take the object literal from the previous example and move it to an interface:</p>\n<pre data-language=\"typescript\">interface GenericIdentityFn {\r\n  &lt;T&gt;(arg: T): T;\r\n}\r\n\r\nfunction identity&lt;T&gt;(arg: T): T {\r\n  return arg;\r\n}\r\n\r\nlet myIdentity: GenericIdentityFn = identity;\r\n</pre>\n<p>In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we’re generic over (e.g. <code>Dictionary&lt;string&gt;</code> rather than just <code>Dictionary</code>). This makes the type parameter visible to all the other members of the interface.</p>\n<pre data-language=\"typescript\">interface GenericIdentityFn&lt;T&gt; {\r\n  (arg: T): T;\r\n}\r\n\r\nfunction identity&lt;T&gt;(arg: T): T {\r\n  return arg;\r\n}\r\n\r\nlet myIdentity: GenericIdentityFn&lt;number&gt; = identity;\r\n</pre>\n<p>Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use <code>GenericIdentityFn</code>, we now will also need to specify the corresponding type argument (here: <code>number</code>), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.</p>\n<p>In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.</p>\n<h2 id=\"generic-classes\">Generic Classes</h2>\n<p>A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (<code>&lt;&gt;</code>) following the name of the class.</p>\n<pre data-language=\"typescript\">class GenericNumber&lt;T&gt; {\r\n  zeroValue: T;\r\n  add: (x: T, y: T) =&gt; T;\r\n}\r\n\r\nlet myGenericNumber = new GenericNumber&lt;number&gt;();\r\nmyGenericNumber.zeroValue = 0;\r\nmyGenericNumber.add = function(x, y) { return x + y; };\r\n</pre>\n<p>This is a pretty literal use of the <code>GenericNumber</code> class, but you may have noticed that nothing is restricting it to only use the <code>number</code> type. We could have instead used <code>string</code> or even more complex objects.</p>\n<pre data-language=\"typescript\">let stringNumeric = new GenericNumber&lt;string&gt;();\r\nstringNumeric.zeroValue = \"\";\r\nstringNumeric.add = function(x, y) { return x + y; };\r\n\r\nalert(stringNumeric.add(stringNumeric.zeroValue, \"test\"));\r\n</pre>\n<p>Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.</p>\n<p>As we covered in [Classes|Classes in TypeScript], a class has two side to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter.</p>\n<h2 id=\"generic-constraints\">Generic Constraints</h2>\n<p>If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our <code>loggingIdentity</code> example, we wanted to be able access the <code>.length</code> property of <code>arg</code>, but the compiler could not prove that every type had a <code>.length</code> property, so it warns us that we can’t make this assumption.</p>\n<pre data-language=\"typescript\">function loggingIdentity&lt;T&gt;(arg: T): T {\r\n  console.log(arg.length);  // Error: T doesn't have .length\r\n  return arg;\r\n}\r\n</pre>\n<p>Instead of working with any and all types, we’d like to constrain this function to work with any and all types that also have the <code>.length</code> property. As long as the type has this member, we’ll allow it, but it’s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.</p>\n<p>To do so, we’ll create an interface that describes our constraint. Here, we’ll create an interface that has a single <code>.length</code> property and then we’ll use this interface and the <code>extends</code> keyword to denote our constraint:</p>\n<pre data-language=\"typescript\">interface Lengthwise {\r\n  length: number;\r\n}\r\n\r\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {\r\n  console.log(arg.length);  // Now we know it has a .length property, so no more error\r\n  return arg;\r\n}\r\n</pre>\n<p>Because the generic function is now constrained, it will no longer work over any and all types:</p>\n<pre data-language=\"typescript\">loggingIdentity(3);  // Error, number doesn't have a .length property\r\n</pre>\n<p>Instead, we need to pass in values whose type has all the required properties:</p>\n<pre data-language=\"typescript\">loggingIdentity({length: 10, value: 3});\r\n</pre>\n<h2 id=\"using-type-parameters-in-generic-constraints\">Using Type Parameters in Generic Constraints</h2>\n<p>In some cases, it may be useful to declare a type parameter that is constrained by another type parameter. For example,</p>\n<pre data-language=\"typescript\">function find&lt;T, U extends Findable&lt;T&gt;&gt;(n: T, s: U) {   // errors because type parameter used in constraint\r\n  // ...\r\n}\r\nfind (giraffe, myAnimals);\r\n</pre>\n<p>You can achieve the pattern above by replacing the type parameter with its constraint. Rewriting the example above,</p>\n<pre data-language=\"typescript\">function find&lt;T&gt;(n: T, s: Findable&lt;T&gt;) {\r\n  // ...\r\n}\r\nfind(giraffe, myAnimals);\r\n</pre>\n<p><em>Note:</em> The above is not strictly identical, as the return type of the first function could have returned <code>U</code>, which the second function pattern does not provide a means to do.</p>\n<h2 id=\"using-class-types-in-generics\">Using Class Types in Generics</h2>\n<p>When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,</p>\n<pre data-language=\"typescript\">function create&lt;T&gt;(c: {new(): T; }): T {\r\n  return new c();\r\n}\r\n</pre>\n<p>A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.</p>\n<pre data-language=\"typescript\">class BeeKeeper {\r\n  hasMask: boolean;\r\n}\r\n\r\nclass ZooKeeper {\r\n  nametag: string;\r\n}\r\n\r\nclass Animal {\r\n  numLegs: number;\r\n}\r\n\r\nclass Bee extends Animal {\r\n  keeper: BeeKeeper;\r\n}\r\n\r\nclass Lion extends Animal {\r\n  keeper: ZooKeeper;\r\n}\r\n\r\nfunction findKeeper&lt;A extends Animal, K&gt; (a: {new(): A;\r\n  prototype: {keeper: K}}): K {\r\n\r\n  return a.prototype.keeper;\r\n}\r\n\r\nfindKeeper(Lion).nametag;  // typechecks!\r\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/generics.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/generics.html</a>\n  </p>\n</div>\n","handbook/enums":"<h1 class=\"post-title\">Enums</h1>\n\n<h2 id=\"enums\">Enums</h2>\n<p>Enums allow us to define a set of named numeric constants. An enum can be defined using the <code>enum</code> keyword.</p>\n<pre data-language=\"typescript\">enum Direction {\r\n  Up = 1,\r\n  Down,\r\n  Left,\r\n  Right\r\n}\r\n</pre>\n<p>The body of an enum consists of zero or more enum members. Enum members have numeric value associated with them and can be either <em>constant</em> or <em>computed</em>. An enum member is considered constant if:</p>\n<ul>\n<li>It does not have an initializer and the preceding enum member was constant. In this case the value of the current enum member will be the value of the preceding enum member plus one. One exception to this rule is the first element on an enum. If it does not have initializer it is assigned the value <code>0</code>.</li>\n<li>The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is either:<ul>\n<li>numeric literal</li>\n<li>reference to previously defined constant enum member (it can be defined in different enum). If member is defined in the same enum it can be referenced using unqualified name.</li>\n<li>parenthesized constant enum expression</li>\n<li>\n<code>+</code>, <code>-</code>, <code>~</code> unary operators applied to constant enum expression</li>\n<li>\n<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> binary operators with constant enum expressions as operands It is a compile time error for constant enum expressions to be evaluated to <code>NaN</code> or <code>Infinity</code>.</li>\n</ul>\n</li>\n</ul>\n<p>In all other cases enum member is considered computed.</p>\n<pre data-language=\"typescript\">enum FileAccess {\r\n  // constant members\r\n  None,\r\n  Read  = 1 &lt;&lt; 1,\r\n  Write   = 1 &lt;&lt; 2,\r\n  ReadWrite  = Read | Write\r\n  // computed member\r\n  G = \"123\".length\r\n}\r\n</pre>\n<p>Enums are real objects that exist at runtime. One reason is the ability to maintain a reverse mapping from enum values to enum names.</p>\n<pre data-language=\"typescript\">enum Enum {\r\n  A\r\n}\r\nlet a = Enum.A;\r\nlet nameOfA = Enum[Enum.A]; // \"A\"\r\n</pre>\n<p>is compiled to:</p>\n<pre data-language=\"javascript\">var Enum;\r\n(function (Enum) {\r\n  Enum[Enum[\"A\"] = 0] = \"A\";\r\n})(Enum || (Enum = {}));\r\nvar a = Enum.A;\r\nvar nameOfA = Enum[Enum.A]; // \"A\"\r\n</pre>\n<p>In generated code an enum is compiled into an object that stores both forward (<code>name</code> -&gt; <code>value</code>) and reverse (<code>value</code> -&gt; <code>name</code>) mappings. References to enum members are always emitted as property accesses and never inlined. In lots of cases this is a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values it is possible to use const enums. Const enums are defined using the <code>const</code> modifier that precedes the <code>enum</code> keyword.</p>\n<pre data-language=\"typescript\">const enum Enum {\r\n  A = 1,\r\n  B = A * 2\r\n}\r\n</pre>\n<p>Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.</p>\n<pre data-language=\"typescript\">const enum Directions {\r\n  Up,\r\n  Down,\r\n  Left,\r\n  Right\r\n}\r\n\r\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]\r\n</pre>\n<p>in generated code will become</p>\n<pre data-language=\"javascript\">var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];\r\n</pre>\n<h2 id=\"ambient-enums\">Ambient enums</h2>\n<p>Ambient enums are used to describe the shape of already existing enum types.</p>\n<pre data-language=\"typescript\">declare enum Enum {\r\n  A = 1,\r\n  B,\r\n  C = 2\r\n}\r\n</pre>\n<p>One important difference between ambient and non-ambient enums is that, in regular enums, members that don’t have an initializer are considered constant members. For non-const ambient enums member that does not have initializer is considered computed.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/enums.html</a>\n  </p>\n</div>\n","handbook/type-inference":"<h1 class=\"post-title\">Type Inference</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>In this section, we will cover type inference in TypeScript. Namely, we’ll discuss where and how types are inferred.</p>\n<h2 id=\"basics\">Basics</h2>\n<p>In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code</p>\n<pre data-language=\"typescript\">let x = 3;\r\n</pre>\n<p>The type of the <code>x</code> variable is inferred to be <code>number</code>. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.</p>\n<p>In most cases, type inference is straightforward. In the following sections, we’ll explore some of the nuances in how types are inferred.</p>\n<h2 id=\"best-common-type\">Best common type</h2>\n<p>When a type inference is made from several expressions, the types of those expressions are used to calculate a “best common type”. For example,</p>\n<pre data-language=\"typescript\">let x = [0, 1, null];\r\n</pre>\n<p>To infer the type of <code>x</code> in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: <code>number</code> and <code>null</code>. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.</p>\n<p>Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:</p>\n<pre data-language=\"typescript\">let zoo = [new Rhino(), new Elephant(), new Snake()];\r\n</pre>\n<p>Ideally, we may want <code>zoo</code> to be inferred as an <code>Animal[]</code>, but because there is no object that is strictly of type <code>Animal</code> in the array, we make no inference about the array element type. To correct this, instead explicitly provide the type when no one type is a super type of all other candidates:</p>\n<pre data-language=\"typescript\">let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];\r\n</pre>\n<p>When no best common type is found, the resulting inference is the empty object type, <code>{}</code>. Because this type has no members, attempting to use any properties of it will cause an error. This result allows you to still use the object in a type-agnostic manner, while providing type safety in cases where the type of the object can’t be implicitly determined.</p>\n<h2 id=\"contextual-type\">Contextual Type</h2>\n<p>Type inference also works in “the other direction” in some cases in TypeScript. This is known as “contextual typing”. Contextual typing occurs when the type of an expression is implied by its location. For example:</p>\n<pre data-language=\"typescript\">window.onmousedown = function(mouseEvent) {\r\n  console.log(mouseEvent.buton);  //&lt;- Error\r\n};\r\n</pre>\n<p>For the code above to give the type error, the TypeScript type checker used the type of the <code>Window.onmousedown</code> function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the type of the <code>mouseEvent</code> parameter. If this function expression were not in a contextually typed position, the <code>mouseEvent</code> parameter would have type <code>any</code>, and no error would have been issued.</p>\n<p>If the contextually typed expression contains explicit type information, the contextual type is ignored. Had we written the above example:</p>\n<pre data-language=\"typescript\">window.onmousedown = function(mouseEvent: any) {\r\n  console.log(mouseEvent.buton);  //&lt;- Now, no error is given\r\n};\r\n</pre>\n<p>The function expression with an explicit type annotation on the parameter will override the contextual type. Once it does so, no error is given as no contextual type applies.</p>\n<p>Contextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:</p>\n<pre data-language=\"typescript\">function createZoo(): Animal[] {\r\n  return [new Rhino(), new Elephant(), new Snake()];\r\n}\r\n</pre>\n<p>In this example, best common type has a set of four candidates: <code>Animal</code>, <code>Rhino</code>, <code>Elephant</code>, and <code>Snake</code>. Of these, <code>Animal</code> can be chosen by the best common type algorithm.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/type-inference.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/type-inference.html</a>\n  </p>\n</div>\n","handbook/iterators-and-generators":"<h1 class=\"post-title\">Iterators and Generators</h1>\n\n<h2 id=\"iterables\">Iterables</h2>\n<p>An object is deemed iterable if it has an implementation for the <a href=\"symbols#symboliterator\"><code>Symbol.iterator</code></a> property. Some built-in types like <code>Array</code>, <code>Map</code>, <code>Set</code>, <code>String</code>, <code>Int32Array</code>, <code>Uint32Array</code>, etc. have their <code>Symbol.iterator</code> property already implemented. <code>Symbol.iterator</code> function on an object is responsible for returning the list of values to iterate on.</p>\n<h2 id=\"forof-statements\">\n<code>for..of</code> statements</h2>\n<p><code>for..of</code> loops over an iterable object, invoking the <code>Symbol.iterator</code> property on the object. Here is a simple <code>for..of</code> loop on an array:</p>\n<pre data-language=\"typescript\">let someArray = [1, \"string\", false];\r\n\r\nfor (let entry of someArray) {\r\n  console.log(entry); // 1, \"string\", false\r\n}\r\n</pre>\n<h3 id=\"forof-vs-forin-statements\">\n<code>for..of</code> vs. <code>for..in</code> statements</h3>\n<p>Both <code>for..of</code> and <code>for..in</code> statements iterate over lists; the values iterated on are different though, <code>for..in</code> returns a list of <em>keys</em> on the object being iterated, whereas <code>for..of</code> returns a list of <em>values</em> of the numeric properties of the object being iterated.</p>\n<p>Here is an example that demonstrates this distinction:</p>\n<pre data-language=\"typescript\">let list = [4, 5, 6];\r\n\r\nfor (let i in list) {\r\n   console.log(i); // \"0\", \"1\", \"2\",\r\n}\r\n\r\nfor (let i of list) {\r\n   console.log(i); // \"4\", \"5\", \"6\"\r\n</pre>\n<p>Another distinction is that <code>for..in</code> operates on any object; it serves as a way to inspect properties on this object. <code>for..of</code> on the other hand, is mainly interested in values of iterable objects. Built-in objects like <code>Map</code> and <code>Set</code> implement <code>Symbol.iterator</code> property allowing access to stored values.</p>\n<pre data-language=\"typescript\">let pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);\r\npets[\"species\"] = \"mammals\";\r\n\r\nfor (let pet in pets) {\r\n   console.log(pet); // \"species\"\r\n}\r\n\r\nfor (let pet of pets) {\r\n  console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"\r\n}\r\n</pre>\n<h3 id=\"code-generation\">Code generation</h3>\n<h4 id=\"targeting-es5-and-es3\">Targeting ES5 and ES3</h4>\n<p>When targeting an ES5 or ES3, iterators are only allowed on values of <code>Array</code> type. It is an error to use <code>for..of</code> loops on non-Array values, even if these non-Array values implement the <code>Symbol.iterator</code> property.</p>\n<p>The compiler will generate a simple <code>for</code> loop for a <code>for..of</code> loop, for instance:</p>\n<pre data-language=\"typescript\">let numbers = [1, 2, 3];\r\nfor (let num of numbers) {\r\n  console.log(num);\r\n}\r\n</pre>\n<p>will be generated as:</p>\n<pre data-language=\"javascript\">var numbers = [1, 2, 3];\r\nfor (var _i = 0; _i &lt; numbers.length; _i++) {\r\n  var num = numbers[_i];\r\n  console.log(num);\r\n}\r\n</pre>\n<h4 id=\"targeting-ecmascript-2015-and-higher\">Targeting ECMAScript 2015 and higher</h4>\n<p>When targeting an ECMAScipt 2015-compliant engine, the compiler will generate <code>for..of</code> loops to target the built-in iterator implementation in the engine.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html</a>\n  </p>\n</div>\n","handbook/functions":"<h1 class=\"post-title\">Functions</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>Functions are the fundamental building block of any applications in JavaScript. They’re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes, namespaces, and modules, functions still play the key role in describing how to <em>do</em> things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.</p>\n<h2 id=\"functions\">Functions</h2>\n<p>To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you’re building a list of functions in an API or a one-off function to hand off to another function.</p>\n<p>To quickly recap what these two approaches look like in JavaScript:</p>\n<pre data-language=\"typescript\">// Named function\r\nfunction add(x, y) {\r\n  return x + y;\r\n}\r\n\r\n// Anonymous function\r\nlet myAdd = function(x, y) { return x+y; };\r\n</pre>\n<p>Just as in JavaScript, functions can refer to variables outside of the function body. When they do so, they’re said to <code>capture</code> these variables. While understanding how this works, and the trade-offs when using this technique, are outside of the scope of this article, having a firm understanding how this mechanic is an important piece of working with JavaScript and TypeScript.</p>\n<pre data-language=\"typescript\">let z = 100;\r\n\r\nfunction addToZ(x, y) {\r\n  return x + y + z;\r\n}\r\n</pre>\n<h2 id=\"function-types\">Function Types</h2>\n<h2 id=\"typing-the-function\">Typing the function</h2>\n<p>Let’s add types to our simple examples from earlier:</p>\n<pre data-language=\"typescript\">function add(x: number, y: number): number {\r\n  return x + y;\r\n}\r\n\r\nlet myAdd = function(x: number, y: number): number { return x+y; };\r\n</pre>\n<p>We can add types to each of the parameters and then to the function itself to add a return type. TypeScript can figure the return type out by looking at the return statements, so we can also optionally leave this off in many cases.</p>\n<h2 id=\"writing-the-function-type\">Writing the function type</h2>\n<p>Now that we’ve typed the function, let’s write the full type of the function out by looking at the each piece of the function type.</p>\n<pre data-language=\"typescript\">let myAdd: (x: number, y: number)=&gt;number =\r\n  function(x: number, y: number): number { return x+y; };\r\n</pre>\n<p>A function’s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type. This name is just to help with readability. We could have instead written:</p>\n<pre data-language=\"typescript\">let myAdd: (baseValue:number, increment:number) =&gt; number =\r\n  function(x: number, y: number): number { return x + y; };\r\n</pre>\n<p>As long as the parameter types line up, it’s considered a valid type for the function, regardless of the names you give the parameters in the function type.</p>\n<p>The second part is the return type. We make it clear which is the return type by using a fat arrow (<code>=&gt;</code>) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn’t return a value, you would use <code>void</code> instead of leaving it off.</p>\n<p>Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the ‘hidden state’ of any function and do not make up its API.</p>\n<h2 id=\"inferring-the-types\">Inferring the types</h2>\n<p>In playing with the example, you may notice that the TypeScript compiler can figure out the type if you have types on one side of the equation but not the other:</p>\n<pre data-language=\"typescript\">// myAdd has the full function type\r\nlet myAdd = function(x: number, y: number): number { return  x + y; };\r\n\r\n// The parameters `x` and `y` have the type number\r\nlet myAdd: (baseValue:number, increment:number) =&gt; number =\r\n  function(x, y) { return x + y; };\r\n</pre>\n<p>This is called “contextual typing”, a form of type inference. This helps cut down on the amount of effort to keep your program typed.</p>\n<h2 id=\"optional-and-default-parameters\">Optional and Default Parameters</h2>\n<p>In TypeScript, every parameter is assumed to be required by the function. This doesn’t mean that it can’t be given <code>null</code> or <code>undefined</code>, but rather, when the function is called the compiler will check that the user has provided a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of arguments given to a function has to match the number of parameters the function expects.</p>\n<pre data-language=\"typescript\">function buildName(firstName: string, lastName: string) {\r\n  return firstName + \" \" + lastName;\r\n}\r\n\r\nlet result1 = buildName(\"Bob\");          // error, too few parameters\r\nlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\");  // error, too many parameters\r\nlet result3 = buildName(\"Bob\", \"Adams\");     // ah, just right\r\n</pre>\n<p>In JavaScript, every parameter is optional, and users may leave them off as they see fit. When they do, their value is <code>undefined</code>. We can get this functionality in TypeScript by adding a <code>?</code> to the end of parameters we want to be optional. For example, let’s say we want the last name parameter from above to be optional:</p>\n<pre data-language=\"typescript\">function buildName(firstName: string, lastName?: string) {\r\n  if (lastName)\r\n    return firstName + \" \" + lastName;\r\n  else\r\n    return firstName;\r\n}\r\n\r\nlet result1 = buildName(\"Bob\");          // works correctly now\r\nlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\");  // error, too many parameters\r\nlet result3 = buildName(\"Bob\", \"Adams\");     // ah, just right\r\n</pre>\n<p>Any optional parameters must follow required parameters. Had we wanted to make the first name optional rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list.</p>\n<p>In TypeScript, we can also set a value that a parameter will be assigned if the user does not provide one, or if the user passes <code>undefined</code> in its place. These are called default-initialized parameters. Let’s take the previous example and default the last name to <code>\"Smith\"</code>.</p>\n<pre data-language=\"typescript\">function buildName(firstName: string, lastName = \"Smith\") {\r\n  return firstName + \" \" + lastName;\r\n}\r\n\r\nlet result1 = buildName(\"Bob\");          // works correctly now, returns \"Bob Smith\"\r\nlet result2 = buildName(\"Bob\", undefined);     // still works, also returns \"Bob Smith\"\r\nlet result3 = buildName(\"Bob\", \"Adams\", \"Sr.\");  // error, too many parameters\r\nlet result4 = buildName(\"Bob\", \"Adams\");     // ah, just right\r\n</pre>\n<p>Default-initialized parameters that come after all required parameters are treated as optional, and just like optional parameters, can be omitted when calling their respective function. This means optional parameters and trailing default parameters will share commonality in their types, so both</p>\n<pre data-language=\"typescript\">function buildName(firstName: string, lastName?: string) {\r\n  // ...\r\n}\r\n</pre>\n<p>and</p>\n<pre data-language=\"typescript\">function buildName(firstName: string, lastName = \"Smith\") {\r\n  // ...\r\n}\r\n</pre>\n<p>share the same type <code>(firstName: string, lastName?: string) =&gt; string</code>. The default value of <code>lastName</code> disappears in the type, only leaving behind the fact that the parameter is optional.</p>\n<p>Unlike plain optional parameters, default-initialized parameters don’t <em>need</em> to occur after required parameters. If a default-initialized parameter comes before a required parameter, users need to explicitly pass <code>undefined</code> to get the default initialized value. For example, we could write our last example with only a default initializer on <code>firstName</code>:</p>\n<pre data-language=\"typescript\">function buildName(firstName = \"Will\", lastName: string) {\r\n  return firstName + \" \" + lastName;\r\n}\r\n\r\nlet result1 = buildName(\"Bob\");          // error, too few parameters\r\nlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\");  // error, too many parameters\r\nlet result3 = buildName(\"Bob\", \"Adams\");     // okay and returns \"Bob Adams\"\r\nlet result4 = buildName(undefined, \"Adams\");   // okay and returns \"Will Adams\"\r\n</pre>\n<h2 id=\"rest-parameters\">Rest Parameters</h2>\n<p>Required, optional, and default parameters all have one thing in common: they talk about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take. In JavaScript, you can work with the arguments directly using the <code>arguments</code> variable that is visible inside every function body.</p>\n<p>In TypeScript, you can gather these arguments together into a variable:</p>\n<pre data-language=\"typescript\">function buildName(firstName: string, ...restOfName: string[]) {\r\n  return firstName + \" \" + restOfName.join(\" \");\r\n}\r\n\r\nlet employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\");\r\n</pre>\n<p><em>Rest parameters</em> are treated as a boundless number of optional parameters. When passing arguments for a rest parameter, can use as many as you want; you can even pass none. The compiler will build an array of the arguments passed in with the name given after the ellipsis (<code>...</code>), allowing you to use it in your function.</p>\n<p>The ellipsis is also used in the type of the function with rest parameters:</p>\n<pre data-language=\"typescript\">function buildName(firstName: string, ...restOfName: string[]) {\r\n  return firstName + \" \" + restOfName.join(\" \");\r\n}\r\n\r\nlet buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName;\r\n</pre>\n<h2 id=\"lambdas-and-using-this\">Lambdas and using <code>this</code>\n</h2>\n<p>How <code>this</code> works in JavaScript functions is a common theme in programmers coming to JavaScript. Indeed, learning how to use it is something of a rite of passage as developers become more accustomed to working in JavaScript. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use <code>this</code> and how to spot when it’s not being used correctly. A whole article could be written on how to use <code>this</code> in JavaScript, and many have. Here, we’ll focus on some of the basics.</p>\n<p>In JavaScript, <code>this</code> is a variable that’s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This can be notoriously confusing when, for instance, a function is used as a callback.</p>\n<p>Let’s look at an example:</p>\n<pre data-language=\"typescript\">let deck = {\r\n  suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\r\n  cards: Array(52),\r\n  createCardPicker: function() {\r\n    return function() {\r\n      let pickedCard = Math.floor(Math.random() * 52);\r\n      let pickedSuit = Math.floor(pickedCard / 13);\r\n\r\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13};\r\n    }\r\n  }\r\n}\r\n\r\nlet cardPicker = deck.createCardPicker();\r\nlet pickedCard = cardPicker();\r\n\r\nalert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);\r\n</pre>\n<p>If we tried to run the example, we would get an error instead of the expected alert box. This is because the <code>this</code> being used in the function created by <code>createCardPicker</code> will be set to <code>window</code> instead of our <code>deck</code> object. This happens as a result of calling <code>cardPicker()</code>. Here, there is no dynamic binding for <code>this</code> other than Window. (note: under strict mode, this will be undefined rather than window).</p>\n<p>We can fix this by making sure the function is bound to the correct <code>this</code> before we return the function to be used later. This way, regardless of how its later used, it will still be able to see the original <code>deck</code> object.</p>\n<p>To fix this, we switch the function expression to use the arrow syntax (<code>() =&gt; {}</code>) rather than the JavaScript function expression. This will automatically capture the <code>this</code> available when the function is created rather than when it is invoked:</p>\n<pre data-language=\"typescript\">let deck = {\r\n  suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\r\n  cards: Array(52),\r\n  createCardPicker: function() {\r\n    // Notice: the line below is now a lambda, allowing us to capture `this` earlier\r\n    return () =&gt; {\r\n      let pickedCard = Math.floor(Math.random() * 52);\r\n      let pickedSuit = Math.floor(pickedCard / 13);\r\n\r\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13};\r\n    }\r\n  }\r\n}\r\n\r\nlet cardPicker = deck.createCardPicker();\r\nlet pickedCard = cardPicker();\r\n\r\nalert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);\r\n</pre>\n<p>For more information on ways to think about <code>this</code>, you can read Yehuda Katz’s <a href=\"http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/\">Understanding JavaScript Function Invocation and “this”</a>.</p>\n<h2 id=\"overloads\">Overloads</h2>\n<p>JavaScript is inherently a very dynamic language. It’s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.</p>\n<pre data-language=\"typescript\">let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];\r\n\r\nfunction pickCard(x): any {\r\n  // Check to see if we're working with an object/array\r\n  // if so, they gave us the deck and we'll pick the card\r\n  if (typeof x == \"object\") {\r\n    let pickedCard = Math.floor(Math.random() * x.length);\r\n    return pickedCard;\r\n  }\r\n  // Otherwise just let them pick the card\r\n  else if (typeof x == \"number\") {\r\n    let pickedSuit = Math.floor(x / 13);\r\n    return { suit: suits[pickedSuit], card: x % 13 };\r\n  }\r\n}\r\n\r\nlet myDeck = [{ suit: \"diamonds\", card: 2 }, { suit: \"spades\", card: 10 }, { suit: \"hearts\", card: 4 }];\r\nlet pickedCard1 = myDeck[pickCard(myDeck)];\r\nalert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);\r\n\r\nlet pickedCard2 = pickCard(15);\r\nalert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit);\r\n</pre>\n<p>Here the <code>pickCard</code> function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they’ve picked. But how do we describe this to the type system?</p>\n<p>The answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let’s create a list of overloads that describe what our <code>pickCard</code> accepts and what it returns.</p>\n<pre data-language=\"typescript\">let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];\r\n\r\nfunction pickCard(x: {suit: string; card: number; }[]): number;\r\nfunction pickCard(x: number): {suit: string; card: number; };\r\nfunction pickCard(x): any {\r\n  // Check to see if we're working with an object/array\r\n  // if so, they gave us the deck and we'll pick the card\r\n  if (typeof x == \"object\") {\r\n    let pickedCard = Math.floor(Math.random() * x.length);\r\n    return pickedCard;\r\n  }\r\n  // Otherwise just let them pick the card\r\n  else if (typeof x == \"number\") {\r\n    let pickedSuit = Math.floor(x / 13);\r\n    return { suit: suits[pickedSuit], card: x % 13 };\r\n  }\r\n}\r\n\r\nlet myDeck = [{ suit: \"diamonds\", card: 2 }, { suit: \"spades\", card: 10 }, { suit: \"hearts\", card: 4 }];\r\nlet pickedCard1 = myDeck[pickCard(myDeck)];\r\nalert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);\r\n\r\nlet pickedCard2 = pickCard(15);\r\nalert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit);\r\n</pre>\n<p>With this change, the overloads now give us type-checked calls to the <code>pickCard</code> function.</p>\n<p>In order for the compiler to pick the correct typecheck, it follows a similar process to the underlying JavaScript. It looks at the overload list, and proceeding with the first overload attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, its customary to order overloads from most specific to least specific.</p>\n<p>Note that the <code>function pickCard(x): any</code> piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling <code>pickCard</code> with any other parameter types would cause an error.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/functions.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/functions.html</a>\n  </p>\n</div>\n","handbook/advanced-types":"<h1 class=\"post-title\">Advanced Types</h1>\n\n<h2 id=\"union-types\">Union Types</h2>\n<p>Occasionally, you’ll run into a library that expects a parameter to be either a <code>number</code> or a <code>string</code>. For instance, take the following function:</p>\n<pre data-language=\"typescript\">/**\r\n * Takes a string and adds \"padding\" to the left.\r\n * If 'padding' is a string, then 'padding' is appended to the left side.\r\n * If 'padding' is a number, then that number of spaces is added to the left side.\r\n */\r\nfunction padLeft(value: string, padding: any) {\r\n  if (typeof padding === \"number\") {\r\n    return Array(padding).join(\" \") + value;\r\n  }\r\n  if (typeof padding === \"string\") {\r\n    return padding + value;\r\n  }\r\n  throw new Error(`Expected string or number, got '${value}'.`);\r\n}\r\n\r\npadLeft(\"Hello world\", 4); // returns \"  Hello world\"\r\n</pre>\n<p>The problem with <code>padLeft</code> is that its <code>padding</code> parameter is typed as <code>any</code>. That means that we can call it with an argument that’s neither a <code>number</code> nor a <code>string</code>, but TypeScript will be okay with it.</p>\n<pre data-language=\"typescript\">let indentedString = padLeft(\"Hello world\", true); // passes at compile time, fails at runtime.\r\n</pre>\n<p>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types. While this is much more explicit, it’s also a little bit overkill. One of the nice things about the original version of <code>padLeft</code> was that we were able to just pass in primitives. That meant that usage was simple and not overly verbose. This new approach also wouldn’t help if we were just trying to use a function that already exists elsewhere.</p>\n<p>Instead of <code>any</code>, we can use a <em>union type</em> for the <code>padding</code> parameter:</p>\n<pre data-language=\"typescript\">/**\r\n * Takes a string and adds \"padding\" to the left.\r\n * If 'padding' is a string, then 'padding' is appended to the left side.\r\n * If 'padding' is a number, then that number of spaces is added to the left side.\r\n */\r\nfunction padLeft(value: string, padding: string | number) {\r\n  // ...\r\n}\r\n\r\nlet indentedString = padLeft(\"Hello world\", true); // errors during compilation\r\n</pre>\n<p>A union type describes a value that can be one of several types. We use the vertical bar (<code>|</code>) to separate each type, so <code>number | string | boolean</code> is the type of a value that can be a <code>number</code>, a <code>string</code>, or a <code>boolean</code>.</p>\n<p>If we have a value that has a union type, we can only access members that are common to all types in the union.</p>\n<pre data-language=\"typescript\">interface Bird {\r\n  fly();\r\n  layEggs();\r\n}\r\n\r\ninterface Fish {\r\n  swim();\r\n  layEggs();\r\n}\r\n\r\nfunction getSmallPet(): Fish | Bird {\r\n  // ...\r\n}\r\n\r\nlet pet = getSmallPet();\r\npet.layEggs(); // okay\r\npet.swim();  // errors\r\n</pre>\n<p>Union types can be a bit tricky here, but it just takes a bit of intuition to get used to. If a value has the type <code>A | B</code>, we only know for <em>certain</em> that it has members that both <code>A</code> <em>and</em> <code>B</code> have. In this example, <code>Bird</code> has a member named <code>fly</code>. We can’t be sure whether a variable typed as <code>Bird | Fish</code> has a <code>fly</code> method. If the variable is really a <code>Fish</code> at runtime, then calling <code>pet.fly()</code> will fail.</p>\n<h2 id=\"type-guards-and-differentiating-types\">Type Guards and Differentiating Types</h2>\n<p>Union types are useful for modeling situations when values can overlap in the types they can take on. What happens when we need to know specifically whether we have a <code>Fish</code>? A common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member. As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.</p>\n<pre data-language=\"typescript\">let pet = getSmallPet();\r\n\r\n// Each of these property accesses will cause an error\r\nif (pet.swim) {\r\n  pet.swim();\r\n}\r\nelse if (pet.fly) {\r\n  pet.fly();\r\n}\r\n</pre>\n<p>To get the same code working, we’ll need to use a type assertion:</p>\n<pre data-language=\"typescript\">let pet = getSmallPet();\r\n\r\nif ((&lt;Fish&gt;pet).swim) {\r\n  (&lt;Fish&gt;pet).swim();\r\n}\r\nelse {\r\n  (&lt;Bird&gt;pet).fly();\r\n}\r\n</pre>\n<h2 id=\"user-defined-type-guards\">User-Defined Type Guards</h2>\n<p>Notice that we had to use type assertions several times. It would be much better if once we performed the check, we could know the type of <code>pet</code> within each branch.</p>\n<p>It just so happens that TypeScript has something called a <em>type guard</em>. A type guard is some expression that performs a runtime check that guarantees the type in some scope. To define a type guard, we simply need to define a function whose return type is a <em>type predicate</em>:</p>\n<pre data-language=\"typescript\">function isFish(pet: Fish | Bird): pet is Fish {\r\n  return (&lt;Fish&gt;pet).swim !== undefined;\r\n}\r\n</pre>\n<p><code>pet is Fish</code> is our type predicate in this example. A predicate takes the form <code>parameterName is Type</code>, where <code>parameterName</code> must be the name of a parameter from the current function signature.</p>\n<p>Any time <code>isFish</code> is called with some variable, TypeScript will <em>narrow</em> that variable to that specific type if the original type is compatible.</p>\n<pre data-language=\"typescript\">// Both calls to 'swim' and 'fly' are now okay.\r\n\r\nif (isFish(pet)) {\r\n  pet.swim();\r\n}\r\nelse {\r\n  pet.fly();\r\n}\r\n</pre>\n<p>Notice that TypeScript not only knows that <code>pet</code> is a <code>Fish</code> in the <code>if</code> branch; it also knows that in the <code>else</code> branch, you <em>don’t</em> have a <code>Fish</code>, so you must have a <code>Bird</code>.</p>\n<h2 id=\"typeof-type-guards\">\n<code>typeof</code> type guards</h2>\n<p>We didn’t actually discuss the implementation of the version of <code>padLeft</code> which used union types. We could write it with type predicates as follows:</p>\n<pre data-language=\"typescript\">function isNumber(x: any): x is number {\r\n  return typeof x === \"number\";\r\n}\r\n\r\nfunction isString(x: any): x is string {\r\n  return typeof x === \"string\";\r\n}\r\n\r\nfunction padLeft(value: string, padding: string | number) {\r\n  if (isNumber(padding)) {\r\n    return Array(padding).join(\" \") + value;\r\n  }\r\n  if (isString(padding)) {\r\n    return padding + value;\r\n  }\r\n  throw new Error(`Expected string or number, got '${value}'.`);\r\n}\r\n</pre>\n<p>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don’t need to abstract <code>typeof x === \"number\"</code> into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.</p>\n<pre data-language=\"typescript\">function padLeft(value: string, padding: string | number) {\r\n  if (typeof padding === \"number\") {\r\n    return Array(padding).join(\" \") + value;\r\n  }\r\n  if (typeof padding === \"string\") {\r\n    return padding + value;\r\n  }\r\n  throw new Error(`Expected string or number, got '${value}'.`);\r\n}\r\n</pre>\n<p>These <em><code>typeof</code> type guards</em> are recognized in two different forms: <code>typeof v === \"typename\"</code> and <code>typeof v !== \"typename\"</code>, where <code>\"typename\"</code> must be <code>\"number\"</code>, <code>\"string\"</code>, <code>\"boolean\"</code>, or <code>\"symbol\"</code>. While TypeScript won’t prohibit comparing to other strings, or switching the two sides of the comparison, the language won’t recognize those forms as type guards.</p>\n<h2 id=\"instanceof-type-guards\">\n<code>instanceof</code> type guards</h2>\n<p>If you’ve read about <code>typeof</code> type guards and are familiar with the <code>instanceof</code> operator in JavaScript, you probably have some idea of what this section is about.</p>\n<p><em><code>instanceof</code> type guards</em> are a way of narrowing types using their constructor function. For instance, let’s borrow our industrial string-padder example from earlier:</p>\n<pre data-language=\"typescript\">interface Padder {\r\n  getPaddingString(): string\r\n}\r\n\r\nclass SpaceRepeatingPadder implements Padder {\r\n  constructor(private numSpaces: number) { }\r\n  getPaddingString() {\r\n    return Array(this.numSpaces).join(\" \");\r\n  }\r\n}\r\n\r\nclass StringPadder implements Padder {\r\n  constructor(private value: string) { }\r\n  getPaddingString() {\r\n    return this.value;\r\n  }\r\n}\r\n\r\nfunction getRandomPadder() {\r\n  return Math.random() &lt; 0.5 ?\r\n    new SpaceRepeatingPadder(4) :\r\n    new StringPadder(\"  \");\r\n}\r\n\r\n// Type is SpaceRepeatingPadder | StringPadder\r\nlet padder: Padding = getRandomPadder();\r\n\r\nif (padder instanceof SpaceRepeatingPadder) {\r\n  padder; // type narrowed to 'SpaceRepeatingPadder'\r\n}\r\nif (padder instanceof StringPadder) {\r\n  padder; // type narrowed to 'StringPadder'\r\n}\r\n</pre>\n<p>The right side of the <code>instanceof</code> needs to be a constructor function, and TypeScript will narrow down to:</p>\n<ol>\n<li>the type of the function’s <code>prototype</code> property if its type is not <code>any</code>\n</li>\n<li>the union of types returned by that type’s construct signatures</li>\n</ol>\n<p>in that order.</p>\n<h2 id=\"intersection-types\">Intersection Types</h2>\n<p>Intersection types are closely related to union types, but they are used very differently. An intersection type, <code>Person &amp; Serializable &amp; Loggable</code>, for example, is a <code>Person</code> <em>and</em> <code>Serializable</code> <em>and</em> <code>Loggable</code>. That means an object of this type will have all members of all three types. In practice you will mostly see intersection types used for mixins. Here’s a simple mixin example:</p>\n<pre data-language=\"typescript\">function extend&lt;T, U&gt;(first: T, second: U): T &amp; U {\r\n  let result = &lt;T &amp; U&gt; {};\r\n  for (let id in first) {\r\n    result[id] = first[id];\r\n  }\r\n  for (let id in second) {\r\n    if (!result.hasOwnProperty(id)) {\r\n      result[id] = second[id];\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nclass Person {\r\n  constructor(public name: string) { }\r\n}\r\ninterface Loggable {\r\n  log(): void;\r\n}\r\nvar jim = extend(new Person(\"Jim\"), new ConsoleLogger());\r\nvar n = jim.name;\r\njim.log();\r\n</pre>\n<h2 id=\"type-aliases\">Type Aliases</h2>\n<p>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you’d otherwise have to write by hand.</p>\n<pre data-language=\"typescript\">type Name = string;\r\ntype NameResolver = () =&gt; string;\r\ntype NameOrResolver = Name | NameResolver;\r\nfunction getName(n: NameOrResolver): Name {\r\n  if (typeof n === 'string') {\r\n    return n;\r\n  }\r\n  else {\r\n    return n();\r\n  }\r\n}\r\n</pre>\n<p>Aliasing doesn’t actually create a new type - it creates a new <em>name</em> to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.</p>\n<p>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</p>\n<pre data-language=\"typescript\">type Container&lt;T&gt; = { value: T };\r\n</pre>\n<p>We can also have a type alias refer to itself in a property:</p>\n<pre data-language=\"typescript\">type Tree&lt;T&gt; = {\r\n  value: T;\r\n  left: Tree&lt;T&gt;;\r\n  right: Tree&lt;T&gt;;\r\n}\r\n</pre>\n<p>Together with intersection types, we can make some pretty mind-bending types:</p>\n<pre data-language=\"typescript\">type LinkedList&lt;T&gt; = T &amp; { next: LinkedList&lt;T&gt; };\r\n\r\ninterface Person {\r\n  name: string;\r\n}\r\n\r\nvar people: LinkedList&lt;Person&gt;;\r\nvar s = people.name;\r\nvar s = people.next.name;\r\nvar s = people.next.next.name;\r\nvar s = people.next.next.next.name;\r\n</pre>\n<p>However, it’s not possible for a type alias to appear anywhere else on the right side of the declaration:</p>\n<pre data-language=\"typescript\">type Yikes = Array&lt;Yikes&gt;; // error\r\n</pre>\n<h2 id=\"interfaces-vs-type-aliases\">Interfaces vs. Type Aliases</h2>\n<p>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</p>\n<p>One important difference is that type aliases cannot be extended or implemented from (nor can they extend/implement other types). Because <a href=\"https://en.wikipedia.org/wiki/Open/closed_principle\">an ideal property of software is being open to extension</a>, you should always use an interface over a type alias if possible.</p>\n<p>On the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</p>\n<h2 id=\"string-literal-types\">String Literal Types</h2>\n<p>String literal types allow you to specify the exact value a string must have. In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</p>\n<pre data-language=\"typescript\">type Easing = \"ease-in\" | \"ease-out\" | \"ease-in-out\";\r\nclass UIElement {\r\n  animate(dx: number, dy: number, easing: Easing) {\r\n    if (easing === \"ease-in\") {\r\n      // ...\r\n    }\r\n    else if (easing === \"ease-out\") {\r\n    }\r\n    else if (easing === \"ease-in-out\") {\r\n    }\r\n    else {\r\n      // error! should not pass null or undefined.\r\n    }\r\n  }\r\n}\r\n\r\nlet button = new UIElement();\r\nbutton.animate(0, 0, \"ease-in\");\r\nbutton.animate(0, 0, \"uneasy\"); // error: \"uneasy\" is not allowed here\r\n</pre>\n<p>You can pass any of the three allowed strings, but any other string will give the error</p>\n<pre data-language=\"text\">Argument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\r\n</pre>\n<p>String literal types can be used in the same way to distinguish overloads:</p>\n<pre data-language=\"typescript\">function createElement(tagName: \"img\"): HTMLImageElement;\r\nfunction createElement(tagName: \"input\"): HTMLInputElement;\r\n// ... more overloads ...\r\nfunction createElement(tagName: string): Element {\r\n  // ... code goes here ...\r\n}\r\n</pre>\n<h2 id=\"polymorphic-this-types\">Polymorphic <code>this</code> types</h2>\n<p>A polymorphic <code>this</code> type represents a type that is the <em>subtype</em> of the containing class or interface. This is called <em>F</em>-bounded polymorphism. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns <code>this</code> after each operation:</p>\n<pre data-language=\"typescript\">class BasicCalculator {\r\n  public constructor(protected value: number = 0) { }\r\n  public currentValue(): number {\r\n    return this.value;\r\n  }\r\n  public add(operand: number): this {\r\n    this.value += operand;\r\n    return this;\r\n  }\r\n  public multiply(operand: number): this {\r\n    this.value *= operand;\r\n    return this;\r\n  }\r\n  // ... other operations go here ...\r\n}\r\n\r\nlet v = new BasicCalculator(2)\r\n      .multiply(5)\r\n      .add(1)\r\n      .currentValue();\r\n</pre>\n<p>Since the class uses <code>this</code> types, you can extend it and the new class can use the old methods with no changes.</p>\n<pre data-language=\"typescript\">class ScientificCalculator extends BasicCalculator {\r\n  public constructor(value = 0) {\r\n    super(value);\r\n  }\r\n  public sin() {\r\n    this.value = Math.sin(this.value);\r\n    return this;\r\n  }\r\n  // ... other operations go here ...\r\n}\r\n\r\nlet v = new ScientificCalculator(2)\r\n    .multiply(5)\r\n    .sin()\r\n    .add(1)\r\n    .currentValue();\r\n</pre>\n<p>Without <code>this</code> types, <code>ScientificCalculator</code> would not have been able to extend <code>BasicCalculator</code> and keep the fluent interface. <code>multiply</code> would have returned <code>BasicCalculator</code>, which doesn’t have the <code>sin</code> method. However, with <code>this</code> types, <code>multiply</code> returns <code>this</code>, which is <code>ScientificCalculator</code> here.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/advanced-types.html</a>\n  </p>\n</div>\n","handbook/symbols":"<h1 class=\"post-title\">Symbols</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>Starting with ECMAScript 2015, <code>symbol</code> is a primitive data type, just like <code>number</code> and <code>string</code>.</p>\n<p><code>symbol</code> values are created by calling the <code>Symbol</code> constructor.</p>\n<pre data-language=\"typescript\">let sym1 = Symbol();\r\n\r\nlet sym2 = Symbol(\"key\"); // optional string key\r\n</pre>\n<p>Symbols are immutable, and unique.</p>\n<pre data-language=\"typescript\">let sym2 = Symbol(\"key\");\r\nlet sym3 = Symbol(\"key\");\r\n\r\nsym2 === sym3; // false, symbols are unique\r\n</pre>\n<p>Just like strings, symbols can be used as keys for object properties.</p>\n<pre data-language=\"typescript\">let sym = Symbol();\r\n\r\nlet obj = {};\r\n\r\nobj[sym] = \"value\";\r\nconsole.log(obj[sym]); // \"value\"\r\n</pre>\n<p>Symbols can also be combined with computed property declarations to declare object properties and class members.</p>\n<pre data-language=\"typescript\">const getClassNameSymbol = Symbol();\r\n\r\nclass C {\r\n  [getClassNameSymbol](){\r\n     return \"C\";\r\n  }\r\n}\r\n\r\nlet c = new C();\r\nlet className = c[getClassNameSymbol](); // \"C\"\r\n</pre>\n<h2 id=\"well-known-symbols\">Well-known Symbols</h2>\n<p>In addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.</p>\n<p>Here is a list of well-known symbols:</p>\n<h2 id=\"symbolhasinstance\"><code>Symbol.hasInstance</code></h2>\n<p>A method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the instanceof operator.</p>\n<h2 id=\"symbolisconcatspreadable\"><code>Symbol.isConcatSpreadable</code></h2>\n<p>A Boolean value indicating that an object should be flatten to its array elements by Array.prototype.concat.</p>\n<h2 id=\"symboliterator\"><code>Symbol.iterator</code></h2>\n<p>A method that returns the default iterator for an object. Called by the semantics of the for-of statement.</p>\n<h2 id=\"symbolmatch\"><code>Symbol.match</code></h2>\n<p>A regular expression method that matches the regular expression against a string. Called by the <code>String.prototype.match</code> method.</p>\n<h2 id=\"symbolreplace\"><code>Symbol.replace</code></h2>\n<p>A regular expression method that replaces matched substrings of a string. Called by the <code>String.prototype.replace</code> method.</p>\n<h2 id=\"symbolsearch\"><code>Symbol.search</code></h2>\n<p>A regular expression method that returns the index within a string that matches the regular expression. Called by the <code>String.prototype.search</code> method.</p>\n<h2 id=\"symbolspecies\"><code>Symbol.species</code></h2>\n<p>A function valued property that is the constructor function that is used to create derived objects.</p>\n<h2 id=\"symbolsplit\"><code>Symbol.split</code></h2>\n<p>A regular expression method that splits a string at the indices that match the regular expression. Called by the <code>String.prototype.split</code> method.</p>\n<h2 id=\"symboltoprimitive\"><code>Symbol.toPrimitive</code></h2>\n<p>A method that converts an object to a corresponding primitive value. Called by the <code>ToPrimitive</code> abstract operation.</p>\n<h2 id=\"symboltostringtag\"><code>Symbol.toStringTag</code></h2>\n<p>A String value that is used in the creation of the default string description of an object. Called by the built-in method <code>Object.prototype.toString</code>.</p>\n<h2 id=\"symbolunscopables\"><code>Symbol.unscopables</code></h2>\n<p>An Object whose own property names are property names that are excluded from the ‘with’ environment bindings of the associated objects.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/symbols.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/symbols.html</a>\n  </p>\n</div>\n","handbook/basic-types":"<h1 class=\"post-title\">Basic Types</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support much the same types as you would expected in JavaScript, with a convenient enumeration type thrown in to help things along.</p>\n<h2 id=\"boolean\">Boolean</h2>\n<p>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a <code>boolean</code> value.</p>\n<pre data-language=\"typescript\">let isDone: boolean = false;\r\n</pre>\n<h2 id=\"number\">Number</h2>\n<p>As in JavaScript, all numbers in TypeScript are floating point values. These floating point numbers get the type <code>number</code>. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.</p>\n<pre data-language=\"typescript\">let decimal: number = 6;\r\nlet hex: number = 0xf00d;\r\nlet binary: number = 0b1010;\r\nlet octal: number = 0o744;\r\n</pre>\n<h2 id=\"string\">String</h2>\n<p>Another fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data. As in other languages, we use the type <code>string</code> to refer to these textual datatypes. Just like JavaScript, TypeScript also uses the double quote (<code>\"</code>) or single quote (<code>'</code>) to surround string data.</p>\n<pre data-language=\"typescript\">let name: string = \"bob\";\r\nname = 'smith';\r\n</pre>\n<p>You can also use <em>template strings</em>, which can span multiple lines and have embedded expressions. These strings are surrounded by the backtick/backquote (<code>`</code>) character, and embedded expressions are of the form <code>${ expr }</code></p>\n<pre data-language=\"typescript\">let name: string = `Gene`;\r\nlet age: number = 37;\r\nlet sentence: string = `Hello, my name is ${ name }.\r\n\r\nI'll be ${ age + 1 } years old next month.`\r\n</pre>\n<p>This is equivalent to declaring <code>sentence</code> like so:</p>\n<pre data-language=\"typescript\">let sentence: string = \"Hello, my name is \" + name + \".\\n\\n\" +\r\n  \"I'll be \" + (age + 1) + \" years old next month.\"\r\n</pre>\n<h2 id=\"array\">Array</h2>\n<p>TypeScript, like JavaScript, allows you to work with arrays of values. Array types can be written in one of two ways. In the first, you use the type of the elements followed by <code>[]</code> to denote an array of that element type:</p>\n<pre data-language=\"typescript\">let list: number[] = [1, 2, 3];\r\n</pre>\n<p>The second way uses a generic array type, <code>Array&lt;elemType&gt;</code>:</p>\n<pre data-language=\"typescript\">let list: Array&lt;number&gt; = [1, 2, 3];\r\n</pre>\n<h2 id=\"tuple\">Tuple</h2>\n<p>Tuple types allow you to express an array where the type of a fixed number of elements is known, but need not be the same. For example, you may want to represent a value as a pair of a <code>string</code> and a <code>number</code>:</p>\n<pre data-language=\"typescript\">// Declare a tuple type\r\nlet x: [string, number];\r\n// Initialize it\r\nx = ['hello', 10]; // OK\r\n// Initialize it incorrectly\r\nx = [10, 'hello']; // Error\r\n</pre>\n<p>When accessing an element with a known index, the correct type is retrieved:</p>\n<pre data-language=\"typescript\">console.log(x[0].substr(1)); // OK\r\nconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr'\r\n</pre>\n<p>When accessing an element outside the set of known indices, a union type is used instead:</p>\n<pre data-language=\"typescript\">x[3] = 'world'; // OK, string can be assigned to (string | number)\r\n\r\nconsole.log(x[5].toString()); // OK, 'string' and 'number' both have toString\r\n\r\nx[6] = true; // Error, boolean isn't (string | number)\r\n</pre>\n<p>Union types are an advanced topic that we’ll cover in a later chapter.</p>\n<h2 id=\"enum\">Enum</h2>\n<p>A helpful addition to the standard set of datatypes from JavaScript is the <code>enum</code>. As in languages like C#, an enum is a way of giving more friendly names to sets of numeric values.</p>\n<pre data-language=\"typescript\">enum Color {Red, Green, Blue};\r\nlet c: Color = Color.Green;\r\n</pre>\n<p>By default, enums begin numbering their members starting at <code>0</code>. You can change this by manually setting the value of one of its members. For example, we can start the previous example at <code>1</code> instead of <code>0</code>:</p>\n<pre data-language=\"typescript\">enum Color {Red = 1, Green, Blue};\r\nlet c: Color = Color.Green;\r\n</pre>\n<p>Or, even manually set all the values in the enum:</p>\n<pre data-language=\"typescript\">enum Color {Red = 1, Green = 2, Blue = 4};\r\nlet c: Color = Color.Green;\r\n</pre>\n<p>A handy feature of enums is that you can also go from a numeric value to the name of that value in the enum. For example, if we had the value <code>2</code> but weren’t sure what that mapped to in the <code>Color</code> enum above, we could look up the corresponding name:</p>\n<pre data-language=\"typescript\">enum Color {Red = 1, Green, Blue};\r\nlet colorName: string = Color[2];\r\n\r\nalert(colorName);\r\n</pre>\n<h2 id=\"any\">Any</h2>\n<p>We may need to describe the type of variables that we do not know when we are writing an application. These values may come from dynamic content, e.g. from the user or a 3rd party library. In these cases, we want to opt-out of type-checking and let the values pass through compile-time checks. To do so, we label these with the <code>any</code> type:</p>\n<pre data-language=\"typescript\">let notSure: any = 4;\r\nnotSure = \"maybe a string instead\";\r\nnotSure = false; // okay, definitely a boolean\r\n</pre>\n<p>The <code>any</code> type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type-checking during compilation. You might expect <code>Object</code> to play a similar role, as it does in other languages. But variables of type <code>Object</code> only allow you to assign any value to them – you can’t call arbitrary methods on them, even ones that actually exist:</p>\n<pre data-language=\"typescript\">let notSure: any = 4;\r\nnotSure.ifItExists(); // okay, ifItExists might exist at runtime\r\nnotSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)\r\n\r\nlet prettySure: Object = 4;\r\nprettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.\r\n</pre>\n<p>The <code>any</code> type is also handy if you know some part of the type, but perhaps not all of it. For example, you may have an array but the array has a mix of different types:</p>\n<pre data-language=\"typescript\">let list: any[] = [1, true, \"free\"];\r\n\r\nlist[1] = 100;\r\n</pre>\n<h2 id=\"void\">Void</h2>\n<p><code>void</code> is a little like the opposite of <code>any</code>: the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:</p>\n<pre data-language=\"typescript\">function warnUser(): void {\r\n  alert(\"This is my warning message\");\r\n}\r\n</pre>\n<p>Declaring variables of type <code>void</code> is not useful because you can only assign <code>undefined</code> or <code>null</code> to them:</p>\n<pre data-language=\"typescript\">let unusable: void = undefined;\r\n</pre>\n<h2 id=\"type-assertions\">Type assertions</h2>\n<p>Sometimes you’ll end up in a situation where you’ll know more about a value than TypeScript does. Usually this will happen when you know the type of some entity could be more specific than its current type.</p>\n<p><em>Type assertions</em> are a way to tell the compiler “trust me, I know what I’m doing.” A type assertion is like a type cast in other languages, but performs no special checking or restructuring of data. It has has no runtime impact, and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.</p>\n<p>Type assertions have two forms. One is the “angle-bracket” syntax:</p>\n<pre data-language=\"typescript\">let someValue: any = \"this is a string\";\r\n\r\nlet strLength: number = (&lt;string&gt;someValue).length;\r\n</pre>\n<p>And the other is the <code>as</code>-syntax:</p>\n<pre data-language=\"typescript\">let someValue: any = \"this is a string\";\r\n\r\nlet strLength: number = (someValue as string).length;\r\n</pre>\n<p>The two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only <code>as</code>-style assertions are allowed.</p>\n<h2 id=\"a-note-about-let\">A note about <code>let</code>\n</h2>\n<p>You may’ve noticed that so far, we’ve been using the <code>let</code> keyword instead of JavaScript’s <code>var</code> keyword which you might be more familiar with. The <code>let</code> keyword is actually a newer JavaScript construct that TypeScript makes available. We’ll discuss the details later, but many common problems in JavaScript are alleviated by using <code>let</code>, so you should use it instead of <code>var</code> whenever possible.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/basic-types.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/basic-types.html</a>\n  </p>\n</div>\n","handbook/interfaces":"<h1 class=\"post-title\">Interfaces</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>One of TypeScript’s core principles is that type-checking focuses on the <em>shape</em> that values have. This is sometimes called “duck typing” or “structural subtyping”. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</p>\n<h2 id=\"our-first-interface\">Our First Interface</h2>\n<p>The easiest way to see how interfaces work is to start with a simple example:</p>\n<pre data-language=\"typescript\">function printLabel(labelledObj: { label: string }) {\r\n  console.log(labelledObj.label);\r\n}\r\n\r\nlet myObj = {size: 10, label: \"Size 10 Object\"};\r\nprintLabel(myObj);\r\n</pre>\n<p>The type-checker checks the call to <code>printLabel</code>. The <code>printLabel</code> function has a single parameter that requires that the object passed in has a property called <code>label</code> of type string. Notice that our object actually has more properties than this, but the compiler only checks that <em>at least</em> the ones required are present and match the types required. There are some cases where TypeScript isn’t as lenient, which we’ll cover in a bit.</p>\n<p>We can write the same example again, this time using an interface to describe the requirement of having the <code>label</code> property that is a string:</p>\n<pre data-language=\"typescript\">interface LabelledValue {\r\n  label: string;\r\n}\r\n\r\nfunction printLabel(labelledObj: LabelledValue) {\r\n  console.log(labelledObj.label);\r\n}\r\n\r\nlet myObj = {size: 10, label: \"Size 10 Object\"};\r\nprintLabel(myObj);\r\n</pre>\n<p>The interface <code>LabelledValue</code> is a name we can now use to describe the requirement in the previous example. It still represents having a single property called <code>label</code> that is of type string. Notice we didn’t have to explicitly say that the object we pass to <code>printLabel</code> implements this interface like we might have to in other languages. Here, it’s only the shape that matters. If the object we pass to the function meets the requirements listed, then it’s allowed.</p>\n<p>It’s worth pointing out that the type-checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.</p>\n<h2 id=\"optional-properties\">Optional Properties</h2>\n<p>Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like “option bags” where you pass an object to a function that only has a couple of properties filled in.</p>\n<p>Here’s an example of this pattern:</p>\n<pre data-language=\"typescript\">interface SquareConfig {\r\n  color?: string;\r\n  width?: number;\r\n}\r\n\r\nfunction createSquare(config: SquareConfig): {color: string; area: number} {\r\n  let newSquare = {color: \"white\", area: 100};\r\n  if (config.color) {\r\n    newSquare.color = config.color;\r\n  }\r\n  if (config.width) {\r\n    newSquare.area = config.width * config.width;\r\n  }\r\n  return newSquare;\r\n}\r\n\r\nlet mySquare = createSquare({color: \"black\"});\r\n</pre>\n<p>Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a <code>?</code> at the end of the property name in the declaration.</p>\n<p>The advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface. For example, had we mistyped the name of the <code>color</code> property in <code>createSquare</code>, we would get an error message letting us know:</p>\n<pre data-language=\"typescript\">interface SquareConfig {\r\n  color?: string;\r\n  width?: number;\r\n}\r\n\r\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\r\n  let newSquare = {color: \"white\", area: 100};\r\n  if (config.color) {\r\n    // Error: Property 'collor' does not exist on type 'SquareConfig'\r\n    newSquare.color = config.collor;\r\n  }\r\n  if (config.width) {\r\n    newSquare.area = config.width * config.width;\r\n  }\r\n  return newSquare;\r\n}\r\n\r\nlet mySquare = createSquare({color: \"black\"});\r\n</pre>\n<h2 id=\"excess-property-checks\">Excess Property Checks</h2>\n<p>In our first example using interfaces, TypeScript let us pass <code>{ size: number; label: string; }</code> to something that only expected a <code>{ label: string; }</code>. We also just learned about optional properties, and how they’re useful when describing so-called “option bags”.</p>\n<p>However, combining the two naively would let you to shoot yourself in the foot the same way you might in JavaScript. For example, taking our last example using <code>createSquare</code>:</p>\n<pre data-language=\"typescript\">interface SquareConfig {\r\n  color?: string;\r\n  width?: number;\r\n}\r\n\r\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\r\n  // ...\r\n}\r\n\r\nlet mySquare = createSquare({ colour: \"red\", width: 100 });\r\n</pre>\n<p>Notice the given argument to <code>createSquare</code> is spelled <em><code>colour</code></em> instead of <code>color</code>. In plain JavaScript, this sort of thing fails silently.</p>\n<p>You could argue that this program is correctly typed, since the <code>width</code> properties are compatible, there’s no <code>color</code> property present, and the extra <code>colour</code> property is insignificant.</p>\n<p>However, TypeScript takes the stance that there’s probably a bug in this code. Object literals get special treatment and undergo <em>excess property checking</em> when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the “target type” doesn’t have, you’ll get an error.</p>\n<pre data-language=\"typescript\">// error: 'colour' not expected in type 'SquareConfig'\r\nlet mySquare = createSquare({ colour: \"red\", width: 100 });\r\n</pre>\n<p>Getting around these checks is actually really simple. The best and easiest method is to just use a type assertion:</p>\n<pre data-language=\"typescript\">let mySquare = createSquare({ colour: \"red\", width: 100 } as SquareConfig);\r\n</pre>\n<p>Another approach, which might be a bit surprising, is to assign the object to another variable:</p>\n<pre data-language=\"typescript\">let squareOptions = { colour: \"red\", width: 100 };\r\nlet mySquare = createSquare(squareOptions);\r\n</pre>\n<p>Since <code>squareOptions</code> won’t undergo excess property checks, the compiler won’t give you an error.</p>\n<p>Keep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it’s okay to pass an object with both a <code>color</code> or <code>colour</code> property to <code>createSquare</code>, you should fix up the definition of <code>SquareConfig</code> to reflect that.</p>\n<h2 id=\"function-types\">Function Types</h2>\n<p>Interfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.</p>\n<p>To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.</p>\n<pre data-language=\"typescript\">interface SearchFunc {\r\n  (source: string, subString: string): boolean;\r\n}\r\n</pre>\n<p>Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.</p>\n<pre data-language=\"typescript\">let mySearch: SearchFunc;\r\nmySearch = function(source: string, subString: string) {\r\n  let result = source.search(subString);\r\n  if (result == -1) {\r\n    return false;\r\n  }\r\n  else {\r\n    return true;\r\n  }\r\n}\r\n</pre>\n<p>For function types to correctly type-check, the name of the parameters do not need to match. We could have, for example, written the above example like this:</p>\n<pre data-language=\"typescript\">let mySearch: SearchFunc;\r\nmySearch = function(src: string, sub: string): boolean {\r\n  let result = src.search(sub);\r\n  if (result == -1) {\r\n    return false;\r\n  }\r\n  else {\r\n    return true;\r\n  }\r\n}\r\n</pre>\n<p>Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. If you do not want to specify types at all, Typescript’s contextual typing can infer the argument types since the function value is assigned directly to a variable of type <code>SearchFunc</code>. Here, also, the return type of our function expression is implied by the values it returns (here <code>false</code> and <code>true</code>). Had the function expression returned numbers or strings, the type-checker would have warned us that return type doesn’t match the return type described in the <code>SearchFunc</code> interface.</p>\n<pre data-language=\"typescript\">let mySearch: SearchFunc;\r\nmySearch = function(src, sub) {\r\n  let result = src.search(sub);\r\n  if (result == -1) {\r\n    return false;\r\n  }\r\n  else {\r\n    return true;\r\n  }\r\n}\r\n</pre>\n<h2 id=\"array-types\">Array Types</h2>\n<p>Similarly to how we can use interfaces to describe function types, we can also describe array types. Array types have an <code>index</code> type that describes the types allowed to index the object, along with the corresponding return type for accessing the index.</p>\n<pre data-language=\"typescript\">interface StringArray {\r\n  [index: number]: string;\r\n}\r\n\r\nlet myArray: StringArray;\r\nmyArray = [\"Bob\", \"Fred\"];\r\n</pre>\n<p>There are two types of supported index types: string and number. It is possible to support both types of indexers, with the restriction that the type returned from the numeric indexer must be a subtype of the type returned from the string indexer.</p>\n<p>While string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that <code>obj.property</code> is also available as <code>obj[\"property\"]</code>. In this example, <code>name</code>’s type does not match the string index’s type, and the type-checker gives an error:</p>\n<pre data-language=\"typescript\">interface NumberDictionary {\r\n  [index: string]: number;\r\n  length: number;  // ok, length is a number\r\n  name: string;    // error, the type of 'name' is not a subtype of the indexer\r\n}\r\n</pre>\n<h2 id=\"class-types\">Class Types</h2>\n<h2 id=\"implementing-an-interface\">Implementing an interface</h2>\n<p>One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.</p>\n<pre data-language=\"typescript\">interface ClockInterface {\r\n  currentTime: Date;\r\n}\r\n\r\nclass Clock implements ClockInterface {\r\n  currentTime: Date;\r\n  constructor(h: number, m: number) { }\r\n}\r\n</pre>\n<p>You can also describe methods in an interface that are implemented in the class, as we do with <code>setTime</code> in the below example:</p>\n<pre data-language=\"typescript\">interface ClockInterface {\r\n  currentTime: Date;\r\n  setTime(d: Date);\r\n}\r\n\r\nclass Clock implements ClockInterface {\r\n  currentTime: Date;\r\n  setTime(d: Date) {\r\n    this.currentTime = d;\r\n  }\r\n  constructor(h: number, m: number) { }\r\n}\r\n</pre>\n<p>Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.</p>\n<h2 id=\"difference-between-the-static-and-instance-sides-of-classes\">Difference between the static and instance sides of classes</h2>\n<p>When working with classes and interfaces, it helps to keep in mind that a class has <em>two</em> types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:</p>\n<pre data-language=\"typescript\">interface ClockConstructor {\r\n  new (hour: number, minute: number);\r\n}\r\n\r\nclass Clock implements ClockConstructor {\r\n  currentTime: Date;\r\n  constructor(h: number, m: number) { }\r\n}\r\n</pre>\n<p>This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.</p>\n<p>Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, <code>ClockConstructor</code> for the constructor and <code>ClockInterface</code> for the instance methods. Then for convenience we define a constructor function <code>createClock</code> that creates instances of the type that is passed to it.</p>\n<pre data-language=\"typescript\">interface ClockConstructor {\r\n  new (hour: number, minute: number): ClockInterface;\r\n}\r\ninterface ClockInterface {\r\n  tick();\r\n}\r\n\r\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\r\n  return new ctor(hour, minute);\r\n}\r\n\r\nclass DigitalClock implements ClockInterface {\r\n  constructor(h: number, m: number) { }\r\n  tick() {\r\n    console.log(\"beep beep\");\r\n  }\r\n}\r\nclass AnalogClock implements ClockInterface {\r\n  constructor(h: number, m: number) { }\r\n  tick() {\r\n    console.log(\"tick tock\");\r\n  }\r\n}\r\n\r\nlet digital = createClock(DigitalClock, 12, 17);\r\nlet analog = createClock(AnalogClock, 7, 32);\r\n</pre>\n<p>Because <code>createClock</code>’s first parameter is of type <code>ClockConstructor</code>, in <code>createClock(AnalogClock, 12, 17)</code>, it checks that <code>AnalogClock</code> has the correct constructor signature.</p>\n<h2 id=\"extending-interfaces\">Extending Interfaces</h2>\n<p>Like classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.</p>\n<pre data-language=\"typescript\">interface Shape {\r\n  color: string;\r\n}\r\n\r\ninterface Square extends Shape {\r\n  sideLength: number;\r\n}\r\n\r\nlet square = &lt;Square&gt;{};\r\nsquare.color = \"blue\";\r\nsquare.sideLength = 10;\r\n</pre>\n<p>An interface can extend multiple interfaces, creating a combination of all of the interfaces.</p>\n<pre data-language=\"typescript\">interface Shape {\r\n  color: string;\r\n}\r\n\r\ninterface PenStroke {\r\n  penWidth: number;\r\n}\r\n\r\ninterface Square extends Shape, PenStroke {\r\n  sideLength: number;\r\n}\r\n\r\nlet square = &lt;Square&gt;{};\r\nsquare.color = \"blue\";\r\nsquare.sideLength = 10;\r\nsquare.penWidth = 5.0;\r\n</pre>\n<h2 id=\"hybrid-types\">Hybrid Types</h2>\n<p>As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript. Because of JavaScript’s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above.</p>\n<p>One such example is an object that acts as both a function and an object, with additional properties:</p>\n<pre data-language=\"typescript\">interface Counter {\r\n  (start: number): string;\r\n  interval: number;\r\n  reset(): void;\r\n}\r\n\r\nfunction getCounter(): Counter {\r\n  let counter = &lt;Counter&gt;function (start: number) { };\r\n  counter.interval = 123;\r\n  counter.reset = function () { };\r\n  return counter;\r\n}\r\n\r\nlet c = getCounter();\r\nc(10);\r\nc.reset();\r\nc.interval = 5.0;\r\n</pre>\n<p>When interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully describe the shape of the type.</p>\n<h2 id=\"interfaces-extending-classes\">Interfaces Extending Classes</h2>\n<p>When an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it.</p>\n<p>This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don’t have to be related besides inheriting from the base class. For example:</p>\n<pre data-language=\"typescript\">class Control {\r\n  private state: any;\r\n}\r\n\r\ninterface SelectableControl extends Control {\r\n  select(): void;\r\n}\r\n\r\nclass Button extends Control {\r\n  select() { }\r\n}\r\n\r\nclass TextBox extends Control {\r\n  select() { }\r\n}\r\n\r\nclass Image extends Control {\r\n}\r\n\r\nclass Location {\r\n  select() { }\r\n}\r\n</pre>\n<p>In the above example, ‘SelectableControl’ contains all of the members of ‘Control’, including the private ‘state’ property. Since ‘state’ is a private member it is only possible for descendants of ‘Control’ to implement ‘SelectableControl’. This is because only descendants of ‘Control’ will have a ‘state’ private member that originates in the same declaration, which is a requirement for private members to be compatible.</p>\n<p>Within the ‘Control’ class it is possible to access the ‘state’ private member through an instance of ‘SelectableControl’. Effectively, a ‘SelectableControl’ acts like a ‘Control’ that is known to have a ‘select’ method. The ‘Button’ and ‘TextBox’ classes are subtypes of ‘SelectableControl’ (because they both inherit from ‘Control’ and have a ‘select’ method), but the ‘Image’ and ‘Location’ classes are not.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/interfaces.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/interfaces.html</a>\n  </p>\n</div>\n","handbook/classes":"<h1 class=\"post-title\">Classes</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>Traditional JavaScript focuses on functions and prototype-based inheritance as the basic means of building up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers will be able to build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</p>\n<h2 id=\"classes\">Classes</h2>\n<p>Let’s take a look at a simple class-based example:</p>\n<pre data-language=\"typescript\">class Greeter {\r\n  greeting: string;\r\n  constructor(message: string) {\r\n    this.greeting = message;\r\n  }\r\n  greet() {\r\n    return \"Hello, \" + this.greeting;\r\n  }\r\n}\r\n\r\nlet greeter = new Greeter(\"world\");\r\n</pre>\n<p>The syntax should look familiar if you’ve used C# or Java before. We declare a new class <code>Greeter</code>. This class has three members: a property called <code>greeting</code>, a constructor, and a method <code>greet</code>.</p>\n<p>You’ll notice that in the class when we refer to one of the members of the class we prepend <code>this.</code>. This denotes that it’s a member access.</p>\n<p>In the last line we construct an instance of the <code>Greeter</code> class using <code>new</code>. This calls into the constructor we defined earlier, creating a new object with the <code>Greeter</code> shape, and running the constructor to initialize it.</p>\n<h2 id=\"inheritance\">Inheritance</h2>\n<p>In TypeScript, we can use common object-oriented patterns. Of course, one of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.</p>\n<p>Let’s take a look at an example:</p>\n<pre data-language=\"typescript\">class Animal {\r\n  name: string;\r\n  constructor(theName: string) { this.name = theName; }\r\n  move(distanceInMeters: number = 0) {\r\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\r\n  }\r\n}\r\n\r\nclass Snake extends Animal {\r\n  constructor(name: string) { super(name); }\r\n  move(distanceInMeters = 5) {\r\n    console.log(\"Slithering...\");\r\n    super.move(distanceInMeters);\r\n  }\r\n}\r\n\r\nclass Horse extends Animal {\r\n  constructor(name: string) { super(name); }\r\n  move(distanceInMeters = 45) {\r\n    console.log(\"Galloping...\");\r\n    super.move(distanceInMeters);\r\n  }\r\n}\r\n\r\nlet sam = new Snake(\"Sammy the Python\");\r\nlet tom: Animal = new Horse(\"Tommy the Palomino\");\r\n\r\nsam.move();\r\ntom.move(34);\r\n</pre>\n<p>This example covers quite a few of the inheritance features in TypeScript that are common to other languages. Here we see the <code>extends</code> keywords used to create a subclass. You can see this where <code>Horse</code> and <code>Snake</code> subclass the base class <code>Animal</code> and gain access to its features.</p>\n<p>The example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both <code>Snake</code> and <code>Horse</code> create a <code>move</code> method that overrides the <code>move</code> from <code>Animal</code>, giving it functionality specific to each class. Note that even though <code>tom</code> is declared as an <code>Animal</code>, since its value is a <code>Horse</code>, when <code>tom.move(34)</code> calls the overriding method in <code>Horse</code>:</p>\n<p>Derived classes that contain constructor functions must call <code>super()</code> which will execute the constructor function on the base class.</p>\n<pre data-language=\"Text\">Slithering...\r\nSammy the Python moved 5m.\r\nGalloping...\r\nTommy the Palomino moved 34m.\r\n</pre>\n<h2 id=\"public-private-and-protected-modifiers\">Public, private, and protected modifiers</h2>\n<h2 id=\"public-by-default\">Public by default</h2>\n<p>In our examples, we’ve been able to freely access the members that we declared throughout our programs. If you’re familiar with classes in other languages, you may have noticed in the above examples we haven’t had to use the word <code>public</code> to accomplish this; for instance, C# requires that each member be explicitly labeled <code>public</code> to be visible. In TypeScript, each member is <code>public</code> by default.</p>\n<p>You may still mark a member <code>public</code> explicitly. We could have written the <code>Animal</code> class from the previous section in the following way:</p>\n<pre data-language=\"typescript\">class Animal {\r\n  public name: string;\r\n  public constructor(theName: string) { this.name = theName; }\r\n  public move(distanceInMeters: number) {\r\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\r\n  }\r\n}\r\n</pre>\n<h2 id=\"understanding-private\">Understanding <code>private</code>\n</h2>\n<p>When a member is marked <code>private</code>, it cannot be accessed from outside of its containing class. For example:</p>\n<pre data-language=\"typescript\">class Animal {\r\n  private name: string;\r\n  constructor(theName: string) { this.name = theName; }\r\n}\r\n\r\nnew Animal(\"Cat\").name; // Error: 'name' is private;\r\n</pre>\n<p>TypeScript is a structural type system. When we compare two different types, regardless of where they came from, if the types of all members are compatible, then we say the types themselves are compatible.</p>\n<p>However, when comparing types that have <code>private</code> and <code>protected</code> members, we treat these types differently. For two types to be considered compatible, if one of them has a <code>private</code> member, then the other must have a <code>private</code> member that originated in the same declaration. The same applies to <code>protected</code> members.</p>\n<p>Let’s look at an example to better see how this plays out in practice:</p>\n<pre data-language=\"typescript\">class Animal {\r\n  private name: string;\r\n  constructor(theName: string) { this.name = theName; }\r\n}\r\n\r\nclass Rhino extends Animal {\r\n  constructor() { super(\"Rhino\"); }\r\n}\r\n\r\nclass Employee {\r\n  private name: string;\r\n  constructor(theName: string) { this.name = theName; }\r\n}\r\n\r\nlet animal = new Animal(\"Goat\");\r\nlet rhino = new Rhino();\r\nlet employee = new Employee(\"Bob\");\r\n\r\nanimal = rhino;\r\nanimal = employee; // Error: Animal and Employee are not compatible\r\n</pre>\n<p>In this example, we have an <code>Animal</code> and a <code>Rhino</code>, with <code>Rhino</code> being a subclass of <code>Animal</code>. We also have a new class <code>Employee</code> that looks identical to <code>Animal</code> in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because <code>Animal</code> and <code>Rhino</code> share the <code>private</code> side of their shape from the same declaration of <code>private name: string</code> in <code>Animal</code>, they are compatible. However, this is not the case for <code>Employee</code>. When we try to assign from an <code>Employee</code> to <code>Animal</code> we get an error that these types are not compatible. Even though <code>Employee</code> also has a <code>private</code> member called <code>name</code>, it’s not the as the one we declared in <code>Animal</code>.</p>\n<h2 id=\"understanding-protected\">Understanding <code>protected</code>\n</h2>\n<p>The <code>protected</code> modifier acts much like the <code>private</code> modifier with the exception that members declared <code>protected</code> can also be accessed by instances of deriving classes. For example,</p>\n<pre data-language=\"typescript\">class Person {\r\n  protected name: string;\r\n  constructor(name: string) { this.name = name; }\r\n}\r\n\r\nclass Employee extends Person {\r\n  private department: string;\r\n\r\n  constructor(name: string, department: string) {\r\n    super(name);\r\n    this.department = department;\r\n  }\r\n\r\n  public getElevatorPitch() {\r\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`;\r\n  }\r\n}\r\n\r\nlet howard = new Employee(\"Howard\", \"Sales\");\r\nconsole.log(howard.getElevatorPitch());\r\nconsole.log(howard.name); // error\r\n</pre>\n<p>Notice that while we can’t use <code>name</code> from outside of <code>Person</code>, we can still use it from within an instance method of <code>Employee</code> because <code>Employee</code> derives from <code>Person</code>.</p>\n<h2 id=\"parameter-properties\">Parameter properties</h2>\n<p>In our last example, we had to declare a private member <code>name</code> and a constructor parameter <code>theName</code>, and we then immediately set <code>name</code> to <code>theName</code>. This turns out to be a very common practice. <em>Parameter properties</em> let you create and initialize a member in one place. Here’s a further revision of the previous <code>Animal</code> class using a parameter property:</p>\n<pre data-language=\"typescript\">class Animal {\r\n  constructor(private name: string) { }\r\n  move(distanceInMeters: number) {\r\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\r\n  }\r\n}\r\n</pre>\n<p>Notice how we dropped <code>theName</code> altogether and just use the shortened <code>private name: string</code> parameter on the constructor to create and initialize the <code>name</code> member. We’ve consolidated the declarations and assignment into one location.</p>\n<p>Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier. Using <code>private</code> for a parameter property declares and initializes a private member; likewise, the same is done for <code>public</code> and <code>protected</code>.</p>\n<h2 id=\"accessors\">Accessors</h2>\n<p>TypeScript supports getters/setters as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object.</p>\n<p>Let’s convert a simple class to use <code>get</code> and <code>set</code>. First, let’s start with an example without getters and setters.</p>\n<pre data-language=\"typescript\">class Employee {\r\n  fullName: string;\r\n}\r\n\r\nlet employee = new Employee();\r\nemployee.fullName = \"Bob Smith\";\r\nif (employee.fullName) {\r\n  console.log(employee.fullName);\r\n}\r\n</pre>\n<p>While allowing people to randomly set <code>fullName</code> directly is pretty handy, this might get us in trouble if people can change names on a whim.</p>\n<p>In this version, we check to make sure the user has a secret passcode available before we allow them to modify the employee. We do this by replacing the direct access to <code>fullName</code> with a <code>set</code> that will check the passcode. We add a corresponding <code>get</code> to allow the previous example to continue to work seamlessly.</p>\n<pre data-language=\"typescript\">let passcode = \"secret passcode\";\r\n\r\nclass Employee {\r\n  private _fullName: string;\r\n\r\n  get fullName(): string {\r\n    return this._fullName;\r\n  }\r\n\r\n  set fullName(newName: string) {\r\n    if (passcode &amp;&amp; passcode == \"secret passcode\") {\r\n      this._fullName = newName;\r\n    }\r\n    else {\r\n      console.log(\"Error: Unauthorized update of employee!\");\r\n    }\r\n  }\r\n}\r\n\r\nlet employee = new Employee();\r\nemployee.fullName = \"Bob Smith\";\r\nif (employee.fullName) {\r\n  console.log(employee.fullName);\r\n}\r\n</pre>\n<p>To prove to ourselves that our accessor is now checking the passcode, we can modify the passcode and see that when it doesn’t match we instead get the message warning us we don’t have access to update the employee.</p>\n<p>Note: Accessors require you to set the compiler to output ECMAScript 5 or higher.</p>\n<h2 id=\"static-properties\">Static Properties</h2>\n<p>Up to this point, we’ve only talked about the <em>instance</em> members of the class, those that show up on the object when its instantiated. We can also create <em>static</em> members of a class, those that are visible on the class itself rather than on the instances. In this example, we use <code>static</code> on the origin, as it’s a general value for all grids. Each instance accesses this value through prepending the name of the class. Similarly to prepending <code>this.</code> in front of instance accesses, here we prepend <code>Grid.</code> in front of static accesses.</p>\n<pre data-language=\"typescript\">class Grid {\r\n  static origin = {x: 0, y: 0};\r\n  calculateDistanceFromOrigin(point: {x: number; y: number;}) {\r\n    let xDist = (point.x - Grid.origin.x);\r\n    let yDist = (point.y - Grid.origin.y);\r\n    return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\r\n  }\r\n  constructor (public scale: number) { }\r\n}\r\n\r\nlet grid1 = new Grid(1.0);  // 1x scale\r\nlet grid2 = new Grid(5.0);  // 5x scale\r\n\r\nconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));\r\nconsole.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));\r\n</pre>\n<h2 id=\"abstract-classes\">Abstract Classes</h2>\n<p>Abstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The <code>abstract</code> keyword is used to define abstract classes as well as abstract methods within an abstract class.</p>\n<pre data-language=\"typescript\">abstract class Animal {\r\n  abstract makeSound(): void;\r\n  move(): void {\r\n    console.log('roaming the earth...');\r\n  }\r\n}\r\n</pre>\n<p>Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the <code>abstract</code> keyword and may optionally include access modifiers.</p>\n<pre data-language=\"typescript\">abstract class Department {\r\n\r\n  constructor(public name: string) {\r\n  }\r\n\r\n  printName(): void {\r\n    console.log('Department name: ' + this.name);\r\n  }\r\n\r\n  abstract printMeeting(): void; // must be implemented in derived classes\r\n}\r\n\r\nclass AccountingDepartment extends Department {\r\n\r\n  constructor() {\r\n    super('Accounting and Auditing'); // constructors in derived classes must call super()\r\n  }\r\n\r\n  printMeeting(): void {\r\n    console.log('The Accounting Department meets each Monday at 10am.');\r\n  }\r\n\r\n  generateReports(): void {\r\n    console.log('Generating accounting reports...');\r\n  }\r\n}\r\n\r\nlet department: Department; // ok to create a reference to an abstract type\r\ndepartment = new Department(); // error: cannot create an instance of an abstract class\r\ndepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclass\r\ndepartment.printName();\r\ndepartment.printMeeting();\r\ndepartment.generateReports(); // error: method doesn't exist on declared abstract type\r\n</pre>\n<h2 id=\"advanced-techniques\">Advanced Techniques</h2>\n<h2 id=\"constructor-functions\">Constructor functions</h2>\n<p>When you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the <em>instance</em> of the class.</p>\n<pre data-language=\"typescript\">class Greeter {\r\n  greeting: string;\r\n  constructor(message: string) {\r\n    this.greeting = message;\r\n  }\r\n  greet() {\r\n    return \"Hello, \" + this.greeting;\r\n  }\r\n}\r\n\r\nlet greeter: Greeter;\r\ngreeter = new Greeter(\"world\");\r\nconsole.log(greeter.greet());\r\n</pre>\n<p>Here, when we say <code>let greeter: Greeter</code>, we’re using <code>Greeter</code> as the type of instances of the class <code>Greeter</code>. This is almost second nature to programmers from other object-oriented languages.</p>\n<p>We’re also creating another value that we call the <em>constructor function</em>. This is the function that is called when we <code>new</code> up instances of the class. To see what this looks like in practice, let’s take a look at the JavaScript created by the above example:</p>\n<pre data-language=\"typescript\">let Greeter = (function () {\r\n  function Greeter(message) {\r\n    this.greeting = message;\r\n  }\r\n  Greeter.prototype.greet = function () {\r\n    return \"Hello, \" + this.greeting;\r\n  };\r\n  return Greeter;\r\n})();\r\n\r\nlet greeter;\r\ngreeter = new Greeter(\"world\");\r\nconsole.log(greeter.greet());\r\n</pre>\n<p>Here, <code>let Greeter</code> is going to be assigned the constructor function. When we call <code>new</code> and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an <em>instance</em> side and a <em>static</em> side.</p>\n<p>Let’s modify the example a bit to show this difference:</p>\n<pre data-language=\"typescript\">class Greeter {\r\n  static standardGreeting = \"Hello, there\";\r\n  greeting: string;\r\n  greet() {\r\n    if (this.greeting) {\r\n      return \"Hello, \" + this.greeting;\r\n    }\r\n    else {\r\n      return Greeter.standardGreeting;\r\n    }\r\n  }\r\n}\r\n\r\nlet greeter1: Greeter;\r\ngreeter1 = new Greeter();\r\nconsole.log(greeter1.greet());\r\n\r\nlet greeterMaker: typeof Greeter = Greeter;\r\ngreeterMaker.standardGreeting = \"Hey there!\";\r\n\r\nlet greeter2: Greeter = new greeterMaker();\r\nconsole.log(greeter2.greet());\r\n</pre>\n<p>In this example, <code>greeter1</code> works similarly to before. We instantiate the <code>Greeter</code> class, and use this object. This we have seen before.</p>\n<p>Next, we then use the class directly. Here we create a new variable called <code>greeterMaker</code>. This variable will hold the class itself, or said another way its constructor function. Here we use <code>typeof Greeter</code>, that is “give me the type of the <code>Greeter</code> class itself” rather than the instance type. Or, more precisely, “give me the type of the symbol called <code>Greeter</code>”, which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the <code>Greeter</code> class. We show this by using <code>new</code> on <code>greeterMaker</code>, creating new instances of <code>Greeter</code> and invoking them as before.</p>\n<h2 id=\"using-a-class-as-an-interface\">Using a class as an interface</h2>\n<p>As we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces.</p>\n<pre data-language=\"typescript\">class Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ninterface Point3d extends Point {\r\n  z: number;\r\n}\r\n\r\nlet point3d: Point3d = {x: 1, y: 2, z: 3};\r\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/classes.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/classes.html</a>\n  </p>\n</div>\n","handbook/type-compatibility":"<h1 class=\"post-title\">Type Compatibility</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:</p>\n<pre data-language=\"typescript\">interface Named {\r\n  name: string;\r\n}\r\n\r\nclass Person {\r\n  name: string;\r\n}\r\n\r\nlet p: Named;\r\n// OK, because of structural typing\r\np = new Person();\r\n</pre>\n<p>In nominally-typed languages like C# or Java, the equivalent code would be an error because the <code>Person</code> class does not explicitly describe itself as being an implementor of the <code>Named</code> interface.</p>\n<p>TypeScript’s structural type system was designed based on how JavaScript code is typically written. Because JavaScript widely uses anonymous objects like function expressions and object literals, it’s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one.</p>\n<h2 id=\"a-note-on-soundness\">A Note on Soundness</h2>\n<p>TypeScript’s type system allows certain operations that can’t be known at compile-time to be safe. When a type system has this property, it is said to not be “sound”. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we’ll explain where these happen and the motivating scenarios behind them.</p>\n<h2 id=\"starting-out\">Starting out</h2>\n<p>The basic rule for TypeScript’s structural type system is that <code>x</code> is compatible with <code>y</code> if <code>y</code> has at least the same members as <code>x</code>. For example:</p>\n<pre data-language=\"typescript\">interface Named {\r\n  name: string;\r\n}\r\n\r\nlet x: Named;\r\n// y's inferred type is { name: string; location: string; }\r\nlet y = { name: 'Alice', location: 'Seattle' };\r\nx = y;\r\n</pre>\n<p>To check whether <code>y</code> can be assigned to <code>x</code>, the compiler checks each property of <code>x</code> to find a corresponding compatible property in <code>y</code>. In this case, <code>y</code> must have a member called <code>name</code> that is a string. It does, so the assignment is allowed.</p>\n<p>The same rule for assignment is used when checking function call arguments:</p>\n<pre data-language=\"typescript\">function greet(n: Named) {\r\n  alert('Hello, ' + n.name);\r\n}\r\ngreet(y); // OK\r\n</pre>\n<p>Note that <code>y</code> has an extra <code>location</code> property, but this does not create an error. Only members of the target type (<code>Named</code> in this case) are considered when checking for compatibility.</p>\n<p>This comparison process proceeds recursively, exploring the type of each member and sub-member.</p>\n<h2 id=\"comparing-two-functions\">Comparing two functions</h2>\n<p>While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible. Let’s start with a basic example of two functions that differ only in their parameter lists:</p>\n<pre data-language=\"typescript\">let x = (a: number) =&gt; 0;\r\nlet y = (b: number, s: string) =&gt; 0;\r\n\r\ny = x; // OK\r\nx = y; // Error\r\n</pre>\n<p>To check if <code>x</code> is assignable to <code>y</code>, we first look at the parameter list. Each parameter in <code>x</code> must have a corresponding parameter in <code>y</code> with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of <code>x</code> has a corresponding compatible parameter in <code>y</code>, so the assignment is allowed.</p>\n<p>The second assignment is an error, because y has a required second parameter that ‘x’ does not have, so the assignment is disallowed.</p>\n<p>You may be wondering why we allow ‘discarding’ parameters like in the example <code>y = x</code>. The reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, <code>Array#forEach</code> provides three parameters to the callback function: the array element, its index, and the containing array. Nevertheless, it’s very useful to provide a callback that only uses the first parameter:</p>\n<pre data-language=\"typescript\">let items = [1, 2, 3];\r\n\r\n// Don't force these extra parameters\r\nitems.forEach((item, index, array) =&gt; console.log(item));\r\n\r\n// Should be OK!\r\nitems.forEach(item =&gt; console.log(item));\r\n</pre>\n<p>Now let’s look at how return types are treated, using two functions that differ only by their return type:</p>\n<pre data-language=\"typescript\">let x = () =&gt; ({name: 'Alice'});\r\nlet y = () =&gt; ({name: 'Alice', location: 'Seattle'});\r\n\r\nx = y; // OK\r\ny = x; // Error because x() lacks a location property\r\n</pre>\n<p>The type system enforces that the source function’s return type be a subtype of the target type’s return type.</p>\n<h2 id=\"function-parameter-bivariance\">Function Parameter Bivariance</h2>\n<p>When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:</p>\n<pre data-language=\"typescript\">enum EventType { Mouse, Keyboard }\r\n\r\ninterface Event { timestamp: number; }\r\ninterface MouseEvent extends Event { x: number; y: number }\r\ninterface KeyEvent extends Event { keyCode: number }\r\n\r\nfunction listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) {\r\n  /* ... */\r\n}\r\n\r\n// Unsound, but useful and common\r\nlistenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x + ',' + e.y));\r\n\r\n// Undesirable alternatives in presence of soundness\r\nlistenEvent(EventType.Mouse, (e: Event) =&gt; console.log((&lt;MouseEvent&gt;e).x + ',' + (&lt;MouseEvent&gt;e).y));\r\nlistenEvent(EventType.Mouse, &lt;(e: Event) =&gt; void&gt;((e: MouseEvent) =&gt; console.log(e.x + ',' + e.y)));\r\n\r\n// Still disallowed (clear error). Type safety enforced for wholly incompatible types\r\nlistenEvent(EventType.Mouse, (e: number) =&gt; console.log(e));\r\n</pre>\n<h2 id=\"optional-parameters-and-rest-parameters\">Optional Parameters and Rest Parameters</h2>\n<p>When comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the target type are not an error.</p>\n<p>When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.</p>\n<p>This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing <code>undefined</code> in that position is equivalent for most functions.</p>\n<p>The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:</p>\n<pre data-language=\"typescript\">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) {\r\n  /* ... Invoke callback with 'args' ... */\r\n}\r\n\r\n// Unsound - invokeLater \"might\" provide any number of arguments\r\ninvokeLater([1, 2], (x, y) =&gt; console.log(x + ', ' + y));\r\n\r\n// Confusing (x and y are actually required) and undiscoverable\r\ninvokeLater([1, 2], (x?, y?) =&gt; console.log(x + ', ' + y));\r\n</pre>\n<h2 id=\"functions-with-overloads\">Functions with overloads</h2>\n<p>When a function has overloads, each overload in the source type must be matched by a compatible signature on the target type. This ensures that the target function can be called in all the same situations as the source function.</p>\n<h2 id=\"enums\">Enums</h2>\n<p>Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,</p>\n<pre data-language=\"typescript\">enum Status { Ready, Waiting };\r\nenum Color { Red, Blue, Green };\r\n\r\nlet status = Status.Ready;\r\nstatus = Color.Green;  //error\r\n</pre>\n<h2 id=\"classes\">Classes</h2>\n<p>Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.</p>\n<pre data-language=\"typescript\">class Animal {\r\n  feet: number;\r\n  constructor(name: string, numFeet: number) { }\r\n}\r\n\r\nclass Size {\r\n  feet: number;\r\n  constructor(numFeet: number) { }\r\n}\r\n\r\nlet a: Animal;\r\nlet s: Size;\r\n\r\na = s;  //OK\r\ns = a;  //OK\r\n</pre>\n<h2 id=\"private-and-protected-members-in-classes\">Private and protected members in classes</h2>\n<p>Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the instance contains a private member, then the target type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but <em>not</em> with classes from a different inheritance hierarchy which otherwise have the same shape.</p>\n<h2 id=\"generics\">Generics</h2>\n<p>Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,</p>\n<pre data-language=\"typescript\">interface Empty&lt;T&gt; {\r\n}\r\nlet x: Empty&lt;number&gt;;\r\nlet y: Empty&lt;string&gt;;\r\n\r\nx = y;  // okay, y matches structure of x\r\n</pre>\n<p>In the above, <code>x</code> and <code>y</code> are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to <code>Empty&lt;T&gt;</code> shows how this works:</p>\n<pre data-language=\"typescript\">interface NotEmpty&lt;T&gt; {\r\n  data: T;\r\n}\r\nlet x: NotEmpty&lt;number&gt;;\r\nlet y: NotEmpty&lt;string&gt;;\r\n\r\nx = y;  // error, x and y are not compatible\r\n</pre>\n<p>In this way, a generic type that has its type arguments specified acts just like a non-generic type.</p>\n<p>For generic types that do not have their type arguments specified, compatibility is checked by specifying <code>any</code> in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.</p>\n<p>For example,</p>\n<pre data-language=\"typescript\">let identity = function&lt;T&gt;(x: T): T {\r\n  // ...\r\n}\r\n\r\nlet reverse = function&lt;U&gt;(y: U): U {\r\n  // ...\r\n}\r\n\r\nidentity = reverse;  // Okay because (x: any)=&gt;any matches (y: any)=&gt;any\r\n</pre>\n<h2 id=\"advanced-topics\">Advanced Topics</h2>\n<h2 id=\"subtype-vs-assignment\">Subtype vs Assignment</h2>\n<p>So far, we’ve used ‘compatible’, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from <code>any</code> and to and from enum with corresponding numeric values.</p>\n<p>Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility even in the cases of the <code>implements</code> and <code>extends</code> clauses. For more information, see the <a href=\"#\">TypeScript spec</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/type-compatibility.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/type-compatibility.html</a>\n  </p>\n</div>\n","handbook/namespaces-and-modules":"<h1 class=\"post-title\">Namespaces and Modules</h1>\n\n<blockquote><p><strong>A note about terminology:</strong> It’s important to note that in TypeScript 1.5, the nomenclature has changed. “Internal modules” are now “namespaces”. “External modules” are now simply “modules”, as to align with <a href=\"http://www.ecma-international.org/ecma-262/6.0/\">ECMAScript 2015</a>’s terminology, (namely that <code>module X {</code> is equivalent to the now-preferred <code>namespace X {</code>).</p></blockquote>\n<h2 id=\"introduction\">Introduction</h2>\n<p>This post outlines the various ways to organize your code using namespaces and modules in TypeScript. We’ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</p>\n<p>See the <a href=\"modules\">Modules</a> documentation for more information about modules. See the <a href=\"namespaces\">Namespaces</a> documentation for more information about namespaces.</p>\n<h2 id=\"using-namespaces\">Using Namespaces</h2>\n<p>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. They can span multiple files, and can be concatenated using <code>--outFile</code>. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as <code>&lt;script&gt;</code> tags in your HTML page.</p>\n<p>Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.</p>\n<h2 id=\"using-modules\">Using Modules</h2>\n<p>Just like namespaces, modules can contain both code and declarations. The main difference is that modules <em>declare</em> their dependencies.</p>\n<p>Modules also have a dependency on a module loader (such as CommonJs/Require.js). For a small JS application this might not be optimal, but for larger applications, the cost comes with long term modularity and maintainability benefits. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</p>\n<p>It is also worth noting that, for Node.js applications, modules are the default and the recommended approach to structure your code.</p>\n<p>Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.</p>\n<h2 id=\"pitfalls-of-namespaces-and-modules\">Pitfalls of Namespaces and Modules</h2>\n<p>In this section we’ll describe various common pitfalls in using namespaces and modules, and how to avoid them.</p>\n<h2 id=\"reference-ing-a-module\">\n<code>/// &lt;reference&gt;</code>-ing a module</h2>\n<p>A common mistake is to try to use the <code>/// &lt;reference ... /&gt;</code> syntax to refer to a module file, rather than using an <code>import</code> statement. To understand the distinction, we first need to understand how compiler can locate the type information for a module based on the path of an <code>import</code> (e.g. the <code>...</code> in <code>import x from \"...\";</code>, <code>import x = require(\"...\");</code>, etc.) path.</p>\n<p>The compiler will try to find a <code>.ts</code>, <code>.tsx</code>, and then a <code>.d.ts</code> with the appropriate path. If a specific file could not be found, then the compiler will look for an <em>ambient module declaration</em>. Recall that these need to be declared in a <code>.d.ts</code> file.</p>\n<ul>\n<li>\n<p><code>myModules.d.ts</code></p>\n<pre data-language=\"typescript\">// In a .d.ts file or .ts file that is not a module:\r\ndeclare module \"SomeModule\" {\r\n  export function fn(): string;\r\n}\r\n</pre>\n</li>\n<li>\n<p><code>myOtherModule.ts</code></p>\n<pre data-language=\"typescript\">/// &lt;reference path=\"myModules.d.ts\" /&gt;\r\nimport * as m from \"SomeModule\";\r\n</pre>\n</li>\n</ul>\n<p>The reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the <code>node.d.ts</code> file that several of the TypeScript samples use is consumed.</p>\n<h2 id=\"needless-namespacing\">Needless Namespacing</h2>\n<p>If you’re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:</p>\n<ul><li>\n<p><code>shapes.ts</code></p>\n<pre data-language=\"typescript\">export namespace Shapes {\r\n  export class Triangle { /* ... */ }\r\n  export class Square { /* ... */ }\r\n}\r\n</pre>\n</li></ul>\n<p>The top-level module here <code>Shapes</code> wraps up <code>Triangle</code> and <code>Square</code> for no reason. This is confusing and annoying for consumers of your module:</p>\n<ul><li>\n<p><code>shapeConsumer.ts</code></p>\n<pre data-language=\"typescript\">import * as shapes from \"./shapes\";\r\nlet t = new shapes.Shapes.Triangle(); // shapes.Shapes?\r\n</pre>\n</li></ul>\n<p>A key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there’s no need to proactively wrap up the exported symbols in a namespace.</p>\n<p>To reiterate why you shouldn’t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it’s unnecessary to use an additional module layer for exported objects.</p>\n<p>Here’s a revised example:</p>\n<ul>\n<li>\n<p><code>shapes.ts</code></p>\n<pre data-language=\"typescript\">export class Triangle { /* ... */ }\r\nexport class Square { /* ... */ }\r\n</pre>\n</li>\n<li>\n<p><code>shapeConsumer.ts</code></p>\n<pre data-language=\"typescript\">import * as shapes from \"./shapes\";\r\nlet t = new shapes.Triangle();\r\n</pre>\n</li>\n</ul>\n<h2 id=\"trade-offs-of-modules\">Trade-offs of Modules</h2>\n<p>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it’s not possible to use the <code>--outFile</code> compiler switch to concatenate multiple module source files into a single JavaScript file.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html</a>\n  </p>\n</div>\n","release-notes/typescript-1.7":"<h1 class=\"post-title\">TypeScript 1.7</h1>\n\n<h2 id=\"asyncawait-support-in-es6-targets-node-v4\">\n<code>async</code>/<code>await</code> support in ES6 targets (Node v4+)</h2>\n<p>TypeScript now supports asynchronous functions for engines that have native support for ES6 generators, e.g. Node v4 and above. Asynchronous functions are prefixed with the <code>async</code> keyword; <code>await</code> suspends the execution until an asynchronous function return promise is fulfilled and unwraps the value from the <code>Promise</code> returned.</p>\n<h5 id=\"example\">Example</h5>\n<p>In the following example, each input element will be printed out one at a time with a 400ms delay:</p>\n<pre data-language=\"typescript\">\"use strict\";\r\n\r\n// printDelayed is a 'Promise&lt;void&gt;'\r\nasync function printDelayed(elements: string[]) {\r\n  for (const element of elements) {\r\n    await delay(200);\r\n    console.log(element);\r\n  }\r\n}\r\n\r\nasync function delay(milliseconds: number) {\r\n  return new Promise&lt;void&gt;(resolve =&gt; {\r\n    setTimeout(resolve, milliseconds);\r\n  });\r\n}\r\n\r\nprintDelayed([\"Hello\", \"beautiful\", \"asynchronous\", \"world\"]).then(() =&gt; {\r\n  console.log();\r\n  console.log(\"Printed every element!\");\r\n});\r\n</pre>\n<p>For more information see <a href=\"http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx\">Async Functions</a> blog post.</p>\n<h2 id=\"support-for---target-es6-with---module\">Support for <code>--target ES6</code> with <code>--module</code>\n</h2>\n<p>TypeScript 1.7 adds <code>ES6</code> to the list of options available for the <code>--module</code> flag and allows you to specify the module output when targeting <code>ES6</code>. This provides more flexibility to target exactly the features you want in specific runtimes.</p>\n<h5 id=\"example-1\">Example</h5>\n<pre data-language=\"javascripton\">{\r\n  \"compilerOptions\": {\r\n    \"module\": \"amd\",\r\n    \"target\": \"es6\"\r\n  }\r\n}\r\n</pre>\n<h2 id=\"this-typing\">\n<code>this</code>-typing</h2>\n<p>It is a common pattern to return the current object (i.e. <code>this</code>) from a method to create <a href=\"https://en.wikipedia.org/wiki/Fluent_interface\">fluent-style APIs</a>. For instance, consider the following <code>BasicCalculator</code> module:</p>\n<pre data-language=\"typescript\">export default class BasicCalculator {\r\n  public constructor(protected value: number = 0) { }\r\n\r\n  public currentValue(): number {\r\n    return this.value;\r\n  }\r\n\r\n  public add(operand: number) {\r\n    this.value += operand;\r\n    return this;\r\n  }\r\n\r\n  public subtract(operand: number) {\r\n    this.value -= operand;\r\n    return this;\r\n  }\r\n\r\n  public multiply(operand: number) {\r\n    this.value *= operand;\r\n    return this;\r\n  }\r\n\r\n  public divide(operand: number) {\r\n    this.value /= operand;\r\n    return this;\r\n  }\r\n}\r\n</pre>\n<p>A user could express <code>2 * 5 + 1</code> as</p>\n<pre data-language=\"typescript\">import calc from \"./BasicCalculator\";\r\n\r\nlet v = new calc(2)\r\n  .multiply(5)\r\n  .add(1)\r\n  .currentValue();\r\n</pre>\n<p>This often opens up very elegant ways of writing code; however, there was a problem for classes that wanted to extend from <code>BasicCalculator</code>. Imagine a user wanted to start writing a <code>ScientificCalculator</code>:</p>\n<pre data-language=\"typescript\">import BasicCalculator from \"./BasicCalculator\";\r\n\r\nexport default class ScientificCalculator extends BasicCalculator {\r\n  public constructor(value = 0) {\r\n    super(value);\r\n  }\r\n\r\n  public square() {\r\n    this.value = this.value ** 2;\r\n    return this;\r\n  }\r\n\r\n  public sin() {\r\n    this.value = Math.sin(this.value);\r\n    return this;\r\n  }\r\n}\r\n</pre>\n<p>Because TypeScript used to infer the type <code>BasicCalculator</code> for each method in <code>BasicCalculator</code> that returned <code>this</code>, the type system would forget that it had <code>ScientificCalculator</code> whenever using a <code>BasicCalculator</code> method.</p>\n<p>For instance:</p>\n<pre data-language=\"typescript\">import calc from \"./ScientificCalculator\";\r\n\r\nlet v = new calc(0.5)\r\n  .square()\r\n  .divide(2)\r\n  .sin()  // Error: 'BasicCalculator' has no 'sin' method.\r\n  .currentValue();\r\n</pre>\n<p>This is no longer the case - TypeScript now infers <code>this</code> to have a special type called <code>this</code> whenever inside an instance method of a class. The <code>this</code> type is written as so, and basically means “the type of the left side of the dot in a method call”.</p>\n<p>The <code>this</code> type is also useful with intersection types in describing libraries (e.g. Ember.js) that use mixin-style patterns to describe inheritance:</p>\n<pre data-language=\"typescript\">interface MyType {\r\n  extend&lt;T&gt;(other: T): this &amp; T;\r\n}\r\n</pre>\n<h2 id=\"es7-exponentiation-operator\">ES7 exponentiation operator</h2>\n<p>TypeScript 1.7 supports upcoming <a href=\"https://github.com/rwaldron/exponentiation-operator\">ES7/ES2016 exponentiation operators</a>: <code>**</code> and <code>**=</code>. The operators will be transformed in the output to ES3/ES5 using <code>Math.pow</code>.</p>\n<h5 id=\"example-2\">Example</h5>\n<pre data-language=\"typescript\">var x = 2 ** 3;\r\nvar y = 10;\r\ny **= 2;\r\nvar z =  -(4 ** 3);\r\n</pre>\n<p>Will generate the following JavaScript output:</p>\n<pre data-language=\"javascript\">var x = Math.pow(2, 3);\r\nvar y = 10;\r\ny = Math.pow(y, 2);\r\nvar z = -(Math.pow(4, 3));\r\n</pre>\n<h2 id=\"improved-checking-for-destructuring-object-literal\">Improved checking for destructuring object literal</h2>\n<p>TypeScript 1.7 makes checking of destructuring patterns with an object literal or array literal initializers less rigid and more intuitive.</p>\n<p>When an object literal is contextually typed by the implied type of an object binding pattern:</p>\n<ul>\n<li>Properties with default values in the object binding pattern become optional in the object literal.</li>\n<li>Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.</li>\n<li>Properties in the object literal that have no match in the object binding pattern are an error.</li>\n</ul>\n<p>When an array literal is contextually typed by the implied type of an array binding pattern:</p>\n<ul><li>Elements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.</li></ul>\n<h5 id=\"example-3\">Example</h5>\n<pre data-language=\"typescript\">// Type of f1 is (arg?: { x?: number, y?: number }) =&gt; void\r\nfunction f1({ x = 0, y = 0 } = {}) { }\r\n\r\n// And can be called as:\r\nf1();\r\nf1({});\r\nf1({ x: 1 });\r\nf1({ y: 1 });\r\nf1({ x: 1, y: 1 });\r\n\r\n// Type of f2 is (arg?: (x: number, y?: number) =&gt; void\r\nfunction f2({ x, y = 0 } = { x: 0 }) { }\r\n\r\nf2();\r\nf2({});    // Error, x not optional\r\nf2({ x: 1 });\r\nf2({ y: 1 });  // Error, x not optional\r\nf2({ x: 1, y: 1 });\r\n</pre>\n<h2 id=\"support-for-decorators-when-targeting-es3\">Support for decorators when targeting ES3</h2>\n<p>Decorators are now allowed when targeting ES3. TypeScript 1.7 removes the ES5-specific use of <code>reduceRight</code> from the <code>__decorate</code> helper. The changes also inline calls <code>Object.getOwnPropertyDescriptor</code> and <code>Object.defineProperty</code> in a backwards-compatible fashion that allows for a to clean up the emit for ES5 and later by removing various repetitive calls to the aforementioned <code>Object</code> methods.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/release-notes/typescript-1.7.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/release-notes/typescript-1.7.html</a>\n  </p>\n</div>\n","handbook/writing-definition-files":"<h1 class=\"post-title\">Writing Definition Files</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>When using an external JavaScript library, or new host API, you’ll need to use a declaration file (.d.ts) to describe the shape of that library. This guide covers a few high-level concepts specific to writing definition files, then proceeds with a number of examples that show how to transcribe various concepts to their matching definition file descriptions.</p>\n<h2 id=\"guidelines-and-specifics\">Guidelines and Specifics</h2>\n<h2 id=\"workflow\">Workflow</h2>\n<p>The best way to write a .d.ts file is to start from the documentation of the library, not the code. Working from the documentation ensures the surface you present isn’t muddied with implementation details, and is typically much easier to read than JS code. The examples below will be written as if you were reading documentation that presented example calling code.</p>\n<h2 id=\"namespacing\">Namespacing</h2>\n<p>When defining interfaces (for example, “options” objects), you have a choice about whether to put these types inside a namespace or not. This is largely a judgement call – if the consumer is likely to often declare variables or parameters of that type, and the type can be named without risk of colliding with other types, prefer placing it in the global namespace. If the type is not likely to be referenced directly, or can’t be named with a reasonably unique name, do use a namespace to prevent it from colliding with other types.</p>\n<h2 id=\"callbacks\">Callbacks</h2>\n<p>Many JavaScript libraries take a function as a parameter, then invoke that function later with a known set of arguments. When writing the function signatures for these types, <em>do not</em> mark those parameters as optional. The right way to think of this is <em>“What parameters will be provided?”</em>, not <em>“What parameters will be consumed?”</em>. While TypeScript 0.9.7 and above does not enforce that the optionality, bivariance on argument optionality might be enforced by an external linter.</p>\n<h2 id=\"extensibility-and-declaration-merging\">Extensibility and Declaration Merging</h2>\n<p>When writing definition files, it’s important to remember TypeScript’s rules for extending existing objects. You might have a choice of declaring a variable using an anonymous type or an interface type:</p>\n<h4 id=\"anonymously-typed-var\">Anonymously-typed var</h4>\n<pre data-language=\"typescript\">declare var MyPoint: { x: number; y: number; };\r\n</pre>\n<h4 id=\"interfaced-typed-var\">Interfaced-typed var</h4>\n<pre data-language=\"typescript\">interface SomePoint { x: number; y: number; }\r\ndeclare var MyPoint: SomePoint;\r\n</pre>\n<p>From a consumption side these declarations are identical, but the type <code>SomePoint</code> can be extended through interface merging:</p>\n<pre data-language=\"typescript\">interface SomePoint { z: number; }\r\nMyPoint.z = 4; // OK\r\n</pre>\n<p>Whether or not you want your declarations to be extensible in this way is a bit of a judgement call. As always, try to represent the intent of the library here.</p>\n<h2 id=\"class-decomposition\">Class Decomposition</h2>\n<p>Classes in TypeScript create two separate types: the instance type, which defines what members an instance of a class has, and the constructor function type, which defines what members the class constructor function has. The constructor function type is also known as the “static side” type because it includes static members of the class.</p>\n<p>While you can reference the static side of a class using the <code>typeof</code> keyword, it is sometimes useful or necessary when writing definition files to use the <em>decomposed class</em> pattern which explicitly separates the instance and static types of class.</p>\n<p>As an example, the following two declarations are nearly equivalent from a consumption perspective:</p>\n<h4 id=\"standard\">Standard</h4>\n<pre data-language=\"typescript\">class A {\r\n  static st: string;\r\n  inst: number;\r\n  constructor(m: any) {}\r\n}\r\n</pre>\n<h4 id=\"decomposed\">Decomposed</h4>\n<pre data-language=\"typescript\">interface A_Static {\r\n  new(m: any): A_Instance;\r\n  st: string;\r\n}\r\ninterface A_Instance {\r\n  inst: number;\r\n}\r\ndeclare var A: A_Static;\r\n</pre>\n<p>The trade-offs here are as follows:</p>\n<ul>\n<li>Standard classes can be inherited from using <code>extends</code>; decomposed classes cannot. This might change in later version of TypeScript if arbitrary <code>extends</code> expressions are allowed.</li>\n<li>It is possible to add members later (through declaration merging) to the static side of both standard and decomposed classes</li>\n<li>It is possible to add instance members to decomposed classes, but not standard classes</li>\n<li>You’ll need to come up with sensible names for more types when writing a decomposed class</li>\n</ul>\n<h2 id=\"naming-conventions\">Naming Conventions</h2>\n<p>In general, you shouldn’t prefix interfaces with <code>I</code> (e.g. <code>IColor</code>). Because the concept of an interface in TypeScript is much more broad than in C# or Java, the <code>IFoo</code> naming convention is not broadly useful.</p>\n<h2 id=\"examples\">Examples</h2>\n<p>Let’s jump in to the examples section. For each example, sample <em>usage</em> of the library is provided, followed by the definition code that accurately types the usage. When there are multiple good representations, more than one definition sample might be listed.</p>\n<h2 id=\"options-objects\">Options Objects</h2>\n<h4 id=\"usage\">Usage</h4>\n<pre data-language=\"typescript\">animalFactory.create(\"dog\");\r\nanimalFactory.create(\"giraffe\", { name: \"ronald\" });\r\nanimalFactory.create(\"panda\", { name: \"bob\", height: 400 });\r\n// Invalid: name must be provided if options is given\r\nanimalFactory.create(\"cat\", { height: 32 });\r\n</pre>\n<h4 id=\"typing\">Typing</h4>\n<pre data-language=\"typescript\">namespace animalFactory {\r\n  interface AnimalOptions {\r\n    name: string;\r\n    height?: number;\r\n    weight?: number;\r\n  }\r\n  function create(name: string, animalOptions?: AnimalOptions): Animal;\r\n}\r\n</pre>\n<h2 id=\"functions-with-properties\">Functions with Properties</h2>\n<h4 id=\"usage-1\">Usage</h4>\n<pre data-language=\"typescript\">zooKeeper.workSchedule = \"morning\";\r\nzooKeeper(giraffeCage);\r\n</pre>\n<h4 id=\"typing-1\">Typing</h4>\n<pre data-language=\"typescript\">// Note: Function must precede namespace\r\nfunction zooKeeper(cage: AnimalCage);\r\nnamespace zooKeeper {\r\n  var workSchedule: string;\r\n}\r\n</pre>\n<h2 id=\"new--callable-methods\">New + callable methods</h2>\n<h4 id=\"usage-2\">Usage</h4>\n<pre data-language=\"typescript\">var w = widget(32, 16);\r\nvar y = new widget(\"sprocket\");\r\n// w and y are both widgets\r\nw.sprock();\r\ny.sprock();\r\n</pre>\n<h4 id=\"typing-2\">Typing</h4>\n<pre data-language=\"typescript\">interface Widget {\r\n  sprock(): void;\r\n}\r\n\r\ninterface WidgetFactory {\r\n  new(name: string): Widget;\r\n  (width: number, height: number): Widget;\r\n}\r\n\r\ndeclare var widget: WidgetFactory;\r\n</pre>\n<h2 id=\"global--external-agnostic-libraries\">Global / External-agnostic Libraries</h2>\n<h4 id=\"usage-3\">Usage</h4>\n<pre data-language=\"typescript\">// Either\r\nimport x = require('zoo');\r\nx.open();\r\n// or\r\nzoo.open();\r\n</pre>\n<h4 id=\"typing-3\">Typing</h4>\n<pre data-language=\"typescript\">declare namespace zoo {\r\n  function open(): void;\r\n}\r\n\r\ndeclare module \"zoo\" {\r\n  export = zoo;\r\n}\r\n</pre>\n<h2 id=\"single-complex-object-in-modules\">Single Complex Object in Modules</h2>\n<h4 id=\"usage-4\">Usage</h4>\n<pre data-language=\"typescript\">// Super-chainable library for eagles\r\nimport Eagle = require('./eagle');\r\n\r\n// Call directly\r\nEagle('bald').fly();\r\n\r\n// Invoke with new\r\nvar eddie = new Eagle('Mille');\r\n\r\n// Set properties\r\neddie.kind = 'golden';\r\n</pre>\n<h4 id=\"typing-4\">Typing</h4>\n<pre data-language=\"typescript\">interface Eagle {\r\n  (kind: string): Eagle;\r\n  new (kind: string): Eagle;\r\n\r\n  kind: string;\r\n  fly(): void\r\n}\r\n\r\ndeclare var Eagle: Eagle;\r\n\r\nexport = Eagle;\r\n</pre>\n<h2 id=\"function-as-an-module\">Function as an Module</h2>\n<p>This is a common pattern for modules whose imported entities are callable functions.</p>\n<h4 id=\"usage-5\">Usage</h4>\n<pre data-language=\"typescript\">import sayHello = require(\"say-hello\");\r\nsayHello(\"Travis\");\r\n</pre>\n<h4 id=\"typing-5\">Typing</h4>\n<pre data-language=\"typescript\">declare module \"say-hello\" {\r\n  function sayHello(name: string): void;\r\n  export = sayHello;\r\n}\r\n</pre>\n<h2 id=\"callbacks-1\">Callbacks</h2>\n<h4 id=\"usage-6\">Usage</h4>\n<pre data-language=\"typescript\">addLater(3, 4, x =&gt; console.log('x = ' + x));\r\n</pre>\n<h4 id=\"typing-6\">Typing</h4>\n<pre data-language=\"typescript\">// Note: 'void' return type is preferred here\r\nfunction addLater(x: number, y: number, (sum: number) =&gt; void): void;\r\n</pre>\n<p>Please post a comment <a href=\"https://github.com/Microsoft/TypeScript-Handbook/issues\">here</a> if there’s a pattern you’d like to see documented! We’ll add to this as we can.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/writing-definition-files.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/writing-definition-files.html</a>\n  </p>\n</div>\n","handbook/module-resolution":"<h1 class=\"post-title\">Module Resolution</h1>\n\n<blockquote><p>This section assumes some basic knowledge about modules. Please see the <a href=\"modules\">Modules</a> documentation for more information.</p></blockquote>\n<p><em>Module resolution</em> is the process the compiler uses to figure out what an import refers to. Consider an import statement like <code>import { a } from \"moduleA\"</code>; in order to check any use of <code>a</code>, the compiler needs to know exactly what it represents, and will need to check its definition <code>moduleA</code>.</p>\n<p>At this point, the compiler will ask “what’s the shape of <code>moduleA</code>?” While this sounds straightforward, <code>moduleA</code> could be defined in one of your own <code>.ts</code>/<code>.tsx</code> files, or in a <code>.d.ts</code> that your code depends on.</p>\n<p>First, the compiler will try to locate a file that represents the imported module. To do so the compiler follows one of two different strategies: <a href=\"#classic\">Classic</a> or <a href=\"#node\">Node</a>. These strategies tell the compiler <em>where</em> to look for <code>moduleA</code>.</p>\n<p>If that didn’t work and if the module name is non-relative (and in the case of <code>\"moduleA\"</code>, it is), then the compiler will attempt to locate an <a href=\"modules#ambient-modules\">ambient module declaration</a>. We’ll cover non-relative imports next.</p>\n<p>Finally, if the compiler could not resolve the module, it will log an error. In this case, the error would be something like <code>error TS2307: Cannot find module 'moduleA'.</code></p>\n<h2 id=\"relative-vs-non-relative-module-imports\">Relative vs. Non-relative module imports</h2>\n<p>Module imports are resolved differently based on whether the module reference is relative or non-relative.</p>\n<p>A <em>relative import</em> is one that starts with <code>/</code>, <code>./</code> or <code>../</code>. Some examples include:</p>\n<ul>\n<li><code>import Entry from \"./components/Entry\";</code></li>\n<li><code>import { DefaultHeaders } from \"../constants/http\";</code></li>\n<li><code>import \"/mod\";</code></li>\n</ul>\n<p>Any other import is considered <strong>non-relative</strong>. Some examples include:</p>\n<ul>\n<li><code>import * as $ from \"jQuery\";</code></li>\n<li><code>import { Component } from \"angular2/core\";</code></li>\n</ul>\n<p>A relative import is resolved relative to the importing file and <em>cannot</em> resolve to an ambient module declaration. You should use relative imports for your own modules that are guaranteed to maintain their relative location at runtime.</p>\n<h2 id=\"module-resolution-strategies\">Module Resolution Strategies</h2>\n<p>There are two possible module resolution strategies: <a href=\"#node\">Node</a> and <a href=\"#classic\">Classic</a>. You can use the <code>--moduleResolution</code> flag to specify the module resolution strategy. The default if not specified is <a href=\"#node\">Node</a>.</p>\n<h3 id=\"classic\">Classic</h3>\n<p>This used to be TypeScript’s default resolution strategy. Nowadays, this strategy is mainly present for backward compatibility.</p>\n<p>A relative import will be resolved relative to the importing file. So <code>import { b } from \"./moduleB\"</code> in source file <code>/root/src/folder/A.ts</code> would result in the following lookups:</p>\n<ol>\n<li><code>/root/src/folder/moduleB.ts</code></li>\n<li><code>/root/src/folder/moduleB.d.ts</code></li>\n</ol>\n<p>For non-relative module imports, however, the compiler walks up the directory tree starting with the directory containing the importing file, trying to locate a matching definition file.</p>\n<p>For example:</p>\n<p>A non-relative import to <code>moduleB</code> such as <code>import { b } from \"moduleB\"</code>, in a source file <code>/root/src/folder/A.ts</code>, would result in attempting the following locations for locating <code>\"moduleB\"</code>:</p>\n<ol>\n<li><code>/root/src/folder/moduleB.ts</code></li>\n<li><code>/root/src/folder/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/moduleB.ts</code></li>\n<li><code>/root/moduleB.d.ts</code></li>\n<li><code>/moduleB.ts</code></li>\n<li><code>/moduleB.d.ts</code></li>\n</ol>\n<h3 id=\"node\">Node</h3>\n<p>This resolution strategy attempts to mimic the <a href=\"https://nodejs.org/\">Node.js</a> module resolution mechanism at runtime. The full Node.js resolution algorithm is outlined in <a href=\"https://nodejs.org/api/modules.html#modules_all_together\">Node.js module documentation</a>.</p>\n<h4 id=\"how-nodejs-resolves-modules\">How Node.js resolves modules</h4>\n<p>To understand what steps the TS compiler will follow, it is important to shed some light on Node.js modules. Traditionally, imports in Node.js are performed by calling a function named <code>require</code>. The behavior Node.js takes will differ depending on if <code>require</code> is given a relative path or a non-relative path.</p>\n<p>Relative paths are fairly straightforward. As an example, let’s consider a file located at <code>/root/src/moduleA.js</code>, which contains the import <code>var x = require(\"./moduleB\");</code> Node.js resolves that import in the following order:</p>\n<ol>\n<li><p>As the file named <code>/root/src/moduleB.js</code>, if it exists.</p></li>\n<li><p>As the folder <code>/root/src/moduleB</code> if it contains a file named <code>package.json</code> that specifies a <code>\"main\"</code> module. In our example, if Node.js found the file <code>/root/src/moduleB/package.json</code> containing <code>{ \"main\": \"lib/mainModule.js\" }</code>, then Node.js will refer to <code>/root/src/moduleB/lib/mainModule.js</code>.</p></li>\n<li><p>As the folder <code>/root/src/moduleB</code> if it contains a file named <code>index.js</code>. That file is implicitly considered that folder’s “main” module.</p></li>\n</ol>\n<p>You can read more about this in Node.js documentation on <a href=\"https://nodejs.org/api/modules.html#modules_file_modules\">file modules</a> and <a href=\"https://nodejs.org/api/modules.html#modules_folders_as_modules\">folder modules</a>.</p>\n<p>However, resolution for a <a href=\"#relative-vs-non-relative-module-imports\">non-relative module name</a> is performed differently. Node will look for your modules in special folders named <code>node_modules</code>. A <code>node_modules</code> folder can be on the same level as the current file, or higher up in the directory chain. Node will walk up the directory chain, looking through each <code>node_modules</code> until it finds the module you tried to load.</p>\n<p>Following up our example above, consider if <code>/root/src/moduleA.js</code> instead used a non-relative path and had the import <code>var x = require(\"moduleB\");</code>. Node would then try to resolve <code>moduleB</code> to each of the locations until one worked.</p>\n<ol>\n<li><code>/root/src/node_modules/moduleB.js</code></li>\n<li>\n<code>/root/src/node_modules/moduleB/package.json</code> (if it specifies a <code>\"main\"</code> property)</li>\n<li>\n<code>/root/src/node_modules/moduleB/index.js</code><br><br>\n</li>\n<li><code>/root/node_modules/moduleB.js</code></li>\n<li>\n<code>/root/node_modules/moduleB/package.json</code> (if it specifies a <code>\"main\"</code> property)</li>\n<li>\n<code>/root/node_modules/moduleB/index.js</code><br><br>\n</li>\n<li><code>/node_modules/moduleB.js</code></li>\n<li>\n<code>/node_modules/moduleB/package.json</code> (if it specifies a <code>\"main\"</code> property)</li>\n<li><code>/node_modules/moduleB/index.js</code></li>\n</ol>\n<p>Notice that Node.js jumped up a directory in steps (4) and (7).</p>\n<p>You can read more about the process in Node.js documentation on <a href=\"https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\">loading modules from <code>node_modules</code></a>.</p>\n<h4 id=\"how-typescript-resolves-modules\">How TypeScript resolves modules</h4>\n<p>TypeScript will mimic the Node.js run-time resolution strategy in order to locate definition files for modules at compile-time. To accomplish this, TypeScript overlays the TypeScript source file extensions (<code>.ts</code>, <code>.tsx</code>, and <code>.d.ts</code>) over the Node’s resolution logic. TypeScript will also use a field in <code>package.json</code> named <code>\"typings\"</code> to mirror the purpose of <code>\"main\"</code> - the compiler will use it to find the “main” definition file to consult.</p>\n<p>For example, an import statement like <code>import { b } from \"./moduleB\"</code> in <code>/root/src/moduleA.ts</code> would result in attempting the following locations for locating <code>\"./moduleB\"</code>:</p>\n<ol>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.tsx</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li>\n<code>/root/src/moduleB/package.json</code> (if it specifies a <code>\"typings\"</code> property)</li>\n<li><code>/root/src/moduleB/index.ts</code></li>\n<li><code>/root/src/moduleB/index.tsx</code></li>\n<li><code>/root/src/moduleB/index.d.ts</code></li>\n</ol>\n<p>Recall that Node.js looked for a file named <code>moduleB.js</code>, then an applicable <code>package.json</code>, and then for an <code>index.js</code>.</p>\n<p>Similarly a non-relative import will follow the Node.js resolution logic, first looking up a file, then looking up an applicable folder. So <code>import { b } from \"moduleB\"</code> in source file <code>/src/moduleA.ts</code> would result in the following lookups:</p>\n<ol>\n<li><code>/root/src/node_modules/moduleB.ts</code></li>\n<li><code>/root/src/node_modules/moduleB.tsx</code></li>\n<li><code>/root/src/node_modules/moduleB.d.ts</code></li>\n<li>\n<code>/root/src/node_modules/moduleB/package.json</code> (if it specifies a <code>\"typings\"</code> property)</li>\n<li><code>/root/src/node_modules/moduleB/index.ts</code></li>\n<li><code>/root/src/node_modules/moduleB/index.tsx</code></li>\n<li>\n<code>/root/src/node_modules/moduleB/index.d.ts</code><br><br>\n</li>\n<li><code>/root/node_modules/moduleB.ts</code></li>\n<li><code>/root/node_modules/moduleB.tsx</code></li>\n<li><code>/root/node_modules/moduleB.d.ts</code></li>\n<li>\n<code>/root/node_modules/moduleB/package.json</code> (if it specifies a <code>\"typings\"</code> property)</li>\n<li><code>/root/node_modules/moduleB/index.ts</code></li>\n<li><code>/root/node_modules/moduleB/index.tsx</code></li>\n<li>\n<code>/root/node_modules/moduleB/index.d.ts</code><br><br>\n</li>\n<li><code>/node_modules/moduleB.ts</code></li>\n<li><code>/node_modules/moduleB.tsx</code></li>\n<li><code>/node_modules/moduleB.d.ts</code></li>\n<li>\n<code>/node_modules/moduleB/package.json</code> (if it specifies a <code>\"typings\"</code> property)</li>\n<li><code>/node_modules/moduleB/index.ts</code></li>\n<li><code>/node_modules/moduleB/index.tsx</code></li>\n<li><code>/node_modules/moduleB/index.d.ts</code></li>\n</ol>\n<p>Don’t be intimidated by the number of steps here - TypeScript is still only jumping up directories twice at steps (8) and (15). This is really no more complex than what Node.js itself is doing.</p>\n<h2 id=\"using---noresolve\">Using <code>--noResolve</code>\n</h2>\n<p>Normally the compiler will attempt to resolve all module imports before it starts the compilation process. Every time it successfully resolves an <code>import</code> to a file, the file is added to the set of files the compiler will process later on.</p>\n<p>The <code>--noResolve</code> compiler options instructs the compiler not to “add” any files to the compilation that were not passed on the command line. It will still try to resolve the module to files, but if the file as not specified, it will not be included.</p>\n<p>For instance:</p>\n<h4 id=\"appts\">app.ts</h4>\n<pre data-language=\"typescript\">import * as A from \"moduleA\" // OK, moduleA passed on the command-line\r\nimport * as B from \"moduleB\" // Error TS2307: Cannot find module 'moduleB'.\r\n</pre>\n<pre data-language=\"shell\">tsc app.ts moduleA.ts --noResolve\r\n</pre>\n<p>Compiling <code>app.ts</code> using <code>--noResolve</code> should result in:</p>\n<ul>\n<li>Correctly finding <code>moduleA</code> as it was passed on the command-line.</li>\n<li>Error for not finding <code>moduleB</code> as it was not passed.</li>\n</ul>\n<h2 id=\"common-questions\">Common Questions</h2>\n<h3 id=\"why-does-a-module-in-exclude-list-is-still-picked-up-by-the-compiler\">Why does a module in <code>exclude</code> list is still picked up by the compiler</h3>\n<p><code>tsconfig.json</code> turns a folder into a “project”. Without specifying any <code>“exclude”</code> or <code>“files”</code> entries, all files in the folder containing the <code>tsconfig.json</code> and all its sub-directories are included in your compilation. If you want to exclude some of the files use <code>“exclude”</code>, if you would rather specify all the files instead of letting the compiler look them up, use <code>“files”</code>.</p>\n<p>That was <code>tsconfig.json</code> automatic inclusion. That does not embed module resolution as discussed above. If the compiler identified a file as a target of a module import, it will be included in the compilation regardless if it was excluded in the previous steps.</p>\n<p>So to exclude a file from the compilation, you need to exclude it and all <strong>all</strong> files that has an <code>import</code> or <code>/// &lt;reference path=\"...\" /&gt;</code> directives to it.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/module-resolution.html</a>\n  </p>\n</div>\n","handbook/declaration-merging":"<h1 class=\"post-title\">Declaration Merging</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of ‘declaration merging’. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.</p>\n<p>For the purposes of this article, “declaration merging” means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it’s not limited to just two declarations.</p>\n<h2 id=\"basic-concepts\">Basic Concepts</h2>\n<p>In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.</p>\n<table>\n<thead><tr>\n<th>Declaration Type</th>\n<th style=\"text-align: center\">Namespace</th>\n<th style=\"text-align: center\">Type</th>\n<th style=\"text-align: center\">Value</th>\n</tr></thead>\n<tbody>\n<tr>\n<td>Namespace</td>\n<td style=\"text-align: center\">X</td>\n<td style=\"text-align: center\"></td>\n<td style=\"text-align: center\">X</td>\n</tr>\n<tr>\n<td>Class</td>\n<td style=\"text-align: center\"></td>\n<td style=\"text-align: center\">X</td>\n<td style=\"text-align: center\">X</td>\n</tr>\n<tr>\n<td>Enum</td>\n<td style=\"text-align: center\"></td>\n<td style=\"text-align: center\">X</td>\n<td style=\"text-align: center\">X</td>\n</tr>\n<tr>\n<td>Interface</td>\n<td style=\"text-align: center\"></td>\n<td style=\"text-align: center\">X</td>\n<td style=\"text-align: center\"></td>\n</tr>\n<tr>\n<td>Type Alias</td>\n<td style=\"text-align: center\"></td>\n<td style=\"text-align: center\">X</td>\n<td style=\"text-align: center\"></td>\n</tr>\n<tr>\n<td>Function</td>\n<td style=\"text-align: center\"></td>\n<td style=\"text-align: center\"></td>\n<td style=\"text-align: center\">X</td>\n</tr>\n<tr>\n<td>Variable</td>\n<td style=\"text-align: center\"></td>\n<td style=\"text-align: center\"></td>\n<td style=\"text-align: center\">X</td>\n</tr>\n</tbody>\n</table>\n<p>Understanding what is created with each declaration will help you understand what is merged when you perform a declaration merge.</p>\n<h2 id=\"merging-interfaces\">Merging Interfaces</h2>\n<p>The simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.</p>\n<pre data-language=\"typescript\">interface Box {\r\n  height: number;\r\n  width: number;\r\n}\r\n\r\ninterface Box {\r\n  scale: number;\r\n}\r\n\r\nlet box: Box = {height: 5, width: 6, scale: 10};\r\n</pre>\n<p>Non-function members of the interfaces must be unique. The compiler will issue an error if the interfaces both declare a non-function member of the same name.</p>\n<p>For function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface <code>A</code> merging with later interface <code>A</code>, the second interface will have a higher precedence than the first.</p>\n<p>That is, in the example:</p>\n<pre data-language=\"typescript\">interface Cloner {\r\n  clone(animal: Animal): Animal;\r\n}\r\n\r\ninterface Cloner {\r\n  clone(animal: Sheep): Sheep;\r\n}\r\n\r\ninterface Cloner {\r\n  clone(animal: Dog): Dog;\r\n  clone(animal: Cat): Cat;\r\n}\r\n</pre>\n<p>The three interfaces will merge to create a single declaration as so:</p>\n<pre data-language=\"typescript\">interface Cloner {\r\n  clone(animal: Dog): Dog;\r\n  clone(animal: Cat): Cat;\r\n  clone(animal: Sheep): Sheep;\r\n  clone(animal: Animal): Animal;\r\n}\r\n</pre>\n<p>Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.</p>\n<p>One exception to this rule is specialized signatures. If a signature has a parameter whose type is a <em>single</em> string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.</p>\n<p>For instance, the following interfaces will merge together:</p>\n<pre data-language=\"typescript\">interface Document {\r\n  createElement(tagName: any): Element;\r\n}\r\ninterface Document {\r\n  createElement(tagName: \"div\"): HTMLDivElement;\r\n  createElement(tagName: \"span\"): HTMLSpanElement;\r\n}\r\ninterface Document {\r\n  createElement(tagName: string): HTMLElement;\r\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\r\n}\r\n</pre>\n<p>The resulting merged declaration of <code>Document</code> will be the following:</p>\n<pre data-language=\"typescript\">interface Document {\r\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\r\n  createElement(tagName: \"div\"): HTMLDivElement;\r\n  createElement(tagName: \"span\"): HTMLSpanElement;\r\n  createElement(tagName: string): HTMLElement;\r\n  createElement(tagName: any): Element;\r\n}\r\n</pre>\n<h2 id=\"merging-namespaces\">Merging Namespaces</h2>\n<p>Similarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.</p>\n<p>To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.</p>\n<p>To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.</p>\n<p>The declaration merge of <code>Animals</code> in this example:</p>\n<pre data-language=\"typescript\">namespace Animals {\r\n  export class Zebra { }\r\n}\r\n\r\nnamespace Animals {\r\n  export interface Legged { numberOfLegs: number; }\r\n  export class Dog { }\r\n}\r\n</pre>\n<p>is equivalent to:</p>\n<pre data-language=\"typescript\">namespace Animals {\r\n  export interface Legged { numberOfLegs: number; }\r\n\r\n  export class Zebra { }\r\n  export class Dog { }\r\n}\r\n</pre>\n<p>This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.</p>\n<p>We can see this more clearly in this example:</p>\n<pre data-language=\"typescript\">namespace Animal {\r\n  let haveMuscles = true;\r\n\r\n  export function animalsHaveMuscles() {\r\n    return haveMuscles;\r\n  }\r\n}\r\n\r\nnamespace Animal {\r\n  export function doAnimalsHaveMuscles() {\r\n    return haveMuscles;  // &lt;-- error, haveMuscles is not visible here\r\n  }\r\n}\r\n</pre>\n<p>Because <code>haveMuscles</code> is not exported, only the <code>animalsHaveMuscles</code> function that shares the same un-merged namespace can see the symbol. The <code>doAnimalsHaveMuscles</code> function, even though it’s part of the merged <code>Animal</code> namespace can not see this un-exported member.</p>\n<h2 id=\"merging-namespaces-with-classes-functions-and-enums\">Merging Namespaces with Classes, Functions, and Enums</h2>\n<p>Namespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of patterns in JavaScript as well as other programming languages.</p>\n<h2 id=\"merging-namespaces-with-classes\">Merging Namespaces with Classes</h2>\n<p>This gives the user a way of describing inner classes.</p>\n<pre data-language=\"typescript\">class Album {\r\n  label: Album.AlbumLabel;\r\n}\r\nnamespace Album {\r\n  export class AlbumLabel { }\r\n}\r\n</pre>\n<p>The visibility rules for merged members is the same as described in the ‘Merging Namespaces’ section, so we must export the <code>AlbumLabel</code> class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.</p>\n<p>In addition to the pattern of inner classes, you may also be familiar with JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.</p>\n<pre data-language=\"typescript\">function buildLabel(name: string): string {\r\n  return buildLabel.prefix + name + buildLabel.suffix;\r\n}\r\n\r\nnamespace buildLabel {\r\n  export let suffix = \"\";\r\n  export let prefix = \"Hello, \";\r\n}\r\n\r\nalert(buildLabel(\"Sam Smith\"));\r\n</pre>\n<p>Similarly, namespaces can be used to extend enums with static members:</p>\n<pre data-language=\"typescript\">enum Color {\r\n  red = 1,\r\n  green = 2,\r\n  blue = 4\r\n}\r\n\r\nnamespace Color {\r\n  export function mixColor(colorName: string) {\r\n    if (colorName == \"yellow\") {\r\n      return Color.red + Color.green;\r\n    }\r\n    else if (colorName == \"white\") {\r\n      return Color.red + Color.green + Color.blue;\r\n    }\r\n    else if (colorName == \"magenta\") {\r\n      return Color.red + Color.blue;\r\n    }\r\n    else if (colorName == \"cyan\") {\r\n      return Color.green + Color.blue;\r\n    }\r\n  }\r\n}\r\n</pre>\n<h2 id=\"disallowed-merges\">Disallowed Merges</h2>\n<p>Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the [Mixins in TypeScript] section.</p>\n<h2 id=\"module-augmentation\">Module Augmentation</h2>\n<p>Although JavaScript modules do not support merging, you can patch existing objects by importing and then updating them. Let’s look at a toy Observable example:</p>\n<pre data-language=\"javascript\">// observable.js\r\nexport class Observable&lt;T&gt; {\r\n  // ... implementation left as an exercise for the reader ...\r\n}\r\n\r\n// map.js\r\nimport { Observable } from \"./observable\";\r\nObservable.prototype.map = function (f) {\r\n  // ... another exercise for the reader\r\n}\r\n</pre>\n<p>This works fine in TypeScript too, but the compiler doesn’t know about <code>Observable.prototype.map</code>. You can use module augmentation to tell the compiler about it:</p>\n<pre data-language=\"typescript\">// observable.ts stays the same\r\n// map.ts\r\nimport { Observable } from \"./observable\";\r\ndeclare module \"./observable\" {\r\n  interface Observable&lt;T&gt; {\r\n    map&lt;U&gt;(f: (x: T) =&gt; U): Observable&lt;U&gt;;\r\n  }\r\n}\r\nObservable.prototype.map = function (f) {\r\n  // ... another exercise for the reader\r\n}\r\n\r\n\r\n// consumer.ts\r\nimport { Observable } from \"./observable\";\r\nimport \"./map\";\r\nlet o: Observable&lt;number&gt;;\r\no.map(x =&gt; x.toFixed());\r\n</pre>\n<p>The module name is resolved the same way as module specifiers in <code>import</code>/<code>export</code>. See <a href=\"modules\">Modules</a> for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original. However, you can’t declare new top-level declarations in the augmentation – just patches to existing declarations.</p>\n<h2 id=\"global-augmentation\">Global augmentation</h2>\n<p>You can also add declarations to the global scope from inside a module:</p>\n<pre data-language=\"typescript\">// observable.ts\r\nexport class Observable&lt;T&gt; {\r\n  // ... still no implementation ...\r\n}\r\n\r\ndeclare global {\r\n  interface Array&lt;T&gt; {\r\n    toObservable(): Observable&lt;T&gt;;\r\n  }\r\n}\r\n\r\nArray.prototype.toObservable = function () {\r\n  // ...\r\n}\r\n</pre>\n<p>Global augmentations have the same behavior and limits as module augmentations.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-merging.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/declaration-merging.html</a>\n  </p>\n</div>\n","handbook/triple-slash-directives":"<h1 class=\"post-title\">Triple-Slash Directives</h1>\n\n<p>Triple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.</p>\n<p>Triple-slash directives are <strong>only</strong> valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.</p>\n<h2 id=\"reference-path-\"><code>/// &lt;reference path=\"...\" /&gt;</code></h2>\n<p>The <code>/// &lt;reference path=\"...\" /&gt;</code> directive is the most common of this group. It serves as a declaration of <em>dependency</em> between files.</p>\n<p>Triple-slash references instruct the compiler to include additional files in the compilation process.</p>\n<p>They also serve as a method to order the output when using <code>--out</code> or <code>--outFile</code>. Files are emitted to the output file location in the same order as the input after preprocessing pass.</p>\n<h3 id=\"preprocessing-input-files\">Preprocessing input files</h3>\n<p>The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.</p>\n<p>The process starts with a set of <em>root files</em>; these are the file names specified on the command-line or in the <code>\"files\"</code> list in the <code>tsconfig.json</code> file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth first manner, in the order they have been seen in the file.</p>\n<p>A triple-slash reference path is resolved relative to the containing file, if unrooted.</p>\n<h3 id=\"errors\">Errors</h3>\n<p>It is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.</p>\n<h3 id=\"using---noresolve\">Using <code>--noResolve</code>\n</h3>\n<p>If the compiler flag <code>--noResolve</code> is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.</p>\n<h2 id=\"reference-no-default-libtrue\"><code>/// &lt;reference no-default-lib=\"true\"/&gt;</code></h2>\n<p>This directive marks a file as a <em>default library</em>. You will see this comment at the top of <code>lib.d.ts</code> and its different variants.</p>\n<p>This directive instructs the compiler to <em>not</em> include the default library (i.e. <code>lib.d.ts</code>) in the compilation. The impact here is similar to passing <code>--noLib</code> on the command line.</p>\n<p>Also note that when passing <code>--skipDefaultLibCheck</code>, the compiler will only skip checking files with <code>/// &lt;reference no-default-lib=\"true\"/&gt;</code>.</p>\n<h2 id=\"amd-module-\"><code>/// &lt;amd-module /&gt;</code></h2>\n<p>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. <code>r.js</code>).</p>\n<p>The <code>amd-module</code> directive allows passing an optional module name to the compiler:</p>\n<h5 id=\"amdmodulets\">amdModule.ts</h5>\n<pre data-language=\"typescript\">///&lt;amd-module name='NamedModule'/&gt;\r\nexport class C {\r\n}\r\n</pre>\n<p>Will result in assigning the name <code>NamedModule</code> to the module as part of calling the AMD <code>define</code>:</p>\n<h5 id=\"amdmodulejs\">amdModule.js</h5>\n<pre data-language=\"javascript\">define(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) {\r\n  var C = (function () {\r\n    function C() {\r\n    }\r\n    return C;\r\n  })();\r\n  exports.C = C;\r\n});\r\n</pre>\n<h2 id=\"amd-dependency-\"><code>/// &lt;amd-dependency /&gt;</code></h2>\n<blockquote><p><strong>Note</strong>: this directive has been deprecated. Use <code>import \"moduleName\";</code> statements instead.</p></blockquote>\n<p><code>/// &lt;amd-dependency path=\"x\" /&gt;</code> informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call.</p>\n<p>The <code>amd-dependency</code> directive can also have an optional <code>name</code> property; this allows passing an optional name for an amd-dependency:</p>\n<pre data-language=\"typescript\">/// &lt;amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/&gt;\r\ndeclare var moduleA:MyType\r\nmoduleA.callStuff()\r\n</pre>\n<p>Generated JS code:</p>\n<pre data-language=\"javascript\">define([\"require\", \"exports\", \"legacy/moduleA\"], function (require, exports, moduleA) {\r\n  moduleA.callStuff()\r\n});\r\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html</a>\n  </p>\n</div>\n","handbook/jsx":"<h1 class=\"post-title\">JSX</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p><a href=\"https://facebook.github.io/jsx/\">JSX</a> is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific. JSX came to popularity with the <a href=\"http://facebook.github.io/react/\">React</a> framework, but has since seen other applications as well. TypeScript supports embedding, type checking, and compiling JSX directly into JavaScript.</p>\n<h2 id=\"basic-usage\">Basic usage</h2>\n<p>In order to use JSX you must do two things.</p>\n<ol>\n<li>Name your files with a <code>.tsx</code> extension</li>\n<li>Enable the <code>jsx</code> option</li>\n</ol>\n<p>TypeScript ships with two JSX modes: <code>preserve</code> and <code>react</code>. These modes only affect the emit stage - type checking is unaffected. The <code>preserve</code> mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. <a href=\"https://babeljs.io/\">Babel</a>). Additionally the output will have a <code>.jsx</code> file extension. The <code>react</code> mode will emit <code>React.createElement</code>, does not need to go through a JSX transformation before use, and the output will have a <code>.js</code> file extension.</p>\n<table>\n<thead><tr>\n<th>Mode</th>\n<th>Input</th>\n<th>Output</th>\n<th>Output File Extension</th>\n</tr></thead>\n<tbody>\n<tr>\n<td><code>preserve</code></td>\n<td><code>&lt;div /&gt;</code></td>\n<td><code>&lt;div /&gt;</code></td>\n<td><code>.jsx</code></td>\n</tr>\n<tr>\n<td><code>react</code></td>\n<td><code>&lt;div /&gt;</code></td>\n<td><code>React.createElement(\"div\")</code></td>\n<td><code>.js</code></td>\n</tr>\n</tbody>\n</table>\n<p>You can specify this mode using either the <code>--jsx</code> command line flag or the corresponding option in your <a href=\"tsconfig.json\">tsconfig.json</a> file.</p>\n<blockquote><p><em>Note: The identifier <code>React</code> is hard-coded, so you must make React available with an uppercase R.</em></p></blockquote>\n<h2 id=\"the-as-operator\">The <code>as</code> operator</h2>\n<p>Recall how to write a type assertion:</p>\n<pre data-language=\"typescript\">var foo = &lt;foo&gt;bar;\r\n</pre>\n<p>Here we are asserting the variable <code>bar</code> to have the type <code>foo</code>. Since TypeScript also uses angle brackets for type assertions, JSX’s syntax introduces certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in <code>.tsx</code> files.</p>\n<p>To make up for this loss of functionality in <code>.tsx</code> files, a new type assertion operator has been added: <code>as</code>. The above example can easily be rewritten with the <code>as</code> operator.</p>\n<pre data-language=\"typescript\">var foo = bar as foo;\r\n</pre>\n<p>The <code>as</code> operator is available in both <code>.ts</code> and <code>.tsx</code> files, and is identical in behavior to the other type assertion style.</p>\n<h2 id=\"type-checking\">Type Checking</h2>\n<p>In order to understand type checking with JSX, you must first understand the difference between intrinsic elements value-based elements. Given a JSX expression <code>&lt;expr /&gt;</code>, <code>expr</code> may either refer to something intrinsic to the environment (e.g. a <code>div</code> or <code>span</code> in a DOM environment) or to a custom component that you’ve created. This is important for two reasons:</p>\n<ol>\n<li>For React, intrinsic elements are emitted as strings (<code>React.createElement(\"div\")</code>), whereas a component you’ve created is not (<code>React.createElement(MyComponent)</code>).</li>\n<li>The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known <em>intrinsically</em> whereas components will likely want to specify their own set of attributes.</li>\n</ol>\n<p>TypeScript uses the <a href=\"http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components\">same convention that React does</a> for distinguishing between these. An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.</p>\n<h2 id=\"intrinsic-elements\">Intrinsic elements</h2>\n<p>Intrinsic elements are looked up on the special interface <code>JSX.IntrinsicElements</code>. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if interface <em>is</em> present, then the name of the intrinsic element is looked up as a property on the <code>JSX.IntrinsicElements</code> interface. For example:</p>\n<pre data-language=\"typescript\">declare namespace JSX {\r\n  interface IntrinsicElements {\r\n    foo: any\r\n  }\r\n}\r\n\r\n&lt;foo /&gt;; // ok\r\n&lt;bar /&gt;; // error\r\n</pre>\n<p>In the above example, <code>&lt;foo /&gt;</code> will work fine but <code>&lt;bar /&gt;</code> will result in an error since it has not been specified on <code>JSX.IntrinsicElements</code>.</p>\n<blockquote><p>Note: You can also specify a catch-all string indexer on <code>JSX.IntrinsicElements</code> as follows: <code>ts declare namespace JSX { interface IntrinsicElements { [elemName: string]: any; } }</code></p></blockquote>\n<h2 id=\"value-based-elements\">Value-based elements</h2>\n<p>Value based elements are simply looked up by identifiers that are in scope.</p>\n<pre data-language=\"typescript\">import MyComponent from \"./myComponent\";\r\n\r\n&lt;MyComponent /&gt;; // ok\r\n&lt;SomeOtherComponent /&gt;; // error\r\n</pre>\n<p>It is possible to limit the type of a value-based element. However, for this we must introduce two new terms: the <em>element class type</em> and the <em>element instance type</em>.</p>\n<p>Given <code>&lt;Expr /&gt;</code>, the <em>element class type</em> is the type of <code>Expr</code>. So in the example above, if <code>MyComponent</code> was an ES6 class the class type would be that class. If <code>MyComponent</code> was a factory function, the class type would be that function.</p>\n<p>Once the class type is established, the instance type is determined by the union of the return types of the class type’s call signatures and construct signatures. So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.</p>\n<pre data-language=\"typescript\">class MyComponent {\r\n  render() {}\r\n}\r\n\r\n// use a construct signature\r\nvar myComponent = new MyComponent();\r\n\r\n// element class type =&gt; MyComponent\r\n// element instance type =&gt; { render: () =&gt; void }\r\n\r\nfunction MyFactoryFunction() {\r\n  return {\r\n  render: () =&gt; {\r\n  }\r\n  }\r\n}\r\n\r\n// use a call signature\r\nvar myComponent = MyFactoryFunction();\r\n\r\n// element class type =&gt; FactoryFunction\r\n// element instance type =&gt; { render: () =&gt; void }\r\n</pre>\n<p>The element instance type is interesting because it must be assignable to <code>JSX.ElementClass</code> or it will result in an error. By default <code>JSX.ElementClass</code> is <code>{}</code>, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.</p>\n<pre data-language=\"typescript\">declare namespace JSX JSX {\r\n  interface ElementClass {\r\n  render: any;\r\n  }\r\n}\r\n\r\nclass MyComponent {\r\n  render() {}\r\n}\r\nfunction MyFactoryFunction() {\r\n  return { render: () =&gt; {} }\r\n}\r\n\r\n&lt;MyComponent /&gt;; // ok\r\n&lt;MyFactoryFunction /&gt;; // ok\r\n\r\nclass NotAValidComponent {}\r\nfunction NotAValidFactoryFunction() {\r\n  return {};\r\n}\r\n\r\n&lt;NotAValidComponent /&gt;; // error\r\n&lt;NotAValidFactoryFunction /&gt;; // error\r\n</pre>\n<h2 id=\"attribute-type-checking\">Attribute type checking</h2>\n<p>The first step to type checking attributes is to determine the <em>element attributes type</em>. This is slightly different between intrinsic and value-based elements.</p>\n<p>For intrinsic elements, it is the type of the property on <code>JSX.IntrinsicElements</code></p>\n<pre data-language=\"typescript\">declare namespace JSX {\r\n  interface IntrinsicElements {\r\n  foo: { bar?: boolean }\r\n  }\r\n}\r\n\r\n// element attributes type for `foo` is `{bar?: boolean}`\r\n&lt;foo bar /&gt;;\r\n</pre>\n<p>For value-based elements, it is a bit more complex. It is determined by the type of a property on the <em>element instance type</em> that was previously determined. Which property to use is determined by <code>JSX.ElementAttributesProperty</code>. It should be declared with a single property. The name of that property is then used.</p>\n<pre data-language=\"typescript\">declare namespace JSX {\r\n  interface ElementAttributesProperty {\r\n  props; // specify the property name to use\r\n  }\r\n}\r\n\r\nclass MyComponent {\r\n  // specify the property on the element instance type\r\n  props: {\r\n  foo?: string;\r\n  }\r\n}\r\n\r\n// element attributes type for `MyComponent` is `{foo?: string}`\r\n&lt;MyComponent foo=\"bar\" /&gt;\r\n</pre>\n<p>The element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.</p>\n<pre data-language=\"typescript\">declare namespace JSX {\r\n  interface IntrinsicElements {\r\n  foo: { requiredProp: string; optionalProp?: number }\r\n  }\r\n}\r\n\r\n&lt;foo requiredProp=\"bar\" /&gt;; // ok\r\n&lt;foo requiredProp=\"bar\" optionalProp={0} /&gt;; // ok\r\n&lt;foo /&gt;; // error, requiredProp is missing\r\n&lt;foo requiredProp={0} /&gt;; // error, requiredProp should be a string\r\n&lt;foo requiredProp=\"bar\" unknownProp /&gt;; // error, unknownProp does not exist\r\n&lt;foo requiredProp=\"bar\" some-unknown-prop /&gt;; // ok, because `some-unknown-prop` is not a valid identifier\r\n</pre>\n<blockquote><p>Note: If an attribute name is not a valid JS identifier (like a <code>data-*</code> attribute), it is not considered to be an error if it is not found in the element attributes type.</p></blockquote>\n<p>The spread operator also works:</p>\n<pre data-language=\"JSX\">var props = { requiredProp: 'bar' };\r\n&lt;foo {...props} /&gt;; // ok\r\n\r\nvar badProps = {};\r\n&lt;foo {...badProps} /&gt;; // error\r\n</pre>\n<h2 id=\"the-jsx-result-type\">The JSX result type</h2>\n<p>By default the result of a JSX expression is typed as <code>any</code>. You can customize the type by specifying the <code>JSX.Element</code> interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.</p>\n<h2 id=\"embedding-expressions\">Embedding Expressions</h2>\n<p>JSX allows you to embed expressions between tags by surrounding the expressions with curly braces (<code>{ }</code>).</p>\n<pre data-language=\"JSX\">var a = &lt;div&gt;\r\n  {['foo', 'bar'].map(i =&gt; &lt;span&gt;{i / 2}&lt;/span&gt;)}\r\n&lt;/div&gt;\r\n</pre>\n<p>The above code will result in an error since you cannot divide a string by a number. The output, when using the <code>preserve</code> option, looks like:</p>\n<pre data-language=\"JSX\">var a = &lt;div&gt;\r\n  {['foo', 'bar'].map(function (i) { return &lt;span&gt;{i / 2}&lt;/span&gt;; })}\r\n&lt;/div&gt;\r\n</pre>\n<h2 id=\"react-integration\">React integration</h2>\n<p>To use JSX with React you should use the <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react\">React typings</a>. These typings define the <code>JSX</code> namespace appropriately for use with React.</p>\n<pre data-language=\"typescript\">/// &lt;reference path=\"react.d.ts\" /&gt;\r\n\r\ninterface Props {\r\n  foo: string;\r\n}\r\n\r\nclass MyComponent extends React.Component&lt;Props, {}&gt; {\r\n  render() {\r\n  return &lt;span&gt;{this.props.foo}&lt;/span&gt;\r\n  }\r\n}\r\n\r\n&lt;MyComponent foo=\"bar\" /&gt;; // ok\r\n&lt;MyComponent foo={0} /&gt;; // error\r\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/jsx.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/jsx.html</a>\n  </p>\n</div>\n","handbook/mixins":"<h1 class=\"post-title\">Mixins</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.</p>\n<h2 id=\"mixin-sample\">Mixin sample</h2>\n<p>In the code below, we show how you can model mixins in TypeScript. After the code, we’ll break down how it works.</p>\n<pre data-language=\"typescript\">// Disposable Mixin\r\nclass Disposable {\r\n  isDisposed: boolean;\r\n  dispose() {\r\n    this.isDisposed = true;\r\n  }\r\n\r\n}\r\n\r\n// Activatable Mixin\r\nclass Activatable {\r\n  isActive: boolean;\r\n  activate() {\r\n    this.isActive = true;\r\n  }\r\n  deactivate() {\r\n    this.isActive = false;\r\n  }\r\n}\r\n\r\nclass SmartObject implements Disposable, Activatable {\r\n  constructor() {\r\n    setInterval(() =&gt; console.log(this.isActive + \" : \" + this.isDisposed), 500);\r\n  }\r\n\r\n  interact() {\r\n    this.activate();\r\n  }\r\n\r\n  // Disposable\r\n  isDisposed: boolean = false;\r\n  dispose: () =&gt; void;\r\n  // Activatable\r\n  isActive: boolean = false;\r\n  activate: () =&gt; void;\r\n  deactivate: () =&gt; void;\r\n}\r\napplyMixins(SmartObject, [Disposable, Activatable]);\r\n\r\nlet smartObj = new SmartObject();\r\nsetTimeout(() =&gt; smartObj.interact(), 1000);\r\n\r\n////////////////////////////////////////\r\n// In your runtime library somewhere\r\n////////////////////////////////////////\r\n\r\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\r\n  baseCtors.forEach(baseCtor =&gt; {\r\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {\r\n      derivedCtor.prototype[name] = baseCtor.prototype[name];\r\n    });\r\n  });\r\n}\r\n</pre>\n<h2 id=\"understanding-the-sample\">Understanding the sample</h2>\n<p>The code sample starts with the two classes that will act as our mixins. You can see each one is focused on a particular activity or capability. We’ll later mix these together to form a new class from both capabilities.</p>\n<pre data-language=\"typescript\">// Disposable Mixin\r\nclass Disposable {\r\n  isDisposed: boolean;\r\n  dispose() {\r\n    this.isDisposed = true;\r\n  }\r\n\r\n}\r\n\r\n// Activatable Mixin\r\nclass Activatable {\r\n  isActive: boolean;\r\n  activate() {\r\n    this.isActive = true;\r\n  }\r\n  deactivate() {\r\n    this.isActive = false;\r\n  }\r\n}\r\n</pre>\n<p>Next, we’ll create the class that will handle the combination of the two mixins. Let’s look at this in more detail to see how it does this:</p>\n<pre data-language=\"typescript\">class SmartObject implements Disposable, Activatable {\r\n</pre>\n<p>The first thing you may notice in the above is that instead of using <code>extends</code>, we use <code>implements</code>. This treats the classes as interfaces, and only uses the types behind Disposable and Activatable rather than the implementation. This means that we’ll have to provide the implementation in class. Except, that’s exactly what we want to avoid by using mixins.</p>\n<p>To satisfy this requirement, we create stand-in properties and their types for the members that will come from our mixins. This satisfies the compiler that these members will be available at runtime. This lets us still get the benefit of the mixins, albeit with some bookkeeping overhead.</p>\n<pre data-language=\"typescript\">// Disposable\r\nisDisposed: boolean = false;\r\ndispose: () =&gt; void;\r\n// Activatable\r\nisActive: boolean = false;\r\nactivate: () =&gt; void;\r\ndeactivate: () =&gt; void;\r\n</pre>\n<p>Finally, we mix our mixins into the class, creating the full implementation.</p>\n<pre data-language=\"typescript\">applyMixins(SmartObject, [Disposable, Activatable]);\r\n</pre>\n<p>Lastly, we create a helper function that will do the mixing for us. This will run through the properties of each of the mixins and copy them over to the target of the mixins, filling out the stand-in properties with their implementations.</p>\n<pre data-language=\"typescript\">function applyMixins(derivedCtor: any, baseCtors: any[]) {\r\n  baseCtors.forEach(baseCtor =&gt; {\r\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {\r\n      derivedCtor.prototype[name] = baseCtor.prototype[name];\r\n    });\r\n  });\r\n}\r\n\r\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/mixins.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/mixins.html</a>\n  </p>\n</div>\n","handbook/tsconfig.json":"<h1 class=\"post-title\">tsconfig.json</h1>\n\n<h2 id=\"overview\">Overview</h2>\n<p>The presence of a <code>tsconfig.json</code> file in a directory indicates that the directory is the root of a TypeScript project. The <code>tsconfig.json</code> file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</p>\n<h2 id=\"using-tsconfigjson\">Using tsconfig.json</h2>\n<ul>\n<li>By invoking tsc with no input files, in which case the compiler searches for the <code>tsconfig.json</code> file starting in the current directory and continuing up the parent directory chain.</li>\n<li>By invoking tsc with no input files and a <code>-project</code> (or just <code>-p</code>) command line option that specifies the path of a directory containing a <code>tsconfig.json</code> file.</li>\n</ul>\n<p>When input files are specified on the command line, <code>tsconfig.json</code> files are ignored.</p>\n<h2 id=\"examples\">Examples</h2>\n<p>Example <code>tsconfig.json</code> files:</p>\n<ul>\n<li>\n<p>Using the <code>\"files\"</code> property</p>\n<pre data-language=\"javascripton\">{\r\n  \"compilerOptions\": {\r\n    \"module\": \"commonjs\",\r\n    \"noImplicitAny\": true,\r\n    \"removeComments\": true,\r\n    \"preserveConstEnums\": true,\r\n    \"out\": \"../../built/local/tsc.js\",\r\n    \"sourceMap\": true\r\n  },\r\n  \"files\": [\r\n    \"core.ts\",\r\n    \"sys.ts\",\r\n    \"types.ts\",\r\n    \"scanner.ts\",\r\n    \"parser.ts\",\r\n    \"utilities.ts\",\r\n    \"binder.ts\",\r\n    \"checker.ts\",\r\n    \"emitter.ts\",\r\n    \"program.ts\",\r\n    \"commandLineParser.ts\",\r\n    \"tsc.ts\",\r\n    \"diagnosticInformationMap.generated.ts\"\r\n  ]\r\n}\r\n</pre>\n</li>\n<li>\n<p>Using the <code>\"exclude\"</code> property</p>\n<pre data-language=\"javascripton\">{\r\n  \"compilerOptions\": {\r\n    \"module\": \"commonjs\",\r\n    \"noImplicitAny\": true,\r\n    \"removeComments\": true,\r\n    \"preserveConstEnums\": true,\r\n    \"out\": \"../../built/local/tsc.js\",\r\n    \"sourceMap\": true\r\n  },\r\n  \"exclude\": [\r\n    \"node_modules\",\r\n    \"wwwroot\"\r\n  ]\r\n}\r\n</pre>\n</li>\n</ul>\n<h2 id=\"details\">Details</h2>\n<p>The <code>\"compilerOptions\"</code> property can be omitted, in which case the compiler’s defaults are used. See our full list of supported <a href=\"compiler-options\">Compiler Options</a>.</p>\n<p>If no <code>\"files\"</code> property is present in a <code>tsconfig.json</code>, the compiler defaults to including all TypeScript (<code>*.ts</code> or <code>*.tsx</code>) files in the containing directory and subdirectories. When a <code>\"files\"</code> property is present, only the specified files are included.</p>\n<p>If the <code>\"exclude\"</code> property is specified, the compiler includes all TypeScript (<code>*.ts</code> or <code>*.tsx</code>) files in the containing directory and subdirectories except for those files or folders that are excluded.</p>\n<p>The <code>\"files\"</code> property cannot be used in conjunction with the <code>\"exclude\"</code> property. If both are specified then the <code>\"files\"</code> property takes precedence.</p>\n<p>Any files that are referenced by those specified in the <code>\"files\"</code> property are also included. Similarly, if a file <code>B.ts</code> is referenced by another file <code>A.ts</code>, then <code>B.ts</code> cannot be excluded unless the referencing file <code>A.ts</code> is also specified in the <code>\"exclude\"</code> list.</p>\n<p>A <code>tsconfig.json</code> file is permitted to be completely empty, which compiles all files in the containing directory and subdirectories with the default compiler options.</p>\n<p>Compiler options specified on the command line override those specified in the <code>tsconfig.json</code> file.</p>\n<h2 id=\"compileonsave\"><code>compileOnSave</code></h2>\n<p>Setting a top-level property <code>compileOnSave</code> signals to the IDE to generate all files for a given tsconfig.json upon saving.</p>\n<pre data-language=\"javascripton\">{\r\n   \"compileOnSave\": true,\r\n   \"compilerOptions\": {\r\n     \"noImplicitAny\" : true\r\n   }\r\n}\r\n</pre>\n<p>This feature is currently supported in Visual Studio 2015 with TypeScript 1.8.4 and above, and <a href=\"https://github.com/TypeStrong/atom-typescript/blob/master/docs/tsconfig.html#compileonsave\">atom-typescript</a> plugin.</p>\n<h2 id=\"schema\">Schema</h2>\n<p>Schema can be found at: <a href=\"http://json.schemastore.org/tsconfig\">http://json.schemastore.org/tsconfig</a></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig.json.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/tsconfig.json.html</a>\n  </p>\n</div>\n","handbook/typings-for-npm-packages":"<h1 class=\"post-title\">Typings for NPM Packages</h1>\n\n<p>The TypeScript compiler resolves Node module names by following the <a href=\"https://nodejs.org/api/modules.html#modules_all_together\">Node.js module resolution algorithm</a>. TypeScript can also load typings that are bundled with npm packages. The compiler will try to discover typings for module <code>\"foo\"</code> using the following set of rules:</p>\n<ol>\n<li>\n<p>Try to load the <code>package.json</code> file located in the appropriate package folder (<code>node_modules/foo/</code>). If present,read the path to the typings file described in the <code>\"typings\"</code> field. For example, in the following <code>package.json</code>, the compiler will resolve the typings at <code>node_modules/foo/lib/foo.d.ts</code></p>\n<pre data-language=\"javascripton\">{\r\n  \"name\": \"foo\",\r\n  \"author\": \"Vandelay Industries\",\r\n  \"version\": \"1.0.0\",\r\n  \"main\": \"./lib/foo.js\",\r\n  \"typings\": \"./lib/foo.d.ts\"\r\n}\r\n</pre>\n</li>\n<li><p>Try to load a file named <code>index.d.ts</code> located in the package folder (<code>node_modules/foo/</code>) - this file should contain typings for the package.</p></li>\n</ol>\n<p>The precise algorithm for module resolution can be found <a href=\"https://github.com/Microsoft/TypeScript/issues/2338\">here</a>.</p>\n<h3 id=\"your-definition-files-should\">Your definition files should</h3>\n<ul>\n<li>be<code>.d.ts</code> files</li>\n<li>be written as external modules</li>\n<li>not contain triple-slash references</li>\n</ul>\n<p>The rationale is that typings should not bring new compilable items to the set of compiled files; otherwise actual implementation files in the package can be overwritten during compilation. Additionally, <strong>loading typings should not pollute global scope</strong> by bringing potentially conflicting entries from different version of the same library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/typings-for-npm-packages.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/typings-for-npm-packages.html</a>\n  </p>\n</div>\n","handbook/compiler-options":"<h1 class=\"post-title\">Compiler Options</h1>\n\n<h2 id=\"compiler-options\">Compiler Options</h2>\n<table>\n<thead><tr>\n<th>Option</th>\n<th>Shorthand</th>\n<th>Description</th>\n</tr></thead>\n<tbody>\n<tr>\n<td><code>--declaration</code></td>\n<td><code>-d</code></td>\n<td>Generates corresponding ‘.d.ts’ file.</td>\n</tr>\n<tr>\n<td><code>--help</code></td>\n<td><code>-h</code></td>\n<td>Print help message.</td>\n</tr>\n<tr>\n<td><code>--version</code></td>\n<td><code>-v</code></td>\n<td>Print the compiler’s version.</td>\n</tr>\n<tr>\n<td><code>--module</code></td>\n<td><code>-m</code></td>\n<td>Specify module code generation: ‘commonjs’, ‘amd’, ‘system’, ‘umd’, or ‘es2015’. Only ‘amd’ and ‘system’ can be used in conjunction with <code>--outFile</code>. The ‘es2015’ value may not be used when targeting ES5 or lower.</td>\n</tr>\n<tr>\n<td><code>--project</code></td>\n<td><code>-p</code></td>\n<td>Compile the project in the given directory. The directory needs to contain a <code>tsconfig.json</code> file to direct compilation. See <a href=\"tsconfig.json\">tsconfig.json</a> documentation for more details.</td>\n</tr>\n<tr>\n<td><code>--target</code></td>\n<td><code>-t</code></td>\n<td>Specify ECMAScript target version: ‘ES3’ (default), ‘ES5’, or ‘ES6’<sup>[1]</sup>\n</td>\n</tr>\n<tr>\n<td><code>--watch</code></td>\n<td><code>-w</code></td>\n<td>Run the compiler in watch mode. Watch input files and trigger recompilation on changes.</td>\n</tr>\n<tr>\n<td><code>--charset</code></td>\n<td></td>\n<td>The character set of the input files.</td>\n</tr>\n<tr>\n<td><code>--diagnostics</code></td>\n<td></td>\n<td>Show diagnostic information.</td>\n</tr>\n<tr>\n<td><code>--emitBOM</code></td>\n<td></td>\n<td>Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.</td>\n</tr>\n<tr>\n<td>\n<code>--emitDecoratorMetadata</code><sup>[1]</sup>\n</td>\n<td></td>\n<td>Emit design-type metadata for decorated declarations in source. See <a href=\"https://github.com/Microsoft/TypeScript/issues/2577\">issue #2577</a> for details.</td>\n</tr>\n<tr>\n<td><code>--experimentalDecorators</code></td>\n<td></td>\n<td>Enables experimental support for ES7 decorators.</td>\n</tr>\n<tr>\n<td><code>--inlineSourceMap</code></td>\n<td></td>\n<td>Emit a single file with source maps instead of having a separate file.</td>\n</tr>\n<tr>\n<td><code>--inlineSources</code></td>\n<td></td>\n<td>Emit the source alongside the sourcemaps within a single file; requires <code>--inlineSourceMap</code> or <code>--sourceMap</code> to be set.</td>\n</tr>\n<tr>\n<td><code>--isolatedModules</code></td>\n<td></td>\n<td>Unconditionally emit imports for unresolved files.</td>\n</tr>\n<tr>\n<td><code>--jsx</code></td>\n<td></td>\n<td>Support JSX in ‘.tsx’ files: ‘React’ or ‘Preserve’. See <a href=\"jsx\">JSX</a>.</td>\n</tr>\n<tr>\n<td><code>--reactNamespace</code></td>\n<td></td>\n<td>Specifies the object invoked for <code>createElement</code> and <code>__spread</code> when targeting ‘react’ JSX emit.</td>\n</tr>\n<tr>\n<td><code>--listFiles</code></td>\n<td></td>\n<td>Print names of files part of the compilation.</td>\n</tr>\n<tr>\n<td><code>--locale</code></td>\n<td></td>\n<td>The locale to use to show error messages, e.g. en-us.</td>\n</tr>\n<tr>\n<td><code>--mapRoot</code></td>\n<td></td>\n<td>Specifies the location where debugger should locate map files instead of generated locations. Use this flag if the .map files will be located at run-time in a different location than than the .js files. The location specified will be embedded in the sourceMap to direct the debugger where the map files where be located.</td>\n</tr>\n<tr>\n<td><code>--moduleResolution</code></td>\n<td></td>\n<td>Determine how modules get resolved. Either ‘node’ for Node.js/io.js style resolution, or ‘classic’ (default).</td>\n</tr>\n<tr>\n<td><code>--newLine</code></td>\n<td></td>\n<td>Use the specified end of line sequence to be used when emitting files: ‘CRLF’ (dos) or ‘LF’ (unix).”</td>\n</tr>\n<tr>\n<td><code>--noEmit</code></td>\n<td></td>\n<td>Do not emit outputs.</td>\n</tr>\n<tr>\n<td><code>--noEmitOnError</code></td>\n<td></td>\n<td>Do not emit outputs if any errors were reported.</td>\n</tr>\n<tr>\n<td><code>--noEmitHelpers</code></td>\n<td></td>\n<td>Do not generate custom helper functions like <code>__extends</code> in compiled output.</td>\n</tr>\n<tr>\n<td><code>--noImplicitAny</code></td>\n<td></td>\n<td>Raise error on expressions and declarations with an implied ‘any’ type.</td>\n</tr>\n<tr>\n<td><code>--noLib</code></td>\n<td></td>\n<td>Do not include the default library file (lib.d.ts).</td>\n</tr>\n<tr>\n<td><code>--noResolve</code></td>\n<td></td>\n<td>Do not add triple-slash references or module import targets to the list of compiled files.</td>\n</tr>\n<tr>\n<td><code>--skipDefaultLibCheck</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>--out</code></td>\n<td></td>\n<td>DEPRECATED. Use <code>--outFile</code> instead.</td>\n</tr>\n<tr>\n<td><code>--outDir</code></td>\n<td></td>\n<td>Redirect output structure to the directory.</td>\n</tr>\n<tr>\n<td><code>--outFile</code></td>\n<td></td>\n<td>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See output file order documentation for more details.</td>\n</tr>\n<tr>\n<td><code>--preserveConstEnums</code></td>\n<td></td>\n<td>Do not erase const enum declarations in generated code. See <a href=\"https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations\">const enums documentation</a> for more details.</td>\n</tr>\n<tr>\n<td>\n<code>--pretty</code><sup>[1]</sup>\n</td>\n<td></td>\n<td>Stylize errors and messages using color and context.</td>\n</tr>\n<tr>\n<td><code>--removeComments</code></td>\n<td></td>\n<td>Remove all comments except copy-right header comments beginning with <code>/*!</code>\n</td>\n</tr>\n<tr>\n<td><code>--rootDir</code></td>\n<td></td>\n<td>Specifies the root directory of input files. Only use to control the output directory structure with <code>--outDir</code>.</td>\n</tr>\n<tr>\n<td><code>--sourceMap</code></td>\n<td></td>\n<td>Generates corresponding ‘.map’ file.</td>\n</tr>\n<tr>\n<td><code>--sourceRoot</code></td>\n<td></td>\n<td>Specifies the location where debugger should locate TypeScript files instead of source locations. Use this flag if the sources will be located at run-time in a different location than that at design-time. The location specified will be embedded in the sourceMap to direct the debugger where the source files where be located.</td>\n</tr>\n<tr>\n<td>\n<code>--stripInternal</code><sup>[1]</sup>\n</td>\n<td></td>\n<td>Do not emit declarations for code that has an <code>/** @internal */</code> JSDoc annotation.</td>\n</tr>\n<tr>\n<td>\n<code>--suppressExcessPropertyErrors</code><sup>[1]</sup>\n</td>\n<td></td>\n<td>Suppress excess property checks for object literals.</td>\n</tr>\n<tr>\n<td><code>--suppressImplicitAnyIndexErrors</code></td>\n<td></td>\n<td>Suppress <code>--noImplicitAny</code> errors for indexing objects lacking index signatures. See <a href=\"https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362\">issue #1232</a> for more details.</td>\n</tr>\n<tr>\n<td><code>--allowUnusedLabels</code></td>\n<td></td>\n<td>Do not report errors on unused labels.</td>\n</tr>\n<tr>\n<td><code>--noImplicitReturns</code></td>\n<td></td>\n<td>Report error when not all code paths in function return a value.</td>\n</tr>\n<tr>\n<td><code>--noFallthroughCasesInSwitch</code></td>\n<td></td>\n<td>Report errors for fallthrough cases in switch statement.</td>\n</tr>\n<tr>\n<td><code>--allowUnreachableCode</code></td>\n<td></td>\n<td>Do not report errors on unreachable code.</td>\n</tr>\n<tr>\n<td><code>--forceConsistentCasingInFileNames</code></td>\n<td></td>\n<td>Disallow inconsistently-cased references to the same file.</td>\n</tr>\n<tr>\n<td><code>--allowSyntheticDefaultImports</code></td>\n<td></td>\n<td>Allow default imports from modules with no default export. This does not affect code emit, just typechecking.</td>\n</tr>\n<tr>\n<td><code>--allowJs</code></td>\n<td></td>\n<td>Allow JavaScript files to be compiled.</td>\n</tr>\n<tr>\n<td><code>--noImplicitUseStrict</code></td>\n<td></td>\n<td>Do not emit <code>\"use strict\"</code> directives in module output.</td>\n</tr>\n</tbody>\n</table>\n<p><sup>[1]</sup> These options are experimental.</p>\n<h2 id=\"related\">Related</h2>\n<ul>\n<li>Setting compiler options in <a href=\"tsconfig.json\"><code>tsconfig.json</code></a> files.</li>\n<li>Setting compiler options in <a href=\"compiler-options-in-msbuild\">MSBuild projects</a>.</li>\n</ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/compiler-options.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/compiler-options.html</a>\n  </p>\n</div>\n","handbook/modules":"<h1 class=\"post-title\">Modules</h1>\n\n<blockquote><p><strong>A note about terminology:</strong> It’s important to note that in TypeScript 1.5, the nomenclature has changed. “Internal modules” are now “namespaces”. “External modules” are now simply “modules”, as to align with <a href=\"http://www.ecma-international.org/ecma-262/6.0/\">ECMAScript 2015</a>’s terminology, (namely that <code>module X {</code> is equivalent to the now-preferred <code>namespace X {</code>).</p></blockquote>\n<h2 id=\"introduction\">Introduction</h2>\n<p>Starting with the ECMAScript 2015, JavaScript has a concept of modules. TypeScript shares this concept.</p>\n<p>Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the <a href=\"#export\"><code>export</code> forms</a>. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the <a href=\"#import\"><code>import</code> forms</a>.</p>\n<p>Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.</p>\n<p>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known modules loaders used in JavaScript are the <a href=\"https://en.wikipedia.org/wiki/CommonJS\">CommonJS</a> module loader for Node.js and <a href=\"http://requirejs.org/\">require.js</a> for Web applications.</p>\n<p>In TypeScript, just as in ECMAScript 2015, any file containing a top-level <code>import</code> or <code>export</code> is considered a module.</p>\n<h2 id=\"export\">Export</h2>\n<h2 id=\"exporting-a-declaration\">Exporting a declaration</h2>\n<p>Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the <code>export</code> keyword.</p>\n<h5 id=\"validationts\">Validation.ts</h5>\n<pre data-language=\"typescript\">export interface StringValidator {\r\n  isAcceptable(s: string): boolean;\r\n}\r\n</pre>\n<h5 id=\"zipcodevalidatorts\">ZipCodeValidator.ts</h5>\n<pre data-language=\"typescript\">export const numberRegexp = /^[0-9]+$/;\r\n\r\nexport class ZipCodeValidator implements StringValidator {\r\n  isAcceptable(s: string) {\r\n    return s.length === 5 &amp;&amp; numberRegexp.test(s);\r\n  }\r\n}\r\n</pre>\n<h2 id=\"export-statements\">Export statements</h2>\n<p>Export statements are handy when exports need to be renamed for consumers, so the above example can be written as:</p>\n<pre data-language=\"typescript\">class ZipCodeValidator implements StringValidator {\r\n  isAcceptable(s: string) {\r\n    return s.length === 5 &amp;&amp; numberRegexp.test(s);\r\n  }\r\n}\r\nexport { ZipCodeValidator };\r\nexport { ZipCodeValidator as mainValidator };\r\n</pre>\n<h2 id=\"re-exports\">Re-exports</h2>\n<p>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</p>\n<h5 id=\"parseintbasedzipcodevalidatorts\">ParseIntBasedZipCodeValidator.ts</h5>\n<pre data-language=\"typescript\">export class ParseIntBasedZipCodeValidator {\r\n  isAcceptable(s: string) {\r\n    return s.length === 5 &amp;&amp; parseInt(s).toString() === s;\r\n  }\r\n}\r\n\r\n// Export original validator but rename it\r\nexport {ZipCodeValidator as RegExpBasedZipCodeValidator} from \"./ZipCodeValidator\";\r\n</pre>\n<p>Optionally, a module can wrap one or more modules and combine all their exports using <code>export * from \"module\"</code> syntax.</p>\n<h5 id=\"allvalidatorsts\">AllValidators.ts</h5>\n<pre data-language=\"typescript\">export * from \"./StringValidator\"; // exports interface StringValidator\r\nexport * from \"./LettersOnlyValidator\"; // exports class LettersOnlyValidator\r\nexport * from \"./ZipCodeValidator\";  // exports class ZipCodeValidator\r\n</pre>\n<h2 id=\"import\">Import</h2>\n<p>Importing is just about as easy as exporting from an module. Importing an exported declaration is done through using one of the <code>import</code> forms below:</p>\n<h2 id=\"import-a-single-export-from-a-module\">Import a single export from a module</h2>\n<pre data-language=\"typescript\">import { ZipCodeValidator } from \"./ZipCodeValidator\";\r\n\r\nlet myValidator = new ZipCodeValidator();\r\n</pre>\n<p>imports can also be renamed</p>\n<pre data-language=\"typescript\">import { ZipCodeValidator as ZCV } from \"./ZipCodeValidator\";\r\nlet myValidator = new ZCV();\r\n</pre>\n<h2 id=\"import-the-entire-module-into-a-single-variable-and-use-it-to-access-the-module-exports\">Import the entire module into a single variable, and use it to access the module exports</h2>\n<pre data-language=\"typescript\">import * as validator from \"./ZipCodeValidator\";\r\nlet myValidator = new validator.ZipCodeValidator();\r\n</pre>\n<h2 id=\"import-a-module-for-side-effects-only\">Import a module for side-effects only</h2>\n<p>Though not recommended practice, some modules set up some global state that can be used by other modules. These modules may not have any exports, or the consumer is not interested in any of their exports. To import these modules, use:</p>\n<pre data-language=\"typescript\">import \"./my-module.js\";\r\n</pre>\n<h2 id=\"default-exports\">Default exports</h2>\n<p>Each module can optionally export a <code>default</code> export. Default exports are marked with the keyword <code>default</code>; and there can only be one <code>default</code> export per module. <code>default</code> exports are imported using a different import form.</p>\n<p><code>default</code> exports are really handy. For instance, a library like JQuery might have a default export of <code>jQuery</code> or <code>$</code>, which we’d probably also import under the name <code>$</code> or <code>jQuery</code>.</p>\n<h5 id=\"jquerydts\">JQuery.d.ts</h5>\n<pre data-language=\"typescript\">declare let $: JQuery;\r\nexport default $;\r\n</pre>\n<h5 id=\"appts\">App.ts</h5>\n<pre data-language=\"typescript\">import $ from \"JQuery\";\r\n\r\n$(\"button.continue\").html( \"Next Step...\" );\r\n</pre>\n<p>Classes and function declarations can be authored directly as default exports. Default export class and function declaration names are optional.</p>\n<h5 id=\"zipcodevalidatorts-1\">ZipCodeValidator.ts</h5>\n<pre data-language=\"typescript\">export default class ZipCodeValidator {\r\n  static numberRegexp = /^[0-9]+$/;\r\n  isAcceptable(s: string) {\r\n    return s.length === 5 &amp;&amp; ZipCodeValidator.numberRegexp.test(s);\r\n  }\r\n}\r\n</pre>\n<h5 id=\"testts\">Test.ts</h5>\n<pre data-language=\"typescript\">import validator from \"./ZipCodeValidator\";\r\n\r\nlet validator = new validator();\r\n</pre>\n<p>or</p>\n<h5 id=\"staticzipcodevalidatorts\">StaticZipCodeValidator.ts</h5>\n<pre data-language=\"typescript\">const numberRegexp = /^[0-9]+$/;\r\n\r\nexport default function (s: string) {\r\n  return s.length === 5 &amp;&amp; numberRegexp.test(s);\r\n}\r\n</pre>\n<h5 id=\"testts-1\">Test.ts</h5>\n<pre data-language=\"typescript\">import validate from \"./StaticZipCodeValidator\";\r\n\r\nlet strings = [\"Hello\", \"98052\", \"101\"];\r\n\r\n// Use function validate\r\nstrings.forEach(s =&gt; {\r\n  console.log(`\"${s}\" ${validate(s) ? \" matches\" : \" does not match\"}`);\r\n});\r\n</pre>\n<p><code>default</code> exports can also be just values:</p>\n<h5 id=\"onetwothreets\">OneTwoThree.ts</h5>\n<pre data-language=\"typescript\">export default \"123\";\r\n</pre>\n<h5 id=\"logts\">Log.ts</h5>\n<pre data-language=\"typescript\">import num from \"./OneTwoThree\";\r\n\r\nconsole.log(num); // \"123\"\r\n</pre>\n<h2 id=\"export--and-import--require\">\n<code>export =</code> and <code>import = require()</code>\n</h2>\n<p>Both CommonJS and AMD generally have the concept of an <code>exports</code> object which contains all exports from a module.</p>\n<p>They also support replacing the <code>exports</code> object with a custom single object. Default exports are meant to act as a replacement for this behavior; however, the two are incompatible. TypeScript supports <code>export =</code> to module the traditional CommonJS and AMD workflow.</p>\n<p>The <code>export =</code> syntax specifies a single object that is exported from the module. This can be a class, interface, namespace, function, or enum.</p>\n<p>When importing a module using <code>export =</code>, TypeScript-specific <code>import let = require(\"module\")</code> must be used to import the module.</p>\n<h5 id=\"zipcodevalidatorts-2\">ZipCodeValidator.ts</h5>\n<pre data-language=\"typescript\">let numberRegexp = /^[0-9]+$/;\r\nclass ZipCodeValidator {\r\n  isAcceptable(s: string) {\r\n    return s.length === 5 &amp;&amp; numberRegexp.test(s);\r\n  }\r\n}\r\nexport = ZipCodeValidator;\r\n</pre>\n<h5 id=\"testts-2\">Test.ts</h5>\n<pre data-language=\"typescript\">import zip = require(\"./ZipCodeValidator\");\r\n\r\n// Some samples to try\r\nlet strings = [\"Hello\", \"98052\", \"101\"];\r\n\r\n// Validators to use\r\nlet validator = new zip.ZipCodeValidator();\r\n\r\n// Show whether each string passed each validator\r\nstrings.forEach(s =&gt; {\r\n  console.log(`\"${ s }\" - ${ validator.isAcceptable(s) ? \"matches\" : \"does not match\" }`);\r\n});\r\n</pre>\n<h2 id=\"code-generation-for-modules\">Code Generation for Modules</h2>\n<p>Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (<a href=\"http://wiki.commonjs.org/wiki/CommonJS\">CommonJS</a>), require.js (<a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\">AMD</a>), isomorphic (<a href=\"https://github.com/umdjs/umd\">UMD</a>), <a href=\"https://github.com/systemjs/systemjs\">SystemJS</a>, or <a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-modules\">ECMAScript 2015 native modules</a> (ES6) module-loading systems. For more information on what the <code>define</code>, <code>require</code> and <code>register</code> calls in the generated code do, consult the documentation for each module loader.</p>\n<p>This simple example shows how the names used during importing and exporting get translated into the module loading code.</p>\n<h5 id=\"simplemodulets\">SimpleModule.ts</h5>\n<pre data-language=\"typescript\">import m = require(\"mod\");\r\nexport let t = m.something + 1;\r\n</pre>\n<h5 id=\"amd--requirejs-simplemodulejs\">AMD / RequireJS SimpleModule.js</h5>\n<pre data-language=\"javascript\">define([\"require\", \"exports\", \"./mod\"], function (require, exports, mod_1) {\r\n  exports.t = mod_1.something + 1;\r\n});\r\n</pre>\n<h5 id=\"commonjs--node-simplemodulejs\">CommonJS / Node SimpleModule.js</h5>\n<pre data-language=\"javascript\">var mod_1 = require(\"./mod\");\r\nexports.t = mod_1.something + 1;\r\n</pre>\n<h5 id=\"umd-simplemodulejs\">UMD SimpleModule.js</h5>\n<pre data-language=\"javascript\">(function (factory) {\r\n  if (typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\") {\r\n    var v = factory(require, exports); if (v !== undefined) module.exports = v;\r\n  }\r\n  else if (typeof define === \"function\" &amp;&amp; define.amd) {\r\n    define([\"require\", \"exports\", \"./mod\"], factory);\r\n  }\r\n})(function (require, exports) {\r\n  var mod_1 = require(\"./mod\");\r\n  exports.t = mod_1.something + 1;\r\n});\r\n</pre>\n<h5 id=\"system-simplemodulejs\">System SimpleModule.js</h5>\n<pre data-language=\"javascript\">System.register([\"./mod\"], function(exports_1) {\r\n  var mod_1;\r\n  var t;\r\n  return {\r\n    setters:[\r\n      function (mod_1_1) {\r\n        mod_1 = mod_1_1;\r\n      }],\r\n    execute: function() {\r\n      exports_1(\"t\", t = mod_1.something + 1);\r\n    }\r\n  }\r\n});\r\n</pre>\n<h5 id=\"native-ecmascript-2015-modules-simplemodulejs\">Native ECMAScript 2015 modules SimpleModule.js</h5>\n<pre data-language=\"javascript\">import { something } from \"./mod\";\r\nexport var t = something + 1;\r\n</pre>\n<h2 id=\"simple-example\">Simple Example</h2>\n<p>Below, we’ve consolidated the Validator implementations used in previous examples to only export a single named export from each module.</p>\n<p>To compile, we must specify a module target on the command line. For Node.js, use <code>--module commonjs</code>; for require.js, use <code>--module amd</code>. For example:</p>\n<pre data-language=\"Shell\">tsc --module commonjs Test.ts\r\n</pre>\n<p>When compiled, each module will become a separate <code>.js</code> file. As with reference tags, the compiler will follow <code>import</code> statements to compile dependent files.</p>\n<h5 id=\"validationts-1\">Validation.ts</h5>\n<pre data-language=\"typescript\">export interface StringValidator {\r\n  isAcceptable(s: string): boolean;\r\n}\r\n</pre>\n<h5 id=\"lettersonlyvalidatorts\">LettersOnlyValidator.ts</h5>\n<pre data-language=\"typescript\">import { StringValidator } from \"./Validation\";\r\n\r\nconst lettersRegexp = /^[A-Za-z]+$/;\r\n\r\nexport class LettersOnlyValidator implements StringValidator {\r\n  isAcceptable(s: string) {\r\n    return lettersRegexp.test(s);\r\n  }\r\n}\r\n</pre>\n<h5 id=\"zipcodevalidatorts-3\">ZipCodeValidator.ts</h5>\n<pre data-language=\"typescript\">import { StringValidator } from \"./Validation\";\r\n\r\nconst numberRegexp = /^[0-9]+$/;\r\n\r\nexport class ZipCodeValidator implements StringValidator {\r\n  isAcceptable(s: string) {\r\n    return s.length === 5 &amp;&amp; numberRegexp.test(s);\r\n  }\r\n}\r\n</pre>\n<h5 id=\"testts-3\">Test.ts</h5>\n<pre data-language=\"typescript\">import { StringValidator } from \"./Validation\";\r\nimport { ZipCodeValidator } from \"./ZipCodeValidator\";\r\nimport { LettersOnlyValidator } from \"./LettersOnlyValidator\";\r\n\r\n// Some samples to try\r\nlet strings = [\"Hello\", \"98052\", \"101\"];\r\n\r\n// Validators to use\r\nlet validators: { [s: string]: StringValidator; } = {};\r\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\r\nvalidators[\"Letters only\"] = new LettersOnlyValidator();\r\n\r\n// Show whether each string passed each validator\r\nstrings.forEach(s =&gt; {\r\n  for (let name in validators) {\r\n    console.log(`\"${ s }\" - ${ validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" } ${ name }`);\r\n  }\r\n});\r\n</pre>\n<h2 id=\"optional-module-loading-and-other-advanced-loading-scenarios\">Optional Module Loading and Other Advanced Loading Scenarios</h2>\n<p>In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.</p>\n<p>The compiler detects whether each module is used in the emitted JavaScript. If a module identifier is only ever used as part of a type annotations and never as an expression, then no <code>require</code> call is emitted for that module. This elision of unused references is a good performance optimization, and also allows for optional loading of those modules.</p>\n<p>The core idea of the pattern is that the <code>import id = require(\"...\")</code> statement gives us access to the types exposed by the module. The module loader is invoked (through <code>require</code>) dynamically, as shown in the <code>if</code> blocks below. This leverages the reference-elision optimization so that the module is only loaded when needed. For this pattern to work, it’s important that the symbol defined via an <code>import</code> is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).</p>\n<p>To maintain type safety, we can use the <code>typeof</code> keyword. The <code>typeof</code> keyword, when used in a type position, produces the type of a value, in this case the type of the module.</p>\n<h5 id=\"dynamic-module-loading-in-nodejs\">Dynamic Module Loading in Node.js</h5>\n<pre data-language=\"typescript\">declare function require(moduleName: string): any;\r\n\r\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\r\n\r\nif (needZipValidation) {\r\n  let ZipCodeValidator: typeof Zip = require(\"./ZipCodeValidator\");\r\n  let validator = new ZipCodeValidator();\r\n  if (validator.isAcceptable(\"...\")) { /* ... */ }\r\n}\r\n</pre>\n<h5 id=\"sample-dynamic-module-loading-in-requirejs\">Sample: Dynamic Module Loading in require.js</h5>\n<pre data-language=\"typescript\">declare function require(moduleNames: string[], onLoad: (...args: any[]) =&gt; void): void;\r\n\r\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\r\n\r\nif (needZipValidation) {\r\n  require([\"./ZipCodeValidator\"], (ZipCodeValidator: typeof Zip) =&gt; {\r\n    let validator = new ZipCodeValidator();\r\n    if (validator.isAcceptable(\"...\")) { /* ... */ }\r\n  });\r\n}\r\n</pre>\n<h5 id=\"sample-dynamic-module-loading-in-systemjs\">Sample: Dynamic Module Loading in System.js</h5>\n<pre data-language=\"typescript\">declare const System: any;\r\n\r\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\r\n\r\nif (needZipValidation) {\r\n  System.import(\"./ZipCodeValidator\").then((ZipCodeValidator: typeof Zip) =&gt; {\r\n    var x = new ZipCodeValidator();\r\n    if (x.isAcceptable(\"...\")) { /* ... */ }\r\n  });\r\n}\r\n</pre>\n<h2 id=\"working-with-other-javascript-libraries\">Working with Other JavaScript Libraries</h2>\n<p>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.</p>\n<p>We call declarations that don’t define an implementation “ambient”. Typically, these are defined in <code>.d.ts</code> files. If you’re familiar with C/C++, you can think of these as <code>.h</code> files. Let’s look at a few examples.</p>\n<h2 id=\"ambient-modules\">Ambient Modules</h2>\n<p>In Node.js, most tasks are accomplished by loading one or more modules. We could define each module in its own <code>.d.ts</code> file with top-level export declarations, but it’s more convenient to write them as one larger <code>.d.ts</code> file. To do so, we use a construct similar to ambient namespaces, but we use the <code>module</code> keyword and the quoted name of the module which will be available to a later import. For example:</p>\n<h5 id=\"nodedts-simplified-excerpt\">node.d.ts (simplified excerpt)</h5>\n<pre data-language=\"typescript\">declare module \"url\" {\r\n  export interface Url {\r\n    protocol?: string;\r\n    hostname?: string;\r\n    pathname?: string;\r\n  }\r\n\r\n  export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;\r\n}\r\n\r\ndeclare module \"path\" {\r\n  export function normalize(p: string): string;\r\n  export function join(...paths: any[]): string;\r\n  export var sep: string;\r\n}\r\n</pre>\n<p>Now we can <code>/// &lt;reference&gt;</code> <code>node.d.ts</code> and then load the modules using <code>import url = require(\"url\");</code>.</p>\n<pre data-language=\"typescript\">/// &lt;reference path=\"node.d.ts\"/&gt;\r\nimport * as URL from \"url\";\r\nlet myUrl = URL.parse(\"http://www.typescriptlang.org\");\r\n</pre>\n<h2 id=\"guidance-for-structuring-modules\">Guidance for structuring modules</h2>\n<h2 id=\"export-as-close-to-top-level-as-possible\">Export as close to top-level as possible</h2>\n<p>Consumers of your module should have as little friction as possible when using things that you export. Adding too many levels of nesting tends to be cumbersome, so think carefully about how you want to structure things.</p>\n<p>Exporting a namespace from your module is an example of adding too many layers of nesting. While namespaces sometimes have their uses, they add an extra level of indirection when using modules. This can quickly becomes a pain point for users, and is usually unnecessary.</p>\n<p>Static methods on an exported class have a similar problem - the class itself adds a layer of nesting. Unless it increases expressivity or intent in a clearly useful way, consider simply exporting a helper function.</p>\n<h3 id=\"if-youre-only-exporting-a-single-class-or-function-use-export-default\">If you’re only exporting a single <code>class</code> or <code>function</code>, use <code>export default</code>\n</h3>\n<p>Just as “exporting near the top-level” reduces friction on your module’s consumers, so does introducing a default export. If a module’s primary purpose is to house one specific export, then you should consider exporting it as a default export. This makes both importing and actually using the import a little easier. For example:</p>\n<h4 id=\"myclassts\">MyClass.ts</h4>\n<pre data-language=\"typescript\">export default class SomeType {\r\n  constructor() { ... }\r\n}\r\n</pre>\n<h4 id=\"myfuncts\">MyFunc.ts</h4>\n<pre data-language=\"typescript\">export default function getThing() { return 'thing'; }\r\n</pre>\n<h4 id=\"consumerts\">Consumer.ts</h4>\n<pre data-language=\"typescript\">import t from \"./MyClass\";\r\nimport f from \"./MyFunc\";\r\nlet x = new t();\r\nconsole.log(f());\r\n</pre>\n<p>This is optimal for consumers. They can name your type whatever they want (<code>t</code> in this case) and don’t have to do any excessive dotting to find your objects.</p>\n<h3 id=\"if-youre-exporting-multiple-objects-put-them-all-at-top-level\">If you’re exporting multiple objects, put them all at top-level</h3>\n<h4 id=\"mythingsts\">MyThings.ts</h4>\n<pre data-language=\"typescript\">export class SomeType { /* ... */ }\r\nexport function someFunc() { /* ... */ }\r\n</pre>\n<p>Conversly when importing:</p>\n<h3 id=\"explicitlly-list-imported-names\">Explicitlly list imported names</h3>\n<h4 id=\"consumerts-1\">Consumer.ts</h4>\n<pre data-language=\"typescript\">import { SomeType, someFunc } from \"./MyThings\";\r\nlet x = new SomeType();\r\nlet y = someFunc();\r\n</pre>\n<h3 id=\"use-the-namespace-import-pattern-if-youre-importing-a-large-number-of-things\">Use the namespace import pattern if you’re importing a large number of things</h3>\n<h4 id=\"mylargemodulets\">MyLargeModule.ts</h4>\n<pre data-language=\"typescript\">export class Dog { ... }\r\nexport class Cat { ... }\r\nexport class Tree { ... }\r\nexport class Flower { ... }\r\n</pre>\n<h4 id=\"consumerts-2\">Consumer.ts</h4>\n<pre data-language=\"typescript\">import * as myLargeModule from \"./MyLargeModule.ts\";\r\nlet x = new myLargeModule.Dog();\r\n</pre>\n<h2 id=\"re-export-to-extend\">Re-export to extend</h2>\n<p>Often you will need to extend functionality on a module. A common JS pattern is to augment the original object with <em>extensions</em>, similar to how JQuery extensions work. As we’ve mentioned before, modules do not <em>merge</em> like global namespace objects would. The recommended solution is to <em>not</em> mutate the original object, but rather export a new entity that provides the new functionality.</p>\n<p>Consider a simple calculator implementation defined in module <code>Calculator.ts</code>. The module also exports a helper function to test the calculator functionality by passing a list of input strings and writing the result at the end.</p>\n<h4 id=\"calculatorts\">Calculator.ts</h4>\n<pre data-language=\"typescript\">export class Calculator {\r\n  private current = 0;\r\n  private memory = 0;\r\n  private operator: string;\r\n\r\n  protected processDigit(digit: string, currentValue: number) {\r\n    if (digit &gt;= \"0\" &amp;&amp; digit &lt;= \"9\") {\r\n      return currentValue * 10 + (digit.charCodeAt(0) - \"0\".charCodeAt(0));\r\n    }\r\n  }\r\n\r\n  protected processOperator(operator: string) {\r\n    if ([\"+\", \"-\", \"*\", \"/\"].indexOf(operator) &gt;= 0) {\r\n      return operator;\r\n    }\r\n  }\r\n\r\n  protected evaluateOperator(operator: string, left: number, right: number): number {\r\n    switch (this.operator) {\r\n      case \"+\": return left + right;\r\n      case \"-\": return left - right;\r\n      case \"*\": return left * right;\r\n      case \"/\": return left / right;\r\n    }\r\n  }\r\n\r\n  private evaluate() {\r\n    if (this.operator) {\r\n      this.memory = this.evaluateOperator(this.operator, this.memory, this.current);\r\n    }\r\n    else {\r\n      this.memory = this.current;\r\n    }\r\n    this.current = 0;\r\n  }\r\n\r\n  public handelChar(char: string) {\r\n    if (char === \"=\") {\r\n      this.evaluate();\r\n      return;\r\n    }\r\n    else {\r\n      let value = this.processDigit(char, this.current);\r\n      if (value !== undefined) {\r\n        this.current = value;\r\n        return;\r\n      }\r\n      else {\r\n        let value = this.processOperator(char);\r\n        if (value !== undefined) {\r\n          this.evaluate();\r\n          this.operator = value;\r\n          return;\r\n        }\r\n      }\r\n    }\r\n    throw new Error(`Unsupported input: '${char}'`);\r\n  }\r\n\r\n  public getResult() {\r\n    return this.memory;\r\n  }\r\n}\r\n\r\nexport function test(c: Calculator, input: string) {\r\n  for (let i = 0; i &lt; input.length; i++) {\r\n    c.handelChar(input[i]);\r\n  }\r\n\r\n  console.log(`result of '${input}' is '${c.getResult()}'`);\r\n}\r\n</pre>\n<p>Here is a simple test for the calculator using the exposed <code>test</code> function.</p>\n<h4 id=\"testcalculatorts\">TestCalculator.ts</h4>\n<pre data-language=\"typescript\">import { Calculator, test } from \"./Calculator\";\r\n\r\n\r\nlet c = new Calculator();\r\ntest(c, \"1+2*33/11=\"); // prints 9\r\n</pre>\n<p>Now to extend this to add support for input with numbers in bases other than 10, let’s create <code>ProgrammerCalculator.ts</code></p>\n<h4 id=\"programmercalculatorts\">ProgrammerCalculator.ts</h4>\n<pre data-language=\"typescript\">import { Calculator } from \"./Calculator\";\r\n\r\nclass ProgrammerCalculator extends Calculator {\r\n  static digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\r\n\r\n  constructor(public base: number) {\r\n    super();\r\n    if (base &lt;= 0 || base &gt; ProgrammerCalculator.digits.length) {\r\n      throw new Error(\"base has to be within 0 to 16 inclusive.\");\r\n    }\r\n  }\r\n\r\n  protected processDigit(digit: string, currentValue: number) {\r\n    if (ProgrammerCalculator.digits.indexOf(digit) &gt;= 0) {\r\n      return currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit);\r\n    }\r\n  }\r\n}\r\n\r\n// Export the new extended calculator as Calculator\r\nexport { ProgrammerCalculator as Calculator };\r\n\r\n// Also, export the helper function\r\nexport { test } from \"./Calculator\";\r\n</pre>\n<p>The new module <code>ProgrammerCalculator</code> exports an API shape similar to that of the original <code>Calculator</code> module, but does not augment any objects in the original module. Here is a test for our ProgrammerCalculator class:</p>\n<h4 id=\"testprogrammercalculatorts\">TestProgrammerCalculator.ts</h4>\n<pre data-language=\"typescript\">import { Calculator, test } from \"./ProgrammerCalculator\";\r\n\r\nlet c = new Calculator(2);\r\ntest(c, \"001+010=\"); // prints 3\r\n</pre>\n<h2 id=\"do-not-use-namespaces-in-modules\">Do not use namespaces in modules</h2>\n<p>When first moving to a module-based organization, a common tendency is to wrap exports in an additional layer of namespaces. Modules have their own scope, and only exported declarations are visible from outside the module. With this in mind, namespace provide very little, if any, value when working with modules.</p>\n<p>On the organization front, namespaces are handy for grouping together logically-related objects and types in the global scope. For example, in C#, you’re going to find all the collection types in System.Collections. By organizing our types into hierarchical namespaces, we provide a good “discovery” experience for users of those types. Modules, on the other hand, are already present in a file system, necessarily. We have to resolve them by path and filename, so there’s a logical organization scheme for us to use. We can have a /collections/generic/ folder with a list module in it.</p>\n<p>Namespaces are important to avoid naming collisions in the global scope. For example, you might have <code>My.Application.Customer.AddForm</code> and <code>My.Application.Order.AddForm</code> – two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there’s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</p>\n<blockquote><p>For more discussion about modules and namespaces see <a href=\"namespaces-and-modules\">Namespaces and Modules</a>.</p></blockquote>\n<h2 id=\"red-flags\">Red Flags</h2>\n<p>All of the following are red flags for module structuring. Double-check that you’re not trying to namespace your external modules if any of these apply to your files:</p>\n<ul>\n<li>A file whose only top-level declaration is <code>export namespace Foo { ... }</code> (remove <code>Foo</code> and move everything ‘up’ a level)</li>\n<li>A file that has a single <code>export class</code> or <code>export function</code> (consider using <code>export default</code>)</li>\n<li>Multiple files that have the same <code>export namespace Foo {</code> at top-level (don’t think that these are going to combine into one <code>Foo</code>!)</li>\n</ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/modules.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/modules.html</a>\n  </p>\n</div>\n","handbook/compiler-options-in-msbuild":"<h1 class=\"post-title\">Compiler Options in MSBuild</h1>\n\n<h2 id=\"overview\">Overview</h2>\n<p>Compiler options can be specified using MSBuild properties within an MSBuild project.</p>\n<h2 id=\"example\">Example</h2>\n<pre data-language=\"XML\">  &lt;PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\"&gt;\r\n  &lt;TypeScriptRemoveComments&gt;false&lt;/TypeScriptRemoveComments&gt;\r\n  &lt;TypeScriptSourceMap&gt;true&lt;/TypeScriptSourceMap&gt;\r\n  &lt;/PropertyGroup&gt;\r\n  &lt;PropertyGroup Condition=\"'$(Configuration)' == 'Release'\"&gt;\r\n  &lt;TypeScriptRemoveComments&gt;true&lt;/TypeScriptRemoveComments&gt;\r\n  &lt;TypeScriptSourceMap&gt;false&lt;/TypeScriptSourceMap&gt;\r\n  &lt;/PropertyGroup&gt;\r\n  &lt;Import\r\n    Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"\r\n    Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" /&gt;\r\n</pre>\n<h2 id=\"mappings\">Mappings</h2>\n<table>\n<thead><tr>\n<th>Compiler Option</th>\n<th>MSBuild Property Name</th>\n<th>Allowed Values</th>\n</tr></thead>\n<tbody>\n<tr>\n<td><code>--declaration</code></td>\n<td>TypeScriptGeneratesDeclarations</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--module</code></td>\n<td>TypeScriptModuleKind</td>\n<td>\n<code>AMD</code>, <code>CommonJs</code>, <code>UMD</code>, or <code>System</code>\n</td>\n</tr>\n<tr>\n<td><code>--target</code></td>\n<td>TypeScriptTarget</td>\n<td>\n<code>ES3</code>, <code>ES5</code>, or <code>ES6</code>\n</td>\n</tr>\n<tr>\n<td><code>--charset</code></td>\n<td>TypeScriptCharset</td>\n<td></td>\n</tr>\n<tr>\n<td><code>--emitBOM</code></td>\n<td>TypeScriptEmitBOM</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--emitDecoratorMetadata</code></td>\n<td>TypeScriptEmitDecoratorMetadata</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--experimentalDecorators</code></td>\n<td>TypeScriptExperimentalDecorators</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--inlineSourceMap</code></td>\n<td>TypeScriptInlineSourceMap</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--inlineSources</code></td>\n<td>TypeScriptInlineSources</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--locale</code></td>\n<td><em>automatic</em></td>\n<td>Automatically set to PreferredUILang value</td>\n</tr>\n<tr>\n<td><code>--mapRoot</code></td>\n<td>TypeScriptMapRoot</td>\n<td>File path</td>\n</tr>\n<tr>\n<td><code>--newLine</code></td>\n<td>TypeScriptNewLine</td>\n<td>\n<code>CRLF</code> or <code>LF</code>\n</td>\n</tr>\n<tr>\n<td><code>--noEmitOnError</code></td>\n<td>TypeScriptNoEmitOnError</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--noEmitHelpers</code></td>\n<td>TypeScriptNoEmitHelpers</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--noImplicitAny</code></td>\n<td>TypeScriptNoImplicitAny</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--noLib</code></td>\n<td>TypeScriptNoLib</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--noResolve</code></td>\n<td>TypeScriptNoResolve</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--out</code></td>\n<td>TypeScriptOutFile</td>\n<td>File path</td>\n</tr>\n<tr>\n<td><code>--outDir</code></td>\n<td>TypeScriptOutDir</td>\n<td>File path</td>\n</tr>\n<tr>\n<td><code>--preserveConstEnums</code></td>\n<td>TypeScriptPreserveConstEnums</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--removeComments</code></td>\n<td>TypeScriptRemoveComments</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--rootDir</code></td>\n<td>TypeScriptRootDir</td>\n<td>File path</td>\n</tr>\n<tr>\n<td><code>--isolatedModules</code></td>\n<td>TypeScriptIsolatedModules</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--sourceMap</code></td>\n<td>TypeScriptSourceMap</td>\n<td>File path</td>\n</tr>\n<tr>\n<td><code>--sourceRoot</code></td>\n<td>TypeScriptSourceRoot</td>\n<td>File path</td>\n</tr>\n<tr>\n<td><code>--suppressImplicitAnyIndexErrors</code></td>\n<td>TypeScriptSuppressImplicitAnyIndexErrors</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--suppressExcessPropertyErrors</code></td>\n<td>TypeScriptSuppressExcessPropertyErrors</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--moduleResolution</code></td>\n<td>TypeScriptModuleResolution</td>\n<td>\n<code>Classic</code> or <code>Node</code>\n</td>\n</tr>\n<tr>\n<td><code>--experimentalAsyncFunctions</code></td>\n<td>TypeScriptExperimentalAsyncFunctions</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--jsx</code></td>\n<td>TypeScriptJSXEmit</td>\n<td>\n<code>React</code> or <code>Preserve</code>\n</td>\n</tr>\n<tr>\n<td><code>--reactNamespace</code></td>\n<td>TypeScriptReactNamespace</td>\n<td>string</td>\n</tr>\n<tr>\n<td><code>--skipDefaultLibCheck</code></td>\n<td>TypeScriptSkipDefaultLibCheck</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--allowUnusedLabels</code></td>\n<td>TypeScriptAllowUnusedLabels</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--noImplicitReturns</code></td>\n<td>TypeScriptNoImplicitReturns</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--noFallthroughCasesInSwitch</code></td>\n<td>TypeScriptNoFallthroughCasesInSwitch</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--allowUnreachableCode</code></td>\n<td>TypeScriptAllowUnreachableCode</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--forceConsistentCasingInFileNames</code></td>\n<td>TypeScriptForceConsistentCasingInFileNames</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--allowSyntheticDefaultImports</code></td>\n<td>TypeScriptAllowSyntheticDefaultImports</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--noImplicitUseStrict</code></td>\n<td>TypeScriptNoImplicitUseStrict</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td><code>--project</code></td>\n<td><em>Not supported in VS</em></td>\n<td></td>\n</tr>\n<tr>\n<td><code>--watch</code></td>\n<td><em>Not supported in VS</em></td>\n<td></td>\n</tr>\n<tr>\n<td><code>--diagnostics</code></td>\n<td><em>Not supported in VS</em></td>\n<td></td>\n</tr>\n<tr>\n<td><code>--listFiles</code></td>\n<td><em>Not supported in VS</em></td>\n<td></td>\n</tr>\n<tr>\n<td><code>--noEmit</code></td>\n<td><em>Not supported in VS</em></td>\n<td></td>\n</tr>\n<tr>\n<td><code>--allowJs</code></td>\n<td><em>Not supported in VS</em></td>\n<td></td>\n</tr>\n<tr>\n<td><em>VS only option</em></td>\n<td>TypeScriptAdditionalFlags</td>\n<td><em>Any compiler option</em></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"what-is-supported-in-my-version-of-visual-studio\">What is supported in my version of Visual Studio?</h2>\n<p>Look in your <code>C:\\Program Files (x86)\\MSBuild\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets</code> file. The authoritative mappings between MSBuild XML tags and <code>tsc</code> compiler options live in there.</p>\n<h2 id=\"toolsversion\">ToolsVersion</h2>\n<p>The value of <code>&lt;TypeScriptToolsVersion&gt;1.7&lt;/TypeScriptToolsVersion&gt;</code> property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the save versions of the compiler on different machines.</p>\n<p>If <code>TypeScriptToolsVersion</code> is not specified, the latest compiler version installed on the machine will be used to build.</p>\n<p>Users using newer versions of TS, will see a prompt to upgrade their project on first load.</p>\n<h2 id=\"typescriptcompileblocked\">TypeScriptCompileBlocked</h2>\n<p>If you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set <code>&lt;TypeScriptCompileBlocked&gt;true&lt;/TypeScriptCompileBlocked&gt;</code> in your project. This should give you all the editing support, but not the build when you hit F5.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html</a>\n  </p>\n</div>\n","handbook/integrating-with-build-tools":"<h1 class=\"post-title\">Integrating with Build Tools</h1>\n\n<h2 id=\"browserify\">Browserify</h2>\n<h3 id=\"install\">Install</h3>\n<pre data-language=\"sh\">npm install tsify\r\n</pre>\n<h3 id=\"using-command-line-interface\">Using Command Line Interface</h3>\n<pre data-language=\"sh\">browserify main.ts -p [ tsify --noImplicitAny ] &gt; bundle.js\r\n</pre>\n<h3 id=\"using-api\">Using API</h3>\n<pre data-language=\"javascript\">var browserify = require(\"browserify\");\r\nvar tsify = require(\"tsify\");\r\n\r\nbrowserify()\r\n  .add('main.ts')\r\n  .plugin('tsify', { noImplicitAny: true })\r\n  .bundle()\r\n  .pipe(process.stdout);\r\n</pre>\n<p>More details: <a href=\"https://github.com/smrq/tsify\">smrq/tsify</a></p>\n<h2 id=\"duo\">Duo</h2>\n<h3 id=\"install-1\">Install</h3>\n<pre data-language=\"sh\">npm install duo-typescript\r\n</pre>\n<h3 id=\"using-command-line-interface-1\">Using Command Line Interface</h3>\n<pre data-language=\"sh\">duo --use duo-typescript entry.ts\r\n</pre>\n<h3 id=\"using-api-1\">Using API</h3>\n<pre data-language=\"javascript\">var Duo = require('duo');\r\nvar fs = require('fs')\r\nvar path = require('path')\r\nvar typescript = require('duo-typescript');\r\n\r\nvar out = path.join(__dirname, \"output.js\")\r\n\r\nDuo(__dirname)\r\n  .entry('entry.ts')\r\n  .use(typescript())\r\n  .run(function (err, results) {\r\n    if (err) throw err;\r\n    // Write compiled result to output file\r\n    fs.writeFileSync(out, results.code);\r\n  });\r\n</pre>\n<p>More details: <a href=\"https://github.com/frankwallis/duo-typescript\">frankwallis/duo-typescript</a></p>\n<h2 id=\"grunt\">Grunt</h2>\n<h3 id=\"install-2\">Install</h3>\n<pre data-language=\"sh\">npm install grunt-ts\r\n</pre>\n<h3 id=\"basic-gruntfilejs\">Basic Gruntfile.js</h3>\n<pre data-language=\"javascript\">module.exports = function(grunt) {\r\n  grunt.initConfig({\r\n    ts: {\r\n      default : {\r\n        src: [\"**/*.ts\", \"!node_modules/**/*.ts\"]\r\n      }\r\n    }\r\n  });\r\n  grunt.loadNpmTasks(\"grunt-ts\");\r\n  grunt.registerTask(\"default\", [\"ts\"]);\r\n};\r\n</pre>\n<p>More details: <a href=\"https://github.com/TypeStrong/grunt-ts\">TypeStrong/grunt-ts</a></p>\n<h2 id=\"gulp\">gulp</h2>\n<h3 id=\"install-3\">Install</h3>\n<pre data-language=\"sh\">npm install gulp-typescript\r\n</pre>\n<h3 id=\"basic-gulpfilejs\">Basic gulpfile.js</h3>\n<pre data-language=\"javascript\">var gulp = require(\"gulp\");\r\nvar ts = require(\"gulp-typescript\");\r\n\r\ngulp.task(\"default\", function () {\r\n  var tsResult = gulp.src(\"src/*.ts\")\r\n    .pipe(ts({\r\n        noImplicitAny: true,\r\n        out: \"output.js\"\r\n    }));\r\n  return tsResult.js.pipe(gulp.dest('built/local'));\r\n});\r\n</pre>\n<p>More details: <a href=\"https://github.com/ivogabe/gulp-typescript\">ivogabe/gulp-typescript</a></p>\n<h2 id=\"jspm\">jspm</h2>\n<h3 id=\"install-4\">Install</h3>\n<pre data-language=\"sh\">npm install -g jspm@beta\r\n</pre>\n<p><em>Note: Currently TypeScript support in jspm is in 0.16beta</em></p>\n<p>More details: <a href=\"https://github.com/Microsoft/TypeScriptSamples/tree/jspm/jspm\">TypeScriptSamples/jspm</a></p>\n<h2 id=\"webpack\">webpack</h2>\n<h3 id=\"install-5\">Install</h3>\n<pre data-language=\"sh\">npm install ts-loader --save-dev\r\n</pre>\n<h3 id=\"basic-webpackconfigjs\">Basic webpack.config.js</h3>\n<pre data-language=\"javascript\">module.exports = {\r\n  entry: \"./src/index.tsx\",\r\n  output: {\r\n    filename: \"bundle.js\"\r\n  },\r\n  resolve: {\r\n    // Add '.ts' and '.tsx' as a resolvable extension.\r\n    extensions: [\"\", \".webpack.js\", \".web.js\", \".ts\", \".tsx\", \".js\"]\r\n  },\r\n  module: {\r\n    loaders: [\r\n      // all files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'\r\n      { test: /\\.tsx?$/, loader: \"ts-loader\" }\r\n    ]\r\n  }\r\n}\r\n</pre>\n<p>See <a href=\"https://www.npmjs.com/package/ts-loader\">more details on ts-loader here</a>.</p>\n<p>Alternatives:</p>\n<ul><li><a href=\"https://www.npmjs.com/package/awesome-typescript-loader\">awesome-typescript-loader</a></li></ul>\n<h2 id=\"msbuild\">MSBuild</h2>\n<p>Update project file to include locally installed <code>Microsoft.TypeScript.Default.props</code> (at the top) and <code>Microsoft.TypeScript.targets</code> (at the bottom) files:</p>\n<pre data-language=\"xml\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\r\n&lt;Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"&gt;\r\n  &lt;!-- Include default props at the bottom --&gt;\r\n  &lt;Import\r\n    Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props\"\r\n    Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props')\" /&gt;\r\n\r\n  &lt;!-- TypeScript configurations go here --&gt;\r\n  &lt;PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\"&gt;\r\n  &lt;TypeScriptRemoveComments&gt;false&lt;/TypeScriptRemoveComments&gt;\r\n  &lt;TypeScriptSourceMap&gt;true&lt;/TypeScriptSourceMap&gt;\r\n  &lt;/PropertyGroup&gt;\r\n  &lt;PropertyGroup Condition=\"'$(Configuration)' == 'Release'\"&gt;\r\n  &lt;TypeScriptRemoveComments&gt;true&lt;/TypeScriptRemoveComments&gt;\r\n  &lt;TypeScriptSourceMap&gt;false&lt;/TypeScriptSourceMap&gt;\r\n  &lt;/PropertyGroup&gt;\r\n\r\n  &lt;!-- Include default targets at the bottom --&gt;\r\n  &lt;Import\r\n    Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"\r\n    Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" /&gt;\r\n&lt;/Project&gt;\r\n</pre>\n<p>More details about defining MSBuild compiler options: <a href=\"compiler-options-in-msbuild\">Setting Compiler Options in MSBuild projects</a></p>\n<h2 id=\"nuget\">NuGet</h2>\n<ul>\n<li>Right-Click -&gt; Manage NuGet Packages</li>\n<li>Search for <code>Microsoft.TypeScript.MSBuild</code>\n</li>\n<li>Hit <code>Install</code>\n</li>\n<li>When install is complete, rebuild!</li>\n</ul>\n<p>More details can be found at <a href=\"http://docs.nuget.org/Consume/Package-Manager-Dialog\">Package Manager Dialog</a> and <a href=\"https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild\">using nightly builds with NuGet</a></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html</a>\n  </p>\n</div>\n","handbook/decorators":"<h1 class=\"post-title\">Decorators</h1>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members. Decorators are a <a href=\"https://github.com/wycats/javascript-decorators/blob/master/readme.html\">stage 1 proposal</a> for JavaScript and are available as an experimental feature of TypeScript.</p>\n<blockquote><p>NOTE Decorators are an experimental feature that may change in future releases.</p></blockquote>\n<p>To enable experimental support for decorators, you must enable the <code>experimentalDecorators</code> compiler option either on the command line or in your <code>tsconfig.json</code>:</p>\n<p><strong>Command Line</strong>:</p>\n<pre data-language=\"shell\">tsc --target ES5 --experimentalDecorators\r\n</pre>\n<p><strong>tsconfig.json</strong>:</p>\n<pre data-language=\"javascripton\">{\r\n  \"compilerOptions\": {\r\n    \"target\": \"ES5\",\r\n    \"experimentalDecorators\": true\r\n  }\r\n}\r\n</pre>\n<h2 id=\"decorators\">Decorators</h2>\n<p>A <em>Decorator</em> is a special kind of declaration that can be attached to a <a href=\"#class-decorators\">class declaration</a>, <a href=\"#method-decorators\">method</a>, <a href=\"#accessor-decorators\">accessor</a>, <a href=\"#property-decorators\">property</a>, or <a href=\"#parameter-decorators\">parameter</a>. Decorators use the form <code>@expression</code>, where <code>expression</code> must evaluate to a function that will be called at runtime with information about the decorated declaration.</p>\n<p>For example, given the decorator <code>@sealed</code> we might write the <code>sealed</code> function as follows:</p>\n<pre data-language=\"typescript\">function sealed(target) {\r\n  // do something with \"target\" ...\r\n}\r\n</pre>\n<blockquote><p>NOTE You can see a more detailed example of a decorator in <a href=\"#class-decorators\">Class Decorators</a>, below.</p></blockquote>\n<h2 id=\"decorator-factories\">Decorator Factories</h2>\n<p>If we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A <em>Decorator Factory</em> is simply a function that returns the expression that will be called by the decorator at runtime.</p>\n<p>We can write a decorator factory in the following fashion:</p>\n<pre data-language=\"typescript\">function color(value: string) { // this is the decorator factory\r\n  return function (target) { // this is the decorator\r\n    // do something with \"target\" and \"value\"...\r\n  }\r\n}\r\n</pre>\n<blockquote><p>NOTE You can see a more detailed example of a decorator factory in <a href=\"#method-decorators\">Method Decorators</a>, below.</p></blockquote>\n<h2 id=\"decorator-composition\">Decorator Composition</h2>\n<p>Multiple decorators can be applied to a declaration, as in the following examples:</p>\n<ul>\n<li>\n<p>On a single line:</p>\n<pre data-language=\"typescript\">@f @g x\r\n</pre>\n</li>\n<li>\n<p>On multiple lines:</p>\n<pre data-language=\"typescript\">@f\r\n@g\r\nx\r\n</pre>\n</li>\n</ul>\n<p>When multiple decorators apply to a single declaration, their evaluation is similar to <a href=\"http://en.wikipedia.org/wiki/Function_composition\">function composition in mathematics</a>. In this model, when composing functions <em>f</em> and <em>g</em>, the resulting composite (<em>f</em> ∘ <em>g</em>)(<em>x</em>) is equivalent to <em>f</em>(<em>g</em>(<em>x</em>)).</p>\n<p>As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:</p>\n<ol>\n<li>The expressions for each decorator are evaluated top-to-bottom.</li>\n<li>The results are then called as functions from bottom-to-top.</li>\n</ol>\n<p>If we were to use <a href=\"#decorator-factories\">decorator factories</a>, we can observe this evaluation order with the following example:</p>\n<pre data-language=\"typescript\">function f() {\r\n  console.log(\"f(): evaluated\");\r\n  return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\r\n    console.log(\"f(): called\");\r\n  }\r\n}\r\n\r\nfunction g() {\r\n  console.log(\"g(): evaluated\");\r\n  return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\r\n    console.log(\"g(): called\");\r\n  }\r\n}\r\n\r\nclass C {\r\n  @f()\r\n  @g()\r\n  method() {}\r\n}\r\n</pre>\n<p>Which would print this output to the console:</p>\n<pre data-language=\"shell\">f(): evaluated\r\ng(): evaluated\r\ng(): called\r\nf(): called\r\n</pre>\n<h2 id=\"decorator-evaluation\">Decorator Evaluation</h2>\n<p>There is a well defined order to how decorators applied to various declarations inside of a class are applied:</p>\n<ol>\n<li>\n<em>Parameter Decorators</em>, followed by <em>Method</em>, <em>Accessor</em>, or <em>Property Decorators</em> are applied for each instance member.</li>\n<li>\n<em>Parameter Decorators</em>, followed by <em>Method</em>, <em>Accessor</em>, or <em>Property Decorators</em> are applied for each static member.</li>\n<li>\n<em>Parameter Decorators</em> are applied for the constructor.</li>\n<li>\n<em>Class Decorators</em> are applied for the class.</li>\n</ol>\n<h2 id=\"class-decorators\">Class Decorators</h2>\n<p>A <em>Class Decorator</em> is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a <code>declare</code> class).</p>\n<p>The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.</p>\n<p>If the class decorator returns a value, it will replace the class declaration with the provided constructor function.</p>\n<blockquote><p>NOTE Should you chose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will <strong>not</strong> do this for you.</p></blockquote>\n<p>The following is an example of a class decorator (<code>@sealed</code>) applied to the <code>Greeter</code> class:</p>\n<pre data-language=\"typescript\">@sealed\r\nclass Greeter {\r\n  greeting: string;\r\n  constructor(message: string) {\r\n    this.greeting = message;\r\n  }\r\n  greet() {\r\n    return \"Hello, \" + this.greeting;\r\n  }\r\n}\r\n</pre>\n<p>We can define the <code>@sealed</code> decorator using the following function declaration:</p>\n<pre data-language=\"typescript\">function sealed(constructor: Function) {\r\n  Object.seal(constructor);\r\n  Object.seal(constructor.prototype);\r\n}\r\n</pre>\n<p>When <code>@sealed</code> is executed, it will seal both the constructor and its prototype.</p>\n<h2 id=\"method-decorators\">Method Decorators</h2>\n<p>A <em>Method Decorator</em> is declared just before a method declaration. The decorator is applied to the <em>Property Descriptor</em> for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a <code>declare</code> class).</p>\n<p>The expression for the method decorator will be called as a function at runtime, with the following three arguments:</p>\n<ol>\n<li>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</li>\n<li>The name of the member.</li>\n<li>The <em>Property Descriptor</em> for the member.</li>\n</ol>\n<blockquote><p>NOTE The <em>Property Descriptor</em> will be <code>undefined</code> if your script target is less than <code>ES5</code>.</p></blockquote>\n<p>If the method decorator returns a value, it will be used as the <em>Property Descriptor</em> for the method.</p>\n<blockquote><p>NOTE The return value is ignored if your script target is less than <code>ES5</code>.</p></blockquote>\n<p>The following is an example of a method decorator (<code>@enumerable</code>) applied to a method on the <code>Greeter</code> class:</p>\n<pre data-language=\"typescript\">class Greeter {\r\n  greeting: string;\r\n  constructor(message: string) {\r\n    this.greeting = message;\r\n  }\r\n\r\n  @enumerable(false)\r\n  greet() {\r\n    return \"Hello, \" + this.greeting;\r\n  }\r\n}\r\n</pre>\n<p>We can define the <code>@enumerable</code> decorator using the following function declaration:</p>\n<pre data-language=\"typescript\">function enumerable(value: boolean) {\r\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\r\n    descriptor.enumerable = value;\r\n  };\r\n}\r\n</pre>\n<p>The <code>@enumerable(false)</code> decorator here is a <a href=\"#decorator-factories\">decorator factory</a>. When the <code>@enumerable(false)</code> decorator is called, it modifies the <code>enumerable</code> property of the property descriptor.</p>\n<h2 id=\"accessor-decorators\">Accessor Decorators</h2>\n<p>An <em>Accessor Decorator</em> is declared just before an accessor declaration. The accessor decorator is applied to the <em>Property Descriptor</em> for the accessor and can be used to observe, modify, or replace an accessor’s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a <code>declare</code> class).</p>\n<blockquote><p>NOTE TypeScript disallows decorating both the <code>get</code> and <code>set</code> accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a <em>Property Descriptor</em>, which combines both the <code>get</code> and <code>set</code> accessor, not each declaration separately.</p></blockquote>\n<p>The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:</p>\n<ol>\n<li>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</li>\n<li>The name of the member.</li>\n<li>The <em>Property Descriptor</em> for the member.</li>\n</ol>\n<blockquote><p>NOTE The <em>Property Descriptor</em> will be <code>undefined</code> if your script target is less than <code>ES5</code>.</p></blockquote>\n<p>If the accessor decorator returns a value, it will be used as the <em>Property Descriptor</em> for the member.</p>\n<blockquote><p>NOTE The return value is ignored if your script target is less than <code>ES5</code>.</p></blockquote>\n<p>The following is an example of an accessor decorator (<code>@configurable</code>) applied to a member of the <code>Point</code> class:</p>\n<pre data-language=\"typescript\">class Point {\r\n  private _x: number;\r\n  private _y: number;\r\n  constructor(x: number, y: number) {\r\n    this._x = x;\r\n    this._y = y;\r\n  }\r\n\r\n  @configurable(false)\r\n  get x() { return this._x; }\r\n\r\n  @configurable(false)\r\n  get y() { return this._y; }\r\n}\r\n</pre>\n<p>We can define the <code>@configurable</code> decorator using the following function declaration:</p>\n<pre data-language=\"typescript\">function configurable(value: boolean) {\r\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\r\n    descriptor.configurable = value;\r\n  };\r\n}\r\n</pre>\n<h2 id=\"property-decorators\">Property Decorators</h2>\n<p>A <em>Property Decorator</em> is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a <code>declare</code> class).</p>\n<p>The expression for the property decorator will be called as a function at runtime, with the following two arguments:</p>\n<ol>\n<li>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</li>\n<li>The name of the member.</li>\n</ol>\n<blockquote><p>NOTE A <em>Property Descriptor</em> is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.</p></blockquote>\n<p>If the property decorator returns a value, it will be used as the <em>Property Descriptor</em> for the member.</p>\n<blockquote><p>NOTE The return value is ignored if your script target is less than <code>ES5</code>.</p></blockquote>\n<p>We can use this information to record metadata about the property, as in the following example:</p>\n<pre data-language=\"typescript\">class Greeter {\r\n  @format(\"Hello, %s\")\r\n  greeting: string;\r\n\r\n  constructor(message: string) {\r\n    this.greeting = message;\r\n  }\r\n  greet() {\r\n    let formatString = getFormat(this, \"greeting\");\r\n    return formatString.replace(\"%s\", this.greeting);\r\n  }\r\n}\r\n</pre>\n<p>We can then define the <code>@format</code> decorator and <code>getFormat</code> functions using the following function declarations:</p>\n<pre data-language=\"typescript\">import \"reflect-metadata\";\r\n\r\nconst formatMetadataKey = Symbol(\"format\");\r\n\r\nfunction format(formatString: string) {\r\n  return Reflect.metadata(formatMetadataKey, formatString);\r\n}\r\n\r\nfunction getFormat(target: any, propertyKey: string) {\r\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\r\n}\r\n</pre>\n<p>The <code>@format(\"Hello, %s\")</code> decorator here is a <a href=\"#decorator-factories\">decorator factory</a>. When <code>@format(\"Hello, %s\")</code> is called, it adds a metadata entry for the property using the <code>Reflect.metadata</code> function from the <code>reflect-metadata</code> library. When <code>getFormat</code> is called, it reads the metadata value for the format.</p>\n<blockquote><p>NOTE This example requires the <code>reflect-metadata</code> library. See <a href=\"#metadata\">Metadata</a> for more information about the <code>reflect-metadata</code> library.</p></blockquote>\n<h2 id=\"parameter-decorators\">Parameter Decorators</h2>\n<p>A <em>Parameter Decorator</em> is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a <code>declare</code> class).</p>\n<p>The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:</p>\n<ol>\n<li>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</li>\n<li>The name of the member.</li>\n<li>The ordinal index of the parameter in the function’s parameter list.</li>\n</ol>\n<blockquote><p>NOTE A parameter decorator can only be used to observe that a parameter has been declared on a method.</p></blockquote>\n<p>The return value of the parameter decorator is ignored.</p>\n<p>The following is an example of a parameter decorator (<code>@required</code>) applied to parameter of a member of the <code>Greeter</code> class:</p>\n<pre data-language=\"typescript\">class Greeter {\r\n  greeting: string;\r\n\r\n  constructor(message: string) {\r\n    this.greeting = message;\r\n  }\r\n\r\n  @validate\r\n  greet(@required name: string) {\r\n    return \"Hello \" + name + \", \" + this.greeting;\r\n  }\r\n}\r\n</pre>\n<p>We can then define the <code>@required</code> and <code>@validate</code> decorators using the following function declarations:</p>\n<pre data-language=\"typescript\">import \"reflect-metadata\";\r\n\r\nconst requiredMetadataKey = Symbol(\"required\");\r\n\r\nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {\r\n  let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\r\n  existingRequiredParameters.push(parameterIndex);\r\n  Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);\r\n}\r\n\r\nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor&lt;Function&gt;) {\r\n  let method = descriptor.value;\r\n  descriptor.value = function () {\r\n    let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\r\n    if (requiredParameters) {\r\n      for (let parameterIndex of requiredParameters) {\r\n        if (parameterIndex &gt;= arguments.length || arguments[parameterIndex] === undefined) {\r\n          throw new Error(\"Missing required argument.\");\r\n        }\r\n      }\r\n    }\r\n\r\n    return method.apply(this, arguments);\r\n  }\r\n}\r\n</pre>\n<p>The <code>@required</code> decorator adds a metadata entry that marks the parameter as required. The <code>@validate</code> decorator then wraps the existing <code>greet</code> method in a function that validates the arguments before invoking the original method.</p>\n<blockquote><p>NOTE This example requires the <code>reflect-metadata</code> library. See <a href=\"#metadata\">Metadata</a> for more information about the <code>reflect-metadata</code> library.</p></blockquote>\n<h2 id=\"metadata\">Metadata</h2>\n<p>Some examples use the <code>reflect-metadata</code> library which adds a polyfill for an <a href=\"https://github.com/rbuckton/ReflectDecorators\">experimental metadata API</a>. This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.</p>\n<p>You can install this library via npm:</p>\n<pre data-language=\"shell\">npm i reflect-metadata --save\r\n</pre>\n<p>TypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators. To enable this experimental support, you must set the <code>emitDecoratorMetadata</code> compiler option either on the command line or in your <code>tsconfig.json</code>:</p>\n<p><strong>Command Line</strong>:</p>\n<pre data-language=\"shell\">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\r\n</pre>\n<p><strong>tsconfig.json</strong>:</p>\n<pre data-language=\"javascripton\">{\r\n  \"compilerOptions\": {\r\n    \"target\": \"ES5\",\r\n    \"experimentalDecorators\": true,\r\n    \"emitDecoratorMetadata\": true\r\n  }\r\n}\r\n</pre>\n<p>When enabled, as long as the <code>reflect-metadata</code> library has been imported, additional design-time type information will be exposed at runtime.</p>\n<p>We can see this in action in the following example:</p>\n<pre data-language=\"typescript\">import \"reflect-metadata\";\r\n\r\nclass Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nclass Line {\r\n  private _p0: Point;\r\n  private _p1: Point;\r\n\r\n  @validate\r\n  set p0(value: Point) { this._p0 = value; }\r\n  get p0() { return this._p0; }\r\n\r\n  @validate\r\n  set p1(value: Point) { this._p1 = value; }\r\n  get p1() { return this._p1; }\r\n}\r\n\r\nfunction validate&lt;T&gt;(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;T&gt;) {\r\n  let set = descriptor.set;\r\n  descriptor.set = function (value: T) {\r\n    let type = Reflect.getMetadata(\"design:type\", target, propertyKey);\r\n    if (!(value instanceof type)) {\r\n      throw new TypeError(\"Invalid type.\");\r\n    }\r\n  }\r\n}\r\n</pre>\n<p>The TypeScript compiler will inject design-time type information using the <code>@Reflect.metadata</code> decorator. You could consider it the equivalent of the following TypeScript:</p>\n<pre data-language=\"typescript\">class Line {\r\n  private _p0: Point;\r\n  private _p1: Point;\r\n\r\n  @validate\r\n  @Reflect.metadata(\"design:type\", Point)\r\n  set p0(value: Point) { this._p0 = value; }\r\n  get p0() { return this._p0; }\r\n\r\n  @validate\r\n  @Reflect.metadata(\"design:type\", Point)\r\n  set p1(value: Point) { this._p1 = value; }\r\n  get p1() { return this._p1; }\r\n}\r\n\r\n</pre>\n<blockquote><p>NOTE Decorator metadata is an experimental feature and may introduce breaking changes in future releases.</p></blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Microsoft and other contributors<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html\" class=\"_attribution-link\">https://www.typescriptlang.org/docs/handbook/decorators.html</a>\n  </p>\n</div>\n"}