{"index":"<h1>Vue.js</h1> <p>Let’s start with a quick tour of Vue’s data binding features. If you are more interested in a high-level overview first, check out this <a href=\"http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/\" target=\"_blank\" rel=\"external\">blog post</a>.</p> <p>The easiest way to try out Vue.js is using the <a href=\"https://jsfiddle.net/yyx990803/okv0rgrk/\" target=\"_blank\" rel=\"external\">JSFiddle Hello World example</a>. Feel free to open it in another tab and follow along as we go through some basic examples. If you prefer downloading / installing from a package manager, check out the <a href=\"guide/installation\">Installation</a> page.</p> <h3 id=\"Hello-World\">\nHello World</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"app\"&gt;\n  {{ message }}\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue.js!'\n  }\n})</pre>   <h3 id=\"Two-way-Binding\">\nTwo-way Binding</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;p&gt;{{ message }}&lt;/p&gt;\n  &lt;input v-model=\"message\"&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue.js!'\n  }\n})</pre>   <h3 id=\"Render-a-List\">\nRender a List</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;ul&gt;\n    &lt;li v-for=\"todo in todos\"&gt;\n      {{ todo.text }}\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#app',\n  data: {\n    todos: [\n      { text: 'Learn JavaScript' },\n      { text: 'Learn Vue.js' },\n      { text: 'Build Something Awesome' }\n    ]\n  }\n})</pre>   <h3 id=\"Handle-User-Input\">\nHandle User Input</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;p&gt;{{ message }}&lt;/p&gt;\n  &lt;button v-on:click=\"reverseMessage\"&gt;Reverse Message&lt;/button&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue.js!'\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})</pre>   <h3 id=\"All-Together-Now\">\nAll Together Now</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;input v-model=\"newTodo\" v-on:keyup.enter=\"addTodo\"&gt;\n  &lt;ul&gt;\n    &lt;li v-for=\"todo in todos\"&gt;\n      &lt;span&gt;{{ todo.text }}&lt;/span&gt;\n      &lt;button v-on:click=\"removeTodo($index)\"&gt;X&lt;/button&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#app',\n  data: {\n    newTodo: '',\n    todos: [\n      { text: 'Add some todos' }\n    ]\n  },\n  methods: {\n    addTodo: function () {\n      var text = this.newTodo.trim()\n      if (text) {\n        this.todos.push({ text: text })\n        this.newTodo = ''\n      }\n    },\n    removeTodo: function (index) {\n      this.todos.splice(index, 1)\n    }\n  }\n})</pre>   <p>I hope this gives you a basic idea of how Vue.js works. I’m sure you also have many questions now - read along, and we will cover them in the rest of the guide.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/index.html\" class=\"_attribution-link\">https://vuejs.org/guide/index.html</a>\n  </p>\n</div>\n","guide/installation":"<h1>Installation</h1> <h3 id=\"Compatibility-Note\">\nCompatibility Note</h3>\n<p>Vue.js does <strong>not</strong> support IE8 and below, because Vue.js uses ECMAScript 5 features that are un-shimmable in IE8. However Vue.js supports all <a href=\"http://caniuse.com/#feat=es5\" target=\"_blank\" rel=\"external\">ECMAScript 5 compliant browsers</a>.</p> <h3 id=\"Release-Notes\">\nRelease Notes</h3>\n<p>Detailed release notes for each version are available on <a href=\"https://github.com/vuejs/vue/releases\" target=\"_blank\" rel=\"external\">GitHub</a>.</p> <h2 id=\"Standalone\">\nStandalone</h2>\n<p>Simply download and include with a script tag. <code>Vue</code> will be registered as a global variable. <strong>Pro tip: don’t use the minified version during development. you will miss out all the nice warnings for common mistakes.</strong></p> <div id=\"downloads\">\n<br><a class=\"button\" href=\"https://vuejs.org/js/vue.js\" download=\"\">Development Version</a><span class=\"light info\">With full warnings and debug mode</span><br><br><a class=\"button\" href=\"https://vuejs.org/js/vue.min.js\" download=\"\">Production Version</a><span class=\"light info\">Warnings stripped, 25.79kb min+gzip</span><br>\n</div> <h3 id=\"CDN\">\nCDN</h3>\n<p>Available on <a href=\"https://cdn.jsdelivr.net/vue/1.0.24/vue.min.js\">jsdelivr</a> or <a href=\"https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.24/vue.min.js\">cdnjs</a> (takes some time to sync so the latest version might not be available yet).</p> <h3 id=\"CSP-compliant-build\">\nCSP-compliant build</h3>\n<p>Some environments, such as Google Chrome Apps, enforces Content Security Policy (CSP) and does not allow the use of <code>new Function()</code> for evaluating expressions. In these cases you can use the <a href=\"https://github.com/vuejs/vue/tree/csp/dist\" target=\"_blank\" rel=\"external\">CSP-compliant build</a> instead.</p> <h2 id=\"NPM\">\nNPM</h2>\n<p>NPM is the recommended installation method when building large scale apps with Vue.js. It pairs nicely with a CommonJS module bundler such as <a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"external\">Webpack</a> or <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"external\">Browserify</a>. Vue.js also provides accompanying tools for authoring <a href=\"application#Single-File-Components\">Single File Components</a>.</p> <pre class=\"highlight bash\" data-language=\"bash\"># latest stable\n$ npm install vue\n# latest stable + CSP-compliant\n$ npm install [email protected]</pre> <h2 id=\"CLI\">\nCLI</h2>\n<p>Vue.js provides an <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"external\">official CLI</a> for quickly scaffolding ambitious Single Page Applications. It provides battery-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save and production-ready builds:</p> <pre class=\"highlight bash\" data-language=\"bash\"># install vue-cli\n$ npm install -g vue-cli\n# create a new project using the \"webpack\" boilerplate\n$ vue init webpack my-project\n# install dependencies and go!\n$ cd my-project\n$ npm install\n$ npm run dev</pre> <h2 id=\"Dev-Build\">\nDev Build</h2>\n<p><strong>Important</strong>: the CommonJS bundle distributed on NPM (<code>vue.common.js</code>) is only checked-in during releases on the <code>master</code> branch, so the file in the <code>dev</code> branch is the same as the stable release. To use Vue from the latest source code on GitHub, you will have to build it yourself!</p> <pre class=\"highlight bash\" data-language=\"bash\">git clone https://github.com/vuejs/vue.git node_modules/vue\ncd node_modules/vue\nnpm install\nnpm run build</pre> <h2 id=\"Bower\">\nBower</h2>\n<pre class=\"highlight bash\" data-language=\"bash\"># latest stable\n$ bower install vue</pre> <h2 id=\"AMD-Module-Loaders\">\nAMD Module Loaders</h2>\n<p>The standalone downloads or versions installed via Bower are wrapped with UMD so they can be used directly as an AMD module.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/installation.html\" class=\"_attribution-link\">https://vuejs.org/guide/installation.html</a>\n  </p>\n</div>\n","guide/custom-filter":"<h1>Custom Filters</h1> <h2 id=\"Basics\">\nBasics</h2>\n<p>Similar to custom directives, you can register a custom filter with the global <code>Vue.filter()</code> method, passing in a <strong>filterID</strong> and a <strong>filter function</strong>. The filter function takes a value as the argument and returns the transformed value:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.filter('reverse', function (value) {\n  return value.split('').reverse().join('')\n})</pre> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- 'abc' =&gt; 'cba' --&gt;\n&lt;span v-text=\"message | reverse\"&gt;&lt;/span&gt;</pre> <p>The filter function also receives any inline arguments:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.filter('wrap', function (value, begin, end) {\n  return begin + value + end\n})</pre> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- 'hello' =&gt; 'before hello after' --&gt;\n&lt;span v-text=\"message | wrap 'before' 'after'\"&gt;&lt;/span&gt;</pre> <h2 id=\"Two-way-Filters\">\nTwo-way Filters</h2>\n<p>Up till now we have used filters to transform values coming from the model and before displaying them in the view. But it is also possible to define a filter that transforms the value before it is written back to the model from the view (input elements):</p> <pre class=\"highlight js\" data-language=\"js\">Vue.filter('currencyDisplay', {\n  // model -&gt; view\n  // formats the value when updating the input element.\n  read: function(val) {\n    return '$'+val.toFixed(2)\n  },\n  // view -&gt; model\n  // formats the value when writing to the data.\n  write: function(val, oldVal) {\n    var number = +val.replace(/[^\\d.]/g, '')\n    return isNaN(number) ? 0 : parseFloat(number.toFixed(2))\n  }\n})</pre> <p>Demo:</p>   <h2 id=\"Dynamic-Arguments\">\nDynamic Arguments</h2>\n<p>If a filter argument is not enclosed by quotes, it will be evaluated dynamically in the current vm’s data context. In addition, the filter function is always invoked using the current vm as its <code>this</code> context. For example:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;input v-model=\"userInput\"&gt;\n&lt;span&gt;{{msg | concat userInput}}&lt;/span&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">Vue.filter('concat', function (value, input) {\n  // here `input` === `this.userInput`\n  return value + input\n})</pre> <p>For this simple example above, you can achieve the same result with just an expression, but for more complicated procedures that need more than one statement, you need to put them either in a computed property or a custom filter.</p> <p>The built-in <code>filterBy</code> and <code>orderBy</code> filters are both filters that perform non-trivial work on the Array being passed in and relies on the current state of the owner Vue instance.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/custom-filter.html\" class=\"_attribution-link\">https://vuejs.org/guide/custom-filter.html</a>\n  </p>\n</div>\n","guide/instance":"<h1>The Vue Instance</h1> <h2 id=\"Constructor\">\nConstructor</h2>\n<p>Every Vue.js app is bootstrapped by creating a <strong>root Vue instance</strong> with the <code>Vue</code> constructor function:</p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  // options\n})</pre> <p>A Vue instance is essentially a <strong>ViewModel</strong> as defined in the <a href=\"https://en.wikipedia.org/wiki/Model_View_ViewModel\" target=\"_blank\" rel=\"external\">MVVM pattern</a>, hence the variable name <code>vm</code> you will see throughout the docs.</p> <p>When you instantiate a Vue instance, you need to pass in an <strong>options object</strong> which can contain options for data, template, element to mount on, methods, lifecycle callbacks and more. The full list of options can be found in the API reference.</p> <p>The <code>Vue</code> constructor can be extended to create reusable <strong>component constructors</strong> with pre-defined options:</p> <pre class=\"highlight js\" data-language=\"js\">var MyComponent = Vue.extend({\n  // extension options\n})\n\n// all instances of `MyComponent` are created with\n// the pre-defined extension options\nvar myComponentInstance = new MyComponent()</pre> <p>Although you can create extended instances imperatively, in most cases you will be registering a component constructor as a custom element and composing them in templates declaratively. We will talk about the component system in detail later. For now, you just need to know that all Vue.js components are essentially extended Vue instances.</p> <h2 id=\"Properties-and-Methods\">\nProperties and Methods</h2>\n<p>Each Vue instance <strong>proxies</strong> all the properties found in its <code>data</code> object:</p> <pre class=\"highlight js\" data-language=\"js\">var data = { a: 1 }\nvar vm = new Vue({\n  data: data\n})\n\nvm.a === data.a // -&gt; true\n\n// setting the property also affects original data\nvm.a = 2\ndata.a // -&gt; 2\n\n// ... and vice-versa\ndata.a = 3\nvm.a // -&gt; 3</pre> <p>It should be noted that only these proxied properties are <strong>reactive</strong>. If you attach a new property to the instance after it has been created, it will not trigger any view updates. We will discuss the reactivity system in details later.</p> <p>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These properties and methods are prefixed with <code>$</code> to differentiate from proxied data properties. For example:</p> <pre class=\"highlight js\" data-language=\"js\">var data = { a: 1 }\nvar vm = new Vue({\n  el: '#example',\n  data: data\n})\n\nvm.$data === data // -&gt; true\nvm.$el === document.getElementById('example') // -&gt; true\n\n// $watch is an instance method\nvm.$watch('a', function (newVal, oldVal) {\n  // this callback will be called when `vm.a` changes\n})</pre> <p>Consult the <a href=\"https://vuejs.org/api\">API reference</a> for the full list of instance properties and methods.</p> <h2 id=\"Instance-Lifecycle\">\nInstance Lifecycle</h2>\n<p>Each Vue instance goes through a series of initialization steps when it is created - for example, it needs to set up data observation, compile the template, and create the necessary data bindings. Along the way, it will also invoke some <strong>lifecycle hooks</strong>, which give us the opportunity to execute custom logic. For example, the <code>created</code> hook is called after the instance is created:</p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` points to the vm instance\n    console.log('a is: ' + this.a)\n  }\n})\n// -&gt; \"a is: 1\"</pre> <p>There are also other hooks which will be called at different stages of the instance’s lifecycle, for example <code>compiled</code>, <code>ready</code> and <code>destroyed</code>. All lifecycle hooks are called with their <code>this</code> context pointing to the Vue instance invoking it. Some users may have been wondering where the concept of “controllers” lives in the Vue.js world, and the answer is: there are no controllers in Vue.js. Your custom logic for a component would be split among these lifecycle hooks.</p> <h2 id=\"Lifecycle-Diagram\">\nLifecycle Diagram</h2>\n<p>Below is a diagram for the instance lifecycle. You don’t need to fully understand everything going on right now, but this diagram will be helpful in the future.</p> <p><img src=\"https://vuejs.org/images/lifecycle.png\" alt=\"Lifecycle\"></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/instance.html\" class=\"_attribution-link\">https://vuejs.org/guide/instance.html</a>\n  </p>\n</div>\n","guide/conditional":"<h1>Conditional Rendering</h1> <h2 id=\"v-if\">\nv-if</h2>\n<p>In string templates, for example Handlebars, we would write a conditional block like this:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- Handlebars template --&gt;\n{{#if ok}}\n  &lt;h1&gt;Yes&lt;/h1&gt;\n{{/if}}</pre> <p>In Vue.js, we use the <code>v-if</code> directive to achieve the same:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt;</pre> <p>It is also possible to add an “else” block with <code>v-else</code>:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt;\n&lt;h1 v-else&gt;No&lt;/h1&gt;</pre> <h2 id=\"Template-v-if\">\nTemplate v-if</h2>\n<p>Because <code>v-if</code> is a directive, it has to be attached to a single element. But what if we want to toggle more than one element? In this case we can use <code>v-if</code> on a <code>&lt;template&gt;</code> element, which serves as an invisible wrapper. The final rendered result will not include the <code>&lt;template&gt;</code> element.</p> <pre class=\"highlight html\" data-language=\"html\">&lt;template v-if=\"ok\"&gt;\n  &lt;h1&gt;Title&lt;/h1&gt;\n  &lt;p&gt;Paragraph 1&lt;/p&gt;\n  &lt;p&gt;Paragraph 2&lt;/p&gt;\n&lt;/template&gt;</pre> <h2 id=\"v-show\">\nv-show</h2>\n<p>Another option for conditionally displaying an element is the <code>v-show</code> directive. The usage is largely the same:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt;</pre> <p>The difference is that an element with <code>v-show</code> will always be rendered and remain in the DOM; <code>v-show</code> simply toggles the <code>display</code> CSS property of the element.</p> <p>Note that <code>v-show</code> doesn’t support the <code>&lt;template&gt;</code> syntax.</p> <h2 id=\"v-else\">\nv-else</h2>\n<p>You can use the <code>v-else</code> directive to indicate an “else block” for <code>v-if</code> or <code>v-show</code>:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-if=\"Math.random() &gt; 0.5\"&gt;\n  Sorry\n&lt;/div&gt;\n&lt;div v-else&gt;\n  Not sorry\n&lt;/div&gt;</pre> <p>The <code>v-else</code> element must immediately follow the <code>v-if</code> or <code>v-show</code> element - otherwise it will not be recognized.</p> <h3 id=\"Component-caveat\">\nComponent caveat</h3>\n<p>When used with components and <code>v-show</code>, <code>v-else</code> doesn’t get applied properly due to directives priorities. So instead of doing this:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;custom-component v-show=\"condition\"&gt;&lt;/custom-component&gt;\n&lt;p v-else&gt;This could be a component too&lt;/p&gt;</pre> <p>Replace the <code>v-else</code> with another <code>v-show</code>:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;custom-component v-show=\"condition\"&gt;&lt;/custom-component&gt;\n&lt;p v-show=\"!condition\"&gt;This could be a component too&lt;/p&gt;</pre> <p>It does work as intended with <code>v-if</code>.</p> <h2 id=\"v-if-vs-v-show\">\nv-if vs. v-show</h2>\n<p>When a <code>v-if</code> block is toggled, Vue.js will have to perform a partial compilation/teardown process, because the template content inside <code>v-if</code> can also contain data bindings or child components. <code>v-if</code> is “real” conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles.</p> <p><code>v-if</code> is also <strong>lazy</strong>: if the condition is false on initial render, it will not do anything - partial compilation won’t start until the condition becomes true for the first time (and the compilation is subsequently cached).</p> <p>In comparison, <code>v-show</code> is much simpler - the element is always compiled and preserved, with just simple CSS-based toggling.</p> <p>Generally speaking, <code>v-if</code> has higher toggle costs while <code>v-show</code> has higher initial render costs. So prefer <code>v-show</code> if you need to toggle something very often, and prefer <code>v-if</code> if the condition is unlikely to change at runtime.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/conditional.html\" class=\"_attribution-link\">https://vuejs.org/guide/conditional.html</a>\n  </p>\n</div>\n","guide/computed":"<h1>Computed Properties</h1> <p>In-template expressions are very convenient, but they are really meant for simple operations only. Templates are meant to describe the structure of your view. Putting too much logic into your templates can make them bloated and hard to maintain. This is why Vue.js limits binding expressions to one expression only. For any logic that requires more than one expression, you should use a <strong>computed property</strong>.</p> <h3 id=\"Basic-Example\">\nBasic Example</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"example\"&gt;\n  a={{ a }}, b={{ b }}\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  el: '#example',\n  data: {\n    a: 1\n  },\n  computed: {\n    // a computed getter\n    b: function () {\n      // `this` points to the vm instance\n      return this.a + 1\n    }\n  }\n})</pre> <p>Result:</p>   <p>Here we have declared a computed property <code>b</code>. The function we provided will be used as the getter function for the property <code>vm.b</code>:</p> <pre class=\"highlight js\" data-language=\"js\">console.log(vm.b) // -&gt; 2\nvm.a = 2\nconsole.log(vm.b) // -&gt; 3</pre> <p>You can open the console and play with the example vm yourself. The value of <code>vm.b</code> is always dependent on the value of <code>vm.a</code>.</p> <p>You can data-bind to computed properties in templates just like a normal property. Vue is aware that <code>vm.b</code> depends on <code>vm.a</code>, so it will update any bindings that depends on <code>vm.b</code> when <code>vm.a</code> changes. And the best part is that we’ve created this dependency relationship declaratively: the computed getter function is pure and has no side effects, which makes it easy to test and reason about.</p> <h3 id=\"Computed-Property-vs-watch\">\nComputed Property vs. $watch</h3>\n<p>Vue.js does provide an API method called <code>$watch</code> that allows you to observe data changes on a Vue instance. When you have some data that needs to change based on some other data, it is tempting to use <code>$watch</code> - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative <code>$watch</code> callback. Consider this example:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"demo\"&gt;{{fullName}}&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar',\n    fullName: 'Foo Bar'\n  }\n})\n\nvm.$watch('firstName', function (val) {\n  this.fullName = val + ' ' + this.lastName\n})\n\nvm.$watch('lastName', function (val) {\n  this.fullName = this.firstName + ' ' + val\n})</pre> <p>The above code is imperative and repetitive. Compare it with a computed property version:</p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar'\n  },\n  computed: {\n    fullName: function () {\n      return this.firstName + ' ' + this.lastName\n    }\n  }\n})</pre> <p>Much better, isn’t it?</p> <h3 id=\"Computed-Setter\">\nComputed Setter</h3>\n<p>Computed properties are by default getter-only, but you can also provide a setter when you need it:</p> <pre class=\"highlight js\" data-language=\"js\">// ...\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...</pre> <p>Now when you call <code>vm.fullName = 'John Doe'</code>, the setter will be invoked and <code>vm.firstName</code> and <code>vm.lastName</code> will be updated accordingly.</p> <p>The technical details behind how computed properties are updated are <a href=\"reactivity#Inside-Computed-Properties\">discussed in another section</a> dedicated to the reactivity system.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/computed.html\" class=\"_attribution-link\">https://vuejs.org/guide/computed.html</a>\n  </p>\n</div>\n","guide/class-and-style":"<h1>Class and Style Bindings</h1> <p>A common need for data binding is manipulating an element’s class list and its inline styles. Since they are both attributes, we can use <code>v-bind</code> to handle them: we just need to calculate a final string with our expressions. However, meddling with string concatenation is annoying and error-prone. For this reason, Vue.js provides special enhancements when <code>v-bind</code> is used for <code>class</code> and <code>style</code>. In addition to Strings, the expressions can also evaluate to Objects or Arrays.</p> <h2 id=\"Binding-HTML-Classes\">\nBinding HTML Classes</h2>\n<p class=\"tip\">Although you can use mustache interpolations such as <code>class=\"{{ className }}\"</code> to bind the class, it is not recommended to mix that style with <code>v-bind:class</code>. Use one or the other!</p> <h3 id=\"Object-Syntax\">\nObject Syntax</h3>\n<p>We can pass an Object to <code>v-bind:class</code> to dynamically toggle classes. Note the <code>v-bind:class</code> directive can co-exist with the plain <code>class</code> attribute:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div class=\"static\" v-bind:class=\"{ 'class-a': isA, 'class-b': isB }\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">data: {\n  isA: true,\n  isB: false\n}</pre> <p>Which will render:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div class=\"static class-a\"&gt;&lt;/div&gt;</pre> <p>When <code>isA</code> and <code>isB</code> changes, the class list will be updated accordingly. For example, if <code>isB</code> becomes <code>true</code>, the class list will become <code>\"static class-a class-b\"</code>.</p> <p>And you can directly bind to an object in data as well:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">data: {\n  classObject: {\n    'class-a': true,\n    'class-b': false\n  }\n}</pre> <p>This will render the same result. As you may have noticed, we can also bind to a <a href=\"computed\">computed property</a> that returns an Object. This is a common and powerful pattern.</p> <h3 id=\"Array-Syntax\">\nArray Syntax</h3>\n<p>We can pass an Array to <code>v-bind:class</code> to apply a list of classes:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-bind:class=\"[classA, classB]\"&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">data: {\n  classA: 'class-a',\n  classB: 'class-b'\n}</pre> <p>Which will render:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div class=\"class-a class-b\"&gt;&lt;/div&gt;</pre> <p>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-bind:class=\"[classA, isB ? classB : '']\"&gt;</pre> <p>This will always apply <code>classA</code>, but will only apply <code>classB</code> when <code>isB</code> is <code>true</code>.</p> <p>However, this can be a bit verbose if you have multiple conditional classes. In version 1.0.19+, it’s also possible to use the Object syntax inside Array syntax:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-bind:class=\"[classA, { classB: isB, classC: isC }]\"&gt;</pre> <h2 id=\"Binding-Inline-Styles\">\nBinding Inline Styles</h2>\n<h3 id=\"Object-Syntax-1\">\nObject Syntax</h3>\n<p>The Object syntax for <code>v-bind:style</code> is pretty straightforward - it looks almost like CSS, except it’s a JavaScript object. You can use either camelCase or kebab-case for the CSS property names:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">data: {\n  activeColor: 'red',\n  fontSize: 30\n}</pre> <p>It is often a good idea to bind to a style object directly so that the template is cleaner:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">data: {\n  styleObject: {\n    color: 'red',\n    fontSize: '13px'\n  }\n}</pre> <p>Again, the Object syntax is often used in conjunction with computed properties that return Objects.</p> <h3 id=\"Array-Syntax-1\">\nArray Syntax</h3>\n<p>The Array syntax for <code>v-bind:style</code> allows you to apply multiple style objects to the same element:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-bind:style=\"[styleObjectA, styleObjectB]\"&gt;</pre> <h3 id=\"Auto-prefixing\">\nAuto-prefixing</h3>\n<p>When you use a CSS property that requires vendor prefixes in <code>v-bind:style</code>, for example <code>transform</code>, Vue.js will automatically detect and add appropriate prefixes to the applied styles.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/class-and-style.html\" class=\"_attribution-link\">https://vuejs.org/guide/class-and-style.html</a>\n  </p>\n</div>\n","guide/mixins":"<h1>Mixins</h1> <h2 id=\"Basics\">\nBasics</h2>\n<p>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be “mixed” into the component’s own options.</p> <p>Example:</p> <pre class=\"highlight js\" data-language=\"js\">// define a mixin object\nvar myMixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log('hello from mixin!')\n    }\n  }\n}\n\n// define a component that uses this mixin\nvar Component = Vue.extend({\n  mixins: [myMixin]\n})\n\nvar component = new Component() // -&gt; \"hello from mixin!\"</pre> <h2 id=\"Option-Merging\">\nOption Merging</h2>\n<p>When a mixin and the component itself contain overlapping options, they will be “merged” using appropriate strategies. For example, hook functions with the same name are merged into an array so that all of them will be called. In addition, mixin hooks will be called <strong>before</strong> the component’s own hooks:</p> <pre class=\"highlight js\" data-language=\"js\">var mixin = {\n  created: function () {\n    console.log('mixin hook called')\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  created: function () {\n    console.log('component hook called')\n  }\n})\n\n// -&gt; \"mixin hook called\"\n// -&gt; \"component hook called\"</pre> <p>Options that expect object values, for example <code>methods</code>, <code>components</code> and <code>directives</code>, will be merged into the same object. The component’s options will take priority when there are conflicting keys in these objects:</p> <pre class=\"highlight js\" data-language=\"js\">var mixin = {\n  methods: {\n    foo: function () {\n      console.log('foo')\n    },\n    conflicting: function () {\n      console.log('from mixin')\n    }\n  }\n}\n\nvar vm = new Vue({\n  mixins: [mixin],\n  methods: {\n    bar: function () {\n      console.log('bar')\n    },\n    conflicting: function () {\n      console.log('from self')\n    }\n  }\n})\n\nvm.foo() // -&gt; \"foo\"\nvm.bar() // -&gt; \"bar\"\nvm.conflicting() // -&gt; \"from self\"</pre> <p>Note that the same merge strategies are used in <code>Vue.extend()</code>.</p> <h2 id=\"Global-Mixin\">\nGlobal Mixin</h2>\n<p>You can also apply a mixin globally. Use caution! Once you apply a mixin globally, it will affect <strong>every</strong> Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:</p> <pre class=\"highlight js\" data-language=\"js\">// inject a handler for `myOption` custom option\nVue.mixin({\n  created: function () {\n    var myOption = this.$options.myOption\n    if (myOption) {\n      console.log(myOption)\n    }\n  }\n})\n\nnew Vue({\n  myOption: 'hello!'\n})\n// -&gt; \"hello!\"</pre> <p class=\"tip\">Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above.</p> <h2 id=\"Custom-Option-Merge-Strategies\">\nCustom Option Merge Strategies</h2>\n<p>When custom options are merged, they use the default strategy, which simply overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to <code>Vue.config.optionMergeStrategies</code>:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {\n  // return mergedVal\n}</pre> <p>For most object-based options, you can simply use the same strategy used by <code>methods</code>:</p> <pre class=\"highlight js\" data-language=\"js\">var strategies = Vue.config.optionMergeStrategies\nstrategies.myOption = strategies.methods</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/mixins.html\" class=\"_attribution-link\">https://vuejs.org/guide/mixins.html</a>\n  </p>\n</div>\n","guide/plugins":"<h1>Plugins</h1> <h2 id=\"Writing-a-Plugin\">\nWriting a Plugin</h2>\n<p>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins you can write:</p> <ol> <li>\n<p>Add some global methods or properties. e.g. <a href=\"https://github.com/vuejs/vue-element\" target=\"_blank\" rel=\"external\">vue-element</a></p> </li> <li>\n<p>Add one or more global assets: directives/filters/transitions etc. e.g. <a href=\"https://github.com/vuejs/vue-touch\" target=\"_blank\" rel=\"external\">vue-touch</a></p> </li> <li>\n<p>Add some Vue instance methods by attaching them to Vue.prototype.</p> </li> <li>\n<p>A library that provides an API of its own, while at the same time injecting some combination of the above. e.g. <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"external\">vue-router</a></p> </li> </ol> <p>A Vue.js plugin should expose an <code>install</code> method. The method will be called with the <code>Vue</code> constructor as the first argument, along with possible options:</p> <pre class=\"highlight js\" data-language=\"js\">MyPlugin.install = function (Vue, options) {\n  // 1. add global method or property\n  Vue.myGlobalMethod = ...\n  // 2. add a global asset\n  Vue.directive('my-directive', {})\n  // 3. add an instance method\n  Vue.prototype.$myMethod = ...\n}</pre> <h2 id=\"Using-a-Plugin\">\nUsing a Plugin</h2>\n<p>Use plugins by calling the <code>Vue.use()</code> global method:</p> <pre class=\"highlight js\" data-language=\"js\">// calls `MyPlugin.install(Vue)`\nVue.use(MyPlugin)</pre> <p>You can optionally pass in some options:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.use(MyPlugin, { someOption: true })</pre> <p>Some plugins such as <code>vue-router</code> automatically calls <code>Vue.use()</code> if <code>Vue</code> is available as a global variable. However in a module environment you always need to call <code>Vue.use()</code> explicitly:</p> <pre class=\"highlight js\" data-language=\"js\">// When using CommonJS via Browserify or Webpack\nvar Vue = require('vue')\nvar VueRouter = require('vue-router')\n\n// Don't forget to call this\nVue.use(VueRouter)</pre> <h2 id=\"Existing-Plugins-amp-Tools\">\nExisting Plugins &amp; Tools</h2>\n<ul> <li>\n<p><a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"external\">vue-router</a>: The official router for Vue.js. Deeply integrated with Vue.js core to make building Single Page Applications a breeze.</p> </li> <li>\n<p><a href=\"https://github.com/vuejs/vue-resource\" target=\"_blank\" rel=\"external\">vue-resource</a>: A plugin that provides services for making web requests and handle responses using a XMLHttpRequest or JSONP.</p> </li> <li>\n<p><a href=\"https://github.com/vuejs/vue-async-data\" target=\"_blank\" rel=\"external\">vue-async-data</a>: Async data loading plugin.</p> </li> <li>\n<p><a href=\"https://github.com/vuejs/vue-validator\" target=\"_blank\" rel=\"external\">vue-validator</a>: A plugin for form validations.</p> </li> <li>\n<p><a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"external\">vue-devtools</a>: A Chrome devtools extension for debugging Vue.js applications.</p> </li> <li>\n<p><a href=\"https://github.com/vuejs/vue-touch\" target=\"_blank\" rel=\"external\">vue-touch</a>: Add touch-gesture directives using Hammer.js.</p> </li> <li>\n<p><a href=\"https://github.com/vuejs/vue-element\" target=\"_blank\" rel=\"external\">vue-element</a>: Register Custom Elements with Vue.js.</p> </li> <li>\n<p><a href=\"https://github.com/vuejs/vue-animated-list\" target=\"_blank\" rel=\"external\">vue-animated-list</a>: A plugin for easily animating <code>v-for</code> rendered lists.</p> </li> <li>\n<p><a href=\"https://github.com/vuejs/awesome-vue#libraries--plugins\" target=\"_blank\" rel=\"external\">List of User Contributed Tools</a></p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/plugins.html\" class=\"_attribution-link\">https://vuejs.org/guide/plugins.html</a>\n  </p>\n</div>\n","guide/overview":"<h1>Overview</h1> <p>Vue.js (pronounced /vjuː/, like <strong>view</strong>) is a library for building interactive web interfaces. The goal of Vue.js is to provide the benefits of <strong>reactive data binding</strong> and <strong>composable view components</strong> with an API that is as simple as possible.</p> <p>Vue.js itself is not a full-blown framework - it is focused on the view layer only. It is therefore very easy to pick up and to integrate with other libraries or existing projects. On the other hand, when used in combination with proper tooling and supporting libraries, Vue.js is also perfectly capable of powering sophisticated Single-Page Applications.</p> <p>If you are an experienced frontend developer and want to know how Vue.js compares to other libraries/frameworks, check out the <a href=\"comparison\">Comparison with Other Frameworks</a>; if you are more interested about how Vue.js approaches larger-scale applications, check out the section on <a href=\"application\">Building Larger-Scale Applications</a>.</p> <h2 id=\"Reactive-Data-Binding\">\nReactive Data Binding</h2>\n<p>At the core of Vue.js is a reactive data-binding system that makes it extremely simple to keep your data and the DOM in sync. When using jQuery to manually manipulate the DOM, the code we write is often imperative, repetitive and error-prone. Vue.js embraces the concept of <strong>data-driven view</strong>. In plain words, it means we use special syntax in our normal HTML templates to “bind” the DOM to the underlying data. Once the bindings are created, the DOM will then be kept in sync with the data. Whenever you modify the data, the DOM updates accordingly. As a result, most of our application logic is now directly manipulating data, rather than messing around with DOM updates. This makes our code easier to write, easier to reason about and easier to maintain.</p> <p><img src=\"https://vuejs.org/images/mvvm.png\" alt=\"MVVM\"></p> <p>For the simplest possible example:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- this is our View --&gt;\n&lt;div id=\"example-1\"&gt;\n  Hello {{ name }}!\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">// this is our Model\nvar exampleData = {\n  name: 'Vue.js'\n}\n\n// create a Vue instance, or, a \"ViewModel\"\n// which links the View and the Model\nvar exampleVM = new Vue({\n  el: '#example-1',\n  data: exampleData\n})</pre> <p>Result:<br> </p>  <p>This looks pretty similar to just rendering a template, but Vue.js has done a lot of work under the hood. The data and the DOM are now linked, and everything is now <strong>reactive</strong>. How do we know? Just open up your browser developer console and modify <code>exampleData.name</code>. You should see the rendered example above update accordingly.</p> <p>Note that we didn’t have to write any DOM-manipulating code: the HTML template, enhanced with the bindings, is a declarative mapping of the underlying data state, which is in turn just plain JavaScript objects. Our view is entirely data-driven.</p> <p>Let’s look at a second example:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"example-2\"&gt;\n  &lt;p v-if=\"greeting\"&gt;Hello!&lt;/p&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">var exampleVM2 = new Vue({\n  el: '#example-2',\n  data: {\n    greeting: true\n  }\n})</pre>   <p>Here we are encountering something new. The <code>v-if</code> attribute you are seeing is called a <strong>Directive</strong>. Directives are prefixed with <code>v-</code> to indicate that they are special attributes provided by Vue.js, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Go ahead and set <code>exampleVM2.greeting</code> to <code>false</code> in the console. You should see the “Hello!” message disappear.</p> <p>This second example demonstrates that not only can we bind DOM text to the data, we can also bind the <strong>structure</strong> of the DOM to the data. Moreover, Vue.js also provides a powerful transition effect system that can automatically apply transition effects when elements are inserted/removed by Vue.</p> <p>There are quite a few other directives, each with its own special functionality. For example the <code>v-for</code> directive for displaying items in an Array, or the <code>v-bind</code> directive for binding HTML attributes. We will discuss the full data-binding syntax with more details later.</p> <h2 id=\"Component-System\">\nComponent System</h2>\n<p>The Component System is another important concept in Vue.js, because it’s an abstraction that allows us to build large-scale applications composed of small, self-contained, and often reusable components. If we think about it, almost any type of application interface can be abstracted into a tree of components:</p> <p><img src=\"https://vuejs.org/images/components.png\" alt=\"Component Tree\"></p> <p>In fact, a typical large application built with Vue.js would form exactly what is on the right - a tree of components. We will talk a lot more about components later in the guide, but here’s an (imaginary) example of what an app’s template would look like with components:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;app-nav&gt;&lt;/app-nav&gt;\n  &lt;app-view&gt;\n    &lt;app-sidebar&gt;&lt;/app-sidebar&gt;\n    &lt;app-content&gt;&lt;/app-content&gt;\n  &lt;/app-view&gt;\n&lt;/div&gt;</pre> <p>You may have noticed that Vue.js components are very similar to <strong>Custom Elements</strong>, which is part of the <a href=\"http://www.w3.org/wiki/WebComponents/\" target=\"_blank\" rel=\"external\">Web Components Spec</a>. In fact, Vue.js’ component syntax is loosely modeled after the spec. For example, Vue components implement the <a href=\"https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md\" target=\"_blank\" rel=\"external\">Slot API</a> and the <code>is</code> special attribute. However, there are a few key differences:</p> <ol> <li>\n<p>The Web Components Spec is still very much a work in progress, and is not natively implemented in every browser. In comparison, Vue.js components don’t require any polyfills and works consistently in all supported browsers (IE9 and above). When needed, Vue.js components can also be wrapped inside a native custom element.</p> </li> <li>\n<p>Vue.js components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and dynamic component switching with transition effects.</p> </li> </ol> <p>The component system is the foundation for building large apps with Vue.js. In addition, the Vue.js ecosystem also provides advanced tooling and various supporting libraries that can be put together to create a more “framework” like system.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/overview.html\" class=\"_attribution-link\">https://vuejs.org/guide/overview.html</a>\n  </p>\n</div>\n","guide/index":"<h1>Getting Started</h1> <p>Let’s start with a quick tour of Vue’s data binding features. If you are more interested in a high-level overview first, check out this <a href=\"http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/\" target=\"_blank\" rel=\"external\">blog post</a>.</p> <p>The easiest way to try out Vue.js is using the <a href=\"https://jsfiddle.net/yyx990803/okv0rgrk/\" target=\"_blank\" rel=\"external\">JSFiddle Hello World example</a>. Feel free to open it in another tab and follow along as we go through some basic examples. If you prefer downloading / installing from a package manager, check out the <a href=\"installation\">Installation</a> page.</p> <h3 id=\"Hello-World\">\nHello World</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"app\"&gt;\n  {{ message }}\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue.js!'\n  }\n})</pre>   <h3 id=\"Two-way-Binding\">\nTwo-way Binding</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;p&gt;{{ message }}&lt;/p&gt;\n  &lt;input v-model=\"message\"&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue.js!'\n  }\n})</pre>   <h3 id=\"Render-a-List\">\nRender a List</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;ul&gt;\n    &lt;li v-for=\"todo in todos\"&gt;\n      {{ todo.text }}\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#app',\n  data: {\n    todos: [\n      { text: 'Learn JavaScript' },\n      { text: 'Learn Vue.js' },\n      { text: 'Build Something Awesome' }\n    ]\n  }\n})</pre>   <h3 id=\"Handle-User-Input\">\nHandle User Input</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;p&gt;{{ message }}&lt;/p&gt;\n  &lt;button v-on:click=\"reverseMessage\"&gt;Reverse Message&lt;/button&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue.js!'\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})</pre>   <h3 id=\"All-Together-Now\">\nAll Together Now</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;input v-model=\"newTodo\" v-on:keyup.enter=\"addTodo\"&gt;\n  &lt;ul&gt;\n    &lt;li v-for=\"todo in todos\"&gt;\n      &lt;span&gt;{{ todo.text }}&lt;/span&gt;\n      &lt;button v-on:click=\"removeTodo($index)\"&gt;X&lt;/button&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#app',\n  data: {\n    newTodo: '',\n    todos: [\n      { text: 'Add some todos' }\n    ]\n  },\n  methods: {\n    addTodo: function () {\n      var text = this.newTodo.trim()\n      if (text) {\n        this.todos.push({ text: text })\n        this.newTodo = ''\n      }\n    },\n    removeTodo: function (index) {\n      this.todos.splice(index, 1)\n    }\n  }\n})</pre>   <p>I hope this gives you a basic idea of how Vue.js works. I’m sure you also have many questions now - read along, and we will cover them in the rest of the guide.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/\" class=\"_attribution-link\">https://vuejs.org/guide/</a>\n  </p>\n</div>\n","guide/events":"<h1>Methods and Event Handling</h1> <h2 id=\"Method-Handler\">\nMethod Handler</h2>\n<p>We can use the <code>v-on</code> directive to listen to DOM events:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"example\"&gt;\n  &lt;button v-on:click=\"greet\"&gt;Greet&lt;/button&gt;\n&lt;/div&gt;</pre> <p>We are binding a click event listener to a method named <code>greet</code>. Here’s how to define that method in our Vue instance:</p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  el: '#example',\n  data: {\n    name: 'Vue.js'\n  },\n  // define methods under the `methods` object\n  methods: {\n    greet: function (event) {\n      // `this` inside methods point to the Vue instance\n      alert('Hello ' + this.name + '!')\n      // `event` is the native DOM event\n      alert(event.target.tagName)\n    }\n  }\n})\n\n// you can invoke methods in JavaScript too\nvm.greet() // -&gt; 'Hello Vue.js!'</pre> <p>Test it yourself:</p>   <h2 id=\"Inline-Statement-Handler\">\nInline Statement Handler</h2>\n<p>Instead of binding directly to a method name, we can also use an inline JavaScript statement:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"example-2\"&gt;\n  &lt;button v-on:click=\"say('hi')\"&gt;Say Hi&lt;/button&gt;\n  &lt;button v-on:click=\"say('what')\"&gt;Say What&lt;/button&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#example-2',\n  methods: {\n    say: function (msg) {\n      alert(msg)\n    }\n  }\n})</pre> <p>Result:<br> </p>  <p>Similar to the restrictions on inline expressions, event handlers are restricted to <strong>one statement only</strong>.</p> <p>Sometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special <code>$event</code> variable:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;button v-on:click=\"say('hello!', $event)\"&gt;Submit&lt;/button&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">// ...\nmethods: {\n  say: function (msg, event) {\n    // now we have access to the native event\n    event.preventDefault()\n  }\n}</pre> <h2 id=\"Event-Modifiers\">\nEvent Modifiers</h2>\n<p>It is a very common need to call <code>event.preventDefault()</code> or <code>event.stopPropagation()</code> inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.</p> <p>To address this problem, Vue.js provides two <strong>event modifiers</strong> for <code>v-on</code>: <code>.prevent</code> and <code>.stop</code>. Recall that modifiers are directive postfixes denoted by a dot:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- the click event's propagation will be stopped --&gt;\n&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;\n\n&lt;!-- the submit event will no longer reload the page --&gt;\n&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;\n\n&lt;!-- modifiers can be chained --&gt;\n&lt;a v-on:click.stop.prevent=\"doThat\"&gt;\n\n&lt;!-- just the modifier --&gt;\n&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</pre> <p>In 1.0.16, two additional modifiers have been introduced:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- use capture mode when adding the event listener --&gt;\n&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;\n\n&lt;!-- only trigger handler if event.target is the element itself --&gt;\n&lt;!-- i.e. not from a child element --&gt;\n&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;</pre> <h2 id=\"Key-Modifiers\">\nKey Modifiers</h2>\n<p>When listening for keyboard events, we often need to check for common key codes. Vue.js also allows adding key modifiers for <code>v-on</code> when listening for key events:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- only call vm.submit() when the keyCode is 13 --&gt;\n&lt;input v-on:keyup.13=\"submit\"&gt;</pre> <p>Remembering all the keyCodes is a hassle, so Vue.js provides aliases for most commonly used keys:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- same as above --&gt;\n&lt;input v-on:keyup.enter=\"submit\"&gt;\n\n&lt;!-- also works for shorthand --&gt;\n&lt;input @keyup.enter=\"submit\"&gt;</pre> <p>Here’s the full list of key modifier aliases:</p> <ul> <li>enter</li> <li>tab</li> <li>delete</li> <li>esc</li> <li>space</li> <li>up</li> <li>down</li> <li>left</li> <li>right</li> </ul> <p><strong>1.0.8+:</strong> Single letter key aliases are also supported.</p> <p><strong>1.0.17+:</strong> You can also define custom key modifier aliases:</p> <pre class=\"highlight js\" data-language=\"js\">// enable @keyup.f1\nVue.directive('on').keyCodes.f1 = 112</pre> <h2 id=\"Why-Listeners-in-HTML\">\nWhy Listeners in HTML?</h2>\n<p>You might be concerned that this whole event listening approach violates the good old rules about “separation of concern”. Rest assured - since all Vue.js handler functions and expressions are strictly bound to the ViewModel that’s handling the current View, it won’t cause any maintenance difficulty. In fact, there are several benefits in using <code>v-on</code>:</p> <ol> <li>\n<p>It makes it easier to locate the handler function implementations within your JS code by simply skimming the HTML template.</p> </li> <li>\n<p>Since you don’t have to manually attach event listeners in JS, your ViewModel code can be pure logic and DOM-free. This makes it easier to test.</p> </li> <li>\n<p>When a ViewModel is destroyed, all event listeners are automatically removed. You don’t need to worry about cleaning it up yourself.</p> </li> </ol><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/events.html\" class=\"_attribution-link\">https://vuejs.org/guide/events.html</a>\n  </p>\n</div>\n","guide/syntax":"<h1>Data Binding Syntax</h1> <p>Vue.js uses a DOM-based templating implementation. This means that all Vue.js templates are essentially valid, parsable HTML enhanced with some special attributes. Keep that in mind, since this makes Vue templates fundamentally different from string-based templates.</p> <h2 id=\"Interpolations\">\nInterpolations</h2>\n<h3 id=\"Text\">\nText</h3>\n<p>The most basic form of data binding is text interpolation using the “Mustache” syntax (double curly braces):</p> <pre class=\"highlight html\" data-language=\"html\">&lt;span&gt;Message: {{ msg }}&lt;/span&gt;</pre> <p>The mustache tag will be replaced with the value of the <code>msg</code> property on the corresponding data object. It will also be updated whenever the data object’s <code>msg</code> property changes.</p> <p>You can also perform one-time interpolations that do not update on data change:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;span&gt;This will never change: {{* msg }}&lt;/span&gt;</pre> <h3 id=\"Raw-HTML\">\nRaw HTML</h3>\n<p>The double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use triple mustaches:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div&gt;{{{ raw_html }}}&lt;/div&gt;</pre> <p>The contents are inserted as plain HTML - data bindings are ignored. If you need to reuse template pieces, you should use <a href=\"../api/index#partial\">partials</a>.</p> <p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\" target=\"_blank\" rel=\"external\">XSS attacks</a>. Only use HTML interpolation on trusted content and <strong>never</strong> on user-provided content.</p> <h3 id=\"Attributes\">\nAttributes</h3>\n<p>Mustaches can also be used inside HTML attributes:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"item-{{ id }}\"&gt;&lt;/div&gt;</pre> <p>Note that attribute interpolations are disallowed in Vue.js directives and special attributes. Don’t worry, Vue.js will raise warnings for you when mustaches are used in wrong places.</p> <h2 id=\"Binding-Expressions\">\nBinding Expressions</h2>\n<p>The text we put inside mustache tags are called <strong>binding expressions</strong>. In Vue.js, a binding expression consists of a single JavaScript expression optionally followed by one or more filters.</p> <h3 id=\"JavaScript-Expressions\">\nJavaScript Expressions</h3>\n<p>So far we’ve only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside data bindings:</p> <pre class=\"highlight html\" data-language=\"html\">{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}</pre> <p>These expressions will be evaluated in the data scope of the owner Vue instance. One restriction is that each binding can only contain <strong>one single expression</strong>, so the following will <strong>NOT</strong> work:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- this is a statement, not an expression: --&gt;\n{{ var a = 1 }}\n\n&lt;!-- flow control won't work either, use ternary expressions --&gt;\n{{ if (ok) { return message } }}</pre> <h3 id=\"Filters\">\nFilters</h3>\n<p>Vue.js allows you to append optional “filters” to the end of an expression, denoted by the “pipe” symbol:</p> <pre class=\"highlight html\" data-language=\"html\">{{ message | capitalize }}</pre> <p>Here we are “piping” the value of the <code>message</code> expression through the built-in <code>capitalize</code> filter, which is in fact just a JavaScript function that returns the capitalized value. Vue.js provides a number of built-in filters, and we will talk about how to write your own filters later.</p> <p>Note that the pipe syntax is not part of JavaScript syntax, therefore you cannot mix filters inside expressions; you can only append them at the end of an expression.</p> <p>Filters can be chained:</p> <pre class=\"highlight html\" data-language=\"html\">{{ message | filterA | filterB }}</pre> <p>Filters can also take arguments:</p> <pre class=\"highlight html\" data-language=\"html\">{{ message | filterA 'arg1' arg2 }}</pre> <p>The filter function always receives the expression’s value as the first argument. Quoted arguments are interpreted as plain string, while un-quoted ones will be evaluated as expressions. Here, the plain string <code>'arg1'</code> will be passed into the filter as the second argument, and the value of expression <code>arg2</code> will be evaluated and passed in as the third argument.</p> <h2 id=\"Directives\">\nDirectives</h2>\n<p>Directives are special attributes with the <code>v-</code> prefix. Directive attribute values are expected to be <strong>binding expressions</strong>, so the rules about JavaScript expressions and filters mentioned above apply here as well. A directive’s job is to reactively apply special behavior to the DOM when the value of its expression changes. Let’s review the example we saw in the introduction:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;p v-if=\"greeting\"&gt;Hello!&lt;/p&gt;</pre> <p>Here, the <code>v-if</code> directive would remove/insert the <code>&lt;p&gt;</code> element based on the truthiness of the value of the expression <code>greeting</code>.</p> <h3 id=\"Arguments\">\nArguments</h3>\n<p>Some directives can take an “argument”, denoted by a colon after the directive name. For example, the <code>v-bind</code> directive is used to reactively update an HTML attribute:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;</pre> <p>Here <code>href</code> is the argument, which tells the <code>v-bind</code> directive to bind the element’s <code>href</code> attribute to the value of the expression <code>url</code>. You may have noticed this achieves the same result as an attribute interpolation using <code>href=\"{{url}}\"</code>: that is correct, and in fact, attribute interpolations are translated into <code>v-bind</code> bindings internally.</p> <p>Another example is the <code>v-on</code> directive, which listens to DOM events:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;a v-on:click=\"doSomething\"&gt;</pre> <p>Here the argument is the event name to listen to. We will talk about event handling in more detail too.</p> <h3 id=\"Modifiers\">\nModifiers</h3>\n<p>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the <code>.literal</code> modifier tells the directive to interpret its attribute value as a literal string rather than an expression:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;a v-bind:href.literal=\"/a/b/c\"&gt;&lt;/a&gt;</pre> <p>Of course, this seems pointless because we can just do <code>href=\"/a/b/c\"</code> instead of using a directive. The example here is just for demonstrating the syntax. We will see more practical uses of modifiers later.</p> <h2 id=\"Shorthands\">\nShorthands</h2>\n<p>The <code>v-</code> prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the <code>v-</code> prefix becomes less important when you are building an <a href=\"https://en.wikipedia.org/wiki/Single-page_application\" target=\"_blank\" rel=\"external\">SPA</a> where Vue.js manages every template. Therefore, Vue.js provides special shorthands for two of the most often used directives, <code>v-bind</code> and <code>v-on</code>:</p> <h3 id=\"v-bind-Shorthand\">\n<code>v-bind</code> Shorthand</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;!-- full syntax --&gt;\n&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;\n\n&lt;!-- shorthand --&gt;\n&lt;a :href=\"url\"&gt;&lt;/a&gt;\n\nor\n\n&lt;!-- full syntax --&gt;\n&lt;button v-bind:disabled=\"someDynamicCondition\"&gt;Button&lt;/button&gt;\n\n&lt;!-- shorthand --&gt;\n&lt;button :disabled=\"someDynamicCondition\"&gt;Button&lt;/button&gt;</pre> <h3 id=\"v-on-Shorthand\">\n<code>v-on</code> Shorthand</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;!-- full syntax --&gt;\n&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;\n\n&lt;!-- shorthand --&gt;\n&lt;a @click=\"doSomething\"&gt;&lt;/a&gt;</pre> <p>They may look a bit different from “valid” HTML, but all Vue.js supported browsers can parse it correctly, and they do not appear in the final rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more about its usage later.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/syntax.html\" class=\"_attribution-link\">https://vuejs.org/guide/syntax.html</a>\n  </p>\n</div>\n","guide/reactivity":"<h1>Reactivity in Depth</h1> <p>We’ve covered most of the basics - now it’s time to take a deep dive! One of Vue.js’ most distinct features is the unobtrusive reactive system - models are just plain JavaScript objects, modify it and the view updates. It makes state management very simple and intuitive, but it’s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue.js’ reactivity system.</p> <h2 id=\"How-Changes-Are-Tracked\">\nHow Changes Are Tracked</h2>\n<p>When you pass a plain JavaScript object to a Vue instance as its <code>data</code> option, Vue.js will walk through all of its properties and convert them to getter/setters using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\" rel=\"external\">Object.defineProperty</a>. This is an ES5-only and un-shimmable feature, which is why Vue.js doesn’t support IE8 and below.</p> <p>The getter/setters are invisible to the user, but under the hood they enable Vue.js to perform dependency-tracking and change-notification when properties are accessed or modified. One caveat is that browser consoles format getter/setters differently when converted data objects are logged, so make sure to use the <code>vm.$log()</code> instance method for more inspection-friendly output.</p> <p>For every directive / data binding in the template, there will be a corresponding <strong>watcher</strong> object, which records any properties “touched” during its evaluation as dependencies. Later on when a dependency’s setter is called, it triggers the watcher to re-evaluate, and in turn causes its associated directive to perform DOM updates.</p> <p><img src=\"https://vuejs.org/images/data.png\" alt=\"data\"></p> <h2 id=\"Change-Detection-Caveats\">\nChange Detection Caveats</h2>\n<p>Due to the limitation of ES5, Vue.js <strong>cannot detect property addition or deletion</strong>. Since Vue.js performs the getter/setter conversion process during instance initialization, a property must be present in the <code>data</code> object in order for Vue.js to convert it and make it reactive. For example:</p> <pre class=\"highlight js\" data-language=\"js\">var data = { a: 1 }\nvar vm = new Vue({\n  data: data\n})\n// `vm.a` and `data.a` are now reactive\n\nvm.b = 2\n// `vm.b` is NOT reactive\n\ndata.b = 2\n// `data.b` is NOT reactive</pre> <p>However, there are ways to <strong>add a property and make it reactive</strong> after an instance has been created.</p> <p>For Vue instances, you can use the <code>$set(path, value)</code> instance method:</p> <pre class=\"highlight js\" data-language=\"js\">vm.$set('b', 2)\n// `vm.b` and `data.b` are now reactive</pre> <p>For plain data objects, you can use the global <code>Vue.set(object, key, value)</code> method:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.set(data, 'c', 3)\n// `vm.c` and `data.c` are now reactive</pre> <p>Sometimes you may want to assign a number of properties on to an existing object, for example using <code>Object.assign()</code> or <code>_.extend()</code>. However, new properties added to the object will not trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin object:</p> <pre class=\"highlight js\" data-language=\"js\">// instead of `Object.assign(this.someObject, { a: 1, b: 2 })`\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })</pre> <p>There are also a few Array-related caveats, which were <a href=\"list#Caveats\">discussed earlier in the list rendering section</a>.</p> <h2 id=\"Initialize-Your-Data\">\nInitialize Your Data</h2>\n<p>Although Vue.js provides the API to dynamically add reactive properties on the fly, it is recommended to declare all reactive properties upfront in the <code>data</code> option.</p> <p>Instead of this:</p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  template: '&lt;div&gt;{{msg}}&lt;/div&gt;'\n})\n// add `msg` later\nvm.$set('msg', 'Hello!')</pre> <p>Prefer this:</p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  data: {\n    // declare msg with an empty value\n    msg: ''\n  },\n  template: '&lt;div&gt;{{msg}}&lt;/div&gt;'\n})\n// set `msg` later\nvm.msg = 'Hello!'</pre> <p>There are two reasons behind this pattern:</p> <ol> <li>\n<p>The <code>data</code> object is like the schema for your component’s state. Declaring all reactive properties upfront makes the component code easier to understand and reason about.</p> </li> <li>\n<p>Adding a top level reactive property on a Vue instance will force all the watchers in its scope to re-evaluate, because it didn’t exist before and no watcher could have tracked it as a dependency. The performance is usually acceptable (essentially the same as Angular’s dirty checking), but can be avoided when you initialize the data properly.</p> </li> </ol> <h2 id=\"Async-Update-Queue\">\nAsync Update Queue</h2>\n<p>By default, Vue.js performs DOM updates <strong>asynchronously</strong>. Whenever a data change is observed, Vue will open a queue and buffer all the data changes that happens in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. Then, in the next event loop “tick”, Vue flushes the queue and performs only the necessary DOM updates. Internally Vue uses <code>MutationObserver</code> if available for the asynchronous queuing and falls back to <code>setTimeout(fn, 0)</code>.</p> <p>For example, when you set <code>vm.someData = 'new value'</code>, the DOM will not update immediately. It will update in the next “tick”, when the queue is flushed. Most of the time we don’t need to care about this, but it can be tricky when you want to do something that depends on the post-update DOM state. Although Vue.js generally encourages developers to think in a “data-driven” fashion and avoid touching the DOM directly, sometimes it might be necessary to get your hands dirty. In order to wait until Vue.js has finished updating the DOM after a data change, you can use <code>Vue.nextTick(callback)</code> immediately after the data is changed. The callback will be called after the DOM has been updated. For example:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"example\"&gt;{{msg}}&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  el: '#example',\n  data: {\n    msg: '123'\n  }\n})\nvm.msg = 'new message' // change data\nvm.$el.textContent === 'new message' // false\nVue.nextTick(function () {\n  vm.$el.textContent === 'new message' // true\n})</pre> <p>There is also the <code>vm.$nextTick()</code> instance method, which is especially handy inside components, because it doesn’t need global <code>Vue</code> and its callback’s <code>this</code> context will be automatically bound to the current Vue instance:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.component('example', {\n  template: '&lt;span&gt;{{msg}}&lt;/span&gt;',\n  data: function () {\n    return {\n      msg: 'not updated'\n    }\n  },\n  methods: {\n    updateMessage: function () {\n      this.msg = 'updated'\n      console.log(this.$el.textContent) // =&gt; 'not updated'\n      this.$nextTick(function () {\n        console.log(this.$el.textContent) // =&gt; 'updated'\n      })\n    }\n  }\n})</pre> <h2 id=\"Inside-Computed-Properties\">\nInside Computed Properties</h2>\n<p>It should be noted that Vue.js computed properties are <strong>not</strong> simple getters. Each computed property keeps track of its own reactive dependencies. When a computed property is evaluated, Vue.js updates its dependency list and caches the result value. The cached value is only invalidated when one of the tracked dependencies have changed. Therefore, as long as the dependencies did not change, accessing the computed property will directly return the cached value instead of calling the getter.</p> <p>Why do we need caching? Imagine we have an expensive computed property <strong>A</strong>, which requires looping through a huge Array and doing a lot of computations. Then, we may have other computed properties that in turn depend on <strong>A</strong>. Without caching, we would be calling <strong>A</strong>’s getter many more times than necessary!</p> <p>Because of computed property caching, the getter function is not always called when you access a computed property. Consider the following example:</p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  data: {\n    msg: 'hi'\n  },\n  computed: {\n    example: function () {\n      return Date.now() + this.msg\n    }\n  }\n})</pre> <p>The computed property <code>example</code> has only one dependency: <code>vm.msg</code>. <code>Date.now()</code> is <strong>not</strong> a reactive dependency, because it has nothing to do with Vue’s data observation system. Therefore, when you programmatically access <code>vm.example</code>, you will find the timestamp to remain the same unless <code>vm.msg</code> triggers a re-evaluation.</p> <p>In some use cases you may want to preserve the simple getter-like behavior, where every time you access <code>vm.example</code> it simply calls the getter again. You can do that by turning off caching for a specific computed property:</p> <pre class=\"highlight js\" data-language=\"js\">computed: {\n  example: {\n    cache: false,\n    get: function () {\n      return Date.now() + this.msg\n    }\n  }\n}</pre> <p>Now, every time you access <code>vm.example</code>, the timestamp will be up-to-date. <strong>However, note this only affects programmatic access inside JavaScript; data-bindings are still dependency-driven.</strong> When you bind to a computed property in the template as <code>{{example}}</code>, the DOM will only be updated when a reactive dependency has changed.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/reactivity.html\" class=\"_attribution-link\">https://vuejs.org/guide/reactivity.html</a>\n  </p>\n</div>\n","guide/list":"<h1>List Rendering</h1> <h2 id=\"v-for\">\nv-for</h2>\n<p>We can use the <code>v-for</code> directive to render a list of items based on an Array. The <code>v-for</code> directive requires a special syntax in the form of <code>item in items</code>, where <code>items</code> is the source data Array and <code>item</code> is an <strong>alias</strong> for the Array element being iterated on:</p> <p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">&lt;ul id=\"example-1\"&gt;\n  &lt;li v-for=\"item in items\"&gt;\n    {{ item.message }}\n  &lt;/li&gt;\n&lt;/ul&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">var example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})</pre> <p><strong>Result:</strong></p>   <p>Inside <code>v-for</code> blocks we have full access to parent scope properties, plus a special variable <code>$index</code> which, as you probably have guessed, is the Array index for the current item:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;ul id=\"example-2\"&gt;\n  &lt;li v-for=\"item in items\"&gt;\n    {{ parentMessage }} - {{ $index }} - {{ item.message }}\n  &lt;/li&gt;\n&lt;/ul&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">var example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})</pre> <p><strong>Result:</strong></p>   <p>Alternatively, you can also specify an alias for the index (or the key if <code>v-for</code> is used on an Object):</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-for=\"(index, item) in items\"&gt;\n  {{ index }} {{ item.message }}\n&lt;/div&gt;</pre> <p>Starting in 1.0.17 you can also use <code>of</code> as the delimiter instead of <code>in</code>, so that it is closer to JavaScript syntax for iterators:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-for=\"item of items\"&gt;&lt;/div&gt;</pre> <h2 id=\"Template-v-for\">\nTemplate v-for</h2>\n<p>Similar to template <code>v-if</code>, you can also use a <code>&lt;template&gt;</code> tag with <code>v-for</code> to render a block of multiple elements. For example:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;ul&gt;\n  &lt;template v-for=\"item in items\"&gt;\n    &lt;li&gt;{{ item.msg }}&lt;/li&gt;\n    &lt;li class=\"divider\"&gt;&lt;/li&gt;\n  &lt;/template&gt;\n&lt;/ul&gt;</pre> <h2 id=\"Array-Change-Detection\">\nArray Change Detection</h2>\n<h3 id=\"Mutation-Methods\">\nMutation Methods</h3>\n<p>Vue.js wraps an observed Array’s mutation methods so they will also trigger View updates. The wrapped methods are:</p> <ul> <li><code>push()</code></li> <li><code>pop()</code></li> <li><code>shift()</code></li> <li><code>unshift()</code></li> <li><code>splice()</code></li> <li><code>sort()</code></li> <li><code>reverse()</code></li> </ul> <p>You can open the console and play with the previous examples’ <code>items</code> array by calling its mutation methods. For example: <code>example1.items.push({ message: 'Baz' })</code>.</p> <h3 id=\"Replacing-an-Array\">\nReplacing an Array</h3>\n<p>Mutation methods, as the name suggests, mutate the original Array they are called on. In comparison, there are also non-mutating methods, e.g. <code>filter()</code>, <code>concat()</code> and <code>slice()</code>, which do not mutate the original Array but <strong>always return a new Array</strong>. When working with non-mutating methods, you can just replace the old Array with the new one:</p> <pre class=\"highlight js\" data-language=\"js\">example1.items = example1.items.filter(function (item) {\n  return item.message.match(/Foo/)\n})</pre> <p>You might think this will cause Vue.js to throw away the existing DOM and re-render the entire list - luckily that is not the case. Vue.js implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</p> <h3 id=\"track-by\">\ntrack-by</h3>\n<p>In some cases, you might need to replace the Array with completely new objects - e.g. ones created from an API call. Since by default <code>v-for</code> determines the reusability of existing scopes and DOM elements by tracking the identity of its data object, this could cause the entire list to be re-rendered. However, if each of your data objects has a unique id property, then you can use a <code>track-by</code> special attribute to give Vue.js a hint so that it can reuse existing instances as much as possible.</p> <p>For example, if your data looks like this:</p> <pre class=\"highlight js\" data-language=\"js\">{\n  items: [\n    { _uid: '88f869d', ... },\n    { _uid: '7496c10', ... }\n  ]\n}</pre> <p>Then you can give the hint like this:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-for=\"item in items\" track-by=\"_uid\"&gt;\n  &lt;!-- content --&gt;\n&lt;/div&gt;</pre> <p>Later on, when you replace the <code>items</code> array and Vue.js encounters a new object with <code>_uid: '88f869d'</code>, it knows it can reuse the existing scope and DOM elements associated with the same <code>_uid</code>.</p> <h3 id=\"track-by-index\">\ntrack-by $index</h3>\n<p>If you don’t have a unique key to track by, you can also use <code>track-by=\"$index\"</code>, which will force <code>v-for</code> into in-place update mode: fragments are no longer moved around, they simply get flushed with the new value at the corresponding index. This mode can also handle duplicate values in the source array.</p> <p>This can make Array replacement extremely efficient, but it comes at a trade-off. Because DOM nodes are no longer moved to reflect the change in order, temporary state like DOM input values and component private state can become out of sync. So, be careful when using <code>track-by=\"$index\"</code> if the <code>v-for</code> block contains form input elements or child components.</p> <h3 id=\"Caveats\">\nCaveats</h3>\n<p>Due to limitations of JavaScript, Vue.js <strong>cannot</strong> detect the following changes to an Array:</p> <ol> <li>When you directly set an item with the index, e.g. <code>vm.items[0] = {}</code>;</li> <li>When you modify the length of the Array, e.g. <code>vm.items.length = 0</code>.</li> </ol> <p>To deal with caveat (1), Vue.js augments observed Arrays with a <code>$set()</code> method:</p> <pre class=\"highlight js\" data-language=\"js\">// same as `example1.items[0] = ...` but triggers view update\nexample1.items.$set(0, { childMsg: 'Changed!'})</pre> <p>To deal with caveat (2), just replace <code>items</code> with an empty array instead.</p> <p>In addition to <code>$set()</code>, Vue.js also augments Arrays with a convenience method <code>$remove()</code>, which searches for and removes an item from target Array by calling <code>splice()</code> internally. So instead of:</p> <pre class=\"highlight js\" data-language=\"js\">var index = this.items.indexOf(item)\nif (index !== -1) {\n  this.items.splice(index, 1)\n}</pre> <p>You can just do:</p> <pre class=\"highlight js\" data-language=\"js\">this.items.$remove(item)</pre> <h4 id=\"Using-Object-freeze\">\nUsing <code>Object.freeze()</code>\n</h4>\n<p>When iterating over an array of objects frozen with <code>Object.freeze()</code>, you need to explicitly use a <code>track-by</code> key. A warning will be displayed in this scenario when Vue.js is unable to track objects automatically.</p> <h2 id=\"Object-v-for\">\nObject v-for</h2>\n<p>You can also use <code>v-for</code> to iterate through the properties of an Object. In addition to <code>$index</code>, each scope will have access to another special property <code>$key</code>.</p> <pre class=\"highlight html\" data-language=\"html\">&lt;ul id=\"repeat-object\" class=\"demo\"&gt;\n  &lt;li v-for=\"value in object\"&gt;\n    {{ $key }} : {{ value }}\n  &lt;/li&gt;\n&lt;/ul&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#repeat-object',\n  data: {\n    object: {\n      FirstName: 'John',\n      LastName: 'Doe',\n      Age: 30\n    }\n  }\n})</pre> <p><strong>Result:</strong></p>   <p>You can also provide an alias for the key:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-for=\"(key, val) in object\"&gt;\n  {{ key }} {{ val }}\n&lt;/div&gt;</pre> <p class=\"tip\">When iterating over an Object, the order is based on the key enumeration order of <code>Object.keys()</code>, which is <strong>not</strong> guaranteed to be consistent in all JavaScript engine implementations.</p> <h2 id=\"Range-v-for\">\nRange v-for</h2>\n<p><code>v-for</code> can also take an integer Number. In this case it will repeat the template that many times.</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div&gt;\n  &lt;span v-for=\"n in 10\"&gt;{{ n }} &lt;/span&gt;\n&lt;/div&gt;</pre> <p>Result:</p>   <h2 id=\"Displaying-Filtered-Sorted-Results\">\nDisplaying Filtered/Sorted Results</h2>\n<p>Sometimes we only need to display a filtered or sorted version of the Array without actually mutating or resetting the original data. There are two options to achieve this:</p> <ol> <li>Create a computed property that returns the filtered or sorted Array;</li> <li>Use the built-in <code>filterBy</code> and <code>orderBy</code> filters.</li> </ol> <p>A computed property would give you finer-grained control and more flexibility since it’s full JavaScript; but the filters can be more convenient for common use cases. For detailed usage of the Array filters, check out their <a href=\"../api/index#filterBy\">documentation</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/list.html\" class=\"_attribution-link\">https://vuejs.org/guide/list.html</a>\n  </p>\n</div>\n","guide/forms":"<h1>Form Input Bindings</h1> <h2 id=\"Basics-Usage\">\nBasics Usage</h2>\n<p>You can use the <code>v-model</code> directive to create two-way data bindings on form input elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, <code>v-model</code> is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.</p> <h3 id=\"Text\">\nText</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;span&gt;Message is: {{ message }}&lt;/span&gt;\n&lt;br&gt;\n&lt;input type=\"text\" v-model=\"message\" placeholder=\"edit me\"&gt;</pre>   <h3 id=\"Checkbox\">\nCheckbox</h3>\n<p>Single checkbox, boolean value:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt;\n&lt;label for=\"checkbox\"&gt;{{ checked }}&lt;/label&gt;</pre>   <p>Mutiple checkboxes, bound to the same Array:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt;\n&lt;label for=\"jack\"&gt;Jack&lt;/label&gt;\n&lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt;\n&lt;label for=\"john\"&gt;John&lt;/label&gt;\n&lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt;\n&lt;label for=\"mike\"&gt;Mike&lt;/label&gt;\n&lt;br&gt;\n&lt;span&gt;Checked names: {{ checkedNames | json }}&lt;/span&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '...',\n  data: {\n    checkedNames: []\n  }\n})</pre>   <h3 id=\"Radio\">\nRadio</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"&gt;\n&lt;label for=\"one\"&gt;One&lt;/label&gt;\n&lt;br&gt;\n&lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"&gt;\n&lt;label for=\"two\"&gt;Two&lt;/label&gt;\n&lt;br&gt;\n&lt;span&gt;Picked: {{ picked }}&lt;/span&gt;</pre>   <h3 id=\"Select\">\nSelect</h3>\n<p>Single select:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;select v-model=\"selected\"&gt;\n  &lt;option selected&gt;A&lt;/option&gt;\n  &lt;option&gt;B&lt;/option&gt;\n  &lt;option&gt;C&lt;/option&gt;\n&lt;/select&gt;\n&lt;span&gt;Selected: {{ selected }}&lt;/span&gt;</pre>   <p>Multiple select (bound to Array):</p> <pre class=\"highlight html\" data-language=\"html\">&lt;select v-model=\"selected\" multiple&gt;\n  &lt;option selected&gt;A&lt;/option&gt;\n  &lt;option&gt;B&lt;/option&gt;\n  &lt;option&gt;C&lt;/option&gt;\n&lt;/select&gt;\n&lt;br&gt;\n&lt;span&gt;Selected: {{ selected | json }}&lt;/span&gt;</pre>   <p>Dynamic options rendered with <code>v-for</code>:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;select v-model=\"selected\"&gt;\n  &lt;option v-for=\"option in options\" v-bind:value=\"option.value\"&gt;\n    {{ option.text }}\n  &lt;/option&gt;\n&lt;/select&gt;\n&lt;span&gt;Selected: {{ selected }}&lt;/span&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '...',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})</pre>   <h2 id=\"Value-Bindings\">\nValue Bindings</h2>\n<p>For radio, checkbox and select options, the <code>v-model</code> binding values are usually static strings (or booleans for checkbox):</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- `picked` is a string \"a\" when checked --&gt;\n&lt;input type=\"radio\" v-model=\"picked\" value=\"a\"&gt;\n\n&lt;!-- `toggle` is either true or false --&gt;\n&lt;input type=\"checkbox\" v-model=\"toggle\"&gt;\n\n&lt;!-- `selected` is a string \"abc\" when selected --&gt;\n&lt;select v-model=\"selected\"&gt;\n  &lt;option value=\"abc\"&gt;ABC&lt;/option&gt;\n&lt;/select&gt;</pre> <p>But sometimes we may want to bind the value to a dynamic property on the Vue instance. We can use <code>v-bind</code> to achieve that. In addition, using <code>v-bind</code> allows us to bind the input value to non-string values.</p> <h3 id=\"Checkbox-1\">\nCheckbox</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;input  type=\"checkbox\"  v-model=\"toggle\"  v-bind:true-value=\"a\"  v-bind:false-value=\"b\"&gt;\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  v-bind:true-value=\"a\"\n  v-bind:false-value=\"b\"&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">// when checked:\nvm.toggle === vm.a\n// when unchecked:\nvm.toggle === vm.b</pre> <h3 id=\"Radio-1\">\nRadio</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\"&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">// when checked:\nvm.pick === vm.a</pre> <h3 id=\"Select-Options\">\nSelect Options</h3>\n<pre class=\"highlight html\" data-language=\"html\">&lt;select v-model=\"selected\"&gt;\n  &lt;!-- inline object literal --&gt;\n  &lt;option v-bind:value=\"{ number: 123 }\"&gt;123&lt;/option&gt;\n&lt;/select&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">// when selected:\ntypeof vm.selected // -&gt; 'object'\nvm.selected.number // -&gt; 123</pre> <h2 id=\"Param-Attributes\">\nParam Attributes</h2>\n<h3 id=\"lazy\">\nlazy</h3>\n<p>By default, <code>v-model</code> syncs the input with the data after each <code>input</code> event. You can add a <code>lazy</code> attribute to change the behavior to sync after <code>change</code> events:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- synced after \"change\" instead of \"input\" --&gt;\n&lt;input v-model=\"msg\" lazy&gt;</pre> <h3 id=\"number\">\nnumber</h3>\n<p>If you want user input to be automatically persisted as numbers, you can add a <code>number</code> attribute to your <code>v-model</code> managed inputs:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;input v-model=\"age\" number&gt;</pre> <h3 id=\"debounce\">\ndebounce</h3>\n<p>The <code>debounce</code> param allows you to set a minimum delay after each keystroke before the input’s value is synced to the model. This can be useful when you are performing expensive operations on each update, for example making an Ajax request for type-ahead autocompletion.</p> <pre class=\"highlight html\" data-language=\"html\">&lt;input v-model=\"msg\" debounce=\"500\"&gt;</pre>   <p>Note that the <code>debounce</code> param does not debounce the user’s input events: it debounces the “write” operation to the underlying data. Therefore you should use <code>vm.$watch()</code> to react to data changes when using <code>debounce</code>. For debouncing real DOM events you should use the <a href=\"../api/index#debounce\">debounce filter</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/forms.html\" class=\"_attribution-link\">https://vuejs.org/guide/forms.html</a>\n  </p>\n</div>\n","guide/join":"<h1>Join the Vue Community!</h1> <h2 id=\"Join-the-Vue-js-Community\">\nJoin the Vue.js Community!</h2>\n<p>The vibrant community around Vue.js is continually growing. Nevertheless, helpful hands are always welcome. In fact, a growing community is the best sign of a healthy OSS project worth putting any effort into, even if it is as the user of the software. </p> <p>If you would like to also be a part of the Vue.js community, this page was meant to support your endeavors. Have a look at the resources listed below to get some orientation around the sailing ship of Vue.js and…</p> <p>….welcome aboard!</p> <h2 id=\"Resources-You-Should-Know-About\">\nResources You Should Know About!</h2>\n<h3 id=\"The-Community\">\nThe Community</h3>\n<ul> <li>\n<a href=\"http://forum.vuejs.org/\" target=\"_blank\" rel=\"external\">The Forum</a> - THE best place to ask questions and get answers about Vue.js and its components.</li> <li>\n<a href=\"https://gitter.im/vuejs/vue\" target=\"_blank\" rel=\"external\">Gitter Channel</a> - A place for devs to meet and chat. You can ask questions here, but the forum is the better platform, since the discussions are threaded.</li> <li>\n<a href=\"https://github.com/vuejs\" target=\"_blank\" rel=\"external\">Github</a> - Report bugs or fork repositories to offer pull requests. Any contribution is greatly appreciated! </li> </ul> <h3 id=\"Third-Party-Contributions\">\nThird Party Contributions</h3>\n<ul> <li>\n<a href=\"https://github.com/vuejs/awesome-vue\" target=\"_blank\" rel=\"external\">The Awesome Vue Page</a> - See what other awesome resources have been published by other awesome people.</li> <li>\n<a href=\"http://forum.vuejs.org/category/15/show-tell\" target=\"_blank\" rel=\"external\">The “Show and Tell” Subforum</a> - Another great place to check out what others have built with and for the growing Vue ecosystem.</li> </ul> <h3 id=\"Contributing-to-Vue\">\nContributing to Vue</h3>\n<ul> <li>\n<p><a href=\"https://github.com/vuejs/vue/blob/dev/CONTRIBUTING.md\" target=\"_blank\" rel=\"external\">The rules to contribute</a> - As with any community, there has to be rules, in order to ensure everyone is doing the right things the right way.</p> </li> <li>\n<p>The Main Components of Vue</p> <ul> <li>\n<a href=\"https://github.com/vuejs/vue\" target=\"_blank\" rel=\"external\">Vue</a> - The core repository.</li> <li>\n<a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"external\">Vuex</a> - A Flux-inspired Application Architecture for Vue.js.</li> <li>\n<a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"external\">Vue-router</a> - A routing system for SPAs with Vue.js.</li> <li>\n<a href=\"https://github.com/vuejs/vue-resource\" target=\"_blank\" rel=\"external\">Vue-resource</a> - A plugin, which provides services for making web requests and to handle responses using XMLHttpRequests or JSONP. </li> </ul> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/join.html\" class=\"_attribution-link\">https://vuejs.org/guide/join.html</a>\n  </p>\n</div>\n","guide/transitions":"<h1>Transitions</h1> <p>With Vue.js’ transition system you can apply automatic transition effects when elements are inserted into or removed from the DOM. Vue.js will automatically add/remove CSS classes at appropriate times to trigger CSS transitions or animations for you, and you can also provide JavaScript hook functions to perform custom DOM manipulations during the transition.</p> <p>To apply transition effects, you need to use the special <code>transition</code> attribute on the target element:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-if=\"show\" transition=\"my-transition\"&gt;&lt;/div&gt;</pre> <p>The <code>transition</code> attribute can be used together with:</p> <ul> <li><code>v-if</code></li> <li><code>v-show</code></li> <li>\n<code>v-for</code> (triggered for insertion and removal only, for animating changes of order<br><a href=\"https://github.com/vuejs/vue-animated-list\" target=\"_blank\" rel=\"external\">use vue-animated-list plugin</a>)</li> <li>Dynamic components (introduced in the <a href=\"components#Dynamic-Components\">next section</a>)</li> <li>On a component root node, and triggered via Vue instance DOM methods, e.g. <code>vm.$appendTo(el)</code>.</li> </ul> <p>When an element with transition is inserted or removed, Vue will:</p> <ol> <li>\n<p>Try to find a JavaScript transition hooks object registered either through <code>Vue.transition(id, hooks)</code> or passed in with the <code>transitions</code> option, using the id <code>\"my-transition\"</code>. If it finds it, it will call the appropriate hooks at different stages of the transition.</p> </li> <li>\n<p>Automatically sniff whether the target element has CSS transitions or CSS animations applied, and add/remove the CSS classes at the appropriate times.</p> </li> <li>\n<p>If no JavaScript hooks are provided and no CSS transitions/animations are detected, the DOM operation (insertion/removal) is executed immediately on next frame.</p> </li> </ol> <h2 id=\"CSS-Transitions\">\nCSS Transitions</h2>\n<h3 id=\"Example\">\nExample</h3>\n<p>A typical CSS transition looks like this:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-if=\"show\" transition=\"expand\"&gt;hello&lt;/div&gt;</pre> <p>You also need to define CSS rules for <code>.expand-transition</code>, <code>.expand-enter</code> and <code>.expand-leave</code> classes:</p> <pre class=\"highlight css\" data-language=\"css\">/* always present */\n.expand-transition {\n  transition: all .3s ease;\n  height: 30px;\n  padding: 10px;\n  background-color: #eee;\n  overflow: hidden;\n}\n\n/* .expand-enter defines the starting state for entering */\n/* .expand-leave defines the ending state for leaving */\n.expand-enter, .expand-leave {\n  height: 0;\n  padding: 0 10px;\n  opacity: 0;\n}</pre> <p>You can achieve different transitions on the same element by using dynamic binding:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-if=\"show\" :transition=\"transitionName\"&gt;hello&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '...',\n  data: {\n    show: false,\n    transitionName: 'fade'\n  }\n})</pre> <p>In addition, you can provide JavaScript hooks:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.transition('expand', {\n\n  beforeEnter: function (el) {\n    el.textContent = 'beforeEnter'\n  },\n  enter: function (el) {\n    el.textContent = 'enter'\n  },\n  afterEnter: function (el) {\n    el.textContent = 'afterEnter'\n  },\n  enterCancelled: function (el) {\n    // handle cancellation\n  },\n\n  beforeLeave: function (el) {\n    el.textContent = 'beforeLeave'\n  },\n  leave: function (el) {\n    el.textContent = 'leave'\n  },\n  afterLeave: function (el) {\n    el.textContent = 'afterLeave'\n  },\n  leaveCancelled: function (el) {\n    // handle cancellation\n  }\n})</pre> <div id=\"demo\"> <div v-if=\"show\" transition=\"expand\">hello</div> <button>Toggle</button> </div>   <h3 id=\"Transition-CSS-Classes\">\nTransition CSS Classes</h3>\n<p>The classes being added and toggled are based on the value of the <code>transition</code> attribute. In the case of <code>transition=\"fade\"</code>, three CSS classes are involved:</p> <ol> <li>\n<p>The class <code>.fade-transition</code> will be always present on the element.</p> </li> <li>\n<p><code>.fade-enter</code> defines the starting state of an entering transition. It is applied for a single frame and then immediately removed.</p> </li> <li>\n<p><code>.fade-leave</code> defines the ending state of a leaving transition. It is applied when the leaving transition starts and removed when the transition finishes.</p> </li> </ol> <p>If the <code>transition</code> attribute has no value, the classes will default to <code>.v-transition</code>, <code>.v-enter</code> and <code>.v-leave</code>.</p> <h3 id=\"Custom-Transition-Classes\">\nCustom Transition Classes</h3>\n<blockquote> <p>New in 1.0.14</p> </blockquote> <p>You can specify custom <code>enterClass</code> and <code>leaveClass</code> in the transition definition. These will override the conventional class names. Useful when you want to combine Vue’s transition system with an existing CSS animation library, e.g. <a href=\"https://daneden.github.io/animate.css/\" target=\"_blank\" rel=\"external\">Animate.css</a>:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-show=\"ok\" class=\"animated\" transition=\"bounce\"&gt;Watch me bounce&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">Vue.transition('bounce', {\n  enterClass: 'bounceInLeft',\n  leaveClass: 'bounceOutRight'\n})</pre> <h3 id=\"Declaring-Transition-Type\">\nDeclaring Transition Type</h3>\n<blockquote> <p>New in 1.0.14</p> </blockquote> <p>Vue.js needs to attach event listeners in order to know when the transition has ended. It can either be <code>transitionend</code> or <code>animationend</code>, depending on the type of CSS rules applied. If you are only using one or the other, Vue.js can automatically detect the correct type. However, if in some cases you want to have both on the same element, for example having a CSS animation triggered by Vue, and also having a CSS transition effect on hover, you will have to explicitly declare the type you want Vue to care about:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.transition('bounce', {\n  // Vue will now only care about `animationend` events\n  // for this transition\n  type: 'animation'\n})</pre> <h3 id=\"Transition-Flow-Details\">\nTransition Flow Details</h3>\n<p>When the <code>show</code> property changes, Vue.js will insert or remove the <code>&lt;div&gt;</code> element accordingly, and apply transition classes as specified below:</p> <ul> <li>\n<p>When <code>show</code> becomes false, Vue.js will:</p> <ol> <li>Call <code>beforeLeave</code> hook;</li> <li>Apply <code>v-leave</code> class to the element to trigger the transition;</li> <li>Call <code>leave</code> hook;</li> <li>Wait for the transition to finish; (listening to a <code>transitionend</code> event)</li> <li>Remove the element from the DOM and remove <code>v-leave</code> class;</li> <li>Call <code>afterLeave</code> hook.</li> </ol> </li> <li>\n<p>When <code>show</code> becomes true, Vue.js will:</p> <ol> <li>Call <code>beforeEnter</code> hook;</li> <li>Apply <code>v-enter</code> class to the element;</li> <li>Insert it into the DOM;</li> <li>Call <code>enter</code> hook;</li> <li>Force a CSS layout so <code>v-enter</code> is actually applied, then remove the <code>v-enter</code> class to trigger a transition back to the element’s original state;</li> <li>Wait for the transition to finish;</li> <li>Call <code>afterEnter</code> hook.</li> </ol> </li> </ul> <p>In addition, if you remove an element when its enter transition is in progress, the <code>enterCancelled</code> hook will be called to give you the opportunity to clean up changes or timers created in <code>enter</code>. Vice-versa for leaving transitions.</p> <p>All of the above hook functions are called with their <code>this</code> contexts set to the associated Vue instances. It follows the same rule of compilation scopes: a transition’s <code>this</code> context will point to the scope it is compiled in.</p> <p>Finally, the <code>enter</code> and <code>leave</code> can optionally take a second callback argument. When you do so, you are indicating that you want to explicitly control when the transition should end, so instead of waiting for the CSS <code>transitionend</code> event, Vue.js will expect you to eventually call the callback to finish the transition. For example:</p> <pre class=\"highlight js\" data-language=\"js\">enter: function (el) {\n  // no second argument, transition end\n  // determined by CSS transitionend event\n}</pre> <p>vs.</p> <pre class=\"highlight js\" data-language=\"js\">enter: function (el, done) {\n  // with the second argument, the transition\n  // will only end when `done` is called.\n}</pre> <p class=\"tip\">When multiple elements are being transitioned together, Vue.js batches them and only applies one forced layout.</p> <h3 id=\"CSS-Animations\">\nCSS Animations</h3>\n<p>CSS animations are applied in the same way with CSS transitions, the difference being that <code>v-enter</code> is not removed immediately after the element is inserted, but on an <code>animationend</code> event.</p> <p>Example: (omitting prefixed CSS rules here)</p> <pre class=\"highlight html\" data-language=\"html\">&lt;span v-show=\"show\" transition=\"bounce\"&gt;Look at me!&lt;/span&gt;</pre> <pre class=\"highlight css\" data-language=\"css\">.bounce-transition {\n  display: inline-block; /* otherwise scale animation won't work */\n}\n.bounce-enter {\n  animation: bounce-in .5s;\n}\n.bounce-leave {\n  animation: bounce-out .5s;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n@keyframes bounce-out {\n  0% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(0);\n  }\n}</pre>    <h2 id=\"JavaScript-Transitions\">\nJavaScript Transitions</h2>\n<p>You can also use just the JavaScript hooks without defining any CSS rules. When using JavaScript only transitions, <strong>the <code>done</code> callbacks are required for the <code>enter</code> and <code>leave</code> hooks</strong>, otherwise they will be called synchronously and the transition will finish immediately.</p> <p>It’s also a good idea to explicitly declare <code>css: false</code> for your JavaScript transitions so that Vue.js can skip the CSS detection. This also prevents cascaded CSS rules from accidentally interfering with the transition.</p> <p>The following example registers a custom JavaScript transition using jQuery:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.transition('fade', {\n  css: false,\n  enter: function (el, done) {\n    // element is already inserted into the DOM\n    // call done when animation finishes.\n    $(el)\n      .css('opacity', 0)\n      .animate({ opacity: 1 }, 1000, done)\n  },\n  enterCancelled: function (el) {\n    $(el).stop()\n  },\n  leave: function (el, done) {\n    // same as enter\n    $(el).animate({ opacity: 0 }, 1000, done)\n  },\n  leaveCancelled: function (el) {\n    $(el).stop()\n  }\n})</pre> <p>Then you can use it with the <code>transition</code> attribute, same deal:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;p transition=\"fade\"&gt;&lt;/p&gt;</pre> <h2 id=\"Staggering-Transitions\">\nStaggering Transitions</h2>\n<p>It’s possible to create staggering transitions when using <code>transition</code> with <code>v-for</code>. You can do this either by adding a <code>stagger</code>, <code>enter-stagger</code> or <code>leave-stagger</code> attribute to your transitioned element:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-for=\"item in list\" transition=\"stagger\" stagger=\"100\"&gt;&lt;/div&gt;</pre> <p>Or, you can provide a <code>stagger</code>, <code>enterStagger</code> or <code>leaveStagger</code> hook for finer-grained control:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.transition('stagger', {\n  stagger: function (index) {\n    // increase delay by 50ms for each transitioned item,\n    // but limit max delay to 300ms\n    return Math.min(300, index * 50)\n  }\n})</pre> <p>Example:</p> <iframe width=\"100%\" height=\"200\" style=\"margin-left:10px\" src=\"http://jsfiddle.net/yyx990803/mvo99bse/embedded/result,html,js,css\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/transitions.html\" class=\"_attribution-link\">https://vuejs.org/guide/transitions.html</a>\n  </p>\n</div>\n","guide/custom-directive":"<h1>Custom Directives</h1> <h2 id=\"Basics\">\nBasics</h2>\n<p>In addition to the default set of directives shipped in core, Vue.js also allows you to register custom directives. Custom directives provide a mechanism for mapping data changes to arbitrary DOM behavior.</p> <p>You can register a global custom directive with the <code>Vue.directive(id, definition)</code> method, passing in a <strong>directive id</strong> followed by a <strong>definition object</strong>. You can also register a local custom directive by including it in a component’s <code>directives</code> option.</p> <h3 id=\"Hook-Functions\">\nHook Functions</h3>\n<p>A definition object can provide several hook functions (all optional):</p> <ul> <li>\n<p><strong>bind</strong>: called only once, when the directive is first bound to the element.</p> </li> <li>\n<p><strong>update</strong>: called for the first time immediately after <code>bind</code> with the initial value, then again whenever the binding value changes. The new value and the previous value are provided as the argument.</p> </li> <li>\n<p><strong>unbind</strong>: called only once, when the directive is unbound from the element.</p> </li> </ul> <p><strong>Example</strong></p> <pre class=\"highlight js\" data-language=\"js\">Vue.directive('my-directive', {\n  bind: function () {\n    // do preparation work\n    // e.g. add event listeners or expensive stuff\n    // that needs to be run only once\n  },\n  update: function (newValue, oldValue) {\n    // do something based on the updated value\n    // this will also be called for the initial value\n  },\n  unbind: function () {\n    // do clean up work\n    // e.g. remove event listeners added in bind()\n  }\n})</pre> <p>Once registered, you can use it in Vue.js templates like this (remember to add the <code>v-</code> prefix):</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-my-directive=\"someValue\"&gt;&lt;/div&gt;</pre> <p>When you only need the <code>update</code> function, you can pass in a single function instead of the definition object:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.directive('my-directive', function (value) {\n  // this function will be used as update()\n})</pre> <h3 id=\"Directive-Instance-Properties\">\nDirective Instance Properties</h3>\n<p>All the hook functions will be copied into the actual <strong>directive object</strong>, which you can access inside these functions as their <code>this</code> context. The directive object exposes some useful properties:</p> <ul> <li>\n<strong>el</strong>: the element the directive is bound to.</li> <li>\n<strong>vm</strong>: the context ViewModel that owns this directive.</li> <li>\n<strong>expression</strong>: the expression of the binding, excluding arguments and filters.</li> <li>\n<strong>arg</strong>: the argument, if present.</li> <li>\n<strong>name</strong>: the name of the directive, without the prefix.</li> <li>\n<strong>modifiers</strong>: an object containing modifiers, if any.</li> <li>\n<strong>descriptor</strong>: an object that contains the parsing result of the entire directive.</li> <li>\n<strong>params</strong>: an object containing param attributes. <a href=\"#params\">Explained below</a>.</li> </ul> <p class=\"tip\">You should treat all these properties as read-only and never modify them. You can attach custom properties to the directive object too, but be careful not to accidentally overwrite existing internal ones.</p> <p>An example of a custom directive using some of these properties:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"demo\" v-demo:hello.a.b=\"msg\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">Vue.directive('demo', {\n  bind: function () {\n    console.log('demo bound!')\n  },\n  update: function (value) {\n    this.el.innerHTML =\n      'name - '       + this.name + '&lt;br&gt;' +\n      'expression - ' + this.expression + '&lt;br&gt;' +\n      'argument - '   + this.arg + '&lt;br&gt;' +\n      'modifiers - '  + JSON.stringify(this.modifiers) + '&lt;br&gt;' +\n      'value - '      + value\n  }\n})\nvar demo = new Vue({\n  el: '#demo',\n  data: {\n    msg: 'hello!'\n  }\n})</pre> <p><strong>Result</strong></p> \n  <h3 id=\"Object-Literals\">\nObject Literals</h3>\n<p>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-demo=\"{ color: 'white', text: 'hello!' }\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">Vue.directive('demo', function (value) {\n  console.log(value.color) // \"white\"\n  console.log(value.text) // \"hello!\"\n})</pre> <h3 id=\"Literal-Modifier\">\nLiteral Modifier</h3>\n<p>When a directive is used with the literal modifier, its attribute value will be interpreted as a plain string and passed directly into the <code>update</code> method. The <code>update</code> method will also be called only once, because a plain string cannot be reactive.</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-demo.literal=\"foo bar baz\"&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">Vue.directive('demo', function (value) {\n  console.log(value) // \"foo bar baz\"\n})</pre> <h3 id=\"Element-Directives\">\nElement Directives</h3>\n<p>In some cases, we may want our directive to be used in the form of a custom element rather than as an attribute. This is very similar to Angular’s notion of “E” mode directives. Element directives provide a lighter-weight alternative to full-blown components (which are explained later in the guide). You can register a custom element directive like so:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.elementDirective('my-directive', {\n  // same API as normal directives\n  bind: function () {\n    // manipulate this.el...\n  }\n})</pre> <p>Then, instead of:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-my-directive&gt;&lt;/div&gt;</pre> <p>We can write:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;my-directive&gt;&lt;/my-directive&gt;</pre> <p>Element directives cannot accept arguments or expressions, but it can read the element’s attributes to determine its behavior.</p> <p>A big difference from normal directives is that element directives are <strong>terminal</strong>, which means once Vue encounters an element directive, it will completely skip that element - only the element directive itself will be able to manipulate that element and its children.</p> <h2 id=\"Advanced-Options\">\nAdvanced Options</h2>\n<h3 id=\"params\">\nparams</h3>\n<p>Custom directive can provide a <code>params</code> array, and the Vue compiler will automatically extract these attributes on the element that the directive is bound to. Example:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-example a=\"hi\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">Vue.directive('example', {\n  params: ['a'],\n  bind: function () {\n    console.log(this.params.a) // -&gt; \"hi\"\n  }\n})</pre> <p>This API also supports dynamic attributes. The <code>this.params[key]</code> value is automatically kept up-to-date. In addition, you can specify a callback when the value has changed:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-example v-bind:a=\"someValue\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">Vue.directive('example', {\n  params: ['a'],\n  paramWatchers: {\n    a: function (val, oldVal) {\n      console.log('a changed!')\n    }\n  }\n})</pre> <p class=\"tip\">Note that similar to props, directive params follow the same camelCase &lt;=&gt; kebab case mapping between JavaScript and HTML. For example, for a param used as <code>disable-effect</code> in the template, you need to access it as <code>disableEffect</code> in JavaScript.</p> <h3 id=\"deep\">\ndeep</h3>\n<p>If your custom directive is expected to be used on an Object, and it needs to trigger <code>update</code> when a nested property inside the object changes, you need to pass in <code>deep: true</code> in your directive definition.</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-my-directive=\"obj\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">Vue.directive('my-directive', {\n  deep: true,\n  update: function (obj) {\n    // will be called when nested properties in `obj`\n    // changes.\n  }\n})</pre> <h3 id=\"twoWay\">\ntwoWay</h3>\n<p>If your directive expects to write data back to the Vue instance, you need to pass in <code>twoWay: true</code>. This option allows the use of <code>this.set(value)</code> inside the directive:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.directive('example', {\n  twoWay: true,\n  bind: function () {\n    this.handler = function () {\n      // set data back to the vm.\n      // If the directive is bound as v-example=\"a.b.c\",\n      // this will attempt to set `vm.a.b.c` with the\n      // given value.\n      this.set(this.el.value)\n    }.bind(this)\n    this.el.addEventListener('input', this.handler)\n  },\n  unbind: function () {\n    this.el.removeEventListener('input', this.handler)\n  }\n})</pre> <h3 id=\"acceptStatement\">\nacceptStatement</h3>\n<p>Passing in <code>acceptStatement:true</code> enables your custom directive to accept inline statements like <code>v-on</code> does:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-my-directive=\"a++\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">Vue.directive('my-directive', {\n  acceptStatement: true,\n  update: function (fn) {\n    // the passed in value is a function which when called,\n    // will execute the \"a++\" statement in the owner vm's\n    // scope.\n  }\n})</pre> <p>Use this wisely though, because in general you want to avoid side-effects in your templates.</p> <h3 id=\"terminal\">\nterminal</h3>\n<blockquote> <p>1.0.19+</p> </blockquote> <p>Vue compiles templates by recursively walking the DOM tree. However when it encounters a <strong>terminal</strong> directive, it will stop walking that element’s children. The terminal directive takes over the job of compiling the element and its children. For example, <code>v-if</code> and <code>v-for</code> are both terminal directives.</p> <p>Writing a custom terminal directive is an advanced topic and requires decent knowledge of Vue’s compilation pipeline, but it’s possible. You can specify a custom terminal directive by specifying <code>terminal: true</code>. You will also likely need to use <code>Vue.FragmentFactory</code> for partial compilation. Here’s an example of a custom terminal directive that compiles and “injects” its content template to another location on the page:</p> <pre class=\"highlight js\" data-language=\"js\">var FragmentFactory = Vue.FragmentFactory\nvar remove = Vue.util.remove\nvar createAnchor = Vue.util.createAnchor\n\nVue.directive('inject', {\n  terminal: true,\n  bind: function () {\n    var container = document.getElementById(this.arg)\n    this.anchor = createAnchor('v-inject')\n    container.appendChild(this.anchor)\n    remove(this.el)\n    var factory = new FragmentFactory(this.vm, this.el)\n    this.frag = factory.create(this._host, this._scope, this._frag)\n    this.frag.before(this.anchor)\n  },\n  unbind: function () {\n    this.frag.remove()\n    remove(this.anchor)\n  }\n})</pre> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"modal\"&gt;&lt;/div&gt;\n...\n&lt;div v-inject:modal&gt;\n  &lt;h1&gt;header&lt;/h1&gt;\n  &lt;p&gt;body&lt;/p&gt;\n  &lt;p&gt;footer&lt;/p&gt;\n&lt;/div&gt;</pre> <p>If you want to write a custom terminal directive, it is recommend that you read through the source code of built-in terminal directives like <code>v-if</code> and <code>v-for</code> to get a better understanding of Vue internals.</p> <h3 id=\"priority\">\npriority</h3>\n<p>You can optionally provide a priority number for your directive. If no priority is specified, a default priority will be used - <code>1000</code> for normal directives and <code>2000</code> for terminal directives. A directive with a higher priority will be processed earlier than other directives on the same element. Directives with the same priority will be processed in the order they appear in the element’s attribute list, although that order is not guaranteed to be consistent in different browsers.</p> <p>You can checkout the priorities for some built-in directives in the <a href=\"../api/index#Directives\">API reference</a>. Additionally, flow control directives <code>v-if</code> and <code>v-for</code> always have the highest priority in the compilation process.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/custom-directive.html\" class=\"_attribution-link\">https://vuejs.org/guide/custom-directive.html</a>\n  </p>\n</div>\n","guide/comparison":"<h1>Comparison with Other Frameworks</h1> <h2 id=\"Angular\">\nAngular</h2>\n<p>There are a few reasons to use Vue over Angular, although they might not apply for everyone:</p> <ul> <li>\n<p>Vue.js is much simpler than Angular, both in terms of API and design. You can learn almost everything about it really fast and get productive.</p> </li> <li>\n<p>Vue.js is a more flexible, less opinionated solution. That allows you to structure your app the way you want it to be, instead of being forced to do everything the Angular way. It’s only an interface layer so you can use it as a light feature in pages instead of a full blown SPA. It gives you bigger room to mix and match with other libraries, but you are also responsible for making more architectural decisions. For example, Vue.js’ core doesn’t come with routing or ajax functionalities by default, and usually assumes you are building the application using an external module bundler. This is probably the most important distinction.</p> </li> <li>\n<p>Angular uses two-way binding between scopes. While Vue also supports explicit two-way bindings, it defaults to a one-way, parent-to-child data flow between components. Using one-way binding makes the flow of data easier to reason about in large apps.</p> </li> <li>\n<p>Vue.js has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations only, while Components stand for a self-contained unit that has its own view and data logic. In Angular there’s a lot of confusion between the two.</p> </li> <li>\n<p>Vue.js has better performance and is much, much easier to optimize, because it doesn’t use dirty checking. Angular gets slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to “stabilize” if some watcher triggers another update. Angular users often have to resort to esoteric techniques to get around the digest cycle, and in some situations there’s simply no way to optimize a scope with a large amount of watchers. Vue.js doesn’t suffer from this at all because it uses a transparent dependency-tracking observing system with async queueing - all changes trigger independently unless they have explicit dependency relationships. The only optimization hint you’ll ever need is the <code>track-by</code> param on <code>v-for</code> lists.</p> </li> </ul> <p>Interestingly, there are quite some similarities in how Angular 2 and Vue are addressing these Angular 1 issues.</p> <h2 id=\"React\">\nReact</h2>\n<p>React and Vue.js do share a similarity in that they both provide reactive &amp; composable View components. There are, of course, many differences as well.</p> <p>First, the internal implementation is fundamentally different. React’s rendering leverages the Virtual DOM - an in-memory representation of what the actual DOM should look like. When the state changes, React does a full re-render of the Virtual DOM, diffs it, and then patches the real DOM.</p> <p>The virtual-DOM approach provides a functional way to describe your view at any point of time, which is really nice. Because it doesn’t use observables and re-renders the entire app on every update, the view is by definition guaranteed to be in sync with the data. It also opens up possibilities to isomorphic JavaScript applications.</p> <p>Instead of a Virtual DOM, Vue.js uses the actual DOM as the template and keeps references to actual nodes for data bindings. This limits Vue.js to environments where DOM is present. However, contrary to the common misconception that Virtual-DOM makes React faster than anything else, Vue.js actually out-performs React when it comes to hot updates, and requires almost no hand-tuned optimization. With React, you need to implement <code>shouldComponentUpdate</code> everywhere and use immutable data structures to achieve fully optimized re-renders.</p> <p>API-wise, one issue with React (or JSX) is that the render function often involves a lot of logic, and ends up looking more like a piece of program (which in fact it is) rather than a visual representation of the interface. For some developers this is a bonus, but for designer/developer hybrids like me, having a template makes it much easier to think visually about the design and CSS. JSX mixed with JavaScript logic breaks that visual model I need to map the code to the design. In contrast, Vue.js pays the cost of a lightweight data-binding DSL so that we have a visually scannable template and with logic encapsulated into directives and filters.</p> <p>Another issue with React is that because DOM updates are completely delegated to the Virtual DOM, it’s a bit tricky when you actually <strong>want</strong> to control the DOM yourself (although theoretically you can, you’d be essentially working against the library when you do that). For applications that need ad-hoc custom DOM manipulations, especially animations with complex timing requirements, this can become a pretty annoying restriction. On this front, Vue.js allows for more flexibility and there are <a href=\"https://github.com/vuejs/awesome-vue#interactive-experiences\" target=\"_blank\" rel=\"external\">multiple FWA/Awwwards winning sites</a> built with Vue.js.</p> <p>Some additional notes:</p> <ul> <li>\n<p>The React team has very ambitious goals in making React a platform-agnostic UI development paradigm, while Vue is focused on providing a pragmatic solution for the web.</p> </li> <li>\n<p>React, due to its functional nature, plays very well with functional programming patterns. However it also introduces a higher learning barrier for junior developers and beginners. Vue is much easier to pick up and get productive with in this regard.</p> </li> <li>\n<p>For large applications, the React community has been doing a lot of innovation in terms of state management solutions, e.g. Flux/Redux. Vue itself doesn’t really address that problem (same for React core), but the state management patterns can be easily adopted for a similar architecture. Vue has its own state management solution called <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"external\">Vuex</a>, and it’s also possible to <a href=\"https://github.com/egoist/revue\" target=\"_blank\" rel=\"external\">use Redux with Vue</a>.</p> </li> <li>\n<p>The trend in React development is pushing you to put everything in JavaScript, including your CSS. There has been many CSS-in-JS solutions out there but all more or less have its own problems. And most importantly, it deviates from the standard CSS authoring experience and makes it very awkward to leverage existing work in the CSS community. Vue’s <a href=\"application#Single-File-Components\">single file components</a> gives you component-encapsulated CSS while still allowing you to use your pre-processors of choice.</p> </li> </ul> <h2 id=\"Ember\">\nEmber</h2>\n<p>Ember is a full-featured framework that is designed to be highly opinionated. It provides a lot of established conventions, and once you are familiar enough with them, it can make you very productive. However, it also means the learning curve is high and the flexibility suffers. It’s a trade-off when you try to pick between an opinionated framework and a library with a loosely coupled set of tools that work together. The latter gives you more freedom but also requires you to make more architectural decisions.</p> <p>That said, it would probably make a better comparison between Vue.js core and Ember’s templating and object model layer:</p> <ul> <li>\n<p>Vue provides unobtrusive reactivity on plain JavaScript objects, and fully automatic computed properties. In Ember you need to wrap everything in Ember Objects and manually declare dependencies for computed properties.</p> </li> <li>\n<p>Vue’s template syntax harnesses the full power of JavaScript expressions, while Handlebars’ expression and helper syntax is quite limited in comparison.</p> </li> <li>\n<p>Performance wise, Vue outperforms Ember by a fair margin, even after the latest Glimmer engine update in Ember 2.0. Vue automatically batches updates, while in Ember you need to manually manage run loops in performance-critical situations.</p> </li> </ul> <h2 id=\"Polymer\">\nPolymer</h2>\n<p>Polymer is yet another Google-sponsored project and in fact was a source of inspiration for Vue.js as well. Vue.js’ components can be loosely compared to Polymer’s custom elements, and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features, and requires non-trivial polyfills to work (with degraded performance) in browsers that don’t support those features natively. In contrast, Vue.js works without any dependencies down to IE9.</p> <p>Also, in Polymer 1.0 the team has really made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are the boolean negation and single method calls. Its computed property implementation is also not very flexible.</p> <p>Finally, when deploying to production, Polymer elements need to be bundled via a Polymer-specific tool called vulcanizer. In comparison, single file Vue components can leverage everything the Webpack ecosystem has to offer, and thus you can easily use ES6 and any CSS pre-processors you want in your Vue components.</p> <h2 id=\"Riot\">\nRiot</h2>\n<p>Riot 2.0 provides a similar component-based development model (which is called a “tag” in Riot), with a minimal and beautifully designed API. I think Riot and Vue share a lot in design philosophies. However, despite being a bit heavier than Riot, Vue does offer some significant advantages over Riot:</p> <ul> <li>True conditional rendering (Riot renders all if branches and simply show/hide them)</li> <li>A far-more powerful router (Riot’s routing API is just way too minimal)</li> <li>More mature tooling support (see webpack + vue-loader)</li> <li>Transition effect system (Riot has none)</li> <li>Better performance. (Riot in fact uses dirty checking rather than a virtual-dom, and thus suffers from the same performance issues as Angular.)</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/comparison.html\" class=\"_attribution-link\">https://vuejs.org/guide/comparison.html</a>\n  </p>\n</div>\n","api/index":" <h2 id=\"Global-Config\">\nGlobal Config</h2>\n<p><code>Vue.config</code> is an object containing Vue’s global configurations. You can modify its properties listed below before bootstrapping your application:</p> <h3 id=\"debug\">\ndebug</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Boolean</code></p> </li> <li>\n<p><strong>Default:</strong> <code>false</code></p> </li> <li>\n<p><strong>Usage:</strong></p> <pre class=\"highlight js\" data-language=\"js\">Vue.config.debug = true</pre> <p>When in debug mode, Vue will:</p> <ol> <li>\n<p>Print stack traces for all warnings.</p> </li> <li>\n<p>Make all anchor nodes visible in the DOM as Comment nodes. This makes it easier to inspect the structure of the rendered result.</p> </li> </ol> <p class=\"tip\">Debug mode is only available in development build.</p> </li> </ul> <h3 id=\"delimiters\">\ndelimiters</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Array&lt;String&gt;</code></p> </li> <li>\n<p><strong>Default:</strong> <code>[\"{{\", \"}}\"]</code></p> </li> <li>\n<p><strong>Usage:</strong></p> <pre class=\"highlight js\" data-language=\"js\">// ES6 template string style\nVue.config.delimiters = ['${', '}']</pre> <p>Change the plain text interpolation delimiters.</p> </li> </ul> <h3 id=\"unsafeDelimiters\">\nunsafeDelimiters</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Array&lt;String&gt;</code></p> </li> <li>\n<p><strong>Default:</strong> <code>[\"{{{\", \"}}}\"]</code></p> </li> <li>\n<p><strong>Usage:</strong></p> <pre class=\"highlight js\" data-language=\"js\">// make it look more dangerous\nVue.config.unsafeDelimiters = ['{!!', '!!}']</pre> <p>Change the raw HTML interpolation delimiters.</p> </li> </ul> <h3 id=\"silent\">\nsilent</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Boolean</code></p> </li> <li>\n<p><strong>Default:</strong> <code>false</code></p> </li> <li>\n<p><strong>Usage:</strong></p> <pre class=\"highlight js\" data-language=\"js\">Vue.config.silent = true</pre> <p>Suppress all Vue.js logs and warnings.</p> </li> </ul> <h3 id=\"async\">\nasync</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Boolean</code></p> </li> <li>\n<p><strong>Default:</strong> <code>true</code></p> </li> <li>\n<p><strong>Usage:</strong></p> <pre class=\"highlight js\" data-language=\"js\">Vue.config.async = false</pre> <p>When async mode is off, Vue will perform all DOM updates synchronously upon detecting data change. This may help with debugging in some scenarios, but could also cause degraded performance and affect the order in which watcher callbacks are called. <strong><code>async: false</code> is not recommended in production.</strong></p> </li> </ul> <h3 id=\"devtools\">\ndevtools</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Boolean</code></p> </li> <li>\n<p><strong>Default:</strong> <code>true</code> (<code>false</code> in production builds)</p> </li> <li>\n<p><strong>Usage:</strong></p> <pre class=\"highlight js\" data-language=\"js\">// make sure to set this synchronously immediately after loading Vue\nVue.config.devtools = true</pre> <p>Configure whether to allow <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"external\">vue-devtools</a> inspection. This option’s default value is <code>true</code> in development builds and <code>false</code> in production builds. You can set it to <code>true</code> to enable inspection for production builds.</p> </li> </ul> <h2 id=\"Global-API\">\nGlobal API</h2>\n<h3 id=\"Vue-extend\">Vue.extend( options )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Object} options</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Create a “subclass” of the base Vue constructor. The argument should be an object containing component options.</p> <p>The special cases to note here are <code>el</code> and <code>data</code> options - they must be functions when used with <code>Vue.extend()</code>.</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"mount-point\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">// create reusable constructor\nvar Profile = Vue.extend({\n  template: '&lt;p&gt;{{firstName}} {{lastName}} aka {{alias}}&lt;/p&gt;'\n})\n// create an instance of Profile\nvar profile = new Profile({\n  data: {\n    firstName: 'Walter',\n    lastName: 'White',\n    alias: 'Heisenberg'\n  }\n})\n// mount it on an element\nprofile.$mount('#mount-point')</pre> <p>Will result in:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt;</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/components\">Components</a></p> </li> </ul> <h3 id=\"Vue-nextTick\">Vue.nextTick( callback )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Function} callback</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update.</p> <pre class=\"highlight js\" data-language=\"js\">// modify data\nvm.msg = 'Hello'\n// DOM not updated yet\nVue.nextTick(function () {\n  // DOM updated\n})</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/reactivity#Async-Update-Queue\">Async Update Queue</a></p> </li> </ul> <h3 id=\"Vue-set\">Vue.set( object, key, value )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Object} object</code></li> <li><code>{String} key</code></li> <li><code>{*} value</code></li> </ul> </li> <li>\n<p><strong>Returns:</strong> the set value.</p> </li> <li>\n<p><strong>Usage:</strong></p> <p>Set a property on an object. If the object is reactive, ensure the property is created as a reactive property and trigger view updates. This is primarily used to get around the limitation that Vue cannot detect property additions.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/reactivity\">Reactivity in Depth</a></p> </li> </ul> <h3 id=\"Vue-delete\">Vue.delete( object, key )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Object} object</code></li> <li><code>{String} key</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/reactivity\">Reactivity in Depth</a></p> </li> </ul> <h3 id=\"Vue-directive\">Vue.directive( id, [definition] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} id</code></li> <li><code>{Function | Object} [definition]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Register or retrieve a global directive.</p> <pre class=\"highlight js\" data-language=\"js\">// register\nVue.directive('my-directive', {\n  bind: function () {},\n  update: function () {},\n  unbind: function () {}\n})\n\n// register (simple function directive)\nVue.directive('my-directive', function () {\n  // this will be called as `update`\n})\n\n// getter, return the directive definition if registered\nvar myDirective = Vue.directive('my-directive')</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/custom-directive\">Custom Directives</a></p> </li> </ul> <h3 id=\"Vue-elementDirective\">Vue.elementDirective( id, [definition] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} id</code></li> <li><code>{Object} [definition]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Register or retrieve a global element directive.</p> <pre class=\"highlight js\" data-language=\"js\">// register\nVue.elementDirective('my-element', {\n  bind: function () {},\n  // element directives do not use `update`\n  unbind: function () {}\n})\n\n// getter, return the directive definition if registered\nvar myDirective = Vue.elementDirective('my-element')</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/custom-directive#Element-Directives\">Element Directives</a></p> </li> </ul> <h3 id=\"Vue-filter\">Vue.filter( id, [definition] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} id</code></li> <li><code>{Function | Object} [definition]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Register or retrieve a global filter.</p> <pre class=\"highlight js\" data-language=\"js\">// register\nVue.filter('my-filter', function (value) {\n  // return processed value\n})\n\n// two way filter\nVue.filter('my-filter', {\n  read: function () {},\n  write: function () {}\n})\n\n// getter, return the filter if registered\nvar myFilter = Vue.filter('my-filter')</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/custom-filter\">Custom Filter</a></p> </li> </ul> <h3 id=\"Vue-component\">Vue.component( id, [definition] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} id</code></li> <li><code>{Function | Object} [definition]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Register or retrieve a global component.</p> <pre class=\"highlight js\" data-language=\"js\">// register an extended constructor\nVue.component('my-component', Vue.extend({ /* ... */ }))\n\n// register an options object (automatically call Vue.extend)\nVue.component('my-component', { /* ... */ })\n\n// retrieve a registered component (always return constructor)\nvar MyComponent = Vue.component('my-component')</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/components\">Components</a>.</p> </li> </ul> <h3 id=\"Vue-transition\">Vue.transition( id, [hooks] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} id</code></li> <li><code>{Object} [hooks]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Register or retrieve a global transition hooks object.</p> <pre class=\"highlight js\" data-language=\"js\">// register\nVue.transition('fade', {\n  enter: function () {},\n  leave: function () {}\n})\n\n// retrieve registered hooks\nvar fadeTransition = Vue.transition('fade')</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/transitions\">Transitions</a>.</p> </li> </ul> <h3 id=\"Vue-partial\">Vue.partial( id, [partial] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} id</code></li> <li><code>{String} [partial]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Register or retrieve a global template partial string.</p> <pre class=\"highlight js\" data-language=\"js\">// register\nVue.partial('my-partial', '&lt;div&gt;Hi&lt;/div&gt;')\n\n// retrieve registered partial\nvar myPartial = Vue.partial('my-partial')</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"#partial\">Special Elements - &lt;partial&gt;</a>.</p> </li> </ul> <h3 id=\"Vue-use\">Vue.use( plugin, [options] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Object | Function} plugin</code></li> <li><code>{Object} [options]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Install a Vue.js plugin. If the plugin is an Object, it must expose an <code>install</code> method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/plugins\">Plugins</a>.</p> </li> </ul> <h3 id=\"Vue-mixin\">Vue.mixin( mixin )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Object} mixin</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. <strong>Not recommended in application code</strong>.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/mixins#Global-Mixin\">Global Mixins</a></p> </li> </ul> <h2 id=\"Options-Data\">\nOptions / Data</h2>\n<h3 id=\"data\">\ndata</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object | Function</code></p> </li> <li>\n<p><strong>Restriction:</strong> Only accepts <code>Function</code> when used in a component definition.</p> </li> <li>\n<p><strong>Details:</strong></p> <p>The data object for the Vue instance. Vue.js will recursively convert its properties into getter/setters to make it “reactive”. <strong>The object must be plain</strong>: native objects, existing getter/setters and prototype properties are ignored. It is not recommended to observe complex objects.</p> <p>Once the instance is created, the original data object can be accessed as <code>vm.$data</code>. The Vue instance also proxies all the properties found on the data object.</p> <p>Properties that start with <code>_</code> or <code>$</code> will <strong>not</strong> be proxied on the Vue instance because they may conflict with Vue’s internal properties and API methods. You will have to access them as <code>vm.$data._property</code>.</p> <p>When defining a <strong>component</strong>, <code>data</code> must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we still use a plain object for <code>data</code>, that same object will be <strong>shared by reference</strong> across all instance created! By providing a <code>data</code> function, every time a new instance is created, we can simply call it to return a fresh copy of the initial data.</p> <p>If required, a deep clone of the original object can be obtained by passing <code>vm.$data</code> through <code>JSON.parse(JSON.stringify(...))</code>.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var data = { a: 1 }\n\n// direct instance creation\nvar vm = new Vue({\n  data: data\n})\nvm.a // -&gt; 1\nvm.$data === data // -&gt; true\n\n// must use function when in Vue.extend()\nvar Component = Vue.extend({\n  data: function () {\n    return { a: 1 }\n  }\n})</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/reactivity\">Reactivity in Depth</a>.</p> </li> </ul> <h3 id=\"props\">\nprops</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Array | Object</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>A list/hash of attributes that are exposed to accept data from the parent component. It has a simple Array-based syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">// simple syntax\nVue.component('props-demo-simple', {\n  props: ['size', 'myMessage']\n})\n\n// object syntax with validation\nVue.component('props-demo-advanced', {\n  props: {\n    // just type check\n    size: Number,\n    // type check plus other validations\n    name: {\n      type: String,\n      required: true,\n      // warn if not two way bound\n      twoWay: true\n    }\n  }\n})</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/components#Props\">Props</a></p> </li> </ul> <h3 id=\"propsData\">\npropsData</h3>\n<blockquote> <p>1.0.22+</p> </blockquote> <ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p> </li> <li>\n<p><strong>Details:</strong></p> <p>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var Comp = Vue.extend({\n  props: ['msg'],\n  template: '&lt;div&gt;{{ msg }}&lt;/div&gt;'\n})\n\nvar vm = new Comp({\n  propsData: {\n    msg: 'hello'\n  }\n})</pre> </li> </ul> <h3 id=\"computed\">\ncomputed</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Computed properties to be mixed into the Vue instance. All getters and setters have their <code>this</code> context automatically bound to the Vue instance.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    // get only, just need a function\n    aDouble: function () {\n      return this.a * 2\n    },\n    // both get and set\n    aPlus: {\n      get: function () {\n        return this.a + 1\n      },\n      set: function (v) {\n        this.a = v - 1\n      }\n    }\n  }\n})\nvm.aPlus   // -&gt; 2\nvm.aPlus = 3\nvm.a       // -&gt; 2\nvm.aDouble // -&gt; 4</pre> </li> <li>\n<p><strong>See also:</strong></p> <ul> <li><a href=\"../guide/computed\">Computed Properties</a></li> <li><a href=\"../guide/reactivity#Inside-Computed-Properties\">Reactivity in Depth: Inside Computed Properties</a></li> </ul> </li> </ul> <h3 id=\"methods\">\nmethods</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their <code>this</code> context automatically bound to the Vue instance.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  data: { a: 1 },\n  methods: {\n    plus: function () {\n      this.a++\n    }\n  }\n})\nvm.plus()\nvm.a // 2</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/events\">Methods and Event Handling</a></p> </li> </ul> <h3 id=\"watch\">\nwatch</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call <code>$watch()</code> for each entry in the object at instantiation.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  data: {\n    a: 1\n  },\n  watch: {\n    'a': function (val, oldVal) {\n      console.log('new: %s, old: %s', val, oldVal)\n    },\n    // string method name\n    'b': 'someMethod',\n    // deep watcher\n    'c': {\n      handler: function (val, oldVal) { /* ... */ },\n      deep: true\n    }\n  }\n})\nvm.a = 2 // -&gt; new: 2, old: 1</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"#vm-watch\">Instance Methods - vm.$watch</a></p> </li> </ul> <h2 id=\"Options-DOM\">\nOptions / DOM</h2>\n<h3 id=\"el\">\nel</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>String | HTMLElement | Function</code></p> </li> <li>\n<p><strong>Restriction:</strong> only accepts type <code>Function</code> when used in a component definition.</p> </li> <li>\n<p><strong>Details:</strong></p> <p>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string, an actual HTMLElement, or a function that returns an HTMLElement. Note that the provided element merely serves as a mounting point; it will be replaced if a template is also provided, unless <code>replace</code> is set to false. The resolved element will be accessible as <code>vm.$el</code>.</p> <p>When used in <code>Vue.extend</code>, a function must be provided so each instance gets a separately created element.</p> <p>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call <code>vm.$mount()</code> to manually start the compilation.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/instance#Lifecycle-Diagram\">Lifecycle Diagram</a></p> </li> </ul> <h3 id=\"template\">\ntemplate</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>String</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>A string template to be used as the markup for the Vue instance. By default, the template will <strong>replace</strong> the mounted element. When the <code>replace</code> option is set to <code>false</code>, the template will be inserted into the mounted element instead. In both cases, any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template.</p> <p>If the string starts with <code>#</code> it will be used as a querySelector and use the selected element’s innerHTML as the template string. This allows the use of the common <code>&lt;script type=\"x-template\"&gt;</code> trick to include templates.</p> <p>Note that under certain situations, for example when the template contains more than one top-level element, or contains only plain text, the instance will become a fragment instance - i.e. one that manages a list of nodes rather than a single node. Non flow-control directives on the mount point for fragment instances are ignored.</p> </li> <li>\n<p><strong>See also:</strong></p> <ul> <li><a href=\"../guide/instance#Lifecycle-Diagram\">Lifecycle Diagram</a></li> <li><a href=\"../guide/components#Content-Distribution-with-Slots\">Content Distribution</a></li> <li><a href=\"../guide/components#Fragment-Instance\">Fragment Instance</a></li> </ul> </li> </ul> <h3 id=\"replace\">\nreplace</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Boolean</code></p> </li> <li>\n<p><strong>Default:</strong> <code>true</code></p> </li> <li>\n<p><strong>Restriction:</strong> only respected if the <strong>template</strong> option is also present.</p> </li> <li>\n<p><strong>Details:</strong></p> <p>Determines whether to replace the element being mounted on with the template. If set to <code>false</code>, the template will overwrite the element’s inner content without replacing the element itself. If set to <code>true</code>, the template will overwrite the element and merge the element’s attributes with the attributes of the component’s root node.</p> </li> <li>\n<p><strong>Example</strong>:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"replace\" class=\"foo\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#replace',\n  template: '&lt;p class=\"bar\"&gt;replaced&lt;/p&gt;'\n})</pre> <p>Will result in:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;p class=\"foo bar\" id=\"replace\"&gt;replaced&lt;/p&gt;</pre> <p>In comparison, when <code>replace</code> is set to <code>false</code>:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"insert\" class=\"foo\"&gt;&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#insert',\n  replace: false,\n  template: '&lt;p class=\"bar\"&gt;inserted&lt;/p&gt;'\n})</pre> <p>Will result in:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"insert\" class=\"foo\"&gt;\n  &lt;p class=\"bar\"&gt;inserted&lt;/p&gt;\n&lt;/div&gt;</pre> </li> </ul> <h2 id=\"Options-Lifecycle-Hooks\">\nOptions / Lifecycle Hooks</h2>\n<h3 id=\"init\">\ninit</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Function</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Called synchronously after the instance has just been initialized, before data observation and event / watcher setup.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/instance#Lifecycle-Diagram\">Lifecycle Diagram</a></p> </li> </ul> <h3 id=\"created\">\ncreated</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Function</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, DOM compilation has not been started, and the <code>$el</code> property will not be available yet.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/instance#Lifecycle-Diagram\">Lifecycle Diagram</a></p> </li> </ul> <h3 id=\"beforeCompile\">\nbeforeCompile</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Function</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Called right before the compilation starts.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/instance#Lifecycle-Diagram\">Lifecycle Diagram</a></p> </li> </ul> <h3 id=\"compiled\">\ncompiled</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Function</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Called after the compilation is finished. At this stage all directives have been linked so data changes will trigger DOM updates. However, <code>$el</code> is not guaranteed to have been inserted into the document yet.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/instance#Lifecycle-Diagram\">Lifecycle Diagram</a></p> </li> </ul> <h3 id=\"ready\">\nready</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Function</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Called after compilation <strong>and</strong> the <code>$el</code> is <strong>inserted into the document for the first time</strong>, i.e. right after the first <code>attached</code> hook. Note this insertion must be executed via Vue (with methods like <code>vm.$appendTo()</code> or as a result of a directive update) to trigger the <code>ready</code> hook.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/instance#Lifecycle-Diagram\">Lifecycle Diagram</a></p> </li> </ul> <h3 id=\"attached\">\nattached</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Function</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Called when <code>vm.$el</code> is attached to DOM by a directive or a VM instance method such as <code>$appendTo()</code>. Direct manipulation of <code>vm.$el</code> will <strong>not</strong> trigger this hook.</p> </li> </ul> <h3 id=\"detached\">\ndetached</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Function</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Called when <code>vm.$el</code> is removed from the DOM by a directive or a VM instance method. Direct manipulation of <code>vm.$el</code> will <strong>not</strong> trigger this hook.</p> </li> </ul> <h3 id=\"beforeDestroy\">\nbeforeDestroy</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Function</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/instance#Lifecycle-Diagram\">Lifecycle Diagram</a></p> </li> </ul> <h3 id=\"destroyed\">\ndestroyed</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Function</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Called after a Vue instance has been destroyed. When this hook is called, all bindings and directives of the Vue instance have been unbound and all child Vue instances have also been destroyed.</p> <p>Note if there is a leaving transition, the <code>destroyed</code> hook is called <strong>after</strong> the transition has finished.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/instance#Lifecycle-Diagram\">Lifecycle Diagram</a></p> </li> </ul> <h2 id=\"Options-Assets\">\nOptions / Assets</h2>\n<h3 id=\"directives\">\ndirectives</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>A hash of directives to be made available to the Vue instance.</p> </li> <li>\n<p><strong>See also:</strong></p> <ul> <li><a href=\"../guide/custom-directive\">Custom Directives</a></li> <li><a href=\"../guide/components#Assets-Naming-Convention\">Assets Naming Convention</a></li> </ul> </li> </ul> <h3 id=\"elementDirectives\">\nelementDirectives</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>A hash of element directives to be made available to the Vue instance.</p> </li> <li>\n<p><strong>See also:</strong></p> <ul> <li><a href=\"../guide/custom-directive#Element-Directives\">Element Directives</a></li> <li><a href=\"../guide/components#Assets-Naming-Convention\">Assets Naming Convention</a></li> </ul> </li> </ul> <h3 id=\"filters\">\nfilters</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>A hash of filters to be made available to the Vue instance.</p> </li> <li>\n<p><strong>See also:</strong></p> <ul> <li><a href=\"../guide/custom-filter\">Custom Filters</a></li> <li><a href=\"../guide/components#Assets-Naming-Convention\">Assets Naming Convention</a></li> </ul> </li> </ul> <h3 id=\"components\">\ncomponents</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>A hash of components to be made available to the Vue instance.</p> </li> <li>\n<p><strong>See also:</strong></p> <ul> <li><a href=\"../guide/components\">Components</a></li> </ul> </li> </ul> <h3 id=\"transitions\">\ntransitions</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>A hash of transitions to be made available to the Vue instance.</p> </li> <li>\n<p><strong>See also:</strong></p> <ul> <li><a href=\"../guide/transitions\">Transitions</a></li> </ul> </li> </ul> <h3 id=\"partials\">\npartials</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>A hash of partial strings to be made available to the Vue instance.</p> </li> <li>\n<p><strong>See also:</strong></p> <ul> <li><a href=\"#partial\">Special Elements - partial</a></li> </ul> </li> </ul> <h2 id=\"Options-Misc\">\nOptions / Misc</h2>\n<h3 id=\"parent\">\nparent</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Vue instance</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as <code>this.$parent</code> for the child, and the child will be pushed into the parent’s <code>$children</code> array.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/components#Parent-Child-Communication\">Parent-Child Communication</a></p> </li> </ul> <h3 id=\"events\">\nevents</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>An object where keys are events to listen for and values are the corresponding callbacks. Note these are Vue events rather than DOM events. The value can also be a string of a method name. The Vue instance will call <code>$on()</code> for each entry in the object at instantiation.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  events: {\n    'hook:created': function () {\n      console.log('created!')\n    },\n    greeting: function (msg) {\n      console.log(msg)\n    },\n    // can also use a string for methods\n    bye: 'sayGoodbye'\n  },\n  methods: {\n    sayGoodbye: function () {\n      console.log('goodbye!')\n    }\n  }\n}) // -&gt; created!\nvm.$emit('greeting', 'hi!') // -&gt; hi!\nvm.$emit('bye')             // -&gt; goodbye!</pre> </li> <li>\n<p><strong>See also:</strong></p> <ul> <li><a href=\"#Instance-Methods-Events\">Instance Methods - Events</a></li> <li><a href=\"../guide/components#Parent-Child-Communication\">Parent-Child Communication</a></li> </ul> </li> </ul> <h3 id=\"mixins\">\nmixins</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Array</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>The <code>mixins</code> option accepts an array of mixin objects. These mixin objects can contain instance options just like normal instance objects, and they will be merged against the eventual options using the same option merging logic in <code>Vue.extend()</code>. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.</p> <p>Mixin hooks are called in the order they are provided, and called before the component’s own hooks.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var mixin = {\n  created: function () { console.log(1) }\n}\nvar vm = new Vue({\n  created: function () { console.log(2) },\n  mixins: [mixin]\n})\n// -&gt; 1\n// -&gt; 2</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/mixins\">Mixins</a></p> </li> </ul> <h3 id=\"name\">\nname</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>String</code></p> </li> <li>\n<p><strong>Restriction:</strong> only respected when used in <code>Vue.extend()</code>.</p> </li> <li>\n<p><strong>Details:</strong></p> <p>Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with <code>Vue.component()</code>, the global ID is automatically set as its name.</p> <p>Another benefit of specifying a <code>name</code> option is console inspection. When inspecting an extended Vue component in the console, the default constructor name is <code>VueComponent</code>, which isn’t very informative. By passing in an optional <code>name</code> option to <code>Vue.extend()</code>, you will get a better inspection output so that you know which component you are looking at. The string will be camelized and used as the component’s constructor name.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var Ctor = Vue.extend({\n  name: 'stack-overflow',\n  template:\n    '&lt;div&gt;' +\n      // recursively invoke self\n      '&lt;stack-overflow&gt;&lt;/stack-overflow&gt;' +\n    '&lt;/div&gt;'\n})\n\n// this will actually result in a max stack size exceeded\n// error, but let's assume it works...\nvar vm = new Ctor()\n\nconsole.log(vm) // -&gt; StackOverflow {$el: null, ...}</pre> </li> </ul> <h3 id=\"extends\">\nextends</h3>\n<blockquote> <p>1.0.22+</p> </blockquote> <ul> <li>\n<p><strong>Type:</strong> <code>Object | Function</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use <code>Vue.extend</code>. This is primarily intended to make it easier to extend between single file components.</p> <p>This is similar to <code>mixins</code>, the difference being that the component’s own options takes higher priority than the source component being extended.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var CompA = { ... }\n\n// extend CompA without having to call Vue.extend on either\nvar CompB = {\n  extends: CompA,\n  ...\n}</pre> </li> </ul> <h2 id=\"Instance-Properties\">\nInstance Properties</h2>\n<h3 id=\"vm-data\">\nvm.$data</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>The data object that the Vue instance is observing. You can swap it with a new object. The Vue instance proxies access to the properties on its data object.</p> </li> </ul> <h3 id=\"vm-el\">\nvm.$el</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>HTMLElement</code></p> </li> <li>\n<p><strong>Read only</strong></p> </li> <li>\n<p><strong>Details:</strong></p> <p>The DOM element that the Vue instance is managing. Note that for <a href=\"../guide/components#Fragment-Instance\">Fragment Instances</a>, <code>vm.$el</code> will return an anchor node that indicates the starting position of the fragment.</p> </li> </ul> <h3 id=\"vm-options\">\nvm.$options</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Read only</strong></p> </li> <li>\n<p><strong>Details:</strong></p> <p>The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:</p> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  customOption: 'foo',\n  created: function () {\n    console.log(this.$options.customOption) // -&gt; 'foo'\n  }\n})</pre> </li> </ul> <h3 id=\"vm-parent\">\nvm.$parent</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Vue instance</code></p> </li> <li>\n<p><strong>Read only</strong></p> </li> <li>\n<p><strong>Details:</strong></p> <p>The parent instance, if the current instance has one.</p> </li> </ul> <h3 id=\"vm-root\">\nvm.$root</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Vue instance</code></p> </li> <li>\n<p><strong>Read only</strong></p> </li> <li>\n<p><strong>Details:</strong></p> <p>The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.</p> </li> </ul> <h3 id=\"vm-children\">\nvm.$children</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Array&lt;Vue instance&gt;</code></p> </li> <li>\n<p><strong>Read only</strong></p> </li> <li>\n<p><strong>Details:</strong></p> <p>The direct child components of the current instance.</p> </li> </ul> <h3 id=\"vm-refs\">\nvm.$refs</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Read only</strong></p> </li> <li>\n<p><strong>Details:</strong></p> <p>An object that holds child components that have <code>v-ref</code> registered.</p> </li> <li>\n<p><strong>See also:</strong></p> <ul> <li><a href=\"../guide/components#Child-Component-Refs\">Child Component Refs</a></li> <li>\n<a href=\"#v-ref\">v-ref</a>.</li> </ul> </li> </ul> <h3 id=\"vm-els\">\nvm.$els</h3>\n<ul> <li>\n<p><strong>Type:</strong> <code>Object</code></p> </li> <li>\n<p><strong>Read only</strong></p> </li> <li>\n<p><strong>Details:</strong></p> <p>An object that holds DOM elements that have <code>v-el</code> registered.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"#v-el\">v-el</a>.</p> </li> </ul> <h2 id=\"Instance-Methods-Data\">\nInstance Methods / Data</h2>\n<h3 id=\"vm-watch\">vm.$watch( expOrFn, callback, [options] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String | Function} expOrFn</code></li> <li><code>{Function} callback</code></li> <li>\n<code>{Object} [options]</code><ul> <li><code>{Boolean} deep</code></li> <li><code>{Boolean} immediate</code></li> </ul> </li> </ul> </li> <li>\n<p><strong>Returns:</strong> <code>{Function} unwatch</code></p> </li> <li>\n<p><strong>Usage:</strong></p> <p>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression can be a single keypath or any valid binding expressions.</p> </li> </ul> <p class=\"tip\">Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn’t keep a copy of the pre-mutate value.</p> <ul> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">// keypath\nvm.$watch('a.b.c', function (newVal, oldVal) {\n  // do something\n})\n\n// expression\nvm.$watch('a + b', function (newVal, oldVal) {\n  // do something\n})\n\n// function\nvm.$watch(\n  function () {\n    return this.a + this.b\n  },\n  function (newVal, oldVal) {\n    // do something\n  }\n)</pre> <p><code>vm.$watch</code> returns an unwatch function that stops firing the callback:</p> <pre class=\"highlight js\" data-language=\"js\">var unwatch = vm.$watch('a', cb)\n// later, teardown the watcher\nunwatch()</pre> </li> <li>\n<p><strong>Option: deep</strong></p> <p>To also detect nested value changes inside Objects, you need to pass in <code>deep: true</code> in the options argument. Note that you don’t need to do so to listen for Array mutations.</p> <pre class=\"highlight js\" data-language=\"js\">vm.$watch('someObject', callback, {\n  deep: true\n})\nvm.someObject.nestedValue = 123\n// callback is fired</pre> </li> <li>\n<p><strong>Option: immediate</strong></p> <p>Passing in <code>immediate: true</code> in the option will trigger the callback immediately with the current value of the expression:</p> <pre class=\"highlight js\" data-language=\"js\">vm.$watch('a', callback, {\n  immediate: true\n})\n// callback is fired immediately with current value of `a`</pre> </li> </ul> <h3 id=\"vm-get\">vm.$get( expression )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} expression</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Retrieve a value from the Vue instance given an expression. Expressions that throw errors will be suppressed and return <code>undefined</code>.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  data: {\n    a: {\n      b: 1\n    }\n  }\n})\nvm.$get('a.b') // -&gt; 1\nvm.$get('a.b + 1') // -&gt; 2</pre> </li> </ul> <h3 id=\"vm-set\">vm.$set( keypath, value )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} keypath</code></li> <li><code>{*} value</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Set a data value on the Vue instance given a valid keypath. In most cases you should prefer setting properties using plain object syntax, e.g. <code>vm.a.b = 123</code>. This method is only needed in two scenarios:</p> <ol> <li>\n<p>When you have a keypath string and want to dynamically set the value using that keypath.</p> </li> <li>\n<p>When you want to set a property that doesn’t exist.</p> </li> </ol> <p>If the path doesn’t exist it will be recursively created and made reactive. If a new root-level reactive property is created due to a <code>$set</code> call, the Vue instance will be forced into a “digest cycle”, during which all its watchers are re-evaluated.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var vm = new Vue({\n  data: {\n    a: {\n      b: 1\n    }\n  }\n})\n\n// set an existing path\nvm.$set('a.b', 2)\nvm.a.b // -&gt; 2\n\n// set a non-existent path, will force digest\nvm.$set('c', 3)\nvm.c // -&gt;</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/reactivity\">Reactivity in Depth</a></p> </li> </ul> <h3 id=\"vm-delete\">vm.$delete( key )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} key</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Delete a root level property on the Vue instance (and also its <code>$data</code>). Forces a digest cycle. Not recommended.</p> </li> </ul> <h3 id=\"vm-eval\">vm.$eval( expression )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} expression</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Evaluate a valid binding expression on the current instance. The expression can also contain filters.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">// assuming vm.msg = 'hello'\nvm.$eval('msg | uppercase') // -&gt; 'HELLO'</pre> </li> </ul> <h3 id=\"vm-interpolate\">vm.$interpolate( templateString )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} templateString</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Evaluate a piece of template string containing mustache interpolations. Note that this method simply performs string interpolation; attribute directives are ignored.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">// assuming vm.msg = 'hello'\nvm.$interpolate('{{msg}} world!') // -&gt; 'hello world!'</pre> </li> </ul> <h3 id=\"vm-log\">vm.$log( [keypath] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} [keypath]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Log the current instance data as a plain object, which is more inspection-friendly than a bunch of getter/setters. Also accepts an optional key.</p> <pre class=\"highlight js\" data-language=\"js\">vm.$log() // logs entire ViewModel data\nvm.$log('item') // logs vm.item</pre> </li> </ul> <h2 id=\"Instance-Methods-Events\">\nInstance Methods / Events</h2>\n<h3 id=\"vm-on\">vm.$on( event, callback )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} event</code></li> <li><code>{Function} callback</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Listen for a custom event on the current vm. Events can be triggered by <code>vm.$emit</code>, <code>vm.$dispatch</code> or <code>vm.$broadcast</code>. The callback will receive all the additional arguments passed into these event-triggering methods.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">vm.$on('test', function (msg) {\n  console.log(msg)\n})\nvm.$emit('test', 'hi')\n// -&gt; \"hi\"</pre> </li> </ul> <h3 id=\"vm-once\">vm.$once( event, callback )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} event</code></li> <li><code>{Function} callback</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</p> </li> </ul> <h3 id=\"vm-off\">vm.$off( [event, callback] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} [event]</code></li> <li><code>{Function} [callback]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Remove event listener(s).</p> <ul> <li>\n<p>If no arguments are provided, remove all event listeners;</p> </li> <li>\n<p>If only the event is provided, remove all listeners for that event;</p> </li> <li>\n<p>If both event and callback are given, remove the listener for that specific callback only.</p> </li> </ul> </li> </ul> <h3 id=\"vm-emit\">vm.$emit( event, […args] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} event</code></li> <li><code>[...args]</code></li> </ul> <p>Trigger an event on the current instance. Any additional arguments will be passed into the listener’s callback function.</p> </li> </ul> <h3 id=\"vm-dispatch\">vm.$dispatch( event, […args] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} event</code></li> <li><code>[...args]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Dispatch an event, first triggering it on the instance itself, and then propagates upward along the parent chain. The propagation stops when it triggers a parent event listener, unless that listener returns <code>true</code>. Any additional arguments will be passed into the listener’s callback function.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">// create a parent chain\nvar parent = new Vue()\nvar child1 = new Vue({ parent: parent })\nvar child2 = new Vue({ parent: child1 })\n\nparent.$on('test', function () {\n  console.log('parent notified')\n})\nchild1.$on('test', function () {\n  console.log('child1 notified')\n})\nchild2.$on('test', function () {\n  console.log('child2 notified')\n})\n\nchild2.$dispatch('test')\n// -&gt; \"child2 notified\"\n// -&gt; \"child1 notified\"\n// parent is NOT notified, because child1 didn't return\n// true in its callback</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/components#Parent-Child-Communication\">Parent-Child Communication</a></p> </li> </ul> <h3 id=\"vm-broadcast\">vm.$broadcast( event, […args] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} event</code></li> <li><code>[...args]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Broadcast an event that propagates downward to all descendants of the current instance. Since the descendants expand into multiple sub-trees, the event propagation will follow many different “paths”. The propagation for each path will stop when a listener callback is fired along that path, unless the callback returns <code>true</code>.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var parent = new Vue()\n// child1 and child2 are siblings\nvar child1 = new Vue({ parent: parent })\nvar child2 = new Vue({ parent: parent })\n// child3 is nested under child2\nvar child3 = new Vue({ parent: child2 })\n\nchild1.$on('test', function () {\n  console.log('child1 notified')\n})\nchild2.$on('test', function () {\n  console.log('child2 notified')\n})\nchild3.$on('test', function () {\n  console.log('child3 notified')\n})\n\nparent.$broadcast('test')\n// -&gt; \"child1 notified\"\n// -&gt; \"child2 notified\"\n// child3 is NOT notified, because child2 didn't return\n// true in its callback</pre> </li> </ul> <h2 id=\"Instance-Methods-DOM\">\nInstance Methods / DOM</h2>\n<h3 id=\"vm-appendTo\">vm.$appendTo( elementOrSelector, [callback] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Element | String} elementOrSelector</code></li> <li><code>{Function} [callback]</code></li> </ul> </li> <li>\n<p><strong>Returns:</strong> <code>vm</code> - the instance itself</p> </li> <li>\n<p><strong>Usage:</strong></p> <p>Append the Vue instance’s DOM element or fragment to target element. The target can be either an element or a querySelector string. This method will trigger transitions if present. The callback is fired after the transition has completed (or immediately if no transition has been triggered).</p> </li> </ul> <h3 id=\"vm-before\">vm.$before( elementOrSelector, [callback] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Element | String} elementOrSelector</code></li> <li><code>{Function} [callback]</code></li> </ul> </li> <li>\n<p><strong>Returns:</strong> <code>vm</code> - the instance itself</p> </li> <li>\n<p><strong>Usage:</strong></p> <p>Insert the Vue instance’s DOM element or fragment before target element. The target can be either an element or a querySelector string. This method will trigger transitions if present. The callback is fired after the transition has completed (or immediately if no transition has been triggered).</p> </li> </ul> <h3 id=\"vm-after\">vm.$after( elementOrSelector, [callback] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Element | String} elementOrSelector</code></li> <li><code>{Function} [callback]</code></li> </ul> </li> <li>\n<p><strong>Returns:</strong> <code>vm</code> - the instance itself</p> </li> <li>\n<p><strong>Usage:</strong></p> <p>Insert the Vue instance’s DOM element or fragment after target element. The target can be either an element or a querySelector string. This method will trigger transitions if present. The callback is fired after the transition has completed (or immediately if no transition has been triggered).</p> </li> </ul> <h3 id=\"vm-remove\">vm.$remove( [callback] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Function} [callback]</code></li> </ul> </li> <li>\n<p><strong>Returns:</strong> <code>vm</code> - the instance itself</p> </li> <li>\n<p><strong>Usage:</strong></p> <p>Remove the Vue instance’s DOM element or fragment from the DOM. This method will trigger transitions if present. The callback is fired after the transition has completed (or immediately if no transition has been triggered).</p> </li> </ul> <h3 id=\"vm-nextTick\">vm.$nextTick( callback )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Function} [callback]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update. This is the same as the global <code>Vue.nextTick</code>, except that the callback’s <code>this</code> context is automatically bound to the instance calling this method.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  // ...\n  methods: {\n    // ...\n    example: function () {\n      // modify data\n      this.message = 'changed'\n      // DOM is not updated yet\n      this.$nextTick(function () {\n        // DOM is now updated\n        // `this` is bound to the current instance\n        this.doSomethingElse()\n      })\n    }\n  }\n})</pre> </li> <li>\n<p><strong>See also:</strong></p> <ul> <li><a href=\"#Vue-nextTick\">Vue.nextTick</a></li> <li><a href=\"../guide/reactivity#Async-Update-Queue\">Async Update Queue</a></li> </ul> </li> </ul> <h2 id=\"Instance-Methods-Lifecycle\">\nInstance Methods / Lifecycle</h2>\n<h3 id=\"vm-mount\">vm.$mount( [elementOrSelector] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Element | String} [elementOrSelector]</code></li> </ul> </li> <li>\n<p><strong>Returns:</strong> <code>vm</code> - the instance itself</p> </li> <li>\n<p><strong>Usage:</strong></p> <p>If a Vue instance didn’t receive the <code>el</code> option at instantiation, it will be in “unmounted” state, without an associated DOM element or fragment. <code>vm.$mount()</code> can be used to manually start the mounting/compilation of an unmounted Vue instance.</p> <p>If no argument is provided, the template will be created as an out-of-document fragment, and you will have to use other DOM instance methods to insert it into the document yourself. If <code>replace</code> option is set to <code>false</code>, then an empty <code>&lt;div&gt;</code> will be automatically created as the wrapper element.</p> <p>Calling <code>$mount()</code> on an already mounted instance will have no effect. The method returns the instance itself so you can chain other instance methods after it.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">var MyComponent = Vue.extend({\n  template: '&lt;div&gt;Hello!&lt;/div&gt;'\n})\n\n// create and mount to #app (will replace #app)\nnew MyComponent().$mount('#app')\n\n// the above is the same as:\nnew MyComponent({ el: '#app' })\n\n// or, compile off-document and append afterwards:\nnew MyComponent().$mount().$appendTo('#container')</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/instance#Lifecycle-Diagram\">Lifecycle Diagram</a></p> </li> </ul> <h3 id=\"vm-destroy\">vm.$destroy( [remove] )</h3> <ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Boolean} [remove] - default: false</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners and, if the <code>remove</code> argument is true, remove its associated DOM element or fragment from the DOM.</p> <p>Triggers the <code>beforeDestroy</code> and <code>destroyed</code> hooks.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/instance#Lifecycle-Diagram\">Lifecycle Diagram</a></p> </li> </ul> <h2 id=\"Directives\">\nDirectives</h2>\n<h3 id=\"v-text\">\nv-text</h3>\n<ul> <li>\n<p><strong>Expects:</strong> <code>String</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Updates the element’s <code>textContent</code>.</p> <p>Internally, <code>{{ Mustache }}</code> interpolations are also compiled as a <code>v-text</code> directive on a textNode. The directive form requires a wrapper element, but offers slightly better performance and avoids FOUC (Flash of Uncompiled Content).</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">&lt;span v-text=\"msg\"&gt;&lt;/span&gt;\n&lt;!-- same as --&gt;\n&lt;span&gt;{{msg}}&lt;/span&gt;</pre> </li> </ul> <h3 id=\"v-html\">\nv-html</h3>\n<ul> <li>\n<p><strong>Expects:</strong> <code>String</code></p> </li> <li>\n<p><strong>Details:</strong></p> <p>Updates the element’s <code>innerHTML</code>. The contents are inserted as plain HTML - data bindings are ignored. If you need to reuse template pieces, you should use <a href=\"#partial\">partials</a>.</p> <p>Internally, <code>{{{ Mustache }}}</code> interpolations are also compiled as a <code>v-html</code> directive using anchor nodes. The directive form requires a wrapper element, but offers slightly better performance and avoids FOUC (Flash of Uncompiled Content).</p> <p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\" target=\"_blank\" rel=\"external\">XSS attacks</a>. Only use <code>v-html</code> on trusted content and <strong>never</strong> on user-provided content.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-html=\"html\"&gt;&lt;/div&gt;\n&lt;!-- same as --&gt;\n&lt;div&gt;{{{html}}}&lt;/div&gt;</pre> </li> </ul> <h3 id=\"v-if\">\nv-if</h3>\n<ul> <li>\n<p><strong>Expects:</strong> <code>*</code></p> </li> <li>\n<p><strong>Usage:</strong></p> <p>Conditionally render the element based on the truthy-ness of the expression value. The element and its contained data bindings / components are destroyed and re-constructed during toggles. If the element is a <code>&lt;template&gt;</code> element, its content will be extracted as the conditional block.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/conditional\">Conditional Rendering</a></p> </li> </ul> <h3 id=\"v-show\">\nv-show</h3>\n<ul> <li>\n<p><strong>Expects:</strong> <code>*</code></p> </li> <li>\n<p><strong>Usage:</strong></p> <p>Toggle’s the element’s <code>display</code> CSS property based on the truthy-ness of the expression value. Triggers transitions if present.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/conditional#v-show\">Conditional Rendering - v-show</a></p> </li> </ul> <h3 id=\"v-else\">\nv-else</h3>\n<ul> <li>\n<p><strong>Does not expect expression</strong></p> </li> <li>\n<p><strong>Restriction:</strong> previous sibling element must have <code>v-if</code> or <code>v-show</code>.</p> </li> <li>\n<p><strong>Usage:</strong></p> <p>Denote the “else block” for <code>v-if</code> and <code>v-show</code>.</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-if=\"Math.random() &gt; 0.5\"&gt;\n  Sorry\n&lt;/div&gt;\n&lt;div v-else&gt;\n  Not sorry\n&lt;/div&gt;</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/conditional#v-else\">Conditional Rendering - v-else</a></p> </li> <li>\n<strong>See also:</strong> <a href=\"../guide/conditional#Component-caveat\">Conditional Rendering - Component caveat</a>\n</li> </ul> <h3 id=\"v-for\">\nv-for</h3>\n<ul> <li>\n<p><strong>Expects:</strong> <code>Array | Object | Number | String</code></p> </li> <li>\n<p><strong>Param Attributes:</strong></p> <ul> <li><a href=\"../guide/list#track-by\"><code>track-by</code></a></li> <li><a href=\"../guide/transitions#Staggering-Transitions\"><code>stagger</code></a></li> <li><a href=\"../guide/transitions#Staggering-Transitions\"><code>enter-stagger</code></a></li> <li><a href=\"../guide/transitions#Staggering-Transitions\"><code>leave-stagger</code></a></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Render the element or template block multiple times based on the source data. The directive’s value must use the special syntax <code>alias (in|of) expression</code> to provide an alias for the current element being iterated on:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-for=\"item in items\"&gt;\n  {{ item.text }}\n&lt;/div&gt;</pre> <p>Note using <code>of</code> as the delimiter is only supported in 1.0.17+.</p> <p>Alternatively, you can also specify an alias for the index (or the key if used on an Object):</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-for=\"(index, item) in items\"&gt;&lt;/div&gt;\n&lt;div v-for=\"(key, val) in object\"&gt;&lt;/div&gt;</pre> <p>The detailed usage for <code>v-for</code> is explained in the guide section linked below.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/list\">List Rendering</a>.</p> </li> </ul> <h3 id=\"v-on\">\nv-on</h3>\n<ul> <li>\n<p><strong>Shorthand:</strong> <code>@</code></p> </li> <li>\n<p><strong>Expects:</strong> <code>Function | Inline Statement</code></p> </li> <li>\n<p><strong>Argument:</strong> <code>event (required)</code></p> </li> <li>\n<p><strong>Modifiers:</strong></p> <ul> <li>\n<code>.stop</code> - call <code>event.stopPropagation()</code>.</li> <li>\n<code>.prevent</code> - call <code>event.preventDefault()</code>.</li> <li>\n<code>.capture</code> - add event listener in capture mode.</li> <li>\n<code>.self</code> - only trigger handler if event was dispatched from this element.</li> <li>\n<code>.{keyCode | keyAlias}</code> - only trigger handler on certain keys.</li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Attaches an event listener to the element. The event type is denoted by the argument. The expression can either be a method name or an inline statement, or simply omitted when there are modifiers present.</p> <p>When used on a normal element, it listens to <strong>native DOM events</strong> only. When used on a custom element component, it also listens to <strong>custom events</strong> emitted on that child component.</p> <p>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special <code>$event</code> property: <code>v-on:click=\"handle('ok', $event)\"</code>.</p> <p><strong>1.0.11+</strong> When listening the custom events, inline statements have access to the special <code>$arguments</code> property, which is an array of the additional arguments passed to the child components’ <code>$emit</code> call.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- method handler --&gt;\n&lt;button v-on:click=\"doThis\"&gt;&lt;/button&gt;\n\n&lt;!-- inline statement --&gt;\n&lt;button v-on:click=\"doThat('hello', $event)\"&gt;&lt;/button&gt;\n\n&lt;!-- shorthand --&gt;\n&lt;button @click=\"doThis\"&gt;&lt;/button&gt;\n\n&lt;!-- stop propagation --&gt;\n&lt;button @click.stop=\"doThis\"&gt;&lt;/button&gt;\n\n&lt;!-- prevent default --&gt;\n&lt;button @click.prevent=\"doThis\"&gt;&lt;/button&gt;\n\n&lt;!-- prevent default without expression --&gt;\n&lt;form @submit.prevent&gt;&lt;/form&gt;\n\n&lt;!-- chain modifiers --&gt;\n&lt;button @click.stop.prevent=\"doThis\"&gt;&lt;/button&gt;\n\n&lt;!-- key modifier using keyAlias --&gt;\n&lt;input @keyup.enter=\"onEnter\"&gt;\n\n&lt;!-- key modifier using keyCode --&gt;\n&lt;input @keyup.13=\"onEnter\"&gt;</pre> <p>Listening to custom events on a child component (the handler is called when “my-event” is emitted on the child):</p> <pre class=\"highlight html\" data-language=\"html\">&lt;my-component @my-event=\"handleThis\"&gt;&lt;/my-component&gt;\n\n&lt;!-- inline statement --&gt;\n&lt;my-component @my-event=\"handleThis(123, $arguments)\"&gt;&lt;/my-component&gt;</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/events\">Methods and Event Handling</a></p> </li> </ul> <h3 id=\"v-bind\">\nv-bind</h3>\n<ul> <li>\n<p><strong>Shorthand:</strong> <code>:</code></p> </li> <li>\n<p><strong>Expects:</strong> <code>* (with argument) | Object (without argument)</code></p> </li> <li>\n<p><strong>Argument:</strong> <code>attrOrProp (optional)</code></p> </li> <li>\n<p><strong>Modifiers:</strong></p> <ul> <li>\n<code>.sync</code> - make the binding two-way. Only respected for prop bindings.</li> <li>\n<code>.once</code> - make the binding one-time. Only respected for prop bindings.</li> <li>\n<code>.camel</code> - convert the attribute name to camelCase when setting it. Only respected for normal attributes. Used for binding camelCase SVG attributes.</li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Dynamically bind one or more attributes, or a component prop to an expression.</p> <p>When used to bind the <code>class</code> or <code>style</code> attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</p> <p>When used for prop binding, the prop must be properly declared in the child component. Prop bindings can specify a different binding type using one of the modifiers.</p> <p>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode <code>class</code> and <code>style</code> does not support Array or Objects.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- bind an attribute --&gt;\n&lt;img v-bind:src=\"imageSrc\"&gt;\n\n&lt;!-- shorthand --&gt;\n&lt;img :src=\"imageSrc\"&gt;\n\n&lt;!-- class binding --&gt;\n&lt;div :class=\"{ red: isRed }\"&gt;&lt;/div&gt;\n&lt;div :class=\"[classA, classB]\"&gt;&lt;/div&gt;\n&lt;div :class=\"[classA, { classB: isB, classC: isC }]\"&gt;\n\n&lt;!-- style binding --&gt;\n&lt;div :style=\"{ fontSize: size + 'px' }\"&gt;&lt;/div&gt;\n&lt;div :style=\"[styleObjectA, styleObjectB]\"&gt;&lt;/div&gt;\n\n&lt;!-- binding an object of attributes --&gt;\n&lt;div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"&gt;&lt;/div&gt;\n\n&lt;!-- prop binding. \"prop\" must be declared in my-component. --&gt;\n&lt;my-component :prop=\"someThing\"&gt;&lt;/my-component&gt;\n\n&lt;!-- two-way prop binding --&gt;\n&lt;my-component :prop.sync=\"someThing\"&gt;&lt;/my-component&gt;\n\n&lt;!-- one-time prop binding --&gt;\n&lt;my-component :prop.once=\"someThing\"&gt;&lt;/my-component&gt;</pre> </li> <li>\n<p><strong>See also:</strong></p> <ul> <li><a href=\"../guide/class-and-style\">Class and Style Bindings</a></li> <li><a href=\"../guide/components#Props\">Component Props</a></li> </ul> </li> </ul> <h3 id=\"v-model\">\nv-model</h3>\n<ul> <li>\n<p><strong>Expects:</strong> varies based on input type</p> </li> <li>\n<p><strong>Limited to:</strong></p> <ul> <li><code>&lt;input&gt;</code></li> <li><code>&lt;select&gt;</code></li> <li><code>&lt;textarea&gt;</code></li> </ul> </li> <li>\n<p><strong>Param Attributes:</strong></p> <ul> <li><a href=\"../guide/forms#lazy\"><code>lazy</code></a></li> <li><a href=\"../guide/forms#number\"><code>number</code></a></li> <li><a href=\"../guide/forms#debounce\"><code>debounce</code></a></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Create a two-way binding on a form input element. For detailed usage, see guide section linked below.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/forms\">Form Input Bindings</a></p> </li> </ul> <h3 id=\"v-ref\">\nv-ref</h3>\n<ul> <li>\n<p><strong>Does not expect expression</strong></p> </li> <li>\n<p><strong>Limited to:</strong> child components</p> </li> <li>\n<p><strong>Argument:</strong> <code>id (required)</code></p> </li> <li>\n<p><strong>Usage:</strong></p> <p>Register a reference to a child component on its parent for direct access. Does not expect an expression. Must provide an argument as the id to register with. The component instance will be accessible on its parent’s <code>$refs</code> object.</p> <p>When used on a component together with <code>v-for</code>, the registered value will be an Array containing all the child component instances corresponding to the Array they are bound to. If the data source for <code>v-for</code> is an Object, the registered value will be an Object containing key-instance pairs mirroring the source Object.</p> </li> <li>\n<p><strong>Note:</strong></p> <p>Because HTML is case-insensitive, camelCase usage like <code>v-ref:someRef</code> will be converted to all lowercase. You can use <code>v-ref:some-ref</code> which properly sets <code>this.$refs.someRef</code>.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">&lt;comp v-ref:child&gt;&lt;/comp&gt;\n&lt;comp v-ref:some-child&gt;&lt;/comp&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">// access from parent:\nthis.$refs.child\nthis.$refs.someChild</pre> <p>With <code>v-for</code>:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;comp v-ref:list v-for=\"item in list\"&gt;&lt;/comp&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">// this will be an array in parent\nthis.$refs.list</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/components#Child-Component-Refs\">Child Component Refs</a></p> </li> </ul> <h3 id=\"v-el\">\nv-el</h3>\n<ul> <li>\n<p><strong>Does not expect expression</strong></p> </li> <li>\n<p><strong>Argument:</strong> <code>id (required)</code></p> </li> <li>\n<p><strong>Usage:</strong></p> <p>Register a reference to a DOM element on its owner Vue instance’s <code>$els</code> object for easier access.</p> </li> <li>\n<p><strong>Note:</strong></p> <p>Because HTML is case-insensitive, camelCase usage like <code>v-el:someEl</code> will be converted to all lowercase. You can use <code>v-el:some-el</code> which properly sets <code>this.$els.someEl</code>.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">&lt;span v-el:msg&gt;hello&lt;/span&gt;\n&lt;span v-el:other-msg&gt;world&lt;/span&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">this.$els.msg.textContent // -&gt; \"hello\"\nthis.$els.otherMsg.textContent // -&gt; \"world\"</pre> </li> </ul> <h3 id=\"v-pre\">\nv-pre</h3>\n<ul> <li>\n<p><strong>Does not expect expression</strong></p> </li> <li>\n<p><strong>Usage</strong></p> <p>Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">&lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;</pre> </li> </ul> <h3 id=\"v-cloak\">\nv-cloak</h3>\n<ul> <li>\n<p><strong>Does not expect expression</strong></p> </li> <li>\n<p><strong>Usage:</strong></p> <p>This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as <code>[v-cloak] { display: none }</code>, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight css\" data-language=\"css\">[v-cloak] {\n  display: none;\n}</pre> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-cloak&gt;\n  {{ message }}\n&lt;/div&gt;</pre> <p>The <code>&lt;div&gt;</code> will not be visible until the compilation is done.</p> </li> </ul> <h2 id=\"Special-Elements\">\nSpecial Elements</h2>\n<h3 id=\"component\">\ncomponent</h3>\n<ul> <li>\n<p><strong>Attributes:</strong></p> <ul> <li><code>is</code></li> </ul> </li> <li>\n<p><strong>Param Attributes:</strong></p> <ul> <li><a href=\"../guide/components#keep-alive\"><code>keep-alive</code></a></li> <li><a href=\"../guide/components#transition-mode\"><code>transition-mode</code></a></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Alternative syntax for invoking components. Primarily used for dynamic components with the <code>is</code> attribute:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- a dynamic component controlled by --&gt;\n&lt;!-- the `componentId` property on the vm --&gt;\n&lt;component :is=\"componentId\"&gt;&lt;/component&gt;</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/components#Dynamic-Components\">Dynamic Components</a></p> </li> </ul> <h3 id=\"slot\">\nslot</h3>\n<ul> <li>\n<p><strong>Attributes:</strong></p> <ul> <li><code>name</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p><code>&lt;slot&gt;</code> elements serve as content distribution outlets in component templates. The slot element itself will be replaced.</p> <p>A slot with the <code>name</code> attribute is called a named slot. A named slot will distribute content with a <code>slot</code> attribute that matches its name.</p> <p>For detailed usage, see the guide section linked below.</p> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/components#Content-Distribution-with-Slots\">Content Distribution with Slots</a></p> </li> </ul> <h3 id=\"partial\">\npartial</h3>\n<ul> <li>\n<p><strong>Attributes:</strong></p> <ul> <li><code>name</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p><code>&lt;partial&gt;</code> elements serve as outlets for registered template partials. Partial contents are also compiled by Vue when inserted. The <code>&lt;partial&gt;</code> element itself will be replaced. It requires a <code>name</code> attribute which will be used to resolve the partial’s content.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight js\" data-language=\"js\">// registering a partial\nVue.partial('my-partial', '&lt;p&gt;This is a partial! {{msg}}&lt;/p&gt;')</pre> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- a static partial --&gt;\n&lt;partial name=\"my-partial\"&gt;&lt;/partial&gt;\n\n&lt;!-- a dynamic partial --&gt;\n&lt;!-- renders partial with id === vm.partialId --&gt;\n&lt;partial v-bind:name=\"partialId\"&gt;&lt;/partial&gt;\n\n&lt;!-- dynamic partial using v-bind shorthand --&gt;\n&lt;partial :name=\"partialId\"&gt;&lt;/partial&gt;</pre> </li> </ul> <h2 id=\"Filters\">\nFilters</h2>\n<h3 id=\"capitalize\">\ncapitalize</h3>\n<ul> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">{{ msg | capitalize }}</pre> <p><em>‘abc’ =&gt; ‘Abc’</em></p> </li> </ul> <h3 id=\"uppercase\">\nuppercase</h3>\n<ul> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">{{ msg | uppercase }}</pre> <p><em>‘abc’ =&gt; ‘ABC’</em></p> </li> </ul> <h3 id=\"lowercase\">\nlowercase</h3>\n<ul> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">{{ msg | lowercase }}</pre> <p><em>‘ABC’ =&gt; ‘abc’</em></p> </li> </ul> <h3 id=\"currency\">\ncurrency</h3>\n<ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} [symbol] - default: '$'</code></li> <li>\n<strong>1.0.22+</strong> <code>{Number} [decimal places] - default: 2</code>\n</li> </ul> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">{{ amount | currency }}</pre> <p><em>12345 =&gt; $12,345.00</em></p> <p>Use a different symbol:</p> <pre class=\"highlight html\" data-language=\"html\">{{ amount | currency '£' }}</pre> <p><em>12345 =&gt; £12,345.00</em></p> <p>Some currencies have 3 or 4 decimal places, while some others have none, for example Japanese Yen (¥) or Vietnamese Dong (₫):</p> <pre class=\"highlight html\" data-language=\"html\">{{ amount | currency '₫' 0 }}</pre> <p><em>12345 =&gt; ₫12,345</em></p> </li> </ul> <h3 id=\"pluralize\">\npluralize</h3>\n<ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String} single, [double, triple, ...]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Pluralizes the argument based on the filtered value. When there is exactly one argument, plural forms simply add an “s” at the end. When there are more than one argument, the arguments will be used as array of strings corresponding to the single, double, triple … forms of the word to be pluralized. When the number to be pluralized exceeds the length of the arguments, it will use the last entry in the array.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">{{count}} {{count | pluralize 'item'}}</pre> <p><em>1 =&gt; ‘1 item’</em><br><em>2 =&gt; ‘2 items’</em></p> <pre class=\"highlight html\" data-language=\"html\">{{date}}{{date | pluralize 'st' 'nd' 'rd' 'th'}}</pre> <p>Will result in:</p> <p><em>1 =&gt; ‘1st’</em><br><em>2 =&gt; ‘2nd’</em><br><em>3 =&gt; ‘3rd’</em><br><em>4 =&gt; ‘4th’</em><br><em>5 =&gt; ‘5th’</em></p> </li> </ul> <h3 id=\"json\">\njson</h3>\n<ul> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Number} [indent] - default: 2</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Output the result of calling <code>JSON.stringify()</code> on the value instead of outputting the <code>toString()</code> value (e.g. <code>[object Object]</code>).</p> </li> <li>\n<p><strong>Example:</strong></p> <p>Print an object with 4-space indent:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;pre&gt;{{ nestedObject | json 4 }}&lt;/pre&gt;</pre> </li> </ul> <h3 id=\"debounce\">\ndebounce</h3>\n<ul> <li>\n<p><strong>Limited to:</strong> directives that expect <code>Function</code> values, e.g. <code>v-on</code></p> </li> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Number} [wait] - default: 300</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Wrap the handler to debounce it for <code>x</code> milliseconds, where <code>x</code> is the argument. Default wait time is 300ms. A debounced handler will be delayed until at least <code>x</code> ms has passed after the call moment; if the handler is called again before the delay period, the delay period is reset to <code>x</code> ms.</p> </li> <li>\n<p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">&lt;input @keyup=\"onKeyup | debounce 500\"&gt;</pre> </li> </ul> <h3 id=\"limitBy\">\nlimitBy</h3>\n<ul> <li>\n<p><strong>Limited to:</strong> directives that expect <code>Array</code> values, e.g. <code>v-for</code></p> </li> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{Number} limit</code></li> <li><code>{Number} [offset]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Limit the array to the first N items, as specified by the argument. An optional second argument can be provided to set a starting offset.</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- only display first 10 items --&gt;\n&lt;div v-for=\"item in items | limitBy 10\"&gt;&lt;/div&gt;\n\n&lt;!-- display items 5 to 15 --&gt;\n&lt;div v-for=\"item in items | limitBy 10 5\"&gt;&lt;/div&gt;</pre> </li> </ul> <h3 id=\"filterBy\">\nfilterBy</h3>\n<ul> <li>\n<p><strong>Limited to:</strong> directives that expect <code>Array</code> values, e.g. <code>v-for</code></p> </li> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String | Function} targetStringOrFunction</code></li> <li><code>\"in\" (optional delimiter)</code></li> <li><code>{String} [...searchKeys]</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Return a filtered version of the source Array. The first argument can either be a string or a function.</p> <p>When the first argument is a string, it will be used as the target string to search for in each element of the Array:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-for=\"item in items | filterBy 'hello'\"&gt;</pre> <p>In the above example, only items that contain the target string <code>\"hello\"</code> will be displayed.</p> <p>If the item is an object, the filter will recursively search every nested property of the object for the target string. To narrow down the search scope, additional search keys can be specified:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-for=\"user in users | filterBy 'Jack' in 'name'\"&gt;</pre> <p>In the above example, the filter will only search for <code>\"Jack\"</code> in the <code>name</code> field of each user object. <strong>It is a good idea to always limit the search scope for better performance.</strong></p> <p>The examples above are using static arguments - we can, of course, use dynamic arguments as target string or search keys. Combined with <code>v-model</code> we can easily implement type-ahead filtering:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"filter-by-example\"&gt;\n  &lt;input v-model=\"name\"&gt;\n  &lt;ul&gt;\n    &lt;li v-for=\"user in users | filterBy name in 'name'\"&gt;\n      {{ user.name }}\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#filter-by-example',\n  data: {\n    name: '',\n    users: [\n      { name: 'Bruce' },\n      { name: 'Chuck' },\n      { name: 'Jackie' }\n    ]\n  }\n})</pre>   </li> <li>\n<p><strong>Additional Examples:</strong></p> <p>Multiple search keys:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;li v-for=\"user in users | filterBy searchText in 'name' 'phone'\"&gt;&lt;/li&gt;</pre> <p>Multiple search keys with a dynamic Array argument:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- fields = ['fieldA', 'fieldB'] --&gt;\n&lt;div v-for=\"user in users | filterBy searchText in fields\"&gt;</pre> <p>Use a custom filter function:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div v-for=\"user in users | filterBy myCustomFilterFunction\"&gt;</pre> </li> </ul> <h3 id=\"orderBy\">\norderBy</h3>\n<ul> <li>\n<p><strong>Limited to:</strong> directives that expect <code>Array</code> values, e.g. <code>v-for</code></p> </li> <li>\n<p><strong>Arguments:</strong></p> <ul> <li><code>{String | Array&lt;String&gt; | Function} ...sortKeys</code></li> <li><code>{String} [order] - default: 1</code></li> </ul> </li> <li>\n<p><strong>Usage:</strong></p> <p>Return a sorted version of the source Array. You can pass any number of Strings to sort on keys. You can also pass an array containing the sorting keys or a Function if you want to use your own sorting strategy instead. The optional <code>order</code> argument specifies whether the result should be in ascending (<code>order &gt;= 0</code>) or descending (<code>order &lt; 0</code>) order.</p> <p>For arrays of primitive values, simply omit <code>sortKeys</code> and provide the order, e.g. <code>orderBy 1</code>.</p> </li> <li>\n<p><strong>Example:</strong></p> <p>Sort users by name:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;ul&gt;\n  &lt;li v-for=\"user in users | orderBy 'name'\"&gt;\n    {{ user.name }}\n  &lt;/li&gt;\n&lt;/ul&gt;</pre> <p>In descending order:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;ul&gt;\n  &lt;li v-for=\"user in users | orderBy 'name' -1\"&gt;\n    {{ user.name }}\n  &lt;/li&gt;\n&lt;/ul&gt;</pre> <p>Sort primitive values:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;ul&gt;\n  &lt;li v-for=\"n in numbers | orderBy true\"&gt;\n    {{ n }}\n  &lt;/li&gt;\n&lt;/ul&gt;</pre> <p>Dynamic sort order:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"orderby-example\"&gt;\n  &lt;button @click=\"order = order * -1\"&gt;Reverse Sort Order&lt;/button&gt;\n  &lt;ul&gt;\n    &lt;li v-for=\"user in users | orderBy 'name' order\"&gt;\n      {{ user.name }}\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#orderby-example',\n  data: {\n    order: 1,\n    users: [{ name: 'Bruce' }, { name: 'Chuck' }, { name: 'Jackie' }]\n  }\n})</pre> <p>Sort using two keys:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;ul&gt;\n  &lt;li v-for=\"user in users | orderBy 'lastName' 'firstName'\"&gt;\n    {{ user.lastName }} {{ user.firstName }}\n  &lt;/li&gt;\n&lt;/ul&gt;</pre>   <p>Sort using a Function:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"orderby-compare-example\" class=\"demo\"&gt;\n  &lt;button @click=\"order = order * -1\"&gt;Reverse Sort Order&lt;/button&gt;\n  &lt;ul&gt;\n    &lt;li v-for=\"user in users | orderBy ageByTen order\"&gt;\n      {{ user.name }} - {{ user.age }}\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: '#orderby-compare-example',\n  data: {\n    order: 1,\n    users: [\n      {\n        name: 'Jackie',\n        age: 62\n      },\n      {\n        name: 'Chuck',\n        age: 76\n      },\n      {\n        name: 'Bruce',\n        age: 61\n      }\n    ]\n  },\n  methods: {\n    ageByTen: function (a, b) {\n      return Math.floor(a.age / 10) - Math.floor(b.age / 10)\n    }\n  }\n})</pre>   </li> </ul> <h2 id=\"Array-Extension-Methods\">\nArray Extension Methods</h2>\n<p>Vue.js extends <code>Array.prototype</code> with two additional methods that makes it easier to perform some common Array operations while ensuring reactive updates are properly triggered.</p> <h3 id=\"array-set-index-value\">\narray.$set(index, value)</h3>\n<ul> <li>\n<p><strong>Arguments</strong></p> <ul> <li><code>{Number} index</code></li> <li><code>{*} value</code></li> </ul> </li> <li>\n<p><strong>Usage</strong></p> <p>Set an element in the array to a value by index and trigger view updates.</p> <pre class=\"highlight js\" data-language=\"js\">vm.animals.$set(0, { name: 'Aardvark' })</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/list#Caveats\">Array Detection Caveats</a></p> </li> </ul> <h3 id=\"array-remove-reference\">\narray.$remove(reference)</h3>\n<ul> <li>\n<p><strong>Arguments</strong></p> <ul> <li><code>{Reference} reference</code></li> </ul> </li> <li>\n<p><strong>Usage</strong></p> <p>Remove an element from an array by reference and trigger view updates. This is a sugar method for first searching for the element in the array, and then if found, calling <code>array.splice(index, 1)</code>.</p> <pre class=\"highlight js\" data-language=\"js\">var aardvark = vm.animals[0]\nvm.animals.$remove(aardvark)</pre> </li> <li>\n<p><strong>See also:</strong> <a href=\"../guide/list#Mutation-Methods\">Mutation Methods</a></p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/api/\" class=\"_attribution-link\">https://vuejs.org/api/</a>\n  </p>\n</div>\n","guide/application":"<h1>Building Large-Scale Apps</h1> <blockquote> <p><strong>NEW:</strong> Get up and running with single file Vue components, hot-reload, lint-on-save and unit testing in minutes with <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"external\">vue-cli</a>!</p> </blockquote> <p>The Vue.js core library is designed to be focused and flexible - it’s just a view layer library that doesn’t enforce any application-level architecture. While this can be great for integrating with existing projects, it could be a challenge for those with less experience to build larger scale applications from scratch.</p> <p>The Vue.js ecosystem provides a set of tools and libraries on how to build large SPAs with Vue. This part is where we start get a bit “framework”-ish, but it’s really just an opinionated list of recommendations; you still get to pick what to use for each part of the stack.</p> <h2 id=\"Modularization\">\nModularization</h2>\n<p>For large projects it’s necessary to utilize a modularized build system to better organize your code. The recommended approach of doing so is by writing your source code in CommonJS or ES6 modules and bundle them using <a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"external\">Webpack</a> or <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"external\">Browserify</a>.</p> <p>Webpack and Browserify are more than just module bundlers, though. They both provide source transform APIs that allow you to transform your source code with other pre-processors. For example, you can write your code with future ES2015/2016 syntax using <a href=\"https://github.com/babel/babel-loader\" target=\"_blank\" rel=\"external\">babel-loader</a> or <a href=\"https://github.com/babel/babelify\" target=\"_blank\" rel=\"external\">babelify</a>.</p> <p>If you’ve never used them before, I highly recommend going through a few tutorials to get familiar with the concept of module bundlers, and start writing JavaScript using the latest ECMAScript features.</p> <h2 id=\"Single-File-Components\">\nSingle File Components</h2>\n<p>In a typical Vue.js project we will be dividing our interface into many small components, and it would be nice to have each component encapsulate its CSS styles, template and JavaScript definition in the same place. As mentioned above, when using Webpack or Browserify, with proper source transforms we can write our components like this:</p> <p><img src=\"https://vuejs.org/images/vue-component.png\"></p> <p>If you are into pre-processors, you can even do this:</p> <p><img src=\"https://vuejs.org/images/vue-component-with-pre-processors.png\"></p> <p>You can build these single-file Vue components with Webpack + <a href=\"https://github.com/vuejs/vue-loader\" target=\"_blank\" rel=\"external\">vue-loader</a> or Browserify + <a href=\"https://github.com/vuejs/vueify\" target=\"_blank\" rel=\"external\">vueify</a>. You can also play with it online at <a href=\"http://www.webpackbin.com/vue\" target=\"_blank\" rel=\"external\">Webpackbin.com</a>!</p> <p>Which build tool to choose is largely dependent on your experience and needs. Webpack-based setup offers more powerful features such as code splitting, processing static assets as module dependencies and extracting component CSS into a separate file, but can be a bit more complex to configure. Browserify can be easier to setup in scenarios where you don’t need the advanced features that Webpack offers.</p> <p>The fastest way to get up and running with a pre-configured build setup is using the official <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"external\">vue-cli</a>. You can also find the official scaffold templates on GitHub:</p> <ul> <li><a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"external\">Webpack + vue-loader</a></li> <li><a href=\"https://github.com/vuejs-templates/browserify\" target=\"_blank\" rel=\"external\">Browserify + vueify</a></li> </ul> <h2 id=\"Routing\">\nRouting</h2>\n<p>For Single Page Applications, it is recommended to use the <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"external\">official vue-router library</a>, which is currently in technical preview. For more details, please refer to vue-router’s <a href=\"http://vuejs.github.io/vue-router/\" target=\"_blank\" rel=\"external\">documentation</a>.</p> <p>If you just need some very simple routing logic, you can also implement it by manually listening on <code>hashchange</code> and utilizing a dynamic component:</p> <p><strong>Example:</strong></p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;component :is=\"currentView\"&gt;&lt;/component&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">Vue.component('home', { /* ... */ })\nVue.component('page1', { /* ... */ })\nvar app = new Vue({\n  el: '#app',\n  data: {\n    currentView: 'home'\n  }\n})\n// Switching pages in your route handler:\napp.currentView = 'page1'</pre> <p>With this mechanism it’s also very easy to leverage external routing libraries such as <a href=\"https://github.com/visionmedia/page.js\" target=\"_blank\" rel=\"external\">Page.js</a> or <a href=\"https://github.com/flatiron/director\" target=\"_blank\" rel=\"external\">Director</a>.</p> <h2 id=\"Communication-with-Server\">\nCommunication with Server</h2>\n<p>All Vue instances can have their raw <code>$data</code> directly serialized with <code>JSON.stringify()</code> with no additional effort. The community has contributed the <a href=\"https://github.com/vuejs/vue-resource\" target=\"_blank\" rel=\"external\">vue-resource</a> plugin, which provides an easy way to work with RESTful APIs. You can also use any Ajax library you like, e.g. <code>$.ajax</code> or <a href=\"https://github.com/visionmedia/superagent\" target=\"_blank\" rel=\"external\">SuperAgent</a>. Vue.js also plays nicely with no-backend services such as Firebase and Parse.</p> <h2 id=\"State-Management\">\nState Management</h2>\n<p>In large applications, state management often becomes complex due to multiple pieces of state scattered across many components and the interactions between them. It is often overlooked that the source of truth in Vue.js applications is the raw data object - a Vue instance simply proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you should avoid duplicating it. Instead, share it by identity:</p> <pre class=\"highlight js\" data-language=\"js\">var sourceOfTruth = {}\n\nvar vmA = new Vue({\n  data: sourceOfTruth\n})\n\nvar vmB = new Vue({\n  data: sourceOfTruth\n})</pre> <p>Now whenever <code>sourceOfTruth</code> is mutated, both <code>vmA</code> and <code>vmB</code> will update their views automatically. Extending this idea further, we would arrive at the <strong>store pattern</strong>:</p> <pre class=\"highlight js\" data-language=\"js\">var store = {\n  state: {\n    message: 'Hello!'\n  },\n  actionA: function () {\n    this.state.message = 'action A triggered'\n  },\n  actionB: function () {\n    this.state.message = 'action B triggered'\n  }\n}\n\nvar vmA = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n\nvar vmB = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})</pre> <p>Notice we are putting all actions that mutate the store’s state inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen to the state, and how are they triggered. Each component can still own and manage its private state.</p> <p><img src=\"https://vuejs.org/images/state.png\" alt=\"State Management\"></p> <p>One thing to take note is that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for the mutations to be observed.</p> <p>If we enforce a convention where components are never allowed to directly mutate state that belongs to a store, but should instead dispatch events that notify the store to perform actions, we’ve essentially arrived at the <a href=\"https://facebook.github.io/flux/\" target=\"_blank\" rel=\"external\">Flux</a> architecture. The benefit of this convention is we can record all state mutations happening to the store, and on top of that we can implement advanced debugging helpers such as mutation logs, snapshots, history re-rolls, etc.</p> <p>The Flux architecture is commonly used in React applications, but it can be applied to Vue.js application as well. For example, <a href=\"https://github.com/vuejs/vuex/\" target=\"_blank\" rel=\"external\">Vuex</a> is a Flux-inspired application architecture that is designed specifically for managing state inside large Vue.js applications. <a href=\"https://github.com/rackt/redux/\" target=\"_blank\" rel=\"external\">Redux</a>, the most popular Flux implementation for React, is view-layer agnostic and can also easily work with Vue via some <a href=\"https://github.com/egoist/revue\" target=\"_blank\" rel=\"external\">simple bindings</a>.</p> <h2 id=\"Unit-Testing\">\nUnit Testing</h2>\n<p>Anything compatible with a module-based build system works. A recommendation is using the <a href=\"http://karma-runner.github.io/0.12/index.html\" target=\"_blank\" rel=\"external\">Karma</a> test runner. It has a lot of community plugins, including support for <a href=\"https://github.com/webpack/karma-webpack\" target=\"_blank\" rel=\"external\">Webpack</a> and <a href=\"https://github.com/Nikku/karma-browserify\" target=\"_blank\" rel=\"external\">Browserify</a>. For detailed setup, please refer to each project’s respective documentation.</p> <p>In terms of code structure for testing, the best practice is to export raw options / functions in your component modules. Consider this example:</p> <pre class=\"highlight js\" data-language=\"js\">// my-component.js\nmodule.exports = {\n  template: '&lt;span&gt;{{msg}}&lt;/span&gt;',\n  data: function () {\n    return {\n      msg: 'hello!'\n    }\n  },\n  created: function () {\n    console.log('my-component created!')\n  }\n}</pre> <p>You can use that file in your entry module like this:</p> <pre class=\"highlight js\" data-language=\"js\">// main.js\nvar Vue = require('vue')\nvar app = new Vue({\n  el: '#app',\n  data: { /* ... */ },\n  components: {\n    'my-component': require('./my-component')\n  }\n})</pre> <p>And you can test that module like this:</p> <pre class=\"highlight js\" data-language=\"js\">// Some Jasmine 2.0 tests\ndescribe('my-component', function () {\n  // require source module\n  var myComponent = require('../src/my-component')\n  it('should have a created hook', function () {\n    expect(typeof myComponent.created).toBe('function')\n  })\n  it('should set correct default data', function () {\n    expect(typeof myComponent.data).toBe('function')\n    var defaultData = myComponent.data()\n    expect(defaultData.msg).toBe('hello!')\n  })\n})</pre> <p>There are example Karma configurations for both <a href=\"https://github.com/vuejs/vue-loader-example/blob/master/build/karma.conf.js\" target=\"_blank\" rel=\"external\">Webpack</a> and <a href=\"https://github.com/vuejs/vueify-example/blob/master/karma.conf.js\" target=\"_blank\" rel=\"external\">Browserify</a>.</p> <p class=\"tip\">Since Vue.js directives perform updates asynchronously, when you are asserting DOM state after changing the data, you will have to do so in a <code>Vue.nextTick</code> callback.</p> <h2 id=\"Deploying-for-Production\">\nDeploying for Production</h2>\n<p>The minified standalone build of Vue.js has already stripped out all the warnings for you for a smaller file size, but when you are using tools like Browserify or Webpack to build Vue.js applications, you will need some additional configuration to achieve this.</p> <h3 id=\"Webpack\">\nWebpack</h3>\n<p>Use Webpack’s <a href=\"http://webpack.github.io/docs/list-of-plugins.html#defineplugin\" target=\"_blank\" rel=\"external\">DefinePlugin</a> to indicate a production environment, so that warning blocks can be automatically dropped by UglifyJS during minification. Example config:</p> <pre class=\"highlight js\" data-language=\"js\">var webpack = require('webpack')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    // ...\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: '\"production\"'\n      }\n    }),\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        warnings: false\n      }\n    })\n  ]\n}</pre> <h3 id=\"Browserify\">\nBrowserify</h3>\n<p>Just run your bundling command with <code>NODE_ENV</code> set to <code>\"production\"</code>. Vue automatically applies <a href=\"https://github.com/hughsk/envify\" target=\"_blank\" rel=\"external\">envify</a> transform to itself and makes warning blocks unreachable. For example:</p> <pre class=\"highlight bash\" data-language=\"bash\">NODE_ENV=production browserify -e main.js | uglifyjs -c -m &gt; build.js</pre> <h2 id=\"An-App-Example\">\nAn App Example</h2>\n<p>The <a href=\"https://github.com/vuejs/vue-hackernews\" target=\"_blank\" rel=\"external\">Vue.js Hackernews Clone</a> is an example application that uses Webpack + vue-loader for code organization, vue-router for routing, and HackerNews’ official Firebase API as the backend. It’s by no means a big application, but it demonstrates the combined usage of the concepts discussed on this page.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/application.html\" class=\"_attribution-link\">https://vuejs.org/guide/application.html</a>\n  </p>\n</div>\n","guide/components":"<h1>Components</h1> <h2 id=\"What-are-Components\">\nWhat are Components?</h2>\n<p>Components are one of the most powerful features of Vue.js. They help you extend basic HTML elements to encapsulate reusable code. At a high level, Components are custom elements that Vue.js’ compiler would attach specified behavior to. In some cases, they may also appear as a native HTML element extended with the special <code>is</code> attribute.</p> <h2 id=\"Using-Components\">\nUsing Components</h2>\n<h3 id=\"Registration\">\nRegistration</h3>\n<p>We’ve learned in the previous sections that we can create a component constructor using <code>Vue.extend()</code>:</p> <pre class=\"highlight js\" data-language=\"js\">var MyComponent = Vue.extend({\n  // options...\n})</pre> <p>To use this constructor as a component, you need to <strong>register</strong> it with <code>Vue.component(tag, constructor)</code>:</p> <pre class=\"highlight js\" data-language=\"js\">// Globally register the component with tag: my-component\nVue.component('my-component', MyComponent)</pre> <p class=\"tip\">Note that Vue.js does not enforce the <a href=\"http://www.w3.org/TR/custom-elements/#concepts\" target=\"_blank\" rel=\"external\">W3C rules</a> for custom tag-names (all-lowercase, must contain a hyphen) though following this convention is considered good practice.</p> <p>Once registered, the component can now be used in a parent instance’s template as a custom element, <code>&lt;my-component&gt;</code>. Make sure the component is registered <strong>before</strong> you instantiate your root Vue instance. Here’s the full example:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"example\"&gt;\n  &lt;my-component&gt;&lt;/my-component&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">// define\nvar MyComponent = Vue.extend({\n  template: '&lt;div&gt;A custom component!&lt;/div&gt;'\n})\n\n// register\nVue.component('my-component', MyComponent)\n\n// create a root instance\nnew Vue({\n  el: '#example'\n})</pre> <p>Which will render:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"example\"&gt;\n  &lt;div&gt;A custom component!&lt;/div&gt;\n&lt;/div&gt;</pre>   <p>Note the component’s template <strong>replaces</strong> the custom element, which only serves as a <strong>mounting point</strong>. This behavior can be configured using the <code>replace</code> instance option.</p> <h3 id=\"Local-Registration\">\nLocal Registration</h3>\n<p>You don’t have to register every component globally. You can make a component available only in the scope of another component by registering it with the <code>components</code> instance option:</p> <pre class=\"highlight js\" data-language=\"js\">var Child = Vue.extend({ /* ... */ })\n\nvar Parent = Vue.extend({\n  template: '...',\n  components: {\n    // &lt;my-component&gt; will only be available in Parent's template\n    'my-component': Child\n  }\n})</pre> <p>The same encapsulation applies for other assets types such as directives, filters and transitions.</p> <h3 id=\"Registration-Sugar\">\nRegistration Sugar</h3>\n<p>To make things easier, you can directly pass in the options object instead of an actual constructor to <code>Vue.component()</code> and the <code>component</code> option. Vue.js will automatically call <code>Vue.extend()</code> for you under the hood:</p> <pre class=\"highlight js\" data-language=\"js\">// extend and register in one step\nVue.component('my-component', {\n  template: '&lt;div&gt;A custom component!&lt;/div&gt;'\n})\n\n// also works for local registration\nvar Parent = Vue.extend({\n  components: {\n    'my-component': {\n      template: '&lt;div&gt;A custom component!&lt;/div&gt;'\n    }\n  }\n})</pre> <h3 id=\"Component-Option-Caveats\">\nComponent Option Caveats</h3>\n<p>Most of the options that can be passed into the Vue constructor can be used in <code>Vue.extend()</code>, with two special cases: <code>data</code> and <code>el</code>. Imagine we simply pass an object as <code>data</code> to <code>Vue.extend()</code>:</p> <pre class=\"highlight js\" data-language=\"js\">var data = { a: 1 }\nvar MyComponent = Vue.extend({\n  data: data\n})</pre> <p>The problem with this is that the same <code>data</code> object will be shared across all instances of <code>MyComponent</code>! This is most likely not what we want, so we should use a function that returns a fresh object as the <code>data</code> option:</p> <pre class=\"highlight js\" data-language=\"js\">var MyComponent = Vue.extend({\n  data: function () {\n    return { a: 1 }\n  }\n})</pre> <p>The <code>el</code> option also requires a function value when used in <code>Vue.extend()</code>, for exactly the same reason.</p> <h3 id=\"Template-Parsing\">\nTemplate Parsing</h3>\n<p>Vue.js template engine is DOM-based and uses native parser that comes with the browser instead of providing a custom one. There are benefits to this approach when compared to string-based template engines, but there are also caveats. Templates have to be individually valid pieces of HTML. Some HTML elements have restrictions on what elements can appear inside them. Most common of these restrictions are:</p> <ul> <li>\n<code>a</code> can not contain other interactive elements (e.g. buttons and other links)</li> <li>\n<code>li</code> should be a direct child of <code>ul</code> or <code>ol</code>, and both <code>ul</code> and <code>ol</code> can only contain <code>li</code>\n</li> <li>\n<code>option</code> should be a direct child of <code>select</code>, and <code>select</code> can only contain <code>option</code> (and <code>optgroup</code>)</li> <li>\n<code>table</code> can only contain <code>thead</code>, <code>tbody</code>, <code>tfoot</code> and <code>tr</code>, and these elements should be direct children of <code>table</code>\n</li> <li>\n<code>tr</code> can only contain <code>th</code> and <code>td</code>, and these elements should be direct children of <code>tr</code>\n</li> </ul> <p>In practice these restriction can cause unexpected behavior. Although in simple cases it might appear to work, you can not rely on custom elements being expanded before browser validation. E.g. <code>&lt;my-select&gt;&lt;option&gt;...&lt;/option&gt;&lt;/my-select&gt;</code> is not a valid template even if <code>my-select</code> component eventually expands to <code>&lt;select&gt;...&lt;/select&gt;</code>.</p> <p>Another consequence is that you can not use custom tags (including custom elements and special tags like <code>&lt;component&gt;</code>, <code>&lt;template&gt;</code> and <code>&lt;partial&gt;</code>) inside of <code>ul</code>, <code>select</code>, <code>table</code> and other elements with similar restrictions. Custom tags will be hoisted out and thus not render properly.</p> <p>In case of a custom element you should use the <code>is</code> special attribute:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;table&gt;\n  &lt;tr is=\"my-component\"&gt;&lt;/tr&gt;\n&lt;/table&gt;</pre> <p>In case of a <code>&lt;template&gt;</code> inside of a <code>&lt;table&gt;</code> you should use <code>&lt;tbody&gt;</code>, as tables are allowed to have multiple <code>tbody</code>:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;table&gt;\n  &lt;tbody v-for=\"item in items\"&gt;\n    &lt;tr&gt;Even row&lt;/tr&gt;\n    &lt;tr&gt;Odd row&lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;</pre> <h2 id=\"Props\">\nProps</h2>\n<h3 id=\"Passing-Data-with-Props\">\nPassing Data with Props</h3>\n<p>Every component instance has its own <strong>isolated scope</strong>. This means you cannot (and should not) directly reference parent data in a child component’s template. Data can be passed down to child components using <strong>props</strong>.</p> <p>A “prop” is a field on a component’s data that is expected to be passed down from its parent component. A child component needs to explicitly declare the props it expects to receive using the <a href=\"../api/index#props\"><code>props</code> option</a>:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.component('child', {\n  // declare the props\n  props: ['msg'],\n  // the prop can be used inside templates, and will also\n  // be set as `this.msg`\n  template: '&lt;span&gt;{{ msg }}&lt;/span&gt;'\n})</pre> <p>Then, we can pass a plain string to it like so:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;child msg=\"hello!\"&gt;&lt;/child&gt;</pre> <p><strong>Result:</strong></p>   <h3 id=\"camelCase-vs-kebab-case\">\ncamelCase vs. kebab-case</h3>\n<p>HTML attributes are case-insensitive. When using camelCased prop names as attributes, you need to use their kebab-case (hyphen-delimited) equivalents:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.component('child', {\n  // camelCase in JavaScript\n  props: ['myMessage'],\n  template: '&lt;span&gt;{{ myMessage }}&lt;/span&gt;'\n})</pre> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- kebab-case in HTML --&gt;\n&lt;child my-message=\"hello!\"&gt;&lt;/child&gt;</pre> <h3 id=\"Dynamic-Props\">\nDynamic Props</h3>\n<p>Similar to binding a normal attribute to an expression, we can also use <code>v-bind</code> for dynamically binding props to data on the parent. Whenever the data is updated in the parent, it will also flow down to the child:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div&gt;\n  &lt;input v-model=\"parentMsg\"&gt;\n  &lt;br&gt;\n  &lt;child v-bind:my-message=\"parentMsg\"&gt;&lt;/child&gt;\n&lt;/div&gt;</pre> <p>It is often simpler to use the shorthand syntax for <code>v-bind</code>:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;child :my-message=\"parentMsg\"&gt;&lt;/child&gt;</pre> <p><strong>Result:</strong></p>   <h3 id=\"Literal-vs-Dynamic\">\nLiteral vs. Dynamic</h3>\n<p>A common mistake beginners tend to make is attempting to pass down a number using the literal syntax:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- this passes down a plain string \"1\" --&gt;\n&lt;comp some-prop=\"1\"&gt;&lt;/comp&gt;</pre> <p>However, since this is a literal prop, its value is passed down as a plain string <code>\"1\"</code>, instead of an actual number. If we want to pass down an actual JavaScript number, we need to use the dynamic syntax to make its value be evaluated as a JavaScript expression:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- this passes down an actual number --&gt;\n&lt;comp :some-prop=\"1\"&gt;&lt;/comp&gt;</pre> <h3 id=\"Prop-Binding-Types\">\nProp Binding Types</h3>\n<p>By default, all props form a <strong>one-way-down</strong> binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This default is meant to prevent child components from accidentally mutating the parent’s state, which can make your app’s data flow harder to reason about. However, it is also possible to explicitly enforce a two-way or a one-time binding with the <code>.sync</code> and <code>.once</code> <strong>binding type modifiers</strong>:</p> <p>Compare the syntax:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- default, one-way-down binding --&gt;\n&lt;child :msg=\"parentMsg\"&gt;&lt;/child&gt;\n\n&lt;!-- explicit two-way binding --&gt;\n&lt;child :msg.sync=\"parentMsg\"&gt;&lt;/child&gt;\n\n&lt;!-- explicit one-time binding --&gt;\n&lt;child :msg.once=\"parentMsg\"&gt;&lt;/child&gt;</pre> <p>The two-way binding will sync the change of child’s <code>msg</code> property back to the parent’s <code>parentMsg</code> property. The one-time binding, once set up, will not sync future changes between the parent and the child.</p> <p class=\"tip\">Note that if the prop being passed down is an Object or an Array, it is passed by reference. Mutating the Object or Array itself inside the child <strong>will</strong> affect parent state, regardless of the binding type you are using.</p> <h3 id=\"Prop-Validation\">\nProp Validation</h3>\n<p>It is possible for a component to specify the requirements for the props it is receiving. This is useful when you are authoring a component that is intended to be used by others, as these prop validation requirements essentially constitute your component’s API, and ensure your users are using your component correctly. Instead of defining the props as an array of strings, you can use the object hash format that contain validation requirements:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.component('example', {\n  props: {\n    // basic type check (`null` means accept any type)\n    propA: Number,\n    // multiple possible types (1.0.21+)\n    propM: [String, Number],\n    // a required string\n    propB: {\n      type: String,\n      required: true\n    },\n    // a number with default value\n    propC: {\n      type: Number,\n      default: 100\n    },\n    // object/array defaults should be returned from a\n    // factory function\n    propD: {\n      type: Object,\n      default: function () {\n        return { msg: 'hello' }\n      }\n    },\n    // indicate this prop expects a two-way binding. will\n    // raise a warning if binding type does not match.\n    propE: {\n      twoWay: true\n    },\n    // custom validator function\n    propF: {\n      validator: function (value) {\n        return value &gt; 10\n      }\n    },\n    // coerce function (new in 1.0.12)\n    // cast the value before setting it on the component\n    propG: {\n      coerce: function (val) {\n        return val + '' // cast the value to string\n      }\n    },\n    propH: {\n      coerce: function (val) {\n        return JSON.parse(val) // cast the value to Object\n      }\n    }\n  }\n})</pre> <p>The <code>type</code> can be one of the following native constructors:</p> <ul> <li>String</li> <li>Number</li> <li>Boolean</li> <li>Function</li> <li>Object</li> <li>Array</li> </ul> <p>In addition, <code>type</code> can also be a custom constructor function and the assertion will be made with an <code>instanceof</code> check.</p> <p>When a prop validation fails, Vue will refuse to set the value on the child component, and throw a warning if using the development build.</p> <h2 id=\"Parent-Child-Communication\">\nParent-Child Communication</h2>\n<h3 id=\"Parent-Chain\">\nParent Chain</h3>\n<p>A child component holds access to its parent component as <code>this.$parent</code>. A root Vue instance will be available to all of its descendants as <code>this.$root</code>. Each parent component has an array, <code>this.$children</code>, which contains all its child components.</p> <p>Although it’s possible to access any instance in the parent chain, you should avoid directly relying on parent data in a child component and prefer passing data down explicitly using props. In addition, it is a very bad idea to mutate parent state from a child component, because:</p> <ol> <li>\n<p>It makes the parent and child tightly coupled;</p> </li> <li>\n<p>It makes the parent state much harder to reason about when looking at it alone, because its state may be modified by any child! Ideally, only a component itself should be allowed to modify its own state.</p> </li> </ol> <h3 id=\"Custom-Events\">\nCustom Events</h3>\n<p>All Vue instances implement a custom event interface that facilitates communication within a component tree. This event system is independent from the native DOM events and works differently.</p> <p>Each Vue instance is an event emitter that can:</p> <ul> <li>\n<p>Listen to events using <code>$on()</code>;</p> </li> <li>\n<p>Trigger events on self using <code>$emit()</code>;</p> </li> <li>\n<p>Dispatch an event that propagates upward along the parent chain using <code>$dispatch()</code>;</p> </li> <li>\n<p>Broadcast an event that propagates downward to all descendants using <code>$broadcast()</code>.</p> </li> </ul> <p class=\"tip\">Unlike DOM events, Vue events will automatically stop propagation after triggering callbacks for the first time along a propagation path, unless the callback explicitly returns <code>true</code>.</p> <p>A simple example:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- template for child --&gt;\n&lt;template id=\"child-template\"&gt;\n  &lt;input v-model=\"msg\"&gt;\n  &lt;button v-on:click=\"notify\"&gt;Dispatch Event&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;!-- template for parent --&gt;\n&lt;div id=\"events-example\"&gt;\n  &lt;p&gt;Messages: {{ messages | json }}&lt;/p&gt;\n  &lt;child&gt;&lt;/child&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">// register child, which dispatches an event with\n// the current message\nVue.component('child', {\n  template: '#child-template',\n  data: function () {\n    return { msg: 'hello' }\n  },\n  methods: {\n    notify: function () {\n      if (this.msg.trim()) {\n        this.$dispatch('child-msg', this.msg)\n        this.msg = ''\n      }\n    }\n  }\n})\n\n// bootstrap parent, which pushes message into an array\n// when receiving the event\nvar parent = new Vue({\n  el: '#events-example',\n  data: {\n    messages: []\n  },\n  // the `events` option simply calls `$on` for you\n  // when the instance is created\n  events: {\n    'child-msg': function (msg) {\n      // `this` in event callbacks are automatically bound\n      // to the instance that registered it\n      this.messages.push(msg)\n    }\n  }\n})</pre>    <h3 id=\"v-on-for-Custom-Events\">\nv-on for Custom Events</h3>\n<p>The example above is pretty nice, but when we are looking at the parent’s code, it’s not so obvious where the <code>\"child-msg\"</code> event comes from. It would be better if we can declare the event handler in the template, right where the child component is used. To make this possible, <code>v-on</code> can be used to listen for custom events when used on a child component:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;child v-on:child-msg=\"handleIt\"&gt;&lt;/child&gt;</pre> <p>This makes things very clear: when the child triggers the <code>\"child-msg\"</code> event, the parent’s <code>handleIt</code> method will be called. Any code that affects the parent’s state will be inside the <code>handleIt</code> parent method; the child is only concerned with triggering the event.</p> <h3 id=\"Child-Component-Refs\">\nChild Component Refs</h3>\n<p>Despite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript. To achieve this you have to assign a reference ID to the child component using <code>v-ref</code>. For example:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div id=\"parent\"&gt;\n  &lt;user-profile v-ref:profile&gt;&lt;/user-profile&gt;\n&lt;/div&gt;</pre> <pre class=\"highlight js\" data-language=\"js\">var parent = new Vue({ el: '#parent' })\n// access child component instance\nvar child = parent.$refs.profile</pre> <p>When <code>v-ref</code> is used together with <code>v-for</code>, the ref you get will be an Array or an Object containing the child components mirroring the data source.</p> <h2 id=\"Content-Distribution-with-Slots\">\nContent Distribution with Slots</h2>\n<p>When using components, it is often desired to compose them like this:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;app&gt;\n  &lt;app-header&gt;&lt;/app-header&gt;\n  &lt;app-footer&gt;&lt;/app-footer&gt;\n&lt;/app&gt;</pre> <p>There are two things to note here:</p> <ol> <li>\n<p>The <code>&lt;app&gt;</code> component does not know what content may be present inside its mount target. It is decided by whatever parent component that is using <code>&lt;app&gt;</code>.</p> </li> <li>\n<p>The <code>&lt;app&gt;</code> component very likely has its own template.</p> </li> </ol> <p>To make the composition work, we need a way to interweave the parent “content” and the component’s own template. This is a process called <strong>content distribution</strong> (or “transclusion” if you are familiar with Angular). Vue.js implements a content distribution API that is modeled after with the current <a href=\"https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md\" target=\"_blank\" rel=\"external\">Web Components spec draft</a>, using the special <code>&lt;slot&gt;</code> element to serve as distribution outlets for the original content.</p> <h3 id=\"Compilation-Scope\">\nCompilation Scope</h3>\n<p>Before we dig into the API, let’s first clarify which scope the contents are compiled in. Imagine a template like this:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;child-component&gt;\n  {{ msg }}\n&lt;/child-component&gt;</pre> <p>Should the <code>msg</code> be bound to the parent’s data or the child data? The answer is parent. A simple rule of thumb for component scope is:</p> <blockquote> <p>Everything in the parent template is compiled in parent scope; everything in the child template is compiled in child scope.</p> </blockquote> <p>A common mistake is trying to bind a directive to a child property/method in the parent template:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- does NOT work --&gt;\n&lt;child-component v-show=\"someChildProperty\"&gt;&lt;/child-component&gt;</pre> <p>Assuming <code>someChildProperty</code> is a property on the child component, the example above would not work as intended. The parent’s template should not be aware of the state of a child component.</p> <p>If you need to bind child-scope directives on a component root node, you should do so in the child component’s own template:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.component('child-component', {\n  // this does work, because we are in the right scope\n  template: '&lt;div v-show=\"someChildProperty\"&gt;Child&lt;/div&gt;',\n  data: function () {\n    return {\n      someChildProperty: true\n    }\n  }\n})</pre> <p>Similarly, distributed content will be compiled in the parent scope.</p> <h3 id=\"Single-Slot\">\nSingle Slot</h3>\n<p>Parent content will be <strong>discarded</strong> unless the child component template contains at least one <code>&lt;slot&gt;</code> outlet. When there is only one slot with no attributes, the entire content fragment will be inserted at its position in the DOM, replacing the slot itself.</p> <p>Anything originally inside the <code>&lt;slot&gt;</code> tags is considered <strong>fallback content</strong>. Fallback content is compiled in the child scope and will only be displayed if the hosting element is empty and has no content to be inserted.</p> <p>Suppose we have a component with the following template:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div&gt;\n  &lt;h1&gt;This is my component!&lt;/h1&gt;\n  &lt;slot&gt;\n    This will only be displayed if there is no content\n    to be distributed.\n  &lt;/slot&gt;\n&lt;/div&gt;</pre> <p>Parent markup that uses the component:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;my-component&gt;\n  &lt;p&gt;This is some original content&lt;/p&gt;\n  &lt;p&gt;This is some more original content&lt;/p&gt;\n&lt;/my-component&gt;</pre> <p>The rendered result will be:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div&gt;\n  &lt;h1&gt;This is my component!&lt;/h1&gt;\n  &lt;p&gt;This is some original content&lt;/p&gt;\n  &lt;p&gt;This is some more original content&lt;/p&gt;\n&lt;/div&gt;</pre> <h3 id=\"Named-Slots\">\nNamed Slots</h3>\n<p><code>&lt;slot&gt;</code> elements have a special attribute, <code>name</code>, which can be used to further customize how content should be distributed. You can have multiple slots with different names. A named slot will match any element that has a corresponding <code>slot</code> attribute in the content fragment.</p> <p>There can still be one unnamed slot, which is the <strong>default slot</strong> that serves as a catch-all outlet for any unmatched content. If there is no default slot, unmatched content will be discarded.</p> <p>For example, suppose we have a <code>multi-insertion</code> component with the following template:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div&gt;\n  &lt;slot name=\"one\"&gt;&lt;/slot&gt;\n  &lt;slot&gt;&lt;/slot&gt;\n  &lt;slot name=\"two\"&gt;&lt;/slot&gt;\n&lt;/div&gt;</pre> <p>Parent markup:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;multi-insertion&gt;\n  &lt;p slot=\"one\"&gt;One&lt;/p&gt;\n  &lt;p slot=\"two\"&gt;Two&lt;/p&gt;\n  &lt;p&gt;Default A&lt;/p&gt;\n&lt;/multi-insertion&gt;</pre> <p>The rendered result will be:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div&gt;\n  &lt;p slot=\"one\"&gt;One&lt;/p&gt;\n  &lt;p&gt;Default A&lt;/p&gt;\n  &lt;p slot=\"two\"&gt;Two&lt;/p&gt;\n&lt;/div&gt;</pre> <p>The content distribution API is a very useful mechanism when designing components that are meant to be composed together.</p> <h2 id=\"Dynamic-Components\">\nDynamic Components</h2>\n<p>You can use the same mount point and dynamically switch between multiple components by using the reserved <code>&lt;component&gt;</code> element and dynamically bind to its <code>is</code> attribute:</p> <pre class=\"highlight js\" data-language=\"js\">new Vue({\n  el: 'body',\n  data: {\n    currentView: 'home'\n  },\n  components: {\n    home: { /* ... */ },\n    posts: { /* ... */ },\n    archive: { /* ... */ }\n  }\n})</pre> <pre class=\"highlight html\" data-language=\"html\">&lt;component :is=\"currentView\"&gt;\n  &lt;!-- component changes when vm.currentview changes! --&gt;\n&lt;/component&gt;</pre> <h3 id=\"keep-alive\">\n<code>keep-alive</code>\n</h3>\n<p>If you want to keep the switched-out components alive so that you can preserve its state or avoid re-rendering, you can add a <code>keep-alive</code> directive param:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;component :is=\"currentView\" keep-alive&gt;\n  &lt;!-- inactive components will be cached! --&gt;\n&lt;/component&gt;</pre> <h3 id=\"activate-Hook\">\n<code>activate</code> Hook</h3>\n<p>When switching components, the incoming component might need to perform some asynchronous operation before it should be swapped in. To control the timing of component swapping, implement the <code>activate</code> hook on the incoming component:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.component('activate-example', {\n  activate: function (done) {\n    var self = this\n    loadDataAsync(function (data) {\n      self.someData = data\n      done()\n    })\n  }\n})</pre> <p>Note the <code>activate</code> hook is only respected during dynamic component swapping or the initial render for static components - it does not affect manual insertions with instance methods.</p> <h3 id=\"transition-mode\">\n<code>transition-mode</code>\n</h3>\n<p>The <code>transition-mode</code> param attribute allows you to specify how the transition between two dynamic components should be executed.</p> <p>By default, the transitions for incoming and outgoing components happen simultaneously. This attribute allows you to configure two other modes:</p> <ul> <li>\n<p><code>in-out</code>: New component transitions in first, current component transitions out after incoming transition has finished.</p> </li> <li>\n<p><code>out-in</code>: Current component transitions out first, new component transitions in after outgoing transition has finished.</p> </li> </ul> <p><strong>Example</strong></p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- fade out first, then fade in --&gt;\n&lt;component  :is=\"view\"  transition=\"fade\"  transition-mode=\"out-in\"&gt;\n  :is=\"view\"\n  transition=\"fade\"\n  transition-mode=\"out-in\"&gt;\n&lt;/component&gt;</pre> <pre class=\"highlight css\" data-language=\"css\">.fade-transition {\n  transition: opacity .3s ease;\n}\n.fade-enter, .fade-leave {\n  opacity: 0;\n}</pre>    <h2 id=\"Misc\">\nMisc</h2>\n<h3 id=\"Components-and-v-for\">\nComponents and v-for</h3>\n<p>You can directly use <code>v-for</code> on the custom component, like any normal element:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;my-component v-for=\"item in items\"&gt;&lt;/my-component&gt;</pre> <p>However, this won’t pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;my-component  v-for=\"item in items\"  :item=\"item\"  :index=\"$index\"&gt;\n  v-for=\"item in items\"\n  :item=\"item\"\n  :index=\"$index\"&gt;\n&lt;/my-component&gt;</pre> <p>The reason for not automatically injecting <code>item</code> into the component is because that makes the component tightly coupled to how <code>v-for</code> works. Being explicit about where its data comes from makes the component reusable in other situations.</p> <h3 id=\"Authoring-Reusable-Components\">\nAuthoring Reusable Components</h3>\n<p>When authoring components, it is good to keep in mind whether you intend to reuse this component somewhere else later. It is OK for one-off components to have some tight coupling with each other, but reusable components should define a clean public interface.</p> <p>The API for a Vue.js component essentially comes in three parts - props, events and slots:</p> <ul> <li>\n<p><strong>Props</strong> allow the external environment to feed data to the component;</p> </li> <li>\n<p><strong>Events</strong> allow the component to trigger actions in the external environment;</p> </li> <li>\n<p><strong>Slots</strong> allow the external environment to insert content into the component’s view structure.</p> </li> </ul> <p>With the dedicated shorthand syntax for <code>v-bind</code> and <code>v-on</code>, the intents can be clearly and succinctly conveyed in the template:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;my-component  :foo=\"baz\"  :bar=\"qux\"  @event-a=\"doThis\"  @event-b=\"doThat\"&gt;\n  :foo=\"baz\"\n  :bar=\"qux\"\n  @event-a=\"doThis\"\n  @event-b=\"doThat\"&gt;\n  &lt;!-- content --&gt;\n  &lt;img slot=\"icon\" src=\"...\"&gt;\n  &lt;p slot=\"main-text\"&gt;Hello!&lt;/p&gt;\n&lt;/my-component&gt;</pre> <h3 id=\"Async-Components\">\nAsync Components</h3>\n<p>In large applications, we may need to divide the app into smaller chunks, and only load a component from the server when it is actually needed. To make that easier, Vue.js allows you to define your component as a factory function that asynchronously resolves your component definition. Vue.js will only trigger the factory function when the component actually needs to be rendered, and will cache the result for future re-renders. For example:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    resolve({\n      template: '&lt;div&gt;I am async!&lt;/div&gt;'\n    })\n  }, 1000)\n})</pre> <p>The factory function receives a <code>resolve</code> callback, which should be called when you have retrieved your component definition from the server. You can also call <code>reject(reason)</code> to indicate the load has failed. The <code>setTimeout</code> here is simply for demonstration; How to retrieve the component is entirely up to you. One recommended approach is to use async components together with <a href=\"http://webpack.github.io/docs/code-splitting.html\" target=\"_blank\" rel=\"external\">Webpack’s code-splitting feature</a>:</p> <pre class=\"highlight js\" data-language=\"js\">Vue.component('async-webpack-example', function (resolve) {\n  // this special require syntax will instruct webpack to\n  // automatically split your built code into bundles which\n  // are automatically loaded over ajax requests.\n  require(['./my-async-component'], resolve)\n})</pre> <h3 id=\"Assets-Naming-Convention\">\nAssets Naming Convention</h3>\n<p>Some assets, such as components and directives, appear in templates in the form of HTML attributes or HTML custom tags. Since HTML attribute names and tag names are <strong>case-insensitive</strong>, we often need to name our assets using kebab-case instead of camelCase, which can be a bit inconvenient.</p> <p>Vue.js actually supports naming your assets using camelCase or PascalCase, and automatically resolves them as kebab-case in templates (similar to the name conversion for props):</p> <pre class=\"highlight js\" data-language=\"js\">// in a component definition\ncomponents: {\n  // register using camelCase\n  myComponent: { /*... */ }\n}</pre> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- use dash case in templates --&gt;\n&lt;my-component&gt;&lt;/my-component&gt;</pre> <p>This works nicely with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_6\" target=\"_blank\" rel=\"external\">ES6 object literal shorthand</a>:</p> <pre class=\"highlight js\" data-language=\"js\">// PascalCase\nimport TextBox from './components/text-box';\nimport DropdownMenu from './components/dropdown-menu';\n\nexport default {\n  components: {\n    // use in templates as &lt;text-box&gt; and &lt;dropdown-menu&gt;\n    TextBox,\n    DropdownMenu\n  }\n}</pre> <h3 id=\"Recursive-Component\">\nRecursive Component</h3>\n<p>Components can recursively invoke itself in its own template, however, it can only do so when it has the <code>name</code> option:</p> <pre class=\"highlight js\" data-language=\"js\">var StackOverflow = Vue.extend({\n  name: 'stack-overflow',\n  template:\n    '&lt;div&gt;' +\n      // recursively invoke self\n      '&lt;stack-overflow&gt;&lt;/stack-overflow&gt;' +\n    '&lt;/div&gt;'\n})</pre> <p>A component like the above will result in a “max stack size exceeded” error, so make sure recursive invocation is conditional. When you register a component globally using <code>Vue.component()</code>, the global ID is automatically set as the component’s <code>name</code> option.</p> <h3 id=\"Fragment-Instance\">\nFragment Instance</h3>\n<p>When you use the <code>template</code> option, the content of the template will replace the element the Vue instance is mounted on. It is therefore recommended to always have a single root-level, plain element in templates.</p> <p>Instead of templates like this:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div&gt;root node 1&lt;/div&gt;\n&lt;div&gt;root node 2&lt;/div&gt;</pre> <p>Prefer this:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;div&gt;\n  I have a single root node!\n  &lt;div&gt;node 1&lt;/div&gt;\n  &lt;div&gt;node 2&lt;/div&gt;\n&lt;/div&gt;</pre> <p>There are multiple conditions that will turn a Vue instance into a <strong>fragment instance</strong>:</p> <ol> <li>Template contains multiple top-level elements.</li> <li>Template contains only plain text.</li> <li>Template contains only another component (which can potentially be a fragment instance itself).</li> <li>Template contains only an element directive, e.g. <code>&lt;partial&gt;</code> or vue-router’s <code>&lt;router-view&gt;</code>.</li> <li>Template root node has a flow-control directive, e.g. <code>v-if</code> or <code>v-for</code>.</li> </ol> <p>The reason is that all of the above cause the instance to have an unknown number of top-level elements, so it has to manage its DOM content as a fragment. A fragment instance will still render the content correctly. However, it will <strong>not</strong> have a root node, and its <code>$el</code> will point to an “anchor node”, which is an empty Text node (or a Comment node in debug mode).</p> <p>What’s more important though, is that <strong>non-flow-control directives, non-prop attributes and transitions on the component element will be ignored</strong>, because there is no root element to bind them to:</p> <pre class=\"highlight html\" data-language=\"html\">&lt;!-- doesn't work due to no root element --&gt;\n&lt;example v-show=\"ok\" transition=\"fade\"&gt;&lt;/example&gt;\n\n&lt;!-- props work --&gt;\n&lt;example :prop=\"someData\"&gt;&lt;/example&gt;\n\n&lt;!-- flow control works, but without transitions --&gt;\n&lt;example v-if=\"ok\"&gt;&lt;/example&gt;</pre> <p>There are, of course, valid use cases for fragment instances, but it is in general a good idea to give your component template a single, plain root element. It ensures directives and attributes on the component element to be properly transferred, and also results in slightly better performance.</p> <h3 id=\"Inline-Template\">\nInline Template</h3>\n<p>When the <code>inline-template</code> special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</p> <pre class=\"highlight html\" data-language=\"html\">&lt;my-component inline-template&gt;\n  &lt;p&gt;These are compiled as the component's own template&lt;/p&gt;\n  &lt;p&gt;Not parent's transclusion content.&lt;/p&gt;\n&lt;/my-component&gt;</pre> <p>However, <code>inline-template</code> makes the scope of your templates harder to reason about, and makes the component’s template compilation un-cachable. As a best practice, prefer defining templates inside the component using the <code>template</code> option.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Evan You, Vue.js contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://vuejs.org/guide/components.html\" class=\"_attribution-link\">https://vuejs.org/guide/components.html</a>\n  </p>\n</div>\n"}