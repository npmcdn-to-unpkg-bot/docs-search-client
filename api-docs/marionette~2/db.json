{"index":"<h1 itemprop=\"alternativeHeadline\">Backbone.Marionette</h1>  <h2> Table of Contents </h2> <ul class=\"index-nav\"> <li> <a href=\"marionette.application\">Application</a> </li> <li> <a href=\"marionette.approuter\">AppRouter</a> </li> <li> <a href=\"marionette.object\">Object</a> </li> <li> <a href=\"marionette.view\">View</a> </li> <li> <a href=\"marionette.itemview\">ItemView</a> </li> <li> <a href=\"marionette.collectionview\">CollectionView</a> </li> <li> <a href=\"marionette.compositeview\">CompositeView</a> </li> <li> <a href=\"marionette.layoutview\">LayoutView</a> </li> <li> <a href=\"marionette.region\">Region</a> </li> <li> <a href=\"marionette.regionmanager\">RegionManager</a> </li> <li> <a href=\"marionette.behavior\">Behavior</a> </li> <li> <a href=\"marionette.behaviors\">Behaviors</a> </li> <li> <a href=\"marionette.callbacks\">Callbacks</a> </li> <li> <a href=\"marionette.configuration\">Configuration</a> </li> <li> <a href=\"marionette.controller\">Controller</a> </li> <li> <a href=\"marionette.functions\">Functions</a> </li> <li> <a href=\"marionette.module\">Module</a> </li> <li> <a href=\"marionette.renderer\">Renderer</a> </li> <li> <a href=\"marionette.templatecache\">TemplateCache</a> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/index\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/index</a>\n  </p>\n</div>\n","marionette.application":"<h1>\nMarionette.Application</h1>\n<p>The <strong>Application</strong> is a container for the rest of your code. It is recommendedthat every Marionette app have at least one instance of Application.</p> <p>By creating an Application you get three important things:</p> <ul> <li>\n<p>A <code>start</code> method to kick off your application.This allows you an opportunity to do things that may need to occur before, say, youbegin routing. An example would be making an AJAX call to request data that your appneeds before starting.</p> </li> <li>\n<p>A namespace to keep things off of the <code>window</code>.If you are not using a module loader like ES6 modules, CommonJS, or AMD, thenyou can use the Application to store your Javascript objects. And if you areusing one of those module systems, then you can still attach things to theapplication to aid in debugging.</p> </li> <li>\n<p>Integration with the Marionette Inspector. The Marionette Inspector is a fantastic toolthat makes it easy to understand and debug your application. Using the Application Classwill automatically hook up your application to that extension.</p> </li> </ul> <p>Note that the Application is undergoing many changes to become more lightweight. While itstill includes many more features beyond what has been listed here, such as a Radio Channel and Regions,these features are now deprecated. Refer to the relevant sections below to learn what to useinstead of these deprecated features.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#getting-started\">Getting Started</a></li> <li><a href=\"#initialize\">initialize</a></li> <li><a href=\"#application-events\">Application Events</a></li> <li><a href=\"#starting-an-application\">Starting An Application</a></li> <li>\n<a href=\"#application-regions\">Application Regions (deprecated)</a><ul> <li><a href=\"#jquery-selector\">jQuery Selector</a></li> <li><a href=\"#custom-region-class\">Custom Region Class</a></li> <li><a href=\"#custom-region-class-and-selector\">Custom Region Class And Selector</a></li> <li><a href=\"#region-options\">Region Options</a></li> <li><a href=\"#overriding-the-default-regionmanager\">Overriding the default RegionManager</a></li> <li><a href=\"#get-region-by-name\">Get Region By Name</a></li> <li><a href=\"#removing-regions\">Removing Regions</a></li> </ul> </li> <li><a href=\"#applicationmergeoptions\">Application.mergeOptions</a></li> <li><a href=\"#applicationgetoption\">Application.getOption</a></li> <li><a href=\"#adding-initializers\">Adding Initializers (deprecated)</a></li> <li>\n<a href=\"#the-application-channel\">The Application Channel (deprecated)</a><ul> <li><a href=\"#event-aggregator\">Event Aggregator</a></li> <li><a href=\"#request-response\">Request Response</a></li> <li><a href=\"#commands\">Commands</a></li> <li><a href=\"#accessing-the-application-channel\">Accessing the Application Channel</a></li> </ul> </li> </ul> <h3 id=\"getting-started\">\nGetting Started</h3>\n<p>A common pattern in Backbone apps is the following:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> app = {};\n</pre> <p>The most notable example of this pattern is<a href=\"https://github.com/documentcloud/documentcloud/blob/master/public/javascripts/application.js#L3\">DocumentCloud's source</a>. DocumentCloudis notable because it is the codebase that Backbone was abstracted from. If such a thing as a quintessential Backbone applicationexisted, then that app would certainly be a candidate.</p> <p>The pattern of creating a Javascript object is so popular because it provides you with a location toput the pieces of your application. For instance, attaching a Router to this object is common practice.</p> <p>Using a raw Javascript object is great, but Marionette provides a light wrapper for a plain Javascript object, which is theApplication. One benefit to using the Application is that it comes with a <code>start</code> method. This can be used to accomplishtasks before the rest of your application begins. Let's take a quick look at an example:</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// Create our Application</span>\n<span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-keyword\">new</span> Mn.Application();\n\n<span class=\"hljs-comment\">// Start history when our application is ready</span>\napp.on(<span class=\"hljs-string\">'start'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n  Backbone.history.start();\n});\n\n<span class=\"hljs-comment\">// Load some initial data, and then start our application</span>\nloadInitialData().then(app.start);\n</pre> <p>In the simple example above, we could have just as easily started history after our initial data had loaded. Thispattern becomes more useful as the startup phase of your application becomes more complex.</p> <h3 id=\"initialize\">\nInitialize</h3>\n<p>Like other objects in Backbone and Marionette, Applications have an <code>initialize</code> method.It is called immediately after the Application has been instantiated, and is invoked withthe same arguments that the constructor received.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> app = Marionette.Application.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'My container:'</span>, options.container);\n  }\n});\n\n<span class=\"hljs-comment\">// Although applications will not do anything</span>\n<span class=\"hljs-comment\">// with a `container` option out-of-the-box, you</span>\n<span class=\"hljs-comment\">// could build an Application Class that does use</span>\n<span class=\"hljs-comment\">// such an option.</span>\n<span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-keyword\">new</span> app({container: <span class=\"hljs-string\">'#app'</span>});\n</pre> <h2 id=\"application-events\">\nApplication Events</h2>\n<p>The <code>Application</code> object raises a few events during its lifecycle, using the<a href=\"marionette.functions#marionettetriggermethod\">Marionette.triggerMethod</a> function. These eventscan be used to do additional processing of your application. For example, youmay want to pre-process some data just before initialization happens. Or you maywant to wait until your entire application is initialized to start<code>Backbone.history</code>.</p> <p>The events that are currently triggered, are:</p> <ul> <li>\n<strong>\"before:start\" / <code>onBeforeStart</code></strong>: fired just before the <code>Application</code> starts and before the initializers are executed.</li> <li>\n<strong>\"start\" / <code>onStart</code></strong>: fires after the <code>Application</code> has started and after the initializers have been executed.</li> </ul> <pre data-language=\"js\">MyApp.on(<span class=\"hljs-string\">\"before:start\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n  options.moreData = <span class=\"hljs-string\">\"Yo dawg, I heard you like options so I put some options in your options!\"</span>;\n});\n\nMyApp.on(<span class=\"hljs-string\">\"start\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n  <span class=\"hljs-keyword\">if</span> (Backbone.history){\n    Backbone.history.start();\n  }\n});\n</pre> <p>The <code>options</code> parameter is passed through the <code>start</code> method of the applicationobject (see below).</p> <h2 id=\"starting-an-application\">\nStarting An Application</h2>\n<p>Once you have your application configured, you can kick everything off bycalling: <code>MyApp.start(options)</code>.</p> <p>This function takes a single optional parameter. This parameter will be passedto each of your initializer functions, as well as the initialize events. Thisallows you to provide extra configuration for various parts of your app throughout theinitialization sequence.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> options = {\n  something: <span class=\"hljs-string\">\"some value\"</span>,\n  another: <span class=\"hljs-string\">\"#some-selector\"</span>\n};\n\nMyApp.start(options);\n</pre> <h2 id=\"application-regions\">\nApplication Regions</h2>\n<blockquote> <p>Warning: deprecatedThis feature is deprecated. Instead of using the Application as the rootof your view tree, you should use a Layout View. To scope your Layout View to the entiredocument, you could set its <code>el</code> to 'body'. This might look something like the following:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> RootView = Marionette.LayoutView.extend({\n  el: <span class=\"hljs-string\">'body'</span>\n});\n</pre> <p>Later, you can attach an instance of the <code>RootView</code> to your Application instance.</p> <pre data-language=\"js\">app.rootView = <span class=\"hljs-keyword\">new</span> RootView();\n</pre> </blockquote> <p>Application instances have an API that allow you to manage <a href=\"marionette.region\">Regions</a>.These Regions are typically the means through which your views become attached to the <code>document</code>.</p> <p>You can create Regions through the <code>addRegions</code> method by passing in an objectliteral or a function that returns an object literal.</p> <p>There are three syntax forms for adding a region to an application object.</p> <h3 id=\"jquery-selector\">\njQuery Selector</h3>\n<p>The first is to specify a jQuery selector as the value of the regiondefinition. This will create an instance of a Marionette.Region directly,and assign it to the selector:</p> <pre data-language=\"js\">MyApp.addRegions({\n  someRegion: <span class=\"hljs-string\">\"#some-div\"</span>,\n  anotherRegion: <span class=\"hljs-string\">\"#another-div\"</span>\n});\n</pre> <h3 id=\"custom-region-class\">\nCustom Region Class</h3>\n<p>The second is to specify a custom region class, where the region class hasalready specified a selector:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyCustomRegion = Marionette.Region.extend({\n  el: <span class=\"hljs-string\">\"#foo\"</span>\n});\n\nMyApp.addRegions(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    someRegion: MyCustomRegion\n  };\n});\n</pre> <h3 id=\"custom-region-class-and-selector\">\nCustom Region Class And Selector</h3>\n<p>The third method is to specify a custom region class, and a jQuery selectorfor this region instance, using an object literal:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyCustomRegion = Marionette.Region.extend({});\n\nMyApp.addRegions({\n\n  someRegion: {\n    selector: <span class=\"hljs-string\">\"#foo\"</span>,\n    regionClass: MyCustomRegion\n  },\n\n  anotherRegion: {\n    selector: <span class=\"hljs-string\">\"#bar\"</span>,\n    regionClass: MyCustomRegion\n  }\n\n});\n</pre> <h3 id=\"region-options\">\nRegion Options</h3>\n<p>You can also specify regions per <code>Application</code> instance.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">new</span> Marionette.Application({\n  regions: {\n    fooRegion: <span class=\"hljs-string\">'#foo-region'</span>\n  }\n});\n</pre> <h3 id=\"overriding-the-default-regionmanager\">\nOverriding the default <code>RegionManager</code>\n</h3>\n<p>If you need the <code>RegionManager</code>'s class chosen dynamically, specify <code>getRegionManager</code>:</p> <pre data-language=\"js\">Marionette.Application.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  getRegionManager: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// custom logic</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyRegionManager();\n  }\n</pre> <p>This can be useful if you want to attach <code>Application</code>'s regions to your own instance of <code>RegionManager</code>.</p> <h3 id=\"get-region-by-name\">\nGet Region By Name</h3>\n<p>A region can be retrieved by name, using the <code>getRegion</code> method:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-keyword\">new</span> Marionette.Application();\napp.addRegions({ r1: <span class=\"hljs-string\">\"#region1\"</span> });\n\n<span class=\"hljs-keyword\">var</span> myRegion = app.getRegion(<span class=\"hljs-string\">'r1'</span>);\n</pre> <p>Regions are also attached directly to the Application instance, <strong>but this is not recommended usage</strong>.</p> <h3 id=\"removing-regions\">\nRemoving Regions</h3>\n<p>Regions can also be removed with the <code>removeRegion</code> method, passing inthe name of the region to remove as a string value:</p> <pre data-language=\"js\">MyApp.removeRegion(<span class=\"hljs-string\">'someRegion'</span>);\n</pre> <p>Removing a region will properly empty it before removing it from theapplication object.</p> <p>For more information on regions, see <a href=\"marionette.region\">the region documentation</a> Also, the API that Applications use tomanage regions comes from the RegionManager Class, which is documented <a href=\"marionette.regionmanager\">over here</a>.</p> <h3 id=\"applicationmergeoptions\">\nApplication.mergeOptions</h3>\n<p>Merge keys from the <code>options</code> object directly onto the Application instance.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyApp = Marionette.Application.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.mergeOptions(options, [<span class=\"hljs-string\">'myOption'</span>]);\n\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'The option is:'</span>, <span class=\"hljs-keyword\">this</span>.myOption);\n  }\n})\n</pre> <p>More information at <a href=\"marionette.functions#marionettemergeoptions\">mergeOptions</a></p> <h3 id=\"applicationgetoption\">\nApplication.getOption</h3>\n<p>Retrieve an object's attribute either directly from the object, or from the object's this.options, with this.options taking precedence.</p> <p>More information <a href=\"marionette.functions#marionettegetoption\">getOption</a></p> <h2 id=\"adding-initializers\">\nAdding Initializers</h2>\n<blockquote> <p>Warning: deprecated</p> <p>This feature is deprecated, and is scheduled to be removed in version 3 of Marionette. Insteadof Initializers, you should use events to manage start-up logic. The <code>start</code> event is an idealsubstitute for Initializers.</p> <p>If you were relying on the deferred nature of Initializers in your app, you should insteaduse Promises. This might look something like the following:</p> <pre data-language=\"js\">doAsyncThings().then(app.start);\n</pre> </blockquote> <p>Your application needs to do useful things, like displaying content in yourregions, starting up your routers, and more. To accomplish these tasks andensure that your <code>Application</code> is fully configured, you can add initializercallbacks to the application.</p> <pre data-language=\"js\">MyApp.addInitializer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n  <span class=\"hljs-comment\">// do useful stuff here</span>\n  <span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView({\n    model: options.someModel\n  });\n  MyApp.mainRegion.show(myView);\n});\n\nMyApp.addInitializer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n  <span class=\"hljs-keyword\">new</span> MyAppRouter();\n  Backbone.history.start();\n});\n</pre> <p>These callbacks will be executed when you start your application,and are bound to the application object as the context forthe callback. In other words, <code>this</code> is the <code>MyApp</code> object insideof the initializer function.</p> <p>The <code>options</code> argument is passed from the <code>start</code> method (see below).</p> <p>Initializer callbacks are guaranteed to run, no matter when youadd them to the app object. If you add them before the app isstarted, they will run when the <code>start</code> method is called. If youadd them after the app is started, they will run immediately.</p> <h2 id=\"the-application-channel\">\nThe Application Channel</h2>\n<blockquote> <p>Warning: deprecated</p> <p>This feature is deprecated, and is scheduled to be removed in the next major release of Marionette.Instead of accessing Channels through the Application, you should use the Wreqr (or Radio) API.By default the application's channel is named 'global'. To access this channel, you can usethe following code, depending on whether you're using Wreqr or Radio:</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// Wreqr</span>\n<span class=\"hljs-keyword\">var</span> globalCh = Backbone.Wreqr.radio.channel(<span class=\"hljs-string\">'global'</span>);\n\n<span class=\"hljs-comment\">// Radio</span>\n<span class=\"hljs-keyword\">var</span> globalCh = Backbone.Radio.channel(<span class=\"hljs-string\">'global'</span>);\n</pre> </blockquote> <p>Marionette Applications come with a <a href=\"http://en.wikipedia.org/wiki/Message_passing\">messaging system</a> to facilitate communications within your app.</p> <p>The messaging system on the Application is the radio channel from Backbone.Wreqr, which is actually comprised of three distinct systems.</p> <p>Marionette Applications default to the 'global' channel, but the channel can be configured.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyApp = <span class=\"hljs-keyword\">new</span> Marionette.Application({ channelName: <span class=\"hljs-string\">'appChannel'</span> });\n</pre> <p>This section will give a brief overview of the systems; for a more in-depth look you are encouraged to readthe <a href=\"https://github.com/marionettejs/backbone.wreqr\"><code>Backbone.Wreqr</code> documentation</a>.</p> <h3 id=\"event-aggregator\">\nEvent Aggregator</h3>\n<p>The Event Aggregator is available through the <code>vent</code> property. <code>vent</code> is convenient for passively sharing information betweenpieces of your application as events occur.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyApp = <span class=\"hljs-keyword\">new</span> Marionette.Application();\n\n<span class=\"hljs-comment\">// Alert the user on the 'minutePassed' event</span>\nMyApp.vent.on(<span class=\"hljs-string\">\"minutePassed\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(someData)</span></span>{\n  alert(<span class=\"hljs-string\">\"Received\"</span>, someData);\n});\n\n<span class=\"hljs-comment\">// This will emit an event with the value of window.someData every minute</span>\n<span class=\"hljs-built_in\">window</span>.setInterval(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n  MyApp.vent.trigger(<span class=\"hljs-string\">\"minutePassed\"</span>, <span class=\"hljs-built_in\">window</span>.someData);\n}, <span class=\"hljs-number\">1000</span> * <span class=\"hljs-number\">60</span>);\n</pre> <h3 id=\"request-response\">\nRequest Response</h3>\n<p>Request Response is a means for any component to request information from another component without being tightly coupled. An instance of Request Response is available on the Application as the <code>reqres</code> property.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyApp = <span class=\"hljs-keyword\">new</span> Marionette.Application();\n\n<span class=\"hljs-comment\">// Set up a handler to return a todoList based on type</span>\nMyApp.reqres.setHandler(<span class=\"hljs-string\">\"todoList\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(type)</span></span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.todoLists[type];\n});\n\n<span class=\"hljs-comment\">// Make the request to get the grocery list</span>\n<span class=\"hljs-keyword\">var</span> groceryList = MyApp.reqres.request(<span class=\"hljs-string\">\"todoList\"</span>, <span class=\"hljs-string\">\"groceries\"</span>);\n\n<span class=\"hljs-comment\">// The request method can also be accessed directly from the application object</span>\n<span class=\"hljs-keyword\">var</span> groceryList = MyApp.request(<span class=\"hljs-string\">\"todoList\"</span>, <span class=\"hljs-string\">\"groceries\"</span>);\n</pre> <h3 id=\"commands\">\nCommands</h3>\n<p>Commands are used to make any component tell another component to perform an action without a direct reference to it. A Commands instance is available under the <code>commands</code> property of the Application.</p> <p>Note that the callback of a command is not meant to return a value.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyApp = <span class=\"hljs-keyword\">new</span> Marionette.Application();\n\nMyApp.model = <span class=\"hljs-keyword\">new</span> Backbone.Model();\n\n<span class=\"hljs-comment\">// Set up the handler to call fetch on the model</span>\nMyApp.commands.setHandler(<span class=\"hljs-string\">\"fetchData\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(reset)</span></span>{\n  MyApp.model.fetch({reset: reset});\n});\n\n<span class=\"hljs-comment\">// Order that the data be fetched</span>\nMyApp.commands.execute(<span class=\"hljs-string\">\"fetchData\"</span>, <span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-comment\">// The execute function is also available directly from the application</span>\nMyApp.execute(<span class=\"hljs-string\">\"fetchData\"</span>, <span class=\"hljs-literal\">true</span>);\n</pre> <h3 id=\"accessing-the-application-channel\">\nAccessing the Application Channel</h3>\n<p>To access this application channel from other objects within your app you are encouraged to get a handle of the systemsthrough the Wreqr API instead of the Application instance itself.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// Assuming that we're in some class within your app,</span>\n<span class=\"hljs-comment\">// and that we are using the default 'global' channel</span>\n<span class=\"hljs-comment\">// it is preferable to access the channel like this:</span>\n<span class=\"hljs-keyword\">var</span> globalCh = Backbone.Wreqr.radio.channel(<span class=\"hljs-string\">'global'</span>);\nglobalCh.vent;\n\n<span class=\"hljs-comment\">// This is discouraged because it assumes the name of your application</span>\n<span class=\"hljs-built_in\">window</span>.app.vent;\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.application.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.application.html</a>\n  </p>\n</div>\n","marionette.approuter":"<h1>\nMarionette.AppRouter</h1>\n<p>Reduce the boilerplate code of handling route events and then calling a single method on another object.Have your routers configured to call the method on your object, directly.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#configure-routes\">Configure Routes</a></li> <li><a href=\"#configure-routes-in-constructor\">Configure Routes In Constructor</a></li> <li><a href=\"#add-routes-at-runtime\">Add Routes At Runtime</a></li> <li><a href=\"#specify-a-controller\">Specify A Controller</a></li> <li><a href=\"#onroute\">onRoute</a></li> </ul> <h2 id=\"configure-routes\">\nConfigure Routes</h2>\n<p>Configure an AppRouter with <code>appRoutes</code>. The route definition is passed on to Backbone's standard routing handlers. This means that you define routes like you normally would. However, instead of providing a callback method that exists on the router, you provide a callback method that exists on the controller, which you specify for the router instance (see below.)</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyRouter = Marionette.AppRouter.extend({\n  <span class=\"hljs-comment\">// \"someMethod\" must exist at controller.someMethod</span>\n  appRoutes: {\n    <span class=\"hljs-string\">\"some/route\"</span>: <span class=\"hljs-string\">\"someMethod\"</span>\n  },\n\n  <span class=\"hljs-comment\">/* standard routes can be mixed with appRoutes/Controllers above */</span>\n  routes : {\n    <span class=\"hljs-string\">\"some/otherRoute\"</span> : <span class=\"hljs-string\">\"someOtherMethod\"</span>\n  },\n  someOtherMethod : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// do something here.</span>\n  }\n\n});\n</pre> <p>You can also add standard routes to an AppRouter with methods on the router.</p> <h2 id=\"configure-routes-in-constructor\">\nConfigure Routes In Constructor</h2>\n<p>Routes can be defined through the constructor function options, as well.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyRouter = <span class=\"hljs-keyword\">new</span> Marionette.AppRouter({\n  controller: myController,\n  appRoutes: {\n    <span class=\"hljs-string\">\"foo\"</span>: <span class=\"hljs-string\">\"doFoo\"</span>,\n    <span class=\"hljs-string\">\"bar/:id\"</span>: <span class=\"hljs-string\">\"doBar\"</span>\n  }\n});\n</pre> <p>This allows you to create router instances without having to <code>.extend</code>from the AppRouter. You can just create the instance with the routes definedin the constructor, as shown.</p> <h2 id=\"add-routes-at-runtime\">\nAdd Routes At Runtime</h2>\n<p>In addition to setting the <code>appRoutes</code> for an AppRouter, you can add app routesat runtime, to an instance of a router. This is done with the <code>appRoute()</code>method call. It works the same as the built-in <code>router.route()</code> call fromBackbone's Router, but has all the same semantics and behavior of the <code>appRoutes</code>configuration.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyRouter = Marionette.AppRouter.extend({});\n\n<span class=\"hljs-keyword\">var</span> router = <span class=\"hljs-keyword\">new</span> MyRouter();\nrouter.appRoute(<span class=\"hljs-string\">\"/foo\"</span>, <span class=\"hljs-string\">\"fooThat\"</span>);\n</pre> <p>Also you can specify a controller with the multiple routes at runtime with method<code>processAppRoutes</code>. However, In this case the current controller of <code>AppRouter</code> will not change.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyRouter = Marionette.AppRouter.extend({});\n\n<span class=\"hljs-keyword\">var</span> router = <span class=\"hljs-keyword\">new</span> MyRouter();\nrouter.processAppRoutes(myController, {\n  <span class=\"hljs-string\">\"foo\"</span>: <span class=\"hljs-string\">\"doFoo\"</span>,\n  <span class=\"hljs-string\">\"bar/:id\"</span>: <span class=\"hljs-string\">\"doBar\"</span>\n});\n</pre> <h2 id=\"specify-a-controller\">\nSpecify A Controller</h2>\n<p>App routers can only use one <code>controller</code> object. You can either specify thisdirectly in the router definition:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> someController = {\n  someMethod: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{ <span class=\"hljs-comment\">/*...*/</span> }\n};\n\nMarionette.AppRouter.extend({\n  controller: someController\n});\n</pre> <p>... or in a parameter to the constructor:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> myObj = {\n  someMethod: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{ <span class=\"hljs-comment\">/*...*/</span> }\n};\n\n<span class=\"hljs-keyword\">new</span> MyRouter({\n  controller: myObj\n});\n</pre> <p>The object that is used as the <code>controller</code> has no requirements, other than it willcontain the methods that you specified in the <code>appRoutes</code>.</p> <p>It is recommended that you divide your controller objects into smaller pieces of related functionalityand have multiple routers / controllers, instead of just one giant router and controller.</p> <h2 id=\"onroute\">\nonRoute</h2>\n<p>If it exists, AppRouters will call the <code>onRoute</code> method whenever a user navigates within your app. Thecallback receives three arguments: the name, path, and arguments of the route.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.approuter.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.approuter.html</a>\n  </p>\n</div>\n","marionette.controller":"<h1>\nMarionette.Controller</h1>\n<blockquote> <p>Warning: deprecated. The Controller object is deprecated. Instead of using the Controllerclass with the AppRouter, you should specify your callbacks on a plain Javascript object or a <a href=\"marionette.object\">Marionette Object</a></p> </blockquote> <p>A Controller is an object used in the Marionette Router. Controllers are where you storeyour Router's callbacks.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#basic-use\">Basic Use</a></li> <li><a href=\"#destroying-a-controller\">Destroying A Controller</a></li> <li><a href=\"#mergeoptions\">mergeOptions</a></li> <li><a href=\"#getoption\">getOption</a></li> <li><a href=\"#prior-usage\">Prior Usage</a></li> </ul> <h2 id=\"basic-use\">\nBasic Use</h2>\n<p>A <code>Marionette.Controller</code> is intended to solely be used within the Router.</p> <pre data-language=\"js\">\n<span class=\"hljs-comment\">// Create a Controller, giving it the callbacks for our Router.</span>\n<span class=\"hljs-keyword\">var</span> MyController = Marionette.Controller.extend({\n  home: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{},\n  profile: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{}\n});\n\n<span class=\"hljs-comment\">// Instantiate it</span>\n<span class=\"hljs-keyword\">var</span> myController = <span class=\"hljs-keyword\">new</span> MyController();\n\n<span class=\"hljs-comment\">// Pass it into the Router</span>\n<span class=\"hljs-keyword\">var</span> myRouter = <span class=\"hljs-keyword\">new</span> Marionette.AppRouter({\n  controller: myController,\n  appRoutes: {\n    <span class=\"hljs-string\">\"home\"</span>: <span class=\"hljs-string\">\"home\"</span>,\n    <span class=\"hljs-string\">\"profile\"</span>: <span class=\"hljs-string\">\"profile\"</span>\n  }\n});\n</pre> <h2 id=\"mergeoptions\">\nmergeOptions</h2>\n<p>Merge keys from the <code>options</code> object directly onto the instance. This is the preferred way to access optionspassed into the Controller.</p> <p>More information at <a href=\"marionette.functions#marionettemergeoptions\">mergeOptions</a></p> <h2 id=\"getoption\">\ngetOption</h2>\n<p>Retrieve an object's attribute either directly from the object, or from the object's this.options, with this.options taking precedence.</p> <p>More information <a href=\"marionette.functions#marionettegetoption\">getOption</a></p> <h2 id=\"destroying-a-controller\">\nDestroying A Controller</h2>\n<p>Each Controller instance has a built in <code>destroy</code> method that handlesunbinding all of the events that are directly attached to the controllerinstance, as well as those that are bound using the EventBinder fromthe controller.</p> <p>Invoking the <code>destroy</code> method will trigger the \"before:destroy\" and \"destroy\" events and thecorresponding <code>onBeforeDestory</code> and <code>onDestroy</code> method calls. These calls will be passed any arguments <code>destroy</code>was invoked with.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// define a controller with an onDestroy method</span>\n<span class=\"hljs-keyword\">var</span> MyController = Marionette.Controller.extend({\n\n  onBeforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(arg1, arg2)</span></span>{\n    <span class=\"hljs-comment\">// put custom code here, before destroying this controller</span>\n  }\n\n  onDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(arg1, arg2)</span></span>{\n    <span class=\"hljs-comment\">// put custom code here, to destroy this controller</span>\n  }\n\n});\n\n<span class=\"hljs-comment\">// create a new controller instance</span>\n<span class=\"hljs-keyword\">var</span> contr = <span class=\"hljs-keyword\">new</span> MyController();\n\n<span class=\"hljs-comment\">// add some event handlers</span>\ncontr.on(<span class=\"hljs-string\">\"before:destroy\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(arg1, arg2)</span></span>{ ... });\ncontr.on(<span class=\"hljs-string\">\"destroy\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(arg1, arg2)</span></span>{ ... });\ncontr.listenTo(something, <span class=\"hljs-string\">\"bar\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{...});\n\n<span class=\"hljs-comment\">// destroy the controller: unbind all of the</span>\n<span class=\"hljs-comment\">// event handlers, trigger the \"destroy\" event and</span>\n<span class=\"hljs-comment\">// call the onDestroy method</span>\ncontr.destroy(arg1, arg2);\n</pre> <h2 id=\"prior-usage\">\nPrior Usage</h2>\n<p>Before Marionette 2.1, the Controller had another use, which was a general-purpose, white-label object. This was confusing given its other use within the Router, and its name, which carries so much meaning in the context of MVC frameworks.</p> <p>As of v2.1, a new Class is available for your use: Marionette.Object. We recommend using Marionette.Object instead of Marionette.Controller in all situations outside of the Router.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.controller.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.controller.html</a>\n  </p>\n</div>\n","marionette.templatecache":"<h1>\nMarionette.TemplateCache</h1>\n<p>The <code>TemplateCache</code> provides a cache for retrieving templatesfrom script blocks in your HTML. This will improvethe speed of subsequent calls to get a template.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#basic-usage\">Basic Usage</a></li> <li><a href=\"#clear-items-from-cache\">Clear Items From cache</a></li> <li><a href=\"#customizing-template-access\">Customizing Template Access</a></li> <li><a href=\"#override-template-retrieval\">Override Template Retrieval</a></li> <li><a href=\"#override-template-compilation\">Override Template Compilation</a></li> </ul> <h2 id=\"basic-usage\">\nBasic Usage</h2>\n<p>To use the <code>TemplateCache</code>, call the <code>get</code> method on TemplateCache directly.Internally, instances of the TemplateCache class will be created and storedbut you do not have to manually create these instances yourself. <code>get</code> willreturn a compiled template function.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> template = Marionette.TemplateCache.get(<span class=\"hljs-string\">\"#my-template\"</span>, {some: options});\n<span class=\"hljs-comment\">// use the template</span>\ntemplate({param1:<span class=\"hljs-string\">'value1'</span>, paramN:<span class=\"hljs-string\">'valueN'</span>});\n</pre> <p>Making multiple calls to get the same template will retrieve thetemplate from the cache on subsequence calls.</p> <h3 id=\"clear-items-from-cache\">\nClear Items From cache</h3>\n<p>You can clear one or more, or all items from the cache using the<code>clear</code> method. Clearing a template from the cache will force itto re-load from the DOM (via the <code>loadTemplate</code>function which can be overridden, see below) the next time it is retrieved.</p> <p>If you do not specify any parameters, all items will be clearedfrom the cache:</p> <pre data-language=\"js\">Marionette.TemplateCache.get(<span class=\"hljs-string\">\"#my-template\"</span>);\nMarionette.TemplateCache.get(<span class=\"hljs-string\">\"#this-template\"</span>);\nMarionette.TemplateCache.get(<span class=\"hljs-string\">\"#that-template\"</span>);\n\n<span class=\"hljs-comment\">// clear all templates from the cache</span>\nMarionette.TemplateCache.clear()\n</pre> <p>If you specify one or more parameters, these parameters are assumedto be the <code>templateId</code> used for loading / caching:</p> <pre data-language=\"js\">Marionette.TemplateCache.get(<span class=\"hljs-string\">\"#my-template\"</span>);\nMarionette.TemplateCache.get(<span class=\"hljs-string\">\"#this-template\"</span>);\nMarionette.TemplateCache.get(<span class=\"hljs-string\">\"#that-template\"</span>);\n\n<span class=\"hljs-comment\">// clear 2 of 3 templates from the cache</span>\nMarionette.TemplateCache.clear(<span class=\"hljs-string\">\"#my-template\"</span>, <span class=\"hljs-string\">\"#this-template\"</span>)\n</pre> <h2 id=\"customizing-template-access\">\nCustomizing Template Access</h2>\n<p>If you want to use an alternate template engine whilestill taking advantage of the template caching functionality, or want to customizehow templates are stored and retrieved, you will need to customize the<code>TemplateCache object</code>. The default operation of <code>TemplateCache</code>, is toretrieve templates from the DOM based on the containing element's idattribute, and compile the html in that element with the underscore.js<code>template</code> function.</p> <h3 id=\"override-template-retrieval\">\nOverride Template Retrieval</h3>\n<p>The default template retrieval is to select the template contentsfrom the DOM using jQuery. If you wish to change the way thisworks, you can override the <code>loadTemplate</code> method on the<code>TemplateCache</code> object.</p> <pre data-language=\"js\">Marionette.TemplateCache.prototype.loadTemplate = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(templateId, options)</span></span>{\n  <span class=\"hljs-comment\">// load your template here, returning the data needed for the compileTemplate</span>\n  <span class=\"hljs-comment\">// function. For example, you have a function that creates templates based on the</span>\n  <span class=\"hljs-comment\">// value of templateId</span>\n  <span class=\"hljs-keyword\">var</span> myTemplate = myTemplateFunc(templateId);\n\n  <span class=\"hljs-comment\">// send the template back</span>\n  <span class=\"hljs-keyword\">return</span> myTemplate;\n}\n</pre> <h3 id=\"override-template-compilation\">\nOverride Template Compilation</h3>\n<p>The default template compilation passes the results from<code>loadTemplate</code> to the <code>compileTemplate</code> function, which returnsan underscore.js compiled template function. When overriding <code>compileTemplate</code>remember that it must return a function which takes an object of parameters and valuesand returns a formatted HTML string.</p> <pre data-language=\"js\">Marionette.TemplateCache.prototype.compileTemplate = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(rawTemplate, options)</span> </span>{\n  <span class=\"hljs-comment\">// use Handlebars.js to compile the template</span>\n  <span class=\"hljs-keyword\">return</span> Handlebars.compile(rawTemplate);\n}\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.templatecache.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.templatecache.html</a>\n  </p>\n</div>\n","marionette.behaviors":"<h1>\nMarionette.Behaviors</h1>\n<p>'Marionette.Behaviors' is a utility class that takes care of gluing your <code>Behavior</code> instances to their given <code>View</code>.The most important thing to understand when using this class is that you <strong>MUST</strong> override the class level <code>behaviorsLookup</code> method or set the option <code>behaviorClass</code> for things to work properly.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li>\n<a href=\"#api\">API</a><ul> <li><a href=\"#behaviorslookup\">Behaviors Lookup</a></li> <li><a href=\"#getbehaviorclass\">getBehaviorClass</a></li> <li><a href=\"#behaviorclass\">behaviorClass</a></li> </ul> </li> </ul> <h2 id=\"api\">\nAPI</h2>\n<p>There are two class level methods that you can override on the <code>Behaviors</code> class. The rest of the class is tied to under the hood implementation details of Views.</p> <h3 id=\"behaviorslookup\">\nbehaviorsLookup</h3>\n<p>This method defines where your Behavior classes are stored. A simple implementation might look something like this.</p> <pre data-language=\"js\">Marionette.Behaviors.behaviorsLookup = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">window</span>.Behaviors;\n}\n</pre> <p>By default the Behaviors are looked up by their key value in a given View's behavior hash.</p> <p>In this sample (using the default <code>getBehaviorClass</code> implementation) your code will expect the following Behaviors to be present in <code>window.Behaviors.DestroyWarn</code> and <code>window.Behaviors.ToolTip</code></p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n    behaviors: {\n        DestroyWarn: {\n            message: <span class=\"hljs-string\">\"you are destroying all your data is now gone!\"</span>\n        },\n        ToolTip: {\n            text: <span class=\"hljs-string\">\"what a nice mouse you have\"</span>\n        }\n    }\n});\n</pre> <h3 id=\"getbehaviorclass\">\ngetBehaviorClass</h3>\n<p>This method has a default implementation that is simple to override. It is responsible for the lookup of single Behavior from within the <code>Behaviors.behaviorsLookup</code> or elsewhere.</p> <pre data-language=\"js\">getBehaviorClass: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options, key)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (options.behaviorClass) {\n        <span class=\"hljs-keyword\">return</span> options.behaviorClass;\n    }\n\n    <span class=\"hljs-keyword\">return</span> Behaviors.behaviorsLookup[key];\n}\n</pre> <h3 id=\"behaviorclass\">\nbehaviorClass</h3>\n<p>This property lets you pass a <code>class</code> in for the Behavior to use (bypassing the normal key based lookup). This is nice to have when the Behavior is a dependency of the View in a module system like <a href=\"http://requirejs.org/\">requirejs</a> or <a href=\"http://browserify.org/\">browserify</a>. Properties passed in this way will be used in <code>getBehaviorClass</code>.</p> <pre data-language=\"js\">define([<span class=\"hljs-string\">'marionette'</span>, <span class=\"hljs-string\">'lib/tooltip'</span>], <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(Marionette, Tooltip)</span> </span>{\n  <span class=\"hljs-keyword\">var</span> View = Marionette.ItemView.extend({\n     behaviors: {\n        Tooltip: {\n          behaviorClass: Tooltip,\n          message: <span class=\"hljs-string\">\"hello world\"</span>\n        }\n     }\n  });\n});\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.behaviors.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.behaviors.html</a>\n  </p>\n</div>\n","marionette.callbacks":"<h1>\nMarionette.Callbacks</h1>\n<blockquote> <p>Warning: deprecated</p> <p>Marionette.Callbacks are deprecated, and are scheduled to be removed in the next major release of the library. Insteadof Callbacks, you should use promises or events to manage asynchronous logic.</p> </blockquote> <p>The <code>Callbacks</code> object assists in managing a collection of callbackmethods, and executing them, in an async-safe manner.</p> <p>There are only two methods:</p> <ul> <li><code>add</code></li> <li><code>run</code></li> </ul> <p>The <code>add</code> method adds a new callback to be executed later.</p> <p>The <code>run</code> method executes all current callbacks in, using thespecified context for each of the callbacks, and supplying theprovided options to the callbacks.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#basic-usage\">Basic Usage</a></li> <li><a href=\"#specify-context-per-callback\">Specify Context Per-Callback</a></li> <li><a href=\"#advanced--async-use\">Advanced / Async Use</a></li> </ul> <h2 id=\"basic-usage\">\nBasic Usage</h2>\n<pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> callbacks = <span class=\"hljs-keyword\">new</span> Marionette.Callbacks();\n\ncallbacks.add(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n  alert(<span class=\"hljs-string\">\"I'm a callback with \"</span> + options.value + <span class=\"hljs-string\">\"!\"</span>);\n});\n\ncallbacks.run({value: <span class=\"hljs-string\">\"options\"</span>}, someContext);\n</pre> <p>This example will display an alert box that says \"I'm a callbackwith options!\". The executing context for each of the callbackmethods has been set to the <code>someContext</code> object, which is an optionalparameter that can be any valid JavaScript object.</p> <h2 id=\"specify-context-per-callback\">\nSpecify Context Per-Callback</h2>\n<p>You can optionally specify the context that you want each callback to beexecuted with, when adding a callback:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> callbacks = <span class=\"hljs-keyword\">new</span> Marionette.Callbacks();\n\ncallbacks.add(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n  alert(<span class=\"hljs-string\">\"I'm a callback with \"</span> + options.value + <span class=\"hljs-string\">\"!\"</span>);\n\n   <span class=\"hljs-comment\">// specify callback context as second parameter</span>\n}, myContext);\n\n\n<span class=\"hljs-comment\">// the `someContext` context is ignored by the above callback</span>\ncallbacks.run({value: <span class=\"hljs-string\">\"options\"</span>}, someContext);\n</pre> <p>This will run the specified callback with the <code>myContext</code> object set as<code>this</code> in the callback, instead of <code>someContext</code>.</p> <h2 id=\"advanced--async-use\">\nAdvanced / Async Use</h2>\n<p>The <code>Callbacks</code> executes each callback in an async-friendlymanner, and can be used to facilitate async callbacks.The <code>Marionette.Application</code> object uses <code>Callbacks</code>to manage initializers (see above).</p> <p>It can also be used to guarantee callback execution in an eventdriven scenario, much like the application initializers.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.callbacks.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.callbacks.html</a>\n  </p>\n</div>\n","marionette.object":"<h1>\nMarionette.Object</h1>\n<p>A base class which other classes can extend from.Object incorporates many backbone conventions and utilitieslike <code>initialize</code> and <code>Backbone.Events</code>.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#initialize\">initialize</a></li> <li><a href=\"#events\">events</a></li> <li><a href=\"#destroying-a-object\">Destroying An Object</a></li> <li><a href=\"#mergeoptions\">mergeOptions</a></li> <li><a href=\"#getoption\">getOption</a></li> <li><a href=\"#bindentityevents\">bindEntityEvents</a></li> <li><a href=\"#basic-use\">Basic Use</a></li> </ul> <h3 id=\"initialize\">\nInitialize</h3>\n<p>Initialize is called immediately after the Object has been instantiated,and is invoked with the same arguments that the constructor received.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> Friend = Marionette.Object.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n    <span class=\"hljs-built_in\">console</span>.log(options.name);\n  }\n});\n\n<span class=\"hljs-keyword\">new</span> Friend({name: <span class=\"hljs-string\">'John'</span>});\n</pre> <h3 id=\"events\">\nEvents</h3>\n<p><code>Marionette.Object</code> extends <code>Backbone.Events</code> and includes <code>triggerMethod</code>.This makes it easy for Objects to emit events that other objects can listen forwith <code>on</code> or <code>listenTo</code>.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> Friend = Marionette.Object.extend({\n  graduate: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.triggerMethod(<span class=\"hljs-string\">'announce'</span>, <span class=\"hljs-string\">'I graduated!!!'</span>);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> john = <span class=\"hljs-keyword\">new</span> Friend({name: <span class=\"hljs-string\">'John'</span>});\n\njohn.on(<span class=\"hljs-string\">'announce'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(message)</span> </span>{\n  <span class=\"hljs-built_in\">console</span>.log(message); <span class=\"hljs-comment\">// I graduated!!!</span>\n})\n\njohn.graduate();\n</pre> <h2 id=\"mergeoptions\">\nmergeOptions</h2>\n<p>Merge keys from the <code>options</code> object directly onto the instance. This is the preferred way to access optionspassed into the Object.</p> <p>More information at <a href=\"marionette.functions#marionettemergeoptions\">mergeOptions</a></p> <h3 id=\"getoption\">\ngetOption</h3>\n<p>Retrieve an object's attribute either directly from the object, or from the object's this.options, with this.options taking precedence.</p> <p>More information <a href=\"marionette.functions#marionettegetoption\">getOption</a>.</p> <h3 id=\"bindentityevents\">\nbindEntityEvents</h3>\n<p>Helps bind a backbone \"entity\" to methods on a target object. More information <a href=\"marionette.functions#marionettebindentityevents\">bindEntityEvents</a>.</p> <h3 id=\"destroying-a-object\">\nDestroying A Object</h3>\n<p>Objects have a <code>destroy</code> method that unbind the events that are directly attached to theinstance.</p> <p>Invoking the <code>destroy</code> method will trigger a \"before:destroy\" event and corresponding<code>onBeforeDestroy</code> method call. These calls will be passed any arguments <code>destroy</code>was invoked with. Invoking <code>destroy</code> will return the object, this can be useful for chaining.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// define a object with an onDestroy method</span>\n<span class=\"hljs-keyword\">var</span> MyObject = Marionette.Object.extend({\n\n  onBeforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(arg1, arg2)</span></span>{\n    <span class=\"hljs-comment\">// put custom code here, to destroy this object</span>\n  }\n\n});\n\n<span class=\"hljs-comment\">// create a new object instance</span>\n<span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> MyObject();\n\n<span class=\"hljs-comment\">// add some event handlers</span>\nobj.on(<span class=\"hljs-string\">\"before:destroy\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(arg1, arg2)</span></span>{ ... });\nobj.listenTo(something, <span class=\"hljs-string\">\"bar\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{...});\n\n<span class=\"hljs-comment\">// destroy the object: unbind all of the</span>\n<span class=\"hljs-comment\">// event handlers, trigger the \"destroy\" event and</span>\n<span class=\"hljs-comment\">// call the onDestroy method</span>\nobj.destroy(arg1, arg2);\n</pre> <h3 id=\"basic-use\">\nBasic Use</h3>\n<p>Selections is a simple Object that manages a selection of things.Because Selections extends from Object, it gets <code>initialize</code> and <code>Events</code>for free.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> Selections = Marionette.Object.extend({\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n    <span class=\"hljs-keyword\">this</span>.selections = {};\n  },\n\n  select: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(key, item)</span></span>{\n    <span class=\"hljs-keyword\">this</span>.triggerMethod(<span class=\"hljs-string\">\"select\"</span>, key, item);\n    <span class=\"hljs-keyword\">this</span>.selections[key] = item;\n  },\n\n  deselect: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(key, item)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.triggerMethod(<span class=\"hljs-string\">\"deselect\"</span>, key, item);\n    <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>.selections[key];\n  }\n\n});\n\n<span class=\"hljs-keyword\">var</span> selections = <span class=\"hljs-keyword\">new</span> Selections({\n  filters: Filters\n});\n\n<span class=\"hljs-comment\">// use the built in EventBinder</span>\nselections.listenTo(selections, <span class=\"hljs-string\">\"select\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(key, item)</span></span>{\n  <span class=\"hljs-built_in\">console</span>.log(item);\n});\n\nselections.select(<span class=\"hljs-string\">'toy'</span>, Truck);\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.object.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.object.html</a>\n  </p>\n</div>\n","marionette.functions":"<h1>\nMarionette functions</h1>\n<p>Marionette provides a set of utility / helper functions that are used tofacilitate common behaviors throughout the framework. These functions maybe useful to those that are building on top of Marionette, as they providea way to get the same behaviors and conventions from your own code.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#marionetteextend\">Marionette.extend</a></li> <li><a href=\"#marionetteisnodeattached\">Marionette.isNodeAttached</a></li> <li><a href=\"#marionettemergeoptions\">Marionette.mergeOptions</a></li> <li><a href=\"#marionettegetoption\">Marionette.getOption</a></li> <li><a href=\"#marionetteproxygetoption\">Marionette.proxyGetOption</a></li> <li><a href=\"#marionettetriggermethod\">Marionette.triggerMethod</a></li> <li><a href=\"#marionettebindentityevents\">Marionette.bindEntityEvents</a></li> <li><a href=\"#marionettetriggermethodon\">Marionette.triggerMethodOn</a></li> <li><a href=\"#marionettebindentityevents\">Marionette.bindEntityEvent</a></li> <li><a href=\"#marionetteunbindentityevents\">Marionette.unbindEntityEvents</a></li> <li><a href=\"#marionetteproxybindentityevents\">Marionette.proxyBindEntityEvents</a></li> <li><a href=\"#marionetteproxyunbindentityevents\">Marionette.proxyUnbindEntityEvents</a></li> <li><a href=\"#marionettenormalizemethods\">Marionette.normalizeMethods</a></li> <li><a href=\"#marionettenormalizeuikeys\">Marionette.normalizeUIKeys</a></li> <li><a href=\"#marionettenormalizeuivalues\">Marionette.normalizeUIValues</a></li> <li><a href=\"#marionetteactascollection\">Marionette.actAsCollection</a></li> </ul> <h2 id=\"marionetteextend\">\nMarionette.extend</h2>\n<p>Backbone's <code>extend</code> function is a useful utility to have, and is used invarious places in Marionette. To make the use of this method more consistent,Backbone's <code>extend</code> has been aliased to <code>Marionette.extend</code>. This allowsyou to get the extend functionality for your object without having todecide if you want to use Backbone.View or Backbone.Model or anotherBackbone object to grab the method from.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> Foo = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{};\n\n<span class=\"hljs-comment\">// use Marionette.extend to make Foo extendable, just like other</span>\n<span class=\"hljs-comment\">// Backbone and Marionette objects</span>\nFoo.extend = Marionette.extend;\n\n<span class=\"hljs-comment\">// Now Foo can be extended to create a new class, with methods</span>\n<span class=\"hljs-keyword\">var</span> Bar = Foo.extend({\n\n  someMethod: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{ ... }\n\n  <span class=\"hljs-comment\">// ...</span>\n});\n\n<span class=\"hljs-comment\">// Create an instance of Bar</span>\n<span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">new</span> Bar();\n</pre> <h2 id=\"marionetteisnodeattached\">\nMarionette.isNodeAttached</h2>\n<p>Determines whether the passed-in node is a child of the <code>document</code> or not.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> div = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'div'</span>);\nMarionette.isNodeAttached(div);\n<span class=\"hljs-comment\">// =&gt; false</span>\n\n$(<span class=\"hljs-string\">'body'</span>).append(div);\nMarionette.isNodeAttached(div);\n<span class=\"hljs-comment\">// =&gt; true</span>\n</pre> <h2 id=\"marionettemergeoptions\">\nMarionette.mergeOptions</h2>\n<p>A handy function to pluck certain <code>options</code> and attach them directly to an instance.Most Marionette Classes, such as the Views, come with this method.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = ItemView.extend({\n  myViewOptions: [<span class=\"hljs-string\">'color'</span>, <span class=\"hljs-string\">'size'</span>, <span class=\"hljs-string\">'country'</span>],\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.mergeOptions(options, <span class=\"hljs-keyword\">this</span>.myViewOptions);\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// The merged options will be attached directly to the prototype</span>\n    <span class=\"hljs-keyword\">this</span>.$el.addClass(<span class=\"hljs-keyword\">this</span>.color);\n  }\n});\n</pre> <h2 id=\"marionettegetoption\">\nMarionette.getOption</h2>\n<p>Retrieve an object's attribute either directly from the object, or fromthe object's <code>this.options</code>, with <code>this.options</code> taking precedence.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> M = Backbone.Model.extend({\n  foo: <span class=\"hljs-string\">\"bar\"</span>,\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(attributes, options)</span></span>{\n    <span class=\"hljs-keyword\">this</span>.options = options;\n    <span class=\"hljs-keyword\">var</span> f = Marionette.getOption(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">\"foo\"</span>);\n    <span class=\"hljs-built_in\">console</span>.log(f);\n  }\n});\n\n<span class=\"hljs-keyword\">new</span> M(); <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n\n<span class=\"hljs-keyword\">new</span> M({}, { foo: <span class=\"hljs-string\">\"quux\"</span> }); <span class=\"hljs-comment\">// =&gt; \"quux\"</span>\n</pre> <p>This is useful when building an object that can have configuration setin either the object definition or the object's constructor options.</p> <h3 id=\"falsey-values\">\nFalsey values</h3>\n<p>The <code>getOption</code> function will return any falsey value from the <code>options</code>,other than <code>undefined</code>. If an object's options has an undefined value, it willattempt to read the value from the object directly.</p> <p>For example:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> M = Backbone.Model.extend({\n  foo: <span class=\"hljs-string\">\"bar\"</span>,\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">var</span> f = Marionette.getOption(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">\"foo\"</span>);\n    <span class=\"hljs-built_in\">console</span>.log(f);\n  }\n});\n\n<span class=\"hljs-keyword\">new</span> M(); <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n\n<span class=\"hljs-keyword\">var</span> f;\n<span class=\"hljs-keyword\">new</span> M({}, { foo: f }); <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n</pre> <p>In this example, \"bar\" is returned both times because the secondexample has an undefined value for <code>f</code>.</p> <h2 id=\"marionetteproxygetoption\">\nMarionette.proxyGetOption</h2>\n<p>This method proxies <code>Marionette.getOption</code> so that it can be easily added to an instance.</p> <p>Say you've written your own Pagination class and you always pass options to it.With <code>proxyGetOption</code>, you can easily give this class the <code>getOption</code> function.</p> <pre data-language=\"js\">_.extend(Pagination.prototype, {\n\n  getFoo: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.getOption(<span class=\"hljs-string\">\"foo\"</span>);\n  },\n\n  getOption: Marionette.proxyGetOption\n});\n</pre> <h2 id=\"marionettetriggermethod\">\nMarionette.triggerMethod</h2>\n<p>Trigger an event and a corresponding method on the target object.</p> <p>When an event is triggered, the first letter of each section of theevent name is capitalized, and the word \"on\" is tagged on to the frontof it. Examples:</p> <ul> <li>\n<code>triggerMethod(\"render\")</code> fires the \"onRender\" function</li> <li>\n<code>triggerMethod(\"before:destroy\")</code> fires the \"onBeforeDestroy\" function</li> </ul> <p>All arguments that are passed to the triggerMethod call are passed along to both the event and the method, with the exception of the event name not being passed to the corresponding method.</p> <p><code>triggerMethod(\"foo\", bar)</code> will call <code>onFoo: function(bar){...})</code></p> <p>Note that <code>triggerMethod</code> can be called on objects that do not have<code>Backbone.Events</code> mixed in to them. These objects will not have a <code>trigger</code>method, and no attempt to call <code>.trigger()</code> will be made. The <code>on{Name}</code>callback methods will still be called, though.</p> <h2 id=\"marionettetriggermethodon\">\nMarionette.triggerMethodOn</h2>\n<p>Invoke <code>triggerMethod</code> on a specific context.</p> <p>This is useful when it's not clear that the object has <code>triggerMethod</code> defined. In the case of views, <code>Marionette.View</code> defines <code>triggerMethod</code>, but <code>Backbone.View</code> does not.</p> <pre data-language=\"js\">Marionette.triggerMethodOn(ctx, <span class=\"hljs-string\">\"foo\"</span>, bar);\n<span class=\"hljs-comment\">// will invoke `onFoo: function(bar){...})`</span>\n<span class=\"hljs-comment\">// will trigger \"foo\" on ctx</span>\n</pre> <h2 id=\"marionettebindentityevents\">\nMarionette.bindEntityEvents</h2>\n<p>This method is used to bind a backbone \"entity\" (e.g. collection/model)to methods on a target object.</p> <pre data-language=\"js\">Backbone.View.extend({\n\n  modelEvents: {\n    <span class=\"hljs-string\">\"change:foo\"</span>: <span class=\"hljs-string\">\"doSomething\"</span>\n  },\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    Marionette.bindEntityEvents(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>.model, <span class=\"hljs-keyword\">this</span>.modelEvents);\n  },\n\n  doSomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// the \"change:foo\" event was fired from the model</span>\n    <span class=\"hljs-comment\">// respond to it appropriately, here.</span>\n  }\n\n});\n</pre> <p>The first parameter, <code>target</code>, must have the Backbone.Events module mixed in.</p> <p>The second parameter is the <code>entity</code> (Backbone.Model, Backbone.Collection orany object that has Backbone.Events mixed in) to bind the events from.</p> <p>The third parameter is a hash of { \"event:name\": \"eventHandler\" }configuration. Multiple handlers can be separated by a space. Afunction can be supplied instead of a string handler name.</p> <h2 id=\"marionetteunbindentityevents\">\nMarionette.unbindEntityEvents</h2>\n<p>This method can be used to unbind callbacks from entities' (e.g. collection/model) events. It'sthe opposite of bindEntityEvents, described above. Consequently, the APIs are identical for each method.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// Just like the above example we bind our model events.</span>\n<span class=\"hljs-comment\">// This time, however, we unbind them on close.</span>\nBackbone.View.extend({\n\n  modelEvents: {\n    <span class=\"hljs-string\">\"change:foo\"</span>: <span class=\"hljs-string\">\"doSomething\"</span>\n  },\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    Marionette.bindEntityEvents(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>.model, <span class=\"hljs-keyword\">this</span>.modelEvents);\n  },\n\n  doSomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// the \"change:foo\" event was fired from the model</span>\n    <span class=\"hljs-comment\">// respond to it appropriately, here.</span>\n  },\n\n  onClose: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    Marionette.unbindEntityEvents(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>.model, <span class=\"hljs-keyword\">this</span>.modelEvents);\n  }\n\n});\n</pre> <h2 id=\"marionetteproxybindentityevents\">\nMarionette.proxyBindEntityEvents</h2>\n<p>This method proxies <code>Marionette.bindEntityEvents</code> so that it can easily be added to an instance.</p> <p>Say you've written your own Pagination class and you want to easily listen to some entities events.With <code>proxyBindEntityEvents</code>, you can easily give this class the <code>bindEntityEvents</code> function.</p> <pre data-language=\"js\">_.extend(Pagination.prototype, {\n\n   bindSomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n     <span class=\"hljs-keyword\">this</span>.bindEntityEvents(<span class=\"hljs-keyword\">this</span>.something, <span class=\"hljs-keyword\">this</span>.somethingEvents)\n   },\n\n   bindEntityEvents: Marionette.proxyBindEntityEvents\n\n});\n</pre> <h2 id=\"marionetteproxyunbindentityevents\">\nMarionette.proxyUnbindEntityEvents</h2>\n<p>This method proxies <code>Marionette.unbindEntityEvents</code> so that it can easily be added to an instance.</p> <p>It's the opposite of proxyBindEntityEvents, described above. Consequently, the APIs are identical for each method.</p> <p>Say you've written your own Pagination class and you want to easily unbind callbacks from some entities events.With <code>proxyUnbindEntityEvents</code>, you can easily give this class the <code>unbindEntityEvents</code> function.</p> <pre data-language=\"js\">_.extend(Pagination.prototype, {\n\n   bindSomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n     <span class=\"hljs-keyword\">this</span>.bindEntityEvents(<span class=\"hljs-keyword\">this</span>.something, <span class=\"hljs-keyword\">this</span>.somethingEvents)\n   },\n\n   unbindSomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n     <span class=\"hljs-keyword\">this</span>.unbindEntityEvents(<span class=\"hljs-keyword\">this</span>.something, <span class=\"hljs-keyword\">this</span>.somethingEvents)\n   },\n\n   bindEntityEvents: Marionette.proxyBindEntityEvents,\n\n   unbindEntityEvents: Marionette.proxyUnbindEntityEvents\n\n});\n</pre> <h2 id=\"marionettenormalizemethods\">\nMarionette.normalizeMethods</h2>\n<p>Receives a hash of event names and functions and/or function names, and returns thesame hash with the function names replaced with the function references themselves.</p> <p>This function is attached to the <code>Marionette.View</code> prototype by default. To use it from non-View classes you'll need to attach it yourself.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> View = Marionette.ItemView.extend({\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.someFn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{};\n    <span class=\"hljs-keyword\">this</span>.someOtherFn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{};\n    <span class=\"hljs-keyword\">var</span> hash = {\n      eventOne: <span class=\"hljs-string\">\"someFn\"</span>, <span class=\"hljs-comment\">// This will become a reference to `this.someFn`</span>\n      eventTwo: <span class=\"hljs-keyword\">this</span>.someOtherFn\n    };\n    <span class=\"hljs-keyword\">this</span>.normalizedHash = <span class=\"hljs-keyword\">this</span>.normalizeMethods(hash);\n  }\n\n});\n</pre> <h2 id=\"marionettenormalizeuikeys\">\nMarionette.normalizeUIKeys</h2>\n<p>This method allows you to use the <code>@ui.</code> syntax within a given key for triggers and events hashes. Itswaps the <code>@ui.</code> reference with the associated selector.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> hash = {\n  <span class=\"hljs-string\">'click @ui.list'</span>: <span class=\"hljs-string\">'myCb'</span>\n};\n\n<span class=\"hljs-keyword\">var</span> ui = {\n  <span class=\"hljs-string\">'list'</span>: <span class=\"hljs-string\">'ul'</span>\n};\n\n<span class=\"hljs-comment\">// This sets 'click @ui.list' to be 'click ul' in the newHash object</span>\n<span class=\"hljs-keyword\">var</span> newHash = Marionette.normalizeUIKeys(hash, ui);\n</pre> <h2 id=\"marionettenormalizeuivalues\">\nMarionette.normalizeUIValues</h2>\n<p>This method allows you to use the <code>@ui.</code> syntax within a given hash value (for example region hashes). Itswaps the <code>@ui.</code> reference with the associated selector.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> hash = {\n  <span class=\"hljs-string\">'foo'</span>: <span class=\"hljs-string\"><a class=\"__cf_email__\" href=\"http://marionettejs.com/cdn-cgi/l/email-protection\" data-cfemail=\"e2c5a2978bcc808390\">[email protected]</a>'</span>\n};\n\n<span class=\"hljs-keyword\">var</span> ui = {\n  <span class=\"hljs-string\">'bar'</span>: <span class=\"hljs-string\">'.quux'</span>\n};\n\n<span class=\"hljs-comment\">// This sets 'foo' to be '.quux' in the newHash object</span>\n<span class=\"hljs-keyword\">var</span> newHash = Marionette.normalizeUIValues(hash, ui);\n</pre> <h2 id=\"marionetteactascollection\">\nMarionette.actAsCollection</h2>\n<p>Utility function for mixing in underscore collection behavior to an object.</p> <p>It works by taking an object and a property field, in this example 'list',and appending collection functions to the object so that it candelegate collection calls to its list.</p> <h4>\nObject Literal</h4>\n<pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> obj = {\n  list: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n}\n\nMarionette.actAsCollection(obj, <span class=\"hljs-string\">'list'</span>);\n\n<span class=\"hljs-keyword\">var</span> double = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(v)</span></span>{ <span class=\"hljs-keyword\">return</span> v*<span class=\"hljs-number\">2</span>};\n<span class=\"hljs-built_in\">console</span>.log(obj.map(double)); <span class=\"hljs-comment\">// [2, 4, 6]</span>\n</pre> <h4>\nFunction Prototype</h4>\n<pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> Func = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(list)</span> </span>{\n  <span class=\"hljs-keyword\">this</span>.list = list;\n};\n\nMarionette.actAsCollection(Func.prototype, <span class=\"hljs-string\">'list'</span>);\n<span class=\"hljs-keyword\">var</span> func = <span class=\"hljs-keyword\">new</span> Func([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]);\n\n\n<span class=\"hljs-keyword\">var</span> double = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(v)</span></span>{ <span class=\"hljs-keyword\">return</span> v*<span class=\"hljs-number\">2</span>};\n<span class=\"hljs-built_in\">console</span>.log(func.map(double)); <span class=\"hljs-comment\">// [2, 4, 6]</span>\n</pre> <p>The first parameter is the object that will delegate underscore collection methods.</p> <p>The second parameter is the object field that will hold the list.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.functions.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.functions.html</a>\n  </p>\n</div>\n","marionette.renderer":"<h1>\nMarionette.Renderer</h1>\n<p>The <code>Renderer</code> object was extracted from the <code>ItemView</code> renderingprocess, in order to create a consistent and re-usable method ofrendering a template with or without data.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#basic-usage\">Basic Usage</a></li> <li><a href=\"#pre-compiled-templates\">Pre-compiled Templates</a></li> <li><a href=\"#custom-template-selection-and-rendering\">Custom Template Selection And Rendering</a></li> <li><a href=\"#using-pre-compiled-templates\">Using Pre-compiled Templates</a></li> </ul> <h2 id=\"basic-usage\">\nBasic Usage</h2>\n<p>The basic usage of the <code>Renderer</code> is to call the <code>render</code> method.This method returns a string containing the result of applying thetemplate using the <code>data</code> object as the context.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> template = <span class=\"hljs-string\">\"#some-template\"</span>;\n<span class=\"hljs-keyword\">var</span> data = {foo: <span class=\"hljs-string\">\"bar\"</span>};\n<span class=\"hljs-keyword\">var</span> html = Marionette.Renderer.render(template, data);\n\n<span class=\"hljs-comment\">// do something with the HTML here</span>\n</pre> <p>If you pass a <code>template</code> that coerces to a falsey value, the<code>render</code> method will throw an exception stating that there was notemplate provided.</p> <h2 id=\"pre-compiled-templates\">\nPre-compiled Templates</h2>\n<p>If the <code>template</code> parameter of the <code>render</code> function is itself a function,the renderer treats this as a pre-compiled template and does not try tocompile it again. This allows any view that supports a <code>template</code> parameterto specify a pre-compiled template function as the <code>template</code> setting.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> myTemplate = _.template(<span class=\"hljs-string\">\"&lt;div&gt;foo&lt;/div&gt;\"</span>);\nMarionette.ItemView.extend({\n  template: myTemplate\n});\n</pre> <p>The template function does not have to be any specific template engine. Itonly needs to be a function that returns valid HTML as a string from the<code>data</code> parameter passed to the function.</p> <h2 id=\"custom-template-selection-and-rendering\">\nCustom Template Selection And Rendering</h2>\n<p>By default, the renderer will take a jQuery selector object asthe first parameter, and a JSON data object as the optionalsecond parameter. It then uses the <code>TemplateCache</code> to load thetemplate by the specified selector, and renders the template withthe data provided (if any) using Underscore.js templates.</p> <p>If you wish to override the way the template is loaded, seethe <code>TemplateCache</code> object.</p> <p>If you wish to override the template engine used, change the<code>render</code> method to work however you want:</p> <pre data-language=\"js\">Marionette.Renderer.render = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(template, data)</span></span>{\n  <span class=\"hljs-keyword\">return</span> $(template).tmpl(data);\n};\n</pre> <p>This implementation will replace the default Underscore.jsrendering with jQuery templates rendering.</p> <p>If you override the <code>render</code> method and wish to use the<code>TemplateCache</code> mechanism, remember to include the code necessary tofetch the template from the cache in your <code>render</code> method:</p> <pre data-language=\"js\">Marionette.Renderer.render = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(template, data)</span></span>{\n  <span class=\"hljs-keyword\">var</span> template = Marionette.TemplateCache.get(template);\n  <span class=\"hljs-comment\">// Do something with the template here</span>\n};\n</pre> <h2 id=\"using-pre-compiled-templates\">\nUsing Pre-compiled Templates</h2>\n<p>You can easily replace the standard template rendering functionalitywith a pre-compiled template, such as those provided by the JST or TPLplugins for AMD/RequireJS.</p> <p>To do this, just override the <code>render</code> method to return your executedtemplate with the data.</p> <pre data-language=\"js\">Marionette.Renderer.render = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(template, data)</span></span>{\n  <span class=\"hljs-keyword\">return</span> template(data);\n};\n</pre> <p>Then you can specify the pre-compiled template function as your view's<code>template</code> attribute:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> myPrecompiledTemplate = _.template(<span class=\"hljs-string\">\"&lt;div&gt;some template&lt;/div&gt;\"</span>);\n\nMarionette.ItemView.extend({\n  template: myPrecompiledTemplate\n});\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.renderer.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.renderer.html</a>\n  </p>\n</div>\n","marionette.view":"<h1>\nMarionette.View</h1>\n<p>Marionette has a base <code>Marionette.View</code> class that other views extend from.This base view provides some common and core functionality forother views to take advantage of.</p> <p><strong>Note:</strong> The <code>Marionette.View</code> class is not intended to beused directly. It exists as a base view for other view classesto be extended from, and to provide a common location forbehaviors that are shared across all views.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#binding-to-view-events\">Binding To View Events</a></li> <li><a href=\"#view-onshow\">View onShow</a></li> <li><a href=\"#view-destroy\">View destroy</a></li> <li><a href=\"#view-onbeforedestroy\">View onBeforeDestroy</a></li> <li><a href=\"#view-attach--onattach-event\">View \"attach\" / onAttach event</a></li> <li><a href=\"#view-beforeattach--onbeforeattach-event\">View \"before:attach\" / onBeforeAttach event</a></li> <li><a href=\"#view-domrefresh--ondomrefresh-event\">View \"dom:refresh\" / onDomRefresh event</a></li> <li><a href=\"#viewevents\">View.events</a></li> <li><a href=\"#viewtriggers\">View.triggers</a></li> <li><a href=\"#viewmodelevents-and-viewcollectionevents\">View.modelEvents and View.collectionEvents</a></li> <li><a href=\"#viewserializemodel\">View.serializeModel</a></li> <li><a href=\"#viewbinduielements\">View.bindUIElements</a></li> <li><a href=\"#viewmergeoptions\">View.mergeOptions</a></li> <li><a href=\"#viewgetoption\">View.getOption</a></li> <li><a href=\"#viewbindentityevents\">View.bindEntityEvents</a></li> <li>\n<a href=\"#viewtemplatehelpers\">View.templateHelpers</a><ul> <li><a href=\"#basic-example\">Basic Example</a></li> <li><a href=\"#accessing-data-within-the-helpers\">Accessing Data Within The Helpers</a></li> <li><a href=\"#object-or-function-as-templatehelpers\">Object Or Function As <code>templateHelpers</code></a></li> </ul> </li> <li><a href=\"#change-which-template-is-rendered-for-a-view\">Change Which Template Is Rendered For A View</a></li> <li><a href=\"#ui-interpolation\">UI Interpolation</a></li> </ul> <h2 id=\"binding-to-view-events\">\nBinding To View Events</h2>\n<p>Marionette.View extends <code>Backbone.View</code>. It is recommended that you usethe <code>listenTo</code> method to bind model, collection, or other events from Backboneand Marionette objects.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">this</span>.listenTo(<span class=\"hljs-keyword\">this</span>.model, <span class=\"hljs-string\">\"change:foo\"</span>, <span class=\"hljs-keyword\">this</span>.modelChanged);\n    <span class=\"hljs-keyword\">this</span>.listenTo(<span class=\"hljs-keyword\">this</span>.collection, <span class=\"hljs-string\">\"add\"</span>, <span class=\"hljs-keyword\">this</span>.modelAdded);\n  },\n\n  modelChanged: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(model, value)</span></span>{\n  },\n\n  modelAdded: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(model)</span></span>{\n  }\n});\n</pre> <p>The context (<code>this</code>) will automatically be set to the view. You canoptionally set the context by using <code>_.bind</code>.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// Force the context of the \"reconcileCollection\" callback method to be the collection</span>\n<span class=\"hljs-comment\">// itself, for this event handler only (does not affect any other use of the</span>\n<span class=\"hljs-comment\">// \"reconcileCollection\" method)</span>\n<span class=\"hljs-keyword\">this</span>.listenTo(<span class=\"hljs-keyword\">this</span>.collection, <span class=\"hljs-string\">\"add\"</span>, _.bind(<span class=\"hljs-keyword\">this</span>.reconcileCollection, <span class=\"hljs-keyword\">this</span>.collection));\n</pre> <h2 id=\"view-onshow\">\nView onShow</h2>\n<ul> <li>\"show\" / <code>onShow</code> - Called on the view instance when the view has been rendered and displayed.</li> </ul> <p>This event can be used to react to when a view has been shown via a <a href=\"marionette.region\">region</a>.All <code>views</code> that inherit from the base <code>Marionette.View</code> class have this functionality, notably <code>ItemView</code>, <code>CollectionView</code>, <code>CompositeView</code>, and <code>LayoutView</code>.</p> <pre data-language=\"js\">Marionette.ItemView.extend({\n  onShow: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// react to when a view has been shown</span>\n  }\n});\n</pre> <p>A common use case for the <code>onShow</code> method is to use it to add children views.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> LayoutView = Marionette.LayoutView.extend({\n   regions: {\n     Header: <span class=\"hljs-string\">'header'</span>,\n     Section: <span class=\"hljs-string\">'section'</span>\n   },\n   onShow: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n      <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'Header'</span>, <span class=\"hljs-keyword\">new</span> Header());\n      <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'Section'</span>, <span class=\"hljs-keyword\">new</span> Section());\n   }\n});\n</pre> <h2 id=\"view-destroy\">\nView destroy</h2>\n<p>View implements a <code>destroy</code> method, which is called by the regionmanagers automatically. As part of the implementation, the followingare performed:</p> <ul> <li>call an <code>onBeforeDestroy</code> event on the view, if one is provided</li> <li>call an <code>onDestroy</code> event on the view, if one is provided</li> <li>unbind all custom view events</li> <li>unbind all DOM events</li> <li>remove <code>this.el</code> from the DOM</li> <li>unbind all <code>listenTo</code> events</li> <li>returns the view.</li> </ul> <p>By providing an <code>onDestroy</code> method in your view definition, you canrun custom code for your view that is fired after your view has beendestroyed and cleaned up. The <code>onDestroy</code> method will be passed any argumentsthat <code>destroy</code> was invoked with. This lets you handle any additional cleanup code without having to override the <code>destroy</code> method.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  onDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(arg1, arg2)</span></span>{\n    <span class=\"hljs-comment\">// custom cleanup or destroying code, here</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> v = <span class=\"hljs-keyword\">new</span> MyView();\nv.destroy(arg1, arg2);\n</pre> <h2 id=\"view-onbeforedestroy\">\nView onBeforeDestroy</h2>\n<p>When destroying a view, an <code>onBeforeDestroy</code> method will be called, if ithas been provided, just before the view destroys. It will be passed any argumentsthat <code>destroy</code> was invoked with.</p> <h3 id=\"view-attach--onattach-event\">\nView \"attach\" / onAttach event</h3>\n<p>Every view in Marionette has a special event called \"attach,\" which is triggered anytime that showingthe view in a Region causes it to be attached to the <code>document</code>. Like other Marionette events, it alsoexecutes a callback method, <code>onAttach</code>, if you've specified one. The <code>\"attach\"</code> event is great for jQueryplugins or other logic that must be executed <em>after</em> the view is attached to the <code>document</code>.</p> <p>The <code>attach</code> event is only fired when the view becomes a child of the <code>document</code>. If the Region you're showing the view in is not a child of the <code>document</code> at the time that you call <code>show</code> then the <code>attach</code> event will not fire until the Region is a child of the <code>document</code>.</p> <p>This event is unique in that it propagates down the view tree. For instance, when a CollectionView's<code>attach</code> event is fired, all of its children views will have the <code>attach</code> event fired as well. Inaddition, deeply nested Layout View structures will all have their <code>attach</code> event fired at the propertime, too.</p> <p>For more on efficient, deeply-nested view structures, refer to the LayoutView docs.</p> <h3 id=\"view-beforeattach--onbeforeattach-event\">\nView \"before:attach\" / onBeforeAttach event</h3>\n<p>This is just like the attach event described above, but it's triggered right before the view isattached to the document.</p> <h3 id=\"view-domrefresh--ondomrefresh-event\">\nView \"dom:refresh\" / onDomRefresh event</h3>\n<p>Triggered after the view has been rendered, has been shown in the DOM via a Marionette.Region, and has beenre-rendered.</p> <p>This event / callback is useful for<a href=\"http://lostechies.com/derickbailey/2012/02/20/using-jquery-plugins-and-ui-controls-with-backbone/\">DOM-dependent UI plugins</a> such as<a href=\"http://jqueryui.com/\">jQueryUI</a> or <a href=\"http://kendoui.com\">KendoUI</a>.</p> <pre data-language=\"js\">Marionette.ItemView.extend({\n  onDomRefresh: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// manipulate the `el` here. it's already</span>\n    <span class=\"hljs-comment\">// been rendered, and is full of the view's</span>\n    <span class=\"hljs-comment\">// HTML, ready to go.</span>\n  }\n});\n</pre> <p>For more information about integration Marionette w/ KendoUI (also applicable to jQueryUI and other UIwidget suites), see <a href=\"http://www.kendoui.com/blogs/teamblog/posts/12-11-26/backbone_and_kendo_ui_a_beautiful_combination.aspx\">this blog post on KendoUI + Backbone</a>.</p> <h2 id=\"viewevents\">\nView.events</h2>\n<p>Since Views extend from backbone's view class, you gain the benefits of the <a href=\"http://backbonejs.org/#View-delegateEvents\">events hash</a>.</p> <p>Some preprocessing sugar is added on top to add the ability to cross utilize the <code>ui</code> hash.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  ui: {\n    <span class=\"hljs-string\">\"cat\"</span>: <span class=\"hljs-string\">\".dog\"</span>\n  },\n\n  events: {\n    <span class=\"hljs-string\">\"click @ui.cat\"</span>: <span class=\"hljs-string\">\"bark\"</span> <span class=\"hljs-comment\">//is the same as \"click .dog\":</span>\n  }\n});\n</pre> <h2 id=\"viewtriggers\">\nView.triggers</h2>\n<p>Views can define a set of <code>triggers</code> as a hash, which willconvert a DOM event into a<a href=\"marionette.functions#marionettetriggermethod\"><code>view.triggerMethod</code></a> call.</p> <p>The left side of the hash is a standard Backbone.View DOMevent configuration, while the right side of the hash is theview event that you want to trigger from the view.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  triggers: {\n    <span class=\"hljs-string\">\"click .do-something\"</span>: <span class=\"hljs-string\">\"something:do:it\"</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> MyView();\nview.render();\n\nview.on(<span class=\"hljs-string\">\"something:do:it\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(args)</span></span>{\n  alert(<span class=\"hljs-string\">\"I DID IT!\"</span>);\n});\n\n<span class=\"hljs-comment\">// \"click\" the 'do-something' DOM element to</span>\n<span class=\"hljs-comment\">// demonstrate the DOM event conversion</span>\nview.$(<span class=\"hljs-string\">\".do-something\"</span>).trigger(<span class=\"hljs-string\">\"click\"</span>);\n</pre> <p>The result of this is an alert box that says, \"I DID IT!\" Triggers can also beexecuted using the 'on{EventName}' attribute.</p> <p>By default all triggers are stopped with <code>preventDefault</code> and<code>stopPropagation</code> methods. But you can manually configure the triggers usinghash instead of event name. Example below triggers an event and preventsdefault browser behaviour using <code>preventDefault</code> method.</p> <pre data-language=\"js\">Marionette.CompositeView.extend({\n  triggers: {\n    <span class=\"hljs-string\">\"click .do-something\"</span>: {\n      event: <span class=\"hljs-string\">\"something:do:it\"</span>,\n      preventDefault: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">// this param is optional and will default to true</span>\n      stopPropagation: <span class=\"hljs-literal\">false</span>\n    }\n  }\n});\n</pre> <p>You can also specify the <code>triggers</code> as a function thatreturns a hash of trigger configurations</p> <pre data-language=\"js\">Marionette.CompositeView.extend({\n  triggers: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-string\">\"click .that-thing\"</span>: <span class=\"hljs-string\">\"that:i:sent:you\"</span>\n    };\n  }\n});\n</pre> <p>Trigger keys can be configured to cross utilize the <code>ui</code> hash.</p> <pre data-language=\"js\">Marionette.ItemView.extend({\n  ui: {\n     <span class=\"hljs-string\">'monkey'</span>: <span class=\"hljs-string\">'.guybrush'</span>\n  },\n  triggers: {\n    <span class=\"hljs-string\">'click @ui.monkey'</span>: <span class=\"hljs-string\">'see:LeChuck'</span> <span class=\"hljs-comment\">// equivalent of \"click .guybrush\"</span>\n  }\n});\n</pre> <p>Triggers work with all View classes that extend from the baseMarionette.View.</p> <h3 id=\"trigger-handler-arguments\">\nTrigger Handler Arguments</h3>\n<p>A <code>trigger</code> event handler will receive a single argument thatincludes the following:</p> <ul> <li>view</li> <li>model</li> <li>collection</li> </ul> <p>These properties match the <code>view</code>, <code>model</code>, and <code>collection</code> properties of the view that triggered the event.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  triggers: {\n    <span class=\"hljs-string\">\"click .do-something\"</span>: <span class=\"hljs-string\">\"some:event\"</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> MyView();\n\nview.on(<span class=\"hljs-string\">\"some:event\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(args)</span></span>{\n  args.view; <span class=\"hljs-comment\">// =&gt; the view instance that triggered the event</span>\n  args.model; <span class=\"hljs-comment\">// =&gt; the view.model, if one was set on the view</span>\n  args.collection; <span class=\"hljs-comment\">// =&gt; the view.collection, if one was set on the view</span>\n});\n</pre> <p>Having access to these allows more flexibility in handling events frommultiple views. For example, a tab control or expand/collapse widget suchas a panel bar could trigger the same event from many different viewsand be handled with a single function.</p> <h2 id=\"viewmodelevents-and-viewcollectionevents\">\nView.modelEvents and View.collectionEvents</h2>\n<p>Similar to the <code>events</code> hash, views can specify a configurationhash for collections and models. The left side is the event onthe model or collection, and the right side is the name of themethod on the view.</p> <pre data-language=\"js\">Marionette.CompositeView.extend({\n\n  modelEvents: {\n    <span class=\"hljs-string\">\"change:name\"</span>: <span class=\"hljs-string\">\"nameChanged\"</span> <span class=\"hljs-comment\">// equivalent to view.listenTo(view.model, \"change:name\", view.nameChanged, view)</span>\n  },\n\n  collectionEvents: {\n    <span class=\"hljs-string\">\"add\"</span>: <span class=\"hljs-string\">\"itemAdded\"</span> <span class=\"hljs-comment\">// equivalent to view.listenTo(view.collection, \"add\", view.itemAdded, view)</span>\n  },\n\n  <span class=\"hljs-comment\">// ... event handler methods</span>\n  nameChanged: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{ <span class=\"hljs-comment\">/* ... */</span> },\n  itemAdded: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{ <span class=\"hljs-comment\">/* ... */</span> },\n\n})\n</pre> <p>These will use the memory safe <code>listenTo</code>, and will set the context(the value of <code>this</code>) in the handler to be the view. Events arebound at the time of instantiation, and an exception will be thrownif the handlers on the view do not exist.</p> <p>The <code>modelEvents</code> and <code>collectionEvents</code> will be bound andunbound with the Backbone.View <code>delegateEvents</code> and <code>undelegateEvents</code>method calls. This allows the view to be re-used and havethe model and collection events re-bound.</p> <h3 id=\"multiple-callbacks\">\nMultiple Callbacks</h3>\n<p>Multiple callback functions can be specified by separating them with aspace.</p> <pre data-language=\"js\">Marionette.CompositeView.extend({\n\n  modelEvents: {\n    <span class=\"hljs-string\">\"change:name\"</span>: <span class=\"hljs-string\">\"nameChanged thatThing\"</span>\n  },\n\n  nameChanged: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{ },\n\n  thatThing: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{ },\n});\n</pre> <p>This works in both <code>modelEvents</code> and <code>collectionEvents</code>.</p> <h3 id=\"callbacks-as-function\">\nCallbacks As Function</h3>\n<p>A single function can be declared directly in-line instead of specifying acallback via a string method name.</p> <pre data-language=\"js\">Marionette.CompositeView.extend({\n\n  modelEvents: {\n    <span class=\"hljs-string\">\"change:name\"</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n      <span class=\"hljs-comment\">// handle the name changed event here</span>\n    }\n  }\n\n});\n</pre> <p>This works for both <code>modelEvents</code> and <code>collectionEvents</code>.</p> <h3 id=\"event-configuration-as-function\">\nEvent Configuration As Function</h3>\n<p>A function can be used to declare the event configuration as long asthat function returns a hash that fits the above configuration options.</p> <pre data-language=\"js\">Marionette.CompositeView.extend({\n\n  modelEvents: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-string\">\"change:name\"</span>: <span class=\"hljs-string\">\"someFunc\"</span> };\n  }\n\n});\n</pre> <p>This works for both <code>modelEvents</code> and <code>collectionEvents</code>.</p> <h2 id=\"viewserializemodel\">\nView.serializeModel</h2>\n<p>The <code>serializeModel</code> method will serialize a model that is passed in as an argument.</p> <h2 id=\"viewbinduielements\">\nView.bindUIElements</h2>\n<p>In several cases you need to access ui elements inside the viewto retrieve their data or manipulate them. For example you have acertain div element you need to show/hide based on some state,or other ui element that you wish to set a css class to it.Instead of having jQuery selectors hanging around in the view's codeyou can define a <code>ui</code> hash that contains a mapping between theui element's name and its jQuery selector. Afterwards you can simplyaccess it via <code>this.ui.elementName</code>.See ItemView documentation for examples.</p> <p>This functionality is provided via the <code>bindUIElements</code> method.Since View doesn't implement the render method, then if you directly extendfrom View you will need to invoke this method from your render method.In ItemView and CompositeView this is already taken care of.</p> <h2 id=\"viewmergeoptions\">\nView.mergeOptions</h2>\n<p>The preferred way to manage your view's options is with <code>mergeOptions</code>. It accepts two arguments: the <code>options</code> objectand the keys to merge onto the instance directly.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> ProfileView = Marionette.ItemView.extend({\n  profileViewOptions: [<span class=\"hljs-string\">'user'</span>, <span class=\"hljs-string\">'age'</span>],\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.mergeOptions(options, <span class=\"hljs-keyword\">this</span>.profileViewOptions);\n\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'The merged options are:'</span>, <span class=\"hljs-keyword\">this</span>.user, <span class=\"hljs-keyword\">this</span>.age);\n  }\n});\n</pre> <p>More information <a href=\"marionette.functions#marionettemergeoptions\">mergeOptions</a></p> <h2 id=\"viewgetoption\">\nView.getOption</h2>\n<p>Retrieve an object's attribute either directly from the object, or from the object's this.options, with this.options taking precedence.</p> <p>More information <a href=\"marionette.functions#marionettegetoption\">getOption</a></p> <h2 id=\"viewbindentityevents\">\nView.bindEntityEvents</h2>\n<p>Helps bind a backbone \"entity\" to methods on a target object. bindEntityEvents is used to support <code>modelEvents</code> and <code>collectionEvents</code>.</p> <p>More information <a href=\"marionette.functions#marionettebindentityevents\">bindEntityEvents</a></p> <h2 id=\"viewtemplatehelpers\">\nView.templateHelpers</h2>\n<p>There are times when a view's template needs to have somelogic in it and the view engine itself will not provide aneasy way to accomplish this. For example, Underscore templatesdo not provide a helper method mechanism while Handlebarstemplates do.</p> <p>A <code>templateHelpers</code> attribute can be applied to any View object thatrenders a template. When this attribute is present its contentswill be mixed in to the data object that comes back from the<code>serializeData</code> method. This will allow you to create helper methodsthat can be called from within your templates. This is also a good placeto add data not returned from <code>serializeData</code>, such as calculated values.</p> <h3 id=\"basic-example\">\nBasic Example</h3>\n<pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"my-template\"</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"text/html\"</span>&gt;</span><span class=\"javascript\">\n  I &lt;%= percent %&gt;% think that &lt;%= showMessage() %&gt;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</pre> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  template: <span class=\"hljs-string\">\"#my-template\"</span>,\n\n  templateHelpers: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> {\n      showMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.name + <span class=\"hljs-string\">\" is the coolest!\"</span>;\n      },\n\n      percent: <span class=\"hljs-keyword\">this</span>.model.get(<span class=\"hljs-string\">'decimal'</span>) * <span class=\"hljs-number\">100</span>\n    };\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> model = <span class=\"hljs-keyword\">new</span> Backbone.Model({\n  name: <span class=\"hljs-string\">\"Marionette\"</span>,\n  decimal: <span class=\"hljs-number\">1</span>\n});\n<span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> MyView({\n  model: model\n});\n\nview.render(); <span class=\"hljs-comment\">//=&gt; \"I 100% think that Marionette is the coolest!\";</span>\n</pre> <p>The <code>templateHelpers</code> can also be provided as a constructor parameterfor any Marionette view class that supports the helpers.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  <span class=\"hljs-comment\">// ...</span>\n});\n\n<span class=\"hljs-keyword\">new</span> MyView({\n  templateHelpers: {\n    doFoo: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{ <span class=\"hljs-comment\">/* ... */</span> }\n  }\n});\n</pre> <h3 id=\"accessing-data-within-the-helpers\">\nAccessing Data Within The Helpers</h3>\n<p>In order to access data from within the helper methods, youneed to prefix the data you need with <code>this</code>. Doing that willgive you all of the methods and attributes of the serializeddata object, including the other helper methods.</p> <pre data-language=\"js\">templateHelpers: {\n  something: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Do stuff with \"</span> + <span class=\"hljs-keyword\">this</span>.name + <span class=\"hljs-string\">\" because it's awesome.\"</span>;\n  }\n}\n</pre> <h3 id=\"object-or-function-as-templatehelpers\">\nObject Or Function As <code>templateHelpers</code>\n</h3>\n<p>You can specify an object literal (as shown above), a referenceto an object literal, or a function as the <code>templateHelpers</code>.</p> <p>If you specify a function, the function will be invokedwith the current view instance as the context of thefunction. The function must return an object that can bemixed in to the data for the view.</p> <pre data-language=\"js\">Marionette.ItemView.extend({\n  templateHelpers: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">return</span> {\n      foo: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{ <span class=\"hljs-comment\">/* ... */</span> }\n    }\n  }\n});\n</pre> <h2 id=\"change-which-template-is-rendered-for-a-view\">\nChange Which Template Is Rendered For A View</h2>\n<p>There may be some cases where you need to change the template that isused for a view, based on some simple logic such as the value of aspecific attribute in the view's model. To do this, you can providea <code>getTemplate</code> function on your views and use this to return thetemplate that you need.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  getTemplate: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.model.get(<span class=\"hljs-string\">\"foo\"</span>)){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"#some-template\"</span>;\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"#a-different-template\"</span>;\n    }\n  }\n});\n</pre> <p>This applies to all view classes.</p> <h2 id=\"ui-interpolation\">\nUI Interpolation</h2>\n<p>Marionette UI offers a convenient way to reference jQuery elements.UI elements can also be interpolated into event and region selectors.</p> <p>In this example, the buy button is referenced in a DOM event and the checkout section is referenced in the region selector.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n\n  ui: {\n    buyButton: <span class=\"hljs-string\">'.buy-button'</span>,\n    checkoutSection: <span class=\"hljs-string\">'.checkout-section'</span>\n  },\n\n  events: {\n    <span class=\"hljs-string\">'click @ui.buyButton'</span>: <span class=\"hljs-string\">'onClickBuyButton'</span>\n  },\n\n  regions: {\n    checkoutSection: <span class=\"hljs-string\"><a class=\"__cf_email__\" href=\"http://marionettejs.com/cdn-cgi/l/email-protection\" data-cfemail=\"280f685d41064b404d4b43475d5c7b4d4b5c414746\">[email protected]</a>'</span>\n  },\n\n  onShow: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.getRegion(<span class=\"hljs-string\">'checkoutSection'</span>).show(<span class=\"hljs-keyword\">new</span> CheckoutSection({\n      model: <span class=\"hljs-keyword\">this</span>.checkoutModel\n    }));\n  }\n});\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.view.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.view.html</a>\n  </p>\n</div>\n","marionette.compositeview":"<h1>\nMarionette.CompositeView</h1>\n<p>A <code>CompositeView</code> extends from <code>CollectionView</code> to be used as acomposite view for scenarios where it should represent both abranch and leaf in a tree structure, or for scenarios where acollection needs to be rendered within a wrapper template. By default the<code>CompositeView</code> will maintain a sorted collection's orderin the DOM. This behavior can be disabled by specifying <code>{sort: false}</code> on initialize.</p> <p>Please see<a href=\"marionette.collectionview\">the Marionette.CollectionView documentation</a>for more information on available features and functionality.</p> <p>Additionally, interactions with Marionette.Regionwill provide features such as <code>onShow</code> callbacks, etc. Please see<a href=\"marionette.region\">the Region documentation</a> for more information.</p> <h2 id=\"example-usage-tree-view\">\nExample Usage: Tree View</h2>\n<p>For example, if you're rendering a tree-view control, you maywant to render a collection view with a model and template sothat it will show a parent child with children in the tree.</p> <p>You can specify a <code>modelView</code> to use for the model. If you don'tspecify one, it will default to the <code>Marionette.ItemView</code>.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> CompositeView = Marionette.CompositeView.extend({\n  template: <span class=\"hljs-string\">\"#leaf-branch-template\"</span>\n});\n\n<span class=\"hljs-keyword\">new</span> CompositeView({\n  model: someModel,\n  collection: someCollection\n});\n</pre> <p>For more examples, see my blog post on<a href=\"http://lostechies.com/derickbailey/2012/04/05/composite-views-tree-structures-tables-and-more/\">using the composite view.</a></p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#composite-model-template\">Composite Model <code>template</code></a></li> <li><a href=\"#compositeviews-childview\">CompositeView's <code>childView</code></a></li> <li><a href=\"#compositeviews-childviewcontainer\">CompositeView's <code>childViewContainer</code></a></li> <li><a href=\"#compositeviews-attachhtml\">CompositeView's <code>attachHtml</code></a></li> <li><a href=\"#recursive-by-default\">Recursive By Default</a></li> <li><a href=\"#model-and-collection-rendering\">Model And Collection Rendering</a></li> <li><a href=\"#events-and-callbacks\">Events And Callbacks</a></li> <li><a href=\"#organizing-ui-elements\">Organizing UI elements</a></li> <li><a href=\"#modelevents-and-collectionevents\">modelEvents and collectionEvents</a></li> </ul> <h2 id=\"composite-model-template\">\nComposite Model <code>template</code>\n</h2>\n<p>When a <code>CompositeView</code> is rendered, the <code>model</code> will be renderedwith the <code>template</code> that the view is configured with. You canoverride the template by passing it in as a constructor option:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">new</span> MyComp({\n  template: <span class=\"hljs-string\">\"#some-template\"</span>\n});\n</pre> <p>The <code>collection</code> option is not passed to the template context bydefault. If your <code>template</code> needs access to the collection, you'llneed to pass it via <code>templateHelpers</code>:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">new</span> MyComp({\n  template: <span class=\"hljs-string\">\"#some-template\"</span>,\n  templateHelpers: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> { items: <span class=\"hljs-keyword\">this</span>.collection.toJSON() };\n  }\n})\n</pre> <h2 id=\"compositeviews-childview\">\nCompositeView's <code>childView</code>\n</h2>\n<p>Each childView will be rendered using the <code>childView</code>'s template. The <code>CompositeView</code>'stemplate is rendered and the childView's templates are added to this.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> ChildView = Marionette.ItemView.extend({});\n\n<span class=\"hljs-keyword\">var</span> CompView = Marionette.CompositeView.extend({\n  childView: ChildView\n});\n</pre> <h2 id=\"compositeviews-childviewcontainer\">\nCompositeView's <code>childViewContainer</code>\n</h2>\n<p>By default the composite view uses the same <code>attachHtml</code> method that thecollection view provides. This means the view will call jQuery's <code>.append</code>to move the HTML contents from the child view instance in to the collectionview's <code>el</code>.</p> <p>This is typically not very useful as a composite view will usually rendera container DOM element in which the child views should be placed.</p> <p>For example, if you are building a table view, and want to append eachchild from the collection in to the <code>&lt;tbody&gt;</code> of the table, you mightdo this with a template:</p> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"row-template\"</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"text/html\"</span>&gt;</span><span class=\"javascript\">\n  &lt;td&gt;<span class=\"xml\"><span class=\"vbscript\">&lt;%= someData %&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">td</span>&gt;</span><span class=\"vbscript\">&lt;%= moreData %&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">td</span>&gt;</span><span class=\"vbscript\">&lt;%= stuff %&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"table-template\"</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"text/html\"</span>&gt;</span><span class=\"javascript\">\n  &lt;table&gt;\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">thead</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tr</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">th</span>&gt;</span>Some Column<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">th</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">th</span>&gt;</span>Another Column<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">th</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">th</span>&gt;</span>Still More<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">th</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tr</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">thead</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- want to insert collection children, here --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tbody</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tbody</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tfoot</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tr</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">td</span> <span class=\"hljs-attribute\">colspan</span>=<span class=\"hljs-value\">\"3\"</span>&gt;</span>some footer information<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tr</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tfoot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">table</span>&gt;</span>\n</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</pre> <p>To get your childView instances to render within the <code>&lt;tbody&gt;</code> of thistable structure, specify an <code>childViewContainer</code> in your composite view,like this:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> RowView = Marionette.ItemView.extend({\n  tagName: <span class=\"hljs-string\">\"tr\"</span>,\n  template: <span class=\"hljs-string\">\"#row-template\"</span>\n});\n\n<span class=\"hljs-keyword\">var</span> TableView = Marionette.CompositeView.extend({\n  childView: RowView,\n\n  <span class=\"hljs-comment\">// specify a jQuery selector to put the `childView` instances into</span>\n  childViewContainer: <span class=\"hljs-string\">\"tbody\"</span>,\n\n  template: <span class=\"hljs-string\">\"#table-template\"</span>\n});\n</pre> <p>This will put all of the <code>childView</code> instances into the <code>&lt;tbody&gt;</code> tag ofthe composite view's rendered template, correctly producing the tablestructure.</p> <p>Alternatively, you can specify a function as the <code>childViewContainer</code>. Thisfunction needs to return a jQuery selector string, or a jQuery selectorobject.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> TableView = Marionette.CompositeView.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  childViewContainer: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"#my-tbody\"</span>\n  }\n});\n</pre> <p>Using a function allows for logic to be used for the selector. However,only one value can be returned. Upon returning the first value, it willbe cached and that value will be used for the remainder of that viewinstance' lifecycle.</p> <p>Alternatively, the <code>childViewContainer</code> can be supplied in the constructorfunction options:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> myComp = <span class=\"hljs-keyword\">new</span> Marionette.CompositeView({\n  <span class=\"hljs-comment\">// ...,</span>\n\n  childViewContainer: <span class=\"hljs-string\">\"#my-tbody\"</span>\n});\n</pre> <h2 id=\"compositeviews-attachhtml\">\nCompositeView's <code>attachHtml</code>\n</h2>\n<p>Sometimes the <code>childViewContainer</code> configuration is insufficient forspecifying where the <code>childView</code> instance should be placed. If this is thecase, you can override the <code>attachHtml</code> method with your own implementation.</p> <p>For more information on this method, see the <a href=\"marionette.collectionview#collectionviews-attachhtml\">CollectionView's documentation</a>.</p> <h2 id=\"compositeviews-childview-container-selection\">\nCompositeView's <code>childView</code> container selection</h2>\n<p>The <code>getChildViewContainer</code> method is passed a second <code>childView</code> parameter which, when overridden, allows for a finer tuned container selection by being able to access the <code>childView</code> which is about to be appended to the <code>containerView</code> returned by <code>getChildViewContainer</code>.</p> <h2 id=\"recursive-by-default\">\nRecursive By Default</h2>\n<p>The default rendering mode for a <code>CompositeView</code> assumes ahierarchical, recursive structure. If you configure a compositeview without specifying an <code>childView</code>, you'll get the samecomposite view class rendered for each child in the collection.</p> <h2 id=\"model-and-collection-rendering\">\nModel And Collection Rendering</h2>\n<p>The model and collection for the composite view will re-renderthemselves under the following conditions:</p> <ul> <li>When the collection's \"reset\" event is fired, it will only re-render the collection within the composite, and not the wrapper template</li> <li>When the collection has a model added to it (the \"add\" event is fired), it will render that one child into the list</li> <li>When the collection has a model removed (the \"remove\" event is fired), it will remove that one child from the rendered list</li> </ul> <p>As with item view instances, the composite view instance is passed as thethird argument to the <code>Renderer</code> object's <code>render</code> method, which isuseful in custom <code>Renderer</code> implementations.</p> <p>As with CollectionView, CompositeView will maintain the sort order of its child views from the collection. It should be noted that the full view will re-render and not just the children, this is to cater for the use case where no <code>childViewContainer</code> is used.</p> <h2 id=\"events-and-callbacks\">\nEvents And Callbacks</h2>\n<p>During the course of rendering a composite, several events willbe triggered. These events are triggered with the <a href=\"marionette.functions#marionettetriggermethod\">Marionette.triggerMethod</a>function, which calls a corresponding \"on{EventName}\" method on the view.</p> <ul> <li>\"before:render:template\" / <code>onBeforeRenderTemplate</code> - before the <code>model</code> has been rendered</li> <li>\"render:template\" / <code>onRenderTemplate</code> - after the <code>model</code> has been rendered</li> <li>\"before:render:collection\" / <code>onBeforeRenderCollection</code> - before the collection of models is rendered</li> <li>\"render:collection\" / <code>onRenderCollection</code> - after the collection of models has been rendered</li> <li>\"before:render\" / <code>onBeforeRender</code> - before anything has been rendered</li> <li>\"render\" / <code>onRender</code> - after everything has been rendered</li> </ul> <p>Additionally, after the composite view has been rendered, an<code>onRender</code> method will be called. You can implement this inyour view to provide custom code for dealing with the view's<code>el</code> after it has been rendered:</p> <pre data-language=\"js\">Marionette.CompositeView.extend({\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// do stuff here</span>\n  }\n});\n</pre> <h2 id=\"organizing-ui-elements\">\nOrganizing UI elements</h2>\n<p>Similar to ItemView, you can organize the UI elements inside theCompositeView by specifying them in the <code>UI</code> hash. It should benoted that the elements that can be accessed via this hash arethe elements that are directly rendered by the composite viewtemplate, not those belonging to the collection.</p> <p>The UI elements will be accessible as soon as the composite viewtemplate is rendered (and before the collection is rendered),which means you can even access them in the <code>onBeforeRender</code> method.</p> <h2 id=\"modelevents-and-collectionevents\">\nmodelEvents and collectionEvents</h2>\n<p>CompositeViews can bind directly to model events and collection eventsin a declarative manner:</p> <pre data-language=\"js\">Marionette.CompositeView.extend({\n  modelEvents: {\n    <span class=\"hljs-string\">\"change\"</span>: <span class=\"hljs-string\">\"modelChanged\"</span>\n  },\n\n  collectionEvents: {\n    <span class=\"hljs-string\">\"add\"</span>: <span class=\"hljs-string\">\"modelAdded\"</span>\n  }\n});\n</pre> <p>For more information, see the <a href=\"marionette.view#viewmodelevents-and-viewcollectionevents\">Marionette.View</a>documentation.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.compositeview.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.compositeview.html</a>\n  </p>\n</div>\n","marionette.layoutview":"<h1>\nMarionette.LayoutView</h1>\n<p>A <code>LayoutView</code> is a hybrid of an <code>ItemView</code> and a collection of <code>Region</code> objects. Theyare ideal for rendering application layouts with multiple sub-regionsmanaged by specified region managers.</p> <p>A layoutView can also act as a composite-view to aggregate multipleviews and sub-application areas of the screen allowing applications toattach multiple region managers to dynamically rendered HTML.</p> <p>You can create complex views by nesting layoutView managers within <code>Regions</code>.</p> <p>For a more in-depth discussion on LayoutViews, see the blog post<a href=\"http://lostechies.com/derickbailey/2012/03/22/managing-layouts-and-nested-views-with-backbone-marionette/\">Manage Layouts And Nested Views With Marionette</a></p> <p>Please see<a href=\"marionette.itemview\">the Marionette.ItemView documentation</a>for more information on available features and functionality.</p> <p>Additionally, interactions with Marionette.Regionwill provide features such as <code>onShow</code> callbacks, etc. Please see<a href=\"marionette.region\">the Region documentation</a> for more information.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#basic-usage\">Basic Usage</a></li> <li><a href=\"#region-options\">Region Options</a></li> <li><a href=\"#layoutview-childevents\">LayoutView.childEvents</a></li> <li><a href=\"#specifying-regions-as-a-function\">Specifying Regions As A Function</a></li> <li><a href=\"#overriding-the-default-regionmanager\">Overriding the default RegionManager</a></li> <li><a href=\"#region-availability\">Region Availability</a></li> <li>\n<a href=\"#re-rendering-a-layoutview\">Re-Rendering A LayoutView</a><ul> <li><a href=\"#avoid-re-rendering-the-entire-layoutview\">Avoid Re-Rendering The Entire LayoutView</a></li> </ul> </li> <li>\n<a href=\"#nested-layoutviews-and-views\">Nested LayoutViews And Views</a><ul> <li>\n<a href=\"#efficient-nested-view-structures\">Efficient Nested View Structures</a><ul> <li><a href=\"#use-of-the-attach-event\">Use of the <code>attach</code> Event</a></li> </ul> </li> </ul> </li> <li><a href=\"#destroying-a-layoutview\">Destroying A LayoutView</a></li> <li><a href=\"#custom-region-class\">Custom Region Class</a></li> <li><a href=\"#adding-and-removing-regions\">Adding And Removing Regions</a></li> <li><a href=\"#region-naming\">Region Naming</a></li> </ul> <h2 id=\"basic-usage\">\nBasic Usage</h2>\n<p>The <code>LayoutView</code> extends directly from <code>ItemView</code> and adds the abilityto specify <code>regions</code> which become <code>Region</code> instances that are attachedto the layoutView.</p> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"layout-view-template\"</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"text/template\"</span>&gt;</span><span class=\"javascript\">\n  &lt;section&gt;\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">navigation</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"menu\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">navigation</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">article</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"content\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">article</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">section</span>&gt;</span>\n</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</pre> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> AppLayoutView = Marionette.LayoutView.extend({\n  template: <span class=\"hljs-string\">\"#layout-view-template\"</span>,\n\n  regions: {\n    menu: <span class=\"hljs-string\">\"#menu\"</span>,\n    content: <span class=\"hljs-string\">\"#content\"</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> layoutView = <span class=\"hljs-keyword\">new</span> AppLayoutView();\nlayoutView.render();\n</pre> <p>Once you've rendered the layoutView, you now have direct accessto all of the specified regions as region managers.</p> <pre data-language=\"js\">layoutView.getRegion(<span class=\"hljs-string\">'menu'</span>).show(<span class=\"hljs-keyword\">new</span> MenuView(), options);\n\nlayoutView.getRegion(<span class=\"hljs-string\">'content'</span>).show(<span class=\"hljs-keyword\">new</span> MainContentView(), options);\n</pre> <p>There are also helpful shortcuts for more concise syntax.</p> <pre data-language=\"js\">layoutView.showChildView(<span class=\"hljs-string\">'menu'</span>, <span class=\"hljs-keyword\">new</span> MenuView(), options);\n\nlayoutView.showChildView(<span class=\"hljs-string\">'content'</span>, <span class=\"hljs-keyword\">new</span> MainContentView(), options);\n</pre> <h3 id=\"region-options\">\nRegion Options</h3>\n<p>A <code>LayoutView</code> can take a <code>regions</code> hash that allows you to specify regions per <code>LayoutView</code> instance.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">new</span> Marionette.LayoutView({\n regions: {\n   <span class=\"hljs-string\">\"cat\"</span>: <span class=\"hljs-string\">\".doge\"</span>,\n   <span class=\"hljs-string\">\"wow\"</span>: {\n     selector: <span class=\"hljs-string\">\".such\"</span>,\n     regionClass: Coin\n   }\n }\n})\n</pre> <h3 id=\"layoutview-childevents\">\nLayoutView childEvents</h3>\n<p>A <code>childEvents</code> hash or method permits handling of child view events without manually setting bindings. The values of the hash can either be a function or a string method name on the collection view.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// childEvents can be specified as a hash...</span>\n<span class=\"hljs-keyword\">var</span> MyLayoutView = Marionette.LayoutView.extend({\n\n  childEvents: {\n    <span class=\"hljs-comment\">// This callback will be called whenever a child is rendered or emits a `render` event</span>\n    render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view has been rendered.'</span>);\n    }\n  }\n});\n\n<span class=\"hljs-comment\">// ...or as a function that returns a hash.</span>\n<span class=\"hljs-keyword\">var</span> MyLayoutView = Marionette.LayoutView.extend({\n\n  childEvents: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> {\n      render: <span class=\"hljs-keyword\">this</span>.onChildRendered\n    }\n  },\n\n  onChildRendered: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view has been rendered.'</span>);\n  }\n});\n</pre> <p><code>childEvents</code> also catches custom events fired by a child view. Take note that the first argument to a <code>childEvents</code> handler is the child view itself. Caution: Events triggered on the child view through <code>this.trigger</code> are not yet supported for LayoutView <code>childEvents</code>. Use strictly <code>triggerMethod</code> within the child view.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// The child view fires a custom event, `show:message`</span>\n<span class=\"hljs-keyword\">var</span> ChildView = Marionette.ItemView.extend({\n\n  <span class=\"hljs-comment\">// Events hash defines local event handlers that in turn may call `triggerMethod`.</span>\n  events: {\n    <span class=\"hljs-string\">'click .button'</span>: <span class=\"hljs-string\">'onClickButton'</span>\n  },\n\n  <span class=\"hljs-comment\">// Triggers hash converts DOM events directly to view events catchable on the parent.</span>\n  triggers: {\n    <span class=\"hljs-string\">'submit form'</span>: <span class=\"hljs-string\">'submit:form'</span>\n  },\n\n  onClickButton: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.triggerMethod(<span class=\"hljs-string\">'show:message'</span>, <span class=\"hljs-string\">'foo'</span>);\n  }\n});\n\n<span class=\"hljs-comment\">// The parent uses childEvents to catch that custom event on the child view</span>\n<span class=\"hljs-keyword\">var</span> ParentView = Marionette.LayoutView.extend({\n\n  childEvents: {\n    <span class=\"hljs-string\">'show:message'</span>: <span class=\"hljs-string\">'onChildShowMessage'</span>,\n    <span class=\"hljs-string\">'submit:form'</span>: <span class=\"hljs-string\">'onChildSubmitForm'</span>\n  },\n\n  onChildShowMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(childView, message)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view fired show:message with '</span> + message);\n  },\n  <span class=\"hljs-comment\">// Methods called from the triggers hash do not have access to DOM events</span>\n  <span class=\"hljs-comment\">// Any logic requiring the original DOM event should be handled in it's respective view</span>\n  onChildSubmitForm: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(childView)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view fired submit:form'</span>);\n  }\n});\n</pre> <h3 id=\"specifying-regions-as-a-function\">\nSpecifying Regions As A Function</h3>\n<p>Regions can be specified on a LayoutView using a function that returnsan object with the region definitions. The returned object follow thesame rules for defining a region, as outlined above.</p> <pre data-language=\"js\">Marionette.LayoutView.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  regions: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n    <span class=\"hljs-keyword\">return</span> {\n      fooRegion: <span class=\"hljs-string\">\"#foo-element\"</span>\n    };\n  },\n\n  <span class=\"hljs-comment\">// ...</span>\n});\n</pre> <p>Note that the function receives the view's <code>options</code> arguments thatwere passed in to the view's constructor. <code>this.options</code> is not yetavailable when the regions are first initialized, so the optionsmust be accessed through this parameter.</p> <h3 id=\"overriding-the-default-regionmanager\">\nOverriding the default <code>RegionManager</code>\n</h3>\n<p>If you need the <code>RegionManager</code>'s class chosen dynamically, specify <code>getRegionManager</code>:</p> <pre data-language=\"js\">Marionette.LayoutView.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  getRegionManager: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// custom logic</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyRegionManager();\n  }\n</pre> <p>This can be useful if you want to attach <code>LayoutView</code>'s regions to your own instance of<code>RegionManager</code>.</p> <h2 id=\"region-availability\">\nRegion Availability</h2>\n<p>Any defined regions within a layoutView will be available to theView or any calling code immediately after instantiating theView. This allows a View to be attached to an existingDOM element in an HTML page, without the need to call a rendermethod or anything else, to create the regions.</p> <p>However, a region will only be able to populate itself if theView has access to the elements specified within the regiondefinitions. That is, if your view has not yet rendered, yourregions may not be able to find the element that you'vespecified for them to manage. In that scenario, using theregion will result in no changes to the DOM.</p> <h2 id=\"re-rendering-a-layoutview\">\nRe-Rendering A LayoutView</h2>\n<p>A layoutView can be rendered as many times as needed, but rendersafter the first one behave differently than the initial render.</p> <p>The first time a layoutView is rendered, nothing special happens. It justdelegates to the <code>ItemView</code> prototype to do the render. After thefirst render has happened, though, the render function is modified toaccount for re-rendering with regions in the layoutView.</p> <p>After the first render, all subsequent renders will force everyregion to be emptied by calling the <code>empty</code> method on them. This willforce every view in the region, and sub-views if any, to be destroyedas well. Once the regions are emptied, the regions will also bereset so that they are no longer referencing the element of the previouslayoutView render.</p> <p>Then after the layoutView is finished re-rendering itself,showing a view in the layoutView's regions will cause the regions to attachthemselves to the new elements in the layoutView.</p> <h3 id=\"avoid-re-rendering-the-entire-layoutview\">\nAvoid Re-Rendering The Entire LayoutView</h3>\n<p>There are times when re-rendering the entire layoutView is necessary. However,due to the behavior described above, this can cause a large amount ofwork to be needed in order to fully restore the layoutView and all of theviews that the layoutView is displaying.</p> <p>Therefore, it is suggested that you avoid re-rendering the entirelayoutView unless absolutely necessary. Instead, if you are binding thelayoutView's template to a model and need to update portions of the layoutView,you should listen to the model's \"change\" events and only update thenecessary DOM elements.</p> <h2 id=\"nested-layoutviews-and-views\">\nNested LayoutViews And Views</h2>\n<p>Since the <code>LayoutView</code> extends directly from <code>ItemView</code>, ithas all of the core functionality of an item view. This includesthe methods necessary to be shown within an existing region manager.</p> <p>In the following example, we will use the Application's Regionsas the base of a deeply nested view structure.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// Create an Application</span>\n<span class=\"hljs-keyword\">var</span> MyApp = <span class=\"hljs-keyword\">new</span> Marionette.Application();\n\n<span class=\"hljs-comment\">// Add a region</span>\nMyApp.addRegions({\n  main: <span class=\"hljs-string\">\"main\"</span>\n});\n\n<span class=\"hljs-comment\">// Create a new LayoutView</span>\n<span class=\"hljs-keyword\">var</span> layoutView = <span class=\"hljs-keyword\">new</span> Marionette.LayoutView({\n  <span class=\"hljs-comment\">// This option removes the layoutView from</span>\n  <span class=\"hljs-comment\">// the DOM before destroying the children</span>\n  <span class=\"hljs-comment\">// preventing repaints as each option is removed.</span>\n  <span class=\"hljs-comment\">// However, it makes it difficult to do close animations</span>\n  <span class=\"hljs-comment\">// for a child view (false by default)</span>\n  destroyImmediate: <span class=\"hljs-literal\">true</span>\n});\n\n<span class=\"hljs-comment\">// Lastly, show the LayoutView in the App's mainRegion</span>\nMyApp.rootView.getRegion(<span class=\"hljs-string\">'main'</span>).show(layoutView, options);\n</pre> <p>You can nest LayoutViews as deeply as you want. This provides for a well organized,nested view structure.</p> <p>For example, to nest 3 layouts:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> layout1 = <span class=\"hljs-keyword\">new</span> Layout1();\n<span class=\"hljs-keyword\">var</span> layout2 = <span class=\"hljs-keyword\">new</span> Layout2();\n<span class=\"hljs-keyword\">var</span> layout3 = <span class=\"hljs-keyword\">new</span> Layout3();\n\nMyApp.rootView.getRegion(<span class=\"hljs-string\">'main'</span>).show(layout1, options);\n\nlayout1.showChildView(<span class=\"hljs-string\">'region1'</span>, layout2);\nlayout2.showChildView(<span class=\"hljs-string\">'region2'</span>, layout3);\n</pre> <h3 id=\"efficient-nested-view-structures\">\nEfficient Nested View Structures</h3>\n<p>The above example works great, but it causes three separate paints: one for each layout that's beingshown. Marionette provides a simple mechanism to infinitely nest views in a single paint: just render allof the children in the <code>onBeforeShow</code> callback.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> ParentLayout = Marionette.LayoutView.extend({\n  onBeforeShow: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'header'</span>, <span class=\"hljs-keyword\">new</span> HeaderView());\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'footer'</span>, <span class=\"hljs-keyword\">new</span> FooterView());\n  }\n});\n\nmyRegion.show(<span class=\"hljs-keyword\">new</span> ParentLayout(), options);\n</pre> <p>In this example, the doubly-nested view structure will be rendered in a single paint.</p> <p>This system is recursive, so it works for any deeply nested structure. The child viewsyou show can render their <em>own</em> child views within their <code>onBeforeShow</code> callbacks!</p> <h4>\nUse of the <code>attach</code> event</h4>\n<p>Often times you need to know when your views in the view tree have been attached to the <code>document</code>,like when using certain jQuery plugins. The <code>attach</code> event, and associated <code>onAttach</code> callback, are perfect for thisuse case. Start with a Region that's a child of the <code>document</code> and show any LayoutView in it: every view in the tree(including the parent LayoutView) will have the <code>attach</code> event triggered on it when they have beenattached to the <code>document</code>.</p> <p>Note that inefficient tree rendering will cause the <code>attach</code> event to be fired multiple times. Thissituation can occur if you render the children views <em>after</em> the parent has been rendered, such as using<code>onShow</code> to render children. As a rule of thumb, most of the time you'll want to render any nested views inthe <code>onBeforeShow</code> callback.</p> <h2 id=\"destroying-a-layoutview\">\nDestroying A LayoutView</h2>\n<p>When you are finished with a layoutView, you can call the<code>destroy</code> method on it. This will ensure that all of the region managerswithin the layoutView are destroyed correctly, which in turnensures all of the views shown within the regions are destroyed correctly.</p> <p>If you are showing a layoutView within a parent region manager, replacingthe layoutView with another view or another layoutView will destroy the currentone, the same it will destroy a view.</p> <p>All of this ensures that layoutViews and the views that theycontain are cleaned up correctly.</p> <p>When calling <code>destroy</code> on a layoutView, the layoutView will be returned. This can be useful forchaining.</p> <h2 id=\"custom-region-class\">\nCustom Region Class</h2>\n<p>If you have the need to replace the <code>Region</code> with a region class ofyour own implementation, you can specify an alternate class to usewith the <code>regionClass</code> property of the <code>LayoutView</code>.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyLayoutView = Marionette.LayoutView.extend({\n  regionClass: SomeCustomRegion\n});\n</pre> <p>You can also specify custom <code>Region</code> classes for each <code>region</code>:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> AppLayoutView = Marionette.LayoutView.extend({\n  template: <span class=\"hljs-string\">\"#layout-view-template\"</span>,\n\n  regionClass: SomeDefaultCustomRegion,\n\n  regions: {\n    menu: {\n      selector: <span class=\"hljs-string\">\"#menu\"</span>,\n      regionClass: CustomRegionClassReference\n    },\n    content: {\n      selector: <span class=\"hljs-string\">\"#content\"</span>,\n      regionClass: CustomRegionClass2Reference\n    }\n  }\n});\n</pre> <h2 id=\"adding-and-removing-regions\">\nAdding And Removing Regions</h2>\n<p>Regions can be added and removed as needed, in aLayoutView instance. Use the following methods:</p> <ul> <li><code>addRegion</code></li> <li><code>addRegions</code></li> <li><code>removeRegion</code></li> </ul> <p>addRegion:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> layoutView = <span class=\"hljs-keyword\">new</span> MyLayoutView();\n\n<span class=\"hljs-comment\">// ...</span>\n\nlayoutView.addRegion(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"#foo\"</span>);\nlayoutView.getRegion(<span class=\"hljs-string\">'foo'</span>).show(<span class=\"hljs-keyword\">new</span> someView(), options);\n</pre> <p>addRegions:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> layoutView = <span class=\"hljs-keyword\">new</span> MyLayoutView();\n\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-comment\">// Object literal</span>\nlayoutView.addRegions({\n  foo: <span class=\"hljs-string\">\"#foo\"</span>,\n  bar: <span class=\"hljs-string\">\"#bar\"</span>\n});\n\n<span class=\"hljs-comment\">// Or, function that returns an object literal</span>\nlayoutView.addRegions(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    baz: <span class=\"hljs-string\">\"#baz\"</span>,\n    quux: <span class=\"hljs-string\">\"#quux\"</span>\n  };\n});\n</pre> <p>removeRegions:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> layoutView = <span class=\"hljs-keyword\">new</span> MyLayoutView();\n\n<span class=\"hljs-comment\">// ...</span>\n\nlayoutView.removeRegion(<span class=\"hljs-string\">\"foo\"</span>);\n</pre> <p>Any region can be removed, whether it was definedin the <code>regions</code> attribute of the region definition,or added later.</p> <p>For more information on using these methods, seethe <code>regionManager</code> documentation.</p> <h2 id=\"region-naming\">\nRegion Naming</h2>\n<p>A LayoutViews' Regions are attached directly to the LayoutView instance with the name of the regionas the key and the region itself as the value. Because of this, you need to be carefulto avoid conflicts with existing properties on the LayoutView when you name your Region.</p> <p>The prototype chain of LayoutViews is:</p> <p><code>Backbone.View &gt; Marionette.View &gt; Marionette.ItemView &gt; Marionette.LayoutView</code></p> <p>Consequently, every property on each of those Classes must be avoided as Region names. The mostcommon issue people run into is trying to name their Region <em>\"attributes\"</em>. Be awarethat you are <strong>not</strong> able to do this.</p> <p>The following is an abbreviated list of other names that can't be used as Region names. For a morecomplete list refer to the API documentation for each Class on the prototype chain:</p> <ul> <li>attributes</li> <li>constructor</li> <li>regionClass</li> <li>render</li> <li>destroy</li> <li>addRegion</li> <li>addRegions</li> <li>removeRegion</li> </ul> <p><em>Note: this is a known issue that is flagged for being fixed in v2</em></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.layoutview.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.layoutview.html</a>\n  </p>\n</div>\n","marionette.regionmanager":"<h1>\nMarionette.RegionManager</h1>\n<p>Region managers provide a consistent way to managea number of Marionette.Region objects within anapplication. The RegionManager is intended to beused by other objects, to facilitate the addition,storage, retrieval, and removal of regions fromthat object. For examples of how it can be used,see the <a href=\"marionette.application\">Marionette.Application</a> and <a href=\"marionette.layoutview\">Marionette.LayoutView</a>objects.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#basic-use\">Basic Use</a></li> <li><a href=\"#constructing\">Constucting</a></li> <li><a href=\"#regionmanageraddregion\">RegionManager.addRegion</a></li> <li>\n<a href=\"#regionmanageraddregions\">RegionManager.addRegions</a><ul> <li><a href=\"#addregions-default-options\">addRegions default options</a></li> </ul> </li> <li><a href=\"#regionmanagerget\">RegionManager.get</a></li> <li><a href=\"#regionmanagergetregions\">RegionManager.getRegions</a></li> <li><a href=\"#regionmanagerremoveregion\">RegionManager.removeRegion</a></li> <li><a href=\"#regionmanagerremoveregions\">RegionManager.removeRegions</a></li> <li><a href=\"#regionmanageremptyregions\">RegionManager.emptyRegions</a></li> <li><a href=\"#regionmanagerdestroy\">RegionManager.destroy</a></li> <li>\n<a href=\"#regionmanager-events\">RegionManager Events</a><ul> <li><a href=\"#beforeaddregion-event\">before:add:region event</a></li> <li><a href=\"#addregion-event\">add:region event</a></li> <li><a href=\"#beforeremoveregion-event\">before:remove:region event</a></li> <li><a href=\"#removeregion-event\">remove:region event</a></li> </ul> </li> <li><a href=\"#regionmanager-iterators\">RegionManager Iterators</a></li> </ul> <h2 id=\"basic-use\">\nBasic Use</h2>\n<p>RegionManagers can be instantiated directly, and canhave regions added and removed via several methods:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\n\n<span class=\"hljs-keyword\">var</span> region = rm.addRegion(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"#bar\"</span>);\n\n<span class=\"hljs-keyword\">var</span> regions = rm.addRegions({\n  baz: <span class=\"hljs-string\">\"#baz\"</span>,\n  quux: <span class=\"hljs-string\">\"ul.quux\"</span>\n});\n\nregions.get(<span class=\"hljs-string\">'baz'</span>).show(myView, options);\n\nrm.removeRegion(<span class=\"hljs-string\">\"foo\"</span>);\n</pre> <h2 id=\"constructing\">\nConstructing</h2>\n<p>The RegionManager take an optional <code>region</code> option in their constructor. the regions are passed directly into <code>addRegions</code> for the region manager instance.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> manager = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager({\n  regions: {\n    <span class=\"hljs-string\">\"aRegion\"</span>: <span class=\"hljs-string\">\"#bar\"</span>\n  }\n});\n\nmanager.get(<span class=\"hljs-string\">'aRegion'</span>).show(<span class=\"hljs-keyword\">new</span> MyView, options);\n</pre> <h2 id=\"regionmanageraddregion\">\nRegionManager.addRegion</h2>\n<p>Regions can be added individually using the <code>addRegion</code>method. This method takes two parameters: the region nameand the region definition.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\n\n<span class=\"hljs-keyword\">var</span> region = rm.addRegion(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"#bar\"</span>);\n</pre> <p>In this example, a region named \"foo\" will be addedto the RegionManager instance. It is defined as ajQuery selector that will search for the <code>#bar</code>element in the DOM.</p> <p>There are a lot of other ways to define a region,including object literals with various options, andinstances of Region objects. For more informationon this, see the Region documentation.</p> <h2 id=\"regionmanageraddregions\">\nRegionManager.addRegions</h2>\n<p>Regions can also be added en-masse through the useof the <code>addRegions</code> method. This method takes an objectliteral or a function that returns an object literal.The object literal must contain region names as keysand region definitions as values. The return valueis an object literal with all the created regions.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\n\n<span class=\"hljs-comment\">// With an object literal</span>\n<span class=\"hljs-keyword\">var</span> regions = rm.addRegions({\n  main: <span class=\"hljs-string\">'#main-content'</span>,\n  navigation: {\n    selector: <span class=\"hljs-string\">'#navigation'</span>,\n    regionClass: MyNavRegion\n  }\n});\n\n<span class=\"hljs-comment\">// With a function</span>\n<span class=\"hljs-keyword\">var</span> otherRegions = rm.addRegions(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(regionDefinition)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    footer: <span class=\"hljs-string\">'#footer'</span>\n  };\n});\n\nregions.get(<span class=\"hljs-string\">'main'</span>);        <span class=\"hljs-comment\">//=&gt; 'main' region instance</span>\nregions.get(<span class=\"hljs-string\">'navigation'</span>);  <span class=\"hljs-comment\">//=&gt; 'navigation' region instance</span>\notherRegions.get(<span class=\"hljs-string\">'footer'</span>); <span class=\"hljs-comment\">//=&gt; 'footer' region instance</span>\n</pre> <p>If you supply a function to <code>addRegions</code>, it will becalled with the <code>RegionManager</code> instance context andall the arguments passed to <code>addRegions</code>.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\n\n<span class=\"hljs-keyword\">var</span> regionDefaults = {\n  regionClass: MyRegionClass\n};\n\nrm.addRegions(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(regionDefinition, defaults)</span> </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>);             <span class=\"hljs-comment\">// `rm` instance of `RegionManager`</span>\n  <span class=\"hljs-built_in\">console</span>.log(regionDefinition); <span class=\"hljs-comment\">// the region definition function</span>\n  <span class=\"hljs-built_in\">console</span>.log(defaults);         <span class=\"hljs-comment\">// `{ regionClass: MyRegionClass }`</span>\n\n  <span class=\"hljs-comment\">// ...return the region definiton object literal</span>\n}, regionDefaults);\n</pre> <h3 id=\"addregions-default-options\">\naddRegions default options</h3>\n<p>When adding multiple regions it may be useful toprovide a set of defaults that get applied to allof the regions being added. This can be done throughthe use of a <code>defaults</code> parameter. Specify thisparameter as an object literal with <code>key: value</code>pairs that will be applied to every region added.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\n\n<span class=\"hljs-keyword\">var</span> defaults = {\n  regionClass: MyRegionClass\n};\n\n<span class=\"hljs-keyword\">var</span> regions = {\n  foo: <span class=\"hljs-string\">\"#bar\"</span>,\n  baz: <span class=\"hljs-string\">\"#quux\"</span>\n};\n\nrm.addRegions(regions, defaults);\n</pre> <p>In this example, all regions will be added asinstances of <code>MyRegionClass</code>.</p> <h2 id=\"regionmanagerget\">\nRegionManager.get</h2>\n<p>A region instance can be retrieved from theRegionManager instance using the <code>get</code> method andpassing in the name of the region.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\nrm.addRegion(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"#bar\"</span>);\n\n<span class=\"hljs-keyword\">var</span> region = rm.get(<span class=\"hljs-string\">\"foo\"</span>);\n</pre> <h2 id=\"regionmanagergetregions\">\nRegionManager.getRegions</h2>\n<p>Get all the regions from the region manager.Returns an object literal with named regionsas attributes.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\nrm.addRegion(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"#foo\"</span>);\nrm.addRegion(<span class=\"hljs-string\">\"bar\"</span>, <span class=\"hljs-string\">\"#bar\"</span>);\n\n<span class=\"hljs-keyword\">var</span> regions = rm.getRegions();\n\nregions.foo; <span class=\"hljs-comment\">//=&gt; foo region</span>\nregions.bar; <span class=\"hljs-comment\">//=&gt; bar region</span>\n</pre> <h2 id=\"regionmanagerremoveregion\">\nRegionManager.removeRegion</h2>\n<p>A region can be removed by calling the <code>removeRegion</code>method and passing in the name of the region.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\nrm.addRegion(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"#bar\"</span>);\n\nrm.removeRegion(<span class=\"hljs-string\">\"foo\"</span>);\n</pre> <p>A region will have its <code>empty</code> method called beforeit is removed from the RegionManager instance and<code>stopListening</code> is called.</p> <h2 id=\"regionmanagerremoveregions\">\nRegionManager.removeRegions</h2>\n<p>You can quickly remove all regions from theRegionManager instance by calling the <code>removeRegions</code>method.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\nrm.addRegions({\n  foo: <span class=\"hljs-string\">\"#foo\"</span>,\n  bar: <span class=\"hljs-string\">\"#bar\"</span>,\n  baz: <span class=\"hljs-string\">\"#baz\"</span>\n});\n\nrm.removeRegions();\n</pre> <p>This will empty all regions, and remove them.</p> <h2 id=\"regionmanageremptyregions\">\nRegionManager.emptyRegions</h2>\n<p>You can quickly empty all regions from the RegionManagerinstance by calling the <code>emptyRegions</code> method.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\nrm.addRegions({\n  foo: <span class=\"hljs-string\">\"#foo\"</span>,\n  bar: <span class=\"hljs-string\">\"#bar\"</span>,\n  baz: <span class=\"hljs-string\">\"#baz\"</span>\n});\n\nrm.emptyRegions();\n</pre> <p>This will empty the regions without removing themfrom the RegionManager instance.</p> <h2 id=\"regionmanagerdestroy\">\nRegionManager.destroy</h2>\n<p>A RegionManager instance can be destroyed entirely bycalling the <code>destroy</code> method. This will both destroyand remove all regions from the RegionManager instance.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\nrm.addRegions({\n  foo: <span class=\"hljs-string\">\"#foo\"</span>,\n  bar: <span class=\"hljs-string\">\"#bar\"</span>,\n  baz: <span class=\"hljs-string\">\"#baz\"</span>\n});\n\nrm.destroy();\n</pre> <h2 id=\"regionmanager-events\">\nRegionManager Events</h2>\n<p>A RegionManager will trigger various events as itis being used.</p> <h3 id=\"beforeaddregion-event\">\nbefore:add:region event</h3>\n<p>The <code>RegionManager</code> will trigger a \"before:add:region\"event before a region is added to the manager. Thisallows you to perform some actions on the region before it is added.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\n\nrm.on(<span class=\"hljs-string\">\"before:add:region\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name, region)</span></span>{\n  <span class=\"hljs-comment\">// do something with the region instance</span>\n});\n\nrm.addRegion(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"#bar\"</span>);\n</pre> <h3 id=\"addregion-event\">\nadd:region event</h3>\n<p>The RegionManager will trigger a \"add:region\"event when a region is added to the manager. Thisallows you to use the region instance immediately,or attach the region to an object that needs areference to it:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\n\nrm.on(<span class=\"hljs-string\">\"add:region\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name, region)</span></span>{\n  <span class=\"hljs-comment\">// add the region instance to an object</span>\n  myObject[name] = region;\n});\n\nrm.addRegion(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"#bar\"</span>);\n</pre> <h3 id=\"beforeremoveregion-event\">\nbefore:remove:region event</h3>\n<p>The <code>RegionManager</code> will trigger a \"before:remove:region\"event before a region is removed from the manager.This allows you to perform any cleanup operations before the region is removed.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\n\nrm.on(<span class=\"hljs-string\">\"before:remove:region\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name, region)</span></span>{\n  <span class=\"hljs-comment\">// do something with the region instance here</span>\n});\n\nrm.addRegion(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"#bar\"</span>);\n\nrm.removeRegion(<span class=\"hljs-string\">\"foo\"</span>);\n</pre> <h3 id=\"removeregion-event\">\nremove:region event</h3>\n<p>The RegionManager will trigger a \"remove:region\"event when a region is removed from the manager.This allows you to use the region instance one lasttime, or remove the region from an object that has areference to it:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\n\nrm.on(<span class=\"hljs-string\">\"remove:region\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name, region)</span></span>{\n  <span class=\"hljs-comment\">// add the region instance to an object</span>\n  <span class=\"hljs-keyword\">delete</span> myObject[name];\n});\n\nrm.addRegion(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"#bar\"</span>);\n\nrm.removeRegion(<span class=\"hljs-string\">\"foo\"</span>);\n</pre> <h2 id=\"regionmanager-iterators\">\nRegionManager Iterators</h2>\n<p>The RegionManager has several methods for iterationattached to it, from underscore.js. This works in thesame way as the Backbone.Collection methods that havebeen imported. For example, you can easily iterate overthe entire collection of region instances by callingthe <code>each</code> method:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> rm = <span class=\"hljs-keyword\">new</span> Marionette.RegionManager();\n\nrm.each(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(region)</span></span>{\n  <span class=\"hljs-comment\">// do stuff w/ the region instance here</span>\n});\n</pre> <p>The list of underscore methods include:</p> <ul> <li><a href=\"http://underscorejs.org/#each\">forEach</a></li> <li><a href=\"http://underscorejs.org/#each\">each</a></li> <li><a href=\"http://underscorejs.org/#map\">map</a></li> <li><a href=\"http://underscorejs.org/#find\">find</a></li> <li><a href=\"http://underscorejs.org/#find\">detect</a></li> <li><a href=\"http://underscorejs.org/#filter\">filter</a></li> <li><a href=\"http://underscorejs.org/#filter\">select</a></li> <li><a href=\"http://underscorejs.org/#reject\">reject</a></li> <li><a href=\"http://underscorejs.org/#every\">every</a></li> <li><a href=\"http://underscorejs.org/#every\">all</a></li> <li><a href=\"http://underscorejs.org/#some\">some</a></li> <li><a href=\"http://underscorejs.org/#some\">any</a></li> <li><a href=\"http://underscorejs.org/#contains\">include</a></li> <li><a href=\"http://underscorejs.org/#contains\">contains</a></li> <li><a href=\"http://underscorejs.org/#invoke\">invoke</a></li> <li><a href=\"http://underscorejs.org/#toArray\">toArray</a></li> <li><a href=\"http://underscorejs.org/#first\">first</a></li> <li><a href=\"http://underscorejs.org/#initial\">initial</a></li> <li><a href=\"http://underscorejs.org/#rest\">rest</a></li> <li><a href=\"http://underscorejs.org/#last\">last</a></li> <li><a href=\"http://underscorejs.org/#without\">without</a></li> <li><a href=\"http://underscorejs.org/#isEmpty\">isEmpty</a></li> <li><a href=\"http://underscorejs.org/#pluck\">pluck</a></li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.regionmanager.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.regionmanager.html</a>\n  </p>\n</div>\n","marionette.behavior":"<h1>\nMarionette.Behavior</h1>\n<p>A <code>Behavior</code> is an isolated set of DOM / user interactions that can be mixed into any <code>View</code> or another <code>Behavior</code>. Behaviors allow you to blackbox <code>View</code>-specific interactions into portable logical chunks, keeping your Views simple and your code DRY.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#the-motivation\">Motivation</a></li> <li><a href=\"#using\">Using Behaviors</a></li> <li>\n<a href=\"#api\">API</a><ul> <li><a href=\"#the-event-proxy\">Event proxy</a></li> <li><a href=\"#triggers\">Triggers</a></li> <li><a href=\"#model-events\">Model Events</a></li> <li><a href=\"#model-events\">Collection Events</a></li> <li><a href=\"#grouped-behaviors\">Grouped Behaviors</a></li> <li><a href=\"#%24\">$</a></li> <li><a href=\"#%24el-and-el\">$el and el</a></li> <li><a href=\"#defaults\">Defaults</a></li> <li><a href=\"#view\">View</a></li> </ul> </li> </ul> <h2 id=\"the-motivation\">\nThe Motivation</h2>\n<p>As you build more and more complex Views, you will find that your <code>View</code> becomes less about displaying model data, and more about interactions.</p> <p>These interactions tend to be chunks of logic that you want to use in multiple views.</p> <h2 id=\"usage\">\nUsage</h2>\n<p>Here is an example of a simple <code>ItemView</code>. Let's take a stab at simplifying it, and abstracting Behaviors from it.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  ui: {\n    <span class=\"hljs-string\">\"destroy\"</span>: <span class=\"hljs-string\">\".destroy-btn\"</span>\n  },\n\n  events: {\n    <span class=\"hljs-string\">\"click @ui.destroy\"</span>: <span class=\"hljs-string\">\"warnBeforeDestroy\"</span>\n  },\n\n  warnBeforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    alert(<span class=\"hljs-string\">\"You are about to destroy all your data!\"</span>);\n    <span class=\"hljs-keyword\">this</span>.destroy();\n  },\n\n  onShow: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.ui.destroy.tooltip({\n      text: <span class=\"hljs-string\">\"What a nice mouse you have.\"</span>\n    });\n  }\n});\n</pre> <p>Interaction points, such as tooltips and warning messages, are generic concepts. There is no need to recode them within your Views. They are prime candidates for abstraction into a higher level, non-coupled concept, which is exactly what Behaviors provide you with.</p> <p>Here is the syntax for declaring which behaviors get used within a View:</p> <ul> <li>The keys in the hash are passed to <code>getBehaviorClass</code>, which looks up the correct <code>Behavior</code> class.</li> <li>The options for each <code>Behavior</code> are also passed through to the <code>Behavior</code> during initialization.</li> <li>The options are then stored within each <code>Behavior</code> under <code>options</code>.</li> </ul> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  ui: {\n    <span class=\"hljs-string\">\"destroy\"</span>: <span class=\"hljs-string\">\".destroy-btn\"</span>\n  },\n\n  behaviors: {\n    DestroyWarn: {\n      message: <span class=\"hljs-string\">\"you are destroying all your data is now gone!\"</span>\n    },\n    ToolTip: {\n      text: <span class=\"hljs-string\">\"what a nice mouse you have\"</span>\n    }\n  }\n});\n</pre> <p>Now let's create the <code>DestroyWarn</code> <code>Behavior</code>.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> DestroyWarn = Marionette.Behavior.extend({\n  <span class=\"hljs-comment\">// You can set default options</span>\n  <span class=\"hljs-comment\">// just like you can in your Backbone Models.</span>\n  <span class=\"hljs-comment\">// They will be overridden if you pass in an option with the same key.</span>\n  defaults: {\n    <span class=\"hljs-string\">\"message\"</span>: <span class=\"hljs-string\">\"You are destroying!\"</span>\n  },\n\n  <span class=\"hljs-comment\">// Behaviors have events that are bound to the views DOM.</span>\n  events: {\n    <span class=\"hljs-string\">\"click @ui.destroy\"</span>: <span class=\"hljs-string\">\"warnBeforeDestroy\"</span>\n  },\n\n  warnBeforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    alert(<span class=\"hljs-keyword\">this</span>.options.message);\n    <span class=\"hljs-comment\">// Every Behavior has a hook into the</span>\n    <span class=\"hljs-comment\">// view that it is attached to.</span>\n    <span class=\"hljs-keyword\">this</span>.view.destroy();\n  }\n});\n</pre> <p>And onto the <code>Tooltip</code> behavior.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> ToolTip = Marionette.Behavior.extend({\n  ui: {\n    tooltip: <span class=\"hljs-string\">'.tooltip'</span>\n  },\n\n  onShow: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.ui.tooltip.tooltip({\n      text: <span class=\"hljs-keyword\">this</span>.options.text\n    });\n  }\n});\n</pre> <p>Finally, the user must define a location where their Behaviors are stored. Here is a simple example:</p> <pre data-language=\"js\">  Marionette.Behaviors.behaviorsLookup = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">window</span>.Behaviors;\n  }\n</pre> <p>In this example, you would then store your Behaviors like this:</p> <pre data-language=\"js\"><span class=\"hljs-built_in\">window</span>.Behaviors.ToolTip = ToolTip;\n<span class=\"hljs-built_in\">window</span>.Behaviors.DestroyWarn = DestroyWarn;\n</pre> <p>Note that in addition to extending a <code>View</code> with <code>Behavior</code>, a <code>Behavior</code> can itself use other Behaviors. The syntax is identical to that used for a <code>View</code>:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> Modal = Marionette.Behavior.extend({\n  behaviors: {\n    DestroyWarn: {\n      message: <span class=\"hljs-string\">\"Whoa! You sure about this?\"</span>\n    }\n  }\n});\n</pre> <p>Nested Behaviors act as if they were direct Behaviors of the parent <code>Behavior</code>'s view instance.</p> <h2 id=\"api\">\nAPI</h2>\n<h3 id=\"the-event-proxy\">\nThe Event Proxy</h3>\n<p>Behaviors are powered by an event proxy. This means that any events that are triggered by the view's <code>triggerMethod</code> function are passed to each <code>Behavior</code> on the <code>View</code> as well.</p> <p>As a real world example, whenever you would define a click event in your <code>View</code>'s <code>events</code> hash, you can define the same event listeners and callbacks in the <code>Behavior</code>'s <code>events</code> hash. The same follows for <code>modelEvents</code> and <code>collectionEvents</code>. Think of your <code>Behavior</code> as a receiver for all of the events on your <code>View</code> instance.</p> <p>This concept also allows for a nice decoupled method to communicate to Behaviors from your <code>View</code> instance. You can just call the following from within your <code>View</code>: <code>this.triggerMethod(\"SomeEvent\", {some: \"data\"})</code>. Then your <code>Behavior</code> class would look like this:</p> <pre data-language=\"js\">Marionette.Behavior.extend({\n  onSomeEvent: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(data)</span> </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"wow such data\"</span>, data);\n    }\n});\n</pre> <h3 id=\"model-events\">\nModel Events</h3>\n<p><code>modelEvents</code> will respond to the <code>View</code>'s model events.</p> <pre data-language=\"js\">  Marionette.Behavior.extend({\n    modelEvents: {\n      <span class=\"hljs-string\">\"change:doge\"</span>: <span class=\"hljs-string\">\"onDogeChange\"</span>\n    },\n\n    onDogeChange: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n      <span class=\"hljs-comment\">// buy more doge...</span>\n    }\n  });\n</pre> <h3 id=\"collection-events\">\nCollection Events</h3>\n<p><code>collectionEvents</code> will respond to the <code>View</code>'s collection events.</p> <pre data-language=\"js\">  Marionette.Behavior.extend({\n    collectionEvents: {\n      add: <span class=\"hljs-string\">\"onCollectionAdd\"</span>\n    },\n\n    onCollectionAdd: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    }\n  });\n</pre> <h3 id=\"life-cycle-methods\">\nLife Cycle Methods</h3>\n<p>In addition to providing the same event hashes as Views, Behaviors allow you to use the same life cycle functions that you find on Views. That means methods like <code>initialize</code>, <code>onRender</code>, <code>onBeforeShow</code>, and <code>onBeforeDestroy</code> are all valid as long as the <code>View</code> that implements the <code>Behavior</code> fires the relevant events.</p> <pre data-language=\"js\">  Marionette.Behavior.extend({\n\n    onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">//Apply a jQuery plugin to every .foo item within the view</span>\n        <span class=\"hljs-keyword\">this</span>.$(<span class=\"hljs-string\">'.foo'</span>).bar();\n    }\n  });\n</pre> <h3 id=\"triggers\">\nTriggers</h3>\n<p>Any <code>triggers</code> you define on the <code>Behavior</code> will be triggered in response to the appropriate event on the <code>View</code>.</p> <pre data-language=\"js\">Marionette.Behavior.extend({\n  triggers: {\n    <span class=\"hljs-string\">'click .label'</span>: <span class=\"hljs-string\">'click:label'</span>\n  }\n});\n</pre> <h3 id=\"grouped-behaviors\">\nGrouped Behaviors</h3>\n<p>The <code>behaviors</code> key allows a <code>Behavior</code> to group multiple behaviors together.</p> <pre data-language=\"js\">  Marionette.Behavior.extend({\n    behaviors: {\n      SomeBehavior: {}\n    }\n  });\n</pre> <h3 id=\"$\">\n$</h3>\n<p><code>$</code> is a direct proxy of the <code>View</code>'s <code>$</code> lookup method.</p> <pre data-language=\"js\">    Marionette.Behavior.extend({\n        onShow: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n            <span class=\"hljs-keyword\">this</span>.$(<span class=\"hljs-string\">'.zerg'</span>)\n        }\n    });\n</pre> <h3 id=\"$el-and-el\">\n$el and el</h3>\n<p><code>el</code> is a direct proxy of the <code>View</code>'s <code>el</code>. Similarly, <code>$el</code> is a direct proxy of the <code>View</code>'s <code>el</code> cached as a jQuery selector.</p> <pre data-language=\"js\">Marionette.Behavior.extend({\n    onShow: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.$el.fadeOut(<span class=\"hljs-string\">'slow'</span>)\n    }\n});\n</pre> <h3 id=\"defaults\">\ndefaults</h3>\n<p><code>defaults</code> can be a <code>hash</code> or <code>function</code> to define the default options for your <code>Behavior</code>. The default options will be overridden depending on what you set as the options per <code>Behavior</code>. (This works just like a <code>Backbone.Model</code>.)</p> <pre data-language=\"js\">Marionette.Behavior.extend({\n    defaults: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-string\">'deepSpace'</span>: <span class=\"hljs-number\">9</span>\n        }\n    }\n});\n</pre> <pre data-language=\"js\">Marionette.Behavior.extend({\n    defaults: {\n        <span class=\"hljs-string\">'dominion'</span>: <span class=\"hljs-string\">'invasion'</span>,\n        <span class=\"hljs-string\">'doge'</span>: <span class=\"hljs-string\">'amaze'</span>\n    }\n});\n</pre> <h3 id=\"view\">\nview</h3>\n<p>The <code>view</code> is a reference to the <code>View</code> instance that the <code>Behavior</code> is attached to.</p> <pre data-language=\"js\">Marionette.Behavior.extend({\n    handleDestroyClick: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.view.destroy();\n    }\n});\n</pre> <h3 id=\"ui\">\nui</h3>\n<p>Behaviors can have their own <code>ui</code> hash, which will be mixed into the <code>ui</code> hash of its associated <code>View</code> instance.<code>ui</code> elements defined on either the <code>Behavior</code> or the <code>View</code> will be made available within events and triggers. Theyalso are attached directly to the <code>Behavior</code> and can be accessed within <code>Behavior</code> methods as <code>this.ui</code>.</p> <pre data-language=\"js\">Marionette.Behavior.extend({\n    ui: {\n        <span class=\"hljs-string\">'foo'</span> : <span class=\"hljs-string\">'li.foo'</span>\n    },\n\n    doStuff: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.ui.foo.trigger(<span class=\"hljs-string\">'something'</span>);\n    }\n})\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.behavior.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.behavior.html</a>\n  </p>\n</div>\n","marionette.module":"<h1>\nMarionette.Module</h1>\n<blockquote> <p>Warning: deprecated</p> <p>Marionette.Module is deprecated, and is scheduled to be removed in the next major release of the library. Insteadof Marionette.Module, you should use AMD/CommonJS/ES6 for modularity. A <a href=\"https://github.com/marionettejs/marionette.module\">Marionette.Module shim</a> is available if necessary after its removal.</p> </blockquote> <p>Marionette Modules allow you to create modular encapsulated logic.They can be used to split apart large applications into multiple files,and to build individual components of your app.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#basic-usage\">Basic Usage</a></li> <li>\n<a href=\"#module-definitions\">Module Definitions</a><ul> <li><a href=\"#callback-function-definition\">Callback Function Definition</a></li> <li><a href=\"#object-literal-definition\">Object Literal Definition</a></li> </ul> </li> <li><a href=\"#module-classes\">Module Classes</a></li> <li><a href=\"#defining-sub-modules\">Defining Sub-Modules</a></li> <li><a href=\"#starting-and-stopping-modules\">Starting and Stopping Modules</a></li> <li>\n<a href=\"#starting-modules\">Starting Modules</a><ul> <li><a href=\"#start-events\">Start Events</a></li> <li><a href=\"#preventing-auto-start-of-modules\">Preventing Auto-Start Of Modules</a></li> <li><a href=\"#starting-sub-modules-with-parent\">Starting Sub-Modules With Parent</a></li> </ul> </li> <li>\n<a href=\"#stopping-modules\">Stopping Modules</a><ul> <li><a href=\"#stop-events\">Stop Events</a></li> </ul> </li> <li><a href=\"#module-initializers\">Module Initializers (deprecated)</a></li> <li><a href=\"#module-finalizers\">Module Finalizers (deprecated)</a></li> </ul> <h2 id=\"basic-usage\">\nBasic Usage</h2>\n<p>A module is defined directly from an Application object. To create a module allyou need to do is give it a name.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyApp = <span class=\"hljs-keyword\">new</span> Marionette.Application();\n\n<span class=\"hljs-comment\">// Creates a new module named \"MyModule\"</span>\n<span class=\"hljs-keyword\">var</span> myModule = MyApp.module(<span class=\"hljs-string\">\"MyModule\"</span>);\n\nmyModule === MyApp.MyModule; <span class=\"hljs-comment\">// =&gt; true</span>\n</pre> <p>Modules cannot be overwritten once they are created. Subsequentcalls to <code>module</code> with the same name argument will not createa new module, but instead return the already-created instance.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyApp = <span class=\"hljs-keyword\">new</span> Marionette.Application();\n\n<span class=\"hljs-comment\">// Instantiates a new Marionette.Module</span>\n<span class=\"hljs-keyword\">var</span> myModule = MyApp.module(<span class=\"hljs-string\">\"MyModule\"</span>);\n\n<span class=\"hljs-comment\">// Returns the module you just created</span>\n<span class=\"hljs-keyword\">var</span> theSameModule = MyApp.module(<span class=\"hljs-string\">\"MyModule\"</span>);\n</pre> <h2 id=\"module-definitions\">\nModule Definitions</h2>\n<p>You can provide a definition for your module when you instantiate it.Definitions can either be a callback function or an object literal.</p> <h3 id=\"callback-function-definition\">\nCallback Function Definition</h3>\n<p>The callback function definition will be invoked immediately on callingthe <code>module</code> method.</p> <p>It will receive 6 parameters, in this order:</p> <ul> <li>The module itself</li> <li>The Application object</li> <li>Backbone</li> <li>Marionette</li> <li>jQuery</li> <li>Underscore</li> <li>Any custom arguments</li> </ul> <p>Within the callback you can attach both private and publicfunctions and data directly to your module.</p> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"MyModule\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(MyModule, MyApp, Backbone, Marionette, $, _)</span></span>{\n\n  <span class=\"hljs-comment\">// The context of the function is also the module itself</span>\n  <span class=\"hljs-keyword\">this</span> === MyModule; <span class=\"hljs-comment\">// =&gt; true</span>\n\n  <span class=\"hljs-comment\">// Private Data And Functions</span>\n  <span class=\"hljs-comment\">// --------------------------</span>\n\n  <span class=\"hljs-keyword\">var</span> myData = <span class=\"hljs-string\">\"this is private data\"</span>;\n\n  <span class=\"hljs-keyword\">var</span> myFunction = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-built_in\">console</span>.log(myData);\n  }\n\n\n  <span class=\"hljs-comment\">// Public Data And Functions</span>\n  <span class=\"hljs-comment\">// -------------------------</span>\n\n  MyModule.someData = <span class=\"hljs-string\">\"public data\"</span>;\n\n  MyModule.someFunction = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-built_in\">console</span>.log(MyModule.someData);\n  }\n});\n\n<span class=\"hljs-built_in\">console</span>.log(MyApp.MyModule.someData); <span class=\"hljs-comment\">//=&gt; public data</span>\nMyApp.MyModule.someFunction(); <span class=\"hljs-comment\">//=&gt; public data</span>\n</pre> <h4>\nAdditional Arguments</h4>\n<p>You can provide additional arguments to the definitionfunction, allowing you to import 3rd party librariesand other resources that you want to have locally scoped toyour module.</p> <p>Pass the additional arguments after thedefinition itself in the call to <code>module</code>.</p> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"MyModule\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(MyModule, MyApp, Backbone, Marionette, $, _, Lib1, Lib2, LibEtc)</span></span>{\n\n  <span class=\"hljs-comment\">// Lib1 === LibraryNumber1;</span>\n  <span class=\"hljs-comment\">// Lib2 === LibraryNumber2;</span>\n  <span class=\"hljs-comment\">// LibEtc === LibraryNumberEtc;</span>\n\n}, LibraryNumber1, LibraryNumber2, LibraryNumberEtc);\n</pre> <h4>\nSplitting A Module Definition Apart</h4>\n<p>Sometimes a module definition can become quite long. You can splitapart the definition by making subsequent calls to the <code>module</code>function.</p> <p>This can be used to split the definition of your moduleacross multiple files.</p> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"MyModule\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(MyModule)</span></span>{\n  MyModule.definition1 = <span class=\"hljs-literal\">true</span>;\n});\n\n<span class=\"hljs-comment\">// The following could be in a separate file</span>\nMyApp.module(<span class=\"hljs-string\">\"MyModule\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(MyModule)</span></span>{\n  MyModule.definition2 = <span class=\"hljs-literal\">true</span>;\n});\n\nMyApp.MyModule.definition1; <span class=\"hljs-comment\">//=&gt; true</span>\nMyApp.MyModule.definition2; <span class=\"hljs-comment\">//=&gt; true</span>\n</pre> <h3 id=\"object-literal-definition\">\nObject Literal Definition</h3>\n<p>The object literal definition of a module allows for more flexibilitythan the callback method. It allows you to, for instance, specifya custom class for your module.</p> <p>Through the object literal definition you can still set a definitionfunction through the <code>define</code> property.</p> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"MyModule\"</span>, {\n  define: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(MyModule, MyApp, Backbone, Marionette, $, _)</span> </span>{\n    <span class=\"hljs-comment\">// Define your module here</span>\n  }\n});\n</pre> <h4>\nSpecifying a Custom Module Class</h4>\n<p>One of the more useful features of the object literal definition is specifying a custommodule class. You can make a new class using the extend function.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> CustomModule = Marionette.Module.extend({\n  <span class=\"hljs-comment\">// Custom module properties</span>\n});\n\nMyApp.module(<span class=\"hljs-string\">\"Foo\"</span>, {\n  moduleClass: CustomModule,\n  define: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{} <span class=\"hljs-comment\">// You can still use the definition function on custom modules</span>\n});\n</pre> <p>When <code>moduleClass</code> is omitted Marionette will default to instantiating a new <code>Marionette.Module</code>.</p> <h4>\nInitialize Function</h4>\n<p>Modules have an <code>initialize</code> function which is immediately called when the Module is invoked. You can think of the <code>initialize</code> function as an extension of the constructor.</p> <p>The initialize function is only available through the object literal definition of a Module.</p> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"Foo\"</span>, {\n  startWithParent: <span class=\"hljs-literal\">false</span>,\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(moduleName, app, options)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.someProperty = <span class=\"hljs-string\">'someValue'</span>;\n  },\n  <span class=\"hljs-comment\">// You can still set a define function</span>\n  define: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(Foo)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.someProperty); <span class=\"hljs-comment\">// Logs 'someValue'</span>\n  }\n});\n</pre> <p>The <code>initialize</code> function is passed the same arguments as the constructor.</p> <ul> <li>The moduleName</li> <li>The app</li> <li>The object literal definition of the Module itself (which allows you to pass arbitrary values to your Module)</li> </ul> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"Foo\"</span>, {\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">( moduleName, app, options )</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log( options.someVar ); <span class=\"hljs-comment\">// Logs 'someString'</span>\n  },\n  someVar: <span class=\"hljs-string\">'someString'</span>\n});\n</pre> <p>The initialize function is distinct from the <code>define</code> function. The primary difference between the two is that <code>initialize</code> is on the prototype chain, whereas <code>define</code> is not. What this means is that <code>initialize</code> can be inherited.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> CustomModule = Marionette.Module.extend({\n  define: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{},    <span class=\"hljs-comment\">// This is not inherited and will never be called</span>\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{} <span class=\"hljs-comment\">// This, on the other hand, will be inherited</span>\n});\n</pre> <h2 id=\"module-classes\">\nModule Classes</h2>\n<p>Module classes can be used as an alternative to the define pattern.</p> <p>The extend function of a Module is identical to the extend functions on other Backbone and Marionette classes. This allows module lifecycle events like <code>onStart</code> and <code>onStop</code> to be called directly.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> FooModule = Marionette.Module.extend({\n  startWithParent: <span class=\"hljs-literal\">false</span>,\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(moduleName, app, options)</span> </span>{\n  },\n\n  onStart: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n  },\n\n  onStop: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n  },\n});\n\nMyApp.module(<span class=\"hljs-string\">\"Foo\"</span>, FooModule);\n</pre> <p>If all of the module's functionality is defined inside its class, then the class can be passed in directly. <code>MyApp.module(\"Foo\", FooModule)</code></p> <h2 id=\"defining-sub-modules\">\nDefining Sub-Modules</h2>\n<p>Sub-Modules (or 'child' Modules) can be defined in a single call by passinga period-separated list of Modules to be created.</p> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"Parent.Child.GrandChild\"</span>);\n\nMyApp.Parent; <span class=\"hljs-comment\">// =&gt; a valid module object</span>\nMyApp.Parent.Child; <span class=\"hljs-comment\">// =&gt; a valid module object</span>\nMyApp.Parent.Child.GrandChild; <span class=\"hljs-comment\">// =&gt; a valid module object</span>\n</pre> <p>When defining sub-modules using the dot-notation, theparent modules do not need to exist; they'll be created for you. If a parenthas already been instantiated then that instance will be used.</p> <h2 id=\"accessing-modules\">\nAccessing Modules</h2>\n<p>Although modules are attached directly to the Application instance we don't recommend accessing them this way. Instead,use the <code>.module()</code> function to access your modules.</p> <p>Let's look at two examples of accessing a module named <code>MyModule.Submodule</code>.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// Not recommended</span>\n<span class=\"hljs-keyword\">var</span> myModule = App.MyModule.Submodule;\n\n<span class=\"hljs-comment\">// Recommended</span>\n<span class=\"hljs-keyword\">var</span> MyModule = App.module(<span class=\"hljs-string\">'MyModule.Submodule'</span>);\n</pre> <h2 id=\"starting-and-stopping-modules\">\nStarting And Stopping Modules</h2>\n<p>Modules can be started and stopped independently of the application andof each other. This allows them to be loaded asynchronously, and also allowsthem to be shut down when they are no longer needed.</p> <p>This also facilitates unit testing of modules as you can start only themodule that you need in your tests.</p> <h2 id=\"starting-modules\">\nStarting Modules</h2>\n<p>Modules will, by default, start with the parent application. They also have a<code>.start</code> function that can be used to start a stopped module, or a module that'sbeen configured to start independently from its parent.</p> <p>In this example, the module will exhibit the default behavior and start automaticallywith the parent application object's <code>start</code> call:</p> <pre data-language=\"js\">MyApp = <span class=\"hljs-keyword\">new</span> Marionette.Application();\n\nMyApp.module(<span class=\"hljs-string\">\"Foo\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  <span class=\"hljs-comment\">// module code goes here</span>\n});\n\nMyApp.start();\n</pre> <p>Note that modules loaded after the <code>MyApp.start()</code> call will beimmediately started.</p> <h3 id=\"start-events\">\nStart Events</h3>\n<p>When starting a module, a \"before:start\" event will be triggered priorto any of the initializers being run. A \"start\" event will then betriggered after they have been run.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> mod = MyApp.module(<span class=\"hljs-string\">\"MyMod\"</span>);\n\nmod.on(<span class=\"hljs-string\">\"before:start\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  <span class=\"hljs-comment\">// do stuff before the module is started</span>\n});\n\nmod.on(<span class=\"hljs-string\">\"start\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  <span class=\"hljs-comment\">// do stuff after the module has been started</span>\n});\n</pre> <h4>\nPassing Data to Start Events</h4>\n<p><code>.start</code> takes a single <code>options</code> parameter that will be passed to start events and their equivalent methods (<code>onStart</code> and <code>onBeforeStart</code>.)</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> mod = MyApp.module(<span class=\"hljs-string\">\"MyMod\"</span>);\n\nmod.on(<span class=\"hljs-string\">\"before:start\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n  <span class=\"hljs-comment\">// do stuff before the module is started</span>\n});\n\nmod.on(<span class=\"hljs-string\">\"start\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n  <span class=\"hljs-comment\">// do stuff after the module has been started</span>\n});\n\n<span class=\"hljs-keyword\">var</span> options = {\n <span class=\"hljs-comment\">// any data</span>\n};\nmod.start(options);\n</pre> <h3 id=\"preventing-auto-start-of-modules\">\nPreventing Auto-Start Of Modules</h3>\n<p>The default behavior of modules is that they start with the application.If you wish to manually start a module instead, you can change this behaviorwith the <code>startWithParent</code> property.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> fooModule = MyApp.module(<span class=\"hljs-string\">\"Foo\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n\n  <span class=\"hljs-comment\">// prevent starting with parent</span>\n  <span class=\"hljs-keyword\">this</span>.startWithParent = <span class=\"hljs-literal\">false</span>;\n\n  <span class=\"hljs-comment\">// ... module code goes here</span>\n});\n\n<span class=\"hljs-comment\">// start the app without starting the module</span>\nMyApp.start();\n\n<span class=\"hljs-comment\">// later, start the module</span>\nfooModule.start();\n</pre> <p>The same behavior can be accomplished with the object literal definition:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> fooModule = MyApp.module(<span class=\"hljs-string\">\"Foo\"</span>, {\n  startWithParent: <span class=\"hljs-literal\">false</span>\n});\n</pre> <p>When splitting a module across multiple files, it is recommended that you set<code>startWithParent</code> to be false.</p> <h3 id=\"starting-sub-modules-with-parent\">\nStarting Sub-Modules With Parent</h3>\n<p>As you might expect, submodules default to starting with their parent module. The starting of sub-modules is done in a depth-first hierarchy traversal.That is, a hierarchy of <code>Foo.Bar.Baz</code> will start <code>Baz</code> first, then <code>Bar</code>,and finally <code>Foo</code>.</p> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"Foo\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{...});\nMyApp.module(<span class=\"hljs-string\">\"Foo.Bar\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{...});\n\nMyApp.start();\n</pre> <p>In this example, the \"Foo.Bar\" module will be started with the call to<code>MyApp.start()</code> because the parent module, \"Foo\" is (by default) set to startwith the app.</p> <p>A sub-module can override this behavior by setting its <code>startWithParent</code>to false. This prevents it from being started by the parent's <code>start</code> call.</p> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"Foo\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{...});\n\nMyApp.module(<span class=\"hljs-string\">\"Foo.Bar\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  <span class=\"hljs-keyword\">this</span>.startWithParent = <span class=\"hljs-literal\">false</span>;\n})\n\nMyApp.start();\n</pre> <p>Now the module \"Foo\" will be started, but the sub-module \"Foo.Bar\" willnot be started.</p> <p>A sub-module can still be started manually, with this configuration:</p> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"Foo.Bar\"</span>).start();\n</pre> <h2 id=\"stopping-modules\">\nStopping Modules</h2>\n<p>A module can be stopped, or shut down, to clear memory and resources whenthe module is no longer needed. Like the starting of modules, stopping is donein a depth-first hierarchy traversal. That is, a hierarchy of modules like<code>Foo.Bar.Baz</code> will stop <code>Baz</code> first, then <code>Bar</code>, and finally <code>Foo</code>.</p> <p>To stop a module and its children, call the <code>stop</code> method of a module.</p> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"Foo\"</span>).stop();\n</pre> <p>Modules are not automatically stopped by the application. If you wish tostop one you must call the <code>stop</code> method on it, or stop its parent module.When you stop any parent module, all of its children will be stopped as well.</p> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"Foo.Bar.Baz\"</span>);\n\nMyApp.module(<span class=\"hljs-string\">\"Foo\"</span>).stop();\n</pre> <p>This call to <code>stop</code> causes the <code>Bar</code> and <code>Baz</code> modules to both be stoppedas they are sub-modules of <code>Foo</code>. For more information on definingsub-modules, see the section \"Defining Sub-Modules\".</p> <h3 id=\"stop-events\">\nStop Events</h3>\n<p>When stopping a module, a \"before:stop\" event will be triggered priorto any of the finalizers being run. A \"stop\" event will then be triggeredafter they have been run.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> mod = MyApp.module(<span class=\"hljs-string\">\"MyMod\"</span>);\n\nmod.on(<span class=\"hljs-string\">\"before:stop\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  <span class=\"hljs-comment\">// do stuff before the module is stopped</span>\n});\n\nmod.on(<span class=\"hljs-string\">\"stop\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  <span class=\"hljs-comment\">// do stuff after the module has been stopped</span>\n});\n</pre> <h3 id=\"module-initializers\">\nModule Initializers</h3>\n<blockquote> <p>Warning: deprecated</p> <p>This feature is deprecated, and is scheduled to be removed in version 3 of Marionette. Insteadof Initializers, you should use events to manage start-up logic. The <code>start</code> event is an idealsubstitute for Initializers.</p> <p>If you were relying on the deferred nature of Initializers in your app, you should insteaduse Promises. This might look something like the following:</p> <pre data-language=\"js\">doAsyncThings().then(myModule.start);\n</pre> </blockquote> <p>Modules, like <code>Application</code> objects, can be configured to have initializers. And just likean Application's initializers, module's initializers are run anytime thatthe module is started. Further, there is no limit to the number of initializers it can have.</p> <p>Initializers can be added in the module's definition function.</p> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"Foo\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(Foo)</span></span>{\n\n  Foo.addInitializer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// Do things once the module has started</span>\n  });\n\n  Foo.addInitializer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// You can have more than one initializer</span>\n  });\n\n});\n</pre> <h3 id=\"module-finalizers\">\nModule Finalizers</h3>\n<blockquote> <p>Warning: deprecated</p> <p>This feature is deprecated, and is scheduled to be removed in version 3 of Marionette. Insteadof Finalizers, you should use events to manage start-up logic. The <code>stop</code> event is an idealsubstitute for Finalizers.</p> <p>If you were relying on the deferred nature of Initializers in your app, you should insteaduse Promises. This might look something like the following:</p> <pre data-language=\"js\">doAsyncThings().then(myModule.stop);\n</pre> <p>Modules also have finalizers that work in an opposite manner toinitializers: they are called whenever a module is stopped via the <code>stop</code> method.You can have as many finalizers as you'd like.</p> </blockquote> <pre data-language=\"js\">MyApp.module(<span class=\"hljs-string\">\"Foo\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(Foo)</span></span>{\n\n  Foo.addFinalizer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// Tear down, shut down and clean up the module in here</span>\n  });\n\n  Foo.addFinalizer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// Do more things</span>\n  });\n\n});\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.module.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.module.html</a>\n  </p>\n</div>\n","marionette.itemview":"<h1>\nMarionette.ItemView</h1>\n<p>An <code>ItemView</code> is a view that represents a single item. That item may be a<code>Backbone.Model</code> or may be a <code>Backbone.Collection</code>. Whichever it is though, itwill be treated as a single item.</p> <p>ItemView extends directly from Marionette.View. Please see<a href=\"marionette.view\">the Marionette.View documentation</a>for more information on available features and functionality.</p> <p>Additionally, interactions with Marionette.Regionwill provide features such as <code>onShow</code> callbacks, etc. Please see<a href=\"marionette.region\">the Region documentation</a> for more information.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#itemview-render\">ItemView render</a></li> <li><a href=\"#rendering-a-collection-in-an-itemview\">Rendering A Collection In An ItemView</a></li> <li><a href=\"#template-less-itemview\">Template-less ItemView</a></li> <li>\n<a href=\"#events-and-callback-methods\">Events and Callback Methods</a><ul> <li><a href=\"#beforerender--onbeforerender-event\">\"before:render\" / onBeforeRender event</a></li> <li><a href=\"#render--onrender-event\">\"render\" / onRender event</a></li> <li><a href=\"#beforedestroy--onbeforedestroy-event\">\"before:destroy\" / onBeforeDestroy event</a></li> <li><a href=\"#destroy--ondestroy-event\">\"destroy\" / onDestroy event</a></li> </ul> </li> <li><a href=\"#itemview-serializedata\">ItemView serializeData</a></li> <li><a href=\"#organizing-ui-elements\">Organizing ui elements</a></li> <li><a href=\"#modelevents-and-collectionevents\">modelEvents and collectionEvents</a></li> </ul> <h2 id=\"itemview-render\">\nItemView render</h2>\n<p>Unlike Backbone Views, all Marionette views come with a powerful render method.In fact, the primary differences between the views are the differences in theirrender methods. It goes without saying that it is unwise to override the <code>render</code>method of any Marionette view. Instead, you should use the <a href=\"#events-and-callback-methods\"><code>onBeforeRender</code> and <code>onRender</code> callbacks</a>to layer in additional functionality to the rendering of your view.</p> <p>The <code>ItemView</code> defers to the <code>Marionette.Renderer</code> object to do the actualrendering of the template.</p> <p>The item view instance is passed as the third argument to the<code>Renderer</code> object's <code>render</code> method, which is useful in custom<code>Renderer</code> implementations.</p> <p>You should provide a <code>template</code> attribute on the item view, whichwill be either a jQuery selector:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  template: <span class=\"hljs-string\">\"#some-template\"</span>\n});\n\n<span class=\"hljs-keyword\">new</span> MyView().render();\n</pre> <p>.. or a function taking a single argument: the object returned by <a href=\"#itemview-serializedata\">ItemView.serializeData</a>:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> my_template_html = <span class=\"hljs-string\">'&lt;div&gt;&lt;%= args.name %&gt;&lt;/div&gt;'</span>\n<span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  template : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(serialized_model)</span> </span>{\n    <span class=\"hljs-keyword\">var</span> name = serialized_model.name;\n    <span class=\"hljs-keyword\">return</span> _.template(my_template_html)({\n        name : name,\n        some_custom_attribute : some_custom_key\n    });\n  }\n});\n\n<span class=\"hljs-keyword\">new</span> MyView().render();\n</pre> <p>Note that using a template function allows passing custom arguments into the <em>.template function and allows for more control over how the </em>.template function is called.</p> <p>For more information on the _.template function see the <a href=\"http://underscorejs.org/#template\">Underscore docs</a>.</p> <h2 id=\"rendering-a-collection-in-an-itemview\">\nRendering A Collection In An ItemView</h2>\n<p>While the most common way to render a Backbone.Collection is to usea <code>CollectionView</code> or <code>CompositeView</code>, if you just need to render asimple list that does not need a lot of interaction, it does notalways make sense to use these. A Backbone.Collection can berendered with a simple ItemView, using the templates to iterateover an <code>items</code> array.</p> <pre data-language=\"js\">&lt;script id=<span class=\"hljs-string\">\"some-template\"</span> type=<span class=\"hljs-string\">\"text/html\"</span>&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ul</span>&gt;</span>\n    <span class=\"vbscript\">&lt;% _.<span class=\"hljs-keyword\">each</span>(items, <span class=\"hljs-keyword\">function</span>(item){ %&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">li</span>&gt;</span> <span class=\"vbscript\">&lt;%= item.someAttribute %&gt;</span> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">li</span>&gt;</span>\n    <span class=\"vbscript\">&lt;% }); %&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span></span>\n</pre> <p>The important thing to note here, is the use of <code>items</code> as thevariable to iterate in the <code>_.each</code> call. This will always be thename of the variable that contains your collection's items.</p> <p>Then, from JavaScript, you can define and use an ItemView with thistemplate, like this:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyItemsView = Marionette.ItemView.extend({\n  template: <span class=\"hljs-string\">\"#some-template\"</span>\n});\n\n<span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> MyItemsView({\n  collection: someCollection\n});\n\n<span class=\"hljs-comment\">// show the view via a region or calling the .render method directly</span>\n</pre> <p>Rendering this view will convert the <code>someCollection</code> collection in tothe <code>items</code> array for your template to use.</p> <p>For more information on when you would want to do this, and what optionsyou have for retrieving an individual item that was clicked orotherwise interacted with, see the blog post on<a href=\"http://lostechies.com/derickbailey/2011/10/11/backbone-js-getting-the-model-for-a-clicked-element/\">Getting The Model For A Clicked Element</a>.</p> <h2 id=\"template-less-itemview\">\nTemplate-less ItemView</h2>\n<p>An <code>ItemView</code> can be attached to existing elements as well. The primary benefit of this is to attach behavior and events to static content that has been rendered by your server (typically for SEO purposes). To set up a template-less <code>ItemView</code>, your <code>template</code> attribute must be <code>false</code>.</p> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"my-element\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">p</span>&gt;</span>Hello World<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">button</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"my-button\"</span>&gt;</span>Click Me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n</pre> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  el: <span class=\"hljs-string\">'#my-element'</span>,\n\n  template: <span class=\"hljs-literal\">false</span>,\n\n  ui: {\n    paragraph: <span class=\"hljs-string\">'p'</span>,\n    button: <span class=\"hljs-string\">'.my-button'</span>\n  },\n\n  events: {\n    <span class=\"hljs-string\">'click @ui.button'</span>: <span class=\"hljs-string\">'clickedButton'</span>\n  },\n\n  clickedButton: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'I clicked the button!'</span>);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> MyView();\nview.render();\n\nview.ui.paragraph.text();        <span class=\"hljs-comment\">// returns 'Hello World'</span>\nview.ui.button.trigger(<span class=\"hljs-string\">'click'</span>); <span class=\"hljs-comment\">// logs 'I clicked the button!'</span>\n</pre> <p>Another use case is when you want to attach a <code>Marionette.ItemView</code> to a SVG graphic or canvas element, to provide a uniform view layer interface to non-standard DOM nodes. By not having a template this allows you to also use a view on pre-rendered DOM nodes, such as complex graphic elements.</p> <h2 id=\"events-and-callback-methods\">\nEvents and Callback Methods</h2>\n<p>There are several events and callback methods that are calledfor an ItemView. These events and methods are triggered with the<a href=\"marionette.functions#marionettetriggermethod\">Marionette.triggerMethod</a> function, whichtriggers the event and a corresponding \"on{EventName}\" method.</p> <h3 id=\"beforerender--onbeforerender-event\">\n\"before:render\" / onBeforeRender event</h3>\n<p>Triggered before an ItemView is rendered.</p> <pre data-language=\"js\">Marionette.ItemView.extend({\n  onBeforeRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// set up final bits just before rendering the view's `el`</span>\n  }\n});\n</pre> <h3 id=\"render--onrender-event\">\n\"render\" / onRender event</h3>\n<p>Triggered after the view has been rendered.You can implement this in your view to provide custom code for dealingwith the view's <code>el</code> after it has been rendered.</p> <pre data-language=\"js\">Marionette.ItemView.extend({\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// manipulate the `el` here. it's already</span>\n    <span class=\"hljs-comment\">// been rendered, and is full of the view's</span>\n    <span class=\"hljs-comment\">// HTML, ready to go.</span>\n  }\n});\n</pre> <h3 id=\"beforedestroy--onbeforedestroy-event\">\n\"before:destroy\" / onBeforeDestroy event</h3>\n<p>Triggered just prior to destroying the view, when the view's <code>destroy()</code>method has been called.</p> <pre data-language=\"js\">Marionette.ItemView.extend({\n  onBeforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// manipulate the `el` here. it's already</span>\n    <span class=\"hljs-comment\">// been rendered, and is full of the view's</span>\n    <span class=\"hljs-comment\">// HTML, ready to go.</span>\n  }\n});\n</pre> <h3 id=\"destroy--ondestroy-event\">\n\"destroy\" / onDestroy event</h3>\n<p>Triggered just after the view has been destroyed.</p> <pre data-language=\"js\">Marionette.ItemView.extend({\n  onDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// custom destroying and cleanup goes here</span>\n  }\n});\n</pre> <h2 id=\"itemview-serializedata\">\nItemView serializeData</h2>\n<p>Item views will serialize a model or collection, by default, bycalling <code>.toJSON</code> on either the model or collection. If both a modeland collection are attached to an item view, the model will be usedas the data source. The results of the data serialization will be passed to the templatethat is rendered.</p> <p>If the serialization is a model, the results are passed in directly:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> myModel = <span class=\"hljs-keyword\">new</span> MyModel({foo: <span class=\"hljs-string\">\"bar\"</span>});\n\n<span class=\"hljs-keyword\">new</span> MyItemView({\n  template: <span class=\"hljs-string\">\"#myItemTemplate\"</span>,\n  model: myModel\n});\n\nMyItemView.render();\n</pre> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"myItemTemplate\"</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"template\"</span>&gt;</span><span class=\"javascript\">\n  Foo is: <span class=\"xml\"><span class=\"vbscript\">&lt;%= foo %&gt;</span>\n</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</pre> <p>If the serialization is a collection, the results are passed in as an<code>items</code> array:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> myCollection = <span class=\"hljs-keyword\">new</span> MyCollection([{foo: <span class=\"hljs-string\">\"bar\"</span>}, {foo: <span class=\"hljs-string\">\"baz\"</span>}]);\n\n<span class=\"hljs-keyword\">new</span> MyItemView({\n  template: <span class=\"hljs-string\">\"#myCollectionTemplate\"</span>,\n  collection: myCollection\n});\n\nMyItemView.render();\n</pre> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"myCollectionTemplate\"</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"template\"</span>&gt;</span><span class=\"javascript\">\n  &lt;% _.each(items, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(item)</span></span>{ %&gt;\n    Foo is: <span class=\"xml\"><span class=\"vbscript\">&lt;%= foo %&gt;</span>\n  <span class=\"vbscript\">&lt;% }); %&gt;</span>\n</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</pre> <p>If you need custom serialization for your data, you can provide a<code>serializeData</code> method on your view. It must return a valid JSONobject, as if you had called <code>.toJSON</code> on a model or collection.</p> <pre data-language=\"js\">Marionette.ItemView.extend({\n  serializeData: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-string\">\"some attribute\"</span>: <span class=\"hljs-string\">\"some value\"</span>\n    }\n  }\n});\n</pre> <h2 id=\"organizing-ui-elements\">\nOrganizing UI Elements</h2>\n<p>As documented in <a href=\"marionette.view#viewbindentityevents\">Marionette.View</a>, you can specify a <code>ui</code> hash in your <code>view</code> thatmaps UI elements by their jQuery selectors. This is especially useful if you access thesame UI element more than once in your view's code. Instead ofduplicating the selector, you can simply reference it by<code>this.ui.elementName</code>:</p> <p>You can also use the ui hash values from within events and trigger keys using the <code>\"@ui.elementName\"</code>: syntax</p> <pre data-language=\"js\">Marionette.ItemView.extend({\n  tagName: <span class=\"hljs-string\">\"tr\"</span>,\n\n  ui: {\n    checkbox: <span class=\"hljs-string\">\"input[type=checkbox]\"</span>\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.model.get(<span class=\"hljs-string\">'selected'</span>)) {\n      <span class=\"hljs-keyword\">this</span>.ui.checkbox.addClass(<span class=\"hljs-string\">'checked'</span>);\n    }\n  }\n});\n</pre> <h2 id=\"modelevents-and-collectionevents\">\nmodelEvents and collectionEvents</h2>\n<p>ItemViews can bind directly to model events and collection eventsin a declarative manner:</p> <pre data-language=\"js\">Marionette.ItemView.extend({\n  modelEvents: {\n    <span class=\"hljs-string\">\"change\"</span>: <span class=\"hljs-string\">\"modelChanged\"</span>\n  },\n\n  collectionEvents: {\n    <span class=\"hljs-string\">\"add\"</span>: <span class=\"hljs-string\">\"modelAdded\"</span>\n  }\n});\n</pre> <p>For more information, see the <a href=\"marionette.view#viewmodelevents-and-viewcollectionevents\">Marionette.View</a> documentation.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.itemview.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.itemview.html</a>\n  </p>\n</div>\n","marionette.collectionview":"<h1>\nMarionette.CollectionView</h1>\n<p>The <code>CollectionView</code> will loop through all of the models in thespecified collection, render each of them using a specified <code>childView</code>,then append the results of the child view's <code>el</code> to the collection view's<code>el</code>. By default the <code>CollectionView</code> will maintain a sorted collection's orderin the DOM. This behavior can be disabled by specifying <code>{sort: false}</code> on initialize.</p> <p>CollectionView extends directly from Marionette.View. Please see<a href=\"marionette.view\">the Marionette.View documentation</a>for more information on available features and functionality.</p> <p>Additionally, interactions with Marionette.Regionwill provide features such as <code>onShow</code> callbacks, etc. Please see<a href=\"marionette.region\">the Region documentation</a> for more information.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li>\n<a href=\"#collectionviews-childview\">CollectionView's <code>childView</code></a><ul> <li><a href=\"#collectionviews-getchildview\">CollectionView's <code>getChildView</code></a></li> <li><a href=\"#collectionviews-childviewoptions\">CollectionView's <code>childViewOptions</code></a></li> <li><a href=\"#collectionviews-childvieweventprefix\">CollectionView's <code>childViewEventPrefix</code></a></li> <li><a href=\"#collectionviews-childevents\">CollectionView's <code>childEvents</code></a></li> <li><a href=\"#collectionviews-buildchildview\">CollectionView's <code>buildChildView</code></a></li> <li><a href=\"#collectionviews-removechildview\">CollectionView's <code>removeChildView</code></a></li> <li><a href=\"#collectionviews-addchild\">CollectionView's <code>addChild</code></a></li> <li><a href=\"#collectionviews-reorderonsort\">CollectionView's <code>reorderOnSort</code></a></li> </ul> </li> <li>\n<a href=\"#collectionviews-emptyview\">CollectionView's <code>emptyView</code></a><ul> <li><a href=\"#collectionviews-getemptyview\">CollectionView's <code>getEmptyView</code></a></li> <li><a href=\"#collectionviews-isempty\">CollectionView's <code>isEmpty</code></a></li> <li><a href=\"#collectionviews-emptyviewoptions\">CollectionView's <code>emptyViewOptions</code></a></li> <li><a href=\"#collectionviews-destroychildren\">CollectionView's <code>destroyChildren</code></a></li> </ul> </li> <li>\n<a href=\"#callback-methods\">Callback Methods</a><ul> <li><a href=\"#onbeforerender-callback\">onBeforeRender callback</a></li> <li><a href=\"#onrender-callback\">onRender callback</a></li> <li><a href=\"#onbeforereorder-callback\">onBeforeReorder callback</a></li> <li><a href=\"#onreorder-callback\">onReorder callback</a></li> <li><a href=\"#beforedestroy-callback\">onBeforeDestroy callback</a></li> <li><a href=\"#ondestroy-callback\">onDestroy callback</a></li> <li><a href=\"#onbeforeaddchild-callback\">onBeforeAddChild callback</a></li> <li><a href=\"#onaddchild-callback\">onAddChild callback</a></li> <li><a href=\"#onbeforeremovechild-callback\">onBeforeRemoveChild callback</a></li> <li><a href=\"#onremovechild-callback\">onRemoveChild callback</a></li> </ul> </li> <li>\n<a href=\"#collectionview-events\">CollectionView Events</a><ul> <li><a href=\"#beforerender-event\">\"before:render\" event</a></li> <li><a href=\"#render-event\">\"render\" event</a></li> <li><a href=\"#beforereorder--reorder-event\">\"before:reorder\" / \"reorder\" event</a></li> <li><a href=\"#beforedestroy-event\">\"before:destroy\" event</a></li> <li><a href=\"#destroy--destroycollection-event\">\"destroy\" / \"destroy:collection\" event</a></li> <li><a href=\"#beforeaddchild--addchild-event\">\"before:add:child\" / \"add:child\" event</a></li> <li><a href=\"#beforeremovechild-event\">\"before:remove:child event</a></li> <li><a href=\"#removechild-event\">\"remove:child\" event</a></li> <li><a href=\"#childview-event-bubbling-from-child-views\">\"childview:*\" event bubbling from child views</a></li> <li><a href=\"#beforerendercollection-event\">\"before:render:collection\" event</a></li> <li><a href=\"#rendercollection-event\">\"render:collection\" event</a></li> </ul> </li> <li><a href=\"#collectionview-child-view-events\">CollectionView Child View Events</a></li> <li><a href=\"#collectionview-render\">CollectionView render</a></li> <li><a href=\"#collectionview-automatic-rendering\">CollectionView: Automatic Rendering</a></li> <li><a href=\"#collectionview-re-render-collection\">CollectionView: Re-render Collection</a></li> <li><a href=\"#collectionviews-attachhtml\">CollectionView's attachHtml</a></li> <li><a href=\"#collectionviews-resortview\">CollectionView's resortView</a></li> <li><a href=\"#collectionviews-viewcomparator\">CollectionView's viewComparator</a></li> <li><a href=\"#collectionviews-filter\">CollectionView's <code>filter</code></a></li> <li><a href=\"#collectionviews-children\">CollectionView's children</a></li> <li><a href=\"#collectionview-destroy\">CollectionView destroy</a></li> </ul> <h2 id=\"collectionviews-childview\">\nCollectionView's <code>childView</code>\n</h2>\n<p>Specify a <code>childView</code> in your collection view definition. This must bea Backbone view object definition, not an instance. It can be any<code>Backbone.View</code> or be derived from <code>Marionette.ItemView</code>.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyChildView = Marionette.ItemView.extend({});\n\nMarionette.CollectionView.extend({\n  childView: MyChildView\n});\n</pre> <p>Child views must be defined before they are referenced by the<code>childView</code> attribute in a collection view definition. Use <code>getChildView</code>to lookup the definition as child views are instantiated.</p> <p>Alternatively, you can specify a <code>childView</code> in the options forthe constructor:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyCollectionView = Marionette.CollectionView.extend({...});\n\n<span class=\"hljs-keyword\">new</span> MyCollectionView({\n  childView: MyChildView\n});\n</pre> <p>If you do not specify a <code>childView</code>, an exception will be thrownstating that you must specify a <code>childView</code>.</p> <h3 id=\"collectionviews-getchildview\">\nCollectionView's <code>getChildView</code>\n</h3>\n<p>The value returned by this method is the <code>ChildView</code> class that will be instantiated when a <code>Model</code> needs to be initially rendered.This method also gives you the ability to customize per <code>Model</code> <code>ChildViews</code>.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> FooBar = Backbone.Model.extend({\n  defaults: {\n    isFoo: <span class=\"hljs-literal\">false</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> FooView = Marionette.ItemView.extend({\n  template: <span class=\"hljs-string\">'#foo-template'</span>\n});\n<span class=\"hljs-keyword\">var</span> BarView = Marionette.ItemView.extend({\n  template: <span class=\"hljs-string\">'#bar-template'</span>\n});\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Marionette.CollectionView.extend({\n  getChildView: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(item)</span> </span>{\n    <span class=\"hljs-comment\">// Choose which view class to render,</span>\n    <span class=\"hljs-comment\">// depending on the properties of the item model</span>\n    <span class=\"hljs-keyword\">if</span>  (item.get(<span class=\"hljs-string\">'isFoo'</span>)) {\n      <span class=\"hljs-keyword\">return</span> FooView;\n    }\n    <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> BarView;\n    }\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> collectionView = <span class=\"hljs-keyword\">new</span> MyCollectionView({\n  collection: <span class=\"hljs-keyword\">new</span> Backbone.Collection()\n});\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">new</span> FooBar({\n  isFoo: <span class=\"hljs-literal\">true</span>\n});\n<span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-keyword\">new</span> FooBar({\n  isFoo: <span class=\"hljs-literal\">false</span>\n});\n\n<span class=\"hljs-comment\">// Renders a FooView</span>\ncollectionView.collection.add(foo);\n\n<span class=\"hljs-comment\">// Renders a BarView</span>\ncollectionView.collection.add(bar);\n</pre> <h3 id=\"collectionviews-childviewoptions\">\nCollectionView's <code>childViewOptions</code>\n</h3>\n<p>There may be scenarios where you need to pass data from your parentcollection view in to each of the childView instances. To do this, providea <code>childViewOptions</code> definition on your collection view as an objectliteral. This will be passed to the constructor of your childView as partof the <code>options</code>.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> ChildView = Marionette.ItemView.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(options.foo); <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> CollectionView = Marionette.CollectionView.extend({\n  childView: ChildView,\n\n  childViewOptions: {\n    foo: <span class=\"hljs-string\">\"bar\"</span>\n  }\n});\n</pre> <p>You can also specify the <code>childViewOptions</code> as a function, if you need tocalculate the values to return at runtime. The model will be passed intothe function should you need access to it when calculating<code>childViewOptions</code>. The function must return an object, and the attributesof the object will be copied to the <code>childView</code> instance's options.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> CollectionView = Marionette.CollectionView.extend({\n  childViewOptions: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(model, index)</span> </span>{\n    <span class=\"hljs-comment\">// do some calculations based on the model</span>\n    <span class=\"hljs-keyword\">return</span> {\n      foo: <span class=\"hljs-string\">\"bar\"</span>,\n      childIndex: index\n    }\n  }\n});\n</pre> <h3 id=\"collectionviews-childvieweventprefix\">\nCollectionView's <code>childViewEventPrefix</code>\n</h3>\n<p>You can customize the event prefix for events that are forwardedthrough the collection view. To do this, set the <code>childViewEventPrefix</code>on the collection view. For more information on the <code>childViewEventPrefix</code> see<a href=\"#childview-event-bubbling-from-child-views\">\"childview:*\" event bubbling from child views</a></p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> CV = Marionette.CollectionView.extend({\n  childViewEventPrefix: <span class=\"hljs-string\">\"some:prefix\"</span>\n});\n\n<span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-keyword\">new</span> CV({\n  collection: myCol\n});\n\nc.on(<span class=\"hljs-string\">\"some:prefix:render\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  <span class=\"hljs-comment\">// child view was rendered</span>\n});\n\nc.render();\n</pre> <p>The <code>childViewEventPrefix</code> can be provided in the view definition orin the constructor function call, to get a view instance.</p> <h3 id=\"collectionviews-childevents\">\nCollectionView's <code>childEvents</code>\n</h3>\n<p>A <code>childEvents</code> hash or method permits handling of child view events without manually setting bindings. The values of the hash can either be a function or a string method name on the collection view.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// childEvents can be specified as a hash...</span>\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Marionette.CollectionView.extend({\n\n  childEvents: {\n    <span class=\"hljs-comment\">// This callback will be called whenever a child is rendered or emits a `render` event</span>\n    render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view has been rendered.'</span>);\n    }\n  }\n});\n\n<span class=\"hljs-comment\">// ...or as a function that returns a hash.</span>\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Marionette.CollectionView.extend({\n\n  childEvents: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> {\n      render: <span class=\"hljs-keyword\">this</span>.onChildRendered\n    }\n  },\n\n  onChildRendered: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view has been rendered.'</span>);\n  }\n});\n</pre> <p><code>childEvents</code> also catches custom events fired by a child view. Take note that the first argument to a <code>childEvents</code> handler is the child view itself.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// The child view fires a custom event, `show:message`</span>\n<span class=\"hljs-keyword\">var</span> ChildView = Marionette.ItemView.extend({\n\n  <span class=\"hljs-comment\">// Events hash defines local event handlers that in turn may call `triggerMethod`.</span>\n  events: {\n    <span class=\"hljs-string\">'click .button'</span>: <span class=\"hljs-string\">'onClickButton'</span>\n  },\n\n  <span class=\"hljs-comment\">// Triggers hash converts DOM events directly to view events catchable on the parent.</span>\n  triggers: {\n    <span class=\"hljs-string\">'submit form'</span>: <span class=\"hljs-string\">'submit:form'</span>\n  },\n\n  onClickButton: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// Both `trigger` and `triggerMethod` events will be caught by parent.</span>\n    <span class=\"hljs-keyword\">this</span>.trigger(<span class=\"hljs-string\">'show:message'</span>, <span class=\"hljs-string\">'foo'</span>);\n    <span class=\"hljs-keyword\">this</span>.triggerMethod(<span class=\"hljs-string\">'show:message'</span>, <span class=\"hljs-string\">'bar'</span>);\n  }\n});\n\n<span class=\"hljs-comment\">// The parent uses childEvents to catch the child view's custom event</span>\n<span class=\"hljs-keyword\">var</span> ParentView = Marionette.CollectionView.extend({\n\n  childView: ChildView,\n\n  childEvents: {\n    <span class=\"hljs-string\">'show:message'</span>: <span class=\"hljs-string\">'onChildShowMessage'</span>,\n    <span class=\"hljs-string\">'submit:form'</span>: <span class=\"hljs-string\">'onChildSubmitForm'</span>\n  },\n\n  onChildShowMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(childView, message)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view fired show:message with '</span> + message);\n  },\n\n  onChildSubmitForm: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(childView)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view fired submit:form'</span>);\n  }\n});\n</pre> <h3 id=\"collectionviews-buildchildview\">\nCollectionView's <code>buildChildView</code>\n</h3>\n<p>When a custom view instance needs to be created for the <code>childView</code> thatrepresents a child, override the <code>buildChildView</code> method. This methodtakes three parameters and returns a view instance to be used as thechild view.</p> <pre data-language=\"js\">buildChildView: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(child, ChildViewClass, childViewOptions)</span></span>{\n  <span class=\"hljs-comment\">// build the final list of options for the childView class</span>\n  <span class=\"hljs-keyword\">var</span> options = _.extend({model: child}, childViewOptions);\n  <span class=\"hljs-comment\">// create the child view instance</span>\n  <span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> ChildViewClass(options);\n  <span class=\"hljs-comment\">// return it</span>\n  <span class=\"hljs-keyword\">return</span> view;\n},\n</pre> <h3 id=\"collectionviews-removechildview\">\nCollectionView's <code>removeChildView</code>\n</h3>\n<p>Remove a specific view instance and destroy it. This function also updates the indices of later views in the collection in order to keep the children in sync with the collection.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// add some views to a CollectionView</span>\n<span class=\"hljs-keyword\">var</span> myCollectionView = <span class=\"hljs-keyword\">new</span> MyCollectionView({\n  collection: <span class=\"hljs-keyword\">new</span> Backbone.Collection([fooModel, barModel]);\n});\n\nmyCollectionView.render();\n\n<span class=\"hljs-keyword\">var</span> myView = myCollectionView.children.findByModel(foo);\n\n<span class=\"hljs-comment\">// remove a child view myView</span>\nmyCollectionView.removeChildView(myView);\n\n<span class=\"hljs-comment\">// check if the removed view still exist</span>\n<span class=\"hljs-built_in\">console</span>.log(myCollectionView.children.findByModel(fooModel)); <span class=\"hljs-comment\">// return undefined</span>\n<span class=\"hljs-built_in\">console</span>.log(myCollectionView.children.findByModel(barModel)); <span class=\"hljs-comment\">// return a childView bar</span>\n</pre> <h3 id=\"collectionviews-addchild\">\nCollectionView's <code>addChild</code>\n</h3>\n<p>The <code>addChild</code> method is responsible for rendering the <code>childViews</code> and adding them to the HTML for the <code>collectionView</code> instance. It is also responsible for triggering the events per <code>ChildView</code>. In most cases you should not override this method. However if you do want to short circuit this method, it can be accomplished via the following.</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  addChild: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(child, ChildView, index)</span></span>{\n    <span class=\"hljs-keyword\">if</span> (child.shouldBeShown()) {\n      Marionette.CollectionView.prototype.addChild.apply(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-built_in\">arguments</span>);\n    }\n  }\n});\n</pre> <h3 id=\"collectionviews-reorderonsort\">\nCollectionView's <code>reorderOnSort</code>\n</h3>\n<p>This option is useful when you have performance issues when you resort your <code>CollectionView</code>.Without this option, your <code>CollectionView</code> will be completely re-rendered, which can becostly if you have a large number of elements or if your <code>ChildView</code>s are complex. If this optionis activated, when you sort your <code>Collection</code>, there will be no re-rendering, only the DOM nodeswill be reordered. This can be a problem if your <code>ChildView</code>s use their collection's indexin their rendering. In this case, you cannot use this option as you need to re-render each<code>ChildView</code>.</p> <p>If you combine this option with a <a href=\"#collectionviews-filter\">filter</a> that changes the views that areto be displayed, <code>reorderOnSort</code> will be bypassed to render new children and remove those that are rejected by the filter.</p> <h2 id=\"collectionviews-emptyview\">\nCollectionView's <code>emptyView</code>\n</h2>\n<p>When a collection has no children, and you need to render a view other thanthe list of childViews, you can specify an <code>emptyView</code> attribute on yourcollection view.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> NoChildrenView = Marionette.ItemView.extend({\n  template: <span class=\"hljs-string\">\"#show-no-children-message-template\"</span>\n});\n\nMarionette.CollectionView.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  emptyView: NoChildrenView\n});\n</pre> <h3 id=\"collectionviews-getemptyview\">\nCollectionView's <code>getEmptyView</code>\n</h3>\n<p>If you need the <code>emptyView</code>'s class chosen dynamically, specify <code>getEmptyView</code>:</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  getEmptyView: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// custom logic</span>\n    <span class=\"hljs-keyword\">return</span> NoChildrenView;\n  }\n});\n</pre> <h3 id=\"collectionviews-isempty\">\nCollectionView's <code>isEmpty</code>\n</h3>\n<p>If you want to control when the empty view is rendered, you can override<code>isEmpty</code>:</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  isEmpty: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(collection)</span> </span>{\n    <span class=\"hljs-comment\">// some logic to calculate if the view should be rendered as empty</span>\n    <span class=\"hljs-keyword\">return</span> someBoolean;\n  }\n});\n</pre> <h3 id=\"collectionviews-emptyviewoptions\">\nCollectionView's <code>emptyViewOptions</code>\n</h3>\n<p>Similar to <code>childView</code> and <code>childViewOptions</code>, there is an <code>emptyViewOptions</code> property that will be passed to the <code>emptyView</code> constructor. It can be provided as an object literal or as a function.</p> <p>If <code>emptyViewOptions</code> aren't provided the CollectionView will default to passing the <code>childViewOptions</code> to the <code>emptyView</code>.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> EmptyView = Marionette.ItemView({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n    <span class=\"hljs-built_in\">console</span>.log(options.foo); <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> CollectionView = Marionette.CollectionView({\n  emptyView: EmptyView,\n\n  emptyViewOptions: {\n    foo: <span class=\"hljs-string\">\"bar\"</span>\n  }\n});\n</pre> <h3 id=\"collectionviews-destroychildren\">\nCollectionView's <code>destroyChildren</code>\n</h3>\n<p><code>CollectionView</code> provides a <code>destroyChildren</code> method that will only destroy it's childViews. This can be useful when you would like to empty your view but keep the data in the <code>collection</code>. This method takes an optional <code>checkEmpty</code> parameter, by default it is set to <code>true</code>, if <code>false</code> it will disable the call to <code>checkEmpty</code> and <code>destroyChildren</code> will not show the <code>emptyView</code>.</p> <pre data-language=\"js\">myView.destroyChildren(); <span class=\"hljs-comment\">// will show emptyView</span>\nmyView.destroyChildren({checkEmpty: <span class=\"hljs-literal\">false</span>}); <span class=\"hljs-comment\">// will not show emptyView</span>\n</pre> <h2 id=\"callback-methods\">\nCallback Methods</h2>\n<p>There are several callback methods that can be provided on a<code>CollectionView</code>. If they are found, they will be called by theview's base methods. These callback methods are intended to behandled within the view definition directly.</p> <h3 id=\"onbeforerender-callback\">\nonBeforeRender callback</h3>\n<p>A <code>onBeforeRender</code> callback will be called just prior to renderingthe collection view.</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  onBeforeRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// do stuff here</span>\n  }\n});\n</pre> <h3 id=\"onrender-callback\">\nonRender callback</h3>\n<p>After the view has been rendered, a <code>onRender</code> method will be called.You can implement this in your view to provide custom code for dealingwith the view's <code>el</code> after it has been rendered:</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// do stuff here</span>\n  }\n});\n</pre> <h3 id=\"onbeforereorder-callback\">\nonBeforeReorder callback</h3>\n<p>If <code>reorderOnSort</code> is set to <code>true</code>, <code>onBeforeReorder</code> will be called justprior to reordering the collection view.</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  onBeforeReorder: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// do stuff here</span>\n  }\n});\n</pre> <h3 id=\"onreorder-callback\">\nonReorder callback</h3>\n<p>If <code>reorderOnSort</code> is set to <code>true</code>, after the view has been reordered,a <code>onReorder</code> method will be called.</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  onReorder: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// do stuff here</span>\n  }\n});\n</pre> <h3 id=\"onbeforedestroy-callback\">\nonBeforeDestroy callback</h3>\n<p>This method is called just before destroying the view.</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  onBeforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// do stuff here</span>\n  }\n});\n</pre> <h3 id=\"ondestroy-callback\">\nonDestroy callback</h3>\n<p>This method is called just after destroying the view.</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  onDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// do stuff here</span>\n  }\n});\n</pre> <h3 id=\"onbeforeaddchild-callback\">\nonBeforeAddChild callback</h3>\n<p>This callback function allows you to know when a child / child viewinstance is about to be added to the collection view. It provides access tothe view instance for the child that was added.</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  onBeforeAddChild: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span></span>{\n    <span class=\"hljs-comment\">// work with the childView instance, here</span>\n  }\n});\n</pre> <h3 id=\"onaddchild-callback\">\nonAddChild callback</h3>\n<p>This callback function allows you to know when a child / child viewinstance has been added to the collection view. It provides access tothe view instance for the child that was added.</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  onAddChild: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span></span>{\n    <span class=\"hljs-comment\">// work with the childView instance, here</span>\n  }\n});\n</pre> <h3 id=\"onbeforeremovechild-callback\">\nonBeforeRemoveChild callback</h3>\n<p>This callback function allows you to know when a <code>childView</code>instance is about to be removed from the <code>collectionView</code>. It provides access tothe view instance for the child that was removed.</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  onBeforeRemoveChild: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span></span>{\n    <span class=\"hljs-comment\">// work with the childView instance, here</span>\n  }\n});\n</pre> <h3 id=\"onremovechild-callback\">\nonRemoveChild callback</h3>\n<p>This callback function allows you to know when a child / childViewinstance has been deleted or removed from thecollection.</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  onRemoveChild: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span></span>{\n    <span class=\"hljs-comment\">// work with the childView instance, here</span>\n  }\n});\n</pre> <h2 id=\"collectionview-events\">\nCollectionView Events</h2>\n<p>There are several events that will be triggered during the lifeof a collection view. Each of these events is called with the<a href=\"marionette.functions#marionettetriggermethod\">Marionette.triggerMethod</a> function,which calls a corresponding \"on{EventName}\" method on theview instance (see <a href=\"#callback-methods\">above</a>).</p> <h3 id=\"beforerender-event\">\n\"before:render\" event</h3>\n<p>Triggers just prior to the view being rendered. Also triggered as\"before:render:collection\" / <code>onBeforeRenderCollection</code>.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.CollectionView.extend({...});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n\nmyView.on(<span class=\"hljs-string\">\"before:render\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  alert(<span class=\"hljs-string\">\"the collection view is about to be rendered\"</span>);\n});\n\nmyView.render();\n</pre> <h3 id=\"render-event\">\n\"render\" event</h3>\n<p>A \"render:collection\" / <code>onRenderCollection</code> event will also be fired. This allows you toadd more than one callback to execute after the view is rendered,and allows parent views and other parts of the application toknow that the view was rendered.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.CollectionView.extend({...});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n\nmyView.on(<span class=\"hljs-string\">\"render\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  alert(<span class=\"hljs-string\">\"the collection view was rendered!\"</span>);\n});\n\nmyView.on(<span class=\"hljs-string\">\"render:collection\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  alert(<span class=\"hljs-string\">\"the collection view was rendered!\"</span>);\n});\n\nmyView.render();\n</pre> <h3 id=\"beforereorder--reorder-events\">\n\"before:reorder\" / \"reorder\" events</h3>\n<p>When <code>reorderOnSort</code> is set to <code>true</code>, these events are firedrespectfully just prior/just after the reordering of the collection.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.CollectionView.extend({...});\n\n<span class=\"hljs-keyword\">var</span> myCol = <span class=\"hljs-keyword\">new</span> Backbone.Collection({ comparator: ... })\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView({ reorderOnSort: <span class=\"hljs-literal\">true</span> });\nmyView.render();\nmyCol.comparator = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.get(<span class=\"hljs-string\">'foo'</span>); };\n\nmyView.on(<span class=\"hljs-string\">\"before:reorder\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  alert(<span class=\"hljs-string\">\"the collection view is about to be reordered\"</span>);\n});\n\nmyView.on(<span class=\"hljs-string\">\"reorder\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  alert(<span class=\"hljs-string\">\"the collection view has been reordered following its collection\"</span>);\n});\n\nmyCol.sort()\n</pre> <h3 id=\"beforedestroy-event\">\n\"before:destroy\" event</h3>\n<p>Triggered just before destroying the view. A \"before:destroy:collection\" /<code>onBeforeDestroyCollection</code> event will also be fired</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.CollectionView.extend({...});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n\nmyView.on(<span class=\"hljs-string\">\"before:destroy:collection\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  alert(<span class=\"hljs-string\">\"the collection view is about to be destroyed\"</span>);\n});\n\nmyView.destroy();\n</pre> <h3 id=\"destroy--destroycollection-event\">\n\"destroy\" / \"destroy:collection\" event</h3>\n<p>Triggered just after destroying the view, both with correspondingmethod calls.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.CollectionView.extend({...});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n\nmyView.on(<span class=\"hljs-string\">\"destroy:collection\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  alert(<span class=\"hljs-string\">\"the collection view is now destroyed\"</span>);\n});\n\nmyView.destroy();\n</pre> <h3 id=\"beforeaddchild--addchild-event\">\n\"before:add:child\" / \"add:child\" event</h3>\n<p>The \"before:add:child\" event and corresponding <code>onBeforeAddChild</code>method are triggered just after creating a new <code>childView</code> instance fora child that was added to the collection, but before theview is rendered and added to the DOM.</p> <p>The \"add:child\" event and corresponding <code>onAddChild</code>method are triggered after rendering the view and adding it to theview's DOM element.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyCV = Marionette.CollectionView.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  onBeforeAddChild: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// ...</span>\n  },\n\n  onAddChild: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// ...</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> MyCV({...});\n\ncv.on(<span class=\"hljs-string\">\"before:add:child\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(viewInstance)</span></span>{\n  <span class=\"hljs-comment\">// ...</span>\n});\n\ncv.on(<span class=\"hljs-string\">\"add:child\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(viewInstance)</span></span>{\n  <span class=\"hljs-comment\">// ...</span>\n});\n</pre> <h3 id=\"beforeremovechild\">\n\"before:remove:child\"</h3>\n<p>This is triggered after the childView instance has beenremoved from the collection, but before it has been destroyed.</p> <pre data-language=\"js\">cv.on(<span class=\"hljs-string\">\"before:remove:child\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span></span>{\n  <span class=\"hljs-comment\">// ...</span>\n});\n</pre> <h3 id=\"removechild-event\">\n\"remove:child\" event</h3>\n<p>Triggered after a childView instance has been destroyed andremoved, when its child was deleted or removed from thecollection.</p> <pre data-language=\"js\">cv.on(<span class=\"hljs-string\">\"remove:child\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(viewInstance)</span></span>{\n  <span class=\"hljs-comment\">// ...</span>\n});\n</pre> <h3 id=\"childview-event-bubbling-from-child-views\">\n\"childview:*\" event bubbling from child views</h3>\n<p>When a child view within a collection view triggers anevent, that event will bubble up through the parentcollection view with \"childview:\" prepended to the eventname.</p> <p>That is, if a child view triggers \"do:something\", theparent collection view will then trigger \"childview:do:something\".</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// set up basic collection</span>\n<span class=\"hljs-keyword\">var</span> myModel = <span class=\"hljs-keyword\">new</span> MyModel();\n<span class=\"hljs-keyword\">var</span> myCollection = <span class=\"hljs-keyword\">new</span> MyCollection();\nmyCollection.add(myModel);\n\n<span class=\"hljs-keyword\">var</span> MyItemView = Marionette.ItemView.extend({\n  triggers: {\n    <span class=\"hljs-string\">'click button'</span>: <span class=\"hljs-string\">'do:something'</span>\n  }\n});\n\n<span class=\"hljs-comment\">// get the collection view in place</span>\n<span class=\"hljs-keyword\">var</span> colView = <span class=\"hljs-keyword\">new</span> CollectionView({\n  collection: myCollection,\n  childView: MyItemView,\n\n  onChildviewDoSomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    alert(<span class=\"hljs-string\">\"I said, 'do something!'\"</span>);\n  }\n});\ncolView.render();\n</pre> <p>Now, whenever the button inside the attached childView is clicked, an alert boxwill appear that says: I said, 'do something!'</p> <p>It's also possible to attach the event manually using the usual<code>view.on('childview:do:something')</code>.</p> <h3 id=\"beforerendercollection-event\">\nbefore:render:collection event</h3>\n<p>The <code>before:render:collection</code> event is triggered before the <code>collectionView</code>'s children have been rendered and buffered. It differs from the <code>collectionsView</code>'s <code>before:render</code> in that it is <strong>only</strong> emitted if the <code>collection</code> is not empty.</p> <h3 id=\"rendercollection-event\">\nrender:collection event</h3>\n<p>The <code>render:collection</code> event is triggered after a <code>collectionView</code>'s children have been rendered and buffered. It differs from the <code>collectionViews</code>'s <code>render</code> event in that it happens <strong>only</strong> if the <code>collection</code> is not empty.</p> <h2 id=\"collectionview-child-view-events\">\nCollectionView Child View Events</h2>\n<p>The following events are raised on child views during rendering and destruction of child views, which is consistent with the view lifecycle experienced during <code>Region#show</code>.</p> <ul> <li>\n<code>before:render</code> / <code>onBeforeRender</code> - Called before the view is rendered.</li> <li>\n<code>render</code> / <code>onRender</code> - Called after the view is rendered, but before it is attached to the DOM.</li> <li>\n<code>before:show</code> / <code>onBeforeShow</code> - Called after the view has been rendered, but before it has been bound to the CollectionView.</li> <li>\n<code>before:attach</code> / <code>onBeforeAttach</code> - Called before the view is attached to the DOM. This will not fire if the CollectionView itself is not attached.</li> <li>\n<code>attach</code> / <code>onAttach</code> - Called after the view is attached to the DOM. This will not fire if the CollectionView itself is not attached.</li> <li>\n<code>show</code> / <code>onShow</code> - Called when the view has been rendered and bound to the CollectionView.</li> <li>\n<code>dom:refresh</code> / <code>onDomRefresh</code> - Called when the view is both rendered and shown, but only if it is attached to the DOM. This will not fire if the CollectionView itself is not attached.</li> <li>\n<code>before:destroy</code> / <code>onBeforeDestroy</code> - Called before destroying a view.</li> <li>\n<code>destroy</code> / <code>onDestroy</code> - Called after destroying a view.</li> </ul> <p>Note: <code>render</code>, <code>destroy</code>, and <code>dom:refresh</code> are triggered on pure Backbone Views during child view rendering, but for a complete implementation of these events the Backbone View should fire <code>render</code> within <code>render()</code> and <code>destroy</code> within <code>remove()</code> as well as set the following flags:</p> <pre data-language=\"js\">view.supportsRenderLifecycle = <span class=\"hljs-literal\">true</span>;\nview.supportsDestroyLifecycle = <span class=\"hljs-literal\">true</span>;\n</pre> <h2 id=\"collectionview-render\">\nCollectionView render</h2>\n<p>The <code>render</code> method of the collection view is responsible forrendering the entire collection. It loops through each of thechildren in the collection and renders them individually as an<code>childView</code>.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyCollectionView = Marionette.CollectionView.extend({...});\n\n<span class=\"hljs-comment\">// all of the children views will now be rendered.</span>\n<span class=\"hljs-keyword\">new</span> MyCollectionView().render();\n</pre> <h2 id=\"collectionview-automatic-rendering\">\nCollectionView: Automatic Rendering</h2>\n<p>After the initial render the collection view binds to the \"add\", \"remove\" and \"reset\" events of thecollection that is specified.</p> <p>When the collection for the view is \"reset\", the view will call <code>render</code> onitself and re-render the entire collection.</p> <p>When a model is added to the collection, the collection view will render thatone model in to the collection of child views.</p> <p>When a model is removed from a collection (or destroyed / deleted), the collectionview will destroy and remove that model's child view.</p> <p>When the collection for the view is sorted, the view will automatically re-sort its child views.if the <code>reorderOnSort</code> option is set it will attempt to reorder the DOM and do this without a full re-render, otherwise it will re-render if the order has changed. Please Note that if you apply a filter to the collection view and the filtered views change during a sort then it will always re-render.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> collection = <span class=\"hljs-keyword\">new</span> Backbone.Collection();\n\n<span class=\"hljs-keyword\">var</span> myChildView = Marionette.View.extend({\n  template: <span class=\"hljs-literal\">false</span>\n});\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Marionette.CollectionView.extend({\n  childView: myChildView,\n  collection: collection,\n});\n\n<span class=\"hljs-keyword\">var</span> myCollectionView = <span class=\"hljs-keyword\">new</span> MyCollectionView();\n\n<span class=\"hljs-comment\">// Collection view will not re-render as it has not been rendered</span>\ncollection.reset([{foo: <span class=\"hljs-string\">'foo'</span>}]);\n\nmyCollectionView.render();\n\n<span class=\"hljs-comment\">// Collection view will re-render displaying the new model</span>\ncollection.reset([{foo: <span class=\"hljs-string\">'bar'</span>}]);\n</pre> <h2 id=\"collectionview-re-render-collection\">\nCollectionView: Re-render Collection</h2>\n<p>If you need to re-render the entire collection, you can call the<code>view.render</code> method. This method takes care of destroying all ofthe child views that may have previously been opened.</p> <h2 id=\"collectionviews-attachhtml\">\nCollectionView's attachHtml</h2>\n<p>By default the collection view will append the HTML of each ChildViewinto the element buffer, and then call jQuery's <code>.append</code> once at theend to move the HTML into the collection view's <code>el</code>.</p> <p>You can override this by specifying an <code>attachHtml</code> method in yourview definition. This method takes three parameters and has no returnvalue.</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n\n    <span class=\"hljs-comment\">// The default implementation:</span>\n  attachHtml: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(collectionView, childView, index)</span></span>{\n    <span class=\"hljs-keyword\">if</span> (collectionView.isBuffering) {\n      <span class=\"hljs-comment\">// buffering happens on reset events and initial renders</span>\n      <span class=\"hljs-comment\">// in order to reduce the number of inserts into the</span>\n      <span class=\"hljs-comment\">// document, which are expensive.</span>\n      collectionView._bufferedChildren.splice(index, <span class=\"hljs-number\">0</span>, childView);\n    }\n    <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// If we've already rendered the main collection, append</span>\n      <span class=\"hljs-comment\">// the new child into the correct order if we need to. Otherwise</span>\n      <span class=\"hljs-comment\">// append to the end.</span>\n      <span class=\"hljs-keyword\">if</span> (!collectionView._insertBefore(childView, index)){\n        collectionView._insertAfter(childView);\n      }\n    }\n  },\n\n  <span class=\"hljs-comment\">// Called after all children have been appended into the elBuffer</span>\n  attachBuffer: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(collectionView, buffer)</span> </span>{\n    collectionView.$el.append(buffer);\n  },\n\n  <span class=\"hljs-comment\">// called on initialize and after attachBuffer is called</span>\n  initRenderBuffer: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.elBuffer = <span class=\"hljs-built_in\">document</span>.createDocumentFragment();\n  }\n\n});\n</pre> <p>The first parameter is the instance of the collection view thatwill receive the HTML from the second parameter, the current childview instance.</p> <p>The third parameter, <code>index</code>, is the index of themodel that this <code>childView</code> instance represents, in the collectionthat the model came from. This is useful for sorting a collectionand displaying the sorted list in the correct order on the screen.</p> <p>Overrides of <code>attachHtml</code> that don't take into account the elementbuffer will work fine, but won't take advantage of the 60x performanceincrease the buffer provides.</p> <h2 id=\"collectionviews-resortview\">\nCollectionView's resortView</h2>\n<p>By default the <code>CollectionView</code> will maintain the order of its <code>collection</code>in the DOM. However on occasions the view may need to re-render to make thispossible, for example if you were to change the comparator on the collection.By default <code>CollectionView</code> will call <code>render</code> when this happens, but there arecases where this may not be suitable. For instance when sorting the <code>children</code>in a <code>CompositeView</code>, you want to only render the internal collection.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> Marionette.CollectionView({\n  collection: someCollection,\n  resortView: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// provide custom logic for rendering after sorting the collection</span>\n  }\n});\n</pre> <h2 id=\"collectionviews-viewcomparator\">\nCollectionView's viewComparator</h2>\n<p>CollectionView allows for a custom <code>viewComparator</code> option if you want your CollectionView's children to be rendered with a different sort order than the underlying Backbone collection uses.</p> <pre data-language=\"js\">  <span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> Marionette.CollectionView({\n    collection: someCollection,\n    viewComparator: <span class=\"hljs-string\">'otherFieldToSortOn'</span>\n  });\n</pre> <p>The <code>viewComparator</code> can take any of the acceptable <code>Backbone.Collection</code> <a href=\"http://backbonejs.org/#Collection-comparator\">comparator formats</a> -- a sortBy (pass a function that takes a single argument), as a sort (pass a comparator function that expects two arguments), or as a string indicating the attribute to sort by.</p> <h2 id=\"collectionviews-filter\">\nCollectionView's <code>filter</code>\n</h2>\n<p>CollectionView allows for a custom <code>filter</code> option if you want to prevent some of theunderlying <code>collection</code>'s models from being rendered as child views.The filter function takes a model from the collection and returns a truthy value if the child should be rendered,and a falsey value if it should not.</p> <pre data-language=\"js\">  <span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> Marionette.CollectionView({\n    childView: SomeChildView,\n    emptyView: SomeEmptyView,\n    collection: <span class=\"hljs-keyword\">new</span> Backbone.Collection([\n      { value: <span class=\"hljs-number\">1</span> },\n      { value: <span class=\"hljs-number\">2</span> },\n      { value: <span class=\"hljs-number\">3</span> },\n      { value: <span class=\"hljs-number\">4</span> }\n    ]),\n\n    <span class=\"hljs-comment\">// Only show views with even values</span>\n    filter: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(child, index, collection)</span> </span>{\n      <span class=\"hljs-keyword\">return</span> child.get(<span class=\"hljs-string\">'value'</span>) % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>;\n    }\n  });\n\n  <span class=\"hljs-comment\">// renders the views with values '2' and '4'</span>\n  cv.render();\n\n  <span class=\"hljs-comment\">// change the filter</span>\n  cv.filter = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(child, index, collection)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> child.get(<span class=\"hljs-string\">'value'</span>) % <span class=\"hljs-number\">2</span> !== <span class=\"hljs-number\">0</span>;\n  };\n\n  <span class=\"hljs-comment\">// renders the views with values '1' and '3'</span>\n  cv.render();\n\n  <span class=\"hljs-comment\">// remove the filter</span>\n  <span class=\"hljs-comment\">// note that using `delete cv.filter` will cause the prototype's filter to be used</span>\n  <span class=\"hljs-comment\">// which may be undesirable</span>\n  cv.filter = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-comment\">// renders all views</span>\n  cv.render();\n</pre> <h2 id=\"collectionviews-children\">\nCollectionView's children</h2>\n<p>The CollectionView uses <a href=\"https://github.com/marionettejs/backbone.babysitter\">Backbone.BabySitter</a>to store and manage its child views. This allows you to easily accessthe views within the collection view, iterate them, find them bya given indexer such as the view's model or collection, and more.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> Marionette.CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\n\n<span class=\"hljs-comment\">// retrieve a view by model</span>\n<span class=\"hljs-keyword\">var</span> v = cv.children.findByModel(someModel);\n\n<span class=\"hljs-comment\">// iterate over all of the views and process them</span>\ncv.children.each(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view)</span></span>{\n\n  <span class=\"hljs-comment\">// process the `view` here</span>\n\n});\n</pre> <p>For more information on the available features and functionality ofthe <code>.children</code>, see the <a href=\"https://github.com/marionettejs/backbone.babysitter\">Backbone.BabySitter documentation</a>.</p> <h2 id=\"collectionview-destroy\">\nCollectionView destroy</h2>\n<p>CollectionView implements a <code>destroy</code> method, which is called by theregion managers automatically. As part of the implementation, thefollowing are performed:</p> <ul> <li>unbind all <code>listenTo</code> events</li> <li>unbind all custom view events</li> <li>unbind all DOM events</li> <li>unbind all child views that were rendered</li> <li>remove <code>this.el</code> from the DOM</li> <li>call an <code>onDestroy</code> event on the view, if one is provided</li> <li>the <code>CollectionView</code> is returned</li> </ul> <p>By providing an <code>onDestroy</code> event in your view definition, you canrun custom code for your view that is fired after your view has beendestroyed and cleaned up. This lets you handle any additional clean upcode without having to override the <code>destroy</code> method.</p> <pre data-language=\"js\">Marionette.CollectionView.extend({\n  onDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// custom cleanup or destroying code, here</span>\n  }\n});\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.collectionview.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.collectionview.html</a>\n  </p>\n</div>\n","marionette.region":"<h1>\nMarionette.Region</h1>\n<p>Regions provide consistent methods to manage, show and destroyviews in your applications and layouts. They use a jQuery selectorto show your views in the correct place.</p> <p>Using the <code>LayoutView</code> class you can create nested regions.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li>\n<a href=\"#defining-an-application-region\">Defining An Application Region</a><ul> <li><a href=\"#region-configuration-types\">Region Configuration Types</a></li> </ul> </li> <li><a href=\"#initialize-a-region-with-an-el\">Initialize A Region With An <code>el</code></a></li> <li><a href=\"#basic-use\">Basic Use</a></li> <li><a href=\"#showing-a-view\">Showing a view</a></li> <li><a href=\"#checking-whether-a-region-is-showing-a-view\">Checking whether a region is showing a view</a></li> <li><a href=\"#reset-a-region\"><code>reset</code> A Region</a></li> <li><a href=\"#set-how-views-el-is-attached\">Set How View's <code>el</code> Is Attached</a></li> <li>\n<a href=\"#attach-existing-view\">Attach Existing View</a><ul> <li><a href=\"#set-currentview-on-initialization\">Set <code>currentView</code> On Initialization</a></li> <li><a href=\"#call-attachview-on-region\">Call <code>attachView</code> On Region</a></li> </ul> </li> <li>\n<a href=\"#region-events-and-callbacks\">Region Events And Callbacks</a><ul> <li><a href=\"#events-raised-on-the-region-during-show\">Events Raised on the Region During <code>show</code></a></li> <li><a href=\"#events-raised-on-the-view-during-show\">Events Raised on the View During <code>show</code></a></li> <li><a href=\"#example-event-handlers\">Example Event Handlers</a></li> </ul> </li> <li>\n<a href=\"#custom-region-classes\">Custom Region Classes</a><ul> <li><a href=\"#attaching-custom-region-classes\">Attaching Custom Region Classes</a></li> <li><a href=\"#instantiate-your-own-region\">Instantiate Your Own Region</a></li> </ul> </li> </ul> <h2 id=\"defining-an-application-region\">\nDefining An Application Region</h2>\n<p>You can add regions to your applications by calling the <code>addRegions</code> method onyour application instance. This method expects a single hash parameter, withnamed regions and either jQuery selectors or <code>Region</code> objects. You maycall this method as many times as you like, and it will continue adding regionsto the app.</p> <pre data-language=\"js\">MyApp.addRegions({\n  mainRegion: <span class=\"hljs-string\">\"#main-content\"</span>,\n  navigationRegion: <span class=\"hljs-string\">\"#navigation\"</span>\n});\n</pre> <p>As soon as you call <code>addRegions</code>, your regions are available on yourapp object. In the above, example <code>MyApp.mainRegion</code> and <code>MyApp.navigationRegion</code>would be available for use immediately.</p> <p>If you specify the same region name twice, the last one in wins.</p> <p>You can also add regions via <code>LayoutView</code>s:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> AppLayoutView = Marionette.LayoutView.extend({\n  template: <span class=\"hljs-string\">\"#layout-view-template\"</span>,\n\n  regions: {\n    menu: <span class=\"hljs-string\">\"#menu\"</span>,\n    content: <span class=\"hljs-string\">\"#content\"</span>\n  }\n});\n<span class=\"hljs-keyword\">var</span> layoutView = <span class=\"hljs-keyword\">new</span> AppLayoutView();\nlayoutView.render();\n<span class=\"hljs-comment\">// you can access your region by its name</span>\nlayoutView.menu.show(<span class=\"hljs-keyword\">new</span> MenuView());\n<span class=\"hljs-comment\">// also with the getRegion method</span>\nlayoutView.getRegion(<span class=\"hljs-string\">'menu'</span>).show(<span class=\"hljs-keyword\">new</span> MenuView());\n<span class=\"hljs-comment\">// or in this case reference and show it with the showChildView method</span>\nlayoutView.showChildView(<span class=\"hljs-string\">'content'</span>, <span class=\"hljs-keyword\">new</span> MainContentView())\n</pre> <h3 id=\"region-configuration-types\">\nRegion Configuration Types</h3>\n<p>Marionette supports multiple ways to define regions on your <code>Application</code> or <code>LayoutView</code>.</p> <h4>\nString Selector</h4>\n<p>You can use a jQuery string selector to define regions.</p> <pre data-language=\"js\">App.addRegions({\n  mainRegion: <span class=\"hljs-string\">'#main'</span>\n});\n</pre> <h4>\nRegion Class</h4>\n<p>If you've created a custom region class, you can use it todefine your region.</p> <p><strong>NOTE:</strong> Make sure the region class has an <code>el</code>property set or it won't work!</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyRegion = Marionette.Region.extend({\n  el: <span class=\"hljs-string\">'#main-nav'</span>\n});\n\nApp.addRegions({\n  navigationRegion: MyRegion\n});\n</pre> <h4>\nObject Literal</h4>\n<p>Finally, you can define regions with an object literal. Objectliteral definitions normally expect a <code>selector</code> or <code>el</code>property. The <code>selector</code> property is a selector string, andthe <code>el</code> property can be a selector string, a jQuery object,or an HTML node.</p> <p>You may also supply a <code>regionClass</code> property for a custom regionclass. If your <code>regionClass</code> already has <code>el</code> set, then you donot need to supply a <code>selector</code> or <code>el</code> property on the objectliteral.</p> <p>Any other properties you set on the object literal will beused as options passed to the region instance, including the<code>allowMissingEl</code> option.</p> <p>Ordinarily regions enforce the presence of a backing DOM element.In some instances it may be desirable to allow regions to beinstantiated and used without an element, such as when regionsdefined by a parent <code>LayoutView</code> class are used by only some of itssubclasses. In these instances, the region can be defined with the<code>allowMissingEl</code> option, suppressing the missing element error andcausing <code>show</code> calls to the region to be treated as no-ops.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyRegion      = Marionette.Region.extend();\n<span class=\"hljs-keyword\">var</span> MyOtherRegion = Marionette.Region.extend();\n<span class=\"hljs-keyword\">var</span> MyElRegion    = Marionette.Region.extend({ el: <span class=\"hljs-string\">'#footer'</span> });\n\nApp.addRegions({\n  contentRegion: {\n    el: <span class=\"hljs-string\">'#content'</span>,\n    regionClass: MyRegion\n  },\n\n  navigationRegion: {\n    el: <span class=\"hljs-string\">'#navigation'</span>,\n    regionClass: MyOtherRegion,\n\n    <span class=\"hljs-comment\">// Options passed to instance of `MyOtherRegion` for</span>\n    <span class=\"hljs-comment\">// the `navigationRegion` on `App`</span>\n    navigationOption: <span class=\"hljs-number\">42</span>,\n    anotherNavigationOption: <span class=\"hljs-string\">'foo'</span>\n  },\n\n  footerRegion: {\n    regionClass: MyElRegion\n  }\n});\n</pre> <p>Take note that one of the primary benefits of using <code>regionClass</code>with an <code>el</code> already set is to also provide options to the regioninstance. This isn't possible when using the region class directlylike earlier.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyRegion = Marionette.Region.extend({\n  el: <span class=\"hljs-string\">'#content'</span>,\n});\n\nApp.addRegions({\n  contentRegion: {\n    regionClass: MyRegion,\n    myRegionOption: <span class=\"hljs-string\">'bar'</span>,\n    myOtherRegionOption: <span class=\"hljs-string\">'baz'</span>\n  }\n});\n</pre> <h4>\nMix-and-match</h4>\n<p>Of course you can mix-and-match the region configuration types.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> MyRegion = Marionette.Region.extend({\n  el: <span class=\"hljs-string\">'#content'</span>\n});\n\n<span class=\"hljs-keyword\">var</span> MyOtherRegion = Marionette.Region.extend();\n\nApp.addRegions({\n  contentRegion: MyRegion,\n\n  navigationRegion: <span class=\"hljs-string\">'#navigation'</span>,\n\n  footerRegion: {\n    el: <span class=\"hljs-string\">'#footer'</span>,\n    regionClass: MyOtherRegion\n  }\n});\n</pre> <h2 id=\"initialize-a-region-with-an-el\">\nInitialize A Region With An <code>el</code>\n</h2>\n<p>You can specify an <code>el</code> for the region to manage at the timethat the region is instantiated:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> mgr = <span class=\"hljs-keyword\">new</span> Marionette.Region({\n  el: <span class=\"hljs-string\">\"#someElement\"</span>\n});\n</pre> <p>The <code>el</code> option can also be a raw DOM node reference:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> mgr = <span class=\"hljs-keyword\">new</span> Marionette.Region({\n  el: <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">\"body\"</span>)\n});\n</pre> <p>Or the <code>el</code> can also be a <code>jQuery</code> wrapped DOM node:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> mgr = <span class=\"hljs-keyword\">new</span> Marionette.Region({\n  el: $(<span class=\"hljs-string\">\"body\"</span>)\n});\n</pre> <h2 id=\"basic-use\">\nBasic Use</h2>\n<h3 id=\"showing-a-view\">\nShowing a View</h3>\n<p>Once a region is defined, you can call its <code>show</code>and <code>empty</code> methods to display and shut-down a view:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n\n<span class=\"hljs-comment\">// render and display the view</span>\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).show(myView, options);\n\n\n<span class=\"hljs-comment\">// empties the current view</span>\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).empty();\n</pre> <p>The <code>options</code> object is optional. If provided, it will be passed to the <a href=\"#events-raised-on-the-region-during-show\">events raised during <code>show</code></a> (except for <code>before:empty</code> and <code>empty</code>). Special properties that change the behavior of <code>show</code> include <code>preventDestroy</code> and <code>forceShow</code>.</p> <h4>\npreventDestroy</h4>\n<p>If you replace the current view with a new view by calling <code>show</code>,by default it will automatically destroy the previous view.You can prevent this behavior by passing <code>{preventDestroy: true}</code> in the optionsparameter. Several events will also be triggered on the views; see<a href=\"#region-events-and-callbacks\">Region Events And Callbacks</a> for details.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// Show the first view.</span>\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).show(myView);\n\n<span class=\"hljs-comment\">// Replace the view with another. The</span>\n<span class=\"hljs-comment\">// `destroy` method is called for you</span>\n<span class=\"hljs-keyword\">var</span> anotherView = <span class=\"hljs-keyword\">new</span> AnotherView();\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).show(anotherView);\n\n<span class=\"hljs-comment\">// Replace the view with another.</span>\n<span class=\"hljs-comment\">// Prevent `destroy` from being called</span>\n<span class=\"hljs-keyword\">var</span> anotherView2 = <span class=\"hljs-keyword\">new</span> AnotherView();\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).show(anotherView2, { preventDestroy: <span class=\"hljs-literal\">true</span> });\n</pre> <p>NOTE: When using <code>preventDestroy: true</code> you must be careful to cleanup your old viewsmanually to prevent memory leaks.</p> <h4>\nforceShow</h4>\n<p>If you re-call <code>show</code> with the same view, by default nothing will happenbecause the view is already in the region. You can force the view to be re-shownby passing in <code>{forceShow: true}</code> in the options parameter.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).show(myView);\n\n<span class=\"hljs-comment\">// the second show call will re-show the view</span>\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).show(myView, {forceShow: <span class=\"hljs-literal\">true</span>});\n</pre> <h4>\nEmptying a region</h4>\n<p>You can empty a region of its view and contents by invoking <code>.empty()</code> on the region instance.If you would like to prevent the view currently shown in the region from being <code>destroyed</code> you can pass <code>{preventDestroy: true}</code> to the empty method to prevent the default destroy behavior.The empty method returns the region instance from the invocation of the method.</p> <h4>\nonBeforeAttach &amp; onAttach</h4>\n<p>Regions that are attached to the document when you execute <code>show</code> are special in that theviews that they show will also become attached to the document. These regions fire a pair of triggerMethods on <em>all</em>of the views that are about to be attached – even the nested ones. This can cause a performance issue if you'rerendering hundreds or thousands of views at once.</p> <p>If you think these events might be causing some lag in your app, you can selectively turn them offwith the <code>triggerBeforeAttach</code> and <code>triggerAttach</code> properties or <code>show()</code> options.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// No longer trigger attach</span>\nmyRegion.triggerAttach = <span class=\"hljs-literal\">false</span>;\n</pre> <p>You can override this on a per-show basis by passing it in as an option to show.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// This region won't trigger beforeAttach...</span>\nmyRegion.triggerBeforeAttach = <span class=\"hljs-literal\">false</span>;\n\n<span class=\"hljs-comment\">// Unless we tell it to</span>\nmyRegion.show(myView, {triggerBeforeAttach: <span class=\"hljs-literal\">true</span>});\n</pre> <p>Or you can leave the events on by default but disable them for a single show.</p> <pre data-language=\"js\"><span class=\"hljs-comment\">// This region will trigger attach events by default but not for this particular show.</span>\nmyRegion.show(myView, {triggerBeforeAttach: <span class=\"hljs-literal\">false</span>, triggerAttach: <span class=\"hljs-literal\">false</span>});\n</pre> <h3 id=\"checking-whether-a-region-is-showing-a-view\">\nChecking whether a region is showing a view</h3>\n<p>If you wish to check whether a region has a view, you can use the <code>hasView</code>function. This will return a boolean value depending whether or not the regionis showing a view.</p> <h3 id=\"reset-a-region\">\n<code>reset</code> A Region</h3>\n<p>A region can be <code>reset</code> at any time. This destroys any existing viewbeing displayed, and deletes the cached <code>el</code>. The next time theregion shows a view, the region's <code>el</code> is queried fromthe DOM.</p> <pre data-language=\"js\">myRegion.reset();\n</pre> <p>This is useful when regions are re-used across viewinstances, and in unit testing.</p> <h3 id=\"set-how-views-el-is-attached\">\nSet How View's <code>el</code> Is Attached</h3>\n<p>Override the region's <code>attachHtml</code> method to change how the view is attachedto the DOM. This method receives one parameter - the view to show.</p> <p>The default implementation of <code>attachHtml</code> is:</p> <pre data-language=\"js\">Marionette.Region.prototype.attachHtml = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view)</span></span>{\n  <span class=\"hljs-keyword\">this</span>.$el.empty().append(view.el);\n}\n</pre> <p>This replaces the contents of the region with the view's<code>el</code> / content. You can override <code>attachHtml</code> for transition effects and more.</p> <pre data-language=\"js\">Marionette.Region.prototype.attachHtml = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view)</span></span>{\n  <span class=\"hljs-keyword\">this</span>.$el.hide();\n  <span class=\"hljs-keyword\">this</span>.$el.html(view.el);\n  <span class=\"hljs-keyword\">this</span>.$el.slideDown(<span class=\"hljs-string\">\"fast\"</span>);\n}\n</pre> <p>It is also possible to define a custom render method for a single region byextending from the Region class and including a custom attachHtml method.</p> <p>This example will make a view slide down from the top of the screen instead of justappearing in place:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> ModalRegion = Marionette.Region.extend({\n  attachHtml: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view)</span></span>{\n    <span class=\"hljs-comment\">// Some effect to show the view:</span>\n    <span class=\"hljs-keyword\">this</span>.$el.empty().append(view.el);\n    <span class=\"hljs-keyword\">this</span>.$el.hide().slideDown(<span class=\"hljs-string\">'fast'</span>);\n  }\n})\n\nMyApp.addRegions({\n  mainRegion: <span class=\"hljs-string\">'#main-region'</span>,\n  modalRegion: {\n    regionClass: ModalRegion,\n    selector: <span class=\"hljs-string\">'#modal-region'</span>\n  }\n})\n</pre> <p>If you are interested in region animations and looking for a performant and more advanced solution, check out <a href=\"https://github.com/maratfakhreev/marionette-animated-region\">marionette-animated-region</a>.</p> <h3 id=\"attach-existing-view\">\nAttach Existing View</h3>\n<p>There are some scenarios where it's desirable to attach an existingview to a region , without rendering or showing the view, andwithout replacing the HTML content of the region. For example, SEO andaccessibility often need HTML to be generated by the server, and progressiveenhancement of the HTML.</p> <p>There are two ways to accomplish this:</p> <ul> <li>set the <code>currentView</code> in the region's constructor</li> <li>call <code>attachView</code> on the region instance</li> </ul> <h4>\nSet <code>currentView</code> On Initialization</h4>\n<pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView({\n  el: $(<span class=\"hljs-string\">\"#existing-view-stuff\"</span>)\n});\n\n<span class=\"hljs-keyword\">var</span> region = <span class=\"hljs-keyword\">new</span> Marionette.Region({\n  el: <span class=\"hljs-string\">\"#content\"</span>,\n  currentView: myView\n});\n</pre> <h4>\nCall <code>attachView</code> On Region</h4>\n<pre data-language=\"js\">MyApp.addRegions({\n  someRegion: <span class=\"hljs-string\">\"#content\"</span>\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView({\n  el: $(<span class=\"hljs-string\">\"#existing-view-stuff\"</span>)\n});\n\nMyApp.getRegion(<span class=\"hljs-string\">'someRegion'</span>).attachView(myView);\n</pre> <h2 id=\"region-events-and-callbacks\">\nRegion Events And Callbacks</h2>\n<p>A region will raise a few events on itself and on the target view when showing and destroying views.</p> <h3 id=\"events-raised-on-the-region-during-show\">\nEvents Raised on the Region During <code>show()</code>\n</h3>\n<ul> <li>\n<code>before:show</code> / <code>onBeforeShow</code> - Called after the view has been rendered, but before its been displayed.</li> <li>\n<code>show</code> / <code>onShow</code> - Called when the view has been rendered and displayed.</li> <li>\n<code>before:swap</code> / <code>onBeforeSwap</code> - Called before a new view is shown. NOTE: this will only be called when a view is being swapped, not when the region is empty.</li> <li>\n<code>swap</code> / <code>onSwap</code> - Called when a new view is shown. NOTE: this will only be called when a view is being swapped, not when the region is empty.</li> <li>\n<code>before:swapOut</code> / <code>onBeforeSwapOut</code> - Called before a new view swapped in. NOTE: this will only be called when a view is being swapped, not when the region is empty.</li> <li>\n<code>swapOut</code> / <code>onSwapOut</code> - Called when a new view swapped in to replace the currently shown view. NOTE: this will only be called when a view is being swapped, not when the region is empty.</li> <li>\n<code>before:empty</code> / <code>onBeforeEmpty</code> - Called before the view has been emptied.</li> <li>\n<code>empty</code> / <code>onEmpty</code> - Called when the view has been emptied.</li> </ul> <h3 id=\"events-raised-on-the-view-during-show\">\nEvents Raised on the View During <code>show()</code>\n</h3>\n<ul> <li>\n<code>before:render</code> / <code>onBeforeRender</code> - Called before the view is rendered.</li> <li>\n<code>render</code> / <code>onRender</code> - Called after the view is rendered, but before it is attached to the DOM.</li> <li>\n<code>before:show</code> / <code>onBeforeShow</code> - Called after the view has been rendered, but before it has been bound to the region.</li> <li>\n<code>before:attach</code> / <code>onBeforeAttach</code> - Called before the view is attached to the DOM. This will not fire if the Region itself is not attached.</li> <li>\n<code>attach</code> / <code>onAttach</code> - Called after the view is attached to the DOM. This will not fire if the Region itself is not attached.</li> <li>\n<code>show</code> / <code>onShow</code> - Called when the view has been rendered and bound to the region.</li> <li>\n<code>dom:refresh</code> / <code>onDomRefresh</code> - Called when the view is both rendered and shown, but only if it is attached to the DOM. This will not fire if the Region itself is not attached.</li> <li>\n<code>before:destroy</code> / <code>onBeforeDestroy</code> - Called before destroying a view.</li> <li>\n<code>destroy</code> / <code>onDestroy</code> - Called after destroying a view.</li> </ul> <p>Note: <code>render</code>, <code>destroy</code>, and <code>dom:refresh</code> are triggered on pure Backbone Views during a show, but for a complete implementation of these events the Backbone View should fire <code>render</code> within <code>render()</code> and <code>destroy</code> within <code>remove()</code> as well as set the following flags:</p> <pre data-language=\"js\">view.supportsRenderLifecycle = <span class=\"hljs-literal\">true</span>;\nview.supportsDestroyLifecycle = <span class=\"hljs-literal\">true</span>;\n</pre> <h3 id=\"example-event-handlers\">\nExample Event Handlers</h3>\n<pre data-language=\"js\">MyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).on(<span class=\"hljs-string\">\"before:show\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span></span>{\n  <span class=\"hljs-comment\">// manipulate the `view` or do something extra</span>\n  <span class=\"hljs-comment\">// with the `region`</span>\n  <span class=\"hljs-comment\">// you also have access to the `options` that were passed to the Region.show call</span>\n});\n\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).on(<span class=\"hljs-string\">\"show\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span></span>{\n  <span class=\"hljs-comment\">// manipulate the `view` or do something extra</span>\n  <span class=\"hljs-comment\">// with the `region`</span>\n  <span class=\"hljs-comment\">// you also have access to the `options` that were passed to the Region.show call</span>\n});\n\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).on(<span class=\"hljs-string\">\"before:swap\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span></span>{\n  <span class=\"hljs-comment\">// manipulate the `view` or do something extra</span>\n  <span class=\"hljs-comment\">// with the `region`</span>\n  <span class=\"hljs-comment\">// you also have access to the `options` that were passed to the Region.show call</span>\n});\n\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).on(<span class=\"hljs-string\">\"swap\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span></span>{\n  <span class=\"hljs-comment\">// manipulate the `view` or do something extra</span>\n  <span class=\"hljs-comment\">// with the `region`</span>\n  <span class=\"hljs-comment\">// you also have access to the `options` that were passed to the Region.show call</span>\n});\n\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).on(<span class=\"hljs-string\">\"before:swapOut\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span></span>{\n  <span class=\"hljs-comment\">// manipulate the `view` or do something extra</span>\n  <span class=\"hljs-comment\">// with the `region`</span>\n  <span class=\"hljs-comment\">// you also have access to the `options` that were passed to the Region.show call</span>\n});\n\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).on(<span class=\"hljs-string\">\"swapOut\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span></span>{\n  <span class=\"hljs-comment\">// manipulate the `view` or do something extra</span>\n  <span class=\"hljs-comment\">// with the `region`</span>\n  <span class=\"hljs-comment\">// you also have access to the `options` that were passed to the Region.show call</span>\n});\n\nMyApp.getRegion(<span class=\"hljs-string\">'mainRegion'</span>).on(<span class=\"hljs-string\">\"empty\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region)</span></span>{\n  <span class=\"hljs-comment\">// manipulate the `view` or do something extra</span>\n  <span class=\"hljs-comment\">// with the `region`</span>\n});\n\n<span class=\"hljs-keyword\">var</span> MyRegion = Marionette.Region.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  onBeforeShow: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span> </span>{\n    <span class=\"hljs-comment\">// the `view` has not been shown yet</span>\n  },\n\n  onShow: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span></span>{\n    <span class=\"hljs-comment\">// the `view` has been shown</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> MyView = Marionette.ItemView.extend({\n  onBeforeShow: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span> </span>{\n    <span class=\"hljs-comment\">// called before the `view` has been shown</span>\n  },\n  onShow: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span></span>{\n    <span class=\"hljs-comment\">// called when the `view` has been shown</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> MyRegion = Marionette.Region.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  onBeforeSwap: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span> </span>{\n    <span class=\"hljs-comment\">// the `view` has not been swapped yet</span>\n  },\n\n  onSwap: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span></span>{\n    <span class=\"hljs-comment\">// the `view` has been swapped</span>\n  },\n\n  onBeforeSwapOut: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span> </span>{\n    <span class=\"hljs-comment\">// the `view` has not been swapped out yet</span>\n  },\n\n  onSwapOut: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view, region, options)</span></span>{\n    <span class=\"hljs-comment\">// the `view` has been swapped out</span>\n  }\n});\n</pre> <h2 id=\"custom-region-classes\">\nCustom Region Classes</h2>\n<p>You can define a custom region by extending from<code>Region</code>. This allows you to create new functionality,or provide a base set of functionality for your app.</p> <h3 id=\"attaching-custom-region-classes\">\nAttaching Custom Region Classes</h3>\n<p>Once you define a region class, you can attach thenew region class by specifying the region class as thevalue. In this case, <code>addRegions</code> expects the constructor itself, not an instance.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> FooterRegion = Marionette.Region.extend({\n  el: <span class=\"hljs-string\">\"#footer\"</span>\n});\n\nMyApp.addRegions({\n  footerRegion: FooterRegion\n});\n</pre> <p>You can also specify a selector for the region by usingan object literal for the configuration.</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> FooterRegion = Marionette.Region.extend({\n  el: <span class=\"hljs-string\">\"#footer\"</span>\n});\n\nMyApp.addRegions({\n  footerRegion: {\n    selector: <span class=\"hljs-string\">\"#footer\"</span>,\n    regionClass: FooterRegion\n  }\n});\n</pre> <p>Note that a region must have an element to attach itself to. If youdo not specify a selector when attaching the region instance to yourApplication or LayoutView, the region must provide an <code>el</code> either in itsdefinition or constructor options.</p> <h3 id=\"instantiate-your-own-region\">\nInstantiate Your Own Region</h3>\n<p>There may be times when you want to add a region to yourapplication after your app is up and running. To do this, you'llneed to extend from <code>Region</code> as shown above and then usethat constructor function on your own:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> SomeRegion = Marionette.Region.extend({\n  el: <span class=\"hljs-string\">\"#some-div\"</span>,\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n    <span class=\"hljs-comment\">// your init code, here</span>\n  }\n});\n\nMyApp.someRegion = <span class=\"hljs-keyword\">new</span> SomeRegion();\n\nMyApp.getRegion(<span class=\"hljs-string\">'someRegion'</span>).show(someView, options);\n</pre> <p>You can optionally add an <code>initialize</code> function to your Regiondefinition as shown in this example. It receives the <code>options</code>that were passed to the constructor of the Region, similar toa Backbone.View.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.region.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.region.html</a>\n  </p>\n</div>\n","marionette.configuration":"<h1>\nMarionette Configuration</h1>\n<p>Marionette has a few globally configurable settings that willchange how the system works. While many of these subjects are coveredin other docs, this configuration doc should provide a list of themost common items to change.</p> <h2 id=\"marionettedeferred\">\nMarionette.Deferred</h2>\n<blockquote> <p>Warning: deprecated</p> <p>This feature is deprecated, and is scheduled to be removed in version 3 of Marionette. It is used to configure<code>Marionette.Callbacks</code>, which is also deprecated and scheduled to be removed in version 3. Instead of proxyingthe <code>Deferred</code> property on Marionette, use the native <code>Promise</code> object directly, and include a polyfill such as<a href=\"https://github.com/jakearchibald/es6-promise\">https://github.com/jakearchibald/es6-promise</a> if you are supporting older browsers. <code>$.Deferred</code> can also be used, butit is not compliant with the ES6 Promise and is not recommended.</p> </blockquote> <p>By default, Marionette makes use of <code>Backbone.$.Deferred</code> to createthenable objects.</p> <h3 id=\"overriding-marionettedeferred\">\nOverriding Marionette.Deferred</h3>\n<p>If you are using Marionette without jQuery you must first shim <code>Backbone.$.Deferred</code> with a following object that adheres to these properties:</p> <ol> <li>\n<code>promise</code>: a Promises/A+ thenable, or a function that returns one</li> <li>\n<code>resolve</code>: a function that resolves the provided promise with a value</li> </ol> <p>For example:</p> <pre data-language=\"js\"><span class=\"hljs-keyword\">var</span> deferred = Marionette.Deferred();\n\n_.result(deferred, <span class=\"hljs-string\">'promise'</span>).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(target)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Hello, \"</span> + target + <span class=\"hljs-string\">\"!\"</span>);\n});\n\ndeferred.resolve(<span class=\"hljs-string\">\"world\"</span>); <span class=\"hljs-comment\">// asynchronous \"Hello, world!\"</span>\n</pre> <p>If you wish to use a specific promise library, you can override the default via:</p> <pre data-language=\"js\">Marionette.Deferred = myDeferredLib;\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v2.4.7/marionette.configuration.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v2.4.7/marionette.configuration.html</a>\n  </p>\n</div>\n"}