{"index":"<h1>Flow Documentation</h1>    <p>Flow is a <strong>static type checker</strong> for JavaScript. It can be used to catch common bugs in JavaScript programs before they run, including:</p> <ul> <li>silent type conversions,</li> <li>\n<code>null</code> dereferences,</li> <li>and the dreaded <code>undefined is not a function</code>.</li> </ul> <p>Flow also powers advanced features for editors, including <a href=\"https://github.com/flowtype/vim-flow\">Vim</a>, <a href=\"https://github.com/facebook/flow/blob/master/flow-types.el\">Emacs</a>, and <a href=\"http://nuclide.io/docs/languages/flow/\">Nuclide</a>.</p> <h2>Gradual</h2> <p>Flow's type checking is opt-in, which means you can gradually convert your existing JavaScript codebase to Flow while reaping incremental benefits. You don't need to rewrite your existing codebase to start using Flow.</p> <p>You can opt-in on a per file basis by simply adding a <code>/* @flow */</code> comment to the top of your source file. Flow uses type inference to find errors without further guidance. You can add type assertions by <a href=\"syntax\">annotating your program</a> with types.</p> <h2>Idiomatic</h2> <p>Flow is designed for JavaScript programmers. Writing code with Flow should feel like writing JavaScript, from the common idioms in the language to the fast development cycle.</p> <p>Most JavaScript code is \"boring.\" Boring is good! Boring code is easy to read and understand for humans and computers alike. Flow is particularly well suited to code like this, but that's not all Flow can do.</p> <p>JavaScript also provides powerful tools for metaprogramming that traditional statically typed languages lack. Flow is designed to understand even very dynamic code which is often found in JavaScript programs.</p> <p>We're constantly improving Flow to understand more and more JavaScript, but if you need it, the <a href=\"builtins#any\"><code>any</code> type</a> lets you opt-out of type checking in a granular way, so you can keep writing JavaScript the way JavaScript was meant to be written.</p> <h2>Fast</h2> <p>When you start Flow, it performs an initial analysis of all the files in your codebase and stores the results in a persistent server. When you save a file, Flow incrementally rechecks the changes in the background.</p> <p>Both the initial analysis and recheck are heavily optimized for performance, which preserves the fast feedback of developing plain JavaScript.</p> <p>In short, you don't need to wait for Flow to check your code.</p> <h2>Safe</h2> <p>Flow uses control flow analysis to deeply understand your code to find errors that other type systems can't. Flow is designed to find errors and we take soundness seriously.</p> <p>For example, Flow tracks <code>null</code> values which may propagate unintentionally through code and eventually cause a runtime error. Flow's path sensitive analysis can uncover bugs like this, even through layers of indirection in the program's control flow.</p> <h2>Powerful</h2> <p>The type system has a rich and rapidly expanding feature set that allows it to understand common JavaScript idioms, even when annotations are absent through type inference.</p> <p>In addition to inference, Flow also provides an expressive type language, covering the JavaScript core language and standard libraries found in browsers and platforms like Node.js.</p>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/about-flow.html\" class=\"_attribution-link\">http://flowtype.org/docs/about-flow.html</a>\n  </p>\n</div>\n","getting-started":"<h1> Getting started with Flow </h1>    <p>To demonstrate how to add Flow to a project, let's set up an example npm project.</p> <p>First, we'll make an npm package for our example project called \"get_started\":</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; mkdir -p get_started\n$&gt; cd get_started\n$&gt; echo '{\"name\": \"get_started\", \"scripts\": {\"flow\": \"flow; test $? -eq 0 -o $? -eq 2\"}}' &gt; package.json\n</pre> <p>Next we'll add Flow to our project:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; touch .flowconfig\n$&gt; npm install --save-dev flow-bin\n</pre> <p>And now we can start writing some code!</p> <p><strong>index.js</strong></p> <pre class=\"highlight\" data-language=\"js\">// @flow\n\nvar str = 'hello world!';\nconsole.log(str);</pre> <p>Note that we've added <code>// @flow</code> to the top of our file. This indicates to Flow that we want this file to be checked. <strong>If we don't add this flag to the top of the file, Flow will assume that the file isn't ready to be checked yet and Flow will not attempt to type check the file.</strong></p> <p>Ok, now let's run Flow and see what it has to say about the code we just wrote:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; npm run-script flow\n\n&gt; test@ flow /get_started\n&gt; flow\n\nNo errors!\n</pre> <p>Woohoo! No errors! Ok, now let's add a trivial type error just to see what happens:</p> <p><strong>index.js</strong></p> <pre class=\"highlight\" data-language=\"js\">// @flow\n\nvar str: number = 'hello world!';\nconsole.log(str);</pre> <pre class=\"highlight\" data-language=\"bash\">  $&gt; npm run-script flow\n\n  &gt; test@ flow /get_started\n  &gt; flow 2&gt; /dev/null\n\n  index.js:3\n    3: let str: number = 'hello world!';\n                         ^^^^^^^^^^^^^^ string. This type is incompatible with\n    3: let str: number = 'hello world!';\n                ^^^^^^ number\n\n\n  Found 1 error\n</pre> <p>Cool -- Flow noticed that we're assigning a string to a number and gave an error.</p> <p>Before we fix this type error, let's add Babel to our project so we can try running our code:</p> <pre class=\"highlight\" data-language=\"bash\">  $&gt; npm install -g babel-cli\n  $&gt; npm install --save-dev babel-plugin-transform-flow-strip-types\n  $&gt; echo '{\"plugins\": [\"transform-flow-strip-types\"]}' &gt; .babelrc\n</pre> <p>Now we can try running our code <em>in spite</em> of the type error and see what happens:</p> <pre class=\"highlight\" data-language=\"bash\">  $&gt; babel-node index.js\n  hello world!\n</pre> <p>It works! As you can see Flow does not prevent you from running the code you have written even if there are type errors. It is considered best practice to never publish your project when it has type errors, but often at development time it's useful to try running code even before it fully typechecks (usually for debugging or ad-hoc testing). This is one of the benefits of gradual typing and Flow is designed to support this and stay out of your way as much as you need it to during development.</p> <p>Note that we ran our code using <code>babel-node</code> rather than just vanilla <code>node</code> to run index.js. <a href=\"https://babeljs.io/docs/usage/cli/#babel-node\"><code>babel-node</code></a> comes with <code>babel-cli</code> and is just a thin wrapper around vanilla <code>node</code> that first intercepts and transpiles JS code before running it with <code>node</code>.</p> <p>Check out the <a href=\"running\">Running Flow Code</a> section for more details on how we recommend compiling and publishing Flow code to npm and into production.</p> <h3>Next steps</h3> <p>Now that we know how to set Flow up, let's take a quick look at <a href=\"five-simple-examples\">a few examples</a> that are <a href=\"https://github.com/facebook/flow/tree/master/examples\">included in the Flow repo</a>:</p> <ol> <li><a href=\"five-simple-examples#1-hello-flow\">Hello Flow!</a></li> <li><a href=\"five-simple-examples#2-adding-type-annotations\">Adding type annotations</a></li> <li><a href=\"five-simple-examples#3-nullable-types\">Nullable types</a></li> <li><a href=\"five-simple-examples#4-arrays\">Arrays</a></li> <li><a href=\"five-simple-examples#5-dynamic-code\">Dynamic code</a></li> </ol>   <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/getting-started.html\" class=\"_attribution-link\">http://flowtype.org/docs/getting-started.html</a>\n  </p>\n</div>\n","new-project":"<h1> Starting a new Flow project </h1>    <p>One of the most powerful ways to use Flow is to have it checking your code from the first line you write. This allows you to ensure type safety from the very beginning and reduce the likelihood of errors, even while prototyping.</p> <h2>Setting up your project</h2> <p>To set up a new project using Flow, all you need to do is initialize the root of the folder to tell Flow to start typechecking files within your project:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; mkdir new_project\n$&gt; cd new_project\n$&gt; flow init\n</pre> <p>All this actually does is create a hidden file <code>.flowconfig</code> at the root of the folder. You might have noticed that this file was already present in each of the examples we looked at earlier.</p> <p>Once the <code>.flowconfig</code> file is present, you can run ad-hoc checks on the code within it and its subfolders:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; flow check\n</pre> <p>Although this works, it is <strong>not the most efficient</strong> way to use Flow. This command causes flow to re-check the entire project's file structure every time. Instead, we recommend you use the flow server:</p> <h2>Using the Flow server</h2> <p>For a large project, you probably only want Flow to recheck files incrementally when they change. Flow uses a client/server architecture which allows you to start a Flow server that will run in the background and type check files as they change. To do this simply run:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; flow   # This starts a server and prints the initial type check results\n</pre> <p>You can then check the status of the server again later with the same command:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; flow   # Connect to the running server and print the type check results\n</pre> <p>And once you've changed some files, you can quickly run it again to see the current state of the type check results:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; flow   # Connect to server (or start one) and print type check results\n</pre> <p>Using the <code>flow</code> command with a running server reduces the overhead of having to re-check all files in the project each time you make a change. This allows for a much faster incremental workflow - not to mention a better integration with IDEs and other tools.</p> <p>When you've finished working on your code, you can shutdown the server:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; flow stop\n</pre> <h2>Typechecking your files</h2> <p>As with all the examples in the Flow tutorial, you need to add</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\n</pre> <p>to the top of each file you'd like Flow to typecheck. You don't have to do this for all files at once, since Flow will just ignore files that do not have this comment. This allows you to convert your project progressively, one file at a time, and get the benefit of typing gradually. No need to convert your whole project at once.</p> <p>It is possible to indicate on the command line that you would like Flow to check all JavaScript files, regardless of whether they have the <code>/* @flow */</code> declaration at the top. To do this, use the <code>--all</code> flag:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; flow check --all\n</pre> <p>However, use this command cautiously, particularly if you are running Flow against a large existing project or a project with many large third party frameworks or test suites. The chances are that the checker will find a <em>lot</em> of errors or hazards, and it can be a little overwhelming!</p> <p>A more valuable approach to converting an existing project is to incrementally check - and fix - the project one file at a time. When you're ready to convert a file, simply add the <code>/* @flow */</code> declaration at the top of the file and run the <code>flow</code> command to see if any errors were discovered.</p> <p>Read more about testing existing libraries or code in the <a href=\"existing\">Running Flow on existing code</a> section of this guide.</p> <h2>Common Issues</h2> <p>As Flow starts to typecheck your files you may run into type errors. Check out the <a href=\"troubleshooting\">Troubleshooting</a> section for common errors and how to resolve them. Your goal is to get the number of errors down to zero as fast as possible so you can continue on with your development.</p> <p>In some cases, errors may be due to inherent imprecision of the analysis - which means Flow won't always get it right and could give errors that are false positives. In those cases you can either try to refactor your code to help Flow understand it, or you can use the <a href=\"base-types#any\"><code>any</code></a> type to tell Flow about values that should not be checked.</p>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/new-project.html\" class=\"_attribution-link\">http://flowtype.org/docs/new-project.html</a>\n  </p>\n</div>\n","existing":"<h1> Running Flow on existing code </h1>    <h2>A word of warning</h2> <p>Making previously-untyped code typecheck with Flow may take some time and work - and sometimes it may not be worth the effort in the short term. Flow supports <em>interface files</em> so you can use libraries in a typed way without having to run Flow on them at all. If your project just depends on third party libraries, check out our <a href=\"third-party\">guide</a> on using Flow with external dependencies and consider using an interface file for the libraries.</p> <p>Why is typechecking existing code so hard? Libraries not written with types in mind often contain complex, highly dynamic code that confuses analyzers such as Flow. The code may also have been written in a style that Flow deliberately chooses not to support in order to give the programmer more help. Some typical examples are:</p> <ul> <li>Operations on primitive values: While JavaScript allows operations such as <code>true + 3</code>, Flow considers it a type error. This is by design, and is done to provide the programmer with more safety. While that's easily avoided for new code, it can sometimes be a lot of effort to eliminate such patterns from existing code.</li> <li>Nullability: Flow protects you against accessing properties on <code>null</code> by tracking null or undefined values throughout the program. In large existing codebases, though, this can require inserting some extra null checks in places where a value appears like it may be null, but actually isn't at runtime.</li> </ul> <p>It is typically a much larger effort, and requires much more programmer annotation, to get such code to typecheck. On the other hand, if you own a library and would like to benefit from Flow typechecking within the library itself, this guide is for you.</p> <h2>Weak mode</h2> <p>Flow has a special mode, known as <em>weak mode</em>, to get started with complex library code without having to pay the full cost up front. The difference between weak mode and regular mode is how Flow deals with missing type annotations. In regular mode Flow will infer types for all missing annotations, and produce errors whenever it detects a mismatch. In weak mode, Flow will do much less type inference. It will still infer types within functions, but will otherwise treat unannotated variables as having the <a href=\"base-types#any\"><code>any</code></a> type - meaning no typechecking happens on them.</p> <p>A good first step towards typechecking existing library code is to use weak mode, rather than regular mode. Simply change the header declaration in the file you want to typecheck:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow weak */\n</pre> <p>Weak mode can still point out type problems, and likely will, but there will be far fewer and they will be easier to fix. This should give you some benefit straight away without too much work. The typical errors you are likely to run into are:</p> <ul> <li>Potentially <code>null</code> or <code>undefined</code> values, easily fixed by adding conditional checks.</li> <li>Primitive type issues, like <code>true + 3</code>. Fixing these requires more knowledge of the code but is usually a small, local fix.</li> <li>In cases where Flow just doesn't understand the code as written, <a href=\"http://flowtype.org/blog/2015/02/18/Typecasts.html\">explicitly annotating values with <code>any</code></a> can help the typechecker.</li> </ul> <p>Weak mode typically produces a manageable number of errors, so you can get down to zero errors in weak mode with moderate effort.</p> <h2>Next steps</h2> <p>Once your code typechecks with Flow's weak mode, you can start adding type annotations incrementally. Each type annotation you add will allow Flow to validate more code, and you can gradually increase Flow's coverage of your code.</p> <p>Once your code has more type annotations, you can consider switching it over to regular flow mode by switching the comment at the top of the file to</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\n</pre>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/existing.html\" class=\"_attribution-link\">http://flowtype.org/docs/existing.html</a>\n  </p>\n</div>\n","type-aliases":"<h1> Type Aliases </h1>    <p>Flow supports type aliasing. Type aliases are similar to <code>typedef</code>s in C or type abbreviations in OCaml. Type aliasing provides a way to redefine existing types as new type names. For example, type aliases may be used to define names for object types, effectively modeling interface types. </p> <p>Here is a simple example: </p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\ntype T = number;\nvar x: T = 0;\n</pre> <p>We declare the new type <code>T</code> is an alias for the built-in type <code>number</code>. Anywhere we use <code>T</code>, we are asserting that <code>T</code> will have an underlying type of <code>number</code>.</p> <h2>Type Checking Aliases</h2> <p>Aliases are type checked the same way as any other type.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\ntype T = Array&lt;string&gt;;\nvar x: T = [];\nx[\"Hi\"] = 2;\n</pre> <pre class=\"highlight\" data-language=\"bbcode\">/tmp/flow/f.js:4:3,6: string\nThis type is incompatible with\n  /tmp/flow/f.js:4:1,11: number\n\n/tmp/flow/f.js:4:11,11: number\nThis type is incompatible with\n  /tmp/flow/f.js:2:16,21: string\n\nFound 2 errors\n</pre> <p>As you can see, we aliased an <code>Array&lt;string&gt;</code> to a new type called <code>T</code>. And then we tried to assign a <code>number</code> value to a <code>string</code> key in the array. However, that does not comport with how we declared <code>T</code>. Instead, this would work:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\ntype T = Array&lt;string&gt;;\nvar x: T = [];\nx[2] = \"Hi\";\n</pre> <h2>A More Complicated Example</h2> <p>Let's take a look at a more involved example where we use arrow functions in our type aliasing.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\n// Let F&lt;U, V&gt; describe the type of functions of the form\n// function(x: U) { \n//   // return some value compatible with that assigned to V\n// }\ntype F&lt;U, V&gt; = (x: U) =&gt; V;\n\n// The function foo applies a given function f to a given argument x\nfunction foo&lt;X, Y&gt;(f: F&lt;X, Y&gt;, x: X): Y { return f(x); }\nvar b: boolean = true;\nvar result: string = foo (function(x) { return b; }, 0);\n</pre> <p>We alias a function (via the <code>=&gt;</code> syntax), to <code>F&lt;U, V&gt;</code>. So whenever <code>F&lt;U, V&gt;</code> is used as a parameter or return type, that function will be the underlying type.</p> <p>Then we create a function that is parameterized to <code>X</code> and <code>Y</code>. <code>foo()</code> takes as its first parameter our type alias <code>F&lt;X, Y&gt;</code> and as its second parameter a value of type <code>X</code>. We are returning a <code>Y</code> from <code>foo()</code>.</p> <p>When we call <code>foo()</code> we have assigned <code>X</code> to an <code>int</code> (via <code>x</code>) and <code>Y</code> as a <code>boolean</code> (via <code>b</code>). Thus, <code>result</code> is expected to be of type <code>boolean</code>.</p> <p>Since we have <code>result</code> as a <code>string</code>, we get the following error:</p> <pre class=\"highlight\" data-language=\"bbcode\">/tmp/flow/f.js:9:48,48: boolean\nThis type is incompatible with\n  /tmp/flow/f.js:9:13,18: string\n\nFound 1 error\n</pre>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/type-aliases.html\" class=\"_attribution-link\">http://flowtype.org/docs/type-aliases.html</a>\n  </p>\n</div>\n","type-annotations":"<h1> Type Annotations </h1>    <p>JavaScript is inherently a dynamically-typed language. As such, explicitly typing your code is not part of the JavaScript lexicon. This is normal JavaScript code:</p> <pre class=\"highlight\" data-language=\"javascript\">function add(num1, num2) {\n  return num1 + num2;\n}\nvar x = add(3, '0');\nconsole.log(x);\n</pre> <p>What is the value of <code>x</code>? <code>3</code>? <code>\"30\"</code>? <code>undefined</code>? The answer is <code>\"30\"</code>, and, in most cases, this probably not the behavior you would prefer.</p> <p>Flow helps mitigate these sort of subtle bugs by trying to keep your code sane through static analysis and type annotations.</p> <h2>Type Annotations</h2> <p>Type annotations are generally prefixed by <code>:</code>. And they can be placed on function parameters, function return types and variable declarations. e.g.,</p> <pre class=\"highlight\" data-language=\"javascript\">function foo(a: string, b: number): void { ... }\nvar x: boolean = someBool;\nclass Bar {\n  y: string;\n  someMethod(a: number): string { ... }\n}\n</pre> <h2>Simple Example</h2> <p>We can easily take this code and make it Flow aware by adding a simple annotation <code>@flow</code> at the top in a comment block:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nfunction add(num1, num2) {\n  return num1 + num2;\n}\nvar x = add(3, '0');\nconsole.log(x);\n</pre> <p>However, Flow will find no errors with the above code. That's because the <code>+</code> operator is perfectly acceptable on <code>number</code>s and <code>string</code>s, and we didn't specify that the parameters to <code>add</code> must be <code>number</code>s.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nfunction add(num1: number, num2: number): number {\n  return num1 + num2;\n}\nvar x: number = add(3, '0');\nconsole.log(x);\n</pre> <p>Running the type checker against the above code will yield type errors since we have explicitly typed all parameters and variables.</p> <pre class=\"highlight\" data-language=\"bbcode\">file.js:5\n  5: var x: number = add(3, '0');\n                     ^^^^^^^^^^^ function call\n  5: var x: number = add(3, '0');\n                            ^^^ string. This type is incompatible with\n  2: function add(num1: number, num2: number): number {\n                                      ^^^^^^ number\n\n\nFound 1 error\n</pre> <h2>Type Annotation Requirements</h2> <p>Type annotations are not always strictly necessary to use Flow. As shown above, all that is strictly required to make your JavaScript file Flow aware is the <code>@flow</code> annotation. And this annotation by itself can be enough for Flow to deduce all that is necessary to type check your code.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nfunction multPI(num1, num2) {\n  return Math.PI * num1 * num2;\n}\nvar x = multPI(3, '0');\nconsole.log(x);\n</pre> <p>Since the multiplication operator makes no real sense on a string, Flow is smart enough to deduce a problem here without explicit type annotations.</p> <pre class=\"highlight\" data-language=\"bbcode\">file.js:5\n  5: var x = multPI(3, '0');\n             ^^^^^^^^^^^^^^ function call\n  3:   return Math.PI * num1 * num2;\n                               ^^^^ string. This type is incompatible with\n  3:   return Math.PI * num1 * num2;\n              ^^^^^^^^^^^^^^^^^^^^^ number\n\n\nFound 1 error\n</pre> <h3>Module Boundaries</h3> <p>Flow requires annotations at the boundaries of modules. This allows Flow to analyze modules in isolation which improves the performance of checking types across module boundaries. Coincidentally we've found that this helps to improve the self-documenting nature of module interfaces as well</p> <pre class=\"highlight\" data-language=\"javascript\">/**\n * Size.js\n * @flow\n */\nfunction size(input: string): number {\n  return input.length;\n}\n\nmodule.exports = size;\n</pre> <pre class=\"highlight\" data-language=\"javascript\">/**\n * UseSize.js\n * @flow\n */\nvar size = require('./Size');\nvar result = size(null);\n</pre> <p>Type annotations are required for the <code>size</code> function in <code>Size.js</code> because <code>UseSize.js</code> imports it and thus crosses the module boundary and isn't inferred.</p> <pre class=\"highlight\" data-language=\"bbcode\">UseSize.js:6\n  6: var result = size(null);\n                  ^^^^^^^^^^ function call\n  6: var result = size(null);\n                       ^^^^ null. This type is incompatible with\n  5: function size(input: string): number {\n                          ^^^^^^ string. See: Size.js:5\n\n\nFound 1 error\n</pre> <h2>\n<code>any</code> Annotations</h2> <p><code>any</code> is a special type annotation that represents the universal dynamic type. <code>any</code> can flow to any other type, and vice-versa. <code>any</code> is basically the \"get out of my way, I know what I am doing\" annotation. Use it when Flow is getting in your way, but you know your program is correct.</p> <h2>Bottom Line</h2> <p>You can type annotate all your code. That would be the most expressive and self-documenting approach. However, Flow does a lot of type inference for you to alleviate this requirement when it becomes a burden. The only place that you must annotate types is where those types go across module boundaries.</p>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/type-annotations.html\" class=\"_attribution-link\">http://flowtype.org/docs/type-annotations.html</a>\n  </p>\n</div>\n","advanced-configuration":"<h1> Advanced Configuration </h1>    <p>This section discusses some of the advanced configuration options available for customizing how <code>flow</code> runs.</p> <h2><code>.flowconfig</code></h2> <p>Many times it is enough to create an empty <code>.flowconfig</code> file via <code>flow init</code> and just have <code>.flowconfig</code> simply be the token that tells flow to \"start type checking here\".</p> <p>However, <code>.flowconfig</code> does provide some configuration options that can be used to customize what files <code>flow</code> accesses and what files it ignores.</p> <h3><code>[include]</code></h3> <p>The <code>[include]</code> heading in a <code>.flowconfig</code> file tells <code>flow</code> to include the specified files or directories when type checking your code. Including a directory includes all the files under that directory. Each line in the include section is a path to include. These paths can be relative to the root directory or absolute, and support both single and double star wildcards.</p> <p>The root directory (where your <code>.flowconfig</code> lives) is automatically included.</p> <p>For example, if <code>/path/to/root/.flowconfig</code> contains the following <code>[include]</code> section:</p> <pre class=\"highlight\" data-language=\"\">[include]\n../externalFile.js\n../externalDir/\n../otherProject/*.js\n../otherProject/**/coolStuff/\n</pre> <p>then when Flow checks the project in <code>/path/to/root</code>, it will read and watch</p> <ol> <li>\n<code>/path/to/root/</code> (automatically included)</li> <li><code>/path/to/externalFile.js</code></li> <li><code>/path/to/externalDir/</code></li> <li>Any file in <code>/path/to/otherProject/</code> that ends in <code>.js</code>\n</li> <li>Any directory under <code>/path/to/otherProject</code> named <code>coolStuff/</code>\n</li> </ol> <h3><code>[ignore]</code></h3> <p>The <code>[ignore]</code> heading in a <code>.flowconfig</code> file tells <code>flow</code> to ignore files matching the specified regular expressions when type checking your code. By default, nothing is ignored.</p> <p>Things to keep in mind:</p> <ol> <li>These are OCaml regular expressions.</li> <li>These regular expressions match against absolute paths. They probably should start with <code>.*</code>\n</li> <li>Ignores are processed AFTER includes. If you include and ignore a file it will be ignored.</li> </ol> <p>An example <code>[ignore]</code> section might look like</p> <pre class=\"highlight\" data-language=\"\">[ignore]\n.*/__tests__/.*\n.*/src/\\(foo\\|bar\\)/.*\n.*\\.ignore\\.js\n</pre> <p>This <code>[ignore]</code> section will ignore</p> <ol> <li>Any file or directory under a directory named <code>__tests__</code>\n</li> <li>Any file or directory under <code>.*/src/foo</code> or under <code>.*/src/bar</code>\n</li> <li>Any file that ends with the extension <code>.ignore.js</code>\n</li> </ol> <p>Starting with Flow v0.23.0, you may use the <code>&lt;PROJECT_ROOT&gt;</code> placeholder in your regular expressions. At runtime, Flow will treat the placeholder as if it were the absolute path to the project's root directory. This is useful for writing regular expressions that are relative rather than absolute. For example, you can write</p> <pre class=\"highlight\" data-language=\"\">[ignore]\n&lt;PROJECT_ROOT&gt;/__tests__/.*\n</pre> <p>which would ignore any file or directory under the directory named <code>__tests__/</code> within the project root. However, unlike the previous example's <code>.*/__tests__/.*</code>, it would NOT ignore files or directories under other directories named <code>__tests__/</code>, like <code>src/__tests__/</code>.</p> <h3><code>[libs]</code></h3> <p>The <code>[libs]</code> heading in a <code>.flowconfig</code> file tells <code>flow</code> to include the specified <a href=\"declarations\">declarations</a> when type checking your code. Multiple libraries can be specified. By default, no additional libraries are included.</p> <p>Each line in the <code>[libs]</code> section is a path to the lib file or lib directory which you would like to include. These paths can be relative to the root directory or absolute.</p> <h3><code>[options]</code></h3> <p>The <code>[options]</code> heading in a <code>.flowconfig</code> file can contain several key-value pairs. Any options that are omitted will use their default values. Some options can be overridden with command line flags.</p> <ul> <li>\n<code>log.file</code> (string): the path to the log file (defaults to <code>/tmp/flow/&lt;escaped root path&gt;.log</code>)</li> <li>\n<p><code>module.name_mapper</code> (regex -&gt; string): specify a regular expression to match against module names, and a replacement pattern, separated by a <code>-&gt;</code>.</p> <p>For example:</p> <pre class=\"highlight\" data-language=\"\">module.name_mapper= '^image![a-zA-Z0-9$_]+$' -&gt; 'ImageStub'\n</pre> <p>makes Flow treat <code>require('image!foo.jpg')</code> as if it were <code>require('ImageStub')</code>.</p> <p>(<strong>note:</strong> you can specify <code>module.name_mapper</code> multiple times)</p>\n</li> <li>\n<p><code>module.name_mapper.extension</code> (string -&gt; string): specify a file extension to match, and a replacement module name, separated by a <code>-&gt;</code>.</p> <p><em>(Note that this is just shorthand for <code>module.name_mapper='^\\(.\\*\\)\\.EXTENSION$' -&gt; 'TEMPLATE'</code>)</em></p> <p>For example:</p> <pre class=\"highlight\" data-language=\"\">module.name_mapper.extension= 'css' -&gt; '&lt;PROJECT_ROOT&gt;/CSSFlowStub.js.flow'\n</pre> <p>makes Flow treat <code>require('foo.css')</code> as if it were <code>require(PROJECT_ROOT + '/CSSFlowStub')</code>.</p> <p>(<strong>note:</strong> you can specify <code>module.name_mapper.extension</code> multiple times for different extensions)</p>\n</li> <li><p><code>module.system</code> (<code>node</code> | <code>haste</code>): the module system to use to resolve <code>import</code> and <code>require</code>. <a href=\"https://github.com/facebook/node-haste\">Haste</a> is used in React Native. The default is <code>node</code>.</p></li> <li>\n<p><code>module.system.node.resolve_dirname</code> (string): By default, Flow will look in directories named <code>node_modules</code> for node modules. You can configure this behavior with this option. For example, if you do</p> <pre class=\"highlight\" data-language=\"\">[options]\nmodule.system.node.resolve_dirname=node_modules\nmodule.system.node.resolve_dirname=custom_node_modules\n</pre> <p>then Flow will look in directories named <code>node_modules</code> or <code>custom_node_modules</code></p>\n</li> <li><p><code>module.ignore_non_literal_requires</code> (boolean): set this to <code>true</code> and Flow will no longer complain when you use <code>require()</code> with something other than a string literal. The default value is <code>false</code></p></li> <li>\n<p><code>module.file_ext</code> (string): By default, Flow will look for files with the extensions <code>.js</code>, <code>.jsx</code>, and <code>.json</code>. You can override this behavior with this option. For example, if you do</p> <pre class=\"highlight\" data-language=\"\">[options]\nmodule.file_ext=.foo\nmodule.file_ext=.bar\n</pre> <p>then Flow will instead look for the file extensions <code>.foo</code> and <code>.bar</code>.</p>\n</li> <li><p><code>module.use_strict</code> (boolean): set this to <code>true</code> if you use a transpiler that adds <code>\"use strict\";</code> to the top of every module. The default value is <code>false</code>.</p></li> <li><p><code>munge_underscores</code> (boolean): Set this to <code>true</code> to have Flow treat underscore-prefixed class properties and methods as private. This should be used in conjunction with <a href=\"https://github.com/facebook/jstransform/blob/master/visitors/es6-class-visitors.js\"><code>jstransform</code>'s ES6 class transform</a>, which enforces the same privacy at runtime.</p></li> <li><p><code>server.max_workers</code> (integer): The maximum number of workers the Flow server can start. By default, the server will use all available cores.</p></li> <li><p><code>traces</code> (integer): enables traces on all error output (showing additional details about the flow of types through the system), to the depth specified. This can be very expensive, so is disabled by default.</p></li> <li><p><code>strip_root</code> (boolean): set this to <code>true</code> to always strip the root directory from file paths in error messages. Can be overridden with the command line flag <code>--strip-root</code>.</p></li> <li>\n<p><code>suppress_comment</code> (regex): defines a magical comment that suppresses any Flow errors on the following line. For example:</p> <pre class=\"highlight\" data-language=\"\">suppress_comment= \\\\(.\\\\|\\n\\\\)*\\\\$FlowFixMe\n</pre> <p>will match a comment like this:</p> <pre class=\"highlight\" data-language=\"\">// $FlowFixMe: suppressing this error until we can refactor\nvar x : string = 123;\n</pre> <p>and suppress the error. If there is no error on the next line (the suppression is unnecessary), an \"Unused suppression\" error will be shown instead.</p> <p><strong>Note:</strong> you can specify <code>suppress_comment</code> multiple times. We recommend defining something like <code>$FlowFixMe</code> (for type errors that need to be fixed) in addition to <code>$FlowIssue</code> (to suppress errors caused by bugs in Flow).</p>\n</li> <li><p><code>temp_dir</code> (string): Tell Flow which directory to use as a temp directory. Defaults to <code>/tmp/flow</code>. Can be overridden with the commandline flag <code>--temp-dir</code>.</p></li> <li><p><code>esproposal.class_static_fields</code> (<code>enable</code>|<code>ignore</code>|<code>warn</code>): set this to <code>enable</code> to indicate that Flow should interpret static <a href=\"https://github.com/jeffmo/es-class-fields-and-static-properties\">class fields</a> per the pending spec. You may also set this to <code>ignore</code> to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a static property on the class). The default value of this option is <code>warn</code>, which gives a warning on use since this proposal is still very early-stage.</p></li> <li><p><code>esproposal.class_instance_fields</code> (<code>enable</code>|<code>ignore</code>|<code>warn</code>): set this to <code>enable</code> to indicate that Flow should interpret instance <a href=\"https://github.com/jeffmo/es-class-fields-and-static-properties\">class fields</a> per the pending spec. You may also set this to <code>ignore</code> to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a property on instances of the class). The default value of this option is <code>warn</code>, which gives a warning on use since this proposal is still very early-stage.</p></li> <li><p><code>esproposal.decorators</code> (<code>ignore</code>|<code>warn</code>): set this to <code>ignore</code> to indicate that Flow should ignore decorators. The default value of this option is <code>warn</code>, which gives a warning on use since this proposal is still very early-stage.</p></li> <li><p><code>esproposal.export_star_as</code> (<code>enable</code>|<code>ignore</code>|<code>warn</code>): set this to <code>enable</code> to indicate that Flow should support the <code>export * as</code> syntax from <a href=\"https://github.com/leebyron/ecmascript-more-export-from\">leebyron's proposal</a>. You may also set this to <code>ignore</code> to indicate that Flow should simply ignore the syntax. The default value of this option is <code>warn</code>, which gives a warning on use since this proposal is still very early-stage.</p></li> </ul> <h3>[version]</h3> <p>You can specify in the <code>.flowconfig</code> which version of Flow you expect to use. You do this with the <code>[version]</code> section. If this section is omitted or left blank, then any version is allowed. If a version is specified and not matched, then Flow will immediately error and exit.</p> <p>So if you have the following in your .flowconfig</p> <pre class=\"highlight\" data-language=\"\">[version]\n0.22.0\n</pre> <p>and you try to use Flow v0.21.0, then Flow will immediately error with the message</p> <p><code>\"Wrong version of Flow. The config specifies version 0.22.0 but this is version\n0.21.0\"</code></p> <p>So far, we support the following ways to specify supported versions</p> <ul> <li>Explicit versions, (e.g. <code>0.22.0</code>, which only matches <code>0.22.0</code>).</li> <li>Intersection ranges, which are ANDed together, (e.g. <code>&gt;=0.13.0 &lt;0.14.0</code>, which matches <code>0.13.0</code> and <code>0.13.5</code> but not <code>0.14.0</code>).</li> <li>Caret ranges, which allow changes that do not modify the left-most non-zero digit (e.g. <code>^0.13.0</code> expands into <code>&gt;=0.13.0 &lt;0.14.0</code>, and <code>^0.13.1</code> expands into <code>&gt;=0.13.1 &lt;0.14.0</code>, whereas \"^1.2.3\" expands into \"&gt;=1.2.3 &lt;2.0.0\").</li> </ul> <h3>Comments</h3> <p>Comment support was added in v0.23.0. Lines beginning with 0 or more spaces followed by an <code>#</code> or <code>;</code> are ignored. For example:</p> <pre class=\"highlight\" data-language=\"\"># This is a comment\n   # This is a comment\n; This is a comment\n   ; This is a comment\n</pre> <h3>Example</h3> <p>Say you have the following directory structure, with your <code>.flowconfig</code> in <code>mydir</code>:</p> <pre class=\"highlight\" data-language=\"bbcode\">otherdir\n└── src\n    ├── othercode.js\nmydir\n├── .flowconfig\n├── build\n│   ├── first.js\n│   └── shim.js\n├── lib\n│   └── flow\n├── node_modules\n│   └── es6-shim\n└── src\n    ├── first.js\n    └── shim.js\n</pre> <p>Here is an example of how you could use the <code>.flowconfig</code> directives.</p> <pre class=\"highlight\" data-language=\"bbcode\">[include]\n../otherdir/src\n\n[ignore]\n.*/build/.*\n\n[libs]\n./lib\n</pre> <p>Now <code>flow</code> will include a directory outside the <code>.flowconfig</code> path in its check, ignore the <code>build</code> directory and use the declarations in <code>lib</code>.</p>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/advanced-configuration.html\" class=\"_attribution-link\">http://flowtype.org/docs/advanced-configuration.html</a>\n  </p>\n</div>\n","five-simple-examples":"<h1> Five simple examples </h1>    <p>Throughout each of the following examples, we will check our code using the <code>flow</code> CLI. You can install this CLI using <a href=\"http://blog.npmjs.org/post/85484771375/how-to-install-npm\">npm</a> by running <code>npm install --global flow-bin</code>.</p> <p>Note also that the first time you run <code>flow</code> on a given example (or project), it will normally take a few seconds, but subsequent runs are <em>much</em> quicker. This is because running <code>flow</code> will start a process in the background which monitors the project you are working within and incrementally recalculate type errors with each change you save to disk. <strong>If you wish to stop the background Flow process, you can do so with the <code>flow stop</code> command.</strong></p> <p>If you wish to just typecheck a project without a persistent process (and you don't mind waiting a few extra seconds each time) you can use <code>flow check</code>. This will ensure that Flow shuts down immediately after checking your project.</p> <h2>1. Hello Flow!</h2> <p>Inside the Flow GitHub repo, you'll find an <a href=\"https://github.com/facebook/flow/tree/master/examples\"><code>examples</code> directory</a>. This directory contains the examples for this tutorial. To get a feel for Flow, let's look at the first one:</p> <pre class=\"highlight\" data-language=\"bash\">  $&gt; cd flow/examples/01_HelloWorld\n  $&gt; flow\n</pre> <p>You should see an error that looks something like this:</p> <pre class=\"highlight\" data-language=\"bbcode\">  hello.js:7\n    7: foo(\"Hello, world!\");\n       ^^^^^^^^^^^^^^^^^^^^ function call\n    4:   return x * 10;\n                ^ string. This type is incompatible with\n    4:   return x * 10;\n                ^^^^^^ number\n</pre> <p>Looking at the <code>hello.js</code> example file, it's easy to see why:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\n\nfunction foo(x) {\n  return x * 10;\n}\n\nfoo('Hello, world!');</pre> <p>We're calling a function with a string, when that function clearly expects a number. Flow detects this problem and gives an error. One fix for this example would be to call <code>foo</code> with a number instead:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\n\nfunction foo(x) {\n  return x * 10;\n}\n\n// This is fine, because we're passing a number now\nfoo(10);</pre> <p>Throughout this tutorial, you will find solutions for each example in the example's <code>answer</code> directory.</p> <p>You may have noticed this header line in the example file:</p> <pre class=\"highlight\" data-language=\"js\">// @flow</pre> <p>This is important: it tells Flow that this file should be typechecked. <strong>Flow will ignore any files that don't have this header.</strong> This allows you to convert and/or typecheck a JS project one file at a time.</p> <h2>2. Adding type annotations</h2> <p>Flow can infer the type of most things within a file, so you don't always have to annotate every function and variable to get typechecking to work. However, even if Flow can infer a type, you can still add annotations to be explicit. The only time that Flow strictly <em>requires</em> an annotation is when a variable/function/class is exported from a module (defined in one file and used in another).</p> <p>The second example (<code>02_TypeAnnotations</code>) shows usage of some basic type annotations in Flow:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\n\nfunction foo(x: string, y: number): string {\n  return x.length * y;\n}\n\nfoo('Hello', 42);</pre> <p>Here we have annotated the <code>foo</code> function to say that it's two parameters are of type <code>string</code> and <code>number</code> and that it returns a <code>string</code>.</p> <p>With these annotations in place, if we run <code>flow check</code> we'll see an error:</p> <pre class=\"highlight\" data-language=\"bbcode\">type_annotations.js:4\n  4:   return x.length * y;\n              ^^^^^^^^^^^^ number. This type is incompatible with\n  3: function foo(x: string, y: number): string {\n                                         ^^^^^^ string\n</pre> <p>In this case it is the return type for <code>foo</code> that is wrong. Even though we have annotated it as returning a <code>string</code>, the actual type that it returns (a <code>number</code>) does not match! Flow flags this issue and you can fix it by correcting the return type:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\n\n// Changing the return type to number fixes the error\nfunction foo(x: string, y: number): number {\n  return x.length * y;\n}\n\nfoo('Hello', 42);</pre> <h2>3. Nullable types</h2> <p>Flow handles <code>null</code> differently than most type systems. When a type system does not track usage of <code>null</code> carefully, it becomes possible for your program to misleadingly typecheck as correct but still crash when <code>null</code> is accessed in an unsafe way. In Flow, accessing <code>null</code> in an unsafe way will incur an error as shown by our third example (<code>03_Null</code>):</p> <pre class=\"highlight\" data-language=\"js\">// @flow\n\nfunction length(x) {\n  return x.length;\n}\n\nvar total = length('Hello') + length(null);\n</pre> <p>This program would fail at runtime, with a <code>TypeError</code> when it tries to read the property <code>length</code> on <code>null</code>. Running <code>flow</code> will detect this bug:</p> <pre class=\"highlight\" data-language=\"bbcode\">  nulls.js:7\n    7: var total = length(\"Hello\") + length(null);\n                                     ^^^^^^^^^^^^ function call\n    4:   return x.length;\n                  ^^^^^^ property `length`. Property cannot be accessed on possibly null value\n    4:   return x.length;\n                ^ null\n</pre> <p>The file in the <code>answer</code> directory fixes this bug just like you might if you had discovered it at runtime. This fix, in turn, makes the type error go away:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\n\nfunction length(x) {\n  if (x !== null) {\n    return x.length;\n  } else {\n    return 0;\n  }\n}\n\nvar total = length('Hello') + length(null);\n</pre> <p>Because we've checked that <code>x</code> is not <code>null</code>, Flow knows that this code is now safe and doesn't emit a type error.</p> <h2>4. Arrays</h2> <p>Flow is of course not limited to simple types like numbers and strings. Our next example, <code>04_Arrays</code>, illustrates support for annotating functions on arrays:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\n\nfunction total(numbers: Array&lt;number&gt;) {\n  var result = 0;\n  for (var i = 0; i &lt; numbers.length; i++) {\n    result += numbers[i];\n  }\n  return result;\n}\n\ntotal([1, 2, 3, 'Hello']);</pre> <p>Flow will flag the string <code>'Hello'</code> here since the <code>total()</code> function accepts only an array of numbers:</p> <pre class=\"highlight\" data-language=\"bbcode\">  arrays.js:11\n   11: total([1, 2, 3, \"Hello\"]);\n       ^^^^^^^^^^^^^^^^^^^^^^^^^ function call\n   11: total([1, 2, 3, \"Hello\"]);\n                       ^^^^^^^ string. This type is incompatible with\n    3: function total(numbers: Array&lt;number&gt;) {\n                                     ^^^^^^ number\n</pre> <p>If we replace <code>\"Hello\"</code> with a number, the code will pass Flow's checks:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\n\nfunction total(numbers: Array&lt;number&gt;) {\n  var result = 0;\n  for (var i = 0; i &lt; numbers.length; i++) {\n    result += numbers[i];\n  }\n  return result;\n}\n\ntotal([1, 2, 3, 4]);</pre> <h2>5. Dynamic code</h2> <p>In our final example, <code>05_DynamicCode</code>, we haven't annotated the function, but we are passing in two different types of arguments:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\n\nfunction foo(x) {\n  return x.length;\n}\n\nvar res = foo('Hello') + foo(42);\n</pre> <p>In this case, Flow detects that the second time the function is called (with a number), the <code>length</code> property will fail:</p> <pre class=\"highlight\" data-language=\"bbcode\">  dynamic.js:4\n    4:   return x.length;\n                ^^^^^^^^ property `length`\n    4:   return x.length;\n                  ^^^^^^ property `length`. Property not found in\n    4:   return x.length;\n                ^ Number\n</pre> <p>One fix is to simply detect what the type is within the function:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\n\nfunction foo(x) {\n  if (typeof x === 'string') {\n    return x.length;\n  } else {\n    return x;\n  }\n}\n\nvar res = foo('Hello') + foo(42);\n</pre> <p>Flow is smart enough to detect that this conditional check is sufficient to avoid any potential failures at run time, and will give you a clean bill of health.</p> <h2>Next Steps</h2> <p>These simple examples just scratch the surface. You're now ready to start a new project with Flow and use the <a href=\"running#using-the-offline-transform-tool\">offline transform tool</a> to compile type annotations before publishing. Or you could incrementally <a href=\"existing\">try Flow using flow on some existing code</a>. You may also want to check out our much bigger <a href=\"react\">React example</a> to see Flow in more representative use cases.</p>   <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/five-simple-examples.html\" class=\"_attribution-link\">http://flowtype.org/docs/five-simple-examples.html</a>\n  </p>\n</div>\n","typeof":"<h1> Typeof </h1>    <p>In vanilla JavaScript, the <code>typeof</code> operator returns a <code>string</code> specifying the data type of an expression. Here is a simple example:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nvar index: number = 10;\nvar result: string = typeof index;\n// result: 'number'\n</pre> <p>However, in Flow, <code>typeof</code> can also be used to as a mechanism to capture types in type annotating positions as well.</p> <h2>Use of <code>typeof</code>\n</h2> <p>Take the following code example:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nclass X {}\nvar a = X; // a infers its type from X\nvar b: typeof X; // b has the same type as X. It is the same as a\n</pre> <p>There is no real advantage of using <code>typeof</code> for variable typing in the above case.</p> <p>However, imagine <code>X</code> has a <code>static</code> function:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nclass X {\n  static bar(): string {\n    return 'Hi';\n  }\n}\nvar a: X = new X();\na.bar(); // Type error\nvar b: typeof X = X;\nb.bar(); // Good\n</pre> <p><code>typeof</code> allows the capturing of the class <code>X</code> itself, rather than just an instance of <code>X</code>. So constructs like <code>static</code> functions can be called using a variable that captured a class via <code>typeof</code>.</p> <p>Here is the error that would occur if Flow was used to check the status of the code above:</p> <pre class=\"highlight\" data-language=\"bbcode\">/tmp/flow/f.js:8:1,7: call of method bar\nProperty not found in\n  /tmp/flow/f.js:2:7,7: X\n</pre> <p><code>typeof</code> is very useful for being able to work with the actual object itself, whether that is a class, module or some other construct.</p> <h2>Another Example</h2> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nclass Foo { }\nclass Bar { }\n// b ends up being a Foo type, since f evaluates to Foo\nvar b: { f : typeof Foo } = { f : Foo };\n// Since the type of b.f is typeof Foo (i.e. Class&lt;Foo&gt;), the following \n// assignment is valid because the type of the new instance is Foo:\nvar inst1: Foo = new b.f();\n// However, this fails because the type of the new instance is not Bar:\nvar inst2: Bar = new b.f();\n</pre> <pre class=\"highlight\" data-language=\"bbcode\">tmp/flow/f.js:10\n 10: var inst2: Bar = new b.f();\n                      ^^^^^^^^^ Foo. This type is incompatible with\n 10: var inst2: Bar = new b.f();\n                ^^^ Bar\n\n\nFound 1 error\n</pre>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/typeof.html\" class=\"_attribution-link\">http://flowtype.org/docs/typeof.html</a>\n  </p>\n</div>\n","third-party":"<h1> Checking third-party code </h1>    <p>Most real JavaScript programs depend on third-party libraries. This guide shows how to use Flow in a project with external dependencies, without having to typecheck library code.</p> <h2>Interface Files</h2> <p>Flow supports <em>interface files</em> for the purpose of understanding third party code you did not write. These files define the interface to a library, including types, separately from the actual code of the library. You never need to change library code to use interface files, but your code will be typechecked against the types declared in the interface file.</p> <p>The workflow for dealing with library code is:</p> <ul> <li>Do not change the library files or add <code>@flow</code> to them</li> <li>Add one or more interface files for your libraries in a special directory in your project - for example <code>interfaces</code>\n</li> <li>Point Flow at those interface files by starting it with <code>flow start --lib  &lt;path to your interface files&gt;</code> or by specifying a <code>[libs]</code> section in your <code>.flowconfig</code> file as such:</li> </ul> <pre class=\"highlight\" data-language=\"\">[libs]\ninterfaces/\n</pre> <h2>Example</h2> <p>To illustrate this workflow, we'll pick the <a href=\"http://underscorejs.org/\">Underscore</a> library. Let's say we have this simple file using Underscore:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\n\nvar pizzas = [\n  { title: 'Margherita', vegetarian: true },\n  { title: 'Pepperoni', vegetarian: false },\n  { title: 'Four cheese', vegetarian: true },\n  { title: 'Hawaiian', vegetarian: false },\n];\n\nfunction vegetarianPizzas() {\n  return _.findWhere(pizzas, {vegetarian: true});\n}\n</pre> <p>Running <code>flow</code> will unsurprisingly produce an error:</p> <pre class=\"highlight\" data-language=\"bbcode\">underscore_example.js:11:10,10: unknown global name: _\n</pre> <p>This is because Flow doesn't know anything about the <code>_</code> variable/module. To fix this we need to bring in an interface file for Underscore.:</p> <pre class=\"highlight\" data-language=\"javascript\">declare class Underscore {\n  findWhere&lt;T&gt;(list: Array&lt;T&gt;, properties: {}): T;\n}\n\ndeclare var _: Underscore;\n</pre> <p>This only describes (part of) the interface for Underscore, eliding all implementation details - so Flow never has to understand the Underscore code itself.</p> <p>If we now add the <code>interfaces/</code> directory to our flow config under a <code>[libs]</code> section:</p> <pre class=\"highlight\" data-language=\"\">[libs]\ninterfaces/\n</pre> <p>We can run flow again and see that the error goes away:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; flow\n</pre>\n<pre class=\"highlight\" data-language=\"\">Found 0 errors\n</pre> <p>If you temporarily modify your code that uses Underscore to purposefully introduce a type error, you can verify that it's now being checked against this interface file.</p> <p>When defining the interface for a library, you can use the <code>any</code> type whenever you don't need Flow to check a value. This lets you gradually add type definitions for the parts of the library you care most about. See the reference guide on <a href=\"declarations\">declarations</a> for more details.</p>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/third-party.html\" class=\"_attribution-link\">http://flowtype.org/docs/third-party.html</a>\n  </p>\n</div>\n","running":"<h1> Running Flow code </h1>    <p>Since types are not part of the JavaScript specification, we need to strip them out before sending the file to the user. There are a few ways to do so:</p> <ul> <li>Normally we recommend that you use <a href=\"http://babeljs.io/\">Babel</a> to strip away any type annotations from your files during development and deployment.</li> <li>For quick prototyping, you can also <a href=\"#using-the-in-browser-transform\">run the transforms directly in the browser</a>\n</li> </ul> <p>For integration with various other tools and build systems, check out this <a href=\"http://babeljs.io/docs/setup/\">really thorough set of docs</a> detailing how to set up Babel to work with various popular tools like Browserify, Broccoli, Webpack, Node.js, etc.</p> <h2>Using the offline transform tool</h2> <p>The offline transform tool is the recommended workflow for production. First, install the Babel CLI:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; npm install -g babel-cli\n</pre> <p>Next, install the babel flow transform and add a <code>.babelrc</code> file to the root your project to tell Babel to strip Flow annotations:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; cd /path/to/my/project\n$&gt; mkdir -p node_modules &amp;&amp; npm install babel-plugin-transform-flow-strip-types\n$&gt; echo '{\"plugins\": [\"transform-flow-strip-types\"]}' &gt; .babelrc\n</pre> <p>You can now simply run the transpiler in the background using the <code>babel</code> command:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; babel --watch=./src --out-dir=./build\n</pre> <p>This will run in the background, pick up any changes to files in <code>src/</code>, and create their pure JavaScript version in <code>build/</code>.</p> <p>For more detailed documentation on the <code>babel</code> CLI utility, check out it's own <a href=\"https://babeljs.io/docs/usage/cli/\">docs</a>.</p> <h2>Using the in-browser transform</h2> <p>This is <strong>not</strong> recommended for production because it is not as performant as the offline transform tool. However, it is a convenient way to get started with quick prototyping.</p> <p>All you have to do is install the <code>babel-browser</code> npm package, include the browser transformer in your document, and just use a special MIME type for your Flow scripts:</p> <pre class=\"highlight\" data-language=\"bash\">$&gt; mkdir -p node_modules &amp;&amp; npm install babel-browser\n</pre>\n<pre class=\"highlight\" data-language=\"html\">&lt;head&gt;\n  &lt;script src=\"node_modules/babel-core/browser.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;script type=\"text/babel\"&gt;\n  /* @flow */\n  // ... Here you can put inline JS with Flow type syntax! ...\n  &lt;/script&gt;\n\n  &lt;!-- Additionally you can just include files indirectly --&gt;\n  &lt;script type=\"text/babel\" src=\"main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n</pre> <p>Your script will then be transformed to plain JavaScript when it is loaded by the browser.</p> <h2>Transpiler in action</h2> <p>You can try out the live Flow transpiler below. Just edit the Flow script in the top window, and the transformed JavaScript will update in the second window.</p>           <p><link rel=\"stylesheet\" href=\"http://facebook.github.io/react/css/codemirror.css\"></p>    <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/running.html\" class=\"_attribution-link\">http://flowtype.org/docs/running.html</a>\n  </p>\n</div>\n","cli":"<h1> Using the CLI </h1>    <p>The flow command line tool is made to be easy-to-use for the simple case.</p> <p>Just using the command <code>flow</code> will type-check your current directory if the <code>.flowconfig</code> file is present. A flow server will automatically be started if needed.</p> <p>The CLI tool also provides several other options and commands that allow you to control the server and build tools that integrate with Flow. For example, this is how the <a href=\"http://nuclide.io\">Nuclide</a> editor integrates with Flow to provide autocompletion, type errors, etc. in it's UI.</p> <p>To find out more about the CLI just type:</p> <pre class=\"highlight\" data-language=\"\">flow --help\n</pre> <p>This will give you information about everything that flow can do. Running this command should print something like this:</p> <pre class=\"highlight\" data-language=\"\">Usage: flow [COMMAND]\n\nValid values for COMMAND:\n  ast             Print the AST\n  autocomplete    Queries autocompletion information\n  check           Does a full Flow check and prints the results\n  check-contents  Run typechecker on contents from stdin\n  coverage        Shows coverage information for a given file\n  find-module     Resolves a module reference to a file\n  get-def         Gets the definition location of a variable or property\n  get-importers   Gets a list of all importers for one or more given modules\n  get-imports     Get names of all modules imported by one or more given modules\n  init            Initializes a directory to be used as a flow root directory\n  port            Shows ported type annotations for given files\n  search          Searches a pattern\n  server          Runs a Flow server in the foreground\n  start           Starts a Flow server\n  status          (default) Shows current Flow errors by asking the Flow server\n  stop            Stops a Flow server\n  suggest         Shows type annotation suggestions for given files\n  type-at-pos     Shows the type at a given file and position\n  version         Print version information\n\nDefault values if unspecified:\n  COMMAND   status\n\nStatus command options:\n  --color              Display terminal output in color. never, always, auto (default: auto)\n  --from               Specify client (for use by editor plugins)\n  --help               This list of options\n  --json               Output results in JSON format\n  --no-auto-start      If the server is not running, do not start it; just exit\n  --old-output-format  Use old output format (absolute file names, line and column numbers)\n  --one-line           Escapes newlines so that each error prints on one line\n  --retries            Set the number of retries. (default: 3)\n  --retry-if-init      retry if the server is initializing (default: true)\n  --show-all-errors    Print all errors (the default is to truncate after 50 errors)\n  --strip-root         Print paths without the root\n  --temp-dir           Directory in which to store temp files (default: /tmp/flow/)\n  --timeout            Maximum time to wait, in seconds\n  --version            (Deprecated, use `flow version` instead) Print version number and exit\n</pre> <p>You can then, further dig into particular COMMANDs by adding the <code>--help</code> flag.</p> <p>So, for example, if you want to know more about how the autocomplete works, you can use this command:</p> <pre class=\"highlight\" data-language=\"\">flow autocomplete --help\n</pre>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/cli.html\" class=\"_attribution-link\">http://flowtype.org/docs/cli.html</a>\n  </p>\n</div>\n","quick-reference":"<h1> Quick Reference </h1>    <h2>Primitives</h2> <p>Flow has types for all of the JavaScript <strong>primitive types</strong>.</p> <ul> <li><a href=\"builtins#boolean\">boolean</a></li> <li><a href=\"builtins#mixed\">number</a></li> <li><a href=\"builtins#string\">string</a></li> <li><a href=\"builtins#null-and-void\">null</a></li> <li><a href=\"builtins#null-and-void\">void</a></li> </ul> <p>See <a href=\"builtins\">Built-in Types</a> for more information and examples.</p> <h2>any</h2> <p>The <code>any</code> type is a supertype <em>and</em> subtype of all types.</p> <p>Code that uses <code>any</code> is effectively unchecked, and should be avoided when another type can be used instead.</p> <p>It can be useful to opt out of type checking, however. In particular, it is very useful when converting an existing code base to use types.</p> <p>It is also occasionally necessary to bypass the type checker. There are a (decreasing) number of JS idioms which Flow is not able to type statically. In these instances, it is practical and reasonable to use <code>any</code>.</p> <p>See <a href=\"builtins#any\">Built-in Types</a> for more about <code>any</code>.</p> <h2>mixed</h2> <p>The <code>mixed</code> type is a supertype of all types.</p> <p>This type is particularly useful when paired with <a href=\"dynamic-type-tests\">dynamic type tests</a>. For example, you can use <code>mixed</code> to annotate a value of an unknown type, and Flow will ensure that you perform the necessary type tests to use the value safely.</p> <p>See <a href=\"builtins#mixed\">Built-in Types</a> for more about <code>mixed</code>.</p> <h2>Arrays</h2> <p>This type describes JavaScript array objects and the type of the elements contained within the array.</p> <p>Indexing into an array with type <code>Array&lt;T&gt;</code> will always yield a value with type <code>T</code>. That is, Flow assumes arrays are dense and does not do bounds checking.</p> <pre class=\"highlight\" data-language=\"js\">let array: number[] = [1, 2, 3.14, 42];\nlet theAnswer: number = array[3]; // 42\nlet offTheEnd: number = array[100]; // No error\n\nlet array2: Array&lt;string&gt; = [\"an alternate\", \"syntax\", \"for arrays\"];</pre> <h3>Tuples</h3> <p>Tuple types are a kind of array type particularly suited to describe finite, heterogeneous collections.</p> <pre class=\"highlight\" data-language=\"js\">let tuple: [string, number, boolean] = [\"foo\", 0, true];\n\n// Indexing into the array will return the type at a given index.\n(tuple[0]: string);\n(tuple[1]: string);\n\n// Indexing into an statically unknown index will return a general type.\ndeclare var unknownNumber: number;\n// `void` is none of `string`, `number`, or `boolean`\n(tuple[unknownNumber]: void);\n(tuple[unknownNumber]: string|number|boolean); // OK\n\n// Values written must be compatible with the type at that index.\ntuple[1] = -1;\ntuple[0] = false;</pre> <p>See <a href=\"arrays\">Arrays</a> for more information and examples.</p> <h2>Objects</h2> <p>This type describes any object values that match a specified shape.</p> <pre class=\"highlight\" data-language=\"js\">let object: {foo: string, bar: number} = {foo: \"foo\", bar: 0};\n(object.foo: string);\n\n// Property writes must be compatible with the declared type.\nobject.bar = \"bar\";</pre> <h3>Objects as maps</h3> <p>Objects are often used as lookup tables, or maps. While the <code>Map</code> type is more suitable for this use case, Flow does support this common idiom.</p> <pre class=\"highlight\" data-language=\"js\">let coolRating: {[id:string]: number} = {};\ncoolRating[\"sam\"] = 10; // Yes, it's a 0-10 scale.</pre> <h3>Callable objects</h3> <p>Functions are also objects, and may have other props. Flow models this as an object type with a callable property.</p> <pre class=\"highlight\" data-language=\"js\">function makeCallable(): { (x: number): string; foo: number } {\n  function callable(number) {\n    return number.toFixed(2);\n  }\n  callable.foo = 123;\n  return callable;\n}\n\nvar callable = makeCallable();\n\nvar callableReturn: string = callable(Math.PI); // \"3.14\"\nvar callableFoo: number = callable.foo; // 123</pre> <h3>The <code>Object</code> type</h3> <p>The <code>Object</code> type is a supertype of all object types. A value of this type supports property access by any property name, and will return a value with type <code>any</code>.</p> <p>Like <code>any</code>, this type should be used sparingly.</p> <pre class=\"highlight\" data-language=\"js\">var anyObject: Object = {};\nanyObject.foo.bar.baz; // OK</pre> <p>See <a href=\"objects\">Objects</a> for more information and examples.</p> <h2>Functions</h2> <p>Functions take zero or more arguments and optionally return a value. In addition to \"standard\" function declarations, Flow supports arrow functions, async functions, and generator functions.</p> <pre class=\"highlight\" data-language=\"js\">function greatestCommonDivisor(a: number, b: number): number {\n  if (!b) {\n    return a;\n  }\n\n  return greatestCommonDivisor(b, a % b);\n}\n\n// Annotations included for example purposes only.\n[1, 2, 3].map((num: number): number =&gt; num * 2)\n\nasync function getFriendNames(\n  friendIDs: Promise&lt;number[]&gt;,\n  getFriendName: (id: number) =&gt; Promise&lt;string&gt;,\n): Promise&lt;string[]&gt; {\n  var ids = await friendIDs;\n  var names = await Promise.all(ids.map(getFriendName));\n  return names;\n}\n\nfunction *infinity(): Generator&lt;number,void,void&gt; {\n  var n = 0;\n  while (true) {\n    yield n++;\n  }\n}</pre> <h3>The <code>Function</code> type</h3> <p>The <code>Function</code> type is a supertype of all function types. A value of this type may be called with any number of any type of parameters, and will return a value with type <code>any</code>.</p> <p>Like <code>any</code>, this type should be used sparingly.</p> <pre class=\"highlight\" data-language=\"js\">var anyFunction: Function = () =&gt; {};\nanyFunction(\"foo\", \"bar\").baz.quux; // OK</pre> <p>See <a href=\"functions\">Functions</a> for more information and examples.</p> <h2>Classes</h2> <p>Defining a class also defines a type, which can be used to annotate instances of that class.</p> <pre class=\"highlight\" data-language=\"js\">class MyClass {\n  foo: string;\n  constructor(foo: string) {\n    this.foo = foo;\n  }\n  bar(): string {\n    return this.foo;\n  }\n}\n\nvar myInstance: MyClass = new MyClass(\"foo\");\n(myInstance.foo: string);\n(myInstance.bar(): string);</pre> <h3>Interfaces</h3> <p>Classes are nominally typed in Flow. That means that two classes are only compatible if they have an explicit subtyping relationship, via <code>extends</code>. It is often useful to describe a set of types which are structurally similar.</p> <pre class=\"highlight\" data-language=\"js\">interface Fooable {\n  foo(): string;\n}\n\nclass AFoo {\n  foo() { return \"foo from A\" };\n}\n\nclass BFoo {\n  foo() { return \"foo from B\" };\n}\n\n(new AFoo: Fooable);\n(new BFoo: Fooable);</pre> <h3>Sugar-free classes</h3> <p>ES2015 classes formalize the common practice of simulating class-like inheritance with functions and prototypes. Flow does have limited support for this pattern as well, but the ES2015 class syntax is highly recommended.</p> <pre class=\"highlight\" data-language=\"js\">function DietClass(foo: string) {\n  this.foo = foo;\n}\n\nDietClass.prototype.bar = function() {\n  return this.foo;\n}\n\nvar myDietInstance: DietClass = new DietClass(\"foo\");\n(myDietInstance.foo: string);\n(myDietInstance.bar(): string);</pre> <h3>The <code>Class&lt;T&gt;</code> type</h3> <p>Remember that the name of the class as a type annotation represents instances of that class. Given a type <code>T</code> representing instances of a class <code>C</code>, the type <code>Class&lt;T&gt;</code> is the type of the class <code>C</code>.</p> <pre class=\"highlight\" data-language=\"js\">var myClass: Class&lt;MyClass&gt; = MyClass;\nvar myInstance2 = new myClass(\"foo\");</pre> <p>See <a href=\"classes\">Classes</a> for more information and examples.</p> <h2>Type aliases</h2> <p>Instead of writing out a potentially complex type multiple times, define a type alias instead.</p> <pre class=\"highlight\" data-language=\"js\">type ObjectWithManyProperties = {\n  foo: string,\n  bar: number,\n  baz: boolean,\n  qux: (foo: string, bar: number) =&gt; boolean;\n}</pre> <p>See <a href=\"type-aliases\">Type Aliases</a> for more information and examples.</p> <h2>Generics</h2> <p>Generics make it possible to abstract over types. A common example is container classes, which store, traverse, and retrieve data without knowledge of specifically what is inside.</p> <p>Generic object types can be specified using a type alias.</p> <pre class=\"highlight\" data-language=\"js\">type GenericObject&lt;T&gt; = { foo: T };\nvar numberObject: GenericObject&lt;number&gt; = { foo: 0 };\nvar stringObject: GenericObject&lt;string&gt; = { foo: \"foo\" };</pre> <p>Type parameters for classes are specified in the class declaration.</p> <pre class=\"highlight\" data-language=\"js\">class GenericClass&lt;T&gt; {\n  x: T;\n  constructor(x: T) {\n    this.x = x;\n  }\n}\n\nvar numberInstance: GenericClass&lt;number&gt; = new GenericClass(0);\nvar stringInstance: GenericClass&lt;string&gt; = new GenericClass(\"\");</pre> <p>Type parameters for functions are specified in the function declaration.</p> <pre class=\"highlight\" data-language=\"js\">function findMax&lt;T&gt;(arr: T[], compare: (a: T, b: T) =&gt; number) {\n  var sorted = arr.sort(compare);\n  return sorted[sorted.length - 1];\n}</pre>   <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/quick-reference.html\" class=\"_attribution-link\">http://flowtype.org/docs/quick-reference.html</a>\n  </p>\n</div>\n","disjoint-unions":"<h1> Disjoint Unions </h1>    <p>Sometimes programs need to deal with different kinds of data all at once, where the shape of the data can be different based on what kind of data the code is looking at. This kind of programming is so common in functional programming languages that almost all such languages come with a way of:</p> <ul> <li><p>Specifying such data by a set of disjoint cases, distinguished by \"tags,\" where each tag is associated with a different \"record\" of properties. (These descriptions are called \"disjoint union\" or \"variant\" types.)</p></li> <li><p>Doing case analysis on such data, by checking tags and then directly accessing the associated record of properties. (The common way to do such case analysis is by pattern matching.)</p></li> </ul> <p>Examples of programs that analyze or transform such data range from compilers working with abstract syntax trees, to operations that may return exceptional values, with much more in between!</p> <p>With Flow, it is possible to program in this style in JavaScript in a type-safe manner. You can define a disjoint union of object types and do case analysis on objects of that type by switching on the value of some common property (called a \"sentinel\") in those object types.</p> <h2>Example</h2> <p>Consider a computation that takes an argument and a callback that is invoked when the computation is complete, with a success or failure result. As a concrete example, suppose that we are interested in computing the inverse of a matrix (which may or may not exist).</p> <p>The result type can be modeled as a disjoint union type. In terms of syntax, a disjoint union type is just a specific form of <a href=\"union-intersection-types\">union type</a>. In addition, a disjoint union type makes heavy use of <a href=\"builtins#literal-types\">literal types</a>: this is important, because we will see below how Flow can relate these types back to dynamic equality checks with literals that appear commonly in JavaScript code.</p> <pre class=\"highlight\" data-language=\"js\">type Matrix = number[][]; // type of input and output for our function\n\ntype Result = Done | Error; // a disjoint union type with two cases\ntype Done = { status: 'done', answer: Matrix };\ntype Error = { status: 'error', message: string };</pre> <p>Here, the property <code>status</code> serves as the sentinel property in <code>Result</code>: this is the property that actually makes the union type \"disjoint.\"</p> <p>Case analysis can be performed on results of type <code>Result</code> by matching the value of the <code>status</code> property with the literals <code>done</code> or <code>error</code>. Note that matching must be performed with the <code>===</code> operator. Conveniently, <code>switch</code> statements already use this operator, but using <code>if</code> with this operator also works.</p> <p>Flow will correctly narrow down the <code>Result</code> type to the corresponding cases, <code>Done</code> and <code>Error</code>, so that the properties <code>answer</code> and <code>message</code> can be accessed safely based on context.</p> <pre class=\"highlight\" data-language=\"js\">function invert(matrix: Matrix, callback: (result: Result) =&gt; void) {\n  // Try to compute the inverse of `matrix`.\n  // On success, invoke callback with `{ status: 'done', answer: ... }`.\n  // On failure, involve callback with `{ status: 'error', message: ... }`.\n\n  // ...\n}\n\nfunction showInverseOf(matrix: Matrix) {\n  invert(matrix, result =&gt; {\n    switch (result.status) {\n    case 'error':\n      console.log (\"Uh oh!\", result.message);\n      break;  // see what happens if you forget to break! :)\n    default:\n      console.log (\"Inverse:\", result.answer);\n    }\n  });\n}</pre>   <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/disjoint-unions.html\" class=\"_attribution-link\">http://flowtype.org/docs/disjoint-unions.html</a>\n  </p>\n</div>\n","troubleshooting":"<h1> Troubleshooting </h1>    <h2>Common errors and how to fix them</h2> <h3>Global not found</h3> <p>These errors are due to global references in your code, and possibly also due to typos. If the former, you can <a href=\"third-party#interface-files\">declare them in an interface file</a> if you know that they are going to be available when you run the code.</p> <pre class=\"highlight\" data-language=\"javascript\">declare var foo: &lt;type&gt;;\n</pre> <h3>Required module not found</h3> <p>These errors are due to <code>require(...)</code> or <code>import</code> statements in your code that don't resolve to the set of modules exported by files under <code>&lt;root&gt;</code>. To specify additional code directories to Flow, you can add the following lines to your project's <code>.flowconfig</code> under <code>&lt;root&gt;</code>.</p> <pre class=\"highlight\" data-language=\"\">[include]\n../node_modules/\n../lib/\n</pre> <p>Alternatively, you may not have the code available for those modules, or otherwise want to specify declarations for them. In that case, as in the 'global not found' case above you need to add an interface file and point to it from within your <code>.flowconfig</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">declare module Bar {\n  ...\n}\n</pre> <p>For more information about writing interface files, see <a href=\"third-party\">this guide</a> Note that if both an implementation and a declaration is found for a module, Flow will choose the implementation only if it has been opted-in. Otherwise it will use the declaration.</p> <h3>Operation not allowed on <code>null</code> / <code>undefined</code>\n</h3> <p>Flow considers types to be incompatible with <code>null</code> / <code>undefined</code> in general (the only compatible types are \"nullable\" types, denoted <code>?&lt;type&gt;</code>. Thus, it will complain if it finds that an operation may happen on <code>null</code> / <code>undefined</code> that couldn't normally happen on the type as well as null.</p> <p>The general way to deal with this is to store the value in a local variable, and guard the operation with a dynamic check on the local variable.</p> <pre class=\"highlight\" data-language=\"javascript\">// var result = foo().bar\nvar x = foo();\nvar result = x != null ? x.bar : ...\n</pre> <p>You can also try other variations of this basic pattern:</p> <pre class=\"highlight\" data-language=\"javascript\">// foo.bar()\nfoo &amp;&amp; foo.bar()\n</pre> <h3>Function call with too few arguments</h3> <p>In JavaScript, function calls can pass too many or too few arguments: Additional arguments get dropped, and missing arguments get initialized with <code>undefined</code>. Flow admits the former pattern because it is mostly harmless; but it complains about the latter.</p> <p>The most common way to fix these errors is to mark optional parameters with a trailing-<code>?</code> in the definition for the function being called:</p> <pre class=\"highlight\" data-language=\"javascript\">function foo(x?) { ... }\nfoo();\n</pre> <p>Doing this might shift the problem to the function definition, where <code>x</code> now has a \"optional\" type. So operations on <code>x</code> may then need to be guarded by dynamic checks.</p> <pre class=\"highlight\" data-language=\"javascript\">function foo(x?) {\n  if (x != undefined) {\n    // operation on x\n  }\n}\nfoo();\n</pre> <p>Alternatively, you might want to just provide a default value to <code>x</code>, in which case the dynamic check is not required.</p> <pre class=\"highlight\" data-language=\"javascript\">function foo(x = 0) {\n  // operation on x\n}\nfoo();\n</pre> <h3>Other type confusions</h3> <p>Some operations only make sense when they're performed on a particular set of values. (They may still work on other values, but may have unintended consequences).</p> <p>For example, multiplication (<code>*</code>) should be performed only on numbers even though it may happen to work when you pass strings (though usually they're usually converted to <code>NaN</code>).</p> <p>Iteration using <code>for-in</code> should be performed only on objects even though it may still work on arrays (the keys are converted to strings and other, often unexpected, properties are also included).</p> <p>Non-strict equality <code>==</code> should be performed only on values that have the same type (otherwise, some sequence of type conversions are tried).</p> <p>Flow will error on many of these operations because they tend to be hazardous. Usually there is a safer way to express the intent of the code in these cases: e.g., use <code>Array.forEach</code> and <code>===</code> in the latter two cases or use <code>Number(...)</code> in the former case).</p>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/troubleshooting.html\" class=\"_attribution-link\">http://flowtype.org/docs/troubleshooting.html</a>\n  </p>\n</div>\n","builtins":"<h1> Built-in Types </h1>    <p>Flow includes many built-in types, which can be used to describe values in JavaScript.</p> <p>There are types for primitive values, like <code>number</code> and <code>string</code>. Types like <code>any</code> and <code>mixed</code> describe more flexible constraints on values, whereas literal types describe specifically a single value.</p> <p>Flow comes out of the box with support for the JavaScript standard library, Browser APIs like the DOM, and the Node.js standard library.</p> <h4>Note about typecast syntax</h4> <p>The following examples make extensive use of typecasts in order to demonstrate type compatibility.</p> <p>In Flow, typecasts are sound, meaning that the statement <code>(e:T)</code> for some expression <code>e</code> and type <code>T</code> is a type error unless the inferred type of <code>e</code> is a valid subtype of <code>T</code>.</p> <p>In other words, with respect to validity a typecast behaves just like a type annotation on a variable or parameter. If <code>var x:T = e</code> would be valid, then <code>(e:T)</code> would be as well.</p> <pre class=\"highlight\" data-language=\"js\">(1 + 1: string); // Error: Numbers are not strings\n(\"Hello, World\": string); // OK: Strings are strings\n\nclass A {}\nclass B extends A {}\nlet a = new A(),\n    b = new B();\n(b: A); // OK: B is a subclass of A\n(a: B); // Error: A is not a subclass of B</pre> <h2>boolean</h2> <p>This type describes a boolean value in JavaScript. The possible values of this type are <code>true</code> and <code>false</code>.</p> <pre class=\"highlight\" data-language=\"js\">(true: boolean);\n(false: boolean);\n(\"foo\": boolean); // strings are not booleans</pre> <p>JavaScript specifies many implicit conversions, which provide boolean semantics to values of other types. Flow understands this and allows any expression to be used as a conditional in an <code>if</code> statement or as an operand to <code>&amp;&amp;</code>. However, if you need to cast an object specifically to the <code>boolean</code> type, you can use the built-in <code>Boolean</code> function</p> <pre class=\"highlight\" data-language=\"js\">function takes_boolean(x: boolean): void {}\ntakes_boolean(0); // Implicit casting is an error.\ntakes_boolean(Boolean(0)); // Adding an explicit cast type checks.</pre> <p>Note that <code>boolean</code> and <code>Boolean</code> are separate types. The former is the type of primitive booleans which appear in programs as literals <code>true</code> and <code>false</code>, or as the result of expressions like <code>a === b</code>. The latter is the type of Boolean wrapper objects, which are rarely used.</p> <pre class=\"highlight\" data-language=\"js\">(true: Boolean);\n(new Boolean(false): Boolean);</pre> <h2>number</h2> <p>JavaScript has a single number type, which is IEEE 754 floating point numbers. The <code>number</code> type describes these values, which includes <code>Infinity</code> and <code>NaN</code>.</p> <pre class=\"highlight\" data-language=\"js\">(3.14: number);\n(42: number);\n(NaN: number);\n\n(parseFloat(\"not a number\"): number); // hint: NaN</pre> <p>Note that <code>number</code> and <code>Number</code> are separate types. The former is the type of primitive numbers which appear in programs as literals, like <code>3.14</code> and <code>42</code>, or as the result of expressions like <code>parseFloat(input.value)</code>. The latter is the type of Number wrapper objects, which are rarely used.</p> <pre class=\"highlight\" data-language=\"js\">(0: Number);\n(new Number(0): Number);</pre> <h2>string</h2> <pre class=\"highlight\" data-language=\"js\">(\"foo\": string);\n(\"bar\": string);</pre> <p>Generally, implicit type casting is an error with Flow. However, it is a fairly common JavaScript idiom to produce a string by combining a <code>string</code> and a <code>number</code> with the binary operator <code>+</code>, so Flow accepts it.</p> <pre class=\"highlight\" data-language=\"js\">((100 + \"%\") : string);</pre> <p>Note that <code>string</code> and <code>String</code> are separate types. The former is the type of primitive strings which appear in programs as literals, like <code>\"foo\"</code> and <code>\"bar\"</code>, or as the result of expressions like <code>\"\" + 42</code>. The latter is the type of String wrapper objects, which are rarely used.</p> <pre class=\"highlight\" data-language=\"js\">(\"foo\": String);\n(new String(\"foo\"): String);</pre> <h2>null and void</h2> <p>JavaScript has both <code>null</code> and <code>undefined</code>, which Flow is careful to treat separately. <code>null</code> (the value) has the type <code>null</code>. <code>undefined</code> has the type <code>void</code>.</p> <pre class=\"highlight\" data-language=\"js\">(null: null); // yup\n(null: void); // nope\n\n(undefined: void); // yup\n(undefined: null); // nope</pre> <p>Optional object properties and optional function parameters have the type <code>T|void</code>, for some type <code>T</code>.</p> <pre class=\"highlight\" data-language=\"js\">function optional_fun(foo?: string) {\n  (foo: string|void);\n}\noptional_fun(\"foo\");\noptional_fun(undefined);\noptional_fun();\noptional_fun(null); // null is not a string, nor void\n\ntype optional_obj = { foo?: string }\n({foo: \"foo\"}: optional_obj);\n({foo: undefined}: optional_obj);\n({}: optional_obj);\n({foo: null}: optional_obj); // null is not a string, nor void</pre> <p>Function parameters that have a default are optional as well, but only for callers. Within the function body, the binding has a non-<code>void</code> type.</p> <pre class=\"highlight\" data-language=\"js\">function default_fun(foo: string = \"default foo\") {\n  (foo: string);\n}\ndefault_fun(\"foo\");\ndefault_fun(undefined);\ndefault_fun();</pre> <p>Maybe types have the type <code>T|void|null</code> for some type <code>T</code>.</p> <pre class=\"highlight\" data-language=\"js\">function maybe_fun(foo: ?string) {\n  (foo: string|void|null);\n}\nmaybe_fun(\"foo\");\nmaybe_fun(undefined);\nmaybe_fun();\nmaybe_fun(null);</pre> <h2>any</h2> <p><code>any</code> is simultaneously a supertype of all types and a subtype of all types. Intuitively, an <code>any</code> value can take the place of \"any\" other value, and Flow will understand that to be well-typed.</p> <pre class=\"highlight\" data-language=\"js\">function takes_any(x: any): void {}\ntakes_any(0);\ntakes_any(\"\");\ntakes_any({ foo: \"bar\" });\n\ndeclare var any: any;\n(any: number);\n(any: string);\n(any: { foo: string });</pre> <p>In addition to compatibility between types, it's useful to think of <code>any</code> in terms of operations that can be performed on values. Accessing any property on an <code>any</code> will yield an <code>any</code>. It is possible to call an <code>any</code> as a function, taking any number arguments of any type, which will also return <code>any</code>.</p> <pre class=\"highlight\" data-language=\"js\">any.foo.bar.baz;\n(any(\"foo\"): string);\n(any(\"bar\"): number);</pre> <p>You can think of <code>any</code> as a kind of \"backdoor\" in the type system. Use of <code>any</code> is inherently unsafe and should be avoided whenever possible. However, it can also be incredibly convenient.</p> <p>For example, when adding types to existing code, using <code>any</code> can help make the gradual transition from untyped to typed code. Similarly, modeling third-party APIs with <code>any</code> can ease integration.</p> <p>Lastly, due to the highly dynamic nature of JavaScript, there are some idioms which Flow does not yet understand. Principled use of <code>any</code> makes it possible to wrap untyped code in types.</p> <h2>mixed</h2> <p>Like <code>any</code>, <code>mixed</code> is a supertype of all types. Unlike <code>any</code>, however, <code>mixed</code> is not a bottom type.</p> <pre class=\"highlight\" data-language=\"js\">function takes_mixed(x: mixed): void {}\ntakes_mixed(0);\ntakes_mixed(\"\");\ntakes_mixed({ foo: \"bar\" });\n\nfunction returns_mixed(): mixed {}\n(returns_mixed(): number);\n(returns_mixed(): string);\n(returns_mixed(): { foo: string });</pre> <p>It's still possible to use a value with a <code>mixed</code>, but you must first <a href=\"dynamic-type-tests\">refine</a> the value.</p> <p>For example, let's construct a type of values which can be expressed directly as JSON. We can express this type quite naturally.</p> <pre class=\"highlight\" data-language=\"js\">type JSON = | string | number | boolean | null | JSONObject | JSONArray;\ntype JSONObject = { [key:string]: JSON };\ntype JSONArray = Array&lt;JSON&gt;;</pre> <p>Now let's write a function that verifies that a given value is a JSON value. If we annotated the parameter as <code>any</code>, we could just return the parameter and Flow would accept that without error because <code>any</code> is a subtype of all types, including <code>JSON</code>.</p> <p>If we use <code>mixed</code>, however, we can still pass any value into our function, as <code>mixed</code> is a supertype of all types. But in order to satisfy the <code>JSON</code> return type, Flow requires us to implement the necessary runtime type checks.</p> <pre class=\"highlight\" data-language=\"js\">function typedJSON(x: mixed): JSON {\n  if (typeof x === \"object\" &amp;&amp; x !== null) {\n    let o: JSONObject = {};\n    for (let k of Object.keys(x)) {\n      o[k] = typedJSON(x[k]);\n    }\n    return o;\n  }\n\n  if (Array.isArray(x)) {\n    return x.map(typedJSON);\n  }\n\n  if (x === null ||\n      typeof x === \"string\" ||\n      typeof x === \"number\" ||\n      typeof x === \"boolean\") {\n    return x;\n  }\n\n  throw new Error(\"Invalid JSON\");\n}</pre> <h2>literal types</h2> <p>While type <code>boolean</code>, <code>number</code>, and <code>string</code> types admit <code>true</code> and <code>false</code>, any number, and any string, respectively, it can also be useful to specify a type that admits a single value. This feature turns out to be surprisingly <a href=\"disjoint-unions\">versatile</a>: literal types can be used to build enums and other disjoint unions, as well as express some common forms of method overloading for which the types <code>boolean</code>, <code>number</code>, and <code>string</code> are not adequate.</p> <pre class=\"highlight\" data-language=\"js\">(\"foo\": \"foo\");\n(\"bar\": \"foo\"); // `\"bar\"` is not exactly `\"foo\"`\n(\"fo\"+\"o\": \"foo\"); // even simple expressions lose literal information\n\n(1: 1);\n(2: 1); // `2` is not exactly `1`\n(1+1: 2); // even simple expressions lose literal information\n\n(true: true);\n(true: false); // `true` is not exactly `false`\n\n// boolean expressions *do* preserve literal information\n(!true: false);\n(true &amp;&amp; false: false);\n(true || false: true);</pre> <p>Let's have a little fun with literal types. The following program shows how literals can be used to statically index into objects. It also shows how tuples of unions can be used to represent enums.</p> <pre class=\"highlight\" data-language=\"js\">type Suit =\n  | \"Diamonds\"\n  | \"Clubs\"\n  | \"Hearts\"\n  | \"Spades\";\ntype Rank =\n  | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n  | \"Jack\"\n  | \"Queen\"\n  | \"King\"\n  | \"Ace\";\ntype Card = {\n  suit: Suit,\n  rank: Rank,\n}\n\ndeclare var cards: Card[];\ncards.sort((a, b) =&gt; cardComparator(a, b));\ncards.sort((a, b) =&gt; cardComparator(a, b, true)); // Aces high\n\nfunction suitOrder(suit) {\n  return {\n    Diamonds: 0,\n    Clubs: 1,\n    Hearts: 3,\n    Spades: 4,\n  }[suit];\n}\n\nfunction rankOrder(rank, aceHigh = false) {\n  if (typeof rank === \"string\") {\n    return {\n      Jack: 11,\n      Queen: 12,\n      King: 13,\n      Ace: aceHigh ? 14 : 1,\n    }[rank];\n  } else {\n    return rank;\n  }\n}\n\nfunction cardComparator(a, b, aceHigh?) {\n  return (rankOrder(a.rank, aceHigh) - rankOrder(b.rank, aceHigh))\n      || (suitOrder(a.suit) - suitOrder(b.suit));\n}</pre> <p>Note that Flow is able to infer the parameter and return types of <code>suitOrder</code>, <code>rankOrder</code>, and <code>cardComparator</code> correctly. Try copying that into your text editor and introducing type errors to see what Flow can catch!</p> <h2>JavaScript standard library</h2> <p>Type declarations for the <a href=\"https://github.com/facebook/flow/blob/master/lib/core.js\">JavaScript standard libarary</a> are included with Flow.</p> <p>Flow has broad support for the standard library, including support for Iterables, Iterators, and Generators.</p> <h2>Browser APIs</h2> <p>Type declarations for the <a href=\"https://github.com/facebook/flow/blob/master/lib/dom.js\">Document Object Model</a> (DOM), <a href=\"https://github.com/facebook/flow/blob/master/lib/bom.js\">Browser Object Model</a> (BOM), and <a href=\"https://github.com/facebook/flow/blob/master/lib/cssom.js\">CSS Object Model</a> (CSSOM) are all included with Flow.</p> <h2>Node.js</h2> <p>Type declarations for the <a href=\"https://github.com/facebook/flow/blob/master/lib/node.js\">Node.js standard libarary</a> are included with Flow.</p>   <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/builtins.html\" class=\"_attribution-link\">http://flowtype.org/docs/builtins.html</a>\n  </p>\n</div>\n","arrays":"<h1> Arrays </h1>    <p>Array types are simply instantiations of a special polymorphic Array class: the type <code>Array&lt;T&gt;</code> describes arrays whose elements are of type <code>T</code>. The shorthand syntax <code>T[]</code> is equivalent to <code>Array&lt;T&gt;</code>.</p> <h2>Type Annotating Arrays</h2> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nvar a = [1, 2, 3];\nvar b: Array&lt;number&gt; = a.map(function(x) { return x + 1; });\n</pre> <p>In this code, we create an array with the literal <code>[1, 2, 3]</code>, and call a method map on it, getting another array whose type we annotate as <code>Array&lt;number&gt;</code>.</p> <h2>Array Elements</h2> <p>Interestingly, the element type of an array is not fixed: it is a supertype of the types of all elements written into the array. Just like other polymorphic classes, array types are invariant in their element types.</p> <p>For example:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nvar a = [];\nfor (var i = 0; i &lt; 10; ++i) {\n  if (i % 2 == 0) {\n    a[i] = 0;\n  } else {\n    a[i] = '';\n  };\n}\n\nfunction foo(i): string { return a[i]; }\n</pre> <p>Running Flow produces the following error:</p> <pre class=\"highlight\" data-language=\"bbcode\">example.js:5:14,14: number\nThis type is incompatible with\n example.js:11:18,23: string\n</pre> <p>The type of a is not pinned to <code>Array&lt;number&gt;</code> by the element write <code>a[i] = 0</code> at line 4: if it did, Flow would report an error for an incompatible element write <code>a[i] = ''</code> at line 5. Instead, based on lines 4 and 5, the type of a becomes <code>Array&lt;T&gt;</code> where <code>T</code> is <code>number</code> or <code>string</code>. Since it is impossible to know which element is read on line 11, Flow must account for the possibility that it could be <code>number</code>, in which case it would be incompatible with the <code>string</code> annotation, as reported.</p> <h2>Exporting Arrays</h2> <p>When an array is exported, its element type must be specified. This effectively \"seals\" the element type.</p> <h2>Tuples</h2> <p>Given types <code>T0</code>, <code>T1</code>, ..., <code>Tn</code>, a tuple type <code>[T0, T1, ..., Tn]</code> is an array. That array has a general type <code>Array&lt;T0 | T1 | ... | Tn&gt;</code>, but Flow also understands that accessing the element at index <code>n</code> will evaluate to the specific type <code>Tn</code>.</p> <p>Note that a tuple type of length <code>n</code> doesn't guarantee inhabitant arrays never grow beyond length <code>n</code>. Thus, <code>var xs: [number, string] = [0, \"\", 0]</code> is a valid assignment. Flow will ensure that the values at indices &lt; <code>n</code> are of the correct specific type, but values &gt;= <code>n</code> can still exist as long as they are consistent with the general element type of the array.</p> <h3>Syntax</h3> <p>Tuples are arrays, so they are declared like arrays</p> <pre class=\"highlight\" data-language=\"javascript\">[&lt;type1&gt;, &lt;type2&gt;, &lt;type3&gt;, ...]\n</pre> <p>The elements of a tuple are accessed by their indices, where the exact type for that particular index will be returned.</p> <h3>Example</h3> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nvar tup = [\"1\", 1, true, \"positive\"];\nvar b = tup[1] * tup[3];\n</pre> <pre class=\"highlight\" data-language=\"\">/tmp/flow/tup.js:2:26,35: string\nThis type is incompatible with\n  /tmp/flow/tup.js:3:9,23: number\n\nFound 1 errors\n</pre> <p>We declared a tuple with four (4) elements and tried to multiply a <code>number</code> with a <code>string</code>, and Flow caught it. </p>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/arrays.html\" class=\"_attribution-link\">http://flowtype.org/docs/arrays.html</a>\n  </p>\n</div>\n","nullable-types":"<h1> Maybe Types </h1>    <p>In JavaScript, <code>null</code> implicitly converts to all the primitive types; it is also a valid inhabitant of any object type.</p> <p>In contrast, Flow considers <code>null</code> to be a distinct value that is not part of any other type. For example, the following code does not typecheck:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nvar o = null;\nprint(o.x);\n</pre> <pre class=\"highlight\" data-language=\"bbcode\">file.js:3:7,9: property x\nProperty cannot be accessed on possibly null value\n  file.js:2:9,12: null\n</pre> <h2>Type Annotating Null</h2> <p>Any type <code>T</code> can be made to include <code>null</code> (and the related value <code>undefined</code>) by writing <code>?T</code>: the latter type is a maybe type that describes <code>null</code> (or <code>undefined</code>) or the set of values of <code>T</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nvar o: ?string = null;\nprint(o.length);\n</pre> <pre class=\"highlight\" data-language=\"bbcode\">file.js:3:7,14: property length\nProperty cannot be accessed on possibly null or undefined value\n  file.js:2:9,14: ?string\n</pre> <p>Relaxing a type into a maybe type makes it a valid annotation for any location that may contain <code>null</code>, but it still does not allow useful operations to be performed on it (as shown by the code above). To do so, we must perform a <code>null</code> check, as follows:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nvar o: ?string = null;\nif (o == null) {\n  o = 'hello';\n}\nprint(o.length);\n</pre> <p>In this code, after the <code>if</code>-statement Flow infers that <code>o</code> is not <code>null</code> (it either was <code>null</code> before the <code>if</code>-statement but is now an object, or was not <code>null</code> before the <code>if</code>-statement). So the code typechecks.</p> <blockquote> <p>NOTE</p> <p>It is important to note that we used <code>==</code> instead of <code>===</code> to do a <code>null</code> check. This ensures that we also check for <code>undefined</code>, which is considered part of a maybe type. Using <code>=== null</code> instead would require yet another <code>=== undefined</code> to cover all cases. </p> </blockquote> <p>This illustrates an interesting feature of Flow: it understands the effects of some dynamic type tests and can adjust the types of local variables accordingly (in technical terms, Flow's analysis is path-sensitive).</p> <p>Read more about <a href=\"dynamic-type-tests\">dynamic type tests</a>.</p> <h2>Maybe and Objects</h2> <p>In addition to being able to adjust types of local variables, Flow can sometimes also adjust types of object properties, especially when there are no intermediate operations between a check and a use. In general, though, aliasing of objects limits the scope of this form of reasoning, since a check on an object property may be invalidated by a write to that property through an alias, and it is difficult for a static analysis to track aliases precisely. </p> <p>In particular, don't expect a nullable field to be recognized as non-<code>null</code> in some method because a <code>null</code> check is performed in some other method in your code, even when it is clear to you that the <code>null</code> check is sufficient for safety at run time (say, because you know that calls to the former method always follow calls to the latter method). On the other hand, you can always propagate the result of a <code>null</code>-check by explicitly passing around the non-<code>null</code> value in your code, and if you are careful enough it should be possible to satisfy Flow without doing additional <code>null</code> checks.</p> <h2>Undefined Values and Optional Types</h2> <p>Undefined values, just like <code>null</code>, can cause issues too. Unfortunately, undefined values are ubiquitous in JavaScript and it is hard to avoid them without severely affecting the usability of the language. For example, arrays can have holes for elements; object properties can be dynamically added and removed. Flow ignores the possibility of <code>undefined</code> resulting from object property and array element accesses. Being stricter would force the programmer to do <code>undefined</code> checks (like <code>null</code> checks) on each dereference of an array element or object property to get anything useful done.</p> <p>However, Flow does detect <code>undefined</code> local variables and return values, and it considers optional parameters and properties to possibly be <code>undefined</code>. As such, uses of these types must be guarded by <code>undefined</code> checks to avoid errors.</p>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/nullable-types.html\" class=\"_attribution-link\">http://flowtype.org/docs/nullable-types.html</a>\n  </p>\n</div>\n","destructuring":"<h1> Destructuring </h1>    <p>Flow supports the JavaScript construct of destructuring, which allows you to extract data from structured values. Here is a simple example:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nvar arr = [1, '', true];\nvar [a, b, c] = arr;\n// a: number (1), b: string (''), c : boolean (true)\n</pre> <p>The canonical example of destructuring is swapping:</p> <pre class=\"highlight\" data-language=\"javascript\">var a = 1, b = 2;\n[a, b] = [b, a];\n// a = 2, b = 1\n</pre> <h2>Destructuring and Type Checks</h2> <p>Flow can verify that any destructuring in your code is type-safe.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nvar arr = [1, '', 'Hello', true];\n// If you only care about some of the return values, you can skip some\n// elements with , ,\nvar [a, b, ,c] = arr;\n// a: number (1), b: string (''), c : boolean (true)\nvar z: number = a * c;\n</pre> <p>Above we have a four (4) element array <code>arr</code> (actually a <a href=\"arrays#tuples\"><code>tuple</code></a>) . And then we destructure that array into three (3) variables, <code>a</code>, <code>b</code>, <code>c</code>. However, we then try to multiply <code>a</code> (a <code>number</code>), and <code>c</code> (a <code>boolean</code>). Flow catches this.</p> <pre class=\"highlight\" data-language=\"bbcode\">/tmp/flow/f.js:2:28,31: boolean\nThis type is incompatible with\n  /tmp/flow/f.js:5:17,21: number\n\nFound 1 error\n</pre> <h2>Another Example</h2> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nvar {x, y, ...o} = {x: '', y: 3, o: {z: false} }\n// x: string, y: number, o: {z: boolean}\nvar z: number = o;\n</pre> <pre class=\"highlight\" data-language=\"bbcode\">/tmp/flow/f.js:3:5,16: object pattern\nThis type is incompatible with\n  /tmp/flow/f.js:5:8,13: number\n\nFound 1 errors\n</pre> <p><code>o</code> has been destructed as an object that contains a boolean value. That cannot be assigned to a number.</p>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/destructuring.html\" class=\"_attribution-link\">http://flowtype.org/docs/destructuring.html</a>\n  </p>\n</div>\n","union-intersection-types":"<h1> Union and Intersection Types </h1>    <p>Flow adds support for both union and intersection types. A union type allows for a value to be one of the input types.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nvar x: number | string = 0;\n</pre> <p><code>x</code> can be either a <code>number</code> or a <code>string</code>. A default value can even be provided of one of those two types.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\ndeclare var f: ((x: number) =&gt; void) &amp; ((x: string) =&gt; void);\nf('');\n</pre> <blockquote> <p>NOTE</p> <p>Parentheses are important. Flow will not type-check correctly if you leave out the outer parenthesis on each of the function declarations on <code>f</code>.</p> </blockquote> <p>We are intersecting <code>function</code> here. A call to <code>f</code> has to be with a <code>number</code> or <code>string</code>. Intersections are well-suited to mimic function overloading.</p> <blockquote> <p>NOTE</p> <p>Not all intersection types make sense. For example, no value has type <code>number &amp; string</code> since there is no value that can have both of those types.</p> </blockquote> <h2>Syntax</h2> <ul> <li>Union: <code>&lt;type 1&gt; | &lt;type 2&gt;  ... | &lt;type n&gt;</code>\n</li> <li>Intersection: <code>&lt;type 1&gt; &amp; &lt;type 2&gt; ... &amp; &lt;type n&gt;</code>\n</li> </ul> <h2>Union Example</h2> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nclass A {}\nclass B {}\nclass C {}\n\nvar x: A | B | number | C = new C();\nx = 3;\nx = new B();\nx = true; // Flow will error here\n</pre> <p><code>x</code> is the union of <code>A</code>, <code>B</code>, <code>number</code> and <code>C</code>. So <code>x</code> can be assigned to any of those types. It cannot, however, be assigned a <code>boolean</code>.</p> <pre class=\"highlight\" data-language=\"bbcode\">/tmp/flow/f.js:9:5,8: boolean\nThis type is incompatible with\n  /tmp/flow/f.js:2:7,7: A\n\n/tmp/flow/f.js:9:5,8: boolean\nThis type is incompatible with\n  /tmp/flow/f.js:3:7,7: B\n\n/tmp/flow/f.js:9:5,8: boolean\nThis type is incompatible with\n  /tmp/flow/f.js:4:7,7: C\n\n/tmp/flow/f.js:9:5,8: boolean\nThis type is incompatible with\n  /tmp/flow/f.js:6:16,21: number\n</pre> <h2>Intersection Example</h2> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nclass Foo {}\nclass Bar {}\ndeclare var f: ((x: Foo) =&gt; void) &amp; ((x: Bar) =&gt; void);\nf(new Foo());\nf(true); // Flow will error here.\n</pre> <p><code>f</code> is intersected on <code>function</code> that take a <code>Foo</code> or <code>Bar</code>. Trying to pass in a <code>boolean</code> will cause a type error.</p> <pre class=\"highlight\" data-language=\"bbcode\">/tmp/flow/f.js:6:3,6: boolean\nThis type is incompatible with\n  /tmp/flow/f.js:2:7,9: Foo\n\n/tmp/flow/f.js:6:3,6: boolean\nThis type is incompatible with\n  /tmp/flow/f.js:3:7,9: Bar\n</pre>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/union-intersection-types.html\" class=\"_attribution-link\">http://flowtype.org/docs/union-intersection-types.html</a>\n  </p>\n</div>\n","dynamic-type-tests":"<h1> Dynamic Type Tests </h1>    <p>Flow understands many idiomatic constructs used to determine the type of a value at runtime, and incorporates that knowledge into its static analysis.</p> <p>There are several dynamic type tests (predicates) on local variables that Flow recognizes and uses to refine types. Refining a type with a predicate means narrowing the original type with the type satisfied by values satisfying the predicate.</p> <p>Type tests can occur in <code>if</code> and <code>switch</code> statements, the test block in loop constructs like <code>for</code>, <code>for-in</code>, <code>for-of</code>, and <code>do-while</code>, conditional expressions (ternary statements), and inline logical expressions like <code>a &amp;&amp;\na.b</code>.</p> <h3>Maybe, Null, and Undefined</h3> <pre class=\"highlight\" data-language=\"js\">function maybe_test(x: ?string): string {\n  if (x == null) {\n    // The condition will pass if `x` is `null` or `undefined`.\n    return x;\n  } else {\n    // In this branch, `x` must be a string.\n    return x;\n  }\n}\n\nfunction null_undefined_tests(x: ?string): string {\n  if (x === null) {\n    // The condition will pass if `x` is `null`.\n    return x;\n  } else if (x === undefined) {\n    // The condition will pass if `x` is `undefined`.\n    return x;\n  } else {\n    // In this branch, `x` must be a string.\n    return x;\n  }\n}</pre> <p>Read more about <a href=\"nullable-types\">Maybe Types</a>.</p> <h3>Truthiness and Existence</h3> <pre class=\"highlight\" data-language=\"js\">function boolean_truthiness(x: boolean): true {\n  if (x) {\n    // In this branch, `x` must be `true`.\n    return x;\n  } else {\n    // Flow understands that `x` must be `false` in this branch, and therefore\n    // that the expression !x must be `true`.\n    return !x;\n  }\n}\n\nfunction string_truthiness(x: string): \"\" {\n  if (x) {\n    // Flow understands that `x` can be any non-empty string in this branch.\n    return x;\n  } else {\n    // Flow understands that `x` can only be \"\" in this branch.\n    return x;\n  }\n}\n\nfunction number_truthiness(x: number): 0 {\n  if (x) {\n    // Flow understands that `x` can be any non-zero number in this branch.\n    return x;\n  } else {\n    // Flow understands that `x` can only be 0 in this branch.\n    return x;\n  }\n}\n\nfunction sketchy_null_check(x: ?string): string {\n  // Since \"\" is not truthy, we will replace \"\" with \"default\" in this function.\n  // Currently Flow does not complain about this pattern, but it's a common\n  // request which may be added in the future.\n  if (x) {\n    return x;\n  } else {\n    return \"default\";\n  }\n}</pre> <h3><code>typeof</code></h3> <p>This type test is particularly useful in conjunction with <a href=\"union-intersection-types\">union types</a>.</p> <pre class=\"highlight\" data-language=\"js\">function typeof_test(x: number | string): number {\n  if (typeof x === \"string\") {\n    // In this branch, `x` must be a string, and thus has a `length` method.\n    return x.length;\n  } else {\n    // By deduction, `x` must be a number in this branch.\n    return x;\n  }\n}</pre> <p>In JavaScript, <code>typeof null</code> is <code>\"object\"</code>, but don't worry, Flow won't let you make that common mistake. (Hint: use <code>x == null</code> instead.)</p> <pre class=\"highlight\" data-language=\"js\">function typeof_null(x: ?Object): Object {\n  if (typeof x === \"object\") {\n    return x; // x can still be null\n  } else {\n    return {};\n  }\n}</pre> <h3>Array.isArray</h3> <pre class=\"highlight\" data-language=\"js\">type NestedArray&lt;T&gt; = Array&lt;T|NestedArray&lt;T&gt;&gt;\n\nfunction flatten&lt;T&gt;(xs: NestedArray&lt;T&gt;): Array&lt;T&gt; {\n  let result = [];\n  for (let x of xs) {\n    if (Array.isArray(x)) {\n      // In this branch, `x` must be a `NestedArray&lt;T&gt;`\n      result.push(...flatten(x));\n    } else {\n      // By deduction, `x` must be a `T` in this branch.\n      result.push(x);\n    }\n  }\n  return result;\n}</pre> <h3>A instanceof B</h3> <pre class=\"highlight\" data-language=\"js\">declare function businessLogic(x: string): void;\n\nfunction myEventHandler(e: Event) {\n  // We only know that e.target is an EventTarget\n  e.target.value;\n  if (e.target instanceof HTMLInputElement) {\n    // Now we know it's an &lt;input /&gt;, with a `value` property.\n    businessLogic(e.target.value);\n  } else {\n    // error handling\n  }\n}</pre> <h3>Tagged Unions</h3> <pre class=\"highlight\" data-language=\"js\">type BinaryTree =\n  { kind: \"leaf\", value: number } |\n  { kind: \"branch\", left: BinaryTree, right: BinaryTree }\n\nfunction sumLeaves(tree: BinaryTree): number {\n  if (tree.kind === \"leaf\") {\n    return tree.value;\n  } else {\n    return sumLeaves(tree.left) + sumLeaves(tree.right);\n  }\n}</pre> <h2>Caveats</h2> <p>Flow is pessimistic about refinements. If it is possible that a refinement may become invalid, Flow will throw away the refinement. This can often happen when invoking a function that might refer to the refined value.</p> <pre class=\"highlight\" data-language=\"js\">declare function something(): void;\n\nfunction foo(x: { y: ?string }): string {\n  if (x.y) {\n    something();\n    return x.y; // error: x.y may be null/undefined\n  } else {\n    return \"default\";\n  }\n}</pre> <p>In the above code, <code>something</code> might mutate <code>x</code>, invalidating the refinement. It is unsafe to expect that <code>x.y</code> will always be a string after calling this function. It is simple to work around this, however. You can copy the object's property value to a local variable, which can't be mutated from the outside.</p> <pre class=\"highlight\" data-language=\"js\">declare function something(): void;\n\nfunction foo(x: { y: ?string }): string {\n  if (x.y) {\n    var y = x.y;\n    something();\n    return y; // OK: something couldn't have changed y\n  } else {\n    return \"default\";\n  }\n}</pre> <p>Another way to help Flow keep a refinement is to use a <code>const</code> binding.</p> <pre class=\"highlight\" data-language=\"js\">function foo(x: ?string) {\n  if (x) {\n    () =&gt; {\n      // We don't know when this function will be invoked, and `null` might be\n      // written to `x` before it is.\n      (x: string);\n    }\n  }\n\n  const const_x = x;\n  if (const_x) {\n    () =&gt; {\n      // Regardless of when this function is invoked, `null` can never be\n      // written to `const_x`, so we can keep the refinement.\n      (const_x: string);\n    }\n  }\n}</pre> <p>In some cases, Flow will throw away a refinement that is always safe to keep. In the following example, Flow doesn't have enough information to realize that <code>console.log</code> will not mutate <code>x</code>.</p> <pre class=\"highlight\" data-language=\"js\">function foo(x: { y: ?string }): string {\n  if (x.y) {\n    console.log(\"*obviously* this doesn't mutate x\");\n    return x.y; // error: Flow doesn't know that\n  } else {\n    return \"default\";\n  }\n}</pre> <p>Flow does perform a mutation analysis and where it is safe to do so, will preserve refinements after function calls which it knows do not invalidate the refinement.</p> <pre class=\"highlight\" data-language=\"js\">function bar(x: ?string): string {\n  function baz() { /* this doesn't mutate x */ }\n  if (x) {\n    baz();\n    return x; // Flow understands that `baz` can't invalidate the refinement.\n  } else {\n    return \"default\";\n  }\n}</pre>   <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/dynamic-type-tests.html\" class=\"_attribution-link\">http://flowtype.org/docs/dynamic-type-tests.html</a>\n  </p>\n</div>\n","functions":"<h1> Functions </h1>    <p>Functions are ubiquitous in JavaScript. As expected, Flow propagates types through function calls.</p> <h2>Type Annotating Functions</h2> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nfunction foo(x: string): string { return x; }\nvar x: number = foo('');\n</pre> <p>Running Flow produces the following error:</p> <pre class=\"highlight\" data-language=\"bbcode\">file.js:2:26,31: string\nThis type is incompatible with\n  file.js:3:8,13: number\n</pre> <h2>Open methods</h2> <p>In JavaScript, functions also take an implicit <code>this</code> parameter, and can therefore serve as open methods for objects that have such functions as properties: the <code>this</code> parameter is bound to whatever object the method is called on. Flow understands such behavior and propagates types through <code>this</code> as well. For example, the following code does not typecheck:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nfunction foo(x) { return this.x; }\nvar o = { x: 42, f: foo };\nvar x: string = o.f();\n</pre> <pre class=\"highlight\" data-language=\"bbcode\">file.js:3:14,15: number\nThis type is incompatible with\n  file.js:4:8,13: string\n\nfile.js:4:17,21: call of method f\nToo few arguments (expected default/rest parameters in function)\n  file.js:2:1,34: function\n</pre> <h2>Variadics</h2> <p>Functions can take optional and rest parameters, and calls to such functions are checked as expected. For example, the following code typechecks:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nfunction foo(x, y = false) { }\nfunction bar(z, ...w) { }\nfoo(0);\nbar('h', 'e', 'l', 'l', 'o');\n</pre> <p>Calls are matched against function signatures following the usual rules of argument matching while taking into account optional/rest parameters.</p> <p>When checking the body of a function, types of optional parameters are considered <a href=\"nullable-types#_\">optional</a> unless default values are provided.</p> <h3>Too Few Arguments</h3> <p>When you call a function with fewer arguments than it accepts, the <code>void</code> type will be flowed to the missing parameters. If the missing parameter does not accept values of type <code>void</code> then you will get an error.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nfunction takesANumber(x: number) {}\ntakesANumber() // Error: undefined passed to x, which expects a number\n</pre> <p>However if the missing parameter accepts values of type <code>void</code> then there will be no error.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nfunction canTakeNoArgs(a: void, b: ?number, c?: number) {}\ncanTakeNoArgs();\n</pre> <h3>Too Many Arguments</h3> <p>In JavaScript you can call a function with more arguments than it expects. Flow allows this too. However, there is an easy trick to declare a function can't take extra arguments.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nfunction takesOnlyOneNumber(x: number, ...rest: Array&lt;void&gt;) {}\ntakesOnlyOneNumber(1, 2) // Error: 2 does not have the type void\n</pre> <p>This is particularly useful when declaring overloads in lib files.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\n// The first overload matches 0 args, the second matches 1 arg, the third\n// matches 2 args\ndeclare function foo(...rest: Array&lt;void&gt;): string;\ndeclare function foo(a: number, ...rest: Array&lt;void&gt;): string;\ndeclare function foo(a: number, b: number, ...rest: Array&lt;void&gt;): string;\n</pre> <h2>Function-based type annotations</h2> <p>Since functions are first-class values in JavaScript (meaning they can be passed around, like numbers), type annotations may include function types. A function type is of the form <code>(P1: T1, .., Pn: Tn) =&gt; U</code> where each <code>Ti</code> is a parameter type, <code>U</code> is the return type, and each <code>Pi</code> is one of the following:</p> <ul> <li>an identifier <code>x</code>, suggesting a name for a regular parameter</li> <li>of the form <code>x?</code>, indicating an optional parameter</li> <li>of the form <code>...x</code>, indicating a rest parameter</li> </ul> <p>There may be at most one rest parameter, which has to appear at the end, and optional parameters must follow regular parameters.</p> <p>Furthermore, function expressions and function definitions may have parts of their types annotated inline, as seen above. For example, we may have:</p> <p><code>function foo (P1: T1, .., Pn: Tn): U { .. }</code></p> <h2>Polymorphic functions</h2> <p>Functions can be polymorphic, just like polymorphic classes.</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nfunction foo&lt;X&gt;(x: X): X { return x; }\n\nvar x: number = foo(0);\nvar y: string = foo('');\n</pre> <p>Furthermore, you may have polymorphic methods in polymorphic classes. For example, you may define a List class with a map method:</p> <pre class=\"highlight\" data-language=\"javascript\">/* @flow */\nclass List&lt;T&gt; {\n  ...\n  map&lt;U&gt;(f: (x: T) =&gt; U): List&lt;U&gt; { ... }\n}\n</pre> <p>This means that for every instantiation of <code>T</code>, there is a polymorphic method for objects of type <code>List&lt;T&gt;</code> that, for any instantiation of <code>U</code>, takes a function of type <code>(x: T) =&gt; U</code> and returns an object of type <code>List&lt;U&gt;</code>.</p> <h2>Overloading</h2> <p>Some methods, such as <code>replace()</code> in <code>String</code> and (the polymorphic method) <code>then()</code> in (the polymorphic class) <code>Promise</code>, have multiple signatures to model slightly different use cases that otherwise make sense to group into a single method.</p> <p>Flow understands such \"overloaded\" signatures and knows how to apply the correct one for a given call. In fact, the addition operator is a special case of an overloaded function that returns number in some cases and string in others, based on the types of its arguments.</p> <p>Sometimes, multiple signatures are not needed to express overloading: the signatures can be coalesced using <a href=\"union-intersection-types#_\">union types</a>. Flow provides the following syntax for union types:</p> <p><code>T1 | .. | Tn</code></p> <p>is the union of types <code>Ti</code>. Union types are available for general use.</p> <p>As specific cases, the overloaded signatures of both <code>replace()</code> in <code>String</code> and <code>then()</code> in <code>Promise</code> have been rewritten to use union types, thereby compressing a combinatorial number of signatures into one. In general this is possible whenever return types do not depend on the specific choice and combination of argument types, which is often the case in JavaScript due to lack of overloading support at run time.</p> <h3>Overloading Caution</h3> <p>Overloading is not recommended in general in a dynamic language, because it can be very confusing, and often results in performance penalties. Flow does not yet provide a way to declare overloaded signatures for definitions outside the prelude, so it is not available for general use.</p> <p>Curiously, there is no actual overloading at run time in JavaScript (since there are no static types at run time). Instead, an overloaded function is implemented by a function that accepts several possible arguments and then does a series of dynamic type tests in its body to dispatch accordingly. This has an interesting effect: since type signatures reflect the truth about implementations, it often turns out that a set of overloaded signatures can be simplified to a single signature using a union type for some parameters.</p>  <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/functions.html\" class=\"_attribution-link\">http://flowtype.org/docs/functions.html</a>\n  </p>\n</div>\n","syntax":"<h1> Syntax </h1>    <p>To bring static typing to JavaScript, Flow specifies a number of syntax extensions, which are used to describe types, annotate programs, and share types between modules.</p> <p>Flow's syntax extensions are only additions which can be easily stripped away and don't change the runtime behavior of JavaScript in any way.</p> <p>This page gives a high-level overview of the various syntax elements introduced by Flow.</p> <p>Remember that Flow has sophisticated type inference and it is often unnecessary to explicitly annotate your program with types.</p> <h2>Stripping Flow syntax</h2> <p>Before type-annotated code can run in a browser or Node, the Flow syntax must be stripped away.</p> <h3>Babel 5.x</h3> <p>Babel 5.x supports Flow's syntax extensions out of the box.</p> <h3>Babel 6.x</h3> <p>Babel 6.x introduced a plugin architecture, which makes it easier to customize to your particular flavor of JavaScript.</p> <p>To use Flow syntax with with Babel 6.x, you need to include the <a href=\"https://babeljs.io/docs/plugins/transform-flow-strip-types/\"><code>transform-flow-strip-types</code> plugin</a>.</p> <p>Another option is to use the <a href=\"https://babeljs.io/docs/plugins/preset-react/\">React preset</a> which includes Flow support in addition to React-specific plugins.</p> <h2>Comment syntax</h2> <p>Flow also supports a comment-based syntax, which makes it possible to use Flow without requiring any compilation.</p> <p>See <a href=\"http://flowtype.org/blog/2015/02/20/Flow-Comments.html\">Comment Syntax</a> for more information and examples.</p> <h2>Variable declarations</h2> <p>To specify a type for a binding introduced in a variable declaration statement, add a type annotation after the binding.</p> <pre class=\"highlight\" data-language=\"js\">var foo: string = \"Hello, World!\";</pre> <p>When declaring multiple variables at once, type annotations can be provided for each variable.</p> <pre class=\"highlight\" data-language=\"js\">var bar: number = 0,\n    baz: boolean = true;</pre> <h2>Function declarations</h2> <p>Type annotations for function parameters and the return type are supplied inline.</p> <pre class=\"highlight\" data-language=\"js\">function numVowels(word: string): number {\n  const vowels = new Set(\"aeiou\");\n  let count = 0;\n  for (let char of word)\n    if (vowels.has(char))\n      count++;\n  return count;\n}</pre> <p>Type parameters for generic functions are also provided inline.</p> <pre class=\"highlight\" data-language=\"js\">function reversed&lt;T&gt;(array: T[]): T[] {\n  let ret = [];\n  let i = array.length;\n  while (i--)\n    ret.push(array[i]);\n  return ret;\n}</pre> <p>Rest parameters should be annotated with an array type.</p> <pre class=\"highlight\" data-language=\"js\">function sum(...xs: number[]): number {\n  return xs.reduce((a,b) =&gt; a + b);\n}</pre> <p>Arrow functions also support inline annotation syntax.</p> <pre class=\"highlight\" data-language=\"js\">const flip = &lt;A,B&gt;([a,b]: [A,B]): [B,A] =&gt; [b,a];</pre> <p>See <a href=\"functions\">Functions</a> for more information and examples.</p> <h2>Class declarations</h2> <p>Type annotations for class fields are specified inside the class body. This syntax works well with the <a href=\"https://github.com/jeffmo/es-class-fields-and-static-properties\">class properties proposal</a> currently being reviewed by TC39 for inclusion in a future JavaScript standard.</p> <p>Methods can also specify types for their parameter and return types.</p> <pre class=\"highlight\" data-language=\"js\">class Point {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  move(x: number, y: number) {\n    this.x += x;\n    this.y += y;\n  }\n\n  copy(): Point {\n    return new Point(this.x, this.y);\n  }\n}</pre> <p>Type parameters for generic classes can also be specified inline.</p> <pre class=\"highlight\" data-language=\"js\">class Box&lt;T&gt; {\n  _value: T;\n\n  constructor(value: T) {\n    this._value = value;\n  }\n\n  get(): T {\n    return this._value;\n  }\n}</pre> <p>See <a href=\"classes\">Classes</a> for more information and examples.</p> <h2>Type aliases</h2> <p>Type aliases make it easy to refer to a potentially complex type by a simple name. Type aliases are completely removed during the compile step.</p> <p>See <a href=\"type-aliases\">Type Aliases</a> for more information and examples.</p> <h2>Object types</h2> <p>The type of an object specifies the type of each of its properties.</p> <pre class=\"highlight\" data-language=\"js\">type Person = {\n  name: string,\n  age: number,\n};</pre> <p>Objects types can include a callable property, which allows values of that type be called like a function.</p> <pre class=\"highlight\" data-language=\"js\">type Callable = {\n  (x: string): number,\n  foo: string,\n};</pre> <p>Object types can include an indexer property, which allows values of that type to be used like a dictionary.</p> <pre class=\"highlight\" data-language=\"js\">type Dictionary = {\n  [x: number]: string,\n  foo: string,\n}</pre> <p>See <a href=\"objects\">Objects</a> for more information and examples.</p> <h2>Function types</h2> <p>In addition to the syntax for annotating a function inline, it's possible to express the type of a function in isolation.</p> <pre class=\"highlight\" data-language=\"js\">type TimesTwo = (value: number) =&gt; number;</pre> <p>Type parameters for generic function types are specified before the parameter list.</p> <pre class=\"highlight\" data-language=\"js\">type Identity = &lt;T&gt;(x: T) =&gt; T;</pre> <p>See <a href=\"functions\">Functions</a> for more information and examples.</p> <h2>Array types</h2> <p>Array types can be specified by adding <code>[]</code> to the end of a type, or using <code>Array&lt;T&gt;</code> syntax. Note that maybe types of the short-hand syntax apply to the entire array, not the contained value type.</p> <pre class=\"highlight\" data-language=\"js\">var array_of_num: number[] = [];\nvar array_of_num_alt: Array&lt;number&gt; = [];\nvar optional_array_of_num: ?number[] = null;\nvar array_of_optional_num: Array&lt;?number&gt; = [null, 0];</pre> <p>Tuple types describe arrays holding heterogeneous values.</p> <pre class=\"highlight\" data-language=\"js\">var tuple_of_str_and_num: [string, number] = [\"Hi\", 42];</pre> <p>See <a href=\"arrays\">Arrays</a> for more information and examples.</p> <h2>Interface declarations</h2> <p>Declaring an interface creates a type that multiple classes can satisfy without being part of the same inheritance hierarchy.</p> <p>Like type aliases, interfaces are entirely erased at compile time and have no runtime presence.</p> <pre class=\"highlight\" data-language=\"js\">interface Comparable&lt;T&gt; {\n  compare(a: T, b: T): number;\n}</pre> <h2>Importing and exporting types</h2> <p>It's possible to export types defined in one file for use in another. <code>import\ntype</code> and <code>export type</code> are entirely erased at compile time and have no runtime presence.</p> <pre class=\"highlight\" data-language=\"js\"># foo.js\nexport type Foo = string;\n</pre>\n<pre class=\"highlight\" data-language=\"js\">import type { Foo } from \"./foo\";\nvar foo: Foo = \"Hello\";\n</pre> <p>See <a href=\"modules\">Modules</a> for more information and examples.</p> <h2>Destructured bindings</h2> <p>JavaScript's destructuring syntax can be used to introduce many bindings at once. Currently, type annotations must be applied to the entire pattern, not the individual bindings.</p> <pre class=\"highlight\" data-language=\"js\">var {a, b: {c}}: {a: string, b: {c: number}} = {a: \"\", b: {c: 0}};</pre> <p>See <a href=\"destructuring\">Destructuring</a> for more information and examples.</p> <h2>Typecasts</h2> <p>A typecast expression is a simple way to annotate any JavaScript expression.</p> <pre class=\"highlight\" data-language=\"js\">(1 + 1 : number);\n\nvar obj = {\n  name: (null: ?string)\n};\n\n([1, \"a\", true]: Array&lt;mixed&gt;).map(x =&gt; x);</pre> <p>See <a href=\"http://flowtype.org/blog/2015/02/18/Typecasts.html\">Typecasts</a> for more information and examples.</p>   <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/syntax.html\" class=\"_attribution-link\">http://flowtype.org/docs/syntax.html</a>\n  </p>\n</div>\n","objects":"<h1> Objects </h1>    <p>Objects can be created with object literals. The types of properties are fixed based on their initializers.</p> <pre class=\"highlight\" data-language=\"js\">// @flow\nvar o = {\n  x: 42,\n  foo(x) { this.x = x; }\n};\no.foo('hello');</pre> <p>Flow infers the type of property <code>x</code> of the object to be number since it is initialized with a <code>number</code>. The method call <code>foo()</code> on the object writes <code>string</code> to that property. As expected, running Flow produces an error.</p> <h2>Object Types</h2> <p>Object types are of the form:</p> <pre class=\"highlight\" data-language=\"javascript\">{ x1: T1; x2: T2; x3: T3;}</pre> <p>Here is an example of declaring an object type:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\nclass Foo {}\nvar obj: {a: boolean; b: string; c: Foo} = {a: true, b: \"Hi\", c: new Foo()}</pre> <p>Here is an example of Flow catching a problem with your object type:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\nclass Bar {}\nvar badObj: {a: boolean; b: string; c: Foo} = {a: true, b: \"Hi\", c: new Bar()}</pre> <h2>Reusable Object Types</h2> <p>Object types can be made reusable through the use of <a href=\"type-aliases\">type aliases</a>:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\ntype MyType = {message: string; isAwesome: boolean};\nfunction sayHello(data: MyType) {\n  console.log(data.message);\n}\n\nvar mySampleData: MyType = {message: 'Hello World', isAwesome: true};\nsayHello(mySampleData);\nsayHello({message: 'Hi', isAwesome: false});</pre> <h2>Optional properties</h2> <p>Object types can have optional properties. The following code shows how optional properties allow objects with missing properties to be typed.</p> <pre class=\"highlight\" data-language=\"js\">// @flow\nvar optObj: { a: string; b?: number } = { a: \"hello\" };</pre> <p>When optional properties are accessed, Flow tracks the fact that they could be <code>undefined</code>, and reports errors when they are used as is.</p> <pre class=\"highlight\" data-language=\"js\">optObj.b * 10 // error: undefined is incompatible with number</pre> <p>One way to avoid errors is to dynamically check that an optional property exists before using it. See <a href=\"nullable-types#_\">nullable types</a> for details.</p> <h2>Constructor Functions and Prototype Objects</h2> <p>Another way of creating objects in JavaScript is by using <code>new</code> on constructor functions. A constructor function is typically an open method that \"initializes\" some properties of <code>this</code>; and a <code>new</code> operation on such a function calls it on a freshly created object before returning it.</p> <p>Additionally, a constructor function may set various properties on its <code>prototype</code> object. These properties are typically methods, and are inherited by all objects created from that constructor function by a process known as prototype chaining.</p> <pre class=\"highlight\" data-language=\"js\">// @flow\nfunction FuncBasedClass(x) { this.x = x; }\nFuncBasedClass.prototype.f = function() { return this.x; }\n\nvar y = new FuncBasedClass(42);\nvar z: number = y.f();</pre> <p>In this code, a <code>new</code> object is created by <code>new Foo(42)</code>; this object has a property <code>x</code> initialized by <code>Foo</code> with the <code>number</code> passed to it. The object also responds to the <code>f</code> method defined in <code>Foo.prototype</code>, so <code>o.f()</code> reads <code>o.x</code> and returns it. This fits with the expectation of a <code>number</code> as expressed by the annotation at line 6, so this code typechecks.</p> <p>Furthermore, Flow ensures that an object's type can always be viewed as a subtype of its constructor's <code>prototype type</code>. (This is analogous to subtyping based on class inheritance.) This means that the following code typechecks:</p> <pre class=\"highlight\" data-language=\"js\">var anObj: FuncBasedClass = new FuncBasedClass(42);</pre> <h2>Adding properties</h2> <p>It is a common idiom in JavaScript to add properties to objects after they are created. In fact, we have already seen this idiom on several occasions above: when initializing properties of <code>this</code> properties in a constructor function; when building a constructor function's <code>prototype</code> object; when building a <code>module.exports</code> object; and so on.</p> <p>Flow supports this idiom. As far as we know, this is a type system novelty: supporting this idiom while balancing other constraints of the type system, such as sound subtyping over objects and prototypes, can be quite tricky!</p> <p>However, for a property that may be added to an object after its creation, Flow cannot guarantee the existence of that property at a particular property access operation; it can only check that its writes and reads are type- consistent. Providing such guarantees for dynamic objects would significantly complicate the analysis; this is a well-known fact (in technical terms, Flow's analysis is heap-insensitive for strong updates).</p> <p>For example, the following code typechecks:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\nfunction foo(p) { p.x = 42; }\nfunction bar(q) { return q.f(); }\n\nvar o = { };\no.f = function() { return this.x; };\n\nbar(o);\nfoo(o);</pre> <p>In this code, when <code>bar(o)</code> is called, <code>o.x</code> is undefined; only later is it initialized by <code>foo(o)</code>, but it is hard to track this fact statically.</p> <p>Fortunately, though, the following code does not typecheck:</p> <pre class=\"highlight\" data-language=\"js\">var test: string = bar(o);</pre> <p>In other words, Flow knows enough to infer that whenever the <code>x</code> property of <code>o</code> does exist, it is a number, so a <code>string</code> should not be expected.</p> <h2>Sealed object types</h2> <p>Unfortunately, supporting dynamically added properties means that Flow can miss errors where the programmer accesses a non-existent property by mistake. Thus, Flow also supports sealed object types, where accesses of non-existent properties are reported as errors.</p> <p>When object types appear as annotations, they are considered sealed. Also, non-empty object literals are considered to have sealed object types. In fact, the only cases where an object type is not sealed are when it describes an empty object literal (to be extended by adding properties to it), an object literal with <a href=\"https://github.com/sebmarkbage/ecmascript-rest-spread\">spread properties</a>, or when it describes a map (see below).</p> <p>Overall, the weaker guarantee for dynamically added properties is a small cost to pay for the huge increase in flexibility it affords. Specifically, it allows Flow to usefully type check lots of idiomatic JavaScript code, while trusting the programmer to follow the discipline of fully initializing an object before making it available, which effectively ensures that any dynamically added properties during initialization are only accessed after initialization is complete.</p> <p>In any case, for most objects you can altogether avoid adding properties dynamically, in which case you get stronger guarantees. Furthermore, as described above, object type annotations are sealed, so you can always force sealing by going through an annotation (and sealing is enforced at module boundaries).</p> <h2>Objects as Maps</h2> <p>An object can be viewed as a map from <code>string</code> to some value type by setting and getting its properties via bracket notation (i.e. dynamic accessors), instead of dot notation. Flow infers a precise value type for the map: in other words, if you only write <code>number</code> values to a map, you will read <code>number</code> values back (rather than, say, <code>any</code>).</p> <p>Such a map can be given a type of the form <code>{ [key: string]: number }</code> where <code>string</code> is the key type and <code>number</code> is the value type of the map.</p> <h3>Maps as Records</h3> <p>Viewing an object as a map does not preclude viewing it as a record. However, for such an object, the value type of the map does not interfere with the types of the properties of the record. This is potentially unsound, but we admit it because a sound design would necessarily lead to severe imprecision in the types of properties.</p> <h3>The <code>Object</code> type</h3> <p>This type describes \"any object\" and you can think of it like an <code>any</code>-flavored version of an object type.</p> <p>In JavaScript, everything is an object. Flow is a bit stricter and does not consider primitive types to be subtypes of <code>Object</code>.)</p> <pre class=\"highlight\" data-language=\"js\">(0: Object);\n(\"\": Object);\n(true: Object);\n(null: Object);\n(undefined: Object);</pre> <p>Many other types can be treated as objects, however. Naturally objects are compatible with <code>Object</code>, but so are functions and classes.</p> <pre class=\"highlight\" data-language=\"js\">({foo: \"foo\"}: Object);\n(function() {}: Object);\n(class {}: Object);\n([]: Object); // Flow does not treat arrays as objects (likely to change)</pre>   <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/objects.html\" class=\"_attribution-link\">http://flowtype.org/docs/objects.html</a>\n  </p>\n</div>\n","modules":"<h1> Modules </h1>    <p>JavaScript projects in Flow are composed of \"modules\" which are just single files that encapsulate some logic. A module can \"<strong>export</strong>\" variables/functions/classes so that other modules can make use of them. Additionally they can \"<strong>import</strong>\" variables/functions/classes from other modules.</p> <p>Flow supports both <strong>ES modules (recommended)</strong> and <strong>CommonJS modules</strong>. For an excellent explanation of how ES modules (sometimes referred to as \"ES6 Modules\") work, check out <a href=\"http://exploringjs.com/es6/ch_modules.html\">the modules chapter</a> of <a href=\"exploring%20js\">http://exploringjs.com/</a>.</p> <h2>ES Modules</h2> <p>Here's a succinct example of ES modules in action:</p> <pre class=\"highlight\" data-language=\"js\">// == `Math.js` == //\n\n// This function is exported, so it's available for other modules to import\nexport function add(num1: number, num2: number): number {\n  return num1 + num2;\n};\n\n// This function isn't exported, so it's only available in the local scope\n// of this module\nfunction sub(num1, num2) {\n  return num1 - num2;\n}\n\n// Note that we can use both exported and non-exported items within this\n// module\nvar two: number = add(1, 2);\nvar one: number = sub(2, 1);</pre> <p>Here we've defined a module by writing a file (<code>Math.js</code>). Both functions defined within this module are available for use within this file, but only <code>add()</code> can be imported by <em>other</em> modules (because it was exported).</p> <pre class=\"highlight\" data-language=\"js\">// == `Calculator.js` == //\n\nimport {add} from \"./Math.js\";\nimport {sub} from \"./Math.js\"; // Error! `sub` is not an export of Math.js\n\nvar four: number = add(2, 2);</pre> <p>Because <code>Math.js</code> exports its <code>add()</code> function, we are able to import it using an <code>import</code> statement. Similarly, because <code>Math.js</code> does <em>not</em> export its <code>sub()</code> function, attempting to import it from another module will result in an error. If we wish to import <code>sub()</code> into <code>Calculator.js</code>, we must export it from <code>Math.js</code> using the <code>export</code> keyword. Note that it is possible to export multiple things from one module by just using the <code>export</code> keyword on multiple things.</p> <h2>CommonJS Modules</h2> <p>Flow also supports CommonJS modules as well. If you're not familiar with CommonJS modules, you can read about them <a href=\"https://addyosmani.com/writing-modular-js/\">here</a> -- but note that we recommend using <a href=\"http://exploringjs.com/es6/ch_modules.html\">ES modules</a> if you need to choose between the two options.</p> <p>Here's the CommonJS version of the example given above for ES modules:</p> <pre class=\"highlight\" data-language=\"js\">// == `Math_CommonJS.js` == //\n\nfunction add(num1: number, num2: number): number {\n  return num1 + num2;\n};\n// This is how we export the `add()` function in CommonJS\nexports.add = add;\n\nfunction sub(num1, num2) {\n  return num1 - num2;\n}\n\nvar two: number = add(1, 2);\nvar one: number = sub(2, 1);</pre> <pre class=\"highlight\" data-language=\"js\">// == Calculator_CommonJS.js == //\n\nvar Math = require('./Math_CommonJS.js');\n\nvar four: number = Math.add(2, 2);\n\n// Error! `sub` is not exported from Math_CommonJS.js\nvar one: number = Math.sub(2, 1);</pre> <h3>ES Module &lt;-&gt; CommonJS Interoperability</h3> <p>Some projects start out as CommonJS and wish to migrate to ES modules incrementally (or just need to pull in legacy code that uses CommonJS). Because of this, Flow supports a set of interoperability semantics between the two kinds of module systems. Note that this interop strategy is compatible with the strategy employed by Babel 6.</p> <h4><strong>Importing from CommonJS -&gt; ES Module</strong></h4> <p>Say we have the following CommonJS module:</p> <pre class=\"highlight\" data-language=\"js\">// == CJSModule.js == //\n\nclass MyClass {}\nmodule.exports = MyClass;</pre> <p>If you wish to import <code>MyClass</code> in to an ES module, Flow models this as a <strong>default</strong> export from <code>CJSModule.js</code>:</p> <pre class=\"highlight\" data-language=\"js\">import MyClass from \"./CJSModule.js\";</pre> <p>(Note the lack of curly braces -- showing that this a <strong>\"default\"</strong> import rather than a <strong>\"named\"</strong> import)</p> <p>Now consider a different common pattern that is used in CommonJS modules:</p> <pre class=\"highlight\" data-language=\"js\">// == CJSModule_MultExports.js == //\nfunction util1() {}\nfunction util2() {}\n\nexports.util1 = util1;\nexports.util2 = util2;</pre> <p>If you wish to import 1 or both of the functions exported by <code>CJSModule_MultExports.js</code>, you can do so using named import(s):</p> <pre class=\"highlight\" data-language=\"js\">import {util1, util2} from \"./CJSModule_MultExports.js\";</pre> <p>If instead you wish to receive an object with <code>util1</code> and <code>util2</code> properties similar to what you might receive from a call to <code>require()</code>, you can do so via <code>import * as</code>:</p> <pre class=\"highlight\" data-language=\"js\">import * as MultExports from \"./CJSModule_MultExports.js\";</pre> <h4><strong>Importing from ES Module -&gt; CommonJS</strong></h4> <p>Sometimes you're in the middle of converting your project to use ES modules and you need to make a change to a legacy module that hasn't been converted yet. For this, Flow supports using <code>require()</code> to import from an ES module.</p> <p>Say we have an ES module with <strong>\"named\"</strong> exports:</p> <pre class=\"highlight\" data-language=\"js\">// == ES_NamedExports.js == //\nexport function util1() {}\nexport function util2() {}</pre> <p>You can <code>require()</code> this ES module from a CommonJS module as follows:</p> <pre class=\"highlight\" data-language=\"js\">const ES_NamedExports = require('./ES_NamedExports.js');\n\nES_NamedExports.util1();\nES_NamedExports.util2();</pre> <p>If you have an ES module that has a <strong>\"default\"</strong> export:</p> <pre class=\"highlight\" data-language=\"js\">// == ES_DefaultExport.js == //\nexport default function() {}</pre> <p>You can <code>require()</code> the function as follows:</p> <pre class=\"highlight\" data-language=\"js\">const ES_DefaultExport = require('./ES_DefaultExport.js');\n\n// Note that the default-export is stored as a property named `default`\nES_DefaultExport.default();</pre> <p>The one rough edge to this CommonJS &lt;-&gt; ES Module interoperability is the fact that <strong>\"default\"</strong> exports from an ES Module will show up as a <code>default</code> property on the object returned from <code>require()</code>.</p> <p>This is because, in ES modules, a <strong>\"default\"</strong> export is essentially just sugar for a <strong>\"named\"</strong> export whose name is <code>default</code>.</p> <hr> <hr> <hr> <h2>Module Resolution</h2> <p>For both ES modules and CommonJS modules, Flow needs to understand how to look up the name of a module on disk. For this, Flow uses the same <a href=\"https://nodejs.org/api/modules.html\">module resolution rules as Node.js</a>. In other words, you most likely don't have to learn or switch to a new module resolution system in order to use Flow.</p> <h3>Aliasing Module Names</h3> <p>In general we recommend against deviating too far from the standard module resolution algorithm, but in some advanced environments it is useful to alias a module name with some other string before Flow performs the resolution.</p> <p>For this we have the <strong><code>module.name_mapper</code></strong> config option that allows you to specify a regular expression template string and a replacement pattern that will be run on all <code>import</code>s and <code>require()</code>s in your project before trying to look things up on disk. We call these aliases \"name mappers\".</p> <p>The simplest example of a name mapper is one that will convert all references of the <code>\"Foo\"</code> module to references of the <code>\"Bar\"</code> module:</p> <p><strong><code>.flowconfig</code></strong></p> <pre class=\"highlight\" data-language=\"\">[options]\nmodule.name_mapper='^Foo$' -&gt; 'Bar'\n</pre> <p><strong><code>main.js</code></strong></p> <pre class=\"highlight\" data-language=\"javascript\">// @flow\n\n// Because the string \"Foo\" matches the name mapper above, Flow will look\n// for a module named \"Bar\" rather than \"Foo\" here.\nimport {something} from \"Foo\";\n</pre> <h3>CSS Modules with Webpack</h3> <p>A more common (and less trivial) example here is to configure Flow to understand <a href=\"https://github.com/css-modules/css-modules\">CSS Modules</a>:</p> <p><strong><code>CSSModule.js.flow</code></strong></p> <pre class=\"highlight\" data-language=\"javascript\">// @flow\n\n// CSS modules have a `className` export which is a string\ndeclare export var className: string;\n</pre> <p><strong><code>.flowconfig</code></strong></p> <pre class=\"highlight\" data-language=\"\">[options]\nmodule.name_mapper='^\\(.*\\)\\.css$' -&gt; '&lt;PROJECT_ROOT&gt;/CSSModule.js.flow'\n</pre> <p><strong>NOTE: You do not need to manually substitue anything for \"&lt;PROJECT_ROOT&gt;\".</strong> This is a string token that Flow recognizes and will automatically replace with the path to the directory of your .flowconfig file.</p> <p><strong><code>main.js</code></strong></p> <pre class=\"highlight\" data-language=\"javascript\">// @flow\n\nimport {className} from \"./SomeCSSFile.css\"; // Works!\n</pre> <p>Note that the <strong><code>module.name_mapper</code></strong> config option uses the regular expression syntax as documented <a href=\"http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp\">here</a>.</p> <hr> <hr> <hr> <h2>Type Imports &amp; Exports</h2> <p>In addition to importing and exporting runtime variables between modules, it can also be useful to import and export types as well. For this, Flow has extended the ES module <code>import</code> and <code>export</code> syntax in a couple of ways:</p> <h3><code>export type</code></h3> <p>If you wish to define a type alias or interface in a module that other modules will need access to as well, you can export it from the module using <code>export type</code>:</p> <pre class=\"highlight\" data-language=\"js\">// == User.js == //\n\nexport type UserID = number;\nexport type User = {\n  id: UserID,\n  name: string,\n};\n\ntype GuitarT = {\n  type: string,\n  color: string,\n};\n\nexport let jimiGuitar: GuitarT = {\n  type: \"Stratocaster\",\n  color: \"White\",\n};\n\nexport function getUser(id: UserID): User {\n  return {\n    id: id,\n    name: \"Jimi Hendrix\",\n    guitar: jimiGuitar,\n  };\n}</pre> <p>Here we've defined <code>UserID</code> and <code>User</code> as types in <code>User.js</code> that are exported for other modules to access.</p> <h3><code>import type</code></h3> <p>In order for another module to import these types, it must use <code>import type</code>:</p> <pre class=\"highlight\" data-language=\"js\">import type {UserID, User} from \"./User.js\";</pre> <p>When you use <code>import type</code> in a module, you are creating a local type alias to the type that you are importing from the other module. <code>import type</code> will work on type aliases, interfaces, and classes. It will not work on other kinds of variables like let/const/var because these do not represent types (they only represent values).</p> <h3><code>import typeof</code></h3> <p>If you have a value that you'd like to import the type <em>of</em>, the most straightforward option would be to import the value and then use <code>typeof</code> to get it's type:</p> <pre class=\"highlight\" data-language=\"js\">import {jimiguitar} from \"./User.js\";\n\ntype GuitarT = typeof jimiguitar;\n\nvar myGuitar: GuitarT = {\n  type: \"Gibson\",\n  color: \"Black\",\n};</pre> <p>Alternatively, you can also use the <code>import typeof</code> short-hand to make things simpler:</p> <pre class=\"highlight\" data-language=\"js\">import typeof {jimiguitar as GuitarT} from \"./User.js\";\n\nvar myGuitar: GuitarT = {\n  type: \"Gibson\",\n  color: \"Black\",\n};</pre> <hr> <hr> <hr> <h2>Missing/Required Annotations</h2> <p>Flow is able to infer most types in your program for you, but there is one restriction imposed on this rule: You must annotate the exports of a module explicitly.</p> <p>Flow requires this for 2 reasons:</p> <p>1) Placing a type annotation at the boundaries of a module reduces the amount of work Flow needs to do to infer the types that span modules across your project. This, in turn, removes a performance barrier from Flow's internal engine while typechecking your project and makes Flow much faster.</p> <p>2) In general, we've found that explicitly annotating module boundaries is a good habit to adopt because it helps document the ways in which the exports of a module are intended to be used.</p> <p>Because of this restriction, you may occasionally see an error from Flow that states that you are <code>Missing an annotation</code>. To resolve this error, simply add type annotations for the export the error points at.</p>   <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/modules.html\" class=\"_attribution-link\">http://flowtype.org/docs/modules.html</a>\n  </p>\n</div>\n","declarations":"<h1> Declarations </h1>    <p>Sometimes we just want to <em>declare</em> the types of some definitions, so that code that <em>uses</em> those definitions may be typechecked, without worrying about the code that <em>implements</em> those definitions. The implementation code may simply not be available for typechecking (such as for JavaScript built-ins like <code>Math</code> or <code>Array</code>). Alternatively, the implementation code may be available but we may not want to typecheck it (yet). Declarations also enable a powerful modular approach to typechecking libraries, separating the checking of uses from the checking of implementations.</p> <p>As we shall see below, declarations can not only express types of definitions in global scope (variables, functions, classes), but also express signatures of modules.</p> <h2>Declarations should be distinct from regular code</h2> <p>Note that declarations are exclusively <em>compile-time</em> entities: they are transpiled away, so they have no effect at run time. In fact, declarations without backing implementations may cause typechecked uses to break at run time! Thus, it is important to distinguish declaration code from regular code.</p> <p>In Flow, there are two recommended styles of doing declarations: let's call them the <a href=\"#pointing-your-project-to-declarations\">\".flowconfig\"-style</a> and the <a href=\"#declaration-files\">\".js.flow\" style</a>. The styles differ in their generality and convenience, but share some important characteristics: both involve locating the declarations separately from regular code, and both use similar syntax.</p> <h2>Pointing your project to declarations</h2> <p>Let's start with the \".flowconfig\" style of doing declarations.</p> <p>In this style, declarations (see below for examples) can be made visible to an entire project by putting them in files with extension <code>.js</code> in a directory, say <code>decls</code>, and putting the following in the <code>.flowconfig</code> of the project:</p> <pre class=\"highlight\" data-language=\"js\">[libs]\ndecls</pre> <h2>Declaring definitions that should exist at run time</h2> <p>Here's a simple example, where we declare a global variable.</p> <pre class=\"highlight\" data-language=\"js\">declare var DEBUG: bool;</pre> <p>Other global definitions, like functions and classes, can similarly be declared. Note how function and method bodies are elided.</p> <pre class=\"highlight\" data-language=\"js\">declare function isLeapYear(year: string): bool;\n\ndeclare class Counter {\n  val: number;\n  incr(): void;\n}</pre> <p>Such declarations can be made visible to all modules in a project (see <a href=\"#pointing-your-project-to-declarations\">above</a>). This means that any code that uses these definitions in a typesafe manner will typecheck.</p> <pre class=\"highlight\" data-language=\"js\">if (isLeapYear('2016')) console.log('Yay!');</pre> <p>Note that it is entirely up to the programmer to ensure that declared definitions actually exist, and have the correct types.</p> <h2>Mixins</h2> <p>You can declare a class which mixes in 1 or more other classes with the <code>mixins</code> keyword. Mixing class <code>B</code> into class <code>A</code> copies <code>B</code>'s fields and methods into <code>A</code>. Note, however, that any fields or methods that <code>B</code> inherits are not copied over. Mixins are for code reuse, not for multiple inheritance.</p> <pre class=\"highlight\" data-language=\"js\">// You can mixin more than one class\ndeclare class MyClass extends Child mixins MixinA, MixinB {}\ndeclare class MixinA {\n  a: number;\n  b: number;\n}\n// Mixing in MixinB will NOT mix in MixinBase\ndeclare class MixinB extends MixinBase {}\ndeclare class MixinBase {\n  c: number;\n}\ndeclare class Child extends Base {\n  a: string;\n  c: string;\n}\ndeclare class Base {\n  b: string;\n}\n\nvar c = new MyClass();\n(c.a: number); // Both Child and MixinA provide `a`, so MixinA wins\n(c.b: number); // The same principle holds for `b`, which Child inherits\n(c.c: string); // mixins does not copy inherited properties,\n               // so `c` comes from Child</pre> <h2>Declaring types</h2> <p>It is similarly useful to declare types. Like other declarations, type declarations can also be made visible to all modules in a project.</p> <p>Declared types include type aliases and interfaces; in fact, they share the same syntax as usual types, so the <code>declare</code> keyword is superfluous.</p> <pre class=\"highlight\" data-language=\"js\">declare type Response = 'yes' | 'no' | 'maybe';\n\ndeclare interface Stack&lt;T&gt; {\n  push(item: T): void;\n  pop(): T;\n  isEmpty(): bool;\n}</pre> <h2>Declaring modules</h2> <p>Finally, modules can be declared as well. Like definitions that should exist at run time, it is up to the programmer to ensure that the declared modules actually exist at run time.</p> <p>Declaring a module consists of naming the module and declaring its exports. Of course, the exports can be variables, functions, classes, as well as type aliases and interfaces. Thus it is not surprising that they share exactly the same syntax as the declarations above, except that they are now scoped to the module, instead of globally.</p> <pre class=\"highlight\" data-language=\"js\">declare module Misc {\n  declare var DEBUG: bool;\n  declare function isLeapYear(year: string): bool;\n  declare class Counter {\n    val: number;\n    incr(): void;\n  }\n  declare type Response = 'yes' | 'no' | 'maybe';\n  declare interface Stack&lt;T&gt; {\n    push(item: T): void;\n    pop(): T;\n    isEmpty(): bool;\n  }\n}</pre> <p>Note that a declared module should have a global name. (This can sometimes be a limitation; see <a href=\"#declaration-files\">below</a>.) The global name could be any string, though: it need not be an identifier. So the following also works:</p> <pre class=\"highlight\" data-language=\"js\">declare module \"fancy-pants\" {\n  // ...\n}</pre> <p>A declared module would be looked up by the typechecker only when a file implementing that module was not found by <a href=\"modules#module-resolution\">the resolution algorithm of the module system</a>, or such a file was found but not <a href=\"new-project#typechecking-your-files\">checked</a>. For example, suppose we have the following code in a file <code>src/LookBeforeYouLeap.js</code>:</p> <pre class=\"highlight\" data-language=\"js\">// @flow\nimport { isLeapYear } from 'Misc';\nif (isLeapYear('2016')) console.log('Yay!');</pre> <p>If the import successfully resolves to (say) a file <code>src/node_modules/Misc/index.js</code> with the following code, then we would get a Flow error, since the parameter of <code>isLeapYear</code> expects a <code>number</code>.</p> <pre class=\"highlight\" data-language=\"js\">// @flow\nexport function isLeapYear(year: number): bool {\n  return (year % 4 == 0); // yeah, this is approximate\n}</pre> <p>But on the other hand, if the above file doesn't exist or we remove the <code>@flow</code> header then we would <em>not</em> get a Flow error, since the parameter of <code>isLeapYear</code> in the declared module <code>Misc</code> expects a <code>string</code>.</p> <h2>Declaration files</h2> <p>Now, let's look at a more general, and sometimes more convenient, way to declare types for modules: the \".js.flow\" style.</p> <p>The exported types of a module may be declared in a <em>declaration file</em> with the <code>.js.flow</code> extension, colocated with the corresponding <em>implementation file</em> with the <code>.js</code> extension. A declaration file for a module shadows a colocated implementation file for that module when typechecking other code that may depend on that module.</p> <p>For example, looking back at the file <code>src/LookBeforeYouLeap.js</code>, suppose it instead had the following code (note the relative-path import):</p> <pre class=\"highlight\" data-language=\"js\">// @flow\nimport { isLeapYear } from './Misc';\nif (isLeapYear('2016')) console.log('Yay!');</pre> <p>Next, suppose that <code>src/Misc.js</code> had an incompatible implementation of <code>isLeapYear</code>, just as above.</p> <pre class=\"highlight\" data-language=\"js\">// @flow\nexport function isLeapYear(year: number): bool {\n  return (year % 4 == 0); // yeah, this is approximate\n}</pre> <p>If we now create a declaration file <code>src/Misc.js.flow</code>, the declarations in it will be used instead of the code in <code>src/Misc.js</code>. Let's say we have the following declarations in <code>src/Misc.js.flow</code>. Note that the syntax for declarations in a declaration file is the same as we've seen above, except that we also write the keyword <code>export</code>, like we would in an implementation file.</p> <pre class=\"highlight\" data-language=\"js\">declare export function isLeapYear(year: string): bool;</pre> <p>What do you think will happen? Right, the <code>isLeapYear</code> call in <code>src/LookBeforeYouLeap.js</code> will typecheck.</p> <p>As this example shows, declaration files must be written with care: it is up to the programmer to ensure they are correct, otherwise they may hide type errors.</p> <p>That said, declaration files provide a very convenient way to write specifications for modular typechecking. Sometimes, the implementation code may not yet be free of type errors, but we may want to move on and come back to fixing the type errors later. Another important use of this feature is for libraries, whose implementation code may be too complex to typecheck satisfactorily, but whose clients we still want to typecheck against well-defined specifications.</p> <h2>Inlining declarations in regular code</h2> <p>As noted above, declarations should be distinct from regular code. But sometimes, it is useful to do declarations \"inline,\" as part of the source of an implementation file. <strong>Proceed with caution!</strong></p> <p>The most common use is writing \"work-in-progress\" code while ensuring that your code typechecks. In the following example, say you want to finish writing the function <code>fooList</code> without bothering to mock up its dependencies first: a function <code>foo</code> that takes a <code>number</code>, and returns a <code>string</code> and a class <code>List</code> that has a <code>map</code> method. Easy! (Just don't forget to replace the declarations with proper implementations.)</p> <pre class=\"highlight\" data-language=\"js\">declare class List&lt;T&gt; {\n  map&lt;U&gt;(f: (x: T) =&gt; U): List&lt;U&gt;;\n}\ndeclare function foo(n: number): string;\n\nfunction fooList(ns: List&lt;number&gt;): List&lt;string&gt; {\n  return ns.map(foo);\n}</pre>   <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/declarations.html\" class=\"_attribution-link\">http://flowtype.org/docs/declarations.html</a>\n  </p>\n</div>\n","classes":"<h1> Classes </h1>    <p>Classes were introduced in JavaScript to formalize the common practice of simulating class-like inheritance hierarchies in JavaScript with functions and prototypes.</p> <p>In Flow, a class may be defined using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\">standard syntax</a> extended with field declarations.</p> <pre class=\"highlight\" data-language=\"js\">class C {\n  x: string;\n  y: number;\n  constructor(x) { this.x = x; }\n  foo() { return this.x; }\n  bar(y) { this.y = y; }\n}\n\nclass D extends C {\n  foo() { return super.foo() + \"!\"; }\n  bar(y) { super.bar(y || 0); }\n\n  static qux() { return new D(\"hello\"); }\n}</pre> <p>In the code above, class <code>C</code> defines fields <code>x</code> and <code>y</code>, which are typed as <code>string</code> and <code>number</code>, respectively. <code>C</code> also defines a constructor and a few methods. class <code>D</code> then overrides those methods, and adds a static method.</p> <p>Just like other languages with classes, Flow enforces that the type of an overridden method in a superclass (e.g., <code>bar</code> in <code>C</code>) is compatible with the type of an overriding method (e.g., <code>bar</code> in <code>D</code>). This ensures that subclassing implies subtyping, i.e., the following code type checks:</p> <pre class=\"highlight\" data-language=\"js\">var c: C = new D(\"D extends C\");</pre> <h2>Type Annotations vs. Inference</h2> <h3>Inference, Locally</h3> <p>Notice that the class definitions above have no type annotations, apart from their field declarations. Flow uses type inference extensively in <em>local</em> contexts, to avoid excessive annotation (and annotating).</p> <p>In the above classes, all methods are in fact strongly typed: Flow has propagated types through method calls and field accesses to infer a static type for each method. So, for example, the following code fails to typecheck:</p> <pre class=\"highlight\" data-language=\"js\">var n: number = c.foo();  // string is incompatible with number</pre> <h3>Annotations, Globally</h3> <p>In general, type inference adds convenience and helps to keep code from becoming cluttered with redundant type annotations. But a lack of annotations can also reduce clarity - in particular, when errors occur far from their causes.</p> <p>For this reason, Flow requires exported definitions be more thoroughly annotated than ones used only locally.</p> <p>Exported classes must annotate their method signatures - parameter and return types - in addition to field declarations:</p> <pre class=\"highlight\" data-language=\"js\">class ExportC {\n  x: string;\n  y: number;\n  constructor(x: string) { this.x = x; }\n  foo(): string { return this.x; }\n  bar(y: number): void { this.y = y; }\n}\n\nclass ExportD extends ExportC {\n  foo(): string { return super.foo() + \"!\"; }\n  bar(y?: number): void { super.bar(y || 0); }\n\n  static qux(): ExportD { return new ExportD(\"hello\"); }\n}\n\nmodule.exports.C = ExportC;\nmodule.exports.D = ExportD;</pre> <h2>Structural vs. Nominal typing for Classes</h2> <p>Flow treats classes as <strong>nominal</strong> types: structurally identical classes are not interchangeable, and one class is only a subtype of another if it has been explicitly declared as a subclass using <code>extends</code>.</p> <pre class=\"highlight\" data-language=\"js\">// structurally identical to C, but nominally unrelated\nclass E {\n  x: string;\n  y: number;\n  constructor(x) { this.x = x; }\n  foo() { return this.x; }\n  bar(y) { this.y = y; }\n}\n\nvar eAsC: C = new E(\"hi\"); // nope, E is incompatible with C</pre> <p>However, <a href=\"objects\">Object</a> and Interface types are structural. Classes implement interfaces, and satisfy object shapes, on a structural basis:</p> <pre class=\"highlight\" data-language=\"js\">// class C has everything it needs to satisfy this interface\ninterface ILikeC {\n  x: string;\n  y: number;\n  foo(): string;\n  bar(y: number): void;\n}\n\nfunction takesAnILikeC(c: ILikeC): string { return c.foo(); }\n\nvar c: C = new C(\"implements ILikeC\");\n\nvar s: string = takesAnILikeC(c);</pre> <pre class=\"highlight\" data-language=\"js\">// similarly, C satisfies this object shape\ntype XY = { x: string; y: number; };\n\nfunction takesAnXY(xy: XY): number { return xy.y; }\n\nvar c: C = new C(\"satisfies XY\");\n\nvar n: number = takesAnXY(c);</pre> <h2>Polymorphic classes</h2> <p>Class definitions can be polymorphic, meaning that they can represent a family of classes of the same \"shape\" but differing only in the instantiation of their type parameters.</p> <p>Consider a polymorphic version of class <code>C</code> above:</p> <pre class=\"highlight\" data-language=\"js\">class PolyC&lt;X&gt; {\n  x: X;\n  y: number;\n  constructor(x) { this.x = x; }\n  foo() { return this.x; }\n  bar(y) { this.y = y; }\n}</pre> <p>The class <code>C</code> is polymorphic in the type parameter <code>X</code>. Flow checks that the parts of <code>C</code> which refer to <code>X</code> are correct for any instantiation of <code>X</code>.</p> <p>Thus, when class <code>InstanceD</code> extends <code>PolyC&lt;string&gt;</code>, Flow can conclude that the latter has a method with signature <code>foo(): string</code>, and (as usual) check that it is compatible with the type of <code>foo</code> in <code>InstanceD</code>.</p> <pre class=\"highlight\" data-language=\"js\">class InstanceD extends PolyC&lt;string&gt; {\n  foo() { return super.foo() + \"!\"; }\n  bar(y) { super.bar(y || 0); }\n}</pre> <h3>Bounded polymorphism</h3> <p>Type parameters can optionally specify constraints that are enforced on instantiation. Such constraints can be assumed to hold in the body of a polymorphic class definition. See <a href=\"http://flowtype.org/blog/2015/03/12/Bounded-Polymorphism.html\">this blog post on bounded polymorphism</a> for details.</p> <h2>Polymorphism and Type Parameter Variance</h2> <p>By default, polymorphic classes are invariant in their type parameters, which means that an expression of type <code>C&lt;T&gt;</code> may flow to a location typed <code>C&lt;U&gt;</code> only when <code>T</code> and <code>U</code> are simultaneously subtypes of each other.</p> <p>For example, this read/write map of values of type <code>V</code> is only compatible with another map of values whose type is <em>both</em> a subtype and supertype of <code>V</code>.</p> <pre class=\"highlight\" data-language=\"js\">class A { x: number; }\nclass B extends A { y: string; }\n\nclass ReadWriteMap&lt;K, V&gt; {\n  store: { [k:K]: V };\n  constructor() { this.store = {}; }\n  get(k: K): ?V { return this.store[k]; }\n  put(k: K, v: V): void { this.store[k] = v; }\n}\n\ndeclare var mapOfB: ReadWriteMap&lt;string, B&gt;;\n\n// error: mapOfB.get(k): A is fine, but consider mapOfB.put(k, (a: A))\nvar mapOfA: ReadWriteMap&lt;string, A&gt; = mapOfB;</pre> <p>However, a polymorphic class may specify that a given type parameter is co- or contravariant, meaning that one instance is compatible with another if one type argument is a sub- or supertype, respectively, of the other.</p> <p><strong>Covariance</strong> is useful when a type parameter only appears in output (or \"positive\") positions within a class definition:</p> <pre class=\"highlight\" data-language=\"js\">class ReadOnlyMap&lt;K, +V&gt; {\n  store: { [k:K]: V };\n  constructor(store) { this.store = store; }\n  get(k: K): ?V { return this.store[k]; }\n}\n\ndeclare var readOnlyMapOfB: ReadOnlyMap&lt;string, B&gt;;\n// ok: B is a subtype of A, and V is a covariant type param.\nvar readOnlyMapOfA: ReadOnlyMap&lt;string, A&gt; = readOnlyMapOfB;</pre> <p>Analogously, <strong>contravariance</strong> is useful when a type parameter only appears in input (or \"negative\") positions within a class definition.</p> <p>Note: type parameter variance may be specified in any polymorphic types, not just polymorphic classes.</p> <h2>This type</h2> <p>Within a class definition, the <code>this</code> type is available for use in annotations. <code>this</code> can improve the precision of certain types in the presence of inheritance.</p> <p>Intuitively, the meaning of the <code>this</code> type is as follows: consider a class <code>C</code> and a class <code>D</code> extending <code>C</code>. At runtime, the value of <code>this</code> within methods of <code>C</code> will sometimes be an instance of <code>C</code>, and sometimes an instance of <code>D</code>.</p> <p>Within the body of <code>C</code>, then, the <code>this</code> type denotes <em>both</em> <code>C</code> and <code>D</code>. More generally, the <code>this</code> type behaves exactly like a type parameter on a class, ranging over that class and all of its subclasses.</p> <p>An immediate consequence is that <code>this</code> may only appear in output (aka covariant, \"positive\") positions, if subtyping is to be preserved.</p> <p>The payoff comes in the form of improved precision in the types of superclass methods <em>from the perspective of subclasses</em>: for example, a method of <code>C</code> that returns a value of type <code>this</code> can safely be viewed as returning <code>D</code> when invoked on an instance of <code>D</code>.</p> <pre class=\"highlight\" data-language=\"js\">class ThisA {\n  x: this;                            // error: input/output position\n  foo(): this { return this; }        // ok: output position\n  bar(x: this): void { this.x = x; }  // error: input position\n}\n\nclass ThisB extends ThisA { }\n\nvar b: ThisB = (new ThisB).foo(); // ok: foo() on a ThisB returns a ThisB</pre> <h2>\n<code>Class&lt;T&gt;</code> type</h2> <p>The name of a class, used as a type annotation, represents instances of that class, not the class itself. It is often useful, however, to refer to the types of classes.</p> <p>Given a type <code>T</code> representing instances of a class <code>C</code>, the type <code>Class&lt;T&gt;</code> is the type of the class <code>C</code>.</p> <pre class=\"highlight\" data-language=\"js\">var theClass: Class&lt;C&gt; = C;\nvar anInstance = new C(\"foo\");</pre>   <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/classes.html\" class=\"_attribution-link\">http://flowtype.org/docs/classes.html</a>\n  </p>\n</div>\n","react":"<h1> React </h1>    <pre class=\"highlight\" data-language=\"js\">const React = require(\"react\");</pre> <p>React applications are composed of nested components. As React-based applications grow, these component trees and the dependencies between them become increasingly complex.</p> <p>Flow's static analysis makes building large Web apps with React safe by tracking the types of props and state. Flow understands which props are required and also supports default props.</p> <p>Currently, Flow supports components defined using the <code>React.createClass</code> factory method and those defined using JavaScript classes inheriting from <code>React.Component</code>.</p> <p>Support for stateless functional components is coming soon.</p> <h2>Defining components with the <code>createClass</code> factory</h2> <h3>PropTypes</h3> <p>React ships with PropTypes, which verify the props provided to a component. Unlike the static analysis performed by Flow, PropTypes are only checked at runtime. If your testing doesn't trigger every code path that provides props to a component, you might not notice a type error in your program.</p> <p>Flow has built-in support for PropTypes. When Flow sees a <code>createClass</code> factory that specifies PropTypes, it is able to statically verify that all elements are constructed using valid props.</p> <pre class=\"highlight\" data-language=\"js\">const Greeter = React.createClass({\n  propTypes: {\n    name: React.PropTypes.string.isRequired,\n  },\n  render() {\n    return &lt;p&gt;Hello, {this.props.name}!&lt;/p&gt;;\n  },\n});\n\n&lt;Greeter /&gt;; // Missing `name`\n&lt;Greeter name={null} /&gt;; // `name` should be a string\n&lt;Greeter name=\"World\" /&gt;; // \"Hello, World!\"</pre> <h3>Default Props</h3> <p>Flow understands when a default value is specified via <code>getDefaultProps</code> and will not error when the prop is not provided.</p> <p>Note that it's still a good idea to specify <code>isRequired</code>, even when a default value is provided, to protect against <code>null</code> prop values. React will only use a default value if the prop value is <code>undefined</code>.</p> <pre class=\"highlight\" data-language=\"js\">const DefaultGreeter = React.createClass({\n  propTypes: {\n    name: React.PropTypes.string.isRequired,\n  },\n  getDefaultProps() {\n    return {name: \"World\"};\n  },\n  render() {\n    return &lt;p&gt;Hello, {this.props.name}!&lt;/p&gt;;\n  },\n});\n\n&lt;DefaultGreeter /&gt;; // \"Hello, World!\"\n&lt;DefaultGreeter name={null} /&gt;; // `name` should still be a string\n&lt;DefaultGreeter name=\"Flow\" /&gt;; // \"Hello, Flow!\"</pre> <h3>State</h3> <p>Flow ensures that state reads and writes are consistent with the object returned from <code>getInitialState</code>.</p> <pre class=\"highlight\" data-language=\"js\">const Counter = React.createClass({\n  getInitialState() {\n    return {\n      value: 0,\n    };\n  },\n  increment() {\n    this.setState({\n      value: this.state.value + \"oops!\",\n    });\n  },\n  decrement() {\n    this.setState({\n      valu: this.state.value - 1,\n    });\n  },\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;button onClick={this.increment}&gt;+&lt;/button&gt;\n        &lt;input type=\"text\" size=\"2\" value={this.state.value} /&gt;\n        &lt;button onClick={this.decrement}&gt;-&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  },\n});</pre> <p><img src=\"http://flowtype.org/docs/flow-state.gif\" alt=\"animation\"></p> <p>## Defining components as <code>React.Component</code> subclasses</p> <p>While PropTypes are great, they are quite limited. For example, it's possible to specify that a prop is some kind of function, but not what parameters that function accepts or what kind of value it might return.</p> <p>Flow has a much richer type system which is able to express those constraints and more. With class-based components, you can specify the your components' props, default props, and state using Flow's annotation syntax.</p> <pre class=\"highlight\" data-language=\"js\">class Button extends React.Component {\n  props: {\n    title: string,\n    visited: boolean,\n    onClick: () =&gt; void,\n  };\n\n  state: {\n    display: 'static' | 'hover' | 'active';\n  };\n\n  static defaultProps = {\n    visited: false,\n  };\n\n  onMouseEnter = () =&gt; this.setState({\n    display: 'hover',\n  });\n\n  onMouseLeave = () =&gt; this.setState({\n    display: 'static',\n  });\n\n  onMouseDown = () =&gt; this.setState({\n    display: 'active',\n  });\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      display: 'static',\n    };\n  }\n\n  render() {\n    let className = 'button ' + this.state.display;\n    if (this.props.visited) {\n      className += ' visited';\n    }\n\n    return (\n      &lt;div className={className}\n        onMouseEnter={this.onMouseEnter}\n        onMouseLeave={this.onMouseLeave}\n        onMouseDown={this.onMouseDown}\n        onClick={this.props.onClick}&gt;\n        {this.props.title}\n      &lt;/div&gt;\n    );\n  }\n}\n\nfunction renderButton(container: HTMLElement, visited?: boolean) {\n  const element = (\n    &lt;Button\n      title=\"Click me!\"\n      visited={visited}\n      onClick={() =&gt; {\n        renderButton(container, true);\n      }}\n    /&gt;\n  );\n  React.render(element, container);\n}</pre> <h2>Higher-order components</h2> <pre class=\"highlight\" data-language=\"js\">type Props&lt;Config&gt; = {\n  class: ReactClass&lt;Config&gt;,\n  config: Promise&lt;Config&gt;,\n};\n\ntype State&lt;Config&gt; = {\n  config: ?Config,\n  loading: boolean,\n};\n\nclass HOC&lt;Config&gt; extends React.Component&lt;void, Props&lt;Config&gt;, State&lt;Config&gt;&gt; {\n  state: State&lt;Config&gt;;\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      config: null,\n      loading: false,\n    };\n  }\n\n  load() {\n    this.setState({loading: true});\n    this.props.config.then(config =&gt; this.setState({\n      loading: false,\n      config\n    }));\n  }\n\n  render() {\n    if (this.state.config == null) {\n      let label = this.state.loading ? \"Loading...\" : \"Load\";\n      return (\n        &lt;button disabled={this.state.loading} onClick={this.load.bind(this)}&gt;\n          {label}\n        &lt;/button&gt;\n      );\n    } else {\n      return React.createElement(\n        this.props.class,\n        this.state.config,\n      );\n    }\n  }\n}</pre>   <div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"http://flowtype.org/docs/react.html\" class=\"_attribution-link\">http://flowtype.org/docs/react.html</a>\n  </p>\n</div>\n"}