{"index":"<h1>  Phoenix  </h1>  <p>This is documentation for the Phoenix project.</p> <p>By default, Phoenix applications depend on other packages besides Phoenix itself. Below we provide a short explanation with links to their documentation for each of those projects:</p> <ul> <li>\n<p><a href=\"https://hexdocs.pm/ecto\">Ecto</a> - a language integrated query and database wrapper</p> </li> <li>\n<p><a href=\"https://hexdocs.pm/phoenix\">Phoenix</a> - the Phoenix web framework (these docs)</p> </li> <li>\n<p><a href=\"https://hexdocs.pm/phoenix_pubsub\">Phoenix Pubsub</a> - a distributed pubsub system with presence support</p> </li> <li>\n<p><a href=\"https://hexdocs.pm/phoenix_html\">Phoenix HTML</a> - conveniences for working with HTML in Phoenix</p> </li> <li>\n<p><a href=\"https://hexdocs.pm/plug\">Plug</a> - a specification and conveniences for composable modules in between web applications</p> </li> <li>\n<a href=\"https://hexdocs.pm/gettext\">Gettext</a> - Internationalization and localization through gettext </li> </ul> <p>There are also optional packages depending on your configuration:</p> <ul> <li>\n<a href=\"https://hexdocs.pm/phoenix_pubsub_redis\">Phoenix PubSub Redis</a> - use Redis to power Phoenix PubSub system </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.html</a>\n  </p>\n</div>\n","phoenix_html/phoenix.html.engine":"<h1>  Phoenix.HTML.Engine  </h1>  <p>This is an implementation of EEx.Engine that guarantees templates are HTML Safe.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_html/Phoenix.HTML.Engine.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_html/Phoenix.HTML.Engine.html</a>\n  </p>\n</div>\n","phoenix_html/phoenix.html":"<h1>  Phoenix.HTML  </h1>  <p>Helpers for working with HTML strings and templates.</p> <p>When used, it imports the given modules:</p> <ul> <li>\n<p><a href=\"phoenix.html#content\"><code class=\"inline\">Phoenix.HTML</code></a>- functions to handle HTML safety;</p> </li> <li>\n<p><a href=\"phoenix.html.tag\"><code class=\"inline\">Phoenix.HTML.Tag</code></a> - functions for generating HTML tags;</p> </li> <li>\n<p><a href=\"phoenix.html.form\"><code class=\"inline\">Phoenix.HTML.Form</code></a> - functions for working with forms;</p> </li> <li>\n<p><a href=\"phoenix.html.link\"><code class=\"inline\">Phoenix.HTML.Link</code></a> - functions for generating links and urls;</p> </li> <li>\n<a href=\"phoenix.html.format\"><code class=\"inline\">Phoenix.HTML.Format</code></a> - functions for formatting text; </li> </ul> <h2>HTML Safe</h2> <p>One of the main responsibilities of this module is to provide convenience functions for escaping and marking HTML code as safe.</p> <p>By default, data output in templates is not considered safe:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= \"&lt;hello&gt;\" %&gt;</code></pre> <p>will be shown as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&amp;lt;hello&amp;gt;</code></pre> <p>User data or data coming from the database is almost never considered safe. However, in some cases, you may want to tag it as safe and show its “raw” contents:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= raw \"&lt;hello&gt;\" %&gt;</code></pre> <p>Keep in mind most helpers will automatically escape your data and return safe content:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= tag :p, \"&lt;hello&gt;\" %&gt;</code></pre> <p>will properly output:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;p&gt;&amp;lt;hello&amp;gt;&lt;/p&gt;</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:safe/0\">safe()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Guaranteed to be safe</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:unsafe/0\">unsafe()</a> </dt> <dd class=\"summary-synopsis\">\n<p>May be safe or unsafe (i.e. it needs to be converted)</p> </dd>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#escape_javascript/1\">escape_javascript(data)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Escapes quotes (double and single), double backslashes and other</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#html_escape/1\">html_escape(safe)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Escapes the HTML entities in the given term, returning iodata</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#raw/1\">raw(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Marks the given content as raw</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#safe_to_string/1\">safe_to_string(arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a safe result into a string</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#sigil_E/2\">sigil_E(expr, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Provides <code class=\"inline\">~E</code> sigil with HTML safe EEx syntax inside source files</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sigil_e/2\">sigil_e(expr, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Provides <code class=\"inline\">~e</code> sigil with HTML safe EEx syntax inside source files</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:safe/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:safe/0\">safe</a> :: {:safe, iodata}</code></pre> <p>Guaranteed to be safe</p>  </div> <div id=\"t:unsafe/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:unsafe/0\">unsafe</a> :: <a href=\"phoenix.html.safe#t:t/0\">Phoenix.HTML.Safe.t</a></code></pre> <p>May be safe or unsafe (i.e. it needs to be converted)</p>  </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"escape_javascript/1\">  <span class=\"signature\">escape_javascript(data)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">escape_javascript(binary | <a href=\"#t:safe/0\">safe</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Escapes quotes (double and single), double backslashes and other</p> <p>This function is useful in JavaScript responses when there is a need to escape html rendered from other templates, like in the following:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$(\"#container\").append(\"&lt;%= escape_javascript(render(\"post.html\", post: @post)) %&gt;\");</code></pre>    <h3 class=\"detail-header function\" id=\"html_escape/1\">  <span class=\"signature\">html_escape(safe)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">html_escape(<a href=\"#t:unsafe/0\">unsafe</a>) :: <a href=\"#t:safe/0\">safe</a></code></pre>    <p>Escapes the HTML entities in the given term, returning iodata.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; html_escape(\"&lt;hello&gt;\")\n{:safe, \"&amp;lt;hello&amp;gt;\"}\n\niex&gt; html_escape('&lt;hello&gt;')\n{:safe, [\"&amp;lt;\", 104, 101, 108, 108, 111, \"&amp;gt;\"]}\n\niex&gt; html_escape(1)\n{:safe, \"1\"}\n\niex&gt; html_escape({:safe, \"&lt;hello&gt;\"})\n{:safe, \"&lt;hello&gt;\"}</code></pre>    <h3 class=\"detail-header function\" id=\"raw/1\">  <span class=\"signature\">raw(value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">raw(iodata | <a href=\"#t:safe/0\">safe</a>) :: <a href=\"#t:safe/0\">safe</a></code></pre>    <p>Marks the given content as raw.</p> <p>This means any HTML code inside the given string won’t be escaped.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; raw(\"&lt;hello&gt;\")\n{:safe, \"&lt;hello&gt;\"}\niex&gt; raw({:safe, \"&lt;hello&gt;\"})\n{:safe, \"&lt;hello&gt;\"}\niex&gt; raw(nil)\n{:safe, \"\"}</code></pre>    <h3 class=\"detail-header function\" id=\"safe_to_string/1\">  <span class=\"signature\">safe_to_string(arg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">safe_to_string(<a href=\"#t:safe/0\">safe</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Converts a safe result into a string.</p> <p>Fails if the result is not safe. In such cases, you can invoke <a href=\"#html_escape/1\"><code class=\"inline\">html_escape/1</code></a> or <a href=\"#raw/1\"><code class=\"inline\">raw/1</code></a> accordingly before.</p>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"sigil_E/2\">  <span class=\"signature\">sigil_E(expr, opts)</span>  </h3>  <p>Provides <code class=\"inline\">~E</code> sigil with HTML safe EEx syntax inside source files.</p> <p>Does not raise on attempts to interpolate with <code class=\"inline\">#{}</code>, but rather shows those characters literally, so it should be preferred over <code class=\"inline\">~e</code>.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~E\"\"\"\n...&gt; Hello &lt;%= \"world\" %&gt;\n...&gt; \"\"\"\n{:safe, [[[\"\" | \"Hello \"] | \"world\"] | \"\\n\"]}</code></pre>    <h3 class=\"detail-header macro\" id=\"sigil_e/2\">  <span class=\"signature\">sigil_e(expr, opts)</span>  </h3>  <p>Provides <code class=\"inline\">~e</code> sigil with HTML safe EEx syntax inside source files.</p> <p>Raises on attempts to interpolate with <code class=\"inline\">#{}</code>, so <code class=\"inline\">~E</code> should be preferred.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~e\"\"\"\n...&gt; Hello &lt;%= \"world\" %&gt;\n...&gt; \"\"\"\n{:safe, [[[\"\" | \"Hello \"] | \"world\"] | \"\\n\"]}</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_html/Phoenix.HTML.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_html/Phoenix.HTML.html</a>\n  </p>\n</div>\n","phoenix/mix.tasks.compile.phoenix":"<h1>  Mix.Tasks.Compile.Phoenix  </h1>  <p>Compiles Phoenix source files that support code reloading.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Mix.Tasks.Compile.Phoenix.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Mix.Tasks.Compile.Phoenix.html</a>\n  </p>\n</div>\n","phoenix/phoenix.codereloader":"<h1>  Phoenix.CodeReloader  </h1>  <p>A plug and module to handle automatic code reloading.</p> <p>For each request, Phoenix checks if any of the modules previously compiled requires recompilation via <code class=\"inline\">__phoenix_recompile__?/0</code> and then calls <code class=\"inline\">mix compile</code> for sources exclusive to the <code class=\"inline\">web</code> directory.</p> <p>To avoid race conditions, all code reloads are funneled through a sequential call operation.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#call/2\">call(conn, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>API used by Plug to invoke the code reloader on every request</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#init/1\">init(opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>API used by Plug to start the code reloader</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reload!/1\">reload!(endpoint)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reloads code for the current Mix project by invoking the <code class=\"inline\">:reloadable_compilers</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"call/2\">  <span class=\"signature\">call(conn, opts)</span>  </h3>  <p>API used by Plug to invoke the code reloader on every request.</p>    <h3 class=\"detail-header function\" id=\"init/1\">  <span class=\"signature\">init(opts)</span>  </h3>  <p>API used by Plug to start the code reloader.</p>    <h3 class=\"detail-header function\" id=\"reload!/1\">  <span class=\"signature\">reload!(endpoint)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reload!(module) :: :ok | {:error, binary}</code></pre>    <p>Reloads code for the current Mix project by invoking the <code class=\"inline\">:reloadable_compilers</code>.</p> <p>This is configured in your application environment like:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :your_app, YourApp.Endpoint,\n  reloadable_compilers: [:gettext, :phoenix, :elixir]</code></pre> <p>Keep in mind <code class=\"inline\">:reloadable_compilers</code> must be a subset of the <code class=\"inline\">:compilers</code> specified in <code class=\"inline\">project/0</code> in your <code class=\"inline\">mix.exs</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.CodeReloader.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.CodeReloader.html</a>\n  </p>\n</div>\n","phoenix_html/phoenix.html.form":"<h1>  Phoenix.HTML.Form  </h1>  <p>Helpers related to producing HTML forms.</p> <p>The functions in this module can be used in three distinct scenarios:</p> <ul> <li>\n<p>with changeset data - when information to populate the form comes from a changeset</p> </li> <li>\n<p>with connection data - when a form is created based on the information in the connection (aka <code class=\"inline\">Plug.Conn</code>)</p> </li> <li>without form data - when the functions are used directly, outside of a form </li> </ul> <p>We will explore all three scenarios below.</p> <h2>With changeset data</h2> <p>The entry point for defining forms in Phoenix is with the <a href=\"#form_for/4\"><code class=\"inline\">form_for/4</code></a> function. For this example, we will use <code class=\"inline\">Ecto.Changeset</code>, which integrate nicely with Phoenix forms via the <code class=\"inline\">phoenix_ecto</code> package.</p> <p>Imagine you have the following action in your controller:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def new(conn, _params) do\n  changeset = User.changeset(%User{})\n  render conn, \"new.html\", changeset: changeset\nend</code></pre> <p>where <code class=\"inline\">User.changeset/2</code> is defined as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def changeset(user, params \\\\ :empty) do\n  cast(user, params, ~w(name age), ~w())\nend</code></pre> <p>Now a <code class=\"inline\">@changeset</code> assign is available in views which we can pass to the form:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= form_for @changeset, user_path(@conn, :create), fn f -&gt; %&gt;\n  &lt;label&gt;\n    Name: &lt;%= text_input f, :name %&gt;\n  &lt;/label&gt;\n\n  &lt;label&gt;\n    Age: &lt;%= select f, :age, 18..100 %&gt;\n  &lt;/label&gt;\n\n  &lt;%= submit \"Submit\" %&gt;\n&lt;% end %&gt;</code></pre> <p><a href=\"#form_for/4\"><code class=\"inline\">form_for/4</code></a> receives the <code class=\"inline\">Ecto.Changeset</code> and converts it to a form, which is passed to the function as the argument <code class=\"inline\">f</code>. All the remaining functions in this module receive the form and automatically generate the input fields, often by extracting information from the given changeset. For example, if the user had a default value for age set, it will automatically show up as selected in the form.</p> <h2>With connection data</h2> <p><a href=\"#form_for/4\"><code class=\"inline\">form_for/4</code></a> expects as first argument any data structure that implements the <a href=\"phoenix.html.formdata\"><code class=\"inline\">Phoenix.HTML.FormData</code></a> protocol. By default, Phoenix implements this protocol for <code class=\"inline\">Plug.Conn</code>, allowing us to create forms based only on connection information.</p> <p>This is useful when you are creating forms that are not backed by any kind of data from the model layer, like a search form.</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= form_for @conn, search_path(@conn, :new), [as: :search], fn f -&gt; %&gt;\n  &lt;%= text_input f, :for %&gt;\n  &lt;%= submit \"Search\" %&gt;\n&lt;% end %&gt;</code></pre> <p><a href=\"#form_for/4\"><code class=\"inline\">form_for/4</code></a> uses the <code class=\"inline\">Plug.Conn</code> to set input values from the request parameters. In this case, the input’s value would be set to <code class=\"inline\">@conn.params[\"search\"][\"for\"]</code>.</p> <h2>Without form data</h2> <p>Sometimes we may want to generate a <a href=\"#text_input/3\"><code class=\"inline\">text_input/3</code></a> or any other tag outside of a form. The functions in this module also support such usage by simply passing an atom as first argument instead of the form.</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= text_input :user, :name, value: \"This is a prepopulated value\" %&gt;</code></pre> <h2>Nested inputs</h2> <p>If your model layer supports embedding or nested associations, you can use <code class=\"inline\">inputs_for</code> to attach nested data to the form.</p> <p>Imagine the following Ecto schemas:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  use Ecto.Schema\n\n  schema \"users\" do\n    field :name\n    embeds_one :permalink, Permalink\n  end\nend\n\ndefmodule Permalink do\n  use Ecto.Schema\n\n  embedded_schema do\n    field :url\n  end\nend</code></pre> <p>In the form, you now can:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= form_for @changeset, user_path(@conn, :create), fn f -&gt; %&gt;\n  &lt;%= text_input f, :name %&gt;\n\n  &lt;%= inputs_for f, :permalink, fn fp -&gt; %&gt;\n    &lt;%= text_input fp, :url %&gt;\n  &lt;% end %&gt;\n&lt;% end %&gt;</code></pre> <p>The default option can be given to populate the fields if none is given:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= inputs_for f, :permalink, [default: %Permalink{title: \"default\"}], fn fp -&gt; %&gt;\n  &lt;%= text_input fp, :url %&gt;\n&lt;% end %&gt;</code></pre> <p><a href=\"#inputs_for/4\"><code class=\"inline\">inputs_for/4</code></a> can be used to work with single entities or collections. When working with collections, <code class=\"inline\">:prepend</code> and <code class=\"inline\">:append</code> can be used to add entries to the collection stored in the changeset.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#__struct__/0\">__struct__()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines the Phoenix.HTML.Form struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#checkbox/3\">checkbox(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a checkbox</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#color_input/3\">color_input(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a color input</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#date_select/3\">date_select(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates select tags for date</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#datetime_select/3\">datetime_select(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates select tags for datetime</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#email_input/3\">email_input(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates an email input</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#field_id/2\">field_id(name, field)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an id of a corresponding form field</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#field_name/2\">field_name(name, field)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a name of a corresponding form field</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#field_value/3\">field_value(form, field, selected \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a value of a corresponding form field</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#file_input/3\">file_input(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a file input</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#form_for/4\">form_for(form_data, action, options \\\\ [], fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a form tag with a form builder</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#hidden_input/3\">hidden_input(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a hidden input</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#humanize/1\">humanize(atom)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an attribute/form field into its humanize version</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#input_type/3\">input_type(form, field, mapping \\\\ %{\"email\" =&gt; :email_input, \"password\" =&gt; :password_input, \"search\" =&gt; :search_input, \"url\" =&gt; :url_input})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the input type for a given field</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#input_validations/2\">input_validations(form, field)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the HTML5 validations that would apply to the given field</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#inputs_for/4\">inputs_for(form, field, options \\\\ [], fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generate a new form builder for the given parameter in form</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#label/2\">label(form, field)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a label tag</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#label/3\">label(form, field, text)</a> </dt> <dd class=\"summary-synopsis\">\n<p>See <a href=\"#label/2\"><code class=\"inline\">label/2</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#label/4\">label(form, field, text, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>See <a href=\"#label/2\"><code class=\"inline\">label/2</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#multiple_select/4\">multiple_select(form, field, options, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a select tag with the given <code class=\"inline\">options</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#number_input/3\">number_input(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a number input</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#password_input/3\">password_input(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a password input</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#radio_button/4\">radio_button(form, field, value, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a radio button</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#range_input/3\">range_input(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a range input</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reset/2\">reset(value, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a reset input to reset all the form fields to their original state</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#search_input/3\">search_input(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a search input</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#select/4\">select(form, field, options, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a select tag with the given <code class=\"inline\">options</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#submit/2\">submit(value, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a submit input to send the form</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#telephone_input/3\">telephone_input(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a telephone input</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#text_input/3\">text_input(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a text input</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#textarea/3\">textarea(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a textarea input</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#time_select/3\">time_select(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates select tags for time</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#url_input/3\">url_input(form, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates an url input</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Phoenix.HTML.Form{data: %{optional(atom) =&gt; term}, errors: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>, hidden: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>, id: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, impl: module, index: nil | non_neg_integer, model: term, name: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, options: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>, params: %{optional(binary) =&gt; term}, source: <a href=\"phoenix.html.formdata#t:t/0\">Phoenix.HTML.FormData.t</a>}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"__struct__/0\">  <span class=\"signature\">__struct__()</span>  </h3>  <p>Defines the Phoenix.HTML.Form struct.</p> <p>Its fields are:</p> <ul> <li>\n<p><code class=\"inline\">:source</code> - the data structure given to <a href=\"#form_for/4\"><code class=\"inline\">form_for/4</code></a> that implements the form data protocol</p> </li> <li>\n<p><code class=\"inline\">:impl</code> - the module with the form data protocol implementation. This is used to avoid multiple protocol dispatches.</p> </li> <li>\n<p><code class=\"inline\">:id</code> - the id to be used when generating input fields</p> </li> <li>\n<p><code class=\"inline\">:name</code> - the name to be used when generating input fields</p> </li> <li>\n<p><code class=\"inline\">:data</code> - the field used to store lookup data</p> </li> <li>\n<p><code class=\"inline\">:params</code> - the parameters associated to this form in case they were sent as part of a previous request</p> </li> <li>\n<p><code class=\"inline\">:hidden</code> - a keyword list of fields that are required for submitting the form behind the scenes as hidden inputs</p> </li> <li>\n<p><code class=\"inline\">:options</code> - a copy of the options given when creating the form via <a href=\"#form_for/4\"><code class=\"inline\">form_for/4</code></a> without any form data specific key</p> </li> <li>\n<code class=\"inline\">:errors</code> - a keyword list of errors that associated with the form </li> </ul>    <h3 class=\"detail-header function\" id=\"checkbox/3\">  <span class=\"signature\">checkbox(form, field, opts \\\\ [])</span>  </h3>  <p>Generates a checkbox.</p> <p>This function is useful for sending boolean values to the server.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Assuming form contains a User schema\ncheckbox(form, :famous)\n#=&gt; &lt;input name=\"user[famous]\" type=\"hidden\" value=\"false\"&gt;\n    &lt;input checked=\"checked\" id=\"user_famous\" name=\"user[famous]\" type=\"checkbox\" value=\"true\"&gt;</code></pre> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:checked_value</code> - the value to be sent when the checkbox is checked. Defaults to “true”</p> </li> <li>\n<p><code class=\"inline\">:unchecked_value</code> - the value to be sent then the checkbox is unchecked, Defaults to “false”</p> </li> <li>\n<code class=\"inline\">:value</code> - the value used to check if a checkbox is checked or unchecked. The default value is extracted from the form data if available </li> </ul> <p>All other options are forwarded to the underlying HTML tag.</p> <h4>Hidden fields</h4> <p>Because an unchecked checkbox is not sent to the server, Phoenix automatically generates a hidden field with the unchecked_value <em>before</em> the checkbox field to ensure the <code class=\"inline\">unchecked_value</code> is sent when the checkbox is not marked.</p>    <h3 class=\"detail-header function\" id=\"color_input/3\">  <span class=\"signature\">color_input(form, field, opts \\\\ [])</span>  </h3>  <p>Generates a color input.</p> <p>Warning: this feature isn’t available in all browsers. Check <code class=\"inline\">http://caniuse.com/#feat=input-color</code> for further informations.</p> <p>See <a href=\"#text_input/3\"><code class=\"inline\">text_input/3</code></a> for example and docs.</p>    <h3 class=\"detail-header function\" id=\"date_select/3\">  <span class=\"signature\">date_select(form, field, opts \\\\ [])</span>  </h3>  <p>Generates select tags for date.</p> <p>Check <a href=\"#datetime_select/3\"><code class=\"inline\">datetime_select/3</code></a> for more information on options and supported values.</p>    <h3 class=\"detail-header function\" id=\"datetime_select/3\">  <span class=\"signature\">datetime_select(form, field, opts \\\\ [])</span>  </h3>  <p>Generates select tags for datetime.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Assuming form contains a User schema\ndatetime_select form, :born_at\n#=&gt; &lt;select id=\"user_born_at_year\" name=\"user[born_at][year]\"&gt;...&lt;/select&gt; /\n    &lt;select id=\"user_born_at_month\" name=\"user[born_at][month]\"&gt;...&lt;/select&gt; /\n    &lt;select id=\"user_born_at_day\" name=\"user[born_at][day]\"&gt;...&lt;/select&gt; —\n    &lt;select id=\"user_born_at_hour\" name=\"user[born_at][hour]\"&gt;...&lt;/select&gt; :\n    &lt;select id=\"user_born_at_min\" name=\"user[born_at][minute]\"&gt;...&lt;/select&gt;</code></pre> <p>If you want to include the seconds field (hidden by default), pass <code class=\"inline\">second: []</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Assuming form contains a User schema\ndatetime_select form, :born_at, second: []</code></pre> <p>If you want to configure the years range:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Assuming form contains a User schema\ndatetime_select form, :born_at, year: [options: 1900..2100]</code></pre> <p>You are also able to configure <code class=\"inline\">:month</code>, <code class=\"inline\">:day</code>, <code class=\"inline\">:hour</code>, <code class=\"inline\">:minute</code> and <code class=\"inline\">:second</code>. All options given to those keys will be forwarded to the underlying select. See <a href=\"#select/4\"><code class=\"inline\">select/4</code></a> for more information.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:value</code> - the value used to select a given option. The default value is extracted from the form data if available</p> </li> <li>\n<p><code class=\"inline\">:default</code> - the default value to use when none was given in <code class=\"inline\">:value</code> and none is available in the form data</p> </li> <li>\n<p><code class=\"inline\">:year</code>, <code class=\"inline\">:month</code>, <code class=\"inline\">:day</code>, <code class=\"inline\">:hour</code>, <code class=\"inline\">:minute</code>, <code class=\"inline\">:second</code> - options passed to the underlying select. See <a href=\"#select/4\"><code class=\"inline\">select/4</code></a> for more information. The available values can be given in <code class=\"inline\">:options</code>.</p> </li> <li>\n<code class=\"inline\">:builder</code> - specify how the select can be build. It must be a function that receives a builder that should be invoked with the select name and a set of options. See builder below for more information. </li> </ul> <h4>Builder</h4> <p>The generated datetime_select can be customized at will by providing a builder option. Here is an example from EEx:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= datetime_select form, :born_at, builder: fn b -&gt; %&gt;\n  Date: &lt;%= b.(:day, []) %&gt; / &lt;%= b.(:month, []) %&gt; / &lt;%= b.(:year, []) %&gt;\n  Time: &lt;%= b.(:hour, []) %&gt; : &lt;%= b.(:minute, []) %&gt;\n&lt;% end %&gt;</code></pre> <p>Although we have passed empty lists as options (they are required), you could pass any option there and it would be given to the underlying select input.</p> <p>In practice, we recommend you to create your own helper with your default builder:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def my_datetime_select(form, field, opts \\\\ []) do\n  builder = fn b -&gt;\n    ~e\"\\\"\"\n    Date: &lt;%= b.(:day, []) %&gt; / &lt;%= b.(:month, []) %&gt; / &lt;%= b.(:year, []) %&gt;\n    Time: &lt;%= b.(:hour, []) %&gt; : &lt;%= b.(:minute, []) %&gt;\n    \"\\\"\"\n  end\n\n  datetime_select(form, field, [builder: builder] ++ opts)\nend</code></pre> <p>Then you are able to use your own datetime_select throughout your whole application.</p> <h4>Supported date values</h4> <p>The following values are supported as date:</p> <ul> <li>a map containing the <code class=\"inline\">year</code>, <code class=\"inline\">month</code> and <code class=\"inline\">day</code> keys (either as strings or atoms) </li> <li>a tuple with three elements: <code class=\"inline\">{year, month, day}</code> </li> <li>\n<code class=\"inline\">nil</code> </li> </ul> <h4>Supported time values</h4> <p>The following values are supported as time:</p> <ul> <li>a map containing the <code class=\"inline\">hour</code> and <code class=\"inline\">min</code> keys and an optional <code class=\"inline\">sec</code> key (either as strings or atoms) </li> <li>a tuple with three elements: <code class=\"inline\">{hour, min, sec}</code> </li> <li>a tuple with four elements: <code class=\"inline\">{hour, min, sec, usec}</code> </li> <li>\n<code class=\"inline\">nil</code> </li> </ul>    <h3 class=\"detail-header function\" id=\"email_input/3\">  <span class=\"signature\">email_input(form, field, opts \\\\ [])</span>  </h3>  <p>Generates an email input.</p> <p>See <a href=\"#text_input/3\"><code class=\"inline\">text_input/3</code></a> for example and docs.</p>    <h3 class=\"detail-header function\" id=\"field_id/2\">  <span class=\"signature\">field_id(name, field)</span>  </h3>  <p>Returns an id of a corresponding form field.</p> <p>The form should either be a <a href=\"phoenix.html.form#content\"><code class=\"inline\">Phoenix.HTML.Form</code></a> emitted by <code class=\"inline\">form_for</code> or an atom.</p>    <h3 class=\"detail-header function\" id=\"field_name/2\">  <span class=\"signature\">field_name(name, field)</span>  </h3>  <p>Returns a name of a corresponding form field.</p> <p>The form should either be a <a href=\"phoenix.html.form#content\"><code class=\"inline\">Phoenix.HTML.Form</code></a> emitted by <code class=\"inline\">form_for</code> or an atom.</p>    <h3 class=\"detail-header function\" id=\"field_value/3\">  <span class=\"signature\">field_value(form, field, selected \\\\ nil)</span>  </h3>  <p>Returns a value of a corresponding form field.</p> <p>The <code class=\"inline\">form</code> should either be a <a href=\"phoenix.html.form#content\"><code class=\"inline\">Phoenix.HTML.Form</code></a> emitted by <code class=\"inline\">form_for</code> or an atom.</p> <p>When a form is given, the value will be first looked up in <code class=\"inline\">params</code>, then fallback to the optional <code class=\"inline\">default</code> argument. If none are available, it will try to fetch the value from the form data.</p> <p>Always returns <code class=\"inline\">selected</code> if a given form is an atom.</p>    <h3 class=\"detail-header function\" id=\"file_input/3\">  <span class=\"signature\">file_input(form, field, opts \\\\ [])</span>  </h3>  <p>Generates a file input.</p> <p>It requires the given form to be configured with <code class=\"inline\">multipart: true</code> when invoking <a href=\"#form_for/4\"><code class=\"inline\">form_for/4</code></a>, otherwise it fails with <code class=\"inline\">ArgumentError</code>.</p> <p>See <a href=\"#text_input/3\"><code class=\"inline\">text_input/3</code></a> for example and docs.</p>    <h3 class=\"detail-header function\" id=\"form_for/4\">  <span class=\"signature\">form_for(form_data, action, options \\\\ [], fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">form_for(<a href=\"phoenix.html.formdata#t:t/0\">Phoenix.HTML.FormData.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>, (<a href=\"#t:t/0\">t</a> -&gt; <a href=\"phoenix.html#t:unsafe/0\">Phoenix.HTML.unsafe</a>)) :: <a href=\"phoenix.html#t:safe/0\">Phoenix.HTML.safe</a></code></pre>    <p>Generates a form tag with a form builder.</p> <p>See the module documentation for examples of using this function.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:as</code> - the name to be used in the form. Automatically inflected when a changeset is given</p> </li> <li>\n<p><code class=\"inline\">:method</code> - the HTTP method. If the method is not “get” nor “post”, an input tag with name <code class=\"inline\">_method</code> is generated along-side the form tag. Defaults to “post”.</p> </li> <li>\n<p><code class=\"inline\">:multipart</code> - when true, sets enctype to “multipart/form-data”. Required when uploading files</p> </li> <li>\n<p><code class=\"inline\">:csrf_token</code> - for “post” requests, the form tag will automatically include an input tag with name <code class=\"inline\">_csrf_token</code>. When set to false, this is disabled</p> </li> <li>\n<code class=\"inline\">:enforce_utf8</code> - the form will have an <code class=\"inline\">accept-charset</code> attribute set to “UTF-8” and a hidden input named <code class=\"inline\">_utf8</code> containing a unicode character to force the browser to use UTF-8 as the charset. When set to false, this is disabled. </li> </ul> <p>See <a href=\"phoenix.html.tag#form_tag/2\"><code class=\"inline\">Phoenix.HTML.Tag.form_tag/2</code></a> for more information on the options above.</p>    <h3 class=\"detail-header function\" id=\"hidden_input/3\">  <span class=\"signature\">hidden_input(form, field, opts \\\\ [])</span>  </h3>  <p>Generates a hidden input.</p> <p>See <a href=\"#text_input/3\"><code class=\"inline\">text_input/3</code></a> for example and docs.</p>    <h3 class=\"detail-header function\" id=\"humanize/1\">  <span class=\"signature\">humanize(atom)</span>  </h3>  <p>Converts an attribute/form field into its humanize version.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; humanize(:username)\n\"Username\"\niex&gt; humanize(:created_at)\n\"Created at\"\niex&gt; humanize(\"user_id\")\n\"User\"</code></pre>    <h3 class=\"detail-header function\" id=\"input_type/3\">  <span class=\"signature\">input_type(form, field, mapping \\\\ %{\"email\" =&gt; :email_input, \"password\" =&gt; :password_input, \"search\" =&gt; :search_input, \"url\" =&gt; :url_input})</span>  </h3>  <p>Gets the input type for a given field.</p> <p>If the underlying input type is a <code class=\"inline\">:text_field</code>, a mapping could be given to further inflect the input type based solely on the field name. The default mapping is:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%{\"url\"      =&gt; :url_input,\n  \"email\"    =&gt; :email_input,\n  \"search\"   =&gt; :search_input,\n  \"password\" =&gt; :password_input}</code></pre>    <h3 class=\"detail-header function\" id=\"input_validations/2\">  <span class=\"signature\">input_validations(form, field)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">input_validations(<a href=\"#t:t/0\">t</a>, atom) :: boolean</code></pre>    <p>Returns the HTML5 validations that would apply to the given field.</p>    <h3 class=\"detail-header function\" id=\"inputs_for/4\">  <span class=\"signature\">inputs_for(form, field, options \\\\ [], fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">inputs_for(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>, (<a href=\"#t:t/0\">t</a> -&gt; <a href=\"phoenix.html#t:unsafe/0\">Phoenix.HTML.unsafe</a>)) :: <a href=\"phoenix.html#t:safe/0\">Phoenix.HTML.safe</a></code></pre>    <p>Generate a new form builder for the given parameter in form.</p> <p>See the module documentation for examples of using this function.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:id</code> - the id to be used in the form, defaults to the concatenation of the given <code class=\"inline\">field</code> to the parent form id</p> </li> <li>\n<p><code class=\"inline\">:as</code> - the name to be used in the form, defaults to the concatenation of the given <code class=\"inline\">field</code> to the parent form name</p> </li> <li>\n<p><code class=\"inline\">:default</code> - the value to use if none is available</p> </li> <li>\n<p><code class=\"inline\">:prepend</code> - the values to prepend when rendering. This only applies if the field value is a list and no parameters were sent through the form.</p> </li> <li>\n<code class=\"inline\">:append</code> - the values to append when rendering. This only applies if the field value is a list and no parameters were sent through the form. </li> </ul>    <h3 class=\"detail-header function\" id=\"label/2\">  <span class=\"signature\">label(form, field)</span>  </h3>  <p>Generates a label tag.</p> <p>The form should either be a <a href=\"phoenix.html.form#content\"><code class=\"inline\">Phoenix.HTML.Form</code></a> emitted by <code class=\"inline\">form_for</code> or an atom.</p> <p>All given options are forwarded to the underlying tag. A default value is provided for <code class=\"inline\">for</code> attribute but can be overriden if you pass a value to the <code class=\"inline\">for</code> option. Text content would be inferred from <code class=\"inline\">field</code> if not specified.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Assuming form contains a User schema\nlabel(form, :name, \"Name\")\n#=&gt; &lt;label for=\"user_name\"&gt;Name&lt;/label&gt;\n\nlabel(:user, :email, \"Email\")\n#=&gt; &lt;label for=\"user_email\"&gt;Email&lt;/label&gt;\n\nlabel(:user, :email)\n#=&gt; &lt;label for=\"user_email\"&gt;Email&lt;/label&gt;\n\nlabel(:user, :email, class: \"control-label\")\n#=&gt; &lt;label for=\"user_email\" class=\"control-label\"&gt;Email&lt;/label&gt;\n\nlabel :user, :email do\n  \"E-mail Address\"\nend\n#=&gt; &lt;label for=\"user_email\"&gt;E-mail Address&lt;/label&gt;\n\nlabel :user, :email, class: \"control-label\" do\n  \"E-mail Address\"\nend\n#=&gt; &lt;label class=\"control-label\" for=\"user_email\"&gt;E-mail Address&lt;/label&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"label/3\">  <span class=\"signature\">label(form, field, text)</span>  </h3>  <p>See <a href=\"#label/2\"><code class=\"inline\">label/2</code></a>.</p>    <h3 class=\"detail-header function\" id=\"label/4\">  <span class=\"signature\">label(form, field, text, opts)</span>  </h3>  <p>See <a href=\"#label/2\"><code class=\"inline\">label/2</code></a>.</p>    <h3 class=\"detail-header function\" id=\"multiple_select/4\">  <span class=\"signature\">multiple_select(form, field, options, opts \\\\ [])</span>  </h3>  <p>Generates a select tag with the given <code class=\"inline\">options</code>.</p> <p>Values are expected to be an Enumerable containing two-item tuples (like maps and keyword lists) or any Enumerable where the element will be used both as key and value for the generated select.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Assuming form contains a User schema\nmultiple_select(form, :roles, [\"Admin\": 1, \"Power User\": 2])\n#=&gt; &lt;select id=\"user_roles\" name=\"user[roles][]\"&gt;\n    &lt;option value=\"1\"&gt;Admin&lt;/option&gt;\n    &lt;option value=\"2\"&gt;Power User&lt;/option&gt;\n    &lt;/select&gt;\n\nmultiple_select(form, :roles, [\"Admin\": 1, \"Power User\": 2], value: [1])\n#=&gt; &lt;select id=\"user_roles\" name=\"user[roles]\"&gt;\n    &lt;option value=\"1\" selected=\"selected\" &gt;Admin&lt;/option&gt;\n    &lt;option value=\"2\"&gt;Power User&lt;/option&gt;\n    &lt;/select&gt;</code></pre> <p>When working with structs, associations and embeds, you will need tell Phoenix how to extract the value out of the collection. For example, imagine <code class=\"inline\">user.roles</code> is a list of <code class=\"inline\">%Role{}</code> structs. You must call it as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">multiple_select(form, :roles, [\"Admin\": 1, \"Power User\": 2],\n                selected: Enum.map(@user.roles, &amp; &amp;1.id))</code></pre> <p>The <code class=\"inline\">:selected</code> option will mark the given IDs as selected unless the form is being resubmitted. When resubmitted, it uses the form params as values.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:value</code> - an Enum of values used to select given options.</p> </li> <li>\n<code class=\"inline\">:selected</code> - the default value to use when none was given in <code class=\"inline\">:value</code> and none was sent as parameter </li> </ul> <p>All other options are forwarded to the underlying HTML tag.</p>    <h3 class=\"detail-header function\" id=\"number_input/3\">  <span class=\"signature\">number_input(form, field, opts \\\\ [])</span>  </h3>  <p>Generates a number input.</p> <p>See <a href=\"#text_input/3\"><code class=\"inline\">text_input/3</code></a> for example and docs.</p>    <h3 class=\"detail-header function\" id=\"password_input/3\">  <span class=\"signature\">password_input(form, field, opts \\\\ [])</span>  </h3>  <p>Generates a password input.</p> <p>For security reasons, the form data and parameter values are never re-used in <a href=\"#password_input/3\"><code class=\"inline\">password_input/3</code></a>. Pass the value explicitly if you would like to set one.</p> <p>See <a href=\"#text_input/3\"><code class=\"inline\">text_input/3</code></a> for example and docs.</p>    <h3 class=\"detail-header function\" id=\"radio_button/4\">  <span class=\"signature\">radio_button(form, field, value, opts \\\\ [])</span>  </h3>  <p>Generates a radio button.</p> <p>Invoke this function for each possible value you to be sent to the server.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Assuming form contains a User schema\nradio_button(form, :role, \"admin\")\n#=&gt; &lt;input id=\"user_role_admin\" name=\"user[role]\" type=\"radio\" value=\"admin\"&gt;</code></pre> <h4>Options</h4> <p>All options are simply forwarded to the underlying HTML tag.</p>    <h3 class=\"detail-header function\" id=\"range_input/3\">  <span class=\"signature\">range_input(form, field, opts \\\\ [])</span>  </h3>  <p>Generates a range input.</p> <p>See <a href=\"#text_input/3\"><code class=\"inline\">text_input/3</code></a> for example and docs.</p>    <h3 class=\"detail-header function\" id=\"reset/2\">  <span class=\"signature\">reset(value, opts \\\\ [])</span>  </h3>  <p>Generates a reset input to reset all the form fields to their original state.</p> <p>All options are forwarded to the underlying input tag.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">reset \"Reset\"\n#=&gt; &lt;input type=\"reset\" value=\"Reset\"&gt;\n\nreset \"Reset\", class: \"btn\"\n#=&gt; &lt;input type=\"reset\" value=\"Reset\" class=\"btn\"&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"search_input/3\">  <span class=\"signature\">search_input(form, field, opts \\\\ [])</span>  </h3>  <p>Generates a search input.</p> <p>See <a href=\"#text_input/3\"><code class=\"inline\">text_input/3</code></a> for example and docs.</p>    <h3 class=\"detail-header function\" id=\"select/4\">  <span class=\"signature\">select(form, field, options, opts \\\\ [])</span>  </h3>  <p>Generates a select tag with the given <code class=\"inline\">options</code>.</p> <p>Values are expected to be an Enumerable containing two-item tuples (like a regular list or a map) or any Enumerable where the element will be used both as key and value for the generated select.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Assuming form contains a User schema\nselect(form, :age, 0..120)\n#=&gt; &lt;select id=\"user_age\" name=\"user[age]\"&gt;\n    &lt;option value=\"0\"&gt;0&lt;/option&gt;\n    ...\n    &lt;option value=\"120\"&gt;120&lt;/option&gt;\n    &lt;/select&gt;\n\nselect(form, :role, [\"Admin\": \"admin\", \"User\": \"user\"])\n#=&gt; &lt;select id=\"user_role\" name=\"user[role]\"&gt;\n    &lt;option value=\"admin\"&gt;Admin&lt;/option&gt;\n    &lt;option value=\"user\"&gt;User&lt;/option&gt;\n    &lt;/select&gt;\n\nselect(form, :role, [\"Admin\": \"admin\", \"User\": \"user\"], prompt: \"Choose your role\")\n#=&gt; &lt;select id=\"user_role\" name=\"user[role]\"&gt;\n    &lt;option value=\"\"&gt;Choose your role&lt;/option&gt;\n    &lt;option value=\"admin\"&gt;Admin&lt;/option&gt;\n    &lt;option value=\"user\"&gt;User&lt;/option&gt;\n    &lt;/select&gt;</code></pre> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:prompt</code> - an option to include at the top of the options with the given prompt text</p> </li> <li>\n<p><code class=\"inline\">:value</code> - the value used to select a given option. The default value is extracted from the form data if available</p> </li> <li>\n<code class=\"inline\">:selected</code> - the default value to use when none was given in <code class=\"inline\">:value</code> and none was sent as parameter </li> </ul> <p>All other options are forwarded to the underlying HTML tag.</p>    <h3 class=\"detail-header function\" id=\"submit/2\">  <span class=\"signature\">submit(value, opts \\\\ [])</span>  </h3>  <p>Generates a submit input to send the form.</p> <p>All options are forwarded to the underlying input tag.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">submit \"Submit\"\n#=&gt; &lt;input type=\"submit\" value=\"Submit\"&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"telephone_input/3\">  <span class=\"signature\">telephone_input(form, field, opts \\\\ [])</span>  </h3>  <p>Generates a telephone input.</p> <p>See <a href=\"#text_input/3\"><code class=\"inline\">text_input/3</code></a> for example and docs.</p>    <h3 class=\"detail-header function\" id=\"text_input/3\">  <span class=\"signature\">text_input(form, field, opts \\\\ [])</span>  </h3>  <p>Generates a text input.</p> <p>The form should either be a <a href=\"phoenix.html.form#content\"><code class=\"inline\">Phoenix.HTML.Form</code></a> emitted by <code class=\"inline\">form_for</code> or an atom.</p> <p>All given options are forwarded to the underlying input, default values are provided for id, name and value if possible.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Assuming form contains a User schema\ntext_input(form, :name)\n#=&gt; &lt;input id=\"user_name\" name=\"user[name]\" type=\"text\" value=\"\"&gt;\n\ntext_input(:user, :name)\n#=&gt; &lt;input id=\"user_name\" name=\"user[name]\" type=\"text\" value=\"\"&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"textarea/3\">  <span class=\"signature\">textarea(form, field, opts \\\\ [])</span>  </h3>  <p>Generates a textarea input.</p> <p>All given options are forwarded to the underlying input, default values are provided for id, name and textarea content if possible.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Assuming form contains a User schema\ntextarea(form, :description)\n#=&gt; &lt;textarea id=\"user_description\" name=\"user[description]\"&gt;&lt;/textarea&gt;</code></pre> <h4>New lines</h4> <p>Notice the generated textarea includes a new line after the opening tag. This is because the HTML spec says new lines after tags must be ignored and all major browser implementations do that.</p> <p>So in order to avoid new lines provided by the user from being ignored when the form is resubmitted, we automatically add a new line before the text area value.</p>    <h3 class=\"detail-header function\" id=\"time_select/3\">  <span class=\"signature\">time_select(form, field, opts \\\\ [])</span>  </h3>  <p>Generates select tags for time.</p> <p>Check <a href=\"#datetime_select/3\"><code class=\"inline\">datetime_select/3</code></a> for more information on options and supported values.</p>    <h3 class=\"detail-header function\" id=\"url_input/3\">  <span class=\"signature\">url_input(form, field, opts \\\\ [])</span>  </h3>  <p>Generates an url input.</p> <p>See <a href=\"#text_input/3\"><code class=\"inline\">text_input/3</code></a> for example and docs.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_html/Phoenix.HTML.Form.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_html/Phoenix.HTML.Form.html</a>\n  </p>\n</div>\n","phoenix/mix.tasks.phoenix.gen.channel":"<h1>  Mix.Tasks.Phoenix.Gen.Channel  </h1>  <p>Generates a Phoenix channel.</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.gen.channel Room</code></pre> <p>Accepts the module name for the channel</p> <p>The generated model will contain:</p> <ul> <li>a channel in web/channels </li> <li>a channel_test in test/channels </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#run/1\">run(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"run/1\">  <span class=\"signature\">run(args)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Gen.Channel.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Gen.Channel.html</a>\n  </p>\n</div>\n","phoenix/mix.tasks.phoenix.gen.secret":"<h1>  Mix.Tasks.Phoenix.Gen.Secret  </h1>  <p>Generates a secret and print it to the terminal.</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.gen.secret [length]</code></pre> <p>By default, mix phoenix.gen.secret generates a key 64 characters long.</p> <p>The minimum value for <code class=\"inline\">length</code> is 32.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#run/1\">run(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"run/1\">  <span class=\"signature\">run(list)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Gen.Secret.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Gen.Secret.html</a>\n  </p>\n</div>\n","phoenix_html/phoenix.html.format":"<h1>  Phoenix.HTML.Format  </h1>  <p>Helpers related to formatting text.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#text_to_html/2\">text_to_html(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns text transformed into HTML using simple formatting rules</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"text_to_html/2\">  <span class=\"signature\">text_to_html(string, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">text_to_html(<a href=\"phoenix.html#t:unsafe/0\">Phoenix.HTML.unsafe</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"phoenix.html#t:safe/0\">Phoenix.HTML.safe</a></code></pre>    <p>Returns text transformed into HTML using simple formatting rules.</p> <p>Two or more consecutive newlines <code class=\"inline\">\\n\\n</code> are considered as a paragraph and text between them is wrapped in <code class=\"inline\">&lt;p&gt;</code> tags. One newline <code class=\"inline\">\\n</code> is considered as a linebreak and a <code class=\"inline\">&lt;br&gt;</code> tag is inserted.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; text_to_html(\"Hello\\n\\nWorld\") |&gt; safe_to_string\n\"&lt;p&gt;Hello&lt;/p&gt;\\n&lt;p&gt;World&lt;/p&gt;\\n\"\n\niex&gt; text_to_html(\"Hello\\nWorld\") |&gt; safe_to_string\n\"&lt;p&gt;Hello&lt;br&gt;\\nWorld&lt;/p&gt;\\n\"\n\niex&gt; opts = [wrapper_tag: :div, attributes: [class: \"p\"]]\n...&gt; text_to_html(\"Hello\\n\\nWorld\", opts) |&gt; safe_to_string\n\"&lt;div class=\\\"p\\\"&gt;Hello&lt;/div&gt;\\n&lt;div class=\\\"p\\\"&gt;World&lt;/div&gt;\\n\"</code></pre> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:escape</code> - if <code class=\"inline\">false</code> does not html escape input (default: <code class=\"inline\">true</code>) </li> <li>\n<code class=\"inline\">:wrapper_tag</code> - tag to wrap each parapgraph (default: <code class=\"inline\">:p</code>) </li> <li>\n<code class=\"inline\">:attributes</code> - html attributes of the wrapper tag (default: <code class=\"inline\">[]</code>) </li> <li>\n<code class=\"inline\">:insert_brs</code> - if <code class=\"inline\">true</code> insert <code class=\"inline\">&lt;br&gt;</code> for single line breaks (default: <code class=\"inline\">true</code>) </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_html/Phoenix.HTML.Format.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_html/Phoenix.HTML.Format.html</a>\n  </p>\n</div>\n","phoenix_html/phoenix.html.safe":"<h1>  Phoenix.HTML.Safe <small>protocol</small>  </h1>  <p>Defines the HTML safe protocol.</p> <p>In order to promote HTML safety, Phoenix templates do not use <code class=\"inline\">Kernel.to_string/1</code> to convert data types to strings in templates. Instead, Phoenix uses this protocol which must be implemented by data structures and guarantee that a HTML safe representation is returned.</p> <p>Furthermore, this protocol relies on iodata, which provides better performance when sending or streaming data to the client.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#to_iodata/1\">to_iodata(data)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: term</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"to_iodata/1\">  <span class=\"signature\">to_iodata(data)</span>  </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_html/Phoenix.HTML.Safe.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_html/Phoenix.HTML.Safe.html</a>\n  </p>\n</div>\n","phoenix/mix.tasks.phoenix.digest":"<h1>  Mix.Tasks.Phoenix.Digest  </h1>  <p>Digests and compress static files.</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.digest\nmix phoenix.digest priv/static -o /www/public</code></pre> <p>The first argument is the path where the static files are located. The <code class=\"inline\">-o</code> option indicates the path that will be used to save the digested and compressed files.</p> <p>If no path is given, it will use <code class=\"inline\">priv/static</code> as the input and output path.</p> <p>The output folder will contain:</p> <ul> <li>the original file </li> <li>a compressed file with gzip </li> <li>a file containing the original file name and its digest </li> <li>a compressed file containing the file name and its digest </li> <li>a manifest file </li> </ul> <p>Example of generated files:</p> <ul> <li>app.js </li> <li>app.js.gz </li> <li>app-eb0a5b9302e8d32828d8a73f137cc8f0.js </li> <li>app-eb0a5b9302e8d32828d8a73f137cc8f0.js.gz </li> <li>manifest.json </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#run/1\">run(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"run/1\">  <span class=\"signature\">run(args)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Digest.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Digest.html</a>\n  </p>\n</div>\n","phoenix/mix.tasks.phoenix.gen.json":"<h1>  Mix.Tasks.Phoenix.Gen.Json  </h1>  <p>Generates a Phoenix resource.</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.gen.json User users name:string age:integer</code></pre> <p>The first argument is the module name followed by its plural name (used for resources and schema).</p> <p>The generated resource will contain:</p> <ul> <li>a schema in web/models </li> <li>a view in web/views </li> <li>a controller in web/controllers </li> <li>a migration file for the repository </li> <li>test files for generated model and controller </li> </ul> <p>If you already have a model, the generated model can be skipped with <code class=\"inline\">--no-model</code>. Read the documentation for <code class=\"inline\">phoenix.gen.model</code> for more information on attributes and namespaced resources.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#run/1\">run(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"run/1\">  <span class=\"signature\">run(args)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Gen.Json.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Gen.Json.html</a>\n  </p>\n</div>\n","phoenix/mix.tasks.phoenix.server":"<h1>  Mix.Tasks.Phoenix.Server  </h1>  <p>Starts the application by configuring all endpoints servers to run.</p> <h2>Command line options</h2> <p>This task accepts the same command-line arguments as <code class=\"inline\">run</code>. For additional information, refer to the documentation for <code class=\"inline\">Mix.Tasks.Run</code>.</p> <p>For example, to run <code class=\"inline\">phoenix.server</code> without checking dependencies:</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.server --no-deps-check</code></pre> <p>The <code class=\"inline\">--no-halt</code> flag is automatically added.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#run/1\">run(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"run/1\">  <span class=\"signature\">run(args)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Server.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Server.html</a>\n  </p>\n</div>\n","phoenix_html/phoenix.html.link":"<h1>  Phoenix.HTML.Link  </h1>  <p>Conveniences for working with links and URLs in HTML.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#button/2\">button(text, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a button that uses a regular HTML form to submit to the given URL</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#link/2\">link(text, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a link to the given URL</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"button/2\">  <span class=\"signature\">button(text, opts)</span>  </h3>  <p>Generates a button that uses a regular HTML form to submit to the given URL.</p> <p>Useful to ensure that links that change data are not triggered by search engines and other spidering software.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">button(\"hello\", to: \"/world\")\n#=&gt; &lt;form action=\"/world\" class=\"button\" method=\"post\"&gt;\n      &lt;input name=\"_csrf_token\" value=\"\"&gt;&lt;input type=\"submit\" value=\"hello\"&gt;\n    &lt;/form&gt;\n\nbutton(\"hello\", to: \"/world\", method: \"get\", class: \"btn\")\n#=&gt; &lt;form action=\"/world\" class=\"btn\" method=\"post\"&gt;\n      &lt;input type=\"submit\" value=\"hello\"&gt;\n    &lt;/form&gt;</code></pre> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:to</code> - the page to link to. This option is required</p> </li> <li>\n<p><code class=\"inline\">:method</code> - the method to use with the button. Defaults to :post.</p> </li> <li>\n<code class=\"inline\">:form</code> - the options for the form. Defaults to <code class=\"inline\">[class: \"button\", enforce_utf8: false]</code> </li> </ul> <p>All other options are forwarded to the underlying button input.</p>    <h3 class=\"detail-header function\" id=\"link/2\">  <span class=\"signature\">link(text, opts)</span>  </h3>  <p>Generates a link to the given URL.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">link(\"hello\", to: \"/world\")\n#=&gt; &lt;a href=\"/world\"&gt;hello&lt;/a&gt;\n\nlink(\"&lt;hello&gt;\", to: \"/world\")\n#=&gt; &lt;a href=\"/world\"&gt;&amp;lt;hello&amp;gt;&lt;/a&gt;\n\nlink(\"&lt;hello&gt;\", to: \"/world\", class: \"btn\")\n#=&gt; &lt;a class=\"btn\" href=\"/world\"&gt;&amp;lt;hello&amp;gt;&lt;/a&gt;\n\nlink(\"delete\", to: \"/the_world\", data: [confirm: \"Really?\"])\n#=&gt; &lt;a data-confirm=\"Really?\" href=\"/the_world\"&gt;delete&lt;/a&gt;\n\n# You can use a `do ... end` block too:\nlink to: \"/hello\" do\n  \"world\"\nend</code></pre> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:to</code> - the page to link to. This option is required</p> </li> <li>\n<p><code class=\"inline\">:method</code> - the method to use with the link. In case the method is not <code class=\"inline\">:get</code>, the link is generated inside the form which sets the proper information. In order to submit the form, JavaScript must be enabled</p> </li> <li>\n<code class=\"inline\">:form</code> - customize the underlying form when the method is not <code class=\"inline\">:get</code> </li> </ul> <p>All other options are forwarded to the underlying <code class=\"inline\">&lt;a&gt;</code> tag.</p> <h4>Data attributes</h4> <p>Data attributes are added as a keyword list passed to the <code class=\"inline\">data</code> key. The following data attributes are supported:</p> <ul> <li>\n<p><code class=\"inline\">data-submit=\"parent\"</code> - automatically used when the <code class=\"inline\">:method</code> is not <code class=\"inline\">:get</code>, this module attribute says the underlying link should submit the parent form on click</p> </li> <li>\n<code class=\"inline\">data-confirm</code> - shows a confirmation prompt before submitting the parent when <code class=\"inline\">:method</code> is not <code class=\"inline\">:get</code>. </li> </ul> <h4>JavaScript dependency</h4> <p>In order to support the data attributes above, <a href=\"phoenix.html\"><code class=\"inline\">Phoenix.HTML</code></a> relies on JavaScript. You can either load the ES5 version from <code class=\"inline\">priv/static/phoenix_html.js</code> or depend on the one at <code class=\"inline\">web/static/js/phoenix_html.js</code> written in ES6 directly from your build tool.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_html/Phoenix.HTML.Link.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_html/Phoenix.HTML.Link.html</a>\n  </p>\n</div>\n","phoenix_html/phoenix.html.formdata":"<h1>  Phoenix.HTML.FormData <small>protocol</small>  </h1>  <p>Converts a data structure into a <a href=\"phoenix.html.form\"><code class=\"inline\">Phoenix.HTML.Form</code></a> struct.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#input_type/2\">input_type(data, field)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives the given field and returns its input type (:text_input, :select, etc). Returns <code class=\"inline\">nil</code> if the type is unknown</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#input_validations/2\">input_validations(data, field)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the HTML5 validations that would apply to the given field</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_form/2\">to_form(data, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a data structure into a <a href=\"phoenix.html.form\"><code class=\"inline\">Phoenix.HTML.Form</code></a> struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_form/4\">to_form(data, form, field, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the field in the given form based on the data structure into a <a href=\"phoenix.html.form\"><code class=\"inline\">Phoenix.HTML.Form</code></a> struct</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: term</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"input_type/2\">  <span class=\"signature\">input_type(data, field)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">input_type(<a href=\"#t:t/0\">t</a>, atom) :: atom | nil</code></pre>    <p>Receives the given field and returns its input type (:text_input, :select, etc). Returns <code class=\"inline\">nil</code> if the type is unknown.</p>    <h3 class=\"detail-header function\" id=\"input_validations/2\">  <span class=\"signature\">input_validations(data, field)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">input_validations(<a href=\"#t:t/0\">t</a>, atom) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a></code></pre>    <p>Returns the HTML5 validations that would apply to the given field.</p>    <h3 class=\"detail-header function\" id=\"to_form/2\">  <span class=\"signature\">to_form(data, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_form(<a href=\"#t:t/0\">t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"phoenix.html.form#t:t/0\">Phoenix.HTML.Form.t</a></code></pre>    <p>Converts a data structure into a <a href=\"phoenix.html.form\"><code class=\"inline\">Phoenix.HTML.Form</code></a> struct.</p> <p>The options are the same options given to <code class=\"inline\">form_for/4</code>. It can be used by implementations to configure their behaviour and it must be stored in the underlying struct, with any custom field removed.</p>    <h3 class=\"detail-header function\" id=\"to_form/4\">  <span class=\"signature\">to_form(data, form, field, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_form(<a href=\"#t:t/0\">t</a>, <a href=\"phoenix.html.form#t:t/0\">Phoenix.HTML.Form.t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"phoenix.html.form#t:t/0\">Phoenix.HTML.Form.t</a></code></pre>    <p>Converts the field in the given form based on the data structure into a <a href=\"phoenix.html.form\"><code class=\"inline\">Phoenix.HTML.Form</code></a> struct.</p> <p>The options are the same options given to <code class=\"inline\">inputs_for/4</code>. It can be used by implementations to configure their behaviour and it must be stored in the underlying struct, with any custom field removed.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_html/Phoenix.HTML.FormData.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_html/Phoenix.HTML.FormData.html</a>\n  </p>\n</div>\n","phoenix_html/phoenix.html.tag":"<h1>  Phoenix.HTML.Tag  </h1>  <p>Helpers related to producing HTML tags within templates.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#content_tag/2\">content_tag(name, content)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates an HTML tag with given name, content, and attributes</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#content_tag/3\">content_tag(name, attrs, attrs)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#form_tag/2\">form_tag(action, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a form tag</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#form_tag/3\">form_tag(action, options, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a form tag with the given contents</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#tag/1\">tag(name)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates an HTML tag with the given name and options</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#tag/2\">tag(name, attrs)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"content_tag/2\">  <span class=\"signature\">content_tag(name, content)</span>  </h3>  <p>Creates an HTML tag with given name, content, and attributes.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; content_tag(:p, \"Hello\")\n{:safe, [60, \"p\", \"\", 62, \"Hello\", 60, 47, \"p\", 62]}\niex&gt; content_tag(:p, \"&lt;Hello&gt;\", class: \"test\")\n{:safe, [60, \"p\", \" class=\\\"test\\\"\", 62, \"&amp;lt;Hello&amp;gt;\", 60, 47, \"p\", 62]}\n\niex&gt; content_tag :p, class: \"test\" do\n...&gt;   \"Hello\"\n...&gt; end\n{:safe, [60, \"p\", \" class=\\\"test\\\"\", 62, \"Hello\", 60, 47, \"p\", 62]}</code></pre>    <h3 class=\"detail-header function\" id=\"content_tag/3\">  <span class=\"signature\">content_tag(name, attrs, attrs)</span>  </h3>     <h3 class=\"detail-header function\" id=\"form_tag/2\">  <span class=\"signature\">form_tag(action, opts \\\\ [])</span>  </h3>  <p>Generates a form tag.</p> <p>This function generates the <code class=\"inline\">&lt;form&gt;</code> tag without its closing part. Check <a href=\"#form_tag/3\"><code class=\"inline\">form_tag/3</code></a> for generating an enclosing tag.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">form_tag(\"/hello\")\n&lt;form action=\"/hello\" method=\"post\"&gt;\n\nform_tag(\"/hello\", method: :get)\n&lt;form action=\"/hello\" method=\"get\"&gt;</code></pre> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:method</code> - the HTTP method. If the method is not “get” nor “post”, an input tag with name <code class=\"inline\">_method</code> is generated along-side the form tag. Defaults to “post”.</p> </li> <li>\n<p><code class=\"inline\">:multipart</code> - when true, sets enctype to “multipart/form-data”. Required when uploading files</p> </li> <li>\n<p><code class=\"inline\">:csrf_token</code> - for “post” requests, the form tag will automatically include an input tag with name <code class=\"inline\">_csrf_token</code>. When set to false, this is disabled</p> </li> <li>\n<code class=\"inline\">:enforce_utf8</code> - when false, does not enforce utf8. Read below for more information </li> </ul> <p>All other options are passed to the underlying HTML tag.</p> <h4>Enforce UTF-8</h4> <p>Alhought forms provide the <code class=\"inline\">accept-charset</code> attribute, which we set to UTF-8, Internet Explorer 5 up to 8 may ignore the value of this attribute if the user chooses their browser to do so. This ends up triggering the browser to send data in a format that is not understandable by the server.</p> <p>For this reason, Phoenix automatically includes a “_utf8=✓” parameter in your forms, to force those browsers to send the data in the proper encoding. This technique has been seen in the Rails web framework and reproduced here.</p>    <h3 class=\"detail-header function\" id=\"form_tag/3\">  <span class=\"signature\">form_tag(action, options, list)</span>  </h3>  <p>Generates a form tag with the given contents.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">form_tag(\"/hello\", method: \"get\") do\n  \"Hello\"\nend\n&lt;form action=\"/hello\" method=\"get\"&gt;...Hello...&lt;/form&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"tag/1\">  <span class=\"signature\">tag(name)</span>  </h3>  <p>Creates an HTML tag with the given name and options.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; tag(:br)\n{:safe, \"&lt;br&gt;\"}\niex&gt; tag(:input, type: \"text\", name: \"user_id\")\n{:safe, \"&lt;input name=\\\"user_id\\\" type=\\\"text\\\"&gt;\"}</code></pre> <h4>Data attributes</h4> <p>In order to add custom data attributes you need to pass a tuple containing :data atom and a keyword list with data attributes’ names and values as the first element in the tag’s attributes keyword list:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; tag(:input, [{:data, [foo: \"bar\"]}, id: \"some_id\"])\n{:safe, \"&lt;input data-foo=\\\"bar\\\" id=\\\"some_id\\\"&gt;\"}</code></pre> <h4>Boolean values</h4> <p>In case an attribute contains a boolean value, its key is repeated when it is true, as expected in HTML, or the attribute is completely removed if it is false:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; tag(:audio, autoplay: true)\n{:safe, \"&lt;audio autoplay=\\\"autoplay\\\"&gt;\"}\niex&gt; tag(:audio, autoplay: false)\n{:safe, \"&lt;audio&gt;\"}</code></pre> <p>If you want the boolean attribute to be sent as is, you can explicitly convert it to a string before.</p>    <h3 class=\"detail-header function\" id=\"tag/2\">  <span class=\"signature\">tag(name, attrs)</span>  </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_html/Phoenix.HTML.Tag.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_html/Phoenix.HTML.Tag.html</a>\n  </p>\n</div>\n","phoenix/mix.tasks.phoenix.gen.presence":"<h1>  Mix.Tasks.Phoenix.Gen.Presence  </h1>  <p>Generates a Presence tracker for your application.</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.gen.presence\n\nmix phoenix.gen.presence MyPresence</code></pre> <p>The only argument is the module name of the Presence tracker, which defaults to Presence.</p> <p>A new file will be generated in:</p> <ul> <li>web/channels/presence.ex </li> </ul> <p>Where <code class=\"inline\">presence.ex</code> is the snake cased version of the module name provided.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#run/1\">run(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"run/1\">  <span class=\"signature\">run(list)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Gen.Presence.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Gen.Presence.html</a>\n  </p>\n</div>\n","phoenix/mix.tasks.phoenix.gen.model":"<h1>  Mix.Tasks.Phoenix.Gen.Model  </h1>  <p>Generates an Ecto model in your Phoenix application.</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.gen.model User users name:string age:integer</code></pre> <p>The first argument is the module name followed by its plural name (used for the schema).</p> <p>The generated model will contain:</p> <ul> <li>a schema file in web/models </li> <li>a migration file for the repository </li> </ul> <p>The generated migration can be skipped with <code class=\"inline\">--no-migration</code>.</p> <h2>Attributes</h2> <p>The resource fields are given using <code class=\"inline\">name:type</code> syntax where type are the types supported by Ecto. Omitting the type makes it default to <code class=\"inline\">:string</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.gen.model User users name age:integer</code></pre> <p>The generator also supports <code class=\"inline\">belongs_to</code> associations via references:</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.gen.model Post posts title user_id:references:users</code></pre> <p>This will result in a migration with an <code class=\"inline\">:integer</code> column of <code class=\"inline\">:user_id</code> and create an index. It will also generate the appropriate <code class=\"inline\">belongs_to</code> entry in the schema.</p> <p>Furthermore an array type can also be given if it is supported by your database, although it requires the type of the underlying array element to be given too:</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.gen.model User users nicknames:array:string</code></pre> <p>Unique columns can be automatically generated by using:</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.gen.model Post posts title:unique unique_int:integer:unique</code></pre> <p>If no data type is given, it defaults to a string.</p> <h2>Namespaced resources</h2> <p>Resources can be namespaced, for such, it is just necessary to namespace the first argument of the generator:</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.gen.model Admin.User users name:string age:integer</code></pre> <h2>binary_id</h2> <p>Generated migration can use <code class=\"inline\">binary_id</code> for schema’s primary key and its references with option <code class=\"inline\">--binary-id</code>.</p> <p>This option assumes the project was generated with the <code class=\"inline\">--binary-id</code> option, that sets up models to use <code class=\"inline\">binary_id</code> by default. If that’s not the case you can still set all your models to use <code class=\"inline\">binary_id</code> by default, by adding the following to your <code class=\"inline\">model</code> function in <code class=\"inline\">web/web.ex</code> or before the <code class=\"inline\">schema</code> declaration:</p> <pre data-language=\"elixir\"><code class=\"elixir\">@primary_key {:id, :binary_id, autogenerate: true}\n@foreign_key_type :binary_id</code></pre> <h2>Default options</h2> <p>This generator uses default options provided in the <code class=\"inline\">:generators</code> configuration of the <code class=\"inline\">:phoenix</code> application. These are the defaults:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :phoenix, :generators,\n  migration: true,\n  binary_id: false,\n  sample_binary_id: \"11111111-1111-1111-1111-111111111111\"</code></pre> <p>You can override those options per invocation by providing corresponding switches, e.g. <code class=\"inline\">--no-binary-id</code> to use normal ids despite the default configuration or <code class=\"inline\">--migration</code> to force generation of the migration.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#run/1\">run(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"run/1\">  <span class=\"signature\">run(args)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Gen.Model.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Gen.Model.html</a>\n  </p>\n</div>\n","phoenix/phoenix.controller.pipeline":"<h1>  Phoenix.Controller.Pipeline  </h1>  <p>This module implements the controller pipeline responsible for handling requests.</p> <h2>The pipeline</h2> <p>The goal of a controller is to receive a request and invoke the desired action. The whole flow of the controller is managed by a single pipeline:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule UserController do\n  use Phoenix.Controller\n  require Logger\n\n  plug :log_message, \"before action\"\n\n  def show(conn, _params) do\n    Logger.debug \"show/2\"\n    send_resp(conn, 200, \"OK\")\n  end\n\n  defp log_message(conn, msg) do\n    Logger.debug msg\n    conn\n  end\nend</code></pre> <p>When invoked, this pipeline will print:</p> <pre data-language=\"elixir\"><code class=\"elixir\">before action\nshow/2</code></pre> <p>As any other Plug pipeline, we can halt at any step by calling <code class=\"inline\">Plug.Conn.halt/1</code> (which is by default imported into controllers). If we change <code class=\"inline\">log_message/2</code> to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def log_message(conn, msg) do\n  Logger.debug msg\n  halt(conn)\nend</code></pre> <p>it will print only:</p> <pre data-language=\"elixir\"><code class=\"elixir\">before action</code></pre> <p>As the rest of the pipeline (the action and the after action plug) will never be invoked.</p> <h2>Guards</h2> <p><a href=\"#plug/2\"><code class=\"inline\">plug/2</code></a> supports guards, allowing a developer to configure a plug to only run in some particular action:</p> <pre data-language=\"elixir\"><code class=\"elixir\">plug :log_message, \"before show and edit\" when action in [:show, :edit]\nplug :log_message, \"before all but index\" when not action in [:index]</code></pre> <p>The first plug will run only when action is show or edit. The second plug will always run, except for the index action.</p> <p>Those guards work like regular Elixir guards and the only variables accessible in the guard are <code class=\"inline\">conn</code>, the <code class=\"inline\">action</code> as an atom and the <code class=\"inline\">controller</code> as an alias.</p> <h2>Controllers are plugs</h2> <p>Like routers, controllers are plugs, but they are wired to dispatch to a particular function which is called an action.</p> <p>For example, the route:</p> <pre data-language=\"elixir\"><code class=\"elixir\">get \"/users/:id\", UserController, :show</code></pre> <p>will invoke <code class=\"inline\">UserController</code> as a plug:</p> <pre data-language=\"elixir\"><code class=\"elixir\">UserController.call(conn, :show)</code></pre> <p>which will trigger the plug pipeline and which will eventually invoke the inner action plug that dispatches to the <code class=\"inline\">show/2</code> function in the <code class=\"inline\">UserController</code>.</p> <p>As controllers are plugs, they implement both <code class=\"inline\">init/1</code> and <code class=\"inline\">call/2</code>, and it also provides a function named <code class=\"inline\">action/2</code> which is responsible for dispatching the appropriate action after the plug stack (and is also overridable).</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#plug/1\">plug(plug)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stores a plug to be executed as part of the plug pipeline</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#plug/2\">plug(plug, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stores a plug with the given options to be executed as part of the plug pipeline</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"plug/1\">  <span class=\"signature\">plug(plug)</span>  </h3>  <p>Stores a plug to be executed as part of the plug pipeline.</p>    <h3 class=\"detail-header macro\" id=\"plug/2\">  <span class=\"signature\">plug(plug, opts)</span>  </h3>  <p>Stores a plug with the given options to be executed as part of the plug pipeline.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Controller.Pipeline.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Controller.Pipeline.html</a>\n  </p>\n</div>\n","phoenix/mix.tasks.phoenix.gen.html":"<h1>  Mix.Tasks.Phoenix.Gen.Html  </h1>  <p>Generates a Phoenix resource.</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix phoenix.gen.html User users name:string age:integer</code></pre> <p>The first argument is the module name followed by its plural name (used for resources and schema).</p> <p>The generated resource will contain:</p> <ul> <li>a schema in web/models </li> <li>a view in web/views </li> <li>a controller in web/controllers </li> <li>a migration file for the repository </li> <li>default CRUD templates in web/templates </li> <li>test files for generated model and controller </li> </ul> <p>The generated model can be skipped with <code class=\"inline\">--no-model</code>. Read the documentation for <code class=\"inline\">phoenix.gen.model</code> for more information on attributes and namespaced resources.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#run/1\">run(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"run/1\">  <span class=\"signature\">run(args)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Gen.Html.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Gen.Html.html</a>\n  </p>\n</div>\n","phoenix/mix.tasks.phoenix.routes":"<h1>  Mix.Tasks.Phoenix.Routes  </h1>  <p>Prints all routes for the default or a given router.</p> <pre data-language=\"elixir\"><code class=\"elixir\">$ mix phoenix.routes\n$ mix phoenix.routes MyApp.AnotherRouter</code></pre> <p>The default router is inflected from the application name unless a configuration named <code class=\"inline\">:namespace</code> is set inside your application configuration. For example, the configuration:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :my_app,\n  namespace: My.App</code></pre> <p>will exhibit the routes for <code class=\"inline\">My.App.Router</code> when this task is invoked without arguments.</p> <p>Umbrella projects do not have a default router and therefore always expect a router to be given.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#run/1\">run(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"run/1\">  <span class=\"signature\">run(args)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Routes.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Mix.Tasks.Phoenix.Routes.html</a>\n  </p>\n</div>\n","phoenix/phoenix.conntest":"<h1>  Phoenix.ConnTest  </h1>  <p>Conveniences for testing Phoenix endpoints and connection related helpers.</p> <p>You likely want to use this module or make it part of your <code class=\"inline\">ExUnit.CaseTemplate</code>. Once used, this module automatically imports all functions defined here as well as the functions in <code class=\"inline\">Plug.Conn</code>.</p> <h2>Endpoint testing</h2> <p><a href=\"phoenix.conntest#content\"><code class=\"inline\">Phoenix.ConnTest</code></a> typically works against endpoints. That’s the preferred way to test anything that your router dispatches to.</p> <pre data-language=\"elixir\"><code class=\"elixir\">conn = get build_conn(), \"/\"\nassert conn.resp_body =~ \"Welcome!\"\n\nconn = post build_conn(), \"/login\", [username: \"john\", password: \"doe\"]\nassert conn.resp_body =~ \"Logged in!\"</code></pre> <p>As in your application, the connection is also the main abstraction in testing. <code class=\"inline\">build_conn()</code> returns a new connection and functions in this module can be used to manipulate the connection before dispatching to the endpoint.</p> <p>For example, one could set the accepts header for json requests as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\">build_conn()\n|&gt; put_req_header(\"accept\", \"application/json\")\n|&gt; get(\"/\")</code></pre> <p>The endpoint being tested is accessed via the <code class=\"inline\">@endpoint</code> module attribute.</p> <h2>Controller testing</h2> <p>The functions in this module can also be used for controller testing. While endpoint testing is preferred over controller testing as a controller often depends on the pipelines invoked in the router and before, unit testing controllers may be helpful in some situations.</p> <p>For such cases, just pass an atom representing the action to dispatch:</p> <pre data-language=\"elixir\"><code class=\"elixir\">conn = get build_conn(), :index\nassert conn.resp_body =~ \"Welcome!\"</code></pre> <h2>Views testing</h2> <p>Under other circumstances, you may be testing a view or another layer that requires a connection for processing. For such cases, a connection can be created using the <a href=\"#conn/3\"><code class=\"inline\">conn/3</code></a> helper:</p> <pre data-language=\"elixir\"><code class=\"elixir\">MyApp.UserView.render \"hello.html\",\n                       conn: conn(:get, \"/\")</code></pre> <h2>Recycling</h2> <p>Browsers implement a storage by using cookies. When a cookie is set in the response, the browser stores it and sends it in the next request.</p> <p>To emulate this behaviour, this module provides the idea of recycling. The <a href=\"#recycle/1\"><code class=\"inline\">recycle/1</code></a> function receives a connection and returns a new connection, similar to the one returned by <a href=\"#conn/0\"><code class=\"inline\">conn/0</code></a> with all the response cookies from the previous connection defined as request headers. This is useful when testing multiple routes that require cookies or session to work.</p> <p>Keep in mind Phoenix will automatically recycle the connection between dispatches. This usually works out well most times but it may discard information if you are modifying the connection before the next dispatch:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># No recycling as the connection is fresh\nconn = get build_conn(), \"/\"\n\n# The connection is recycled, creating a new one behind the scenes\nconn = post conn, \"/login\"\n\n# We can also recycle manually in case we want custom headers\nconn = \n  conn\n  |&gt; recycle()\n  |&gt; put_req_header(\"x-special\", \"nice\")\n\n# No recycling as we did it explicitly\nconn = delete conn, \"/logout\"</code></pre> <p>Recycling also recycles the “accept” header.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#assert_error_sent/2\">assert_error_sent(status_int_or_atom, func)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts an error was wrapped and sent with the given status</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#build_conn/0\">build_conn()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a connection to be used in upcoming requests</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#build_conn/3\">build_conn(method, path, params_or_body \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a connection to be used in upcoming requests with a preset method, path and body</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#bypass_through/1\">bypass_through(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calls the Endpoint and bypasses Router match</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#bypass_through/3\">bypass_through(conn, router, pipelines \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calls the Endpoint and bypasses Router match</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#clear_flash/1\">clear_flash(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Clears up the flash storage</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#conn/0\">conn()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deprecated version of conn/0. Use build_conn/0 instead</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#conn/3\">conn(method, path, params_or_body \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deprecated version of conn/3. Use build_conn/3 instead</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete_req_cookie/2\">delete_req_cookie(conn, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes a request cookie</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dispatch/5\">dispatch(conn, endpoint, method, path_or_action, params_or_body \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dispatches the connection to the given endpoint</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ensure_recycled/1\">ensure_recycled(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Ensures the connection is recycled if it wasn’t already</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch_flash/1\">fetch_flash(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches the flash storage</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_flash/1\">get_flash(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the whole flash storage</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_flash/2\">get_flash(conn, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the given key from the flash storage</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#html_response/2\">html_response(conn, status)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts the given status code, that we have an html response and returns the response body if one was set or sent</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#json_response/2\">json_response(conn, status)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts the given status code, that we have an json response and returns the decoded JSON response if one was set or sent</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_flash/3\">put_flash(conn, key, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts the given value under key in the flash storage</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_req_cookie/3\">put_req_cookie(conn, key, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts a request cookie</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#recycle/1\">recycle(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Recycles the connection</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#redirected_to/2\">redirected_to(conn, status \\\\ 302)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the location header from the given redirect response</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#response/2\">response(conn, given)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts the given status code and returns the response body if one was set or sent</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#response_content_type/2\">response_content_type(conn, format)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the content type as long as it matches the given format</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#text_response/2\">text_response(conn, status)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts the given status code, that we have an text response and returns the response body if one was set or sent</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#connect/3\">connect(conn, path_or_action, params_or_body \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dispatches to the current endpoint</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete/3\">delete(conn, path_or_action, params_or_body \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dispatches to the current endpoint</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get/3\">get(conn, path_or_action, params_or_body \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dispatches to the current endpoint</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#head/3\">head(conn, path_or_action, params_or_body \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dispatches to the current endpoint</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#options/3\">options(conn, path_or_action, params_or_body \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dispatches to the current endpoint</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#patch/3\">patch(conn, path_or_action, params_or_body \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dispatches to the current endpoint</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#post/3\">post(conn, path_or_action, params_or_body \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dispatches to the current endpoint</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put/3\">put(conn, path_or_action, params_or_body \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dispatches to the current endpoint</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#trace/3\">trace(conn, path_or_action, params_or_body \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dispatches to the current endpoint</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"assert_error_sent/2\">  <span class=\"signature\">assert_error_sent(status_int_or_atom, func)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">assert_error_sent(integer | atom, function) :: {integer, list, term}</code></pre>    <p>Asserts an error was wrapped and sent with the given status.</p> <p>Useful for testing actions that you expect raise an error and have the response wrapped in an HTTP status, with content usually rendered by your MyApp.ErrorView.</p> <p>The function accepts a status either as an integer HTTP status or atom, such as <code class=\"inline\">404</code> or <code class=\"inline\">:not_found</code>. If an error is raised, a 3-tuple of the wrapped response is returned matching the status, headers, and body of the response:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{404, [{\"content-type\", \"text/html\"} | _], \"Page not found\"}</code></pre> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">assert_error_sent :not_found, fn -&gt;\n  get build_conn(), \"/users/not-found\"\nend\n\nresponse = assert_error_sent 404, fn -&gt;\n  get build_conn(), \"/users/not-found\"\nend\nassert {404, [_h | _t], \"Page not found\"} = response</code></pre>    <h3 class=\"detail-header function\" id=\"build_conn/0\">  <span class=\"signature\">build_conn()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">build_conn :: Plug.Conn.t</code></pre>    <p>Creates a connection to be used in upcoming requests.</p>    <h3 class=\"detail-header function\" id=\"build_conn/3\">  <span class=\"signature\">build_conn(method, path, params_or_body \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">build_conn(atom | binary, binary, binary | list | map) :: Plug.Conn.t</code></pre>    <p>Creates a connection to be used in upcoming requests with a preset method, path and body.</p> <p>This is useful when a specific connection is required for testing a plug or a particular function.</p>    <h3 class=\"detail-header function\" id=\"bypass_through/1\">  <span class=\"signature\">bypass_through(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">bypass_through(Plug.Conn.t) :: Plug.Conn.t</code></pre>    <p>Calls the Endpoint and bypasses Router match.</p> <p>Useful for unit testing Plugs where Endpoint and/or router pipline plugs are required for proper setup.</p> <h4>Examples</h4> <p>For example, imagine you are testing an authentication plug in isolation, but you need to invoke the Endpoint plugs and <code class=\"inline\">:browser</code> pipeline of your Router for session and flash related dependencies:</p> <pre data-language=\"elixir\"><code class=\"elixir\">conn =\n  conn\n  |&gt; bypass_through(MyApp.Router, [:browser])\n  |&gt; get(\"/\")\n  |&gt; MyApp.RequireAuthentication.call([])\nassert conn.halted</code></pre> <p>Alternatively, you could invoke only the Endpoint, and Router:</p> <pre data-language=\"elixir\"><code class=\"elixir\">conn =\n  conn\n  |&gt; bypass_through(MyApp.Router, [])\n  |&gt; get(\"/\")\n  |&gt; MyApp.RequireAuthentication.call([])\nassert conn.halted</code></pre> <p>Or only invoke the Endpoint’s plugs:</p> <pre data-language=\"elixir\"><code class=\"elixir\">conn =\n  conn\n  |&gt; bypass_through()\n  |&gt; get(\"/\")\n  |&gt; MyApp.RequireAuthentication.call([])\nassert conn.halted</code></pre>    <h3 class=\"detail-header function\" id=\"bypass_through/3\">  <span class=\"signature\">bypass_through(conn, router, pipelines \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">bypass_through(Plug.Conn.t, module, :atom | list) :: Plug.Conn.t</code></pre>    <p>Calls the Endpoint and bypasses Router match.</p> <p>See <a href=\"#bypass_through/1\"><code class=\"inline\">bypass_through/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"clear_flash/1\">  <span class=\"signature\">clear_flash(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">clear_flash(Plug.Conn.t) :: Plug.Conn.t</code></pre>    <p>Clears up the flash storage.</p>    <h3 class=\"detail-header function\" id=\"conn/0\">  <span class=\"signature\">conn()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">conn :: Plug.Conn.t</code></pre>    <p>Deprecated version of conn/0. Use build_conn/0 instead</p>    <h3 class=\"detail-header function\" id=\"conn/3\">  <span class=\"signature\">conn(method, path, params_or_body \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">conn(atom | binary, binary, binary | list | map) :: Plug.Conn.t</code></pre>    <p>Deprecated version of conn/3. Use build_conn/3 instead</p>    <h3 class=\"detail-header function\" id=\"delete_req_cookie/2\">  <span class=\"signature\">delete_req_cookie(conn, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete_req_cookie(Plug.Conn.t, binary) :: Plug.Conn.t</code></pre>    <p>Deletes a request cookie.</p>    <h3 class=\"detail-header function\" id=\"dispatch/5\">  <span class=\"signature\">dispatch(conn, endpoint, method, path_or_action, params_or_body \\\\ nil)</span>  </h3>  <p>Dispatches the connection to the given endpoint.</p> <p>When invoked via <a href=\"#get/3\"><code class=\"inline\">get/3</code></a>, <a href=\"#post/3\"><code class=\"inline\">post/3</code></a> and friends, the endpoint is automatically retrieved from the <code class=\"inline\">@endpoint</code> module attribute, otherwise it must be given as an argument.</p> <p>The connection will be configured with the given <code class=\"inline\">method</code>, <code class=\"inline\">path_or_action</code> and <code class=\"inline\">params_or_body</code>.</p> <p>If <code class=\"inline\">path_or_action</code> is a string, it is considered to be the request path and stored as so in the connection. If an atom, it is assumed to be an action and the connection is dispatched to the given action.</p> <h4>Parameters and body</h4> <p>This function, as well as <a href=\"#get/3\"><code class=\"inline\">get/3</code></a>, <a href=\"#post/3\"><code class=\"inline\">post/3</code></a> and friends, accepts the request body or parameters as last argument:</p> <pre data-language=\"elixir\"><code class=\"elixir\">  get build_conn(), \"/\", some: \"param\"\n  get build_conn(), \"/\", \"some=param&amp;url=encoded\"</code></pre> <p>The allowed values are:</p> <ul> <li>\n<p><code class=\"inline\">nil</code> - meaning there is no body</p> </li> <li>\n<p>a binary - containing a request body. For such cases, <code class=\"inline\">:headers</code> must be given as option with a content-type</p> </li> <li>\n<p>a map or list - containing the parameters which will automatically set the content-type to multipart. The map or list may contain other lists or maps and all entries will be normalized to string keys</p> </li> <li>a struct - unlike other maps, a struct will be passed through as-is without normalizing its entries </li> </ul>    <h3 class=\"detail-header function\" id=\"ensure_recycled/1\">  <span class=\"signature\">ensure_recycled(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">ensure_recycled(Plug.Conn.t) :: Plug.Conn.t</code></pre>    <p>Ensures the connection is recycled if it wasn’t already.</p> <p>See <a href=\"#recycle/1\"><code class=\"inline\">recycle/1</code></a> for more information.</p>    <h3 class=\"detail-header function\" id=\"fetch_flash/1\">  <span class=\"signature\">fetch_flash(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch_flash(Plug.Conn.t) :: Plug.Conn.t</code></pre>    <p>Fetches the flash storage.</p>    <h3 class=\"detail-header function\" id=\"get_flash/1\">  <span class=\"signature\">get_flash(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_flash(Plug.Conn.t) :: Plug.Conn.t</code></pre>    <p>Gets the whole flash storage.</p>    <h3 class=\"detail-header function\" id=\"get_flash/2\">  <span class=\"signature\">get_flash(conn, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_flash(Plug.Conn.t, term) :: Plug.Conn.t</code></pre>    <p>Gets the given key from the flash storage.</p>    <h3 class=\"detail-header function\" id=\"html_response/2\">  <span class=\"signature\">html_response(conn, status)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">html_response(Plug.Conn.t, status :: integer | atom) ::\n  <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a> |\n  no_return</code></pre>    <p>Asserts the given status code, that we have an html response and returns the response body if one was set or sent.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">assert html_response(conn, 200) =~ \"&lt;html&gt;\"</code></pre>    <h3 class=\"detail-header function\" id=\"json_response/2\">  <span class=\"signature\">json_response(conn, status)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">json_response(Plug.Conn.t, status :: integer | atom) ::\n  map |\n  no_return</code></pre>    <p>Asserts the given status code, that we have an json response and returns the decoded JSON response if one was set or sent.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">body = json_response(conn, 200)\nassert \"can't be blank\" in body[\"errors\"]</code></pre>    <h3 class=\"detail-header function\" id=\"put_flash/3\">  <span class=\"signature\">put_flash(conn, key, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_flash(Plug.Conn.t, term, term) :: Plug.Conn.t</code></pre>    <p>Puts the given value under key in the flash storage.</p>    <h3 class=\"detail-header function\" id=\"put_req_cookie/3\">  <span class=\"signature\">put_req_cookie(conn, key, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_req_cookie(Plug.Conn.t, binary, binary) :: Plug.Conn.t</code></pre>    <p>Puts a request cookie.</p>    <h3 class=\"detail-header function\" id=\"recycle/1\">  <span class=\"signature\">recycle(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">recycle(Plug.Conn.t) :: Plug.Conn.t</code></pre>    <p>Recycles the connection.</p> <p>Recycling receives a connection and returns a new connection, containing cookies and relevant information from the given one.</p> <p>This emulates behaviour performed by browsers where cookies returned in the response are available in following requests.</p> <p>Note <a href=\"#recycle/1\"><code class=\"inline\">recycle/1</code></a> is automatically invoked when dispatching to the endpoint, unless the connection has already been recycled.</p>    <h3 class=\"detail-header function\" id=\"redirected_to/2\">  <span class=\"signature\">redirected_to(conn, status \\\\ 302)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">redirected_to(Plug.Conn.t, status :: non_neg_integer) :: Plug.Conn.t</code></pre>    <p>Returns the location header from the given redirect response.</p> <p>Raises if the response does not match the redirect status code (defaults to 302).</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">assert redirected_to(conn) =~ \"/foo/bar\"\nassert redirected_to(conn, 301) =~ \"/foo/bar\"\nassert redirected_to(conn, :moved_permanently) =~ \"/foo/bar\"</code></pre>    <h3 class=\"detail-header function\" id=\"response/2\">  <span class=\"signature\">response(conn, given)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">response(Plug.Conn.t, status :: integer | atom) ::\n  binary |\n  no_return</code></pre>    <p>Asserts the given status code and returns the response body if one was set or sent.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">conn = get build_conn(), \"/\"\nassert response(conn, 200) =~ \"hello world\"</code></pre>    <h3 class=\"detail-header function\" id=\"response_content_type/2\">  <span class=\"signature\">response_content_type(conn, format)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">response_content_type(Plug.Conn.t, atom) ::\n  <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a> |\n  no_return</code></pre>    <p>Returns the content type as long as it matches the given format.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Assert we have an html repsonse with utf-8 charset\nassert response_content_type(conn, :html) =~ \"charset=utf-8\"</code></pre>    <h3 class=\"detail-header function\" id=\"text_response/2\">  <span class=\"signature\">text_response(conn, status)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">text_response(Plug.Conn.t, status :: integer | atom) ::\n  <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a> |\n  no_return</code></pre>    <p>Asserts the given status code, that we have an text response and returns the response body if one was set or sent.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">assert text_response(conn, 200) =~ \"hello\"</code></pre>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"connect/3\">  <span class=\"signature\">connect(conn, path_or_action, params_or_body \\\\ nil)</span>  </h3>  <p>Dispatches to the current endpoint.</p> <p>See <a href=\"#dispatch/5\"><code class=\"inline\">dispatch/5</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"delete/3\">  <span class=\"signature\">delete(conn, path_or_action, params_or_body \\\\ nil)</span>  </h3>  <p>Dispatches to the current endpoint.</p> <p>See <a href=\"#dispatch/5\"><code class=\"inline\">dispatch/5</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"get/3\">  <span class=\"signature\">get(conn, path_or_action, params_or_body \\\\ nil)</span>  </h3>  <p>Dispatches to the current endpoint.</p> <p>See <a href=\"#dispatch/5\"><code class=\"inline\">dispatch/5</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"head/3\">  <span class=\"signature\">head(conn, path_or_action, params_or_body \\\\ nil)</span>  </h3>  <p>Dispatches to the current endpoint.</p> <p>See <a href=\"#dispatch/5\"><code class=\"inline\">dispatch/5</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"options/3\">  <span class=\"signature\">options(conn, path_or_action, params_or_body \\\\ nil)</span>  </h3>  <p>Dispatches to the current endpoint.</p> <p>See <a href=\"#dispatch/5\"><code class=\"inline\">dispatch/5</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"patch/3\">  <span class=\"signature\">patch(conn, path_or_action, params_or_body \\\\ nil)</span>  </h3>  <p>Dispatches to the current endpoint.</p> <p>See <a href=\"#dispatch/5\"><code class=\"inline\">dispatch/5</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"post/3\">  <span class=\"signature\">post(conn, path_or_action, params_or_body \\\\ nil)</span>  </h3>  <p>Dispatches to the current endpoint.</p> <p>See <a href=\"#dispatch/5\"><code class=\"inline\">dispatch/5</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"put/3\">  <span class=\"signature\">put(conn, path_or_action, params_or_body \\\\ nil)</span>  </h3>  <p>Dispatches to the current endpoint.</p> <p>See <a href=\"#dispatch/5\"><code class=\"inline\">dispatch/5</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"trace/3\">  <span class=\"signature\">trace(conn, path_or_action, params_or_body \\\\ nil)</span>  </h3>  <p>Dispatches to the current endpoint.</p> <p>See <a href=\"#dispatch/5\"><code class=\"inline\">dispatch/5</code></a> for more information.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.ConnTest.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.ConnTest.html</a>\n  </p>\n</div>\n","phoenix/phoenix.channel":"<h1>  Phoenix.Channel <small>behaviour</small>  </h1>  <p>Defines a Phoenix Channel.</p> <p>Channels provide a means for bidirectional communication from clients that integrate with the <code class=\"inline\">Phoenix.PubSub</code> layer for soft-realtime functionality.</p> <h2>Topics &amp; Callbacks</h2> <p>Everytime you join a channel, you need to choose which particular topic you want to listen to. The topic is just an identifier, but by convention it is often made of two parts: <code class=\"inline\">\"topic:subtopic\"</code>. Using the <code class=\"inline\">\"topic:subtopic\"</code> approach pairs nicely with the <code class=\"inline\">Phoenix.Socket.channel/2</code> allowing you to match on all topics starting with a given prefix:</p> <pre data-language=\"elixir\"><code class=\"elixir\">channel \"room:*\", MyApp.RoomChannel</code></pre> <p>Any topic coming into the router with the <code class=\"inline\">\"room:\"</code> prefix would dispatch to <code class=\"inline\">MyApp.RoomChannel</code> in the above example. Topics can also be pattern matched in your channels’ <code class=\"inline\">join/3</code> callback to pluck out the scoped pattern:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># handles the special `\"lobby\"` subtopic\ndef join(\"room:lobby\", _auth_message, socket) do\n  {:ok, socket}\nend\n\n# handles any other subtopic as the room ID, for example `\"room:12\"`, `\"room:34\"`\ndef join(\"room:\" &lt;&gt; room_id, auth_message, socket) do\n  {:ok, socket}\nend</code></pre> <h2>Authorization</h2> <p>Clients must join a channel to send and receive PubSub events on that channel. Your channels must implement a <code class=\"inline\">join/3</code> callback that authorizes the socket for the given topic. For example, you could check if the user is allowed to join that particular room.</p> <p>To authorize a socket in <code class=\"inline\">join/3</code>, return <code class=\"inline\">{:ok, socket}</code>. To refuse authorization in <code class=\"inline\">join/3</code>, return <code class=\"inline\">{:error, reply}</code>.</p> <h2>Incoming Events</h2> <p>After a client has successfully joined a channel, incoming events from the client are routed through the channel’s <code class=\"inline\">handle_in/3</code> callbacks. Within these callbacks, you can perform any action. Typically you’ll either forward a message to all listeners with <a href=\"#broadcast!/3\"><code class=\"inline\">broadcast!/3</code></a>, or push a message directly down the socket with <a href=\"#push/3\"><code class=\"inline\">push/3</code></a>. Incoming callbacks must return the <code class=\"inline\">socket</code> to maintain ephemeral state.</p> <p>Here’s an example of receiving an incoming <code class=\"inline\">\"new_msg\"</code> event from one client, and broadcasting the message to all topic subscribers for this socket.</p> <pre data-language=\"elixir\"><code class=\"elixir\">def handle_in(\"new_msg\", %{\"uid\" =&gt; uid, \"body\" =&gt; body}, socket) do\n  broadcast! socket, \"new_msg\", %{uid: uid, body: body}\n  {:noreply, socket}\nend</code></pre> <p>You can also push a message directly down the socket:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># client asks for their current rank, push sent directly as a new event.\ndef handle_in(\"current_rank\", socket) do\n  push socket, \"current_rank\", %{val: Game.get_rank(socket.assigns[:user])}\n  {:noreply, socket}\nend</code></pre> <h2>Replies</h2> <p>In addition to pushing messages out when you receive a <code class=\"inline\">handle_in</code> event, you can also reply directly to a client event for request/response style messaging. This is useful when a client must know the result of an operation or to simply ack messages.</p> <p>For example, imagine creating a resource and replying with the created record:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def handle_in(\"create:post\", attrs, socket) do\n  changeset = Post.changeset(%Post{}, attrs)\n\n  if changeset.valid? do\n    Repo.insert!(changeset)\n    {:reply, {:ok, changeset}, socket}\n  else\n    {:reply,{:error, MyApp.ChangesetView.render(\"errors.json\",\n      %{changeset: changeset}), socket}\n  end\nend</code></pre> <p>Alternatively, you may just want to ack the status of the operation:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def handle_in(\"create:post\", attrs, socket) do\n  changeset = Post.changeset(%Post{}, attrs)\n\n  if changeset.valid? do\n    Repo.insert!(changeset)\n    {:reply, :ok, socket}\n  else\n    {:reply, :error, socket}\n  end\nend</code></pre> <h2>Intercepting Outgoing Events</h2> <p>When an event is broadcasted with <a href=\"#broadcast/3\"><code class=\"inline\">broadcast/3</code></a>, each channel subscriber can choose to intercept the event and have their <code class=\"inline\">handle_out/3</code> callback triggered. This allows the event’s payload to be customized on a socket by socket basis to append extra information, or conditionally filter the message from being delivered. If the event is not intercepted with <a href=\"phoenix.channel#intercept/1\"><code class=\"inline\">Phoenix.Channel.intercept/1</code></a>, then the message is pushed directly to the client:</p> <pre data-language=\"elixir\"><code class=\"elixir\">intercept [\"new_msg\", \"user_joined\"]\n\n# for every socket subscribing to this topic, append an `is_editable`\n# value for client metadata.\ndef handle_out(\"new_msg\", msg, socket) do\n  push socket, \"new_msg\", Map.merge(msg,\n    %{is_editable: User.can_edit_message?(socket.assigns[:user], msg)}\n  )\n  {:noreply, socket}\nend\n\n# do not send broadcasted `\"user_joined\"` events if this socket's user\n# is ignoring the user who joined.\ndef handle_out(\"user_joined\", msg, socket) do\n  unless User.ignoring?(socket.assigns[:user], msg.user_id) do\n    push socket, \"user_joined\", msg\n  end\n  {:noreply, socket}\nend</code></pre> <h2>Broadcasting to an external topic</h2> <p>In some cases, you will want to broadcast messages without the context of a <code class=\"inline\">socket</code>. This could be for broadcasting from within your channel to an external topic, or broadcasting from elsewhere in your application like a controller or another process. Such can be done via your endpoint:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># within channel\ndef handle_in(\"new_msg\", %{\"uid\" =&gt; uid, \"body\" =&gt; body}, socket) do\n  ...\n  broadcast_from! socket, \"new_msg\", %{uid: uid, body: body}\n  MyApp.Endpoint.broadcast_from! self(), \"room:superadmin\",\n    \"new_msg\", %{uid: uid, body: body}\n  {:noreply, socket}\nend\n\n# within controller\ndef create(conn, params) do\n  ...\n  MyApp.Endpoint.broadcast! \"room:\" &lt;&gt; rid, \"new_msg\", %{uid: uid, body: body}\n  MyApp.Endpoint.broadcast! \"room:superadmin\", \"new_msg\", %{uid: uid, body: body}\n  redirect conn, to: \"/\"\nend</code></pre> <h2>Terminate</h2> <p>On termination, the channel callback <code class=\"inline\">terminate/2</code> will be invoked with the error reason and the socket.</p> <p>If we are terminating because the client left, the reason will be <code class=\"inline\">{:shutdown, :left}</code>. Similarly, if we are terminating because the client connection was closed, the reason will be <code class=\"inline\">{:shutdown, :closed}</code>.</p> <p>If any of the callbacks return a <code class=\"inline\">:stop</code> tuple, it will also trigger terminate with the reason given in the tuple.</p> <p><code class=\"inline\">terminate/2</code>, however, won’t be invoked in case of errors nor in case of exits. This is the same behaviour as you find in Elixir abstractions like <code class=\"inline\">GenServer</code> and others. Typically speaking, if you want to clean something up, it is better to monitor your channel process and do the clean up from another process. Similar to GenServer, it would also be possible <code class=\"inline\">:trap_exit</code> to guarantee that <code class=\"inline\">terminate/2</code> is invoked. This practice is not encouraged though.</p> <h2>Exit reasons when stopping a channel</h2> <p>When the channel callbacks return a <code class=\"inline\">:stop</code> tuple, such as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:stop, :shutdown, socket}\n{:stop, {:error, :enoent}, socket}</code></pre> <p>the second argument is the exit reason, which follows the same behaviour as standard <code class=\"inline\">GenServer</code> exits.</p> <p>You have three options to choose from when shutting down a channel:</p> <ul> <li>\n<p><code class=\"inline\">:normal</code> - in such cases, the exit won’t be logged, there is no restart in transient mode, and linked processes do not exit</p> </li> <li>\n<p><code class=\"inline\">:shutdown</code> or <code class=\"inline\">{:shutdown, term}</code> - in such cases, the exit won’t be logged, there is no restart in transient mode, and linked processes exit with the same reason unless they’re trapping exits</p> </li> <li>any other term - in such cases, the exit will be logged, there are restarts in transient mode, and linked processes exit with the same reason unless they’re trapping exits </li> </ul> <h2>Subscribing to external topics</h2> <p>Sometimes you may need to programmatically subscribe a socket to external topics in addition to the the internal <code class=\"inline\">socket.topic</code>. For example, imagine you have a bidding system where a remote client dynamically sets preferences on products they want to receive bidding notifications on. Instead of requiring a unique channel process and topic per preference, a more efficient and simple approach would be to subscribe a single channel to relevant notifications via your endpoint. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def MyApp.Endpoint.NotificationChannel do\n  use Phoenix.Channel\n\n  def join(\"notification:\" &lt;&gt; user_id, %{\"ids\" =&gt; ids}, socket) do\n    topics = for product_id &lt;- ids, do: \"product:#{product_id}\"\n\n    {:ok, socket\n          |&gt; assign(:topics, [])\n          |&gt; put_new_topics(topics)}\n  end\n\n  def handle_in(\"watch\", %{\"product_id\" =&gt; id}, socket) do\n    {:reply, :ok, put_new_topics(socket, [\"product:#{id}\"])}\n  end\n\n  def handle_in(\"unwatch\", %{\"product_id\" =&gt; id}, socket) do\n    {:reply, :ok, MyApp.Endpoint.unsubscribe(\"product:#{id}\")}\n  end\n\n  defp put_new_topics(socket, topics) do\n    Enum.reduce(topics, socket, fn topic, acc -&gt;\n      topics = acc.assigns.topics\n      if topic in topics do\n        acc\n      else\n        :ok = MyApp.Endpoint.subscribe(topic)\n        assign(acc, :topics, [topic | topics])\n      end\n    end)\n  end\nend</code></pre> <p>Note: the caller must be responsible for preventing duplicate subscriptions. After calling <code class=\"inline\">subscribe/1</code> from your endpoint, the same flow applies to handling regular Elixir messages within your channel. Most often, you’ll simply relay the <code class=\"inline\">%Phoenix.Socket.Broadcast{}</code> event and payload:</p> <pre data-language=\"elixir\"><code class=\"elixir\">alias Phoenix.Socket.Broadcast\ndef handle_info(%Broadcast{topic: _, event: ev, payload: payload}, socket) do\n  push socket, ev, payload\n  {:noreply, socket}\nend</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:reply/0\">reply()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:socket_ref/0\">socket_ref()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#broadcast/3\">broadcast(socket, event, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Broadcast an event to all subscribers of the socket topic</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#broadcast!/3\">broadcast!(socket, event, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#broadcast/3\"><code class=\"inline\">broadcast/3</code></a> but raises if broadcast fails</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#broadcast_from/3\">broadcast_from(socket, event, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Broadcast event from pid to all subscribers of the socket topic</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#broadcast_from!/3\">broadcast_from!(socket, event, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#broadcast_from/3\"><code class=\"inline\">broadcast_from/3</code></a> but raises if broadcast fails</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#push/3\">push(socket, event, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends event to the socket</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reply/2\">reply(arg1, arg2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Replies asynchronously to a socket push</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#socket_ref/1\">socket_ref(socket)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a <code class=\"inline\">socket_ref</code> for an async reply</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#intercept/1\">intercept(events)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines which Channel events to intercept for <code class=\"inline\">handle_out/3</code> callbacks</p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:code_change/3\">code_change(old_vsn, arg1, extra)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:handle_in/3\">handle_in(event, msg, arg2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:handle_info/2\">handle_info(term, arg1)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:join/3\">join(topic, auth_msg, arg2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:terminate/2\">terminate(msg, arg1)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:reply/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:reply/0\">reply</a> :: status :: atom | {status :: atom, response :: map}</code></pre> </div> <div id=\"t:socket_ref/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:socket_ref/0\">socket_ref</a> :: {transport_pid :: Pid, serializer :: module, topic :: binary, ref :: binary}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"broadcast/3\">  <span class=\"signature\">broadcast(socket, event, message)</span>  </h3>  <p>Broadcast an event to all subscribers of the socket topic.</p> <p>The event’s message must be a serializable map.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; broadcast socket, \"new_message\", %{id: 1, content: \"hello\"}\n:ok</code></pre>    <h3 class=\"detail-header function\" id=\"broadcast!/3\">  <span class=\"signature\">broadcast!(socket, event, message)</span>  </h3>  <p>Same as <a href=\"#broadcast/3\"><code class=\"inline\">broadcast/3</code></a> but raises if broadcast fails.</p>    <h3 class=\"detail-header function\" id=\"broadcast_from/3\">  <span class=\"signature\">broadcast_from(socket, event, message)</span>  </h3>  <p>Broadcast event from pid to all subscribers of the socket topic.</p> <p>The channel that owns the socket will not receive the published message. The event’s message must be a serializable map.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; broadcast_from socket, \"new_message\", %{id: 1, content: \"hello\"}\n:ok</code></pre>    <h3 class=\"detail-header function\" id=\"broadcast_from!/3\">  <span class=\"signature\">broadcast_from!(socket, event, message)</span>  </h3>  <p>Same as <a href=\"#broadcast_from/3\"><code class=\"inline\">broadcast_from/3</code></a> but raises if broadcast fails.</p>    <h3 class=\"detail-header function\" id=\"push/3\">  <span class=\"signature\">push(socket, event, message)</span>  </h3>  <p>Sends event to the socket.</p> <p>The event’s message must be a serializable map.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; push socket, \"new_message\", %{id: 1, content: \"hello\"}\n:ok</code></pre>    <h3 class=\"detail-header function\" id=\"reply/2\">  <span class=\"signature\">reply(arg1, arg2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reply(<a href=\"#t:socket_ref/0\">socket_ref</a>, <a href=\"#t:reply/0\">reply</a>) :: :ok</code></pre>    <p>Replies asynchronously to a socket push.</p> <p>Useful when you need to reply to a push that can’t otherwise be handled using the <code class=\"inline\">{:reply, {status, payload}, socket}</code> return from your <code class=\"inline\">handle_in</code> callbacks. <code class=\"inline\">reply/3</code> will be used in the rare cases you need to perform work in another process and reply when finished by generating a reference to the push with <a href=\"#socket_ref/1\"><code class=\"inline\">socket_ref/1</code></a>.</p> <p><em>Note</em>: In such cases, a <code class=\"inline\">socket_ref</code> should be generated and passed to the external process, so the <code class=\"inline\">socket</code> itself is not leaked outside the channel. The <code class=\"inline\">socket</code> holds information such as assigns and transport configuration, so it’s important to not copy this information outside of the channel that owns it.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">def handle_in(\"work\", payload, socket) do\n  Worker.perform(payload, socket_ref(socket))\n  {:noreply, socket}\nend\n\ndef handle_info({:work_complete, result, ref}, socket) do\n  reply ref, {:ok, result}\n  {:noreply, socket}\nend</code></pre>    <h3 class=\"detail-header function\" id=\"socket_ref/1\">  <span class=\"signature\">socket_ref(socket)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">socket_ref(<a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>) :: <a href=\"#t:socket_ref/0\">socket_ref</a></code></pre>    <p>Generates a <code class=\"inline\">socket_ref</code> for an async reply.</p> <p>See <a href=\"#reply/2\"><code class=\"inline\">reply/2</code></a> for example usage.</p>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"intercept/1\">  <span class=\"signature\">intercept(events)</span>  </h3>  <p>Defines which Channel events to intercept for <code class=\"inline\">handle_out/3</code> callbacks.</p> <p>By default, broadcasted events are pushed directly to the client, but intercepting events gives your channel a chance to customize the event for the client to append extra information or filter the message from being delivered.</p> <p><em>Note</em>: intercepting events can introduce significantly more overhead if a large number of subscribers must customize a message since the broadcast will be encoded N times instead of a single shared encoding across all subscribers.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">intercept [\"new_msg\"]\n\ndef handle_out(\"new_msg\", payload, socket) do\n  push socket, \"new_msg\", Map.merge(payload,\n    is_editable: User.can_edit_message?(socket.assigns[:user], payload)\n  )\n  {:noreply, socket}\nend</code></pre> <p><code class=\"inline\">handle_out/3</code> callbacks must return one of:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:noreply, Socket.t} |\n{:stop, reason :: term, Socket.t}</code></pre>     <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:code_change/3\">  <span class=\"signature\">code_change(old_vsn, arg1, extra)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">code_change(old_vsn, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>, extra :: term) ::\n  {:ok, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>} |\n  {:error, reason :: term} when old_vsn: term | {:down, term}</code></pre>       <h3 class=\"detail-header callback\" id=\"c:handle_in/3\">  <span class=\"signature\">handle_in(event, msg, arg2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_in(event :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, msg :: map, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>) ::\n  {:noreply, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>} |\n  {:reply, <a href=\"#t:reply/0\">reply</a>, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>} |\n  {:stop, reason :: term, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>} |\n  {:stop, reason :: term, <a href=\"#t:reply/0\">reply</a>, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>}</code></pre>       <h3 class=\"detail-header callback\" id=\"c:handle_info/2\">  <span class=\"signature\">handle_info(term, arg1)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_info(term, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>) ::\n  {:noreply, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>} |\n  {:stop, reason :: term, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>}</code></pre>       <h3 class=\"detail-header callback\" id=\"c:join/3\">  <span class=\"signature\">join(topic, auth_msg, arg2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">join(topic :: binary, auth_msg :: map, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>) ::\n  {:ok, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>} |\n  {:ok, map, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>} |\n  {:error, map}</code></pre>       <h3 class=\"detail-header callback\" id=\"c:terminate/2\">  <span class=\"signature\">terminate(msg, arg1)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">terminate(msg :: map, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>) ::\n  {:shutdown, :left | :closed} |\n  term</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Channel.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Channel.html</a>\n  </p>\n</div>\n","phoenix/phoenix.digester":"<h1>  Phoenix.Digester  </h1>  <p>Digests and compress static files.</p> <p>For each file under the given input path, Phoenix will generate a digest and also compress in <code class=\"inline\">.gz</code> format. The filename and its digest will be used to generate the manifest file. It also avoids duplications checking for already digested files.</p> <p>For stylesheet files found under the given path, Phoenix will replace asset references with the digested paths, as long as the asset exists in the generated manifest.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#compile/2\">compile(input_path, output_path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Digests and compresses the static files and saves them in the given output path</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"compile/2\">  <span class=\"signature\">compile(input_path, output_path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">compile(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) ::\n  :ok |\n  {:error, :invalid_path}</code></pre>    <p>Digests and compresses the static files and saves them in the given output path.</p> <ul> <li>\n<code class=\"inline\">input_path</code> - The path where the assets are located </li> <li>\n<code class=\"inline\">output_path</code> - The path where the compiled/compressed files will be saved </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Digester.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Digester.html</a>\n  </p>\n</div>\n","phoenix/phoenix.endpoint.cowboyhandler":"<h1>  Phoenix.Endpoint.CowboyHandler  </h1>  <p>The Cowboy adapter for Phoenix.</p> <p>It implements the required <a href=\"#child_spec/3\"><code class=\"inline\">child_spec/3</code></a> function as well as the handler for the WebSocket transport.</p> <h2>Custom dispatch options</h2> <p><em>NOTE</em>: This feature depends on the internals of Cowboy 1.0 API and how it integrates with Phoenix. Those may change <em>any time</em>, without backwards compatibility, specially when Cowboy 2.0 is out. We document this for clarity and for those with very special needs.</p> <p>You can provide custom dispatch options in order to use Phoenix’s builtin Cowboy server with custom handlers. For example, to handle raw WebSockets <a href=\"https://github.com/ninenines/cowboy/tree/1.0.x/examples\">as shown in Cowboy’s docs</a>).</p> <p>The options are passed to both <code class=\"inline\">:http</code> and <code class=\"inline\">:https</code> keys in the endpoint configuration. However, once you pass your custom dispatch options, you will need to manually wire all Phoenix endpoints, including the socket transports.</p> <p>You will need the following rules:</p> <ul> <li>\n<p>Per websocket transport:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{\"/socket/websocket\", Phoenix.Endpoint.CowboyWebSocket,\n  {Phoenix.Transports.WebSocket,\n    {MyApp.Endpoint, MyApp.UserSocket, :websocket}}}</code></pre> </li> <li>\n<p>Per longpoll transport:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{\"/socket/long_poll\", Plug.Adapters.Cowboy.Handler,\n  {Phoenix.Transports.LongPoll,\n    {MyApp.Endpoint, MyApp.UserSocket, :longpoll}}}</code></pre> </li> <li>\n<p>For the endpoint:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:_, Plug.Adapters.Cowboy.Handler, {MyApp.Endpoint, []}}</code></pre> </li> </ul> <p>For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :myapp, MyApp.Endpoint,\n  http: [dispatch: [\n          {:_, [\n              {\"/foo\", MyApp.CustomHandler, []},\n              {\"/bar\", MyApp.AnotherHandler, []},\n              {:_, Plug.Adapters.Cowboy.Handler, {MyApp.Endpoint, []}}\n            ]}]]</code></pre> <p>It is also important to specify your handlers first, otherwise Phoenix will intercept the requests before they get to your handler.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#child_spec/3\">child_spec(scheme, endpoint, config)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a childspec to be used in the supervision tree</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/3\">start_link(scheme, endpoint, arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback to start the Cowboy endpoint</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"child_spec/3\">  <span class=\"signature\">child_spec(scheme, endpoint, config)</span>  </h3>  <p>Generates a childspec to be used in the supervision tree.</p>    <h3 class=\"detail-header function\" id=\"start_link/3\">  <span class=\"signature\">start_link(scheme, endpoint, arg)</span>  </h3>  <p>Callback to start the Cowboy endpoint.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Endpoint.CowboyHandler.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Endpoint.CowboyHandler.html</a>\n  </p>\n</div>\n","phoenix/phoenix.socket.broadcast":"<h1>  Phoenix.Socket.Broadcast  </h1>  <p>Defines a message sent from pubsub to channels and vice-versa.</p> <p>The message format requires the following keys:</p> <ul> <li>\n<code class=\"inline\">topic</code> - The string topic or topic:subtopic pair namespace, for example “messages”, “messages:123” </li> <li>\n<code class=\"inline\">event</code>- The string event name, for example “phx_join” </li> <li>\n<code class=\"inline\">payload</code> - The message payload </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Phoenix.Socket.Broadcast{event: term, payload: term, topic: term}</code></pre> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Socket.Broadcast.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Socket.Broadcast.html</a>\n  </p>\n</div>\n","phoenix/phoenix.socket.reply":"<h1>  Phoenix.Socket.Reply  </h1>  <p>Defines a reply sent from channels to transports.</p> <p>The message format requires the following keys:</p> <ul> <li>\n<code class=\"inline\">topic</code> - The string topic or topic:subtopic pair namespace, for example “messages”, “messages:123” </li> <li>\n<code class=\"inline\">status</code> - The reply status as an atom </li> <li>\n<code class=\"inline\">payload</code> - The reply payload </li> <li>\n<code class=\"inline\">ref</code> - The unique string ref </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Phoenix.Socket.Reply{payload: term, ref: term, status: term, topic: term}</code></pre> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Socket.Reply.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Socket.Reply.html</a>\n  </p>\n</div>\n","phoenix/phoenix.endpoint.handler":"<h1>  Phoenix.Endpoint.Handler <small>behaviour</small>  </h1>  <p>API for exporting a webserver.</p> <p>A handler will need to implement a <code class=\"inline\">child_spec/3</code> function which takes:</p> <ul> <li>the scheme of the endpoint :http or :https </li> <li>phoenix top-most endpoint module </li> <li>phoenix app configuration for the specified scheme </li> </ul> <p>it has to return a child_spec.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:child_spec/3\">child_spec(scheme, endpoint, config)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Provides the children specification to be passed to <code class=\"inline\">Phoenix.Endpoint.Server</code> supervisor</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:child_spec/3\">  <span class=\"signature\">child_spec(scheme, endpoint, config)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">child_spec(scheme :: atom, endpoint :: module, config :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Supervisor.Spec.html#t:spec/0\">Supervisor.Spec.spec</a></code></pre>    <p>Provides the children specification to be passed to <code class=\"inline\">Phoenix.Endpoint.Server</code> supervisor.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Endpoint.Handler.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Endpoint.Handler.html</a>\n  </p>\n</div>\n","phoenix/phoenix.logger":"<h1>  Phoenix.Logger  </h1>  <p>Instrumenter to handle logging of various instrumentation events.</p> <h2>Parameter filtering</h2> <p>When logging parameters, Phoenix can filter out sensitive parameters in the logs, such as passwords, tokens and what not. Parameters to be filtered can be added via the <code class=\"inline\">:filter_parameters</code> option:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :phoenix, :filter_parameters, [\"password\", \"secret\"]</code></pre> <p>With the configuration above, Phoenix will filter any parameter that contains the terms <code class=\"inline\">password</code> or <code class=\"inline\">secret</code>. The match is case sensitive.</p> <p>Phoenix’s default is <code class=\"inline\">[\"password\"]</code>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#phoenix_channel_join/3\">phoenix_channel_join(arg1, compile, arg3)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#phoenix_controller_call/3\">phoenix_controller_call(arg1, arg2, arg3)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"phoenix_channel_join/3\">  <span class=\"signature\">phoenix_channel_join(arg1, compile, arg3)</span>  </h3>     <h3 class=\"detail-header function\" id=\"phoenix_controller_call/3\">  <span class=\"signature\">phoenix_controller_call(arg1, arg2, arg3)</span>  </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Logger.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Logger.html</a>\n  </p>\n</div>\n","phoenix/phoenix.socket.message":"<h1>  Phoenix.Socket.Message  </h1>  <p>Defines a message dispatched over transport to channels and vice-versa.</p> <p>The message format requires the following keys:</p> <ul> <li>\n<code class=\"inline\">topic</code> - The string topic or topic:subtopic pair namespace, for example “messages”, “messages:123” </li> <li>\n<code class=\"inline\">event</code>- The string event name, for example “phx_join” </li> <li>\n<code class=\"inline\">payload</code> - The message payload </li> <li>\n<code class=\"inline\">ref</code> - The unique string ref </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#from_map!/1\">from_map!(map)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a map with string keys into a message struct</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Phoenix.Socket.Message{event: term, payload: term, ref: term, topic: term}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"from_map!/1\">  <span class=\"signature\">from_map!(map)</span>  </h3>  <p>Converts a map with string keys into a message struct.</p> <p>Raises <a href=\"phoenix.socket.invalidmessageerror\"><code class=\"inline\">Phoenix.Socket.InvalidMessageError</code></a> if not valid.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Socket.Message.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Socket.Message.html</a>\n  </p>\n</div>\n","phoenix/phoenix.supervisor":"<h1>  Phoenix.Supervisor  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#init/1\">init(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Supervisor.init/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/0\">start_link()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"init/1\">  <span class=\"signature\">init(list)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Supervisor.init/1</code>.</p>    <h3 class=\"detail-header function\" id=\"start_link/0\">  <span class=\"signature\">start_link()</span>  </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Supervisor.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Supervisor.html</a>\n  </p>\n</div>\n","phoenix/phoenix.naming":"<h1>  Phoenix.Naming  </h1>  <p>Conveniences for inflecting and working with names in Phoenix.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#camelize/1\">camelize(arg1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts String to camel case</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#camelize/2\">camelize(arg1, atom)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#humanize/1\">humanize(atom)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an attribute/form field into its humanize version</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#resource_name/2\">resource_name(alias, suffix \\\\ \"\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Extracts the resource name from an alias</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#underscore/1\">underscore(arg1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts String to underscore case</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unsuffix/2\">unsuffix(value, suffix)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes the given suffix from the name if it exists</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"camelize/1\">  <span class=\"signature\">camelize(arg1)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">camelize(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Converts String to camel case.</p> <p>Takes an optional <code class=\"inline\">:lower</code> option to return lowerCamelCase.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Naming.camelize(\"my_app\")\n\"MyApp\"\n\niex&gt; Phoenix.Naming.camelize(\"my_app\", :lower)\n\"myApp\"</code></pre> <p>In general, <code class=\"inline\">camelize</code> can be thought of as the reverse of <code class=\"inline\">underscore</code>, however, in some cases formatting may be lost:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Phoenix.Naming.underscore \"SAPExample\"  #=&gt; \"sap_example\"\nPhoenix.Naming.camelize   \"sap_example\" #=&gt; \"SapExample\"</code></pre>    <h3 class=\"detail-header function\" id=\"camelize/2\">  <span class=\"signature\">camelize(arg1, atom)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">camelize(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, :lower) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>       <h3 class=\"detail-header function\" id=\"humanize/1\">  <span class=\"signature\">humanize(atom)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">humanize(atom | <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Converts an attribute/form field into its humanize version.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Naming.humanize(:username)\n\"Username\"\niex&gt; Phoenix.Naming.humanize(:created_at)\n\"Created at\"\niex&gt; Phoenix.Naming.humanize(\"user_id\")\n\"User\"</code></pre>    <h3 class=\"detail-header function\" id=\"resource_name/2\">  <span class=\"signature\">resource_name(alias, suffix \\\\ \"\")</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">resource_name(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.Chars.html#t:t/0\">String.Chars.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Extracts the resource name from an alias.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Naming.resource_name(MyApp.User)\n\"user\"\n\niex&gt; Phoenix.Naming.resource_name(MyApp.UserView, \"View\")\n\"user\"</code></pre>    <h3 class=\"detail-header function\" id=\"underscore/1\">  <span class=\"signature\">underscore(arg1)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">underscore(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Converts String to underscore case.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Naming.underscore(\"MyApp\")\n\"my_app\"</code></pre> <p>In general, <code class=\"inline\">underscore</code> can be thought of as the reverse of <code class=\"inline\">camelize</code>, however, in some cases formatting may be lost:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Phoenix.Naming.underscore \"SAPExample\"  #=&gt; \"sap_example\"\nPhoenix.Naming.camelize   \"sap_example\" #=&gt; \"SapExample\"</code></pre>    <h3 class=\"detail-header function\" id=\"unsuffix/2\">  <span class=\"signature\">unsuffix(value, suffix)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unsuffix(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Removes the given suffix from the name if it exists.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Naming.unsuffix(\"MyApp.User\", \"View\")\n\"MyApp.User\"\n\niex&gt; Phoenix.Naming.unsuffix(\"MyApp.UserView\", \"View\")\n\"MyApp.User\"</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Naming.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Naming.html</a>\n  </p>\n</div>\n","phoenix/phoenix.channeltest":"<h1>  Phoenix.ChannelTest  </h1>  <p>Conveniences for testing Phoenix channels.</p> <p>In channel tests, we interact with channels via process communication, sending and receiving messages. It is also common to subscribe to the same topic the channel subscribes to, allowing us to assert if a given message was broadcast or not.</p> <h2>Channel testing</h2> <p>To get started, define the module attribute <code class=\"inline\">@endpoint</code> in your test case pointing to your application endpoint.</p> <p>Then you can directly create a socket and <a href=\"#subscribe_and_join/4\"><code class=\"inline\">subscribe_and_join/4</code></a> topics and channels:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:ok, _, socket} =\n  socket(\"user:id\", %{some_assigns: 1})\n  |&gt; subscribe_and_join(RoomChannel, \"room:lobby\", %{\"id\" =&gt; 3})</code></pre> <p>You usually want to set the same ID and assigns your <code class=\"inline\">UserSocket.connect/2</code> callback would set. Alternatively, you can use the <a href=\"#connect/2\"><code class=\"inline\">connect/2</code></a> helper to call your <code class=\"inline\">UserSocket.connect/2</code> callback and initialize the socket with the socket id:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:ok, socket} = connect(UserSocket, %{\"some\" =&gt; \"params\"})\n{:ok, _, socket} = subscribe_and_join(socket, \"room:lobby\", %{\"id\" =&gt; 3})</code></pre> <p>Once called, <a href=\"#subscribe_and_join/4\"><code class=\"inline\">subscribe_and_join/4</code></a> will subscribe the current test process to the “room:lobby” topic and start a channel in another process. It returns <code class=\"inline\">{:ok, reply, socket}</code> or <code class=\"inline\">{:error, reply}</code>.</p> <p>Now, in the same way the channel has a socket representing communication it will push to the client. Our test has a socket representing communication to be pushed to the server.</p> <p>For example, we can use the <a href=\"#push/3\"><code class=\"inline\">push/3</code></a> function in the test to push messages to the channel (it will invoke <code class=\"inline\">handle_in/3</code>):</p> <pre data-language=\"elixir\"><code class=\"elixir\">push socket, \"my_event\", %{\"some\" =&gt; \"data\"}</code></pre> <p>Similarly, we can broadcast messages from the test itself on the topic that both test and channel are subscribed to, triggering <code class=\"inline\">handle_out/3</code> on the channel:</p> <pre data-language=\"elixir\"><code class=\"elixir\">broadcast_from socket, \"my_event\", %{\"some\" =&gt; \"data\"}</code></pre> <blockquote>\n<p>Note only <a href=\"#broadcast_from/3\"><code class=\"inline\">broadcast_from/3</code></a> and <a href=\"#broadcast_from!/3\"><code class=\"inline\">broadcast_from!/3</code></a> are available in tests to avoid broadcast messages to be resent to the test process.</p> </blockquote> <p>While the functions above are pushing data to the channel (server) we can use <a href=\"#assert_push/3\"><code class=\"inline\">assert_push/3</code></a> to verify the channel pushed a message to the client:</p> <pre data-language=\"elixir\"><code class=\"elixir\">assert_push \"my_event\", %{\"some\" =&gt; \"data\"}</code></pre> <p>Or even assert something was broadcast into pubsub:</p> <pre data-language=\"elixir\"><code class=\"elixir\">assert_broadcast \"my_event\", %{\"some\" =&gt; \"data\"}</code></pre> <p>Finally, every time a message is pushed to the channel, a reference is returned. We can use this reference to assert a particular reply was sent from the server:</p> <pre data-language=\"elixir\"><code class=\"elixir\">ref = push socket, \"counter\", %{}\nassert_reply ref, :ok, %{\"counter\" =&gt; 1}</code></pre> <h2>Checking side-effects</h2> <p>Often one may want to do side-effects inside channels, like writing to the database, and verify those side-effects during their tests.</p> <p>Imagine the following <code class=\"inline\">handle_in/3</code> inside a channel:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def handle_in(\"publish\", %{\"id\" =&gt; id}, socket) do\n  Repo.get!(Post, id) |&gt; Post.publish() |&gt; Repo.update!()\n  {:noreply, socket}\nend</code></pre> <p>Because the whole communication is asynchronous, the following test would be very brittle:</p> <pre data-language=\"elixir\"><code class=\"elixir\">push socket, \"publish\", %{\"id\" =&gt; 3}\nassert Repo.get_by(Post, id: 3, published: true)</code></pre> <p>The issue is that we have no guarantees the channel has done processing our message after calling <a href=\"#push/3\"><code class=\"inline\">push/3</code></a>. The best solution is to assert the channel sent us a reply before doing any other assertion. First change the channel to send replies:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def handle_in(\"publish\", %{\"id\" =&gt; id}, socket) do\n  Repo.get!(Post, id) |&gt; Post.publish() |&gt; Repo.update!()\n  {:reply, :ok, socket}\nend</code></pre> <p>Then expect them in the test:</p> <pre data-language=\"elixir\"><code class=\"elixir\">ref = push socket, \"publish\", %{\"id\" =&gt; 3}\nassert_reply ref, :ok\nassert Repo.get_by(Post, id: 3, published: true)</code></pre> <h2>Leave and close</h2> <p>This module also provides functions to simulate leaving and closing a channel. Once you leave or close a channel, because the channel is linked to the test process on join, it will crash the test process:</p> <pre data-language=\"elixir\"><code class=\"elixir\">leave(socket)\n** (EXIT from #PID&lt;...&gt;) {:shutdown, :leave}</code></pre> <p>You can avoid this by unlinking the channel process in the test:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Process.unlink(socket.channel_pid)</code></pre> <p>Notice <a href=\"#leave/1\"><code class=\"inline\">leave/1</code></a> is async, so it will also return a reference which you can use to check for a reply:</p> <pre data-language=\"elixir\"><code class=\"elixir\">ref = leave(socket)\nassert_reply ref, :ok</code></pre> <p>On the other hand, close is always sync and it will return only after the channel process is guaranteed to have been terminated:</p> <pre data-language=\"elixir\"><code class=\"elixir\">:ok = close(socket)</code></pre> <p>This mimics the behaviour existing in clients.</p> <p>To assert that your channel closes or errors asynchronously, you can monitor the channel process with the tools provided by Elixir, and wait for the <code class=\"inline\">:DOWN</code> message. Imagine an implementation of the <code class=\"inline\">handle_info/2</code> function that closes the channel when it receives <code class=\"inline\">:some_message</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def handle_info(:some_message, socket) do\n  {:stop, :normal, socket}\nend</code></pre> <p>In your test, you can assert that the close happened by:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Process.monitor(socket.channel_pid)\nsend(socket.channel_pid, :some_message)\nassert_receive {:DOWN, _, _, _, :normal}</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#broadcast_from/3\">broadcast_from(socket, event, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Broadcast event from pid to all subscribers of the socket topic</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#broadcast_from!/3\">broadcast_from!(socket, event, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#broadcast_from/3\"><code class=\"inline\">broadcast_from/3</code></a> but raises if broadcast fails</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#close/2\">close(socket, timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Emulates the client closing the channel</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#join/2\">join(socket, topic)</a> </dt> <dd class=\"summary-synopsis\">\n<p>See <a href=\"#join/4\"><code class=\"inline\">join/4</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#join/3\">join(socket, topic, payload)</a> </dt> <dd class=\"summary-synopsis\">\n<p>See <a href=\"#join/4\"><code class=\"inline\">join/4</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#join/4\">join(socket, channel, topic, payload \\\\ %{})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Joins the channel under the given topic and payload</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#leave/1\">leave(socket)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Emulates the client leaving the channel</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#push/3\">push(socket, event, payload \\\\ %{})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Pushes a message into the channel</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subscribe_and_join/2\">subscribe_and_join(socket, topic)</a> </dt> <dd class=\"summary-synopsis\">\n<p>See <a href=\"#subscribe_and_join/4\"><code class=\"inline\">subscribe_and_join/4</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subscribe_and_join/3\">subscribe_and_join(socket, topic, payload)</a> </dt> <dd class=\"summary-synopsis\">\n<p>See <a href=\"#subscribe_and_join/4\"><code class=\"inline\">subscribe_and_join/4</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subscribe_and_join/4\">subscribe_and_join(socket, channel, topic, payload \\\\ %{})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Subscribes to the given topic and joins the channel under the given topic and payload</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subscribe_and_join!/2\">subscribe_and_join!(socket, topic)</a> </dt> <dd class=\"summary-synopsis\">\n<p>See <a href=\"#subscribe_and_join!/4\"><code class=\"inline\">subscribe_and_join!/4</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subscribe_and_join!/3\">subscribe_and_join!(socket, topic, payload)</a> </dt> <dd class=\"summary-synopsis\">\n<p>See <a href=\"#subscribe_and_join!/4\"><code class=\"inline\">subscribe_and_join!/4</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subscribe_and_join!/4\">subscribe_and_join!(socket, channel, topic, payload \\\\ %{})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#subscribe_and_join/4\"><code class=\"inline\">subscribe_and_join/4</code></a> but returns either the socket or throws an error</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#assert_broadcast/3\">assert_broadcast(event, payload, timeout \\\\ 100)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts the channel has broadcast a message within <code class=\"inline\">timeout</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#assert_push/3\">assert_push(event, payload, timeout \\\\ 100)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts the channel has pushed a message back to the client with the given event and payload within <code class=\"inline\">timeout</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#assert_reply/4\">assert_reply(ref, status, payload \\\\ Macro.escape(%{}), timeout \\\\ 100)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts the channel has replied to the given message within <code class=\"inline\">timeout</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#connect/2\">connect(handler, params)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Initiates a transport connection for the socket handler</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#refute_broadcast/3\">refute_broadcast(event, payload, timeout \\\\ 100)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts the channel has not broadcast a message within <code class=\"inline\">timeout</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#refute_push/3\">refute_push(event, payload, timeout \\\\ 100)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts the channel has not pushed a message to the client matching the given event and payload within <code class=\"inline\">timeout</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#refute_reply/4\">refute_reply(ref, status, payload \\\\ Macro.escape(%{}), timeout \\\\ 100)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts the channel has not replied with a matching payload within <code class=\"inline\">timeout</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#socket/0\">socket()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Builds a socket</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#socket/2\">socket(id, assigns)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Builds a socket with given id and assigns</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"broadcast_from/3\">  <span class=\"signature\">broadcast_from(socket, event, message)</span>  </h3>  <p>Broadcast event from pid to all subscribers of the socket topic.</p> <p>The test process will not receive the published message. This triggers the <code class=\"inline\">handle_out/3</code> callback in the channel.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; broadcast_from socket, \"new_message\", %{id: 1, content: \"hello\"}\n:ok</code></pre>    <h3 class=\"detail-header function\" id=\"broadcast_from!/3\">  <span class=\"signature\">broadcast_from!(socket, event, message)</span>  </h3>  <p>Same as <a href=\"#broadcast_from/3\"><code class=\"inline\">broadcast_from/3</code></a> but raises if broadcast fails.</p>    <h3 class=\"detail-header function\" id=\"close/2\">  <span class=\"signature\">close(socket, timeout \\\\ 5000)</span>  </h3>  <p>Emulates the client closing the channel.</p> <p>Closing channels is synchronous and has a default timeout of 5000 milliseconds.</p>    <h3 class=\"detail-header function\" id=\"join/2\">  <span class=\"signature\">join(socket, topic)</span>  </h3>  <p>See <a href=\"#join/4\"><code class=\"inline\">join/4</code></a>.</p>    <h3 class=\"detail-header function\" id=\"join/3\">  <span class=\"signature\">join(socket, topic, payload)</span>  </h3>  <p>See <a href=\"#join/4\"><code class=\"inline\">join/4</code></a>.</p>    <h3 class=\"detail-header function\" id=\"join/4\">  <span class=\"signature\">join(socket, channel, topic, payload \\\\ %{})</span>  </h3>  <p>Joins the channel under the given topic and payload.</p> <p>The given channel is joined in a separate process which is linked to the test process.</p> <p>It returns <code class=\"inline\">{:ok, reply, socket}</code> or <code class=\"inline\">{:error, reply}</code>.</p>    <h3 class=\"detail-header function\" id=\"leave/1\">  <span class=\"signature\">leave(socket)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">leave(<a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>) :: reference</code></pre>    <p>Emulates the client leaving the channel.</p>    <h3 class=\"detail-header function\" id=\"push/3\">  <span class=\"signature\">push(socket, event, payload \\\\ %{})</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">push(<a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, map) :: reference</code></pre>    <p>Pushes a message into the channel.</p> <p>The triggers the <code class=\"inline\">handle_in/3</code> callback in the channel.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; push socket, \"new_message\", %{id: 1, content: \"hello\"}\nreference</code></pre>    <h3 class=\"detail-header function\" id=\"subscribe_and_join/2\">  <span class=\"signature\">subscribe_and_join(socket, topic)</span>  </h3>  <p>See <a href=\"#subscribe_and_join/4\"><code class=\"inline\">subscribe_and_join/4</code></a>.</p>    <h3 class=\"detail-header function\" id=\"subscribe_and_join/3\">  <span class=\"signature\">subscribe_and_join(socket, topic, payload)</span>  </h3>  <p>See <a href=\"#subscribe_and_join/4\"><code class=\"inline\">subscribe_and_join/4</code></a>.</p>    <h3 class=\"detail-header function\" id=\"subscribe_and_join/4\">  <span class=\"signature\">subscribe_and_join(socket, channel, topic, payload \\\\ %{})</span>  </h3>  <p>Subscribes to the given topic and joins the channel under the given topic and payload.</p> <p>By subscribing to the topic, we can use <a href=\"#assert_broadcast/3\"><code class=\"inline\">assert_broadcast/3</code></a> to verify a message has been sent through the pubsub layer.</p> <p>By joining the channel, we can interact with it directly. The given channel is joined in a separate process which is linked to the test process.</p> <p>If no channel module is provided, the socket’s handler is used to lookup the matching channel for the given topic.</p> <p>It returns <code class=\"inline\">{:ok, reply, socket}</code> or <code class=\"inline\">{:error, reply}</code>.</p>    <h3 class=\"detail-header function\" id=\"subscribe_and_join!/2\">  <span class=\"signature\">subscribe_and_join!(socket, topic)</span>  </h3>  <p>See <a href=\"#subscribe_and_join!/4\"><code class=\"inline\">subscribe_and_join!/4</code></a>.</p>    <h3 class=\"detail-header function\" id=\"subscribe_and_join!/3\">  <span class=\"signature\">subscribe_and_join!(socket, topic, payload)</span>  </h3>  <p>See <a href=\"#subscribe_and_join!/4\"><code class=\"inline\">subscribe_and_join!/4</code></a>.</p>    <h3 class=\"detail-header function\" id=\"subscribe_and_join!/4\">  <span class=\"signature\">subscribe_and_join!(socket, channel, topic, payload \\\\ %{})</span>  </h3>  <p>Same as <a href=\"#subscribe_and_join/4\"><code class=\"inline\">subscribe_and_join/4</code></a> but returns either the socket or throws an error.</p> <p>This is helpful when you are not testing joining the channel and just need the socket.</p>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"assert_broadcast/3\">  <span class=\"signature\">assert_broadcast(event, payload, timeout \\\\ 100)</span>  </h3>  <p>Asserts the channel has broadcast a message within <code class=\"inline\">timeout</code>.</p> <p>Before asserting anything was broadcast, we must first subscribe to the topic of the channel in the test process:</p> <pre data-language=\"elixir\"><code class=\"elixir\">@endpoint.subscribe(\"foo:ok\")</code></pre> <p>Now we can match on event and payload as patterns:</p> <pre data-language=\"elixir\"><code class=\"elixir\">assert_broadcast \"some_event\", %{\"data\" =&gt; _}</code></pre> <p>In the assertion above, we don’t particularly care about the data being sent, as long as something was sent.</p> <p>The timeout is in milliseconds and defaults to 100ms.</p>    <h3 class=\"detail-header macro\" id=\"assert_push/3\">  <span class=\"signature\">assert_push(event, payload, timeout \\\\ 100)</span>  </h3>  <p>Asserts the channel has pushed a message back to the client with the given event and payload within <code class=\"inline\">timeout</code>.</p> <p>Notice event and payload are patterns. This means one can write:</p> <pre data-language=\"elixir\"><code class=\"elixir\">assert_push \"some_event\", %{\"data\" =&gt; _}</code></pre> <p>In the assertion above, we don’t particularly care about the data being sent, as long as something was sent.</p> <p>The timeout is in milliseconds and defaults to 100ms.</p>    <h3 class=\"detail-header macro\" id=\"assert_reply/4\">  <span class=\"signature\">assert_reply(ref, status, payload \\\\ Macro.escape(%{}), timeout \\\\ 100)</span>  </h3>  <p>Asserts the channel has replied to the given message within <code class=\"inline\">timeout</code>.</p> <p>Notice status and payload are patterns. This means one can write:</p> <pre data-language=\"elixir\"><code class=\"elixir\">ref = push channel, \"some_event\"\nassert_reply ref, :ok, %{\"data\" =&gt; _}</code></pre> <p>In the assertion above, we don’t particularly care about the data being sent, as long as something was replied.</p> <p>The timeout is in milliseconds and defaults to 100ms.</p>    <h3 class=\"detail-header macro\" id=\"connect/2\">  <span class=\"signature\">connect(handler, params)</span>  </h3>  <p>Initiates a transport connection for the socket handler.</p> <p>Useful for testing UserSocket authentication. Returns the result of the handler’s <a href=\"#connect/2\"><code class=\"inline\">connect/2</code></a> callback.</p>    <h3 class=\"detail-header macro\" id=\"refute_broadcast/3\">  <span class=\"signature\">refute_broadcast(event, payload, timeout \\\\ 100)</span>  </h3>  <p>Asserts the channel has not broadcast a message within <code class=\"inline\">timeout</code>.</p> <p>Like <code class=\"inline\">assert_broadcast</code>, the event and payload are patterns.</p> <p>The timeout is in milliseconds and defaults to 100ms. Keep in mind this macro will block the test by the timeout value, so use it only when necessary as overuse will certainly slow down your test suite.</p>    <h3 class=\"detail-header macro\" id=\"refute_push/3\">  <span class=\"signature\">refute_push(event, payload, timeout \\\\ 100)</span>  </h3>  <p>Asserts the channel has not pushed a message to the client matching the given event and payload within <code class=\"inline\">timeout</code>.</p> <p>Like <code class=\"inline\">assert_push</code>, the event and payload are patterns.</p> <p>The timeout is in milliseconds and defaults to 100ms. Keep in mind this macro will block the test by the timeout value, so use it only when necessary as overuse will certainly slow down your test suite.</p>    <h3 class=\"detail-header macro\" id=\"refute_reply/4\">  <span class=\"signature\">refute_reply(ref, status, payload \\\\ Macro.escape(%{}), timeout \\\\ 100)</span>  </h3>  <p>Asserts the channel has not replied with a matching payload within <code class=\"inline\">timeout</code>.</p> <p>Like <code class=\"inline\">assert_reply</code>, the event and payload are patterns.</p> <p>The timeout is in milliseconds and defaults to 100ms. Keep in mind this macro will block the test by the timeout value, so use it only when necessary as overuse will certainly slow down your test suite.</p>    <h3 class=\"detail-header macro\" id=\"socket/0\">  <span class=\"signature\">socket()</span>  </h3>  <p>Builds a socket.</p> <p>The socket is then used to subscribe and join channels. Use this function when you want to create a blank socket to pass to functions like <code class=\"inline\">UserSocket.connect/2</code>.</p> <p>Otherwise, use <a href=\"#socket/2\"><code class=\"inline\">socket/2</code></a> if you want to build a socket with id and assigns.</p> <p>The socket endpoint is read from the <code class=\"inline\">@endpoint</code> variable.</p>    <h3 class=\"detail-header macro\" id=\"socket/2\">  <span class=\"signature\">socket(id, assigns)</span>  </h3>  <p>Builds a socket with given id and assigns.</p> <p>The socket endpoint is read from the <code class=\"inline\">@endpoint</code> variable.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.ChannelTest.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.ChannelTest.html</a>\n  </p>\n</div>\n","phoenix/phoenix.controller":"<h1>  Phoenix.Controller  </h1>  <p>Controllers are used to group common functionality in the same (pluggable) module.</p> <p>For example, the route:</p> <pre data-language=\"elixir\"><code class=\"elixir\">get \"/users/:id\", MyApp.UserController, :show</code></pre> <p>will invoke the <code class=\"inline\">show/2</code> action in the <code class=\"inline\">MyApp.UserController</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def show(conn, %{\"id\" =&gt; id}) do\n    user = Repo.get(User, id)\n    render conn, \"show.html\", user: user\n  end\nend</code></pre> <p>An action is just a regular function that receives the connection and the request parameters as arguments. The connection is a <code class=\"inline\">Plug.Conn</code> struct, as specified by the Plug library.</p> <h2>Connection</h2> <p>A controller by default provides many convenience functions for manipulating the connection, rendering templates, and more.</p> <p>Those functions are imported from two modules:</p> <ul> <li>\n<p><code class=\"inline\">Plug.Conn</code> - a bunch of low-level functions to work with the connection</p> </li> <li>\n<a href=\"phoenix.controller#content\"><code class=\"inline\">Phoenix.Controller</code></a> - functions provided by Phoenix to support rendering, and other Phoenix specific behaviour </li> </ul> <h2>Rendering and layouts</h2> <p>One of the main features provided by controllers is the ability to do content negotiation and render templates based on information sent by the client. Read <a href=\"#render/3\"><code class=\"inline\">render/3</code></a> to learn more.</p> <p>It is also important to not confuse <a href=\"phoenix.controller#render/3\"><code class=\"inline\">Phoenix.Controller.render/3</code></a> with <a href=\"phoenix.view#render/3\"><code class=\"inline\">Phoenix.View.render/3</code></a> in the long term. The former expects a connection and relies on content negotiation while the latter is connection-agnostic and typically invoked from your views.</p> <h2>Plug pipeline</h2> <p>As with routers, controllers also have their own plug pipeline. However, different from routers, controllers have a single pipeline:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  plug :authenticate, usernames: [\"jose\", \"eric\", \"sonny\"]\n\n  def show(conn, params) do\n    # authenticated users only\n  end\n\n  defp authenticate(conn, options) do\n    if get_session(conn, :username) in options[:usernames] do\n      conn\n    else\n      conn |&gt; redirect(to: \"/\") |&gt; halt()\n    end\n  end\nend</code></pre> <p>Check <a href=\"phoenix.controller.pipeline\"><code class=\"inline\">Phoenix.Controller.Pipeline</code></a> for more information on <code class=\"inline\">plug/2</code> and how to customize the plug pipeline.</p> <h2>Options</h2> <p>When used, the controller supports the following options:</p> <ul> <li>\n<p><code class=\"inline\">:namespace</code> - sets the namespace to properly inflect the layout view. By default it uses the base alias in your controller name</p> </li> <li>\n<code class=\"inline\">:log</code> - the level to log. When false, disables controller logging </li> </ul> <h2>Overriding <code class=\"inline\">action/2</code> for custom arguments</h2> <p>Phoenix injects an <code class=\"inline\">action/2</code> plug in your controller which calls the function matched from the router. By default, it passes the conn and params. In some cases, overriding the <code class=\"inline\">action/2</code> plug in your controller is a useful way to inject certain argument to your actions that you would otherwise need to fetch off the connection repeatedly. For example, imagine if you stored a <code class=\"inline\">conn.assigns.current_user</code> in the connection and wanted quick access to the user for every action in your controller:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def action(conn, _) do\n  apply(__MODULE__, action_name(conn), [conn,\n                                        conn.params,\n                                        conn.assigns.current_user])\nend\n\ndef index(conn, _params, user) do\n  videos = Repo.all(user_videos(user))\n  # ...\nend\n\ndef delete(conn, %{\"id\" =&gt; id}, user) do\n  video = Repo.get!(user_videos(user), id)\n  # ...\nend</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#accepts/2\">accepts(conn, accepted)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Performs content negotiation based on the available formats</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#action_name/1\">action_name(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the action name as an atom, raises if unavailable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#allow_jsonp/2\">allow_jsonp(conn, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>A plug that may convert a JSON response into a JSONP one</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#clear_flash/1\">clear_flash(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Clears all flash messages</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#controller_module/1\">controller_module(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the controller module as an atom, raises if unavailable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete_csrf_token/0\">delete_csrf_token()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes any CSRF token set</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#endpoint_module/1\">endpoint_module(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the endpoint module as an atom, raises if unavailable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch_flash/2\">fetch_flash(conn, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches the flash storage</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_csrf_token/0\">get_csrf_token()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the CSRF token</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_flash/1\">get_flash(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a previously set flash message or nil</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_flash/2\">get_flash(conn, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a message from flash by key</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_format/1\">get_format(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the request format, such as “json”, “html”</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#html/2\">html(conn, data)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends html response</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#json/2\">json(conn, data)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends JSON response</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#layout/1\">layout(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Retrieves the current layout</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#layout_formats/1\">layout_formats(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Retrieves current layout formats</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#protect_from_forgery/2\">protect_from_forgery(conn, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Enables CSRF protection</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_flash/3\">put_flash(conn, key, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Persists a value in flash</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_format/2\">put_format(conn, format)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts the format in the connection</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_layout/2\">put_layout(conn, layout)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stores the layout for rendering</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_layout_formats/2\">put_layout_formats(conn, formats)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets which formats have a layout when rendering</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_new_layout/2\">put_new_layout(conn, layout)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stores the layout for rendering if one was not stored yet</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_new_view/2\">put_new_view(conn, module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stores the view for rendering if one was not stored yet</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_secure_browser_headers/2\">put_secure_browser_headers(conn, headers \\\\ %{})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Put headers that improve browser security</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_view/2\">put_view(conn, module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stores the view for rendering</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#redirect/2\">redirect(conn, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends redirect response to the given url</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#render/2\">render(conn, template_or_assigns \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Render the given template or the default template specified by the current action with the given assigns</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#render/3\">render(conn, template, assigns)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Renders the given <code class=\"inline\">template</code> and <code class=\"inline\">assigns</code> based on the <code class=\"inline\">conn</code> information</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#render/4\">render(conn, view, template, assigns)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A shortcut that renders the given template in the given view</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#router_module/1\">router_module(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the router module as an atom, raises if unavailable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#scrub_params/2\">scrub_params(conn, required_key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Scrubs the parameters from the request</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#text/2\">text(conn, data)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends text response</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#view_module/1\">view_module(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Retrieves the current view</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#view_template/1\">view_template(conn)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the template name rendered in the view as a string (or nil if no template was rendered)</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"accepts/2\">  <span class=\"signature\">accepts(conn, accepted)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">accepts(Plug.Conn.t, [binary]) ::\n  Plug.Conn.t |\n  no_return</code></pre>    <p>Performs content negotiation based on the available formats.</p> <p>It receives a connection, a list of formats that the server is capable of rendering and then proceeds to perform content negotiation based on the request information. If the client accepts any of the given formats, the request proceeds.</p> <p>If the request contains a “_format” parameter, it is considered to be the format desired by the client. If no “_format” parameter is available, this function will parse the “accept” header and find a matching format accordingly.</p> <p>It is important to notice that browsers have historically sent bad accept headers. For this reason, this function will default to “html” format whenever:</p> <ul> <li>\n<p>the accepted list of arguments contains the “html” format</p> </li> <li>the accept header specified more than one media type preceeded or followed by the wildcard media type “<code class=\"inline\">*/*</code>” </li> </ul> <p>This function raises <a href=\"phoenix.notacceptableerror\"><code class=\"inline\">Phoenix.NotAcceptableError</code></a>, which is rendered with status 406, whenever the server cannot serve a response in any of the formats expected by the client.</p> <h4>Examples</h4> <p><a href=\"#accepts/2\"><code class=\"inline\">accepts/2</code></a> can be invoked as a function:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; accepts(conn, [\"html\", \"json\"])</code></pre> <p>or used as a plug:</p> <pre data-language=\"elixir\"><code class=\"elixir\">plug :accepts, [\"html\", \"json\"]\nplug :accepts, ~w(html json)</code></pre> <h4>Custom media types</h4> <p>It is possible to add custom media types to your Phoenix application. The first step is to teach Plug about those new media types in your <code class=\"inline\">config/config.exs</code> file:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :plug, :mimes, %{\n  \"application/vnd.api+json\" =&gt; [\"json-api\"]\n}</code></pre> <p>The key is the media type, the value is a list of formats the media type can be identified with. For example, by using “json-api”, you will be able to use templates with extension “index.json-api” or to force a particular format in a given URL by sending “?_format=json-api”.</p> <p>After this change, you must recompile plug:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$ touch deps/plug/mix.exs\n$ mix deps.compile plug</code></pre> <p>And now you can use it in accepts too:</p> <pre data-language=\"elixir\"><code class=\"elixir\">plug :accepts, [\"html\", \"json-api\"]</code></pre>    <h3 class=\"detail-header function\" id=\"action_name/1\">  <span class=\"signature\">action_name(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">action_name(Plug.Conn.t) :: atom</code></pre>    <p>Returns the action name as an atom, raises if unavailable.</p>    <h3 class=\"detail-header function\" id=\"allow_jsonp/2\">  <span class=\"signature\">allow_jsonp(conn, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">allow_jsonp(Plug.Conn.t, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: Plug.Conn.t</code></pre>    <p>A plug that may convert a JSON response into a JSONP one.</p> <p>In case a JSON response is returned, it will be converted to a JSONP as long as the callback field is present in the query string. The callback field itself defaults to “callback” but may be configured with the callback option.</p> <p>In case there is no callback or the response is not encoded in JSON format, it is a no-op.</p> <p>Only alphanumeric characters and underscore are allowed in the callback name. Otherwise an exception is raised.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Will convert JSON to JSONP if callback=someFunction is given\nplug :allow_jsonp\n\n# Will convert JSON to JSONP if cb=someFunction is given\nplug :allow_jsonp, callback: \"cb\"</code></pre>    <h3 class=\"detail-header function\" id=\"clear_flash/1\">  <span class=\"signature\">clear_flash(conn)</span>  </h3>  <p>Clears all flash messages.</p>    <h3 class=\"detail-header function\" id=\"controller_module/1\">  <span class=\"signature\">controller_module(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">controller_module(Plug.Conn.t) :: atom</code></pre>    <p>Returns the controller module as an atom, raises if unavailable.</p>    <h3 class=\"detail-header function\" id=\"delete_csrf_token/0\">  <span class=\"signature\">delete_csrf_token()</span>  </h3>  <p>Deletes any CSRF token set.</p>    <h3 class=\"detail-header function\" id=\"endpoint_module/1\">  <span class=\"signature\">endpoint_module(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">endpoint_module(Plug.Conn.t) :: atom</code></pre>    <p>Returns the endpoint module as an atom, raises if unavailable.</p>    <h3 class=\"detail-header function\" id=\"fetch_flash/2\">  <span class=\"signature\">fetch_flash(conn, opts \\\\ [])</span>  </h3>  <p>Fetches the flash storage.</p>    <h3 class=\"detail-header function\" id=\"get_csrf_token/0\">  <span class=\"signature\">get_csrf_token()</span>  </h3>  <p>Gets the CSRF token.</p>    <h3 class=\"detail-header function\" id=\"get_flash/1\">  <span class=\"signature\">get_flash(conn)</span>  </h3>  <p>Returns a previously set flash message or nil.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; conn = put_flash(conn, :info, \"Welcome Back!\")\niex&gt; get_flash(conn)\n%{\"info\" =&gt; \"Welcome Back!\"}</code></pre>    <h3 class=\"detail-header function\" id=\"get_flash/2\">  <span class=\"signature\">get_flash(conn, key)</span>  </h3>  <p>Returns a message from flash by key.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; conn = put_flash(conn, :info, \"Welcome Back!\")\niex&gt; get_flash(conn, :info)\n\"Welcome Back!\"</code></pre>    <h3 class=\"detail-header function\" id=\"get_format/1\">  <span class=\"signature\">get_format(conn)</span>  </h3>  <p>Returns the request format, such as “json”, “html”.</p>    <h3 class=\"detail-header function\" id=\"html/2\">  <span class=\"signature\">html(conn, data)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">html(Plug.Conn.t, iodata) :: Plug.Conn.t</code></pre>    <p>Sends html response.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; html conn, \"&lt;html&gt;&lt;head&gt;...\"</code></pre>    <h3 class=\"detail-header function\" id=\"json/2\">  <span class=\"signature\">json(conn, data)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">json(Plug.Conn.t, term) :: Plug.Conn.t</code></pre>    <p>Sends JSON response.</p> <p>It uses the configured <code class=\"inline\">:format_encoders</code> under the <code class=\"inline\">:phoenix</code> application for <code class=\"inline\">:json</code> to pick up the encoder module.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; json conn, %{id: 123}</code></pre>    <h3 class=\"detail-header function\" id=\"layout/1\">  <span class=\"signature\">layout(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">layout(Plug.Conn.t) :: {atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>} | false</code></pre>    <p>Retrieves the current layout.</p>    <h3 class=\"detail-header function\" id=\"layout_formats/1\">  <span class=\"signature\">layout_formats(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">layout_formats(Plug.Conn.t) :: [<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>]</code></pre>    <p>Retrieves current layout formats.</p>    <h3 class=\"detail-header function\" id=\"protect_from_forgery/2\">  <span class=\"signature\">protect_from_forgery(conn, opts \\\\ [])</span>  </h3>  <p>Enables CSRF protection.</p> <p>Currently used as a wrapper function for <code class=\"inline\">Plug.CSRFProtection</code> and mainly serves as a function plug in <code class=\"inline\">YourApp.Router</code>.</p> <p>Check <a href=\"#get_csrf_token/0\"><code class=\"inline\">get_csrf_token/0</code></a> and <a href=\"#delete_csrf_token/0\"><code class=\"inline\">delete_csrf_token/0</code></a> for retrieving and deleting CSRF tokens.</p>    <h3 class=\"detail-header function\" id=\"put_flash/3\">  <span class=\"signature\">put_flash(conn, key, message)</span>  </h3>  <p>Persists a value in flash.</p> <p>Returns the updated connection.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; conn = put_flash(conn, :info, \"Welcome Back!\")\niex&gt; get_flash(conn, :info)\n\"Welcome Back!\"</code></pre>    <h3 class=\"detail-header function\" id=\"put_format/2\">  <span class=\"signature\">put_format(conn, format)</span>  </h3>  <p>Puts the format in the connection.</p> <p>See <a href=\"#get_format/1\"><code class=\"inline\">get_format/1</code></a> for retrieval.</p>    <h3 class=\"detail-header function\" id=\"put_layout/2\">  <span class=\"signature\">put_layout(conn, layout)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_layout(Plug.Conn.t, {atom, binary | atom} | binary | false) :: Plug.Conn.t</code></pre>    <p>Stores the layout for rendering.</p> <p>The layout must be a tuple, specifying the layout view and the layout name, or false. In case a previous layout is set, <code class=\"inline\">put_layout</code> also accepts the layout name to be given as a string or as an atom. If a string, it must contain the format. Passing an atom means the layout format will be found at rendering time, similar to the template in <a href=\"#render/3\"><code class=\"inline\">render/3</code></a>. It can also be set to <code class=\"inline\">false</code>. In this case, no layout would be used.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; layout(conn)\nfalse\n\niex&gt; conn = put_layout conn, {AppView, \"application.html\"}\niex&gt; layout(conn)\n{AppView, \"application.html\"}\n\niex&gt; conn = put_layout conn, \"print.html\"\niex&gt; layout(conn)\n{AppView, \"print.html\"}\n\niex&gt; conn = put_layout conn, :print\niex&gt; layout(conn)\n{AppView, :print}</code></pre> <p>Raises <code class=\"inline\">Plug.Conn.AlreadySentError</code> if the conn was already sent.</p>    <h3 class=\"detail-header function\" id=\"put_layout_formats/2\">  <span class=\"signature\">put_layout_formats(conn, formats)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_layout_formats(Plug.Conn.t, [<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>]) :: Plug.Conn.t</code></pre>    <p>Sets which formats have a layout when rendering.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; layout_formats conn\n[\"html\"]\n\niex&gt; put_layout_formats conn, [\"html\", \"mobile\"]\niex&gt; layout_formats conn\n[\"html\", \"mobile\"]</code></pre> <p>Raises <code class=\"inline\">Plug.Conn.AlreadySentError</code> if the conn was already sent.</p>    <h3 class=\"detail-header function\" id=\"put_new_layout/2\">  <span class=\"signature\">put_new_layout(conn, layout)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_new_layout(Plug.Conn.t, {atom, binary | atom} | false) :: Plug.Conn.t</code></pre>    <p>Stores the layout for rendering if one was not stored yet.</p> <p>Raises <code class=\"inline\">Plug.Conn.AlreadySentError</code> if the conn was already sent.</p>    <h3 class=\"detail-header function\" id=\"put_new_view/2\">  <span class=\"signature\">put_new_view(conn, module)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_new_view(Plug.Conn.t, atom) :: Plug.Conn.t</code></pre>    <p>Stores the view for rendering if one was not stored yet.</p> <p>Raises <code class=\"inline\">Plug.Conn.AlreadySentError</code> if the conn was already sent.</p>    <h3 class=\"detail-header function\" id=\"put_secure_browser_headers/2\">  <span class=\"signature\">put_secure_browser_headers(conn, headers \\\\ %{})</span>  </h3>  <p>Put headers that improve browser security.</p> <p>It sets the following headers:</p> <pre data-language=\"elixir\"><code class=\"elixir\">* x-frame-options - set to SAMEORIGIN to avoid clickjacking\n  through iframes unless in the same origin\n* x-content-type-options - set to nosniff. This requires\n  script and style tags to be sent with proper content type\n* x-xss-protection - set to \"1; mode=block\" to improve XSS\n  protection on both Chrome and IE</code></pre> <p>A custom headers map may also be given to be merged with defaults.</p>    <h3 class=\"detail-header function\" id=\"put_view/2\">  <span class=\"signature\">put_view(conn, module)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_view(Plug.Conn.t, atom) :: Plug.Conn.t</code></pre>    <p>Stores the view for rendering.</p> <p>Raises <code class=\"inline\">Plug.Conn.AlreadySentError</code> if the conn was already sent.</p>    <h3 class=\"detail-header function\" id=\"redirect/2\">  <span class=\"signature\">redirect(conn, opts)</span>  </h3>  <p>Sends redirect response to the given url.</p> <p>For security, <code class=\"inline\">:to</code> only accepts paths. Use the <code class=\"inline\">:external</code> option to redirect to any URL.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; redirect conn, to: \"/login\"\n\niex&gt; redirect conn, external: \"http://elixir-lang.org\"</code></pre>    <h3 class=\"detail-header function\" id=\"render/2\">  <span class=\"signature\">render(conn, template_or_assigns \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">render(Plug.Conn.t, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a> | map | binary | atom) :: Plug.Conn.t</code></pre>    <p>Render the given template or the default template specified by the current action with the given assigns.</p> <p>See <a href=\"#render/3\"><code class=\"inline\">render/3</code></a> for more information.</p>    <h3 class=\"detail-header function\" id=\"render/3\">  <span class=\"signature\">render(conn, template, assigns)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">render(Plug.Conn.t, binary | atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a> | map) :: Plug.Conn.t</code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">render(Plug.Conn.t, module, binary | atom) :: Plug.Conn.t</code></pre>    <p>Renders the given <code class=\"inline\">template</code> and <code class=\"inline\">assigns</code> based on the <code class=\"inline\">conn</code> information.</p> <p>Once the template is rendered, the template format is set as the response content type (for example, an HTML template will set “text/html” as response content type) and the data is sent to the client with default status of 200.</p> <h4>Arguments</h4> <ul> <li>\n<p><code class=\"inline\">conn</code> - the <code class=\"inline\">Plug.Conn</code> struct</p> </li> <li>\n<p><code class=\"inline\">template</code> - which may be an atom or a string. If an atom, like <code class=\"inline\">:index</code>, it will render a template with the same format as the one returned by <a href=\"#get_format/1\"><code class=\"inline\">get_format/1</code></a>. For example, for an HTML request, it will render the “index.html” template. If the template is a string, it must contain the extension too, like “index.json”</p> </li> <li>\n<code class=\"inline\">assigns</code> - a dictionary with the assigns to be used in the view. Those assigns are merged and have higher precedence than the connection assigns (<code class=\"inline\">conn.assigns</code>) </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.UserController do\n  use Phoenix.Controller\n\n  def show(conn, _params) do\n    render conn, \"show.html\", message: \"Hello\"\n  end\nend</code></pre> <p>The example above renders a template “show.html” from the <code class=\"inline\">MyApp.UserView</code> and sets the response content type to “text/html”.</p> <p>In many cases, you may want the template format to be set dynamically based on the request. To do so, you can pass the template name as an atom (without the extension):</p> <pre data-language=\"elixir\"><code class=\"elixir\">def show(conn, _params) do\n  render conn, :show, message: \"Hello\"\nend</code></pre> <p>In order for the example above to work, we need to do content negotiation with the accepts plug before rendering. You can do so by adding the following to your pipeline (in the router):</p> <pre data-language=\"elixir\"><code class=\"elixir\">plug :accepts, [\"html\"]</code></pre> <h4>Views</h4> <p>By default, Controllers render templates in a view with a similar name to the controller. For example, <code class=\"inline\">MyApp.UserController</code> will render templates inside the <code class=\"inline\">MyApp.UserView</code>. This information can be changed any time by using <a href=\"#render/3\"><code class=\"inline\">render/3</code></a>, <a href=\"#render/4\"><code class=\"inline\">render/4</code></a> or the <a href=\"#put_view/2\"><code class=\"inline\">put_view/2</code></a> function:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def show(conn, _params) do\n  render(conn, MyApp.SpecialView, :show, message: \"Hello\")\nend\n\ndef show(conn, _params) do\n  conn\n  |&gt; put_view(MyApp.SpecialView)\n  |&gt; render(:show, message: \"Hello\")\nend</code></pre> <p><a href=\"#put_view/2\"><code class=\"inline\">put_view/2</code></a> can also be used as a plug:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.UserController do\n  use Phoenix.Controller\n\n  plug :put_view, MyApp.SpecialView\n\n  def show(conn, _params) do\n    render conn, :show, message: \"Hello\"\n  end\nend</code></pre> <h4>Layouts</h4> <p>Templates are often rendered inside layouts. By default, Phoenix will render layouts for html requests. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.UserController do\n  use Phoenix.Controller\n\n  def show(conn, _params) do\n    render conn, \"show.html\", message: \"Hello\"\n  end\nend</code></pre> <p>will render the “show.html” template inside an “app.html” template specified in <code class=\"inline\">MyApp.LayoutView</code>. <a href=\"#put_layout/2\"><code class=\"inline\">put_layout/2</code></a> can be used to change the layout, similar to how <a href=\"#put_view/2\"><code class=\"inline\">put_view/2</code></a> can be used to change the view.</p> <p><code class=\"inline\">layout_formats/2</code> and <a href=\"#put_layout_formats/2\"><code class=\"inline\">put_layout_formats/2</code></a> can be used to configure which formats support/require layout rendering (defaults to “html” only).</p>    <h3 class=\"detail-header function\" id=\"render/4\">  <span class=\"signature\">render(conn, view, template, assigns)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">render(Plug.Conn.t, atom, atom | binary, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a> | map) :: Plug.Conn.t</code></pre>    <p>A shortcut that renders the given template in the given view.</p> <p>Equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">conn\n|&gt; put_view(view)\n|&gt; render(template, assigns)</code></pre>    <h3 class=\"detail-header function\" id=\"router_module/1\">  <span class=\"signature\">router_module(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">router_module(Plug.Conn.t) :: atom</code></pre>    <p>Returns the router module as an atom, raises if unavailable.</p>    <h3 class=\"detail-header function\" id=\"scrub_params/2\">  <span class=\"signature\">scrub_params(conn, required_key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">scrub_params(Plug.Conn.t, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: Plug.Conn.t</code></pre>    <p>Scrubs the parameters from the request.</p> <p>This process is two-fold:</p> <ul> <li>Checks to see if the <code class=\"inline\">required_key</code> is present </li> <li>Changes empty parameters of <code class=\"inline\">required_key</code> (recursively) to nils </li> </ul> <p>This function is useful to remove empty strings sent via HTML forms. If you are providing an API, there is likely no need to invoke <a href=\"#scrub_params/2\"><code class=\"inline\">scrub_params/2</code></a>.</p> <p>If the <code class=\"inline\">required_key</code> is not present, it will raise <a href=\"phoenix.missingparamerror\"><code class=\"inline\">Phoenix.MissingParamError</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; scrub_params(conn, \"user\")</code></pre>    <h3 class=\"detail-header function\" id=\"text/2\">  <span class=\"signature\">text(conn, data)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">text(Plug.Conn.t, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.Chars.html#t:t/0\">String.Chars.t</a>) :: Plug.Conn.t</code></pre>    <p>Sends text response.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; text conn, \"hello\"\n\niex&gt; text conn, :implements_to_string</code></pre>    <h3 class=\"detail-header function\" id=\"view_module/1\">  <span class=\"signature\">view_module(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">view_module(Plug.Conn.t) :: atom</code></pre>    <p>Retrieves the current view.</p>    <h3 class=\"detail-header function\" id=\"view_template/1\">  <span class=\"signature\">view_template(conn)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">view_template(Plug.Conn.t) :: binary | nil</code></pre>    <p>Returns the template name rendered in the view as a string (or nil if no template was rendered).</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Controller.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Controller.html</a>\n  </p>\n</div>\n","phoenix/phoenix.socket":"<h1>  Phoenix.Socket <small>behaviour</small>  </h1>  <p>Defines a socket and its state.</p> <p><a href=\"phoenix.socket#content\"><code class=\"inline\">Phoenix.Socket</code></a> is used as a module for establishing and maintaining the socket state via the <a href=\"phoenix.socket#content\"><code class=\"inline\">Phoenix.Socket</code></a> struct.</p> <p>Once connected to a socket, incoming and outgoing events are routed to channels. The incoming client data is routed to channels via transports. It is the responsibility of the socket to tie transports and channels together.</p> <p>By default, Phoenix supports both websockets and longpoll transports. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">transport :websocket, Phoenix.Transports.WebSocket</code></pre> <p>The command above means incoming socket connections can be done via the WebSocket transport. Events are routed by topic to channels:</p> <pre data-language=\"elixir\"><code class=\"elixir\">channel \"room:lobby\", MyApp.LobbyChannel</code></pre> <p>See <a href=\"phoenix.channel\"><code class=\"inline\">Phoenix.Channel</code></a> for more information on channels. Check each transport module to check the options specific to each transport.</p> <h2>Socket Behaviour</h2> <p>Socket handlers are mounted in Endpoints and must define two callbacks:</p> <ul> <li>\n<code class=\"inline\">connect/2</code> - receives the socket params and authenticates the connection. Must return a <a href=\"phoenix.socket#content\"><code class=\"inline\">Phoenix.Socket</code></a> struct, often with custom assigns. </li> <li>\n<code class=\"inline\">id/1</code> - receives the socket returned by <code class=\"inline\">connect/2</code> and returns the id of this connection as a string. The <code class=\"inline\">id</code> is used to identify socket connections, often to a particular user, allowing us to force disconnections. For sockets requiring no authentication, <code class=\"inline\">nil</code> can be returned. </li> </ul> <h2>Examples</h2> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.UserSocket do\n  use Phoenix.Socket\n\n  transport :websocket, Phoenix.Transports.WebSocket\n  channel \"room:*\", MyApp.RoomChannel\n\n  def connect(params, socket) do\n    {:ok, assign(socket, :user_id, params[\"user_id\"])}\n  end\n\n  def id(socket), do: \"users_socket:#{socket.assigns.user_id}\"\nend\n\n# Disconnect all user's socket connections and their multiplexed channels\nMyApp.Endpoint.broadcast(\"users_socket:\" &lt;&gt; user.id, \"disconnect\", %{})</code></pre> <h2>Socket Fields</h2> <ul> <li>\n<code class=\"inline\">id</code> - The string id of the socket </li> <li>\n<code class=\"inline\">assigns</code> - The map of socket assigns, default: <code class=\"inline\">%{}</code> </li> <li>\n<code class=\"inline\">channel</code> - The current channel module </li> <li>\n<code class=\"inline\">channel_pid</code> - The channel pid </li> <li>\n<code class=\"inline\">endpoint</code> - The endpoint module where this socket originated, for example: <code class=\"inline\">MyApp.Endpoint</code> </li> <li>\n<code class=\"inline\">handler</code> - The socket module where this socket originated, for example: <code class=\"inline\">MyApp.UserSocket</code> </li> <li>\n<code class=\"inline\">joined</code> - If the socket has effectively joined the channel </li> <li>\n<code class=\"inline\">pubsub_server</code> - The registered name of the socket’s pubsub server </li> <li>\n<code class=\"inline\">ref</code> - The latest ref sent by the client </li> <li>\n<code class=\"inline\">topic</code> - The string topic, for example <code class=\"inline\">\"room:123\"</code> </li> <li>\n<code class=\"inline\">transport</code> - The socket’s transport, for example: <a href=\"phoenix.transports.websocket\"><code class=\"inline\">Phoenix.Transports.WebSocket</code></a> </li> <li>\n<code class=\"inline\">transport_pid</code> - The pid of the socket’s transport process </li> <li>\n<code class=\"inline\">transport_name</code> - The socket’s transport, for example: <code class=\"inline\">:websocket</code> </li> <li>\n<code class=\"inline\">serializer</code> - The serializer for socket messages, for example: <code class=\"inline\">Phoenix.Transports.WebSocketSerializer</code> </li> </ul> <h2>Custom transports</h2> <p>See the <a href=\"phoenix.socket.transport\"><code class=\"inline\">Phoenix.Socket.Transport</code></a> documentation for more information on writing your own transports.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#assign/3\">assign(socket, key, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds key/value pair to socket assigns</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#channel/3\">channel(topic_pattern, module, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a channel matching the given topic and transports</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#transport/3\">transport(name, module, config \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a transport with configuration</p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:connect/2\">connect(params, arg1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives the socket params and authenticates the connection</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:id/1\">id(arg0)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Identifies the socket connection</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Phoenix.Socket{assigns: %{}, channel: atom, channel_pid: pid, endpoint: atom, handler: atom, id: nil, joined: boolean, pubsub_server: atom, ref: term, serializer: atom, topic: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, transport: atom, transport_name: atom, transport_pid: pid}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"assign/3\">  <span class=\"signature\">assign(socket, key, value)</span>  </h3>  <p>Adds key/value pair to socket assigns.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; socket.assigns[:token]\nnil\niex&gt; socket = assign(socket, :token, \"bar\")\niex&gt; socket.assigns[:token]\n\"bar\"</code></pre>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"channel/3\">  <span class=\"signature\">channel(topic_pattern, module, opts \\\\ [])</span>  </h3>  <p>Defines a channel matching the given topic and transports.</p> <ul> <li>\n<code class=\"inline\">topic_pattern</code> - The string pattern, for example “room:<em>”, “users:</em>”, “system” </li> <li>\n<code class=\"inline\">module</code> - The channel module handler, for example <code class=\"inline\">MyApp.RoomChannel</code> </li> <li>\n<code class=\"inline\">opts</code> - The optional list of options, see below </li> </ul> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:via</code> - the transport adapters to accept on this channel. Defaults <code class=\"inline\">[:websocket, :longpoll]</code> </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">channel \"topic1:*\", MyChannel\nchannel \"topic2:*\", MyChannel, via: [:websocket]\nchannel \"topic\",    MyChannel, via: [:longpoll]</code></pre> <h4>Topic Patterns</h4> <p>The <code class=\"inline\">channel</code> macro accepts topic patterns in two flavors. A splat argument can be provided as the last character to indicate a “topic:subtopic” match. If a plain string is provied, only that topic will match the channel handler. Most use-cases will use the “topic:*” pattern to allow more versatile topic scoping.</p> <p>See <a href=\"phoenix.channel\"><code class=\"inline\">Phoenix.Channel</code></a> for more information</p>    <h3 class=\"detail-header macro\" id=\"transport/3\">  <span class=\"signature\">transport(name, module, config \\\\ [])</span>  </h3>  <p>Defines a transport with configuration.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># customize default `:websocket` transport options\ntransport :websocket, Phoenix.Transports.WebSocket,\n  timeout: 10_000\n\n# define separate transport, using websocket handler\ntransport :websocket_slow_clients, Phoenix.Transports.WebSocket,\n  timeout: 60_000</code></pre>     <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:connect/2\">  <span class=\"signature\">connect(params, arg1)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">connect(params :: map, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>) ::\n  {:ok, <a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>} |\n  :error</code></pre>    <p>Receives the socket params and authenticates the connection.</p> <h4>Socket params and assigns</h4> <p>Socket params are passed from the client and can be used to verify and authenticate a user. After verification, you can put default assigns into the socket that will be set for all channels, ie</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:ok, assign(socket, :user_id, verified_user_id)}</code></pre> <p>To deny connection, return <code class=\"inline\">:error</code>.</p> <p>See <a href=\"phoenix.token\"><code class=\"inline\">Phoenix.Token</code></a> documentation for examples in performing token verification on connect.</p>    <h3 class=\"detail-header callback\" id=\"c:id/1\">  <span class=\"signature\">id(arg0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">id(<a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a> | nil</code></pre>    <p>Identifies the socket connection.</p> <p>Socket id’s are topics that allow you to identify all sockets for a given user:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def id(socket), do: \"users_socket:#{socket.assigns.user_id}\"</code></pre> <p>Would allow you to broadcast a “disconnect” event and terminate all active sockets and channels for a given user:</p> <pre data-language=\"elixir\"><code class=\"elixir\">MyApp.Endpoint.broadcast(\"users_socket:\" &lt;&gt; user.id, \"disconnect\", %{})</code></pre> <p>Returning <code class=\"inline\">nil</code> makes this socket anonymous.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Socket.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Socket.html</a>\n  </p>\n</div>\n","phoenix/phoenix.template.engine":"<h1>  Phoenix.Template.Engine <small>behaviour</small>  </h1>  <p>Specifies the API for adding custom template engines into Phoenix.</p> <p>Engines need only to implement the <code class=\"inline\">compile/2</code> function, that receives the template file and the template name and outputs the template quoted expression:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def compile(template_path, template_name)</code></pre> <p>See <a href=\"phoenix.template.eexengine\"><code class=\"inline\">Phoenix.Template.EExEngine</code></a> for an example engine implementation.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:compile/2\">compile(template_path, template_name)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:compile/2\">  <span class=\"signature\">compile(template_path, template_name)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">compile(template_path :: binary, template_name :: binary) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Macro.html#t:t/0\">Macro.t</a></code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Template.Engine.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Template.Engine.html</a>\n  </p>\n</div>\n","phoenix/phoenix.notacceptableerror":"<h1>  Phoenix.NotAcceptableError <small>exception</small>  </h1>  <p>Raised when one of the <code class=\"inline\">accept*</code> headers is not accepted by the server.</p> <p>This exception is commonly raised by <a href=\"phoenix.controller#accepts/2\"><code class=\"inline\">Phoenix.Controller.accepts/2</code></a> which negotiates the media types the server is able to serve with the contents the client is able to render.</p> <p>If you are seeing this error, you should check if you are listing the desired formats in your <code class=\"inline\">:accepts</code> plug or if you are setting the proper accept header in the client. The exception contains the acceptable mime types in the <code class=\"inline\">accepts</code> field.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.NotAcceptableError.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.NotAcceptableError.html</a>\n  </p>\n</div>\n","phoenix/phoenix.socket.transport":"<h1>  Phoenix.Socket.Transport <small>behaviour</small>  </h1>  <p>API for building transports.</p> <p>This module describes what is required to build a Phoenix transport. The transport sits between the socket and channels, forwarding client messages to channels and vice-versa.</p> <p>A transport is responsible for:</p> <ul> <li>Implementing the transport behaviour </li> <li>Establishing the socket connection </li> <li>Handling of incoming messages </li> <li>Handling of outgoing messages </li> <li>Managing channels </li> <li>Providing secure defaults </li> </ul> <h2>The transport behaviour</h2> <p>The transport requires two functions:</p> <ul> <li>\n<p><code class=\"inline\">default_config/0</code> - returns the default transport configuration to be merged when the transport is declared in the socket module</p> </li> <li>\n<code class=\"inline\">handlers/0</code> - returns a map of handlers. For example, if the transport can be run cowboy, it just need to specify the appropriate cowboy handler </li> </ul> <h2>Socket connections</h2> <p>Once a connection is established, the transport is responsible for invoking the <code class=\"inline\">Phoenix.Socket.connect/2</code> callback and acting accordingly. Once connected, the transport should request the <code class=\"inline\">Phoenix.Socket.id/1</code> and subscribe to the topic if one exists. On subscribed, the transport must be able to handle “disconnect” broadcasts on the given id topic.</p> <p>The <a href=\"#connect/6\"><code class=\"inline\">connect/6</code></a> function in this module can be used as a convenience or a documentation on such steps.</p> <h2>Incoming messages</h2> <p>Incoming messages are encoded in whatever way the transport chooses. Those messages must be decoded in the transport into a <a href=\"phoenix.socket.message\"><code class=\"inline\">Phoenix.Socket.Message</code></a> before being forwarded to a channel.</p> <p>Most of those messages are user messages except by:</p> <ul> <li>“heartbeat” events in the “phoenix” topic - should just emit an OK reply </li> <li>“phx_join” on any topic - should join the topic </li> <li>“phx_leave” on any topic - should leave the topic </li> </ul> <p>The function <a href=\"#dispatch/3\"><code class=\"inline\">dispatch/3</code></a> can help with handling of such messages.</p> <h2>Outgoing messages</h2> <p>Channels can send two types of messages back to a transport: <a href=\"phoenix.socket.message\"><code class=\"inline\">Phoenix.Socket.Message</code></a> and <a href=\"phoenix.socket.reply\"><code class=\"inline\">Phoenix.Socket.Reply</code></a>. Those messages are encoded in the channel into a format defined by the transport. That’s why transports are required to pass a serializer that abides to the behaviour described in <a href=\"phoenix.transports.serializer\"><code class=\"inline\">Phoenix.Transports.Serializer</code></a>.</p> <h2>Managing channels</h2> <p>Because channels are spawned from the transport process, transports must trap exits and correctly handle the <code class=\"inline\">{:EXIT, _, _}</code> messages arriving from channels, relaying the proper response to the client.</p> <p>The following events are sent by the transport when a channel exits:</p> <ul> <li>\n<code class=\"inline\">\"phx_close\"</code> - The channel has exited gracefully </li> <li>\n<code class=\"inline\">\"phx_error\"</code> - The channel has crashed </li> </ul> <p>The <a href=\"#on_exit_message/3\"><code class=\"inline\">on_exit_message/3</code></a> function aids in constructing these messages.</p> <h2>Duplicate Join Subscriptions</h2> <p>For a given topic, the client may only establish a single channel subscription. When attempting to create a duplicate subscription, <a href=\"#dispatch/3\"><code class=\"inline\">dispatch/3</code></a> will close the existing channel, log a warning, and spawn a new channel for the topic. When sending the <code class=\"inline\">\"phx_close\"</code> event form the closed channel, the message will contain the <code class=\"inline\">ref</code> the client sent when joining. This allows the client to uniquely identify <code class=\"inline\">\"phx_close\"</code> and <code class=\"inline\">\"phx_error\"</code> messages when force-closing a channel on duplicate joins.</p> <h2>Security</h2> <p>This module also provides functions to enable a secure environment on transports that, at some point, have access to a <code class=\"inline\">Plug.Conn</code>.</p> <p>The functionality provided by this module help with doing “origin” header checks and ensuring only SSL connections are allowed.</p> <h2>Remote Client</h2> <p>Channels can reply, synchronously, to any <code class=\"inline\">handle_in/3</code> event. To match pushes with replies, clients must include a unique <code class=\"inline\">ref</code> with every message and the channel server will reply with a matching ref where the client and pick up the callback for the matching reply.</p> <p>Phoenix includes a JavaScript client for WebSocket and Longpolling support using JSON encodings.</p> <p>However, a client can be implemented for other protocols and encodings by abiding by the <a href=\"phoenix.socket.message\"><code class=\"inline\">Phoenix.Socket.Message</code></a> format.</p> <h2>Protocol Versioning</h2> <p>Clients are expected to send the Channel Transport protocol version that they expect to be talking to. The version can be retrieved on the server from <code class=\"inline\">Phoenix.Channel.Transport.protocol_version/0</code>. If no version is provided, the Transport adapters should default to assume a <code class=\"inline\">\"1.0.0\"</code> version number. See <code class=\"inline\">web/static/js/phoenix.js</code> for an example transport client implementation.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#check_origin/5\">check_origin(conn, handler, endpoint, opts, sender \\\\ &amp;Plug.Conn.send_resp/1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks the origin request header against the list of allowed origins</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#connect/6\">connect(endpoint, handler, transport_name, transport, serializer, params)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles the socket connection</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dispatch/3\">dispatch(msg, channels, socket)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dispatches <a href=\"phoenix.socket.message\"><code class=\"inline\">Phoenix.Socket.Message</code></a> to a channel</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#force_ssl/4\">force_ssl(conn, socket, endpoint, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Forces SSL in the socket connection</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#on_exit_message/2\">on_exit_message(topic, reason)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the message to be relayed when a channel exists</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#on_exit_message/3\">on_exit_message(topic, join_ref, reason)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#protocol_version/0\">protocol_version()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the Channel Transport protocol version</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#transport_log/2\">transport_log(conn, level)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Logs the transport request</p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:default_config/0\">default_config()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Provides a keyword list of default configuration for socket transports</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"check_origin/5\">  <span class=\"signature\">check_origin(conn, handler, endpoint, opts, sender \\\\ &amp;Plug.Conn.send_resp/1)</span>  </h3>  <p>Checks the origin request header against the list of allowed origins.</p> <p>Should be called by transports before connecting when appropriate. If the origin header matches the allowed origins, no origin header was sent or no origin was configured, it will return the given connection.</p> <p>Otherwise a otherwise a 403 Forbidden response will be sent and the connection halted. It is a noop if the connection has been halted.</p>    <h3 class=\"detail-header function\" id=\"connect/6\">  <span class=\"signature\">connect(endpoint, handler, transport_name, transport, serializer, params)</span>  </h3>  <p>Handles the socket connection.</p> <p>It builds a new <a href=\"phoenix.socket\"><code class=\"inline\">Phoenix.Socket</code></a> and invokes the handler <code class=\"inline\">connect/2</code> callback and returns the result.</p> <p>If the connection was successful, generates <code class=\"inline\">Phoenix.PubSub</code> topic from the <code class=\"inline\">id/1</code> callback.</p>    <h3 class=\"detail-header function\" id=\"dispatch/3\">  <span class=\"signature\">dispatch(msg, channels, socket)</span>  </h3>  <p>Dispatches <a href=\"phoenix.socket.message\"><code class=\"inline\">Phoenix.Socket.Message</code></a> to a channel.</p> <p>All serialized, remote client messages should be deserialized and forwarded through this function by adapters.</p> <p>The following returns must be handled by transports:</p> <ul> <li>\n<code class=\"inline\">:noreply</code> - Nothing to be done by the transport </li> <li>\n<code class=\"inline\">{:reply, reply}</code> - The reply to be sent to the client </li> <li>\n<code class=\"inline\">{:joined, channel_pid, reply}</code> - The channel was joined and the reply must be sent as result </li> <li>\n<code class=\"inline\">{:error, reason, reply}</code> - An error happened and the reply must be sent as result </li> </ul> <h4>Parameters filtering on join</h4> <p>When logging parameters, Phoenix can filter out sensitive parameters in the logs, such as passwords, tokens and what not. Parameters to be filtered can be added via the <code class=\"inline\">:filter_parameters</code> option:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :phoenix, :filter_parameters, [\"password\", \"secret\"]</code></pre> <p>With the configuration above, Phoenix will filter any parameter that contains the terms <code class=\"inline\">password</code> or <code class=\"inline\">secret</code>. The match is case sensitive.</p> <p>Phoenix’s default is <code class=\"inline\">[\"password\"]</code>.</p>    <h3 class=\"detail-header function\" id=\"force_ssl/4\">  <span class=\"signature\">force_ssl(conn, socket, endpoint, opts)</span>  </h3>  <p>Forces SSL in the socket connection.</p> <p>Uses the endpoint configuration to decide so. It is a noop if the connection has been halted.</p>    <h3 class=\"detail-header function\" id=\"on_exit_message/2\">  <span class=\"signature\">on_exit_message(topic, reason)</span>  </h3>  <p>Returns the message to be relayed when a channel exists.</p>    <h3 class=\"detail-header function\" id=\"on_exit_message/3\">  <span class=\"signature\">on_exit_message(topic, join_ref, reason)</span>  </h3>     <h3 class=\"detail-header function\" id=\"protocol_version/0\">  <span class=\"signature\">protocol_version()</span>  </h3>  <p>Returns the Channel Transport protocol version.</p>    <h3 class=\"detail-header function\" id=\"transport_log/2\">  <span class=\"signature\">transport_log(conn, level)</span>  </h3>  <p>Logs the transport request.</p> <p>Available for transports that generate a connection.</p>     <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:default_config/0\">  <span class=\"signature\">default_config()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">default_config :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a></code></pre>    <p>Provides a keyword list of default configuration for socket transports.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Socket.Transport.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Socket.Transport.html</a>\n  </p>\n</div>\n","phoenix/phoenix.template":"<h1>  Phoenix.Template  </h1>  <p>Templates are used by Phoenix on rendering.</p> <p>Since many views require rendering large contents, for example a whole HTML file, it is common to put those files in the file system into a particular directory, typically “web/templates”.</p> <p>This module provides conveniences for reading all files from a particular directory and embedding them into a single module. Imagine you have a directory with templates:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># templates/foo.html.eex\nHello &lt;%= @name %&gt;\n\n# templates.ex\ndefmodule Templates do\n  use Phoenix.Template, root: \"templates\"\nend</code></pre> <p>Now the template foo can be directly rendered with:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Templates.render(\"foo.html\", %{name: \"John Doe\"})</code></pre> <h2>Options</h2> <ul> <li>\n<code class=\"inline\">:root</code> - the root template path to find templates </li> <li>\n<code class=\"inline\">:pattern</code> - the wildcard pattern to apply to the root when finding templates. Default <code class=\"inline\">\"*\"</code> </li> </ul> <h2>Rendering</h2> <p>In some cases, you will want to overide the <code class=\"inline\">render/2</code> clause to compose the assigns for the template before rendering. In such cases, you can render the template directly by calling the generated private function <code class=\"inline\">render_template/2</code>. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># templates/foo.html.eex\nHello &lt;%= @name %&gt;\n\n# templates.ex\ndefmodule Templates do\n  use Phoenix.Template, root: \"templates\"\n\n  def render(\"foo.html\", %{name: name}) do\n    render_template(\"foo.html\", %{name: String.upcase(name)})\n  end\nend</code></pre> <p>In practice, developers rarely use <a href=\"phoenix.template#content\"><code class=\"inline\">Phoenix.Template</code></a> directly. Instead they use <a href=\"phoenix.view\"><code class=\"inline\">Phoenix.View</code></a> which wraps the template functionality and adds some extra conveniences.</p> <h2>Terminology</h2> <p>Here is a quick introduction into Phoenix templates terms:</p> <ul> <li>\n<p>template name - is the name of the template as given by the user, without the template engine extension, for example: “users.html”</p> </li> <li>\n<p>template path - is the complete path of the template in the filesystem, for example, “path/to/users.html.eex”</p> </li> <li>\n<p>template root - the directory were templates are defined</p> </li> <li>template engine - a module that receives a template path and transforms its source code into Elixir quoted expressions. </li> </ul> <h2>Custom Template Engines</h2> <p>Phoenix supports custom template engines. Engines tell Phoenix how to convert a template path into quoted expressions. Please check <a href=\"phoenix.template.engine\"><code class=\"inline\">Phoenix.Template.Engine</code></a> for more information on the API required to be implemented by custom engines.</p> <p>Once a template engine is defined, you can tell Phoenix about it via the template engines option:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :phoenix, :template_engines,\n  eex: Phoenix.Template.EExEngine,\n  exs: Phoenix.Template.ExsEngine</code></pre> <h2>Format encoders</h2> <p>Besides template engines, Phoenix has the concept of format encoders. Format encoders work per format and are responsible for encoding a given format to string once the view layer finishes processing.</p> <p>A format encoder must export a function called <code class=\"inline\">encode_to_iodata!/1</code> which receives the rendering artifact and returns iodata.</p> <p>New encoders can be added via the format encoder option:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :phoenix, :format_encoders,\n  html: Phoenix.HTML.Engine,\n  json: Poison</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:name/0\">name()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:path/0\">path()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:root/0\">root()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#engines/0\">engines()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a keyword list with all template engines extensions followed by their modules</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#find_all/2\">find_all(root, pattern \\\\ \"*\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all template paths in a given template root</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format_encoder/1\">format_encoder(template_name)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the format encoder for the given template name</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#hash/2\">hash(root, pattern \\\\ \"*\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the hash of all template paths in the given root</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#module_to_template_root/3\">module_to_template_root(module, base, suffix)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a module, without the suffix, to a template root</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#template_path_to_name/2\">template_path_to_name(path, root)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the template path into the template name</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:name/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:name/0\">name</a> :: binary</code></pre> </div> <div id=\"t:path/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:path/0\">path</a> :: binary</code></pre> </div> <div id=\"t:root/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:root/0\">root</a> :: binary</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"engines/0\">  <span class=\"signature\">engines()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">engines :: %{optional(atom) =&gt; module}</code></pre>    <p>Returns a keyword list with all template engines extensions followed by their modules.</p>    <h3 class=\"detail-header function\" id=\"find_all/2\">  <span class=\"signature\">find_all(root, pattern \\\\ \"*\")</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">find_all(<a href=\"#t:root/0\">root</a>, pattern :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: [<a href=\"#t:path/0\">path</a>]</code></pre>    <p>Returns all template paths in a given template root.</p>    <h3 class=\"detail-header function\" id=\"format_encoder/1\">  <span class=\"signature\">format_encoder(template_name)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">format_encoder(<a href=\"#t:name/0\">name</a>) :: module | nil</code></pre>    <p>Returns the format encoder for the given template name.</p>    <h3 class=\"detail-header function\" id=\"hash/2\">  <span class=\"signature\">hash(root, pattern \\\\ \"*\")</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">hash(<a href=\"#t:root/0\">root</a>, pattern :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: binary</code></pre>    <p>Returns the hash of all template paths in the given root.</p> <p>Used by Phoenix to check if a given root path requires recompilation.</p>    <h3 class=\"detail-header function\" id=\"module_to_template_root/3\">  <span class=\"signature\">module_to_template_root(module, base, suffix)</span>  </h3>  <p>Converts a module, without the suffix, to a template root.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Template.module_to_template_root(MyApp.UserView, MyApp, \"View\")\n\"user\"\n\niex&gt; Phoenix.Template.module_to_template_root(MyApp.Admin.User, MyApp, \"View\")\n\"admin/user\"\n\niex&gt; Phoenix.Template.module_to_template_root(MyApp.Admin.User, MyApp.Admin, \"View\")\n\"user\"\n\niex&gt; Phoenix.Template.module_to_template_root(MyApp.View, MyApp, \"View\")\n\"\"\n\niex&gt; Phoenix.Template.module_to_template_root(MyApp.View, MyApp.View, \"View\")\n\"\"</code></pre>    <h3 class=\"detail-header function\" id=\"template_path_to_name/2\">  <span class=\"signature\">template_path_to_name(path, root)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">template_path_to_name(<a href=\"#t:path/0\">path</a>, <a href=\"#t:root/0\">root</a>) :: <a href=\"#t:name/0\">name</a></code></pre>    <p>Converts the template path into the template name.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Template.template_path_to_name(\n...&gt;   \"lib/templates/admin/users/show.html.eex\",\n...&gt;   \"lib/templates\")\n\"admin/users/show.html\"</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Template.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Template.html</a>\n  </p>\n</div>\n","phoenix/phoenix.template.eexengine":"<h1>  Phoenix.Template.EExEngine  </h1>  <p>The Phoenix engine that handles the <code class=\"inline\">.eex</code> extension.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#compile/2\">compile(path, name)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"phoenix.template.engine#c:compile/2\"><code class=\"inline\">Phoenix.Template.Engine.compile/2</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"compile/2\">  <span class=\"signature\">compile(path, name)</span>  </h3>  <p>Callback implementation for <a href=\"phoenix.template.engine#c:compile/2\"><code class=\"inline\">Phoenix.Template.Engine.compile/2</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Template.EExEngine.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Template.EExEngine.html</a>\n  </p>\n</div>\n","phoenix/phoenix.template.exsengine":"<h1>  Phoenix.Template.ExsEngine  </h1>  <p>The Phoenix engine that handles the <code class=\"inline\">.exs</code> extension.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#compile/2\">compile(path, name)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"phoenix.template.engine#c:compile/2\"><code class=\"inline\">Phoenix.Template.Engine.compile/2</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"compile/2\">  <span class=\"signature\">compile(path, name)</span>  </h3>  <p>Callback implementation for <a href=\"phoenix.template.engine#c:compile/2\"><code class=\"inline\">Phoenix.Template.Engine.compile/2</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Template.ExsEngine.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Template.ExsEngine.html</a>\n  </p>\n</div>\n","phoenix/phoenix.template.html":"<h1>  Phoenix.Template.HTML  </h1>  <p>The default HTML encoder that ships with Phoenix.</p> <p>It expects <code class=\"inline\">{:safe, body}</code> as a safe response or body as a string which will be HTML escaped.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#encode_to_iodata!/1\">encode_to_iodata!(body)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Encodes the HTML templates to iodata</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"encode_to_iodata!/1\">  <span class=\"signature\">encode_to_iodata!(body)</span>  </h3>  <p>Encodes the HTML templates to iodata.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Template.HTML.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Template.HTML.html</a>\n  </p>\n</div>\n","phoenix/phoenix.presence":"<h1>  Phoenix.Presence <small>behaviour</small>  </h1>  <p>Provides Presence tracking to processes and channels.</p> <p>This behaviour provides presence features such as fetching presences for a given topic, as well as handling diffs of join and leave events as they occur in real-time. Using this module defines a supervisor and allows the calling module to implement the <code class=\"inline\">Phoenix.Tracker</code> behaviour which starts a tracker process to handle presence information.</p> <h2>Example Usage</h2> <p>Start by defining a presence module within your application which uses <a href=\"phoenix.presence#content\"><code class=\"inline\">Phoenix.Presence</code></a> and provide the <code class=\"inline\">:otp_app</code> which holds your configuration, as well as the <code class=\"inline\">:pubsub_server</code>.</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.Presence do\n  use Phoenix.Presence, otp_app: :my_app,\n                        pubsub_server: MyApp.PubSub\nend</code></pre> <p>The <code class=\"inline\">:pubsub_server</code> must point to an existing pubsub server running in your application, which is included by default as <code class=\"inline\">MyApp.PubSub</code> for new applications.</p> <p>Next, add the new supervisor to your supervision tree in <code class=\"inline\">lib/my_app.ex</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">children = [\n  ...\n  supervisor(MyApp.Presence, []),\n]</code></pre> <p>Once added, presences can be tracked in your channel after joining:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.MyChannel do\n  use MyApp.Web, :channel\n  alias MyApp.Presence\n\n  def join(\"some:topic\", _params, socket) do\n    send(self, :after_join)\n    {:ok, assign(socket, :user_id, ...)}\n  end\n\n  def handle_info(:after_join, socket) do\n    push socket, \"presence_state\", Presence.list(socket)\n    {:ok, _} = Presence.track(socket, socket.assigns.user_id, %{\n      online_at: inspect(System.system_time(:seconds))\n    })\n    {:noreply, socket}\n  end\nend</code></pre> <p>In the example above, <code class=\"inline\">Presence.track</code> is used to register this channel’s process as a presence for the socket’s user ID, with a map of metadata. Next, the current presence information for the socket’s topic is pushed to the client as a <code class=\"inline\">\"presence_state\"</code> event.</p> <p>Finally, a diff of presence join and leave events will be sent to the client as they happen in real-time with the “presence_diff” event. The diff structure will be a map of <code class=\"inline\">:joins</code> and <code class=\"inline\">:leaves</code> of the form:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%{joins: %{\"123\" =&gt; %{metas: [%{status: \"away\", phx_ref: ...}]},\n  leaves: %{\"456\" =&gt; %{metas: [%{status: \"online\", phx_ref: ...}]},</code></pre> <p>See <a href=\"phoenix.presence#list/2\"><code class=\"inline\">Phoenix.Presence.list/2</code></a> for more information on the presence datastructure.</p> <h2>Fetching Presence Information</h2> <p>Presence metadata should be minimized and used to store small, ephemeral state, such as a user’s “online” or “away” status. More detailed information, such as user details that need to be fetched from the database, can be achieved by overriding the <code class=\"inline\">fetch/2</code> function. The <code class=\"inline\">fetch/2</code> callback is triggered when using <code class=\"inline\">list/1</code> and serves as a mechanism to fetch presence information a single time, before broadcasting the information to all channel subscribers. This prevents N query problems and gives you a single place to group isolated data fetching to extend presence metadata. The function must return a map of data matching the outlined Presence datastructure, including the <code class=\"inline\">:metas</code> key, but can extend the map of information to include any additional information. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def fetch(_topic, entries) do\n  query =\n    from u in User,\n      where: u.id in ^Map.keys(entries),\n      select: {u.id, u}\n\n  users = query |&gt; Repo.all |&gt; Enum.into(%{})\n\n  for {key, %{metas: metas}} &lt;- entries, into: %{} do\n    {key, %{metas: metas, user: users[key]}}\n  end\nend</code></pre> <p>The function above fetches all users from the database who have registered presences for the given topic. The fetched information is then extended with a <code class=\"inline\">:user</code> key of the user’s information, while maintaining the required <code class=\"inline\">:metas</code> field from the original presence data.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:presence/0\">presence()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:presences/0\">presences()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:topic/0\">topic()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#list/2\">list(module, topic)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns presences for a topic</p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:fetch/2\">fetch(topic, presences)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:handle_diff/2\">handle_diff(%{}, state)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:init/1\">init(arg0)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:list/1\">list(topic)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:start_link/1\">start_link(arg0)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:track/3\">track(arg0, key, meta)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:track/4\">track(pid, topic, key, meta)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:untrack/2\">untrack(arg0, key)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:untrack/3\">untrack(pid, topic, key)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:update/3\">update(arg0, key, meta)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:update/4\">update(pid, topic, key, meta)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:presence/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:presence/0\">presence</a> :: %{key: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, meta: map}</code></pre> </div> <div id=\"t:presences/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:presences/0\">presences</a> :: %{optional(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) =&gt; %{metas: [map]}}</code></pre> </div> <div id=\"t:topic/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:topic/0\">topic</a> :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"list/2\">  <span class=\"signature\">list(module, topic)</span>  </h3>  <p>Returns presences for a topic.</p> <h4>Presence datastructure</h4> <p>The presence information is returned as map with presences grouped by key, cast as a string, and accumulated metadata, with the following form:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%{key =&gt; %{metas: [%{phx_ref: ..., ...}, ...]}}</code></pre> <p>For example, imagine a user with id <code class=\"inline\">123</code> online from two different devices, as well as a user with id <code class=\"inline\">456</code> online from just one device. The following presence information might be returned:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%{\"123\" =&gt; %{metas: [%{status: \"away\", phx_ref: ...},\n                     %{status: \"online\", phx_ref: ...}]},\n  \"456\" =&gt; %{metas: [%{status: \"online\", phx_ref: ...}]}}</code></pre> <p>The keys of the map will usually point to a resource ID. The value will contain a map with a <code class=\"inline\">:metas</code> key containing a list of metadata for each resource. Additionally, every metadata entry will contain a <code class=\"inline\">:phx_ref</code> key which can be used to uniquely identify metadata for a given key. In the event that the metadata was previously updated, a <code class=\"inline\">:phx_ref_prev</code> key will be present containing the previous <code class=\"inline\">:phx_ref</code> value.</p>     <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:fetch/2\">  <span class=\"signature\">fetch(topic, presences)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch(<a href=\"#t:topic/0\">topic</a>, <a href=\"#t:presences/0\">presences</a>) :: <a href=\"#t:presences/0\">presences</a></code></pre>       <h3 class=\"detail-header callback\" id=\"c:handle_diff/2\">  <span class=\"signature\">handle_diff(%{}, state)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_diff(%{optional(<a href=\"#t:topic/0\">topic</a>) =&gt; {joins :: <a href=\"#t:presences/0\">presences</a>, leaves :: <a href=\"#t:presences/0\">presences</a>}}, state :: term) :: {:ok, state :: term}</code></pre>       <h3 class=\"detail-header callback\" id=\"c:init/1\">  <span class=\"signature\">init(arg0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">init(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, pid} |\n  {:error, reason :: term}</code></pre>       <h3 class=\"detail-header callback\" id=\"c:list/1\">  <span class=\"signature\">list(topic)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">list(<a href=\"#t:topic/0\">topic</a>) :: <a href=\"#t:presences/0\">presences</a></code></pre>       <h3 class=\"detail-header callback\" id=\"c:start_link/1\">  <span class=\"signature\">start_link(arg0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_link(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: {:ok, pid} | {:error, reason :: term} :: :ignore</code></pre>       <h3 class=\"detail-header callback\" id=\"c:track/3\">  <span class=\"signature\">track(arg0, key, meta)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">track(<a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>, key :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, meta :: map) ::\n  {:ok, binary} |\n  {:error, reason :: term}</code></pre>       <h3 class=\"detail-header callback\" id=\"c:track/4\">  <span class=\"signature\">track(pid, topic, key, meta)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">track(pid, <a href=\"#t:topic/0\">topic</a>, key :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, meta :: map) ::\n  {:ok, binary} |\n  {:error, reason :: term}</code></pre>       <h3 class=\"detail-header callback\" id=\"c:untrack/2\">  <span class=\"signature\">untrack(arg0, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">untrack(<a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>, key :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: :ok</code></pre>       <h3 class=\"detail-header callback\" id=\"c:untrack/3\">  <span class=\"signature\">untrack(pid, topic, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">untrack(pid, <a href=\"#t:topic/0\">topic</a>, key :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: :ok</code></pre>       <h3 class=\"detail-header callback\" id=\"c:update/3\">  <span class=\"signature\">update(arg0, key, meta)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update(<a href=\"phoenix.socket#t:t/0\">Phoenix.Socket.t</a>, key :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, meta :: map) ::\n  {:ok, binary} |\n  {:error, reason :: term}</code></pre>       <h3 class=\"detail-header callback\" id=\"c:update/4\">  <span class=\"signature\">update(pid, topic, key, meta)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update(pid, <a href=\"#t:topic/0\">topic</a>, key :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, meta :: map) ::\n  {:ok, binary} |\n  {:error, reason :: term}</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Presence.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Presence.html</a>\n  </p>\n</div>\n","phoenix/phoenix.transports.longpoll":"<h1>  Phoenix.Transports.LongPoll  </h1>  <p>Socket transport for long poll clients.</p> <h2>Configuration</h2> <p>The long poll is configurable in your socket:</p> <pre data-language=\"elixir\"><code class=\"elixir\">transport :longpoll, Phoenix.Transports.LongPoll,\n  window_ms: 10_000,\n  pubsub_timeout_ms: 2_000,\n  transport_log: false,\n  crypto: [max_age: 1209600]</code></pre> <ul> <li>\n<p><code class=\"inline\">:window_ms</code> - how long the client can wait for new messages in its poll request</p> </li> <li>\n<p><code class=\"inline\">:pubsub_timeout_ms</code> - how long a request can wait for the pubsub layer to respond</p> </li> <li>\n<p><code class=\"inline\">:crypto</code> - options for verifying and signing the token, accepted by <a href=\"phoenix.token\"><code class=\"inline\">Phoenix.Token</code></a>. By default tokens are valid for 2 weeks</p> </li> <li>\n<p><code class=\"inline\">:transport_log</code> - if the transport layer itself should log and, if so, the level</p> </li> <li>\n<p><code class=\"inline\">:check_origin</code> - if we should check the origin of requests when the origin header is present. It defaults to true and, in such cases, it will check against the host value in <code class=\"inline\">YourApp.Endpoint.config(:url)[:host]</code>. It may be set to <code class=\"inline\">false</code> (not recommended) or to a list of explicitly allowed origins</p> </li> <li>\n<code class=\"inline\">:code_reloader</code> - optionally override the default <code class=\"inline\">:code_reloader</code> value from the socket’s endpoint </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#default_config/0\">default_config()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"phoenix.socket.transport#c:default_config/0\"><code class=\"inline\">Phoenix.Socket.Transport.default_config/0</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"default_config/0\">  <span class=\"signature\">default_config()</span>  </h3>  <p>Callback implementation for <a href=\"phoenix.socket.transport#c:default_config/0\"><code class=\"inline\">Phoenix.Socket.Transport.default_config/0</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Transports.LongPoll.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Transports.LongPoll.html</a>\n  </p>\n</div>\n","phoenix/phoenix.transports.websocket":"<h1>  Phoenix.Transports.WebSocket  </h1>  <p>Socket transport for websocket clients.</p> <h2>Configuration</h2> <p>The websocket is configurable in your socket:</p> <pre data-language=\"elixir\"><code class=\"elixir\">transport :websocket, Phoenix.Transports.WebSocket,\n  timeout: :infinity,\n  serializer: Phoenix.Transports.WebSocketSerializer,\n  transport_log: false</code></pre> <ul> <li>\n<p><code class=\"inline\">:timeout</code> - the timeout for keeping websocket connections open after it last received data, defaults to 60_000ms</p> </li> <li>\n<p><code class=\"inline\">:transport_log</code> - if the transport layer itself should log and, if so, the level</p> </li> <li>\n<p><code class=\"inline\">:serializer</code> - the serializer for websocket messages</p> </li> <li>\n<p><code class=\"inline\">:check_origin</code> - if we should check the origin of requests when the origin header is present. It defaults to true and, in such cases, it will check against the host value in <code class=\"inline\">YourApp.Endpoint.config(:url)[:host]</code>. It may be set to <code class=\"inline\">false</code> (not recommended) or to a list of explicitly allowed origins</p> </li> <li>\n<code class=\"inline\">:code_reloader</code> - optionally override the default <code class=\"inline\">:code_reloader</code> value from the socket’s endpoint </li> </ul> <h2>Serializer</h2> <p>By default, JSON encoding is used to broker messages to and from clients. A custom serializer may be given as module which implements the <code class=\"inline\">encode!/1</code> and <code class=\"inline\">decode!/2</code> functions defined by the <a href=\"phoenix.transports.serializer\"><code class=\"inline\">Phoenix.Transports.Serializer</code></a> behaviour.</p> <p>The <code class=\"inline\">encode!/1</code> function must return a tuple in the format <code class=\"inline\">{:socket_push, :text | :binary, String.t | binary}</code>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#default_config/0\">default_config()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"phoenix.socket.transport#c:default_config/0\"><code class=\"inline\">Phoenix.Socket.Transport.default_config/0</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"default_config/0\">  <span class=\"signature\">default_config()</span>  </h3>  <p>Callback implementation for <a href=\"phoenix.socket.transport#c:default_config/0\"><code class=\"inline\">Phoenix.Socket.Transport.default_config/0</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Transports.WebSocket.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Transports.WebSocket.html</a>\n  </p>\n</div>\n","phoenix/phoenix.actionclauseerror":"<h1>  Phoenix.ActionClauseError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.ActionClauseError.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.ActionClauseError.html</a>\n  </p>\n</div>\n","phoenix/phoenix.missingparamerror":"<h1>  Phoenix.MissingParamError <small>exception</small>  </h1>  <p>Raised when a key is expected to be present in the request parameters, but is not.</p> <p>This exception is raised by <a href=\"phoenix.controller#scrub_params/2\"><code class=\"inline\">Phoenix.Controller.scrub_params/2</code></a> which:</p> <ul> <li>Checks to see if the required_key is present (can be empty) </li> <li>Changes all empty parameters to nils (“” -&gt; nil). </li> </ul> <p>If you are seeing this error, you should handle the error and surface it to the end user. It means that there is a parameter missing from the request.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.MissingParamError.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.MissingParamError.html</a>\n  </p>\n</div>\n","phoenix/phoenix.template.undefinederror":"<h1>  Phoenix.Template.UndefinedError <small>exception</small>  </h1>  <p>Exception raised when a template cannot be found.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Template.UndefinedError.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Template.UndefinedError.html</a>\n  </p>\n</div>\n","phoenix/phoenix.token":"<h1>  Phoenix.Token  </h1>  <p>Tokens provide a way to generate and verify bearer tokens for use in Channels or API authentication.</p> <p>The data can be read by clients, but the message is signed to prevent tampering.</p> <h2>Example</h2> <p>When generating a unique token for usage in an API or Channel it is advised to use a unique identifier for the user typically the id from a database. For example:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; user_id = 1\niex&gt; token = Phoenix.Token.sign(MyApp.Endpoint, \"user\", user_id)\niex&gt; Phoenix.Token.verify(MyApp.Endpoint, \"user\", token)\n{:ok, 1}</code></pre> <p>In that example we have a user’s id, we generate a token and verify it using the secret key base configured in the given <code class=\"inline\">endpoint</code>.</p> <p>The first argument to both <a href=\"#sign/4\"><code class=\"inline\">sign/4</code></a> and <a href=\"#verify/4\"><code class=\"inline\">verify/4</code></a> can be one of:</p> <ul> <li>the module name of a Phoenix endpoint (shown above) - where the secret key base is extracted from the endpoint </li> <li>\n<code class=\"inline\">Plug.Conn</code> - where the secret key base is extracted from the endpoint stored in the connection </li> <li>\n<a href=\"phoenix.socket\"><code class=\"inline\">Phoenix.Socket</code></a> - where the secret key base is extracted from the endpoint stored in the socket </li> <li>a string, representing the secret key base itself. We recommend a key base with at least 20 characters to provide enough entropy </li> </ul> <h2>Usage</h2> <p>Once a token is signed, we can send it to the client in multiple ways.</p> <p>One is via the meta tag:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= tag :meta, name: \"channel_token\",\n               content: Phoenix.Token.sign(@conn, \"user\", @current_user.id) %&gt;</code></pre> <p>Or an endpoint that returns it:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def create(conn, params) do\n  user = User.create(params)\n  render conn, \"user.json\",\n         %{token: Phoenix.Token.sign(conn, \"user\", user.id), user: user}\nend</code></pre> <p>Once the token is sent, the client may now send it back to the server as an authentication mechanism. For example, we can use it to authenticate a user on a Phoenix channel:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.UserSocket do\n  use Phoenix.Socket\n\n  def connect(%{\"token\" =&gt; token}, socket) do\n    # Max age of 2 weeks (1209600 seconds)\n    case Phoenix.Token.verify(socket, \"user\", token, max_age: 1209600) do\n      {:ok, user_id} -&gt;\n        socket = assign(socket, :user, Repo.get!(User, user_id))\n        {:ok, socket}\n      {:error, _} -&gt;\n        :error\n    end\n  end\nend</code></pre> <p>In this example, the phoenix.js client will send the token in the <code class=\"inline\">connect</code> command which is then validated by the server.</p> <p><a href=\"phoenix.token#content\"><code class=\"inline\">Phoenix.Token</code></a> can also be used for validating APIs, handling password resets, e-mail confirmation and more.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#sign/4\">sign(context, salt, data, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Encodes data and signs it resulting in a token you can send down to clients</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#verify/4\">verify(context, salt, token, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes the original data from the token and verifies its integrity</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"sign/4\">  <span class=\"signature\">sign(context, salt, data, opts \\\\ [])</span>  </h3>  <p>Encodes data and signs it resulting in a token you can send down to clients.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:key_iterations</code> - option passed to <code class=\"inline\">Plug.Crypto.KeyGenerator</code> when generating the encryption and signing keys. Defaults to 1000; </li> <li>\n<code class=\"inline\">:key_length</code> - option passed to <code class=\"inline\">Plug.Crypto.KeyGenerator</code> when generating the encryption and signing keys. Defaults to 32; </li> <li>\n<code class=\"inline\">:key_digest</code> - option passed to <code class=\"inline\">Plug.Crypto.KeyGenerator</code> when generating the encryption and signing keys. Defaults to `:sha256’; </li> </ul>    <h3 class=\"detail-header function\" id=\"verify/4\">  <span class=\"signature\">verify(context, salt, token, opts \\\\ [])</span>  </h3>  <p>Decodes the original data from the token and verifies its integrity.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:max_age</code> - verifies the token only if it has been generated “max age” ago in seconds. A reasonable value is 2 weeks (<code class=\"inline\">1209600</code> seconds); </li> <li>\n<code class=\"inline\">:key_iterations</code> - option passed to <code class=\"inline\">Plug.Crypto.KeyGenerator</code> when generating the encryption and signing keys. Defaults to 1000; </li> <li>\n<code class=\"inline\">:key_length</code> - option passed to <code class=\"inline\">Plug.Crypto.KeyGenerator</code> when generating the encryption and signing keys. Defaults to 32; </li> <li>\n<code class=\"inline\">:key_digest</code> - option passed to <code class=\"inline\">Plug.Crypto.KeyGenerator</code> when generating the encryption and signing keys. Defaults to `:sha256’; </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Token.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Token.html</a>\n  </p>\n</div>\n","phoenix/phoenix.transports.serializer":"<h1>  Phoenix.Transports.Serializer <small>behaviour</small>  </h1>  <p>Defines a behaviour for <a href=\"phoenix.socket.message\"><code class=\"inline\">Phoenix.Socket.Message</code></a> serialization.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:decode!/2\">decode!(iodata, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes iodata into <a href=\"phoenix.socket.message\"><code class=\"inline\">Phoenix.Socket.Message</code></a> struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:encode!/1\">encode!(arg0)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Encodes <a href=\"phoenix.socket.message\"><code class=\"inline\">Phoenix.Socket.Message</code></a> struct to transport respresentation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:fastlane!/1\">fastlane!(arg0)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Translates a <a href=\"phoenix.socket.broadcast\"><code class=\"inline\">Phoenix.Socket.Broadcast</code></a> struct to fastlane format</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:decode!/2\">  <span class=\"signature\">decode!(iodata, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">decode!(iodata, options :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"phoenix.socket.message#t:t/0\">Phoenix.Socket.Message.t</a></code></pre>    <p>Decodes iodata into <a href=\"phoenix.socket.message\"><code class=\"inline\">Phoenix.Socket.Message</code></a> struct</p>    <h3 class=\"detail-header callback\" id=\"c:encode!/1\">  <span class=\"signature\">encode!(arg0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">encode!(<a href=\"phoenix.socket.message#t:t/0\">Phoenix.Socket.Message.t</a> | <a href=\"phoenix.socket.reply#t:t/0\">Phoenix.Socket.Reply.t</a>) :: term</code></pre>    <p>Encodes <a href=\"phoenix.socket.message\"><code class=\"inline\">Phoenix.Socket.Message</code></a> struct to transport respresentation</p>    <h3 class=\"detail-header callback\" id=\"c:fastlane!/1\">  <span class=\"signature\">fastlane!(arg0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fastlane!(<a href=\"phoenix.socket.broadcast#t:t/0\">Phoenix.Socket.Broadcast.t</a>) :: term</code></pre>    <p>Translates a <a href=\"phoenix.socket.broadcast\"><code class=\"inline\">Phoenix.Socket.Broadcast</code></a> struct to fastlane format</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Transports.Serializer.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Transports.Serializer.html</a>\n  </p>\n</div>\n","ecto/ecto":"<h1>  Ecto  </h1>  <p>Ecto is split into 4 main components:</p> <ul> <li>\n<p><a href=\"ecto.repo\"><code class=\"inline\">Ecto.Repo</code></a> - repositories are wrappers around the data store. Via the repository, we can create, update, destroy and query existing entries. A repository needs an adapter and credentials to communicate to the database</p> </li> <li>\n<p><a href=\"ecto.schema\"><code class=\"inline\">Ecto.Schema</code></a> - schemas are used to map any data source into an Elixir struct. We will often use them to map tables into Elixir data but that’s one of their use cases and not a requirement for using Ecto</p> </li> <li>\n<p><a href=\"ecto.changeset\"><code class=\"inline\">Ecto.Changeset</code></a> - changesets provide a way for developers to filter and cast external parameters, as well as a mechanism to track and validate changes before they are applied to your data</p> </li> <li>\n<a href=\"ecto.query\"><code class=\"inline\">Ecto.Query</code></a> - written in Elixir syntax, queries are used to retrieve information from a given repository. Queries in Ecto are secure, avoiding common problems like SQL Injection, while still being composable, allowing developers to build queries piece by piece instead of all at once </li> </ul> <p>In the following sections, we will provide an overview of those components and how they interact with each other. Feel free to access their respective module documentation for more specific examples, options and configuration.</p> <p>If you want to quickly check a sample application using Ecto, please check the <a href=\"http://hexdocs.pm/ecto/getting-started.html\">getting started guide</a> and the accompanying sample application.</p> <h2 id=\"module-repositories\" class=\"section-heading\">  Repositories </h2> <p><a href=\"ecto.repo\"><code class=\"inline\">Ecto.Repo</code></a> is a wrapper around the database. We can define a repository as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Repo do\n  use Ecto.Repo, otp_app: :my_app\nend</code></pre> <p>Where the configuration for the Repo must be in your application environment, usually defined in your <code class=\"inline\">config/config.exs</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :my_app, Repo,\n  adapter: Ecto.Adapters.Postgres,\n  database: \"ecto_simple\",\n  username: \"postgres\",\n  password: \"postgres\",\n  hostname: \"localhost\",\n  # OR use a URL to connect instead\n  url: \"postgres://postgres:postgres@localhost/ecto_simple\"</code></pre> <p>Each repository in Ecto defines a <code class=\"inline\">start_link/0</code> function that needs to be invoked before using the repository. In general, this function is not called directly, but used as part of your application supervision tree.</p> <p>If your application was generated with a supervisor (by passing <code class=\"inline\">--sup</code> to <code class=\"inline\">mix new</code>) you will have a <code class=\"inline\">lib/my_app.ex</code> file containing the application start callback that defines and starts your supervisor. You just need to edit the <code class=\"inline\">start/2</code> function to start the repo as a supervisor on your application’s supervisor:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def start(_type, _args) do\n  import Supervisor.Spec\n\n  children = [\n    supervisor(Repo, [])\n  ]\n\n  opts = [strategy: :one_for_one, name: MyApp.Supervisor]\n  Supervisor.start_link(children, opts)\nend</code></pre> <h2 id=\"module-schema\" class=\"section-heading\">  Schema </h2> <p>Schemas allows developers to define the shape of their data. Let’s see an example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Weather do\n  use Ecto.Schema\n\n  # weather is the DB table\n  schema \"weather\" do\n    field :city,    :string\n    field :temp_lo, :integer\n    field :temp_hi, :integer\n    field :prcp,    :float, default: 0.0\n  end\nend</code></pre> <p>By defining a schema, Ecto automatically defines a struct with the schema fields:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; weather = %Weather{temp_lo: 30}\niex&gt; weather.temp_lo\n30</code></pre> <p>The schema also allows us to interact with a repository:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; weather = %Weather{temp_lo: 0, temp_hi: 23}\niex&gt; Repo.insert!(weather)\n%Weather{...}</code></pre> <p>After persisting <code class=\"inline\">weather</code> to the database, it will return a new copy of <code class=\"inline\">%Weather{}</code> with the primary key (the <code class=\"inline\">id</code>) set. We can use this value to read a struct back from the repository:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Get the struct back\niex&gt; weather = Repo.get Weather, 1\n%Weather{id: 1, ...}\n\n# Delete it\niex&gt; Repo.delete!(weather)\n%Weather{...}</code></pre> <blockquote>\n<p>NOTE: by using <a href=\"ecto.schema\"><code class=\"inline\">Ecto.Schema</code></a>, an <code class=\"inline\">:id</code> field with type <code class=\"inline\">:id</code> (:id means :integer) is generated by default, which is the primary key of the Schema. If you want to use a different primary key, you can declare custom <code class=\"inline\">@primary_key</code> before the <code class=\"inline\">schema/2</code> call. Consult the <a href=\"ecto.schema\"><code class=\"inline\">Ecto.Schema</code></a> documentation for more information.</p> </blockquote> <p>Notice how the storage (repository) and the data are decoupled. This provides two main benefits:</p> <ul> <li>\n<p>By having structs as data, we guarantee they are light-weight, serializable structures. In many languages, the data is often represented by large, complex objects, with entwined state transactions, which makes serialization, maintenance and understanding hard;</p> </li> <li>You do not need to define schemas in order to interact with repositories, operations like <code class=\"inline\">all</code>, <code class=\"inline\">insert_all</code> and so on allow developers to directly access and modify the data, keeping the database at your fingertips when necessary; </li> </ul> <h2 id=\"module-changesets\" class=\"section-heading\">  Changesets </h2> <p>Although in the example above we have directly inserted and deleted the struct in the repository, operations on top of schemas are done through changesets so Ecto can efficiently track changes.</p> <p>Changesets allow developers to filter, cast, and validate changes before we apply them to the data. Imagine the given schema:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  use Ecto.Schema\n\n  import Ecto.Changeset\n\n  schema \"users\" do\n    field :name\n    field :email\n    field :age, :integer\n  end\n\n  def changeset(user, params \\\\ %{}) do\n    user\n    |&gt; cast(params, [:name, :email, :age])\n    |&gt; validate_required([:name, :email])\n    |&gt; validate_format(:email, ~r/@/)\n    |&gt; validate_inclusion(:age, 18..100)\n  end\nend</code></pre> <p>The <code class=\"inline\">changeset/2</code> function first invokes <a href=\"ecto.changeset#cast/3\"><code class=\"inline\">Ecto.Changeset.cast/3</code></a> with the struct, the parameters and a list of required and optional fields; this returns a changeset. The parameter is a map with binary keys and a value that will be cast based on the type defined on the schema.</p> <p>Any parameter that was not explicitly listed in the required or optional fields list will be ignored. Furthermore, if a field is given as required but it is not in the parameter map nor in the struct, it will be marked with an error and the changeset is deemed invalid.</p> <p>After casting, the changeset is given to many <code class=\"inline\">Ecto.Changeset.validate_*/2</code> functions that validate only the <strong>changed fields</strong>. In other words: if a field was not given as a parameter, it won’t be validated at all. For example, if the params map contain only the “name” and “email” keys, the “age” validation won’t run.</p> <p>Once a changeset is built, it can be given to functions like <code class=\"inline\">insert</code> and <code class=\"inline\">update</code> in the repository that will return an <code class=\"inline\">:ok</code> or <code class=\"inline\">:error</code> tuple:</p> <pre data-language=\"elixir\"><code class=\"elixir\">case Repo.update(changeset) do\n  {:ok, user} -&gt;\n    # user updated\n  {:error, changeset} -&gt;\n    # an error occurred\nend</code></pre> <p>The benefit of having explicit changesets is that we can easily provide different changesets for different use cases. For example, one could easily provide specific changesets for registering and updating users:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def registration_changeset(user, params) do\n  # Changeset on create\nend\n\ndef update_changeset(user, params) do\n  # Changeset on update\nend</code></pre> <p>Changesets are also capable of transforming database constraints, like unique indexes and foreign key checks, into errors. Allowing developers to keep their database consistent while still providing proper feedback to end users. Check <a href=\"ecto.changeset#unique_constraint/3\"><code class=\"inline\">Ecto.Changeset.unique_constraint/3</code></a> for some examples as well as the other <code class=\"inline\">_constraint</code> functions.</p> <h2 id=\"module-query\" class=\"section-heading\">  Query </h2> <p>Last but not least, Ecto allows you to write queries in Elixir and send them to the repository, which translates them to the underlying database. Let’s see an example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import Ecto.Query, only: [from: 2]\n\nquery = from u in User,\n          where: u.age &gt; 18 or is_nil(u.email),\n          select: u\n\n# Returns %User{} structs matching the query\nRepo.all(query)</code></pre> <p>In the example above we relied on our schema but queries can also be made directly against a table by giving the table name as a string. In such cases, the data to be fetched must be explicitly outlined:</p> <pre data-language=\"elixir\"><code class=\"elixir\">query = from u in \"users\",\n          where: u.age &gt; 18 or is_nil(u.email),\n          select: %{name: u.name, age: u.age}\n\n# Returns maps as defined in select\nRepo.all(query)</code></pre> <p>Queries are defined and extended with the <code class=\"inline\">from</code> macro. The supported keywords are:</p> <ul> <li>\n<code class=\"inline\">:distinct</code> </li> <li>\n<code class=\"inline\">:where</code> </li> <li>\n<code class=\"inline\">:order_by</code> </li> <li>\n<code class=\"inline\">:offset</code> </li> <li>\n<code class=\"inline\">:limit</code> </li> <li>\n<code class=\"inline\">:lock</code> </li> <li>\n<code class=\"inline\">:group_by</code> </li> <li>\n<code class=\"inline\">:having</code> </li> <li>\n<code class=\"inline\">:join</code> </li> <li>\n<code class=\"inline\">:select</code> </li> <li>\n<code class=\"inline\">:preload</code> </li> </ul> <p>Examples and detailed documentation for each of those are available in the <a href=\"ecto.query\"><code class=\"inline\">Ecto.Query</code></a> module. Functions supported in queries are listed in <a href=\"ecto.query.api\"><code class=\"inline\">Ecto.Query.API</code></a>.</p> <p>When writing a query, you are inside Ecto’s query syntax. In order to access params values or invoke Elixir functions, you need to use the <code class=\"inline\">^</code> operator, which is overloaded by Ecto:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def min_age(min) do\n  from u in User, where: u.age &gt; ^min\nend</code></pre> <p>Besides <code class=\"inline\">Repo.all/1</code> which returns all entries, repositories also provide <code class=\"inline\">Repo.one/1</code> which returns one entry or nil, <code class=\"inline\">Repo.one!/1</code> which returns one entry or raises, <code class=\"inline\">Repo.get/2</code> which fetches entries for a particular ID and more.</p> <p>Finally, if you need a escape hatch, Ecto provides fragments (see <a href=\"ecto.query.api#fragment/1)\"><code class=\"inline\">Ecto.Query.API.fragment/1</code></a> to inject SQL (and non-SQL) fragments into queries. Also, most adapters provide direct APIs for queries, like <a href=\"ecto.adapters.sql#query/4\"><code class=\"inline\">Ecto.Adapters.SQL.query/4</code></a>, allowing developers to completely bypass Ecto queries.</p> <h2 id=\"module-other-topics\" class=\"section-heading\">  Other topics </h2> <h3>Associations</h3> <p>Ecto supports defining associations on schemas:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Post do\n  use Ecto.Schema\n\n  schema \"posts\" do\n    has_many :comments, Comment\n  end\nend\n\ndefmodule Comment do\n  use Ecto.Schema\n\n  schema \"comments\" do\n    field :title, :string\n    belongs_to :post, Post\n  end\nend</code></pre> <p>When an association is defined, Ecto also defines a field in the schema with the association name. By default, associations are not loaded into this field:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; post = Repo.get(Post, 42)\niex&gt; post.comments\n#Ecto.Association.NotLoaded&lt;...&gt;</code></pre> <p>However, developers can use the preload functionality in queries to automatically pre-populate the field:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Repo.all from p in Post, preload: [:comments]</code></pre> <p>Preloading can also be done with a pre-defined join value:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Repo.all from p in Post,\n          join: c in assoc(p, :comments),\n          where: c.votes &gt; p.votes,\n          preload: [comments: c]</code></pre> <p>Finally, for the simple cases, preloading can also be done after a collection was fetched:</p> <pre data-language=\"elixir\"><code class=\"elixir\">posts = Repo.all(Post) |&gt; Repo.preload(:comments)</code></pre> <p>The <a href=\"ecto#content\"><code class=\"inline\">Ecto</code></a> module also provides conveniences for working with associations. For example, <a href=\"ecto#assoc/2\"><code class=\"inline\">Ecto.assoc/2</code></a> returns a query with all associated data to a given struct:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import Ecto\n\n# Get all comments for the given post\nRepo.all assoc(post, :comments)\n\n# Or build a query on top of the associated comments\nquery = from c in assoc(post, :comments), where: not is_nil(c.title)\nRepo.all(query)</code></pre> <p>Another function in <a href=\"ecto#content\"><code class=\"inline\">Ecto</code></a> is <a href=\"#build_assoc/3\"><code class=\"inline\">build_assoc/3</code></a>, which allows someone to build an associated struct with the proper fields:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Repo.transaction fn -&gt;\n  post = Repo.insert!(%Post{title: \"Hello\", body: \"world\"})\n\n  # Build a comment from post\n  comment = Ecto.build_assoc(post, :comments, body: \"Excellent!\")\n\n  Repo.insert!(comment)\nend</code></pre> <p>In the example above, <a href=\"ecto#build_assoc/3\"><code class=\"inline\">Ecto.build_assoc/3</code></a> is equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%Comment{post_id: post.id, body: \"Excellent!\"}</code></pre> <p>You can find more information about defining associations and each respective association module in <a href=\"ecto.schema\"><code class=\"inline\">Ecto.Schema</code></a> docs.</p> <blockquote>\n<p>NOTE: Ecto does not lazy load associations. While lazily loading associations may sound convenient at first, in the long run it becomes a source of confusion and performance issues.</p> </blockquote> <h3>Embeds</h3> <p>Ecto also supports embeds. While associations keep parent and child entries in different tables, embeds stores the child along side the parent.</p> <p>Databases like Mongo have native support for embeds. Databases like PostgreSQL uses a mixture of JSONB (<code class=\"inline\">embeds_one/3</code>) and ARRAY columns to provide this functionality.</p> <p>Check <a href=\"ecto.schema#embeds_one/3\"><code class=\"inline\">Ecto.Schema.embeds_one/3</code></a> and <a href=\"ecto.schema#embeds_many/3\"><code class=\"inline\">Ecto.Schema.embeds_many/3</code></a> for more information.</p> <h3>Mix tasks and generators</h3> <p>Ecto provides many tasks to help your workflow as well as code generators. You can find all available tasks by typing <code class=\"inline\">mix help</code> inside a project with Ecto listed as a dependency.</p> <p>Ecto generators will automatically open the generated files if you have <code class=\"inline\">ECTO_EDITOR</code> set in your environment variable.</p> <h4>Migrations</h4> <p>Ecto supports database migrations. You can generate a migration with:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$ mix ecto.gen.migration create_posts</code></pre> <p>This will create a new file inside <code class=\"inline\">priv/repo/migrations</code> with the <code class=\"inline\">change</code> function. Check <a href=\"ecto.migration\"><code class=\"inline\">Ecto.Migration</code></a> for more information.</p> <h4>Repo resolution</h4> <p>Ecto requires developers to specify the key <code class=\"inline\">:ecto_repos</code> in their application configuration before using tasks like <code class=\"inline\">ecto.create</code> and <code class=\"inline\">ecto.migrate</code>. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :my_app, :ecto_repos, [MyApp.Repo]\n\nconfig :my_app, MyApp.Repo,\n  adapter: Ecto.Adapters.Postgres,\n  database: \"ecto_simple\",\n  username: \"postgres\",\n  password: \"postgres\",\n  hostname: \"localhost\"</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#assoc/2\">assoc(struct_or_structs, assoc)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Builds a query for the association in the given struct or structs</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#assoc_loaded?/1\">assoc_loaded?(association)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if an association is loaded</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#build_assoc/3\">build_assoc(struct, assoc, attributes \\\\ %{})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Builds a struct from the given <code class=\"inline\">assoc</code> in <code class=\"inline\">struct</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_meta/2\">get_meta(struct, atom)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the metadata from the given struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#primary_key/1\">primary_key(struct)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the schema primary keys as a keyword list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#primary_key!/1\">primary_key!(struct)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the schema primary keys as a keyword list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_meta/2\">put_meta(struct, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a new struct with updated metadata</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"assoc/2\">  <span class=\"signature\">assoc(struct_or_structs, assoc)</span>  </h3>  <p>Builds a query for the association in the given struct or structs.</p> <h4>Examples</h4> <p>In the example below, we get all comments associated to the given post:</p> <pre data-language=\"elixir\"><code class=\"elixir\">post = Repo.get Post, 1\nRepo.all assoc(post, :comments)</code></pre> <p><a href=\"#assoc/2\"><code class=\"inline\">assoc/2</code></a> can also receive a list of posts, as long as the posts are not empty:</p> <pre data-language=\"elixir\"><code class=\"elixir\">posts = Repo.all from p in Post, where: is_nil(p.published_at)\nRepo.all assoc(posts, :comments)</code></pre>    <h3 class=\"detail-header function\" id=\"assoc_loaded?/1\">  <span class=\"signature\">assoc_loaded?(association)</span>  </h3>  <p>Checks if an association is loaded.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; post = Repo.get(Post, 1)\niex&gt; Ecto.assoc_loaded?(post.comments)\nfalse\niex&gt; post = post |&gt; Repo.preload(:comments)\niex&gt; Ecto.assoc_loaded?(post.comments)\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"build_assoc/3\">  <span class=\"signature\">build_assoc(struct, assoc, attributes \\\\ %{})</span>  </h3>  <p>Builds a struct from the given <code class=\"inline\">assoc</code> in <code class=\"inline\">struct</code>.</p> <h4>Examples</h4> <p>If the relationship is a <code class=\"inline\">has_one</code> or <code class=\"inline\">has_many</code> and the key is set in the given struct, the key will automatically be set in the built association:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; post = Repo.get(Post, 13)\n%Post{id: 13}\niex&gt; build_assoc(post, :comments)\n%Comment{id: nil, post_id: 13}</code></pre> <p>Note though it doesn’t happen with <code class=\"inline\">belongs_to</code> cases, as the key is often the primary key and such is usually generated dynamically:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; comment = Repo.get(Comment, 13)\n%Comment{id: 13, post_id: 25}\niex&gt; build_assoc(comment, :post)\n%Post{id: nil}</code></pre> <p>You can also pass the attributes, which can be a map or a keyword list, to set the struct’s fields except the association key.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; build_assoc(post, :comments, text: \"cool\")\n%Comment{id: nil, post_id: 13, text: \"cool\"}\n\niex&gt; build_assoc(post, :comments, %{text: \"cool\"})\n%Comment{id: nil, post_id: 13, text: \"cool\"}\n\niex&gt; build_assoc(post, :comments, post_id: 1)\n%Comment{id: nil, post_id: 13}</code></pre>    <h3 class=\"detail-header function\" id=\"get_meta/2\">  <span class=\"signature\">get_meta(struct, atom)</span>  </h3>  <p>Gets the metadata from the given struct.</p>    <h3 class=\"detail-header function\" id=\"primary_key/1\">  <span class=\"signature\">primary_key(struct)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">primary_key(<a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a></code></pre>    <p>Returns the schema primary keys as a keyword list.</p>    <h3 class=\"detail-header function\" id=\"primary_key!/1\">  <span class=\"signature\">primary_key!(struct)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">primary_key!(<a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a> | no_return</code></pre>    <p>Returns the schema primary keys as a keyword list.</p> <p>Raises <a href=\"ecto.noprimarykeyfielderror\"><code class=\"inline\">Ecto.NoPrimaryKeyFieldError</code></a> if the schema has no primary key field.</p>    <h3 class=\"detail-header function\" id=\"put_meta/2\">  <span class=\"signature\">put_meta(struct, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_meta(<a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>, source: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, prefix: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, context: term, state: :built | :loaded | :deleted) :: <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a></code></pre>    <p>Returns a new struct with updated metadata.</p> <p>It is possible to set:</p> <ul> <li>\n<code class=\"inline\">:source</code> - changes the struct query source </li> <li>\n<code class=\"inline\">:prefix</code> - changes the struct query prefix </li> <li>\n<code class=\"inline\">:context</code> - changes the struct meta context </li> <li>\n<code class=\"inline\">:state</code> - changes the struct state </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.html</a>\n  </p>\n</div>\n","phoenix/phoenix.router.norouteerror":"<h1>  Phoenix.Router.NoRouteError <small>exception</small>  </h1>  <p>Exception raised when no route is found.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Router.NoRouteError.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Router.NoRouteError.html</a>\n  </p>\n</div>\n","phoenix/phoenix.socket.invalidmessageerror":"<h1>  Phoenix.Socket.InvalidMessageError <small>exception</small>  </h1>  <p>Raised when the socket message is invalid.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Socket.InvalidMessageError.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Socket.InvalidMessageError.html</a>\n  </p>\n</div>\n","phoenix/phoenix.param":"<h1>  Phoenix.Param <small>protocol</small>  </h1>  <p>A protocol that converts data structures into URL parameters.</p> <p>This protocol is used by URL helpers and other parts of the Phoenix stack. For example, when you write:</p> <pre data-language=\"elixir\"><code class=\"elixir\">user_path(conn, :edit, @user)</code></pre> <p>Phoenix knows how to extract the <code class=\"inline\">:id</code> from <code class=\"inline\">@user</code> thanks to this protocol.</p> <p>By default, Phoenix implements this protocol for integers, binaries, atoms, maps and structs. For maps and structs, a key <code class=\"inline\">:id</code> is looked up.</p> <p>Nil values cannot be converted to param.</p> <h2>Custom parameters</h2> <p>In order to customize the parameter for any model or struct, one can simply implement this protocol.</p> <p>However, for convenience, this protocol can also be derivable. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  @derive Phoenix.Param\n  defstruct [:id, :username]\nend</code></pre> <p>By default, the derived implementation will also use the <code class=\"inline\">:id</code> key. In case the user does not contain an <code class=\"inline\">:id</code> key, the key can be specified with an option:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  @derive {Phoenix.Param, key: :username}\n  defstruct [:username]\nend</code></pre> <p>will automatically use <code class=\"inline\">:username</code> in URLs.</p> <p>When using Ecto, you must call <code class=\"inline\">@derive</code> before your <code class=\"inline\">schema</code> call:</p> <pre data-language=\"elixir\"><code class=\"elixir\">@derive {Phoenix.Param, key: :username}\nschema \"users\" do</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#to_param/1\">to_param(term)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: term</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"to_param/1\">  <span class=\"signature\">to_param(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_param(term) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Param.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Param.html</a>\n  </p>\n</div>\n","ecto/ecto.adapter":"<h1>  Ecto.Adapter <small>behaviour</small>  </h1>  <p>This module specifies the adapter API that an adapter is required to implement.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:autogenerate_id/0\">autogenerate_id()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:cached/0\">cached()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:constraints/0\">constraints()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:fields/0\">fields()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:filters/0\">filters()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:prepared/0\">prepared()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:process/0\">process()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:query_meta/0\">query_meta()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Ecto.Query metadata fields (stored in cache)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:returning/0\">returning()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:schema_meta/0\">schema_meta()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Ecto.Schema metadata fields</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:source/0\">source()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:__before_compile__/1\">__before_compile__(env)</a> </dt> <dd class=\"summary-synopsis\">\n<p>The callback invoked in case the adapter needs to inject code</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:autogenerate/1\">autogenerate(field_type)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Called to autogenerate a value for id/embed_id/binary_id</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:child_spec/2\">child_spec(repo, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the childspec that starts the adapter process</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:delete/4\">delete(repo, schema_meta, filters, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes a single struct with the given filters</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:dumpers/2\">dumpers(primitive_type, ecto_type)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the dumpers for a given type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:ensure_all_started/2\">ensure_all_started(repo, type)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Ensure all applications necessary to run the adapter are started</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:execute/6\">execute(repo, query_meta, query, params, arg4, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Executes a previously prepared query</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:insert/5\">insert(repo, schema_meta, fields, returning, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts a single new struct in the data store</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:insert_all/6\">insert_all(repo, schema_meta, header, list, returning, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts multiple entries into the data store</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:loaders/2\">loaders(primitive_type, ecto_type)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the loaders for a given type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:prepare/2\">prepare(atom, query)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Commands invoked to prepare a query for <code class=\"inline\">all</code>, <code class=\"inline\">update_all</code> and <code class=\"inline\">delete_all</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:update/6\">update(repo, schema_meta, fields, filters, returning, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates a single struct with the given filters</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:autogenerate_id/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:autogenerate_id/0\">autogenerate_id</a> ::\n  {field :: atom, type :: :id | :binary_id, value :: term} |\n  nil</code></pre> </div> <div id=\"t:cached/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:cached/0\">cached</a> :: term</code></pre> </div> <div id=\"t:constraints/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:constraints/0\">constraints</a> :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a></code></pre> </div> <div id=\"t:fields/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:fields/0\">fields</a> :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a></code></pre> </div> <div id=\"t:filters/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:filters/0\">filters</a> :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a></code></pre> </div> <div id=\"t:prepared/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:prepared/0\">prepared</a> :: term</code></pre> </div> <div id=\"t:process/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:process/0\">process</a> :: (field :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Macro.html#t:t/0\">Macro.t</a>, value :: term, context :: term -&gt; term)</code></pre> </div> <div id=\"t:query_meta/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:query_meta/0\">query_meta</a> :: %{prefix: binary | nil, sources: tuple, assocs: term, preloads: term, select: term, fields: [term]}</code></pre> <p>Ecto.Query metadata fields (stored in cache)</p>  </div> <div id=\"t:returning/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:returning/0\">returning</a> :: [atom]</code></pre> </div> <div id=\"t:schema_meta/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:schema_meta/0\">schema_meta</a> :: %{source: <a href=\"#t:source/0\">source</a>, schema: atom, context: term, autogenerate_id: {atom, :id | :binary_id}}</code></pre> <p>Ecto.Schema metadata fields</p>  </div> <div id=\"t:source/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:source/0\">source</a> :: {prefix :: binary | nil, table :: binary}</code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: module</code></pre> </div>    <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:__before_compile__/1\">  <span class=\"signature\">__before_compile__(env)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">__before_compile__({line :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Macro.Env.html#t:line/0\">Macro.Env.line</a>, env :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Macro.Env.html#t:t/0\">Macro.Env.t</a>}, env :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Macro.Env.html#t:t/0\">Macro.Env.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Macro.html#t:t/0\">Macro.t</a></code></pre>    <p>The callback invoked in case the adapter needs to inject code.</p>    <h3 class=\"detail-header callback\" id=\"c:autogenerate/1\">  <span class=\"signature\">autogenerate(field_type)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">autogenerate(field_type :: :id | :binary_id | :embed_id) ::\n  term |\n  nil |\n  no_return</code></pre>    <p>Called to autogenerate a value for id/embed_id/binary_id.</p> <p>Returns the autogenerated value, or nil if it must be autogenerated inside the storage or raise if not supported.</p>    <h3 class=\"detail-header callback\" id=\"c:child_spec/2\">  <span class=\"signature\">child_spec(repo, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">child_spec(repo, options) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Supervisor.Spec.html#t:spec/0\">Supervisor.Spec.spec</a></code></pre>    <p>Returns the childspec that starts the adapter process.</p>    <h3 class=\"detail-header callback\" id=\"c:delete/4\">  <span class=\"signature\">delete(repo, schema_meta, filters, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete(repo, <a href=\"#t:schema_meta/0\">schema_meta</a>, <a href=\"#t:filters/0\">filters</a>, options) ::\n  {:ok, <a href=\"#t:fields/0\">fields</a>} |\n  {:invalid, <a href=\"#t:constraints/0\">constraints</a>} |\n  {:error, :stale} |\n  no_return</code></pre>    <p>Deletes a single struct with the given filters.</p> <p>While <code class=\"inline\">filters</code> can be any record column, it is expected that at least the primary key (or any other key that uniquely identifies an existing record) be given as a filter. Therefore, in case there is no record matching the given filters, <code class=\"inline\">{:error, :stale}</code> is returned.</p>    <h3 class=\"detail-header callback\" id=\"c:dumpers/2\">  <span class=\"signature\">dumpers(primitive_type, ecto_type)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">dumpers(primitive_type :: <a href=\"ecto.type#t:primitive/0\">Ecto.Type.primitive</a>, ecto_type :: <a href=\"ecto.type#t:t/0\">Ecto.Type.t</a>) :: [(term -&gt; {:ok, term} | :error) | <a href=\"ecto.type#t:t/0\">Ecto.Type.t</a>]</code></pre>    <p>Returns the dumpers for a given type.</p> <p>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of dumpers with the given type usually at the beginning.</p> <p>This allows developers to properly translate values coming from the Ecto into adapter ones. For example, if the database does not support booleans but instead returns 0 and 1 for them, you could add:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def dumpers(:boolean, type), do: [type, &amp;bool_encode/1]\ndef dumpers(_primitive, type), do: [type]\n\ndefp bool_encode(false), do: {:ok, 0}\ndefp bool_encode(true), do: {:ok, 1}</code></pre> <p>All adapters are required to implement a clause or :binary_id types, since they are adapter specific. If your adapter does not provide binary ids, you may simply use Ecto.UUID:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def dumpers(:binary_id, type), do: [type, Ecto.UUID]\ndef dumpers(_primitive, type), do: [type]</code></pre>    <h3 class=\"detail-header callback\" id=\"c:ensure_all_started/2\">  <span class=\"signature\">ensure_all_started(repo, type)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">ensure_all_started(repo, type :: :application.restart_type) ::\n  {:ok, [atom]} |\n  {:error, atom}</code></pre>    <p>Ensure all applications necessary to run the adapter are started.</p>    <h3 class=\"detail-header callback\" id=\"c:execute/6\">  <span class=\"signature\">execute(repo, query_meta, query, params, arg4, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">execute(repo, <a href=\"#t:query_meta/0\">query_meta</a>, query, params :: list, <a href=\"#t:process/0\">process</a> | nil, options) :: result when result: {integer, [[term]] | nil} | no_return, query: {:nocache, <a href=\"#t:prepared/0\">prepared</a>} | {:cached, <a href=\"#t:cached/0\">cached</a>} | {:cache, (<a href=\"#t:cached/0\">cached</a> -&gt; :ok), <a href=\"#t:prepared/0\">prepared</a>}</code></pre>    <p>Executes a previously prepared query.</p> <p>It must return a tuple containing the number of entries and the result set as a list of lists. The result set may also be <code class=\"inline\">nil</code> if a particular operation does not support them.</p> <p>The <code class=\"inline\">meta</code> field is a map containing some of the fields found in the <a href=\"ecto.query\"><code class=\"inline\">Ecto.Query</code></a> struct.</p> <p>It receives a process function that should be invoked for each selected field in the query result in order to convert them to the expected Ecto type. The <code class=\"inline\">process</code> function will be nil if no result set is expected from the query.</p>    <h3 class=\"detail-header callback\" id=\"c:insert/5\">  <span class=\"signature\">insert(repo, schema_meta, fields, returning, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">insert(repo, <a href=\"#t:schema_meta/0\">schema_meta</a>, <a href=\"#t:fields/0\">fields</a>, <a href=\"#t:returning/0\">returning</a>, options) ::\n  {:ok, <a href=\"#t:fields/0\">fields</a>} |\n  {:invalid, <a href=\"#t:constraints/0\">constraints</a>} |\n  no_return</code></pre>    <p>Inserts a single new struct in the data store.</p> <h4>Autogenerate</h4> <p>The primary key will be automatically included in <code class=\"inline\">returning</code> if the field has type <code class=\"inline\">:id</code> or <code class=\"inline\">:binary_id</code> and no value was set by the developer or none was autogenerated by the adapter.</p>    <h3 class=\"detail-header callback\" id=\"c:insert_all/6\">  <span class=\"signature\">insert_all(repo, schema_meta, header, list, returning, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">insert_all(repo, <a href=\"#t:schema_meta/0\">schema_meta</a>, header :: [atom], [<a href=\"#t:fields/0\">fields</a>], <a href=\"#t:returning/0\">returning</a>, options) ::\n  {integer, [[term]] | nil} |\n  no_return</code></pre>    <p>Inserts multiple entries into the data store.</p>    <h3 class=\"detail-header callback\" id=\"c:loaders/2\">  <span class=\"signature\">loaders(primitive_type, ecto_type)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">loaders(primitive_type :: <a href=\"ecto.type#t:primitive/0\">Ecto.Type.primitive</a>, ecto_type :: <a href=\"ecto.type#t:t/0\">Ecto.Type.t</a>) :: [(term -&gt; {:ok, term} | :error) | <a href=\"ecto.type#t:t/0\">Ecto.Type.t</a>]</code></pre>    <p>Returns the loaders for a given type.</p> <p>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of loaders with the given type usually at the end.</p> <p>This allows developers to properly translate values coming from the adapters into Ecto ones. For example, if the database does not support booleans but instead returns 0 and 1 for them, you could add:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def loaders(:boolean, type), do: [&amp;bool_decode/1, type]\ndef loaders(_primitive, type), do: [type]\n\ndefp bool_decode(0), do: {:ok, false}\ndefp bool_decode(1), do: {:ok, true}</code></pre> <p>All adapters are required to implement a clause for <code class=\"inline\">:binary_id</code> types, since they are adapter specific. If your adapter does not provide binary ids, you may simply use Ecto.UUID:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def loaders(:binary_id, type), do: [Ecto.UUID, type]\ndef loaders(_primitive, type), do: [type]</code></pre>    <h3 class=\"detail-header callback\" id=\"c:prepare/2\">  <span class=\"signature\">prepare(atom, query)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">prepare(atom :: :all | :update_all | :delete_all, query :: <a href=\"ecto.query#t:t/0\">Ecto.Query.t</a>) ::\n  {:cache, <a href=\"#t:prepared/0\">prepared</a>} |\n  {:nocache, <a href=\"#t:prepared/0\">prepared</a>}</code></pre>    <p>Commands invoked to prepare a query for <code class=\"inline\">all</code>, <code class=\"inline\">update_all</code> and <code class=\"inline\">delete_all</code>.</p> <p>The returned result is given to <code class=\"inline\">execute/6</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:update/6\">  <span class=\"signature\">update(repo, schema_meta, fields, filters, returning, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update(repo, <a href=\"#t:schema_meta/0\">schema_meta</a>, <a href=\"#t:fields/0\">fields</a>, <a href=\"#t:filters/0\">filters</a>, <a href=\"#t:returning/0\">returning</a>, options) ::\n  {:ok, <a href=\"#t:fields/0\">fields</a>} |\n  {:invalid, <a href=\"#t:constraints/0\">constraints</a>} |\n  {:error, :stale} |\n  no_return</code></pre>    <p>Updates a single struct with the given filters.</p> <p>While <code class=\"inline\">filters</code> can be any record column, it is expected that at least the primary key (or any other key that uniquely identifies an existing record) be given as a filter. Therefore, in case there is no record matching the given filters, <code class=\"inline\">{:error, :stale}</code> is returned.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Adapter.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Adapter.html</a>\n  </p>\n</div>\n","phoenix/phoenix.endpoint":"<h1>  Phoenix.Endpoint  </h1>  <p>Defines a Phoenix endpoint.</p> <p>The endpoint is the boundary where all requests to your web application start. It is also the interface your application provides to the underlying web servers.</p> <p>Overall, an endpoint has three responsibilities:</p> <ul> <li>\n<p>to provide a wrapper for starting and stopping the endpoint as part of a supervision tree;</p> </li> <li>\n<p>to define an initial plug pipeline where requests are sent through;</p> </li> <li>to host web specific configuration for your application. </li> </ul> <h2>Endpoints</h2> <p>An endpoint is simply a module defined with the help of <a href=\"phoenix.endpoint#content\"><code class=\"inline\">Phoenix.Endpoint</code></a>. If you have used the <code class=\"inline\">mix phoenix.new</code> generator, an endpoint was automatically generated as part of your application:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule YourApp.Endpoint do\n  use Phoenix.Endpoint, otp_app: :your_app\n\n  # plug ...\n  # plug ...\n\n  plug YourApp.Router\nend</code></pre> <p>Before being used, an endpoint must be explicitly started as part of your application supervision tree too (which is again done by default in generated applications):</p> <pre data-language=\"elixir\"><code class=\"elixir\">supervisor(YourApp.Endpoint, [])</code></pre> <h3>Endpoint configuration</h3> <p>All endpoints are configured in your application environment. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :your_app, YourApp.Endpoint,\n  secret_key_base: \"kjoy3o1zeidquwy1398juxzldjlksahdk3\"</code></pre> <p>Endpoint configuration is split into two categories. Compile-time configuration means the configuration is read during compilation and changing it at runtime has no effect. The compile-time configuration is mostly related to error handling and instrumentation.</p> <p>Runtime configuration, instead, is accessed during or after your application is started and can be read and written through the <code class=\"inline\">config/2</code> function:</p> <pre data-language=\"elixir\"><code class=\"elixir\">YourApp.Endpoint.config(:port)\nYourApp.Endpoint.config(:some_config, :default_value)</code></pre> <h3>Compile-time configuration</h3> <ul> <li>\n<p><code class=\"inline\">:code_reloader</code> - when <code class=\"inline\">true</code>, enables code reloading functionality</p> </li> <li>\n<p><code class=\"inline\">:debug_errors</code> - when <code class=\"inline\">true</code>, uses <code class=\"inline\">Plug.Debugger</code> functionality for debugging failures in the application. Recommended to be set to <code class=\"inline\">true</code> only in development as it allows listing of the application source code during debugging. Defaults to <code class=\"inline\">false</code>.</p> </li> <li>\n<p><code class=\"inline\">:render_errors</code> - responsible for rendering templates whenever there is a failure in the application. For example, if the application crashes with a 500 error during a HTML request, <code class=\"inline\">render(\"500.html\", assigns)</code> will be called in the view given to <code class=\"inline\">:render_errors</code>. Defaults to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">[view: MyApp.ErrorView, accepts: ~w(html), layout: false]</code></pre> <p>The default format is used when none is set in the connection.</p> </li> <li>\n<code class=\"inline\">:instrumenters</code> - a list of instrumenter modules whose callbacks will be fired on instrumentation events. Read more on instrumentation in the “Instrumentation” section below. </li> </ul> <h3>Runtime configuration</h3> <ul> <li>\n<p><code class=\"inline\">:cache_static_manifest</code> - a path to a json manifest file that contains static files and their digested version. This is typically set to “priv/static/manifest.json” which is the file automatically generated by <code class=\"inline\">mix phoenix.digest</code>.</p> </li> <li>\n<p><code class=\"inline\">:check_origin</code> - configure transports to check origins or not. May be false, true or a list of hosts that are allowed. Hosts also support wildcards. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">check_origin: [\"//phoenixframework.org\", \"//*.example.com\"]</code></pre> </li> <li>\n<p><code class=\"inline\">:http</code> - the configuration for the HTTP server. Currently uses cowboy and accepts all options as defined by <a href=\"../plug/plug.adapters.cowboy\"><code class=\"inline\">Plug.Adapters.Cowboy</code></a>. Defaults to <code class=\"inline\">false</code>.</p> </li> <li>\n<p><code class=\"inline\">:https</code> - the configuration for the HTTPS server. Currently uses cowboy and accepts all options as defined by <a href=\"../plug/plug.adapters.cowboy\"><code class=\"inline\">Plug.Adapters.Cowboy</code></a>. Defaults to <code class=\"inline\">false</code>.</p> </li> <li>\n<p><code class=\"inline\">:force_ssl</code> - ensures no data is ever sent via http, always redirecting to https. It expects a list of options which are forwarded to <code class=\"inline\">Plug.SSL</code>. By default, it redirects http requests and sets the “strict-transport-security” header for https ones.</p> </li> <li>\n<p><code class=\"inline\">:secret_key_base</code> - a secret key used as a base to generate secrets for encrypting and signing data. For example, cookies and tokens are signed by default but they may also be encrypted if desired. Defaults to <code class=\"inline\">nil</code> as it must be set per application.</p> </li> <li>\n<p><code class=\"inline\">:server</code> - when <code class=\"inline\">true</code>, starts the web server when the endpoint supervision tree starts. Defaults to <code class=\"inline\">false</code>. The <code class=\"inline\">mix phoenix.server</code> task automatically sets this to <code class=\"inline\">true</code>.</p> </li> <li>\n<p><code class=\"inline\">:url</code> - configuration for generating URLs throughout the app. Accepts the <code class=\"inline\">:host</code>, <code class=\"inline\">:scheme</code>, <code class=\"inline\">:path</code> and <code class=\"inline\">:port</code> options. All keys except <code class=\"inline\">:path</code> can be changed at runtime. Defaults to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">[host: \"localhost\", path: \"/\"]</code></pre> <p>The <code class=\"inline\">:port</code> option requires either an integer, string, or <code class=\"inline\">{:system, \"ENV_VAR\"}</code>. When given a tuple like <code class=\"inline\">{:system, \"PORT\"}</code>, the port will be referenced from <code class=\"inline\">System.get_env(\"PORT\")</code> at runtime as a workaround for releases where environment specific information is loaded only at compile-time.</p> <p>The <code class=\"inline\">:host</code> option requires a string or <code class=\"inline\">{:system, \"ENV_VAR\"}</code>. Similar to <code class=\"inline\">:port</code>, when given a tuple like <code class=\"inline\">{:system, \"HOST\"}</code>, the host will be referenced from <code class=\"inline\">System.get_env(\"HOST\")</code> at runtime.</p> </li> <li>\n<p><code class=\"inline\">:static_url</code> - configuration for generating URLs for static files. It will fallback to <code class=\"inline\">url</code> if no option is provided. Accepts the same options as <code class=\"inline\">url</code>.</p> </li> <li>\n<p><code class=\"inline\">:watchers</code> - a set of watchers to run alongside your server. It expects a list of tuples containing the executable and its arguments. Watchers are guaranteed to run in the application directory but only when the server is enabled. For example, the watcher below will run the “watch” mode of the brunch build tool when the server starts. You can configure it to whatever build tool or command you want:</p> <pre data-language=\"elixir\"><code class=\"elixir\">[node: [\"node_modules/brunch/bin/brunch\", \"watch\"]]</code></pre> </li> <li>\n<p><code class=\"inline\">:live_reload</code> - configuration for the live reload option. Configuration requires a <code class=\"inline\">:patterns</code> option which should be a list of file patterns to watch. When these files change, it will trigger a reload. If you are using a tool like <a href=\"http://pow.cx\">pow</a> in development, you may need to set the <code class=\"inline\">:url</code> option appropriately.</p> <pre data-language=\"elixir\"><code class=\"elixir\">live_reload: [\n  url: \"ws://localhost:4000\",\n  patterns: [\n    ~r{priv/static/.*(js|css|png|jpeg|jpg|gif)$},\n    ~r{web/views/.*(ex)$},\n    ~r{web/templates/.*(eex)$}\n  ]\n]</code></pre> </li> <li>\n<p><code class=\"inline\">:pubsub</code> - configuration for this endpoint’s pubsub adapter. Configuration either requires a <code class=\"inline\">:name</code> of the registered pubsub server or a <code class=\"inline\">:name</code> and <code class=\"inline\">:adapter</code> pair. The given adapter and name pair will be started as part of the supervision tree. if no adapter is specified, the pubsub system will work by sending events and subscribing to the given name. Defaults to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">[adapter: Phoenix.PubSub.PG2, name: MyApp.PubSub]</code></pre> <p>It also supports custom adapter configuration:</p> <pre data-language=\"elixir\"><code class=\"elixir\">[name: :my_pubsub, adapter: Phoenix.PubSub.Redis,\n host: \"192.168.100.1\"]</code></pre> </li> </ul> <h2>Endpoint API</h2> <p>In the previous section, we have used the <code class=\"inline\">config/2</code> function which is automatically generated in your endpoint. Here is a summary of all the functions that are automatically defined in your endpoint.</p> <h4>Paths and URLs</h4> <ul> <li>\n<code class=\"inline\">struct_url()</code> - generates the endpoint base URL but as a <code class=\"inline\">URI</code> struct </li> <li>\n<code class=\"inline\">url()</code> - generates the endpoint base URL without any path information </li> <li>\n<code class=\"inline\">path(path)</code> - generates the path information when routing to this endpoint </li> <li>\n<code class=\"inline\">static_url()</code> - generates the static URL without any path information </li> <li>\n<code class=\"inline\">static_path(path)</code> - generates a route to a static file in <code class=\"inline\">priv/static</code> </li> </ul> <h4>Channels</h4> <ul> <li>\n<p><code class=\"inline\">subscribe(topic, opts)</code> - subscribes the caller to the given topic. See <code class=\"inline\">Phoenix.PubSub.subscribe/3</code> for options.</p> </li> <li>\n<p><code class=\"inline\">unsubscribe(topic)</code> - unsubscribes the caller from the given topic.</p> </li> <li>\n<p><code class=\"inline\">broadcast(topic, event, msg)</code> - broadcasts a <code class=\"inline\">msg</code> with as <code class=\"inline\">event</code> in the given <code class=\"inline\">topic</code>.</p> </li> <li>\n<p><code class=\"inline\">broadcast!(topic, event, msg)</code> - broadcasts a <code class=\"inline\">msg</code> with as <code class=\"inline\">event</code> in the given <code class=\"inline\">topic</code>. Raises in case of failures.</p> </li> <li>\n<p><code class=\"inline\">broadcast_from(from, topic, event, msg)</code> - broadcasts a <code class=\"inline\">msg</code> from the given <code class=\"inline\">from</code> as <code class=\"inline\">event</code> in the given <code class=\"inline\">topic</code>.</p> </li> <li>\n<code class=\"inline\">broadcast_from!(from, topic, event, msg)</code> - broadcasts a <code class=\"inline\">msg</code> from the given <code class=\"inline\">from</code> as <code class=\"inline\">event</code> in the given <code class=\"inline\">topic</code>. Raises in case of failures. </li> </ul> <h4>Endpoint configuration</h4> <ul> <li>\n<code class=\"inline\">start_link()</code> - starts the Endpoint supervision tree, including its configuration cache and possibly the servers for handling requests </li> <li>\n<code class=\"inline\">config(key, default)</code> - access the endpoint configuration given by key </li> <li>\n<code class=\"inline\">config_change(changed, removed)</code> - reload the endpoint configuration on application upgrades </li> </ul> <h4>Plug API</h4> <ul> <li>\n<code class=\"inline\">init(opts)</code> - invoked when starting the endpoint server </li> <li>\n<code class=\"inline\">call(conn, opts)</code> - invoked on every request (simply dispatches to the defined plug pipeline) </li> </ul> <h4>Instrumentation API</h4> <ul> <li>\n<code class=\"inline\">instrument(event, runtime_metadata \\ nil, function)</code> - read more about instrumentation in the “Instrumentation” section </li> </ul> <h2>Instrumentation</h2> <p>Phoenix supports instrumentation through an extensible API. Each endpoint defines an <code class=\"inline\">instrument/3</code> macro that both users and Phoenix internals can call to instrument generic events. This macro is responsible for measuring the time it takes for the event to happen and for notifying a list of interested instrumenter modules of this measurement.</p> <p>You can configure this list of instrumenter modules in the compile-time configuration of your endpoint. (see the <code class=\"inline\">:instrumenters</code> option above). The way these modules express their interest in events is by exporting public functions where the name of each function is the name of an event. For example, if someone instruments the <code class=\"inline\">:render_view</code> event, then each instrumenter module interested in that event will have to export <code class=\"inline\">render_view/3</code>.</p> <p><strong>Note</strong>: since the configuration for the list of instrumenters is specified at compile time but it’s used inside Phoenix itself, if you change this configuration you’ll have to recompile Phoenix manually:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$ mix deps.compile phoenix\n$ mix compile</code></pre> <h3>Callbacks cycle</h3> <p>The way event callbacks are called is the following.</p> <ol> <li>The event callback is called <em>before</em> the event happens (in this case, before the view is rendered) with the atom <code class=\"inline\">:start</code> as the first argument; see the “Before clause” section below. </li> <li>The event happens (in this case, the view is rendered). </li> <li>The same event callback is called again, this time with the atom <code class=\"inline\">:stop</code> as the first argument; see the “After clause” section below. </li> </ol> <p>The second and third argument that each event callback takes depend on the callback being an “after” or a “before” callback (i.e., they depend on the value of the first argument, <code class=\"inline\">:start</code> or <code class=\"inline\">:stop</code>). For this reason, most of the time you will want to define (at least) two separate clauses for each event callback, one for the “before” and one for the “after” callbacks.</p> <p>All event callbacks are run in the same process that calls the <code class=\"inline\">instrument/3</code> macro; hence, instrumenters should be careful in performing blocking actions. If an event callback fails in any way (exits, throws, or raises), it won’t affect anything (the error is caught) but the failure will be logged. Note that “after” callbacks are not guaranteed to be called as, for example, a link may break before they’ve been called.</p> <h4>“Before” clause</h4> <p>When the first argument to an event callback is <code class=\"inline\">:start</code>, the signature of that callback is:</p> <pre data-language=\"elixir\"><code class=\"elixir\">event_callback(:start, compile_metadata, runtime_metadata)</code></pre> <p>where:</p> <ul> <li>\n<code class=\"inline\">compile_metadata</code> is a map of compile-time metadata about the environment where <code class=\"inline\">instrument/3</code> has been called. It contains the module where the instrumentation is happening (under the <code class=\"inline\">:module</code> key), the file and line (<code class=\"inline\">:file</code> and <code class=\"inline\">:line</code>), and the function inside which the instrumentation is happening (under <code class=\"inline\">:function</code>). This information can be used arbitrarely by the callback. </li> <li>\n<code class=\"inline\">runtime_metadata</code> is a map of runtime data that the instrumentation passes to the callbacks. This can be used for any purposes: for example, when instrumenting the rendering of a view, the name of the view could be passed in these runtime data so that instrumenters know which view is being rendered (<code class=\"inline\">instrument(:view_render, %{view: \"index.html\"}, fn\n    ...)</code>). </li> </ul> <h4>“After” clause</h4> <p>When the first argument to an event callback is <code class=\"inline\">:stop</code>, the signature of that callback is:</p> <pre data-language=\"elixir\"><code class=\"elixir\">event_callback(:stop, time_diff, result_of_before_callback)</code></pre> <p>where:</p> <ul> <li>\n<p><code class=\"inline\">time_diff</code> is an integer representing the time it took to execute the instrumented function <strong>in native units</strong>.</p> </li> <li>\n<code class=\"inline\">result_of_before_callback</code> is the return value of the “before” clause of the same <code class=\"inline\">event_callback</code>. This is a means of passing data from the “before” clause to the “after” clause when instrumenting. </li> </ul> <p>The return value of each “before” event callback will be stored and passed to the corresponding “after” callback.</p> <h3>Using instrumentation</h3> <p>Each Phoenix endpoint defines its own <code class=\"inline\">instrument/3</code> macro. This macro is called like this:</p> <pre data-language=\"elixir\"><code class=\"elixir\">require MyApp.Endpoint\nMyApp.Endpoint.instrument :render_view, %{view: \"index.html\"}, fn -&gt;\n  # actual view rendering\nend</code></pre> <p>All the instrumenter modules that export a <code class=\"inline\">render_view/3</code> function will be notified of the event so that they can perform their respective actions.</p> <h3>Phoenix default events</h3> <p>By default, Phoenix instruments the following events:</p> <ul> <li>\n<code class=\"inline\">:phoenix_controller_call</code> - it’s the whole controller pipeline. The <code class=\"inline\">%Plug.Conn{}</code> is passed as runtime metadata. </li> <li>\n<code class=\"inline\">:phoenix_controller_render</code> - the rendering of a view from a controller. The map of runtime metadata passed to instrumentation callbacks has the <code class=\"inline\">:template</code> key - for the name of the template, e.g., <code class=\"inline\">\"index.html\"</code> - and the <code class=\"inline\">:format</code> key - for the format of the template. </li> <li>\n<code class=\"inline\">:phoenix_channel_join</code> - the joining of a channel. The <code class=\"inline\">%Phoenix.Socket{}</code> and join params are passed as runtime metadata via <code class=\"inline\">:socket</code> and <code class=\"inline\">:params</code>. </li> <li>\n<code class=\"inline\">:phoenix_channel_receive</code> - the receiving of an incoming message over a channel. The <code class=\"inline\">%Phoenix.Socket{}</code>, payload, event, and ref are passed as runtime metadata via <code class=\"inline\">:socket</code>, <code class=\"inline\">:params</code>, <code class=\"inline\">:event</code>, and <code class=\"inline\">:ref</code>. </li> </ul> <h3>Dynamic instrumentation</h3> <p>If you want to instrument a piece of code but the endpoint that should instrument it (the one that contains the <code class=\"inline\">instrument/3</code> macro you want to use) is not known at compile time, but only at runtime, then you can use the <a href=\"phoenix.endpoint#instrument/4\"><code class=\"inline\">Phoenix.Endpoint.instrument/4</code></a> macro. Refer to its documentation for more information.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#server?/2\">server?(otp_app, endpoint)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if Endpoint’s web server has been configured to start</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#instrument/4\">instrument(endpoint_or_conn_or_socket, event, runtime \\\\ Macro.escape(%{}), fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Instruments the given function using the instrumentation provided by the given endpoint</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#plug/2\">plug(plug, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stores a plug to be executed as part of the pipeline</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#socket/2\">socket(path, module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a mount-point for a Socket module to handle channel definitions</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"server?/2\">  <span class=\"signature\">server?(otp_app, endpoint)</span>  </h3>  <p>Checks if Endpoint’s web server has been configured to start.</p> <ul> <li>\n<code class=\"inline\">otp_app</code> - The otp app running the endpoint, for example <code class=\"inline\">:my_app</code> </li> <li>\n<code class=\"inline\">endpoint</code> - The endpoint module, for example <code class=\"inline\">MyApp.Endpoint</code> </li> </ul> <h4>Exampes</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Endpoint.server?(:my_app, MyApp.Endpoint)\ntrue</code></pre>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"instrument/4\">  <span class=\"signature\">instrument(endpoint_or_conn_or_socket, event, runtime \\\\ Macro.escape(%{}), fun)</span>  </h3>  <p>Instruments the given function using the instrumentation provided by the given endpoint.</p> <p>To specify the endpoint that will provide instrumentation, the first argument can be:</p> <ul> <li>a module name - the endpoint itself </li> <li>a <code class=\"inline\">Plug.Conn</code> struct - this macro will look for the endpoint module in the <code class=\"inline\">:private</code> field of the connection; if it’s not there, <code class=\"inline\">fun</code> will be executed with no instrumentation </li> <li>a <a href=\"phoenix.socket\"><code class=\"inline\">Phoenix.Socket</code></a> struct - this macro will look for the endpoint module in the <code class=\"inline\">:endpoint</code> field of the socket; if it’s not there, <code class=\"inline\">fun</code> will be executed with no instrumentation </li> </ul> <p>Usually, users should prefer to instrument events using the <code class=\"inline\">instrument/3</code> macro defined in every Phoenix endpoint. This macro should only be used for cases when the endpoint is dynamic and not known at compile time instead.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">endpoint = MyApp.Endpoint\nPhoenix.Endpoint.instrument endpoint, :render_view, fn -&gt; ... end</code></pre>    <h3 class=\"detail-header macro\" id=\"plug/2\">  <span class=\"signature\">plug(plug, opts \\\\ [])</span>  </h3>  <p>Stores a plug to be executed as part of the pipeline.</p>    <h3 class=\"detail-header macro\" id=\"socket/2\">  <span class=\"signature\">socket(path, module)</span>  </h3>  <p>Defines a mount-point for a Socket module to handle channel definitions.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">socket \"/ws\", MyApp.UserSocket\nsocket \"/ws/admin\", MyApp.AdminUserSocket</code></pre> <p>By default, the given path is a websocket upgrade endpoint, with long-polling fallback. The transports can be configured within the Socket handler. See <a href=\"phoenix.socket\"><code class=\"inline\">Phoenix.Socket</code></a> for more information on defining socket handlers.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Endpoint.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Endpoint.html</a>\n  </p>\n</div>\n","ecto/ecto.adapter.storage":"<h1>  Ecto.Adapter.Storage <small>behaviour</small>  </h1>  <p>Specifies the adapter storage API.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:storage_down/1\">storage_down(options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Drops the storage given by options</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:storage_up/1\">storage_up(options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates the storage given by options</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:storage_down/1\">  <span class=\"signature\">storage_down(options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">storage_down(options :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  :ok |\n  {:error, :already_down} |\n  {:error, term}</code></pre>    <p>Drops the storage given by options.</p> <p>Returns <code class=\"inline\">:ok</code> if it was dropped successfully.</p> <p>Returns <code class=\"inline\">{:error, :already_down}</code> if the storage has already been dropped or <code class=\"inline\">{:error, term}</code> in case anything else goes wrong.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">storage_down(username: postgres,\n             database: 'ecto_test',\n             hostname: 'localhost')</code></pre>    <h3 class=\"detail-header callback\" id=\"c:storage_up/1\">  <span class=\"signature\">storage_up(options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">storage_up(options :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  :ok |\n  {:error, :already_up} |\n  {:error, term}</code></pre>    <p>Creates the storage given by options.</p> <p>Returns <code class=\"inline\">:ok</code> if it was created successfully.</p> <p>Returns <code class=\"inline\">{:error, :already_up}</code> if the storage has already been created or <code class=\"inline\">{:error, term}</code> in case anything else goes wrong.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">storage_up(username: postgres,\n           database: 'ecto_test',\n           hostname: 'localhost')</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Adapter.Storage.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Adapter.Storage.html</a>\n  </p>\n</div>\n","ecto/ecto.adapter.structure":"<h1>  Ecto.Adapter.Structure <small>behaviour</small>  </h1>  <p>Specifies the adapter structure API.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:structure_dump/2\">structure_dump(default, config)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dumps the given structure</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:structure_load/2\">structure_load(default, config)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Loads the given structure</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:structure_dump/2\">  <span class=\"signature\">structure_dump(default, config)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">structure_dump(default :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, config :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>} |\n  {:error, term}</code></pre>    <p>Dumps the given structure.</p> <p>The path will be looked in the <code class=\"inline\">config</code> under :dump_path or default to the structure path inside <code class=\"inline\">default</code>.</p> <p>Returns <code class=\"inline\">:ok</code> if it was loaded successfully, an error tuple otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">structure_dump(\"priv/repo\", username: \"postgres\",\n                            database: \"ecto_test\",\n                            hostname: \"localhost\")</code></pre>    <h3 class=\"detail-header callback\" id=\"c:structure_load/2\">  <span class=\"signature\">structure_load(default, config)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">structure_load(default :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, config :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>} |\n  {:error, term}</code></pre>    <p>Loads the given structure.</p> <p>The path will be looked in the <code class=\"inline\">config</code> under :dump_path or default to the structure path inside <code class=\"inline\">default</code>.</p> <p>Returns <code class=\"inline\">:ok</code> if it was loaded successfully, an error tuple otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">structure_load(\"priv/repo\", username: \"postgres\",\n                            database: \"ecto_test\",\n                            hostname: \"localhost\")</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Adapter.Structure.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Adapter.Structure.html</a>\n  </p>\n</div>\n","ecto/ecto.adapters.mysql":"<h1>  Ecto.Adapters.MySQL  </h1>  <p>Adapter module for MySQL.</p> <p>It handles and pools the connections to the MySQL database using <code class=\"inline\">mariaex</code> and a connection pool, such as <code class=\"inline\">poolboy</code>.</p> <h2 id=\"module-options\" class=\"section-heading\">  Options </h2> <p>MySQL options split in different categories described below. All options should be given via the repository configuration.</p> <h3>Compile time options</h3> <p>Those options should be set in the config file and require recompilation in order to make an effect.</p> <ul> <li>\n<code class=\"inline\">:adapter</code> - The adapter name, in this case, <a href=\"ecto.adapters.mysql#content\"><code class=\"inline\">Ecto.Adapters.MySQL</code></a> </li> <li>\n<code class=\"inline\">:pool</code> - The connection pool module, defaults to <code class=\"inline\">Ecto.Pools.Poolboy</code> </li> <li>\n<code class=\"inline\">:pool_timeout</code> - The default timeout to use on pool calls, defaults to <code class=\"inline\">5000</code> </li> <li>\n<code class=\"inline\">:timeout</code> - The default timeout to use on queries, defaults to <code class=\"inline\">15000</code> </li> </ul> <h3>Connection options</h3> <ul> <li>\n<code class=\"inline\">:hostname</code> - Server hostname </li> <li>\n<code class=\"inline\">:port</code> - Server port (default: 3306) </li> <li>\n<code class=\"inline\">:username</code> - Username </li> <li>\n<code class=\"inline\">:password</code> - User password </li> <li>\n<code class=\"inline\">:ssl</code> - Set to true if ssl should be used (default: false) </li> <li>\n<code class=\"inline\">:ssl_opts</code> - A list of ssl options, see Erlang’s <code class=\"inline\">ssl</code> docs </li> <li>\n<code class=\"inline\">:parameters</code> - Keyword list of connection parameters </li> <li>\n<code class=\"inline\">:connect_timeout</code> - The timeout for establishing new connections (default: 5000) </li> <li>\n<code class=\"inline\">:socket_options</code> - Specifies socket configuration </li> </ul> <p>The <code class=\"inline\">:socket_options</code> are particularly useful when configuring the size of both send and receive buffers. For example, when Ecto starts with a pool of 20 connections, the memory usage may quickly grow from 20MB to 50MB based on the operating system default values for TCP buffers. It is advised to stick with the operating system defaults but they can be tweaked if desired:</p> <pre data-language=\"elixir\"><code class=\"elixir\">socket_options: [recbuf: 8192, sndbuf: 8192]</code></pre> <p>We also recommend developers to consult the <a href=\"https://hexdocs.pm/mariaex/Mariaex.html#start_link/1\">Mariaex documentation</a> for a complete listing of all supported options.</p> <h3>Storage options</h3> <ul> <li>\n<code class=\"inline\">:charset</code> - the database encoding (default: “utf8”) </li> <li>\n<code class=\"inline\">:collation</code> - the collation order </li> <li>\n<code class=\"inline\">:dump_path</code> - where to place dumped structures </li> </ul> <h2 id=\"module-limitations\" class=\"section-heading\">  Limitations </h2> <p>There are some limitations when using Ecto with MySQL that one needs to be aware of.</p> <h3>Engine</h3> <p>Since Ecto uses transactions, MySQL users running old versions (5.1 and before) must ensure their tables use the InnoDB engine as the default (MyISAM) does not support transactions.</p> <p>Tables created by Ecto are guaranteed to use InnoDB, regardless of the MySQL version.</p> <h3>UUIDs</h3> <p>MySQL does not support UUID types. Ecto emulates them by using <code class=\"inline\">binary(16)</code>.</p> <h3>Read after writes</h3> <p>Because MySQL does not support RETURNING clauses in INSERT and UPDATE, it does not support the <code class=\"inline\">:read_after_writes</code> option of <a href=\"ecto.schema#field/3\"><code class=\"inline\">Ecto.Schema.field/3</code></a>.</p> <h3>DDL Transaction</h3> <p>MySQL does not support migrations inside transactions as it automatically commits after some commands like CREATE TABLE. Therefore MySQL migrations does not run inside transactions.</p> <h3>usec in datetime</h3> <p>Old MySQL versions did not support usec in datetime while more recent versions would round or truncate the usec value.</p> <p>Therefore, in case the user decides to use microseconds in datetimes and timestamps with MySQL, be aware of such differences and consult the documentation for your MySQL version.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Adapters.MySQL.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Adapters.MySQL.html</a>\n  </p>\n</div>\n","ecto/ecto.association.has":"<h1>  Ecto.Association.Has  </h1>  <p>The association struct for <code class=\"inline\">has_one</code> and <code class=\"inline\">has_many</code> associations.</p> <p>Its fields are:</p> <ul> <li>\n<code class=\"inline\">cardinality</code> - The association cardinality </li> <li>\n<code class=\"inline\">field</code> - The name of the association field on the schema </li> <li>\n<code class=\"inline\">owner</code> - The schema where the association was defined </li> <li>\n<code class=\"inline\">related</code> - The schema that is associated </li> <li>\n<code class=\"inline\">owner_key</code> - The key on the <code class=\"inline\">owner</code> schema used for the association </li> <li>\n<code class=\"inline\">related_key</code> - The key on the <code class=\"inline\">related</code> schema used for the association </li> <li>\n<code class=\"inline\">queryable</code> - The real query to use for querying association </li> <li>\n<code class=\"inline\">on_delete</code> - The action taken on associations when schema is deleted </li> <li>\n<code class=\"inline\">on_replace</code> - The action taken on associations when schema is replaced </li> <li>\n<code class=\"inline\">defaults</code> - Default fields used when building the association </li> <li>\n<code class=\"inline\">relationship</code> - The relationship to the specified schema, default is <code class=\"inline\">:child</code> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Association.Has.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Association.Has.html</a>\n  </p>\n</div>\n","phoenix/phoenix.router":"<h1>  Phoenix.Router  </h1>  <p>Defines a Phoenix router.</p> <p>The router provides a set of macros for generating routes that dispatch to specific controllers and actions. Those macros are named after HTTP verbs. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.Router do\n  use Phoenix.Router\n\n  get \"/pages/:page\", PageController, :show\nend</code></pre> <p>The <code class=\"inline\">get/3</code> macro above accepts a request of format <code class=\"inline\">\"/pages/VALUE\"</code> and dispatches it to the show action in the <code class=\"inline\">PageController</code>.</p> <p>Routes can also match glob-like patterns, routing any path with a common base to the same controller. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">get \"/dynamic*anything\", DynamicController, :show</code></pre> <p>Phoenix’s router is extremely efficient, as it relies on Elixir pattern matching for matching routes and serving requests.</p> <h3>Helpers</h3> <p>Phoenix automatically generates a module <code class=\"inline\">Helpers</code> inside your router which contains named helpers to help developers generate and keep their routes up to date.</p> <p>Helpers are automatically generated based on the controller name. For example, the route:</p> <pre data-language=\"elixir\"><code class=\"elixir\">get \"/pages/:page\", PageController, :show</code></pre> <p>will generate the following named helper:</p> <pre data-language=\"elixir\"><code class=\"elixir\">MyApp.Router.Helpers.page_path(conn_or_endpoint, :show, \"hello\")\n\"/pages/hello\"\n\nMyApp.Router.Helpers.page_path(conn_or_endpoint, :show, \"hello\", some: \"query\")\n\"/pages/hello?some=query\"\n\nMyApp.Router.Helpers.page_url(conn_or_endpoint, :show, \"hello\")\n\"http://example.com/pages/hello\"\n\nMyApp.Router.Helpers.page_url(conn_or_endpoint, :show, \"hello\", some: \"query\")\n\"http://example.com/pages/hello?some=query\"</code></pre> <p>If the route contains glob-like patterns, parameters for those have to be given as list:</p> <pre data-language=\"elixir\"><code class=\"elixir\">MyApp.Router.Helpers.dynamic_path(conn_or_endpoint, :show, [\"dynamic\", \"something\"])\n\"/dynamic/something\"</code></pre> <p>The url generated in the named url helpers is based on the configuration for <code class=\"inline\">:url</code>, <code class=\"inline\">:http</code> and <code class=\"inline\">:https</code>.</p> <p>The named helper can also be customized with the <code class=\"inline\">:as</code> option. Given the route:</p> <pre data-language=\"elixir\"><code class=\"elixir\">get \"/pages/:page\", PageController, :show, as: :special_page</code></pre> <p>the named helper will be:</p> <pre data-language=\"elixir\"><code class=\"elixir\">MyApp.Router.Helpers.special_page_path(conn, :show, \"hello\")\n\"/pages/hello\"</code></pre> <h3>Scopes and Resources</h3> <p>The router also supports scoping of routes:</p> <pre data-language=\"elixir\"><code class=\"elixir\">scope \"/api/v1\", as: :api_v1 do\n  get \"/pages/:id\", PageController, :show\nend</code></pre> <p>For example, the route above will match on the path <code class=\"inline\">\"/api/v1/pages/:id\"</code> and the named route will be <code class=\"inline\">api_v1_page_path</code>, as expected from the values given to <a href=\"#scope/2\"><code class=\"inline\">scope/2</code></a> option.</p> <p>Phoenix also provides a <a href=\"#resources/4\"><code class=\"inline\">resources/4</code></a> macro that allows developers to generate “RESTful” routes to a given resource:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.Router do\n  use Phoenix.Router\n\n  resources \"/pages\", PageController, only: [:show]\n  resources \"/users\", UserController, except: [:delete]\nend</code></pre> <p>Finally, Phoenix ships with a <code class=\"inline\">mix phoenix.routes</code> task that nicely formats all routes in a given router. We can use it to verify all routes included in the router above:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$ mix phoenix.routes\npage_path  GET    /pages/:id       PageController.show/2\nuser_path  GET    /users           UserController.index/2\nuser_path  GET    /users/:id/edit  UserController.edit/2\nuser_path  GET    /users/new       UserController.new/2\nuser_path  GET    /users/:id       UserController.show/2\nuser_path  POST   /users           UserController.create/2\nuser_path  PATCH  /users/:id       UserController.update/2\n           PUT    /users/:id       UserController.update/2</code></pre> <p>One can also pass a router explicitly as an argument to the task:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$ mix phoenix.routes MyApp.Router</code></pre> <p>Check <a href=\"#scope/2\"><code class=\"inline\">scope/2</code></a> and <a href=\"#resources/4\"><code class=\"inline\">resources/4</code></a> for more information.</p> <h2>Pipelines and plugs</h2> <p>Once a request arrives at the Phoenix router, it performs a series of transformations through pipelines until the request is dispatched to a desired end-point.</p> <p>Such transformations are defined via plugs, as defined in the <a href=\"http://github.com/elixir-lang/plug\">Plug</a> specification. Once a pipeline is defined, it can be piped through per scope.</p> <p>For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.Router do\n  use Phoenix.Router\n\n  pipeline :browser do\n    plug :fetch_session\n    plug :accepts, [\"html\"]\n  end\n\n  scope \"/\" do\n    pipe_through :browser\n\n    # browser related routes and resources\n  end\nend</code></pre> <p><a href=\"phoenix.router#content\"><code class=\"inline\">Phoenix.Router</code></a> imports functions from both <code class=\"inline\">Plug.Conn</code> and <a href=\"phoenix.controller\"><code class=\"inline\">Phoenix.Controller</code></a> to help define plugs. In the example above, <code class=\"inline\">fetch_session/2</code> comes from <code class=\"inline\">Plug.Conn</code> while <code class=\"inline\">accepts/2</code> comes from <a href=\"phoenix.controller\"><code class=\"inline\">Phoenix.Controller</code></a>.</p> <p>Note that router pipelines are only invoked after a route is found. No plug is invoked in case no matches were found.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#connect/4\">connect(path, plug, plug_opts, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a route to handle a connect request to the given path</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete/4\">delete(path, plug, plug_opts, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a route to handle a delete request to the given path</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#forward/4\">forward(path, plug, plug_opts \\\\ [], router_opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Forwards a request at the given path to a plug</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get/4\">get(path, plug, plug_opts, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a route to handle a get request to the given path</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#head/4\">head(path, plug, plug_opts, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a route to handle a head request to the given path</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#match/5\">match(verb, path, plug, plug_opts, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a route match based on an arbitrary HTTP method</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#options/4\">options(path, plug, plug_opts, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a route to handle a options request to the given path</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#patch/4\">patch(path, plug, plug_opts, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a route to handle a patch request to the given path</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pipe_through/1\">pipe_through(pipes)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a pipeline to send the connection through</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pipeline/2\">pipeline(plug, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a plug pipeline</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#plug/2\">plug(plug, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a plug inside a pipeline</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#post/4\">post(path, plug, plug_opts, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a route to handle a post request to the given path</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put/4\">put(path, plug, plug_opts, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a route to handle a put request to the given path</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#resources/2\">resources(path, controller)</a> </dt> <dd class=\"summary-synopsis\">\n<p>See <a href=\"#resources/4\"><code class=\"inline\">resources/4</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#resources/3\">resources(path, controller, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>See <a href=\"#resources/4\"><code class=\"inline\">resources/4</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#resources/4\">resources(path, controller, opts, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines “RESTful” routes for a resource</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#scope/2\">scope(options, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a scope in which routes can be nested</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#scope/3\">scope(path, options, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Define a scope with the given path</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#scope/4\">scope(path, alias, options, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a scope with the given path and alias</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#trace/4\">trace(path, plug, plug_opts, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a route to handle a trace request to the given path</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"connect/4\">  <span class=\"signature\">connect(path, plug, plug_opts, options \\\\ [])</span>  </h3>  <p>Generates a route to handle a connect request to the given path.</p>    <h3 class=\"detail-header macro\" id=\"delete/4\">  <span class=\"signature\">delete(path, plug, plug_opts, options \\\\ [])</span>  </h3>  <p>Generates a route to handle a delete request to the given path.</p>    <h3 class=\"detail-header macro\" id=\"forward/4\">  <span class=\"signature\">forward(path, plug, plug_opts \\\\ [], router_opts \\\\ [])</span>  </h3>  <p>Forwards a request at the given path to a plug.</p> <p>All paths that matches the forwarded prefix will be sent to the forwarded plug. This is useful to share router between applications or even break a big router into smaller ones. The router pipelines will be invoked prior to forwarding the connection.</p> <p>The forwarded plug will be initialized at compile time.</p> <p>Note, however, that we don’t advise forwarding to another endpoint. The reason is that plugs defined by your app and the forwarded endpoint would be invoked twice, which may lead to errors.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">scope \"/\", MyApp do\n  pipe_through [:browser, :admin]\n\n  forward \"/admin\", SomeLib.AdminDashboard\n  forward \"/api\", ApiRouter\nend</code></pre>    <h3 class=\"detail-header macro\" id=\"get/4\">  <span class=\"signature\">get(path, plug, plug_opts, options \\\\ [])</span>  </h3>  <p>Generates a route to handle a get request to the given path.</p>    <h3 class=\"detail-header macro\" id=\"head/4\">  <span class=\"signature\">head(path, plug, plug_opts, options \\\\ [])</span>  </h3>  <p>Generates a route to handle a head request to the given path.</p>    <h3 class=\"detail-header macro\" id=\"match/5\">  <span class=\"signature\">match(verb, path, plug, plug_opts, options \\\\ [])</span>  </h3>  <p>Generates a route match based on an arbitrary HTTP method</p> <p>Useful for defining routes not included in the builtin macros:</p> <p><code class=\"inline\">get</code>, <code class=\"inline\">post</code>, <code class=\"inline\">put</code>, <code class=\"inline\">patch</code>, <code class=\"inline\">delete</code>, <code class=\"inline\">options</code>, <code class=\"inline\">connect</code>, <code class=\"inline\">trace</code>, <code class=\"inline\">head</code></p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">match(:move, \"/events/:id\", EventController, :move)</code></pre>    <h3 class=\"detail-header macro\" id=\"options/4\">  <span class=\"signature\">options(path, plug, plug_opts, options \\\\ [])</span>  </h3>  <p>Generates a route to handle a options request to the given path.</p>    <h3 class=\"detail-header macro\" id=\"patch/4\">  <span class=\"signature\">patch(path, plug, plug_opts, options \\\\ [])</span>  </h3>  <p>Generates a route to handle a patch request to the given path.</p>    <h3 class=\"detail-header macro\" id=\"pipe_through/1\">  <span class=\"signature\">pipe_through(pipes)</span>  </h3>  <p>Defines a pipeline to send the connection through.</p> <p>See <a href=\"#pipeline/2\"><code class=\"inline\">pipeline/2</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"pipeline/2\">  <span class=\"signature\">pipeline(plug, list)</span>  </h3>  <p>Defines a plug pipeline.</p> <p>Pipelines are defined at the router root and can be used from any scope.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">pipeline :api do\n  plug :token_authentication\n  plug :dispatch\nend</code></pre> <p>A scope may then use this pipeline as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">scope \"/\" do\n  pipe_through :api\nend</code></pre> <p>Every time <a href=\"#pipe_through/1\"><code class=\"inline\">pipe_through/1</code></a> is called, the new pipelines are appended to the ones previously given.</p>    <h3 class=\"detail-header macro\" id=\"plug/2\">  <span class=\"signature\">plug(plug, opts \\\\ [])</span>  </h3>  <p>Defines a plug inside a pipeline.</p> <p>See <a href=\"#pipeline/2\"><code class=\"inline\">pipeline/2</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"post/4\">  <span class=\"signature\">post(path, plug, plug_opts, options \\\\ [])</span>  </h3>  <p>Generates a route to handle a post request to the given path.</p>    <h3 class=\"detail-header macro\" id=\"put/4\">  <span class=\"signature\">put(path, plug, plug_opts, options \\\\ [])</span>  </h3>  <p>Generates a route to handle a put request to the given path.</p>    <h3 class=\"detail-header macro\" id=\"resources/2\">  <span class=\"signature\">resources(path, controller)</span>  </h3>  <p>See <a href=\"#resources/4\"><code class=\"inline\">resources/4</code></a>.</p>    <h3 class=\"detail-header macro\" id=\"resources/3\">  <span class=\"signature\">resources(path, controller, opts)</span>  </h3>  <p>See <a href=\"#resources/4\"><code class=\"inline\">resources/4</code></a>.</p>    <h3 class=\"detail-header macro\" id=\"resources/4\">  <span class=\"signature\">resources(path, controller, opts, list)</span>  </h3>  <p>Defines “RESTful” routes for a resource.</p> <p>The given definition:</p> <pre data-language=\"elixir\"><code class=\"elixir\">resources \"/users\", UserController</code></pre> <p>will include routes to the following actions:</p> <ul> <li>\n<code class=\"inline\">GET /users</code> =&gt; <code class=\"inline\">:index</code> </li> <li>\n<code class=\"inline\">GET /users/new</code> =&gt; <code class=\"inline\">:new</code> </li> <li>\n<code class=\"inline\">POST /users</code> =&gt; <code class=\"inline\">:create</code> </li> <li>\n<code class=\"inline\">GET /users/:id</code> =&gt; <code class=\"inline\">:show</code> </li> <li>\n<code class=\"inline\">GET /users/:id/edit</code> =&gt; <code class=\"inline\">:edit</code> </li> <li>\n<code class=\"inline\">PATCH /users/:id</code> =&gt; <code class=\"inline\">:update</code> </li> <li>\n<code class=\"inline\">PUT /users/:id</code> =&gt; <code class=\"inline\">:update</code> </li> <li>\n<code class=\"inline\">DELETE /users/:id</code> =&gt; <code class=\"inline\">:delete</code> </li> </ul> <h4>Options</h4> <p>This macro accepts a set of options:</p> <ul> <li>\n<code class=\"inline\">:only</code> - a list of actions to generate routes for, for example: <code class=\"inline\">[:show, :edit]</code> </li> <li>\n<code class=\"inline\">:except</code> - a list of actions to exclude generated routes from, for example: <code class=\"inline\">[:delete]</code> </li> <li>\n<code class=\"inline\">:param</code> - the name of the parameter for this resource, defaults to <code class=\"inline\">\"id\"</code> </li> <li>\n<code class=\"inline\">:name</code> - the prefix for this resource. This is used for the named helper and as the prefix for the parameter in nested resources. The default value is automatically derived from the controller name, i.e. <code class=\"inline\">UserController</code> will have name <code class=\"inline\">\"user\"</code> </li> <li>\n<code class=\"inline\">:as</code> - configures the named helper exclusively </li> <li>\n<code class=\"inline\">:singleton</code> - defines routes for a singleton resource that is looked up by the client without referencing an ID. Read below for more information </li> </ul> <h4>Singleton resources</h4> <p>When a resource needs to be looked up without referencing an ID, because it contains only a single entry in the given context, the <code class=\"inline\">:singleton</code> option can be used to generate a set of routes that are specific to such single resource:</p> <ul> <li>\n<code class=\"inline\">GET /user</code> =&gt; <code class=\"inline\">:show</code> </li> <li>\n<code class=\"inline\">GET /user/new</code> =&gt; <code class=\"inline\">:new</code> </li> <li>\n<code class=\"inline\">POST /user</code> =&gt; <code class=\"inline\">:create</code> </li> <li>\n<code class=\"inline\">GET /user/edit</code> =&gt; <code class=\"inline\">:edit</code> </li> <li>\n<code class=\"inline\">PATCH /user</code> =&gt; <code class=\"inline\">:update</code> </li> <li>\n<code class=\"inline\">PUT /user</code> =&gt; <code class=\"inline\">:update</code> </li> <li>\n<p><code class=\"inline\">DELETE /user</code> =&gt; <code class=\"inline\">:delete</code></p> <p> Usage example:</p> <p><code class=\"inline\">resources \"/account\", AccountController, only: [:show], singleton: true</code></p> </li> </ul>    <h3 class=\"detail-header macro\" id=\"scope/2\">  <span class=\"signature\">scope(options, list)</span>  </h3>  <p>Defines a scope in which routes can be nested.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">scope \"/api/v1\", as: :api_v1, alias: API.V1 do\n  get \"/pages/:id\", PageController, :show\nend</code></pre> <p>The generated route above will match on the path <code class=\"inline\">\"/api/v1/pages/:id\"</code> and will dispatch to <code class=\"inline\">:show</code> action in <code class=\"inline\">API.V1.PageController</code>. A named helper <code class=\"inline\">api_v1_page_path</code> will also be generated.</p> <h4>Options</h4> <p>The supported options are:</p> <ul> <li>\n<code class=\"inline\">:path</code> - a string containing the path scope </li> <li>\n<code class=\"inline\">:as</code> - a string or atom containing the named helper scope </li> <li>\n<code class=\"inline\">:alias</code> - an alias (atom) containing the controller scope </li> <li>\n<code class=\"inline\">:host</code> - a string containing the host scope, or prefix host scope, ie <code class=\"inline\">\"foo.bar.com\"</code>, <code class=\"inline\">\"foo.\"</code> </li> <li>\n<code class=\"inline\">:private</code> - a map of private data to merge into the connection when a route matches </li> <li>\n<code class=\"inline\">:assigns</code> - a map of data to merge into the connection when a route matches </li> </ul>    <h3 class=\"detail-header macro\" id=\"scope/3\">  <span class=\"signature\">scope(path, options, list)</span>  </h3>  <p>Define a scope with the given path.</p> <p>This function is a shortcut for:</p> <pre data-language=\"elixir\"><code class=\"elixir\">scope path: path do\n  ...\nend</code></pre>    <h3 class=\"detail-header macro\" id=\"scope/4\">  <span class=\"signature\">scope(path, alias, options, list)</span>  </h3>  <p>Defines a scope with the given path and alias.</p> <p>This function is a shortcut for:</p> <pre data-language=\"elixir\"><code class=\"elixir\">scope path: path, alias: alias do\n  ...\nend</code></pre>    <h3 class=\"detail-header macro\" id=\"trace/4\">  <span class=\"signature\">trace(path, plug, plug_opts, options \\\\ [])</span>  </h3>  <p>Generates a route to handle a trace request to the given path.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.Router.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.Router.html</a>\n  </p>\n</div>\n","ecto/ecto.adapter.migration":"<h1>  Ecto.Adapter.Migration <small>behaviour</small>  </h1>  <p>Specifies the adapter migrations API.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:command/0\">command()</a> </dt> <dd class=\"summary-synopsis\">\n<p>All migration commands</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:ddl_object/0\">ddl_object()</a> </dt> <dd class=\"summary-synopsis\">\n<p>A DDL object is a struct that represents a table or index in a database schema. These database objects can be modified through the use of a Data Definition Language, hence the name DDL object</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:table_subcommand/0\">table_subcommand()</a> </dt> <dd class=\"summary-synopsis\">\n<p>All commands allowed within the block passed to <code class=\"inline\">table/2</code></p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:execute_ddl/3\">execute_ddl(repo, command, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Executes migration commands</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:supports_ddl_transaction?/0\">supports_ddl_transaction?()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the adapter supports ddl transaction</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:command/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:command/0\">command</a> :: raw :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a> | {:create, <a href=\"ecto.migration.table#t:t/0\">Ecto.Migration.Table.t</a>, [<a href=\"#t:table_subcommand/0\">table_subcommand</a>]} | {:create_if_not_exists, <a href=\"ecto.migration.table#t:t/0\">Ecto.Migration.Table.t</a>, [<a href=\"#t:table_subcommand/0\">table_subcommand</a>]} | {:alter, <a href=\"ecto.migration.table#t:t/0\">Ecto.Migration.Table.t</a>, [<a href=\"#t:table_subcommand/0\">table_subcommand</a>]} | {:drop, <a href=\"ecto.migration.table#t:t/0\">Ecto.Migration.Table.t</a>} | {:drop_if_exists, <a href=\"ecto.migration.table#t:t/0\">Ecto.Migration.Table.t</a>} | {:create, <a href=\"ecto.migration.index#t:t/0\">Ecto.Migration.Index.t</a>} | {:create_if_not_exists, <a href=\"ecto.migration.index#t:t/0\">Ecto.Migration.Index.t</a>} | {:drop, <a href=\"ecto.migration.index#t:t/0\">Ecto.Migration.Index.t</a>} | {:drop_if_exists, <a href=\"ecto.migration.index#t:t/0\">Ecto.Migration.Index.t</a>}</code></pre> <p>All migration commands</p>  </div> <div id=\"t:ddl_object/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:ddl_object/0\">ddl_object</a> ::\n  <a href=\"ecto.migration.table#t:t/0\">Ecto.Migration.Table.t</a> |\n  <a href=\"ecto.migration.index#t:t/0\">Ecto.Migration.Index.t</a></code></pre> <p>A DDL object is a struct that represents a table or index in a database schema. These database objects can be modified through the use of a Data Definition Language, hence the name DDL object.</p>  </div> <div id=\"t:table_subcommand/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:table_subcommand/0\">table_subcommand</a> ::\n  {:add, field :: atom, type :: <a href=\"ecto.type#t:t/0\">Ecto.Type.t</a> | <a href=\"ecto.migration.reference#t:t/0\">Ecto.Migration.Reference.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>} |\n  {:modify, field :: atom, type :: <a href=\"ecto.type#t:t/0\">Ecto.Type.t</a> | <a href=\"ecto.migration.reference#t:t/0\">Ecto.Migration.Reference.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>} |\n  {:remove, field :: atom}</code></pre> <p>All commands allowed within the block passed to <code class=\"inline\">table/2</code></p>  </div>    <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:execute_ddl/3\">  <span class=\"signature\">execute_ddl(repo, command, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">execute_ddl(repo :: <a href=\"ecto.repo#t:t/0\">Ecto.Repo.t</a>, <a href=\"#t:command/0\">command</a>, options :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  :ok |\n  no_return</code></pre>    <p>Executes migration commands.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:timeout</code> - The time in milliseconds to wait for the query call to finish, <code class=\"inline\">:infinity</code> will wait indefinitely (default: 15000); </li> <li>\n<code class=\"inline\">:pool_timeout</code> - The time in milliseconds to wait for calls to the pool to finish, <code class=\"inline\">:infinity</code> will wait indefinitely (default: 5000); </li> <li>\n<code class=\"inline\">:log</code> - When false, does not log begin/commit/rollback queries </li> </ul>    <h3 class=\"detail-header callback\" id=\"c:supports_ddl_transaction?/0\">  <span class=\"signature\">supports_ddl_transaction?()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">supports_ddl_transaction? :: boolean</code></pre>    <p>Checks if the adapter supports ddl transaction.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Adapter.Migration.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Adapter.Migration.html</a>\n  </p>\n</div>\n","ecto/ecto.adapter.transaction":"<h1>  Ecto.Adapter.Transaction <small>behaviour</small>  </h1>  <p>Specifies the adapter transactions API.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:in_transaction?/1\">in_transaction?(repo)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns true if the given process is inside a transaction</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:rollback/2\">rollback(repo, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Rolls back the current transaction</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:transaction/3\">transaction(repo, options, function)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Runs the given function inside a transaction</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:in_transaction?/1\">  <span class=\"signature\">in_transaction?(repo)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">in_transaction?(repo :: <a href=\"ecto.repo#t:t/0\">Ecto.Repo.t</a>) :: boolean</code></pre>    <p>Returns true if the given process is inside a transaction.</p>    <h3 class=\"detail-header callback\" id=\"c:rollback/2\">  <span class=\"signature\">rollback(repo, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rollback(repo :: <a href=\"ecto.repo#t:t/0\">Ecto.Repo.t</a>, value :: any) :: no_return</code></pre>    <p>Rolls back the current transaction.</p> <p>The transaction will return the value given as <code class=\"inline\">{:error, value}</code>.</p> <p>See <code class=\"inline\">Ecto.Repo.rollback/1</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:transaction/3\">  <span class=\"signature\">transaction(repo, options, function)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">transaction(repo :: <a href=\"ecto.repo#t:t/0\">Ecto.Repo.t</a>, options :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>, function :: (... -&gt; any)) ::\n  {:ok, any} |\n  {:error, any}</code></pre>    <p>Runs the given function inside a transaction.</p> <p>Returns <code class=\"inline\">{:ok, value}</code> if the transaction was successful where <code class=\"inline\">value</code> is the value return by the function or <code class=\"inline\">{:error, value}</code> if the transaction was rolled back where <code class=\"inline\">value</code> is the value given to <code class=\"inline\">rollback/1</code>.</p> <p>See <code class=\"inline\">Ecto.Repo.transaction/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Adapter.Transaction.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Adapter.Transaction.html</a>\n  </p>\n</div>\n","ecto/ecto.association.belongsto":"<h1>  Ecto.Association.BelongsTo  </h1>  <p>The association struct for a <code class=\"inline\">belongs_to</code> association.</p> <p>Its fields are:</p> <ul> <li>\n<code class=\"inline\">cardinality</code> - The association cardinality </li> <li>\n<code class=\"inline\">field</code> - The name of the association field on the schema </li> <li>\n<code class=\"inline\">owner</code> - The schema where the association was defined </li> <li>\n<code class=\"inline\">owner_key</code> - The key on the <code class=\"inline\">owner</code> schema used for the association </li> <li>\n<code class=\"inline\">related</code> - The schema that is associated </li> <li>\n<code class=\"inline\">related_key</code> - The key on the <code class=\"inline\">related</code> schema used for the association </li> <li>\n<code class=\"inline\">queryable</code> - The real query to use for querying association </li> <li>\n<code class=\"inline\">defaults</code> - Default fields used when building the association </li> <li>\n<code class=\"inline\">relationship</code> - The relationship to the specified schema, default <code class=\"inline\">:parent</code> </li> <li>\n<code class=\"inline\">on_replace</code> - The action taken on associations when schema is replaced </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Association.BelongsTo.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Association.BelongsTo.html</a>\n  </p>\n</div>\n","ecto/ecto.association.manytomany":"<h1>  Ecto.Association.ManyToMany  </h1>  <p>The association struct for <code class=\"inline\">many_to_many</code> associations.</p> <p>Its fields are:</p> <ul> <li>\n<code class=\"inline\">cardinality</code> - The association cardinality </li> <li>\n<code class=\"inline\">field</code> - The name of the association field on the schema </li> <li>\n<code class=\"inline\">owner</code> - The schema where the association was defined </li> <li>\n<code class=\"inline\">related</code> - The schema that is associated </li> <li>\n<code class=\"inline\">owner_key</code> - The key on the <code class=\"inline\">owner</code> schema used for the association </li> <li>\n<code class=\"inline\">queryable</code> - The real query to use for querying association </li> <li>\n<code class=\"inline\">on_delete</code> - The action taken on associations when schema is deleted </li> <li>\n<code class=\"inline\">on_replace</code> - The action taken on associations when schema is replaced </li> <li>\n<code class=\"inline\">defaults</code> - Default fields used when building the association </li> <li>\n<code class=\"inline\">relationship</code> - The relationship to the specified schema, default <code class=\"inline\">:child</code> </li> <li>\n<code class=\"inline\">join_keys</code> - The keyword list with many to many join keys </li> <li>\n<code class=\"inline\">join_through</code> - Atom (representing a schema) or a string (representing a table) for many to many associations </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Association.ManyToMany.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Association.ManyToMany.html</a>\n  </p>\n</div>\n","ecto/ecto.adapters.postgres":"<h1>  Ecto.Adapters.Postgres  </h1>  <p>Adapter module for PostgreSQL.</p> <p>It uses <code class=\"inline\">postgrex</code> for communicating to the database and a connection pool, such as <code class=\"inline\">poolboy</code>.</p> <h2 id=\"module-features\" class=\"section-heading\">  Features </h2> <ul> <li>Full query support (including joins, preloads and associations) </li> <li>Support for transactions </li> <li>Support for data migrations </li> <li>Support for ecto.create and ecto.drop operations </li> <li>Support for transactional tests via <a href=\"ecto.adapters.sql\"><code class=\"inline\">Ecto.Adapters.SQL</code></a> </li> </ul> <h2 id=\"module-options\" class=\"section-heading\">  Options </h2> <p>Postgres options split in different categories described below. All options should be given via the repository configuration.</p> <h3>Compile time options</h3> <p>Those options should be set in the config file and require recompilation in order to make an effect.</p> <ul> <li>\n<code class=\"inline\">:adapter</code> - The adapter name, in this case, <a href=\"ecto.adapters.postgres#content\"><code class=\"inline\">Ecto.Adapters.Postgres</code></a> </li> <li>\n<code class=\"inline\">:name</code>- The name of the Repo supervisor process </li> <li>\n<code class=\"inline\">:pool</code> - The connection pool module, defaults to <code class=\"inline\">Ecto.Pools.Poolboy</code> </li> <li>\n<code class=\"inline\">:pool_timeout</code> - The default timeout to use on pool calls, defaults to <code class=\"inline\">5000</code> </li> <li>\n<code class=\"inline\">:timeout</code> - The default timeout to use on queries, defaults to <code class=\"inline\">15000</code> </li> </ul> <h3>Connection options</h3> <ul> <li>\n<code class=\"inline\">:hostname</code> - Server hostname </li> <li>\n<code class=\"inline\">:port</code> - Server port (default: 5432) </li> <li>\n<code class=\"inline\">:username</code> - Username </li> <li>\n<code class=\"inline\">:password</code> - User password </li> <li>\n<code class=\"inline\">:ssl</code> - Set to true if ssl should be used (default: false) </li> <li>\n<code class=\"inline\">:ssl_opts</code> - A list of ssl options, see Erlang’s <code class=\"inline\">ssl</code> docs </li> <li>\n<code class=\"inline\">:parameters</code> - Keyword list of connection parameters </li> <li>\n<code class=\"inline\">:connect_timeout</code> - The timeout for establishing new connections (default: 5000) </li> <li>\n<code class=\"inline\">:socket_options</code> - Specifies socket configuration </li> </ul> <p>The <code class=\"inline\">:socket_options</code> are particularly useful when configuring the size of both send and receive buffers. For example, when Ecto starts with a pool of 20 connections, the memory usage may quickly grow from 20MB to 50MB based on the operating system default values for TCP buffers. It is advised to stick with the operating system defaults but they can be tweaked if desired:</p> <pre data-language=\"elixir\"><code class=\"elixir\">socket_options: [recbuf: 8192, sndbuf: 8192]</code></pre> <p>We also recommend developers to consult the <a href=\"https://hexdocs.pm/postgrex/Postgrex.html#start_link/1\">Postgrex documentation</a> for a complete listing of all supported options.</p> <h3>Storage options</h3> <ul> <li>\n<code class=\"inline\">:encoding</code> - the database encoding (default: “UTF8”) </li> <li>\n<code class=\"inline\">:template</code> - the template to create the database from </li> <li>\n<code class=\"inline\">:lc_collate</code> - the collation order </li> <li>\n<code class=\"inline\">:lc_ctype</code> - the character classification </li> <li>\n<code class=\"inline\">:dump_path</code> - where to place dumped structures </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Adapters.Postgres.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Adapters.Postgres.html</a>\n  </p>\n</div>\n","ecto/ecto.association.hasthrough":"<h1>  Ecto.Association.HasThrough  </h1>  <p>The association struct for <code class=\"inline\">has_one</code> and <code class=\"inline\">has_many</code> through associations.</p> <p>Its fields are:</p> <ul> <li>\n<code class=\"inline\">cardinality</code> - The association cardinality </li> <li>\n<code class=\"inline\">field</code> - The name of the association field on the schema </li> <li>\n<code class=\"inline\">owner</code> - The schema where the association was defined </li> <li>\n<code class=\"inline\">owner_key</code> - The key on the <code class=\"inline\">owner</code> schema used for the association </li> <li>\n<code class=\"inline\">through</code> - The through associations </li> <li>\n<code class=\"inline\">relationship</code> - The relationship to the specified schema, default <code class=\"inline\">:child</code> </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#on_repo_change/4\">on_repo_change(map, , , )</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Ecto.Association.on_repo_change/4</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"on_repo_change/4\">  <span class=\"signature\">on_repo_change(map, , , )</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Ecto.Association.on_repo_change/4</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Association.HasThrough.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Association.HasThrough.html</a>\n  </p>\n</div>\n","ecto/ecto.association.notloaded":"<h1>  Ecto.Association.NotLoaded  </h1>  <p>Struct returned by one to one associations when they are not loaded.</p> <p>The fields are:</p> <ul> <li>\n<code class=\"inline\">__field__</code> - the association field in <code class=\"inline\">owner</code> </li> <li>\n<code class=\"inline\">__owner__</code> - the schema that owns the association </li> <li>\n<code class=\"inline\">__cardinality__</code> - the cardinality of the association </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Association.NotLoaded.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Association.NotLoaded.html</a>\n  </p>\n</div>\n","ecto/ecto.date":"<h1>  Ecto.Date  </h1>  <p>An Ecto type for dates.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#cast/1\">cast(d)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Casts the given value to date</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cast!/1\">cast!(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#cast/1\"><code class=\"inline\">cast/1</code></a> but raises <a href=\"ecto.casterror\"><code class=\"inline\">Ecto.CastError</code></a> on invalid dates</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compare/2\">compare(t1, t2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compare two dates</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dump/1\">dump(arg1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a> into a date triplet</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_erl/1\">from_erl(arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a> from an Erlang date tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#load/1\">load(arg1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a date triplet into an <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_erl/1\">to_erl(date)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an Erlang date tuple from an <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_iso8601/1\">to_iso8601(date)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a> to ISO8601 representation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(date)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a> to a readable string representation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#type/0\">type()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The Ecto primitive type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#utc/0\">utc()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a> in UTC</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"cast/1\">  <span class=\"signature\">cast(d)</span>  </h3>  <p>Casts the given value to date.</p> <p>It supports:</p> <ul> <li>a binary in the “YYYY-MM-DD” format </li> <li>a binary in the “YYYY-MM-DD HH:MM:SS” format (may be separated by T and/or followed by “Z”, as in <code class=\"inline\">2014-04-17T14:00:00Z</code>) </li> <li>a binary in the “YYYY-MM-DD HH:MM:SS.USEC” format (may be separated by T and/or followed by “Z”, as in <code class=\"inline\">2014-04-17T14:00:00.030Z</code>) </li> <li>a map with <code class=\"inline\">\"year\"</code>, <code class=\"inline\">\"month\"</code> and <code class=\"inline\">\"day\"</code> keys with integer or binaries as values </li> <li>a map with <code class=\"inline\">:year</code>, <code class=\"inline\">:month</code> and <code class=\"inline\">:day</code> keys with integer or binaries as values </li> <li>a tuple with <code class=\"inline\">{year, month, day}</code> as integers or binaries </li> <li>an <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a> struct itself </li> </ul>    <h3 class=\"detail-header function\" id=\"cast!/1\">  <span class=\"signature\">cast!(value)</span>  </h3>  <p>Same as <a href=\"#cast/1\"><code class=\"inline\">cast/1</code></a> but raises <a href=\"ecto.casterror\"><code class=\"inline\">Ecto.CastError</code></a> on invalid dates.</p>    <h3 class=\"detail-header function\" id=\"compare/2\">  <span class=\"signature\">compare(t1, t2)</span>  </h3>  <p>Compare two dates.</p> <p>Receives two dates and compares the <code class=\"inline\">t1</code> against <code class=\"inline\">t2</code> and returns <code class=\"inline\">:lt</code>, <code class=\"inline\">:eq</code> or <code class=\"inline\">:gt</code>.</p>    <h3 class=\"detail-header function\" id=\"dump/1\">  <span class=\"signature\">dump(arg1)</span>  </h3>  <p>Converts an <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a> into a date triplet.</p>    <h3 class=\"detail-header function\" id=\"from_erl/1\">  <span class=\"signature\">from_erl(arg)</span>  </h3>  <p>Returns an <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a> from an Erlang date tuple.</p>    <h3 class=\"detail-header function\" id=\"load/1\">  <span class=\"signature\">load(arg1)</span>  </h3>  <p>Converts a date triplet into an <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a>.</p>    <h3 class=\"detail-header function\" id=\"to_erl/1\">  <span class=\"signature\">to_erl(date)</span>  </h3>  <p>Returns an Erlang date tuple from an <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a>.</p>    <h3 class=\"detail-header function\" id=\"to_iso8601/1\">  <span class=\"signature\">to_iso8601(date)</span>  </h3>  <p>Converts <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a> to ISO8601 representation.</p>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(date)</span>  </h3>  <p>Converts <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a> to a readable string representation.</p>    <h3 class=\"detail-header function\" id=\"type/0\">  <span class=\"signature\">type()</span>  </h3>  <p>The Ecto primitive type.</p>    <h3 class=\"detail-header function\" id=\"utc/0\">  <span class=\"signature\">utc()</span>  </h3>  <p>Returns an <a href=\"ecto.date#content\"><code class=\"inline\">Ecto.Date</code></a> in UTC.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Date.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Date.html</a>\n  </p>\n</div>\n","phoenix/phoenix.view":"<h1>  Phoenix.View  </h1>  <p>Defines the view layer of a Phoenix application.</p> <p>This module is used to define the application main view, which serves as the base for all other views and templates in the application.</p> <p>The view layer also contains conveniences for rendering templates, including support for layouts and encoders per format.</p> <h2>Examples</h2> <p>Phoenix defines the view template at <code class=\"inline\">web/web.ex</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule YourApp.Web do\n  def view do\n    quote do\n      use Phoenix.View, root: \"web/templates\"\n\n      # Import common functionality\n      import YourApp.Router.Helpers\n\n      # Use Phoenix.HTML to import all HTML functions (forms, tags, etc)\n      use Phoenix.HTML\n    end\n  end\n\n  # ...\nend</code></pre> <p>We can use the definition above to define any view in your application:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule YourApp.UserView do\n  use YourApp.Web, :view\nend</code></pre> <p>Because we have defined the template root to be “web/templates”, <a href=\"phoenix.view#content\"><code class=\"inline\">Phoenix.View</code></a> will automatically load all templates at “web/templates/user” and include them in the <code class=\"inline\">YourApp.UserView</code>. For example, imagine we have the template:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># web/templates/user/index.html.eex\nHello &lt;%= @name %&gt;</code></pre> <p>The <code class=\"inline\">.eex</code> extension is called a template engine which tells Phoenix how to compile the code in the file into actual Elixir source code. After it is compiled, the template can be rendered as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Phoenix.View.render(YourApp.UserView, \"index.html\", name: \"John Doe\")\n#=&gt; {:safe, \"Hello John Doe\"}</code></pre> <p>We will discuss rendering in detail next.</p> <h2>Rendering</h2> <p>The main responsibility of a view is to render a template.</p> <p>A template has a name, which also contains a format. For example, in the previous section we have rendered the “index.html” template:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Phoenix.View.render(YourApp.UserView, \"index.html\", name: \"John Doe\")\n#=&gt; {:safe, \"Hello John Doe\"}</code></pre> <p>When a view renders a template, the result returned is an inner representation specific to the template format. In the example above, we got: <code class=\"inline\">{:safe, \"Hello John Doe\"}</code>. The safe tuple annotates that our template is safe and that we don’t need to escape its contents because all data was already encoded so far. Let’s try to inject custom code:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Phoenix.View.render(YourApp.UserView, \"index.html\", name: \"John&lt;br /&gt;Doe\")\n#=&gt; {:safe, \"Hello John&amp;lt;br /&amp;gt;Doe\"}</code></pre> <p>This inner representation allows us to render and compose templates easily. For example, if you want to render JSON data, we could do so by adding a “show.json” entry to <code class=\"inline\">render/2</code> in our view:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule YourApp.UserView do\n  use YourApp.View\n\n  def render(\"show.json\", %{user: user}) do\n    %{name: user.name, address: user.address}\n  end\nend</code></pre> <p>Notice that in order to render JSON data, we don’t need to explicitly return a JSON string! Instead, we just return data that is encodable to JSON.</p> <p>Both JSON and HTML formats will be encoded only when passing the data to the controller via the <a href=\"#render_to_iodata/3\"><code class=\"inline\">render_to_iodata/3</code></a> function. The <a href=\"#render_to_iodata/3\"><code class=\"inline\">render_to_iodata/3</code></a> uses the notion of format encoders to convert a particular format to its string/iodata representation.</p> <p>Phoenix ships with some template engines and format encoders, which can be further configured in the Phoenix application. You can read more about format encoders in <a href=\"phoenix.template\"><code class=\"inline\">Phoenix.Template</code></a> documentation.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#render/3\">render(module, template, assigns)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Renders a template</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#render_existing/3\">render_existing(module, template, assigns \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Renders a template only if it exists</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#render_many/4\">render_many(collection, view, template, assigns \\\\ %{})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Renders a collection</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#render_one/4\">render_one(model, view, template, assigns \\\\ %{})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Renders a single item if not nil</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#render_to_iodata/3\">render_to_iodata(module, template, assign)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Renders the template and returns iodata</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#render_to_string/3\">render_to_string(module, template, assign)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Renders the template and returns a string</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#__using__/1\">__using__(opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>When used, defines the current module as a main view module</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"render/3\">  <span class=\"signature\">render(module, template, assigns)</span>  </h3>  <p>Renders a template.</p> <p>It expects the view module, the template as a string, and a set of assigns.</p> <p>Notice this function returns the inner representation of a template. If you want the encoded template as a result, use <a href=\"#render_to_iodata/3\"><code class=\"inline\">render_to_iodata/3</code></a> instead.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Phoenix.View.render(YourApp.UserView, \"index.html\", name: \"John Doe\")\n#=&gt; {:safe, \"Hello John Doe\"}</code></pre> <h4>Assigns</h4> <p>Assigns are meant to be user data that will be available in templates. However there are keys under assigns that are specially handled by Phoenix, they are:</p> <ul> <li>\n<code class=\"inline\">:layout</code> - tells Phoenix to wrap the rendered result in the given layout. See next section. </li> </ul> <p>The following assigns are reserved, and cannot be set directly:</p> <ul> <li>\n<code class=\"inline\">@view_module</code> - The view module being rendered </li> <li>\n<code class=\"inline\">@view_template</code> - The <code class=\"inline\">@view_module</code>’s template being rendered </li> </ul> <h4>Layouts</h4> <p>Templates can be rendered within other templates using the <code class=\"inline\">:layout</code> option. <code class=\"inline\">:layout</code> accepts a tuple of the form <code class=\"inline\">{LayoutModule, \"template.extension\"}</code>.</p> <p>To render the template within the layout, simply call <a href=\"#render/3\"><code class=\"inline\">render/3</code></a> using the <code class=\"inline\">@view_module</code> and <code class=\"inline\">@view_template</code> assign:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= render @view_module, @view_template, assigns %&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"render_existing/3\">  <span class=\"signature\">render_existing(module, template, assigns \\\\ [])</span>  </h3>  <p>Renders a template only if it exists.</p> <p>Same as <a href=\"#render/3\"><code class=\"inline\">render/3</code></a>, but returns <code class=\"inline\">nil</code> instead of raising. Useful for dynamically rendering templates in the layout that may or may not be implemented by the <code class=\"inline\">@view_module</code> view.</p> <h4>Examples</h4> <p>Consider the case where the application layout allows views to dynamically render a section of script tags in the head of the document. Some views may wish to inject certain scripts, while others will not.</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;head&gt;\n  &lt;%= render_existing @view_module, \"scripts.html\", assigns %&gt;\n&lt;/head&gt;</code></pre> <p>Then the module for the <code class=\"inline\">@view_module</code> view can decide to provide scripts with either a precompiled template, or by implementing the function directly, ie:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def render(\"scripts.html\", _assigns) do\n  ~E(&lt;script src=\"file.js\"&gt;&lt;/script&gt;)\nend</code></pre> <p>To use a precompiled template, create a <code class=\"inline\">scripts.html.eex</code> file in the <code class=\"inline\">templates</code> directory for the corresponding view you want it to render for. For example, for the <code class=\"inline\">UserView</code>, create the <code class=\"inline\">scripts.html.eex</code> file at <code class=\"inline\">web/templates/user/</code>.</p> <h4>Rendering based on controller template</h4> <p>In some cases, you might need to render based on the template. For these cases, <code class=\"inline\">@view_template</code> can pair with <a href=\"#render_existing/3\"><code class=\"inline\">render_existing/3</code></a> for per-template based content, ie:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;head&gt;\n  &lt;%= render_existing @view_module, \"scripts.\" &lt;&gt; @view_template, assigns %&gt;\n&lt;/head&gt;\n\ndef render(\"scripts.show.html\", _assigns) do\n  ~E(&lt;script src=\"file.js\"&gt;&lt;/script&gt;)\nend\ndef render(\"scripts.index.html\", _assigns) do\n  ~E(&lt;script src=\"file.js\"&gt;&lt;/script&gt;)\nend</code></pre>    <h3 class=\"detail-header function\" id=\"render_many/4\">  <span class=\"signature\">render_many(collection, view, template, assigns \\\\ %{})</span>  </h3>  <p>Renders a collection.</p> <p>A collection is any enumerable of structs. This function returns the rendered collection in a list:</p> <pre data-language=\"elixir\"><code class=\"elixir\">render_many users, UserView, \"show.html\"</code></pre> <p>is roughly equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Enum.map(users, fn user -&gt;\n  render(UserView, \"show.html\", user: user)\nend)</code></pre> <p>The underlying user is passed to the view and template as <code class=\"inline\">:user</code>, which is inferred from the view name. The name of the key in assigns can be customized with the <code class=\"inline\">:as</code> option:</p> <pre data-language=\"elixir\"><code class=\"elixir\">render_many users, UserView, \"show.html\", as: :data</code></pre> <p>is roughly equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Enum.map(users, fn user -&gt;\n  render(UserView, \"show.html\", data: user)\nend)</code></pre>    <h3 class=\"detail-header function\" id=\"render_one/4\">  <span class=\"signature\">render_one(model, view, template, assigns \\\\ %{})</span>  </h3>  <p>Renders a single item if not nil.</p> <p>The following:</p> <pre data-language=\"elixir\"><code class=\"elixir\">render_one user, UserView, \"show.html\"</code></pre> <p>is roughly equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">if user != nil do\n  render(UserView, \"show.html\", user: user)\nend</code></pre> <p>The underlying user is passed to the view and template as <code class=\"inline\">:user</code>, which is inflected from the view name. The name of the key in assigns can be customized with the <code class=\"inline\">:as</code> option:</p> <pre data-language=\"elixir\"><code class=\"elixir\">render_one user, UserView, \"show.html\", as: :data</code></pre> <p>is roughly equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">if user != nil do\n  render(UserView, \"show.html\", data: user)\nend</code></pre>    <h3 class=\"detail-header function\" id=\"render_to_iodata/3\">  <span class=\"signature\">render_to_iodata(module, template, assign)</span>  </h3>  <p>Renders the template and returns iodata.</p>    <h3 class=\"detail-header function\" id=\"render_to_string/3\">  <span class=\"signature\">render_to_string(module, template, assign)</span>  </h3>  <p>Renders the template and returns a string.</p>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"__using__/1\">  <span class=\"signature\">__using__(opts)</span>  </h3>  <p>When used, defines the current module as a main view module.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:root</code> - the template root to find templates </li> <li>\n<code class=\"inline\">:path</code> - the optional path to search for templates within the <code class=\"inline\">:root</code>. Defaults to the underscored view module name. A blank string may be provided to use the <code class=\"inline\">:root</code> path directly as the template lookup path. </li> <li>\n<code class=\"inline\">:namespace</code> - the namespace to consider when calculating view paths </li> <li>\n<code class=\"inline\">:pattern</code> - the wildcard pattern to apply to the root when finding templates. Default <code class=\"inline\">\"*\"</code> </li> </ul> <p>The <code class=\"inline\">:root</code> option is required while the <code class=\"inline\">:namespace</code> defaults to the first nesting in the module name. For instance, both <code class=\"inline\">MyApp.UserView</code> and <code class=\"inline\">MyApp.Admin.UserView</code> have namespace <code class=\"inline\">MyApp</code>.</p> <p>The <code class=\"inline\">:namespace</code> and <code class=\"inline\">:path</code> options are used to calculate template lookup paths. For example, if you are in <code class=\"inline\">MyApp.UserView</code> and the namespace is <code class=\"inline\">MyApp</code>, templates are expected at <code class=\"inline\">Path.join(root, \"user\")</code>. On the other hand, if the view is <code class=\"inline\">MyApp.Admin.UserView</code>, the path will be <code class=\"inline\">Path.join(root, \"admin/user\")</code> and so on. For explicit root path locations, the <code class=\"inline\">:path</code> option can instead be provided. The <code class=\"inline\">:root</code> and <code class=\"inline\">:path</code> are joined to form the final lookup path. A blank string may be provided to use the <code class=\"inline\">:root</code> path direclty as the template lookup path.</p> <p>Setting the namespace to <code class=\"inline\">MyApp.Admin</code> in the second example will force the template to also be looked up at <code class=\"inline\">Path.join(root, \"user\")</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix/Phoenix.View.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix/Phoenix.View.html</a>\n  </p>\n</div>\n","ecto/ecto.adapters.sql":"<h1>  Ecto.Adapters.SQL  </h1>  <p>Behaviour and implementation for SQL adapters.</p> <p>The implementation for SQL adapter relies on <code class=\"inline\">DBConnection</code> to provide pooling, prepare, execute and more.</p> <p>Developers that use <a href=\"ecto.adapters.sql#content\"><code class=\"inline\">Ecto.Adapters.SQL</code></a> should implement the callbacks required both by this module and the ones from <code class=\"inline\">Ecto.Adapters.SQL.Query</code> about building queries.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#query/4\">query(repo, sql, params \\\\ [], opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Runs custom SQL query on given repo</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#query!/4\">query!(repo, sql, params \\\\ [], opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#query/4\"><code class=\"inline\">query/4</code></a> but raises on invalid queries</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_sql/3\">to_sql(kind, repo, queryable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given query to SQL according to its kind and the adapter in the given repository</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"query/4\">  <span class=\"signature\">query(repo, sql, params \\\\ [], opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">query(<a href=\"ecto.repo#t:t/0\">Ecto.Repo.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, [term], <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, %{rows: nil | [tuple], num_rows: non_neg_integer}} |\n  {:error, <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>}</code></pre>    <p>Runs custom SQL query on given repo.</p> <p>In case of success, it must return an <code class=\"inline\">:ok</code> tuple containing a map with at least two keys:</p> <ul> <li>\n<p><code class=\"inline\">:num_rows</code> - the number of rows affected</p> </li> <li>\n<code class=\"inline\">:rows</code> - the result set as a list. <code class=\"inline\">nil</code> may be returned instead of the list if the command does not yield any row as result (but still yields the number of affected rows, like a <code class=\"inline\">delete</code> command without returning would) </li> </ul> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:timeout</code> - The time in milliseconds to wait for a query to finish, <code class=\"inline\">:infinity</code> will wait indefinitely. (default: 15_000) </li> <li>\n<p><code class=\"inline\">:pool_timeout</code> - The time in milliseconds to wait for a call to the pool to finish, <code class=\"inline\">:infinity</code> will wait indefinitely. (default: 5_000)</p> </li> <li>\n<code class=\"inline\">:log</code> - When false, does not log the query </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Ecto.Adapters.SQL.query(MyRepo, \"SELECT $1::integer + $2\", [40, 2])\n{:ok, %{rows: [{42}], num_rows: 1}}</code></pre>    <h3 class=\"detail-header function\" id=\"query!/4\">  <span class=\"signature\">query!(repo, sql, params \\\\ [], opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">query!(<a href=\"ecto.repo#t:t/0\">Ecto.Repo.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, [term], <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  %{rows: nil | [tuple], num_rows: non_neg_integer} |\n  no_return</code></pre>    <p>Same as <a href=\"#query/4\"><code class=\"inline\">query/4</code></a> but raises on invalid queries.</p>    <h3 class=\"detail-header function\" id=\"to_sql/3\">  <span class=\"signature\">to_sql(kind, repo, queryable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_sql(:all | :update_all | :delete_all, <a href=\"ecto.repo#t:t/0\">Ecto.Repo.t</a>, <a href=\"ecto.queryable#t:t/0\">Ecto.Queryable.t</a>) :: {<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, [term]}</code></pre>    <p>Converts the given query to SQL according to its kind and the adapter in the given repository.</p> <h4>Examples</h4> <p>The examples below are meant for reference. Each adapter will return a different result:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Ecto.Adapters.SQL.to_sql(:all, repo, Post)\n{\"SELECT p.id, p.title, p.inserted_at, p.created_at FROM posts as p\", []}\n\nEcto.Adapters.SQL.to_sql(:update_all, repo,\n                        from(p in Post, update: [set: [title: ^\"hello\"]]))\n{\"UPDATE posts AS p SET title = $1\", [\"hello\"]}</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Adapters.SQL.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Adapters.SQL.html</a>\n  </p>\n</div>\n","ecto/ecto.datetime":"<h1>  Ecto.DateTime  </h1>  <p>An Ecto type that includes a date and a time.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#cast/1\">cast(dt)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Casts the given value to datetime</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cast!/1\">cast!(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#cast/1\"><code class=\"inline\">cast/1</code></a> but raises <a href=\"ecto.casterror\"><code class=\"inline\">Ecto.CastError</code></a> on invalid datetimes</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compare/2\">compare(t1, t2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compare two datetimes</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dump/1\">dump(arg1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> into a <code class=\"inline\">{date, time}</code> tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_date/1\">from_date(date)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given <a href=\"ecto.date\"><code class=\"inline\">Ecto.Date</code></a> into <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> with the time being 00:00:00</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_date_and_time/2\">from_date_and_time(date, time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given <a href=\"ecto.date\"><code class=\"inline\">Ecto.Date</code></a> and <a href=\"ecto.time\"><code class=\"inline\">Ecto.Time</code></a> into <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_erl/1\">from_erl(arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> from an Erlang datetime tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#load/1\">load(datetime)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a <code class=\"inline\">{date, time}</code> tuple into an <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_date/1\">to_date(date_time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> into an <a href=\"ecto.date\"><code class=\"inline\">Ecto.Date</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_erl/1\">to_erl(date_time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an Erlang datetime tuple from an <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_iso8601/1\">to_iso8601(date_time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> to its ISO 8601 representation without timezone specification</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(date_time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> to its string representation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_time/1\">to_time(date_time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> into an <a href=\"ecto.time\"><code class=\"inline\">Ecto.Time</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#type/0\">type()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The Ecto primitive type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#utc/1\">utc(precision \\\\ :sec)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> in UTC</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"cast/1\">  <span class=\"signature\">cast(dt)</span>  </h3>  <p>Casts the given value to datetime.</p> <p>It supports:</p> <ul> <li>a binary in the “YYYY-MM-DD HH:MM:SS” format (may be separated by T and/or followed by “Z”, as in <code class=\"inline\">2014-04-17T14:00:00Z</code>) </li> <li>a binary in the “YYYY-MM-DD HH:MM:SS.USEC” format (may be separated by T and/or followed by “Z”, as in <code class=\"inline\">2014-04-17T14:00:00.030Z</code>) </li> <li>a map with <code class=\"inline\">\"year\"</code>, <code class=\"inline\">\"month\"</code>,<code class=\"inline\">\"day\"</code>, <code class=\"inline\">\"hour\"</code>, <code class=\"inline\">\"minute\"</code> keys with <code class=\"inline\">\"second\"</code> and <code class=\"inline\">\"microsecond\"</code> as optional keys and values are integers or binaries </li> <li>a map with <code class=\"inline\">:year</code>, <code class=\"inline\">:month</code>,<code class=\"inline\">:day</code>, <code class=\"inline\">:hour</code>, <code class=\"inline\">:minute</code> keys with <code class=\"inline\">:second</code> and <code class=\"inline\">:microsecond</code> as optional keys and values are integers or binaries </li> <li>a tuple with <code class=\"inline\">{{year, month, day}, {hour, min, sec}}</code> as integers or binaries </li> <li>a tuple with <code class=\"inline\">{{year, month, day}, {hour, min, sec, usec}}</code> as integers or binaries </li> <li>an <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> struct itself </li> </ul>    <h3 class=\"detail-header function\" id=\"cast!/1\">  <span class=\"signature\">cast!(value)</span>  </h3>  <p>Same as <a href=\"#cast/1\"><code class=\"inline\">cast/1</code></a> but raises <a href=\"ecto.casterror\"><code class=\"inline\">Ecto.CastError</code></a> on invalid datetimes.</p>    <h3 class=\"detail-header function\" id=\"compare/2\">  <span class=\"signature\">compare(t1, t2)</span>  </h3>  <p>Compare two datetimes.</p> <p>Receives two datetimes and compares the <code class=\"inline\">t1</code> against <code class=\"inline\">t2</code> and returns <code class=\"inline\">:lt</code>, <code class=\"inline\">:eq</code> or <code class=\"inline\">:gt</code>.</p>    <h3 class=\"detail-header function\" id=\"dump/1\">  <span class=\"signature\">dump(arg1)</span>  </h3>  <p>Converts an <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> into a <code class=\"inline\">{date, time}</code> tuple.</p>    <h3 class=\"detail-header function\" id=\"from_date/1\">  <span class=\"signature\">from_date(date)</span>  </h3>  <p>Converts the given <a href=\"ecto.date\"><code class=\"inline\">Ecto.Date</code></a> into <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> with the time being 00:00:00.</p>    <h3 class=\"detail-header function\" id=\"from_date_and_time/2\">  <span class=\"signature\">from_date_and_time(date, time)</span>  </h3>  <p>Converts the given <a href=\"ecto.date\"><code class=\"inline\">Ecto.Date</code></a> and <a href=\"ecto.time\"><code class=\"inline\">Ecto.Time</code></a> into <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a>.</p>    <h3 class=\"detail-header function\" id=\"from_erl/1\">  <span class=\"signature\">from_erl(arg)</span>  </h3>  <p>Returns an <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> from an Erlang datetime tuple.</p>    <h3 class=\"detail-header function\" id=\"load/1\">  <span class=\"signature\">load(datetime)</span>  </h3>  <p>Converts a <code class=\"inline\">{date, time}</code> tuple into an <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a>.</p>    <h3 class=\"detail-header function\" id=\"to_date/1\">  <span class=\"signature\">to_date(date_time)</span>  </h3>  <p>Converts <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> into an <a href=\"ecto.date\"><code class=\"inline\">Ecto.Date</code></a>.</p>    <h3 class=\"detail-header function\" id=\"to_erl/1\">  <span class=\"signature\">to_erl(date_time)</span>  </h3>  <p>Returns an Erlang datetime tuple from an <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a>.</p>    <h3 class=\"detail-header function\" id=\"to_iso8601/1\">  <span class=\"signature\">to_iso8601(date_time)</span>  </h3>  <p>Converts <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> to its ISO 8601 representation without timezone specification.</p>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(date_time)</span>  </h3>  <p>Converts <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> to its string representation.</p>    <h3 class=\"detail-header function\" id=\"to_time/1\">  <span class=\"signature\">to_time(date_time)</span>  </h3>  <p>Converts <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> into an <a href=\"ecto.time\"><code class=\"inline\">Ecto.Time</code></a>.</p>    <h3 class=\"detail-header function\" id=\"type/0\">  <span class=\"signature\">type()</span>  </h3>  <p>The Ecto primitive type.</p>    <h3 class=\"detail-header function\" id=\"utc/1\">  <span class=\"signature\">utc(precision \\\\ :sec)</span>  </h3>  <p>Returns an <a href=\"ecto.datetime#content\"><code class=\"inline\">Ecto.DateTime</code></a> in UTC.</p> <p><code class=\"inline\">precision</code> can be <code class=\"inline\">:sec</code> or <code class=\"inline\">:usec</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.DateTime.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.DateTime.html</a>\n  </p>\n</div>\n","ecto/ecto.migration.constraint":"<h1>  Ecto.Migration.Constraint  </h1>  <p>Used internally by adapters.</p> <p>To define a constraint in a migration, see <a href=\"ecto.migration#constraint/3\"><code class=\"inline\">Ecto.Migration.constraint/3</code></a></p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Ecto.Migration.Constraint{check: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a> | nil, comment: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a> | nil, exclude: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a> | nil, name: atom, prefix: atom | nil, table: atom}</code></pre> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Migration.Constraint.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Migration.Constraint.html</a>\n  </p>\n</div>\n","ecto/ecto.migration.index":"<h1>  Ecto.Migration.Index  </h1>  <p>Used internally by adapters.</p> <p>To define an index in a migration, see <a href=\"ecto.migration#index/3\"><code class=\"inline\">Ecto.Migration.index/3</code></a></p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Ecto.Migration.Index{columns: [atom | <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>], comment: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a> | nil, concurrently: boolean, name: atom, prefix: atom, table: atom, unique: boolean, using: atom | <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, where: atom | <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>}</code></pre> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Migration.Index.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Migration.Index.html</a>\n  </p>\n</div>\n","ecto/ecto.migration.reference":"<h1>  Ecto.Migration.Reference  </h1>  <p>Used internally by adapters.</p> <p>To define a reference in a migration, see <a href=\"ecto.migration#references/2\"><code class=\"inline\">Ecto.Migration.references/2</code></a></p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Ecto.Migration.Reference{column: atom, name: term, on_delete: atom, on_update: atom, table: atom, type: atom}</code></pre> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Migration.Reference.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Migration.Reference.html</a>\n  </p>\n</div>\n","ecto/ecto.model":"<h1>  Ecto.Model  </h1>  <p>Warning: this module is currently deprecated. Instead <code class=\"inline\">use Ecto.Schema</code> and the functions in the <a href=\"ecto\"><code class=\"inline\">Ecto</code></a> module.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %atom{}</code></pre> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Model.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Model.html</a>\n  </p>\n</div>\n","ecto/ecto.migration.table":"<h1>  Ecto.Migration.Table  </h1>  <p>Used internally by adapters.</p> <p>To define a table in a migration, see <a href=\"ecto.migration#table/2\"><code class=\"inline\">Ecto.Migration.table/2</code></a></p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Ecto.Migration.Table{comment: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a> | nil, engine: atom, name: atom, options: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, prefix: atom | nil, primary_key: boolean}</code></pre> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Migration.Table.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Migration.Table.html</a>\n  </p>\n</div>\n","ecto/ecto.logentry":"<h1>  Ecto.LogEntry  </h1>  <p>Struct used for logging entries.</p> <p>It is composed of the following fields:</p> <ul> <li>query - the query as string or a function that when invoked resolves to string; </li> <li>params - the query parameters; </li> <li>result - the query result as an <code class=\"inline\">:ok</code> or <code class=\"inline\">:error</code> tuple; </li> <li>query_time - the time spent executing the query in native units; </li> <li>decode_time - the time spent decoding the result in native units (it may be nil); </li> <li>queue_time - the time spent to check the connection out in native units (it may be nil); </li> <li>connection_pid - the connection process that executed the query; </li> </ul> <p>Notice all times are stored in native unit. You must convert them to the proper unit by using <code class=\"inline\">System.convert_time_unit/3</code> before logging.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#log/1\">log(entry)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Logs the given entry in debug mode</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#log/2\">log(entry, level)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Logs the given entry in the given level</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_iodata/1\">to_iodata(entry)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a log entry into iodata</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Ecto.LogEntry{connection_pid: pid | nil, decode_time: integer | nil, params: [term], query: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a> | (<a href=\"#t:t/0\">t</a> -&gt; <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>), query_time: integer, queue_time: integer | nil, result: {:ok, term} | {:error, <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>}}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"log/1\">  <span class=\"signature\">log(entry)</span>  </h3>  <p>Logs the given entry in debug mode.</p> <p>The logger call will be removed at compile time if <code class=\"inline\">compile_time_purge_level</code> is set to higher than debug.</p>    <h3 class=\"detail-header function\" id=\"log/2\">  <span class=\"signature\">log(entry, level)</span>  </h3>  <p>Logs the given entry in the given level.</p> <p>The logger call won’t be removed at compile time as custom level is given.</p>    <h3 class=\"detail-header function\" id=\"to_iodata/1\">  <span class=\"signature\">to_iodata(entry)</span>  </h3>  <p>Converts a log entry into iodata.</p> <p>The entry is automatically resolved if it hasn’t been yet.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.LogEntry.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.LogEntry.html</a>\n  </p>\n</div>\n","ecto/ecto.adapters.sql.connection":"<h1>  Ecto.Adapters.SQL.Connection <small>behaviour</small>  </h1>  <p>Specifies the behaviour to be implemented by all SQL connections.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:cached/0\">cached()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The cache query which is a DBConnection Query</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:prepared/0\">prepared()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The prepared query which is an SQL command</p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:all/1\">all(query)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a query and must return a SELECT query</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:child_spec/1\">child_spec(options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives options and returns <code class=\"inline\">DBConnection</code> supervisor child specification</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:delete/4\">delete(prefix, table, filters, returning)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a DELETE for the <code class=\"inline\">filters</code> returning the given <code class=\"inline\">returning</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:delete_all/1\">delete_all(query)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a query and must return a DELETE query</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:execute/4\">execute(connection, prepared_query, params, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Executes the given prepared query with <code class=\"inline\">DBConnection</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:execute_ddl/1\">execute_ddl(command)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a DDL command and returns a query that executes it</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:insert/5\">insert(prefix, table, header, rows, returning)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an INSERT for the given <code class=\"inline\">rows</code> in <code class=\"inline\">table</code> returning the given <code class=\"inline\">returning</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:prepare_execute/5\">prepare_execute(connection, name, prepared, params, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prepares and executes the given query with <code class=\"inline\">DBConnection</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:to_constraints/1\">to_constraints(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives the exception returned by <code class=\"inline\">query/4</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:update/5\">update(prefix, table, fields, filters, returning)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an UPDATE for the given <code class=\"inline\">fields</code> in <code class=\"inline\">table</code> filtered by <code class=\"inline\">filters</code> returning the given <code class=\"inline\">returning</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:update_all/1\">update_all(query)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a query and values to update and must return an UPDATE query</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:cached/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:cached/0\">cached</a> :: map</code></pre> <p>The cache query which is a DBConnection Query</p>  </div> <div id=\"t:prepared/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:prepared/0\">prepared</a> :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre> <p>The prepared query which is an SQL command</p>  </div>    <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:all/1\">  <span class=\"signature\">all(query)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">all(query :: <a href=\"ecto.query#t:t/0\">Ecto.Query.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Receives a query and must return a SELECT query.</p>    <h3 class=\"detail-header callback\" id=\"c:child_spec/1\">  <span class=\"signature\">child_spec(options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">child_spec(options :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: {module, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>}</code></pre>    <p>Receives options and returns <code class=\"inline\">DBConnection</code> supervisor child specification.</p>    <h3 class=\"detail-header callback\" id=\"c:delete/4\">  <span class=\"signature\">delete(prefix, table, filters, returning)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete(prefix :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, table :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, filters :: [atom], returning :: [atom]) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Returns a DELETE for the <code class=\"inline\">filters</code> returning the given <code class=\"inline\">returning</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:delete_all/1\">  <span class=\"signature\">delete_all(query)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete_all(query :: <a href=\"ecto.query#t:t/0\">Ecto.Query.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Receives a query and must return a DELETE query.</p>    <h3 class=\"detail-header callback\" id=\"c:execute/4\">  <span class=\"signature\">execute(connection, prepared_query, params, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">execute(connection :: DBConnection.t, prepared_query :: <a href=\"#t:prepared/0\">prepared</a> | <a href=\"#t:cached/0\">cached</a>, params :: [term], options :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, term} |\n  {:error, <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>}</code></pre>    <p>Executes the given prepared query with <code class=\"inline\">DBConnection</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:execute_ddl/1\">  <span class=\"signature\">execute_ddl(command)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">execute_ddl(command :: <a href=\"ecto.adapter.migration#t:command/0\">Ecto.Adapter.Migration.command</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Receives a DDL command and returns a query that executes it.</p>    <h3 class=\"detail-header callback\" id=\"c:insert/5\">  <span class=\"signature\">insert(prefix, table, header, rows, returning)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">insert(prefix :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, table :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, header :: [atom], rows :: [[atom | nil]], returning :: [atom]) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Returns an INSERT for the given <code class=\"inline\">rows</code> in <code class=\"inline\">table</code> returning the given <code class=\"inline\">returning</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:prepare_execute/5\">  <span class=\"signature\">prepare_execute(connection, name, prepared, params, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">prepare_execute(connection :: DBConnection.t, name :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, <a href=\"#t:prepared/0\">prepared</a>, params :: [term], options :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, query :: map, term} |\n  {:error, <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>}</code></pre>    <p>Prepares and executes the given query with <code class=\"inline\">DBConnection</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:to_constraints/1\">  <span class=\"signature\">to_constraints(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_constraints(exception :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a></code></pre>    <p>Receives the exception returned by <code class=\"inline\">query/4</code>.</p> <p>The constraints are in the keyword list and must return the constraint type, like <code class=\"inline\">:unique</code>, and the constraint name as a string, for example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">[unique: \"posts_title_index\"]</code></pre> <p>Must return an empty list if the error does not come from any constraint.</p>    <h3 class=\"detail-header callback\" id=\"c:update/5\">  <span class=\"signature\">update(prefix, table, fields, filters, returning)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update(prefix :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, table :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, fields :: [atom], filters :: [atom], returning :: [atom]) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Returns an UPDATE for the given <code class=\"inline\">fields</code> in <code class=\"inline\">table</code> filtered by <code class=\"inline\">filters</code> returning the given <code class=\"inline\">returning</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:update_all/1\">  <span class=\"signature\">update_all(query)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update_all(query :: <a href=\"ecto.query#t:t/0\">Ecto.Query.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Receives a query and values to update and must return an UPDATE query.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Adapters.SQL.Connection.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Adapters.SQL.Connection.html</a>\n  </p>\n</div>\n","ecto/ecto.adapters.sql.sandbox":"<h1>  Ecto.Adapters.SQL.Sandbox  </h1>  <p>A pool for concurrent transactional tests.</p> <p>The sandbox pool is implemented on top of an ownership mechanism. When started, the pool is in automatic mode, which means the repository will automatically check connections out as with any other pool.</p> <p>The <a href=\"#mode/2\"><code class=\"inline\">mode/2</code></a> function can be used to change the pool mode to manual or shared. In both modes, the connection must be explicitly checked out before use. When explicit checkouts are made, the sandbox will wrap the connection in a transaction by default and control who has access to it. This means developers have a safe mechanism for running concurrent tests against the database.</p> <h2 id=\"module-database-support\" class=\"section-heading\">  Database support </h2> <p>While both PostgreSQL and MySQL support SQL Sandbox, only PostgreSQL supports concurrent tests while running the SQL Sandbox. Therefore, do not run concurrent tests with MySQL as you may run into deadlocks due to its transaction implementation.</p> <h2 id=\"module-example\" class=\"section-heading\">  Example </h2> <p>The first step is to configure your database to use the <a href=\"ecto.adapters.sql.sandbox#content\"><code class=\"inline\">Ecto.Adapters.SQL.Sandbox</code></a> pool. You set those options in your <code class=\"inline\">config/config.exs</code> (or preferrably <code class=\"inline\">config/test.exs</code>) if you haven’t yet:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :my_app, Repo,\n  pool: Ecto.Adapters.SQL.Sandbox</code></pre> <p>Now with the test database properly configured, you can write transactional tests:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># At the end of your test_helper.exs\n# Set the pool mode to manual for explicitly checkouts\nEcto.Adapters.SQL.Sandbox.mode(Repo, :manual)\n\ndefmodule PostTest do\n  # Once the mode is manual, tests can also be async\n  use ExUnit.Case, async: true\n\n  setup do\n    # Explicitly get a connection before each test\n    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Repo)\n  end\n\n  test \"create post\" do\n    # Use the repository as usual\n    assert %Post{} = Repo.insert!(%Post{})\n  end\nend</code></pre> <h2 id=\"module-collaborating-processes\" class=\"section-heading\">  Collaborating processes </h2> <p>The example above is straight-forward because we have only a single process using the database connection. However, sometimes a test may need to interact with multiple processes, all using the same connection so they all belong to the same transaction.</p> <p>Before we discuss solutions, let’s see what happens if we try to use a connection from a new process without explicitly checking it out first:</p> <pre data-language=\"elixir\"><code class=\"elixir\">setup do\n  # Explicitly get a connection before each test\n  :ok = Ecto.Adapters.SQL.Sandbox.checkout(Repo)\nend\n\ntest \"create two posts, one sync, another async\" do\n  task = Task.async(fn -&gt;\n    Repo.insert!(%Post{title: \"async\"})\n  end)\n  assert %Post{} = Repo.insert!(%Post{title: \"sync\"})\n  assert %Post{} = Task.await(task)\nend</code></pre> <p>The test above will fail with an error similar to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">** (RuntimeError) cannot find ownership process for #PID&lt;0.35.0&gt;</code></pre> <p>That’s because the <code class=\"inline\">setup</code> block is checking out the connection only for the test process. Once we spawn a Task, there is no connection assigned to it and it will fail.</p> <p>The sandbox module provides two ways of doing so, via allowances or by running in shared mode.</p> <h3>Allowances</h3> <p>The idea behind allowances is that you can explicitly tell a process which checked out connection it should use, allowing multiple processes to collaborate over the same connection. Let’s give it a try:</p> <pre data-language=\"elixir\"><code class=\"elixir\">test \"create two posts, one sync, another async\" do\n  parent = self()\n  task = Task.async(fn -&gt;\n    Ecto.Adapters.SQL.Sandbox.allow(Repo, parent, self())\n    Repo.insert!(%Post{title: \"async\"})\n  end)\n  assert %Post{} = Repo.insert!(%Post{title: \"sync\"})\n  assert %Post{} = Task.await(task)\nend</code></pre> <p>And that’s it, by calling <code class=\"inline\">allow/3</code>, we are explicitly assigning the parent’s connection (i.e. the test process’ connection) to the task.</p> <p>Because allowances use an explicit mechanism, their advantage is that you can still run your tests in async mode. The downside is that you need to explicitly control and allow every single process. This is not always possible. In such cases, you will want to use shared mode.</p> <h3>Shared mode</h3> <p>Shared mode allows a process to share its connection with any other process automatically, without relying on explicit allowances. Let’s change the example above to use shared mode:</p> <pre data-language=\"elixir\"><code class=\"elixir\">setup do\n  # Explicitly get a connection before each test\n  :ok = Ecto.Adapters.SQL.Sandbox.checkout(Repo)\n  # Setting the shared mode must be done only after checkout\n  Ecto.Adapters.SQL.Sandbox.mode(Repo, {:shared, self()})\nend\n\ntest \"create two posts, one sync, another async\" do\n  task = Task.async(fn -&gt;\n    Repo.insert!(%Post{title: \"async\"})\n  end)\n  assert %Post{} = Repo.insert!(%Post{title: \"sync\"})\n  assert %Post{} = Task.await(task)\nend</code></pre> <p>By calling <code class=\"inline\">mode({:shared, self()})</code>, any process that needs to talk to the database will now use the same connection as the one checked out by the test process during the <code class=\"inline\">setup</code> block.</p> <p>Make sure to always check a connection out before setting the mode to <code class=\"inline\">{:shared, self()}</code>.</p> <p>The advantage of shared mode is that by calling a single function, you will ensure all upcoming processes and operations will use that shared connection, without a need to explicitly allow them. The downside is that tests can no longer run concurrently in shared mode.</p> <h3>Summing up</h3> <p>There are two mechanisms for explicit ownerships:</p> <ul> <li>\n<p>Using allowances - requires explicit allowances via <code class=\"inline\">allow/3</code>. Tests may run concurrently.</p> </li> <li>Using shared mode - does not require explicit allowances. Tests cannot run concurrently. </li> </ul> <h2 id=\"module-faq\" class=\"section-heading\">  FAQ </h2> <p>When running the sandbox mode concurrently, developers may run into issues we explore in the upcoming sections.</p> <h3>“owner exited while client is still running”</h3> <p>In some situations, you may see error reports similar to the one below:</p> <pre data-language=\"elixir\"><code class=\"elixir\">21:57:43.910 [error] Postgrex.Protocol (#PID&lt;0.284.0&gt;) disconnected:\n    ** (DBConnection.Error) owner #PID&lt;&gt; exited while client #PID&lt;&gt; is still running</code></pre> <p>Such errors are usually followed by another error report from another process that failed while executing a database query.</p> <p>To understand the failure, we need to answer the question: who are the owner and client processes? The owner process is the one that checks out the connection, which, in the majority of cases, is the test process, the one running your tests. In other words, the error happens because the test process has finished, either because the test succeeded or because it failed, while the client process was trying to get information from the database. Since the owner process, the one that owns the connection, no longer exists, Ecto will check the connection back in and notify the client process using the connection that the connection owner is no longer available.</p> <p>This can happen in different situations. For example, imagine you query a GenServer in your test that is using a database connection:</p> <pre data-language=\"elixir\"><code class=\"elixir\">test \"gets results from GenServer\" do\n  {:ok, pid} = MyAppServer.start_link()\n  Ecto.Adapters.SQL.Sandbox.allow(Repo, self(), pid)\n  assert MyAppServer.get_my_data_fast(timeout: 1000) == [...]\nend</code></pre> <p>In the test above, we spawn the server and allow it to perform database queries using the connection owned by the test process. Since we gave a timeout of 1 second, in case the database takes longer than one second to reply, the test process will fail, due to the timeout, making the “owner down” message to be printed because the server process is still waiting on a connection reply.</p> <p>In some situations, such failures may be intermittent. Imagine that you allow a process that queries the database every half second:</p> <pre data-language=\"elixir\"><code class=\"elixir\">test \"queries periodically\" do\n  {:ok, pid} = PeriodicServer.start_link()\n  Ecto.Adapters.SQL.Sandbox.allow(Repo, self(), pid)\n  # more tests\nend</code></pre> <p>Because the server is querying the database from time to time, there is a chance that, when the test exists, the periodic process may be querying the database, regardless of test success or failure.</p> <h3>“owner timed out because it owned the connection for longer than Nms”</h3> <p>In some situations, you may see error reports similar to the one below:</p> <pre data-language=\"elixir\"><code class=\"elixir\">09:56:43.081 [error] Postgrex.Protocol (#PID&lt;&gt;) disconnected:\n    ** (DBConnection.ConnectionError) owner #PID&lt;&gt; timed out\n    because it owned the connection for longer than 15000ms</code></pre> <p>If you have a long running test, the timeout for the connection ownership may be too short. You can increase the timeout by setting the <code class=\"inline\">:ownership_timeout</code> options for your repo config:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :my_app, Repo,\n  ownership_timeout: NEW_TIMEOUT_IN_MILLISECONDS</code></pre> <p>The <code class=\"inline\">:ownership_timeout</code> option is part of <a href=\"https://hexdocs.pm/db_connection/DBConnection.Ownership.html\"><code class=\"inline\">DBConnection.Ownership</code></a> and defaults to 15000ms.</p> <h3>Database deadlocks</h3> <p>Since the sandbox relies on concurrent transactional tests, there is a chance your tests may trigger deadlocks in your database. This is specially true with MySQL, where the solutions presented here are not enough to avoid deadlocks and thefore making the use of concurrent tests with MySQL prohibited.</p> <p>However, even on databases like PostgreSQL, deadlocks can still occur. For example, consider this scenario:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Transaction 1:                Transaction 2:\nbegin\n                              begin\nupdate posts where id = 1\n                              update posts where id = 2\n                              update posts where id = 1\nupdate posts where id = 2\n                      **deadlock**</code></pre> <p>There are different ways to avoid this problem. One of them is to make sure your tests work on distinct data. Regardless of your choice between using fixtures or factories for test data, make sure you get a new set of data per test. This is specially important for data that is meant to be unique like user emails.</p> <p>For example, instead of:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def insert_user do\n  Repo.insert! %User{email: \"sample@example.com\"}\nend</code></pre> <p>prefer:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def insert_user do\n  Repo.insert! %User{email: \"sample-#{counter()}@example.com\"}\nend\n\ndefp counter do\n  System.unique_integer [:positive]\nend</code></pre> <p>Deadlocks may happen in other circumstances. If you believe you are hitting a scenario that has not been described here, please report an issue so we can improve our examples. As a last resort, you can always disable the test triggering the deadlock from running asynchronously by setting “async: false”.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#allow/4\">allow(repo, parent, allow, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Allows the <code class=\"inline\">allow</code> process to use the same connection as <code class=\"inline\">parent</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#checkin/2\">checkin(repo, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks in the connection back into the sandbox pool</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#checkout/2\">checkout(repo, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks a connection out for the given <code class=\"inline\">repo</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#mode/2\">mode(repo, mode)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets the mode for the <code class=\"inline\">repo</code> pool</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"allow/4\">  <span class=\"signature\">allow(repo, parent, allow, opts \\\\ [])</span>  </h3>  <p>Allows the <code class=\"inline\">allow</code> process to use the same connection as <code class=\"inline\">parent</code>.</p>    <h3 class=\"detail-header function\" id=\"checkin/2\">  <span class=\"signature\">checkin(repo, opts \\\\ [])</span>  </h3>  <p>Checks in the connection back into the sandbox pool.</p>    <h3 class=\"detail-header function\" id=\"checkout/2\">  <span class=\"signature\">checkout(repo, opts \\\\ [])</span>  </h3>  <p>Checks a connection out for the given <code class=\"inline\">repo</code>.</p> <p>The process calling <a href=\"#checkout/2\"><code class=\"inline\">checkout/2</code></a> will own the connection until it calls <a href=\"#checkin/2\"><code class=\"inline\">checkin/2</code></a> or until it crashes when then the connection will be automatically reclaimed by the pool.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:sandbox</code> - when true the connection is wrapped in a transaction. Defaults to true.</p> </li> <li>\n<code class=\"inline\">:isolation</code> - set the query to the given isolation level </li> </ul>    <h3 class=\"detail-header function\" id=\"mode/2\">  <span class=\"signature\">mode(repo, mode)</span>  </h3>  <p>Sets the mode for the <code class=\"inline\">repo</code> pool.</p> <p>The mode can be <code class=\"inline\">:auto</code>, <code class=\"inline\">:manual</code> or <code class=\"inline\">:shared</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Adapters.SQL.Sandbox.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Adapters.SQL.Sandbox.html</a>\n  </p>\n</div>\n","ecto/ecto.migrator":"<h1>  Ecto.Migrator  </h1>  <p>This module provides the migration API.</p> <h2 id=\"module-example\" class=\"section-heading\">  Example </h2> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.MigrationExample do\n  use Ecto.Migration\n\n  def up do\n    execute \"CREATE TABLE users(id serial PRIMARY_KEY, username text)\"\n  end\n\n  def down do\n    execute \"DROP TABLE users\"\n  end\nend\n\nEcto.Migrator.up(Repo, 20080906120000, MyApp.MigrationExample)</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#down/4\">down(repo, version, module, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Runs a down migration on the given repository</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#migrated_versions/2\">migrated_versions(repo, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets all migrated versions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#migrations/2\">migrations(repo, directory)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an array of tuples as the migration status of the given repo, without actually running any migrations</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#run/4\">run(repo, directory, direction, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Apply migrations in a directory to a repository with given strategy</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#up/4\">up(repo, version, module, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Runs an up migration on the given repository</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"down/4\">  <span class=\"signature\">down(repo, version, module, opts \\\\ [])</span>  </h3>  <p>Runs a down migration on the given repository.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:log</code> - the level to use for logging. Defaults to <code class=\"inline\">:info</code>. Can be any of <code class=\"inline\">Logger.level/0</code> values or <code class=\"inline\">false</code>. </li> </ul>    <h3 class=\"detail-header function\" id=\"migrated_versions/2\">  <span class=\"signature\">migrated_versions(repo, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">migrated_versions(<a href=\"ecto.repo#t:t/0\">Ecto.Repo.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: [integer]</code></pre>    <p>Gets all migrated versions.</p> <p>This function ensures the migration table exists if no table has been defined yet.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:log</code> - the level to use for logging. Defaults to <code class=\"inline\">:info</code>. Can be any of <code class=\"inline\">Logger.level/0</code> values or <code class=\"inline\">false</code>. </li> <li>\n<code class=\"inline\">:prefix</code> - the prefix to run the migrations on </li> </ul>    <h3 class=\"detail-header function\" id=\"migrations/2\">  <span class=\"signature\">migrations(repo, directory)</span>  </h3>  <p>Returns an array of tuples as the migration status of the given repo, without actually running any migrations.</p>    <h3 class=\"detail-header function\" id=\"run/4\">  <span class=\"signature\">run(repo, directory, direction, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">run(<a href=\"ecto.repo#t:t/0\">Ecto.Repo.t</a>, binary, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: [integer]</code></pre>    <p>Apply migrations in a directory to a repository with given strategy.</p> <p>A strategy must be given as an option.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:all</code> - runs all available if <code class=\"inline\">true</code> </li> <li>\n<code class=\"inline\">:step</code> - runs the specific number of migrations </li> <li>\n<code class=\"inline\">:to</code> - runs all until the supplied version is reached </li> <li>\n<code class=\"inline\">:log</code> - the level to use for logging. Defaults to <code class=\"inline\">:info</code>. Can be any of <code class=\"inline\">Logger.level/0</code> values or <code class=\"inline\">false</code>. </li> </ul>    <h3 class=\"detail-header function\" id=\"up/4\">  <span class=\"signature\">up(repo, version, module, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">up(<a href=\"ecto.repo#t:t/0\">Ecto.Repo.t</a>, integer, module, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  :ok |\n  :already_up |\n  no_return</code></pre>    <p>Runs an up migration on the given repository.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:log</code> - the level to use for logging. Defaults to <code class=\"inline\">:info</code>. Can be any of <code class=\"inline\">Logger.level/0</code> values or <code class=\"inline\">false</code>. </li> <li>\n<code class=\"inline\">:prefix</code> - the prefix to run the migrations on </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Migrator.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Migrator.html</a>\n  </p>\n</div>\n","ecto/ecto.schema.metadata":"<h1>  Ecto.Schema.Metadata  </h1>  <p>Stores metadata of a struct.</p> <p>The fields are:</p> <ul> <li>\n<code class=\"inline\">state</code> - the state in a struct’s lifetime, one of <code class=\"inline\">:built</code>, <code class=\"inline\">:loaded</code>, <code class=\"inline\">:deleted</code> </li> <li>\n<code class=\"inline\">source</code> - the source for the schema alongside the query prefix, defaults to <code class=\"inline\">{nil, \"source\"}</code> </li> <li>\n<code class=\"inline\">context</code> - context stored by the database </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Schema.Metadata.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Schema.Metadata.html</a>\n  </p>\n</div>\n","ecto/ecto.query.api":"<h1>  Ecto.Query.API  </h1>  <p>This module lists all functions allowed in the query API.</p> <ul> <li>Comparison operators: <code class=\"inline\">==</code>, <code class=\"inline\">!=</code>, <code class=\"inline\">&lt;=</code>, <code class=\"inline\">&gt;=</code>, <code class=\"inline\">&lt;</code>, <code class=\"inline\">&gt;</code> </li> <li>Boolean operators: <code class=\"inline\">and</code>, <code class=\"inline\">or</code>, <code class=\"inline\">not</code> </li> <li>Inclusion operator: <a href=\"#in/2\"><code class=\"inline\">in/2</code></a> </li> <li>Search functions: <a href=\"#like/2\"><code class=\"inline\">like/2</code></a> and <a href=\"#ilike/2\"><code class=\"inline\">ilike/2</code></a> </li> <li>Null check functions: <a href=\"#is_nil/1\"><code class=\"inline\">is_nil/1</code></a> </li> <li>Aggregates: <a href=\"#count/1\"><code class=\"inline\">count/1</code></a>, <a href=\"#avg/1\"><code class=\"inline\">avg/1</code></a>, <a href=\"#sum/1\"><code class=\"inline\">sum/1</code></a>, <a href=\"#min/1\"><code class=\"inline\">min/1</code></a>, <a href=\"#max/1\"><code class=\"inline\">max/1</code></a> </li> <li>Date/time intervals: <a href=\"#datetime_add/3\"><code class=\"inline\">datetime_add/3</code></a>, <a href=\"#date_add/3\"><code class=\"inline\">date_add/3</code></a>, <a href=\"#from_now/2\"><code class=\"inline\">from_now/2</code></a>, <a href=\"#ago/2\"><code class=\"inline\">ago/2</code></a> </li> <li>Inside select: <a href=\"#struct/2\"><code class=\"inline\">struct/2</code></a>, <a href=\"#map/2\"><code class=\"inline\">map/2</code></a> and literals (map, tuples, lists, etc) </li> <li>General: <a href=\"#fragment/1\"><code class=\"inline\">fragment/1</code></a>, <a href=\"#field/2\"><code class=\"inline\">field/2</code></a> and <a href=\"#type/2\"><code class=\"inline\">type/2</code></a> </li> </ul> <p>Note the functions in this module exist for documentation purposes and one should never need to invoke them directly. Furthermore, it is possible to define your own macros and use them in Ecto queries (see docs for <a href=\"#fragment/1)\"><code class=\"inline\">fragment/1</code></a>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#!=/2\">left != right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Binary <code class=\"inline\">!=</code> operation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%3C/2\">left &lt; right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Binary <code class=\"inline\">&lt;</code> operation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%3C=/2\">left &lt;= right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Binary <code class=\"inline\">&lt;=</code> operation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#==/2\">left == right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Binary <code class=\"inline\">==</code> operation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%3E/2\">left &gt; right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Binary <code class=\"inline\">&gt;</code> operation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%3E=/2\">left &gt;= right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Binary <code class=\"inline\">&gt;=</code> operation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ago/2\">ago(count, interval)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Substracts the given interval from the current time in UTC</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#and/2\">left and right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Binary <code class=\"inline\">and</code> operation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#avg/1\">avg(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calculates the average for the given entry</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#count/1\">count(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Counts the given entry</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#count/2\">count(value, atom)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Counts the distinct values in given entry</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#date_add/3\">date_add(date, count, interval)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds a given interval to a date</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#datetime_add/3\">datetime_add(datetime, count, interval)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds a given interval to a datetime</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#field/2\">field(source, field)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Allows a field to be dynamically accessed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fragment/1\">fragment(fragments)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Send fragments directly to the database</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_now/2\">from_now(count, interval)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds the given interval to the current time in UTC</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ilike/2\">ilike(string, search)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Searches for <code class=\"inline\">search</code> in <code class=\"inline\">string</code> in a case insensitive fashion</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#in/2\">left in right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the left-value is included in the right one</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_nil/1\">is_nil(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the given value is nil</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#like/2\">like(string, search)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Searches for <code class=\"inline\">search</code> in <code class=\"inline\">string</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#map/2\">map(source, fields)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Used in <code class=\"inline\">select</code> to specify which fields should be returned as a map</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#max/1\">max(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calculates the maximum for the given entry</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#min/1\">min(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calculates the minimum for the given entry</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#not/1\">not value</a> </dt> <dd class=\"summary-synopsis\">\n<p>Unary <code class=\"inline\">not</code> operation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#or/2\">left or right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Binary <code class=\"inline\">or</code> operation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#struct/2\">struct(source, fields)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Used in <code class=\"inline\">select</code> to specify which struct fields should be returned</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sum/1\">sum(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calculates the sum for the given entry</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#type/2\">type(interpolated_value, type)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Casts the given value to the given type</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"!=/2\">  <span class=\"signature\">left != right</span>  </h3>  <p>Binary <code class=\"inline\">!=</code> operation.</p>    <h3 class=\"detail-header function\" id=\"%3C/2\">  <span class=\"signature\">left &lt; right</span>  </h3>  <p>Binary <code class=\"inline\">&lt;</code> operation.</p>    <h3 class=\"detail-header function\" id=\"%3C=/2\">  <span class=\"signature\">left &lt;= right</span>  </h3>  <p>Binary <code class=\"inline\">&lt;=</code> operation.</p>    <h3 class=\"detail-header function\" id=\"==/2\">  <span class=\"signature\">left == right</span>  </h3>  <p>Binary <code class=\"inline\">==</code> operation.</p>    <h3 class=\"detail-header function\" id=\"%3E/2\">  <span class=\"signature\">left &gt; right</span>  </h3>  <p>Binary <code class=\"inline\">&gt;</code> operation.</p>    <h3 class=\"detail-header function\" id=\"%3E=/2\">  <span class=\"signature\">left &gt;= right</span>  </h3>  <p>Binary <code class=\"inline\">&gt;=</code> operation.</p>    <h3 class=\"detail-header function\" id=\"ago/2\">  <span class=\"signature\">ago(count, interval)</span>  </h3>  <p>Substracts the given interval from the current time in UTC.</p> <p>The current time in UTC is retrieved from Elixir and not from the database.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post, where: p.published_at &gt; ago(3, \"month\")</code></pre>    <h3 class=\"detail-header function\" id=\"and/2\">  <span class=\"signature\">left and right</span>  </h3>  <p>Binary <code class=\"inline\">and</code> operation.</p>    <h3 class=\"detail-header function\" id=\"avg/1\">  <span class=\"signature\">avg(value)</span>  </h3>  <p>Calculates the average for the given entry.</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Payment, select: avg(p.value)</code></pre>    <h3 class=\"detail-header function\" id=\"count/1\">  <span class=\"signature\">count(value)</span>  </h3>  <p>Counts the given entry.</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post, select: count(p.id)</code></pre>    <h3 class=\"detail-header function\" id=\"count/2\">  <span class=\"signature\">count(value, atom)</span>  </h3>  <p>Counts the distinct values in given entry.</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post, select: count(p.id, :distinct)</code></pre>    <h3 class=\"detail-header function\" id=\"date_add/3\">  <span class=\"signature\">date_add(date, count, interval)</span>  </h3>  <p>Adds a given interval to a date.</p> <p>See <a href=\"#datetime_add/3\"><code class=\"inline\">datetime_add/3</code></a> for more information.</p>    <h3 class=\"detail-header function\" id=\"datetime_add/3\">  <span class=\"signature\">datetime_add(datetime, count, interval)</span>  </h3>  <p>Adds a given interval to a datetime.</p> <p>The first argument is a <code class=\"inline\">datetime</code>, the second one is the count for the interval, which may be either positive or negative and the interval value:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Get all items published since the last month\nfrom p in Post, where: p.published_at &gt;\n                       datetime_add(^Ecto.DateTime.utc, -1, \"month\")</code></pre> <p>In the example above, we used <a href=\"#datetime_add/3\"><code class=\"inline\">datetime_add/3</code></a> to subtract one month from the current datetime and compared it with the <code class=\"inline\">p.published_at</code>. If you want to perform operations on date, <a href=\"#date_add/3\"><code class=\"inline\">date_add/3</code></a> could be used.</p> <p>The following intervals are supported: year, month, week, day, hour, minute, second, millisecond and microsecond.</p>    <h3 class=\"detail-header function\" id=\"field/2\">  <span class=\"signature\">field(source, field)</span>  </h3>  <p>Allows a field to be dynamically accessed.</p> <pre data-language=\"elixir\"><code class=\"elixir\">def at_least_four(doors_or_tires) do\n    from c in Car,\n  where: field(c, ^doors_or_tires) &gt;= 4\nend</code></pre> <p>In the example above, both <code class=\"inline\">at_least_four(:doors)</code> and <code class=\"inline\">at_least_four(:tires)</code> would be valid calls as the field is dynamically generated.</p>    <h3 class=\"detail-header function\" id=\"fragment/1\">  <span class=\"signature\">fragment(fragments)</span>  </h3>  <p>Send fragments directly to the database.</p> <p>It is not possible to represent all possible database queries using Ecto’s query syntax. When such is required, it is possible to use fragments to send any expression to the database:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def unpublished_by_title(title) do\n  from p in Post,\n    where: is_nil(p.published_at) and\n           fragment(\"lower(?)\", p.title) == ^title\nend</code></pre> <p>In the example above, we are using the lower procedure in the database to downcase the title column.</p> <p>It is very important to keep in mind that Ecto is unable to do any type casting described above when fragments are used. You can however use the <a href=\"#type/2\"><code class=\"inline\">type/2</code></a> function to give Ecto some hints:</p> <pre data-language=\"elixir\"><code class=\"elixir\">fragment(\"lower(?)\", p.title) == type(^title, :string)</code></pre> <p>Or even say the right side is of the same type as <code class=\"inline\">p.title</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">fragment(\"lower(?)\", p.title) == type(^title, p.title)</code></pre> <p>It is possible to make use of PostgreSQL’s JSON/JSONB data type with fragments, as well:</p> <pre data-language=\"elixir\"><code class=\"elixir\">fragment(\"?-&gt;&gt;? ILIKE ?\", p.map, \"key_name\", ^some_value)</code></pre> <h4>Keyword fragments</h4> <p>In order to support databases that do not have string-based queries, like MongoDB, fragments also allow keywords to be given:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post,\n    where: fragment(title: [\"$eq\": ^some_value])</code></pre> <h4>Defining custom functions using macros and fragment</h4> <p>You can add a custom Ecto query function using macros. For example to expose SQL’s coalesce function you can define this macro:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule CustomFunctions do\n  defmacro coalesce(left, right) do\n    quote do\n      fragment(\"coalesce(?, ?)\", unquote(left), unquote(right))\n    end\n  end\nend</code></pre> <p>To have coalesce/2 available, just import the module that defines it.</p> <pre data-language=\"elixir\"><code class=\"elixir\">import CustomFunctions</code></pre> <p>The only downside is that it will show up as a fragment when inspecting the Elixir query. Other than that, it should be equivalent to a built-in Ecto query function.</p>    <h3 class=\"detail-header function\" id=\"from_now/2\">  <span class=\"signature\">from_now(count, interval)</span>  </h3>  <p>Adds the given interval to the current time in UTC.</p> <p>The current time in UTC is retrieved from Elixir and not from the database.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">from a in Account, where: a.expires_at &lt; from_now(3, \"month\")</code></pre>    <h3 class=\"detail-header function\" id=\"ilike/2\">  <span class=\"signature\">ilike(string, search)</span>  </h3>  <p>Searches for <code class=\"inline\">search</code> in <code class=\"inline\">string</code> in a case insensitive fashion.</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post, where: ilike(p.body, \"Chapter%\")</code></pre> <p>Translates to the underlying SQL ILIKE query. This operation is only available on PostgreSQL.</p>    <h3 class=\"detail-header function\" id=\"in/2\">  <span class=\"signature\">left in right</span>  </h3>  <p>Checks if the left-value is included in the right one.</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post, where: p.id in [1, 2, 3]</code></pre> <p>The right side may either be a list, a literal list or even a column in the database with array type:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post, where: \"elixir\" in p.tags</code></pre>    <h3 class=\"detail-header function\" id=\"is_nil/1\">  <span class=\"signature\">is_nil(value)</span>  </h3>  <p>Checks if the given value is nil.</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post, where: is_nil(p.published_at)</code></pre>    <h3 class=\"detail-header function\" id=\"like/2\">  <span class=\"signature\">like(string, search)</span>  </h3>  <p>Searches for <code class=\"inline\">search</code> in <code class=\"inline\">string</code>.</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post, where: like(p.body, \"Chapter%\")</code></pre> <p>Translates to the underlying SQL LIKE query, therefore its behaviour is dependent on the database. In particular, PostgreSQL will do a case-sensitive operation, while the majority of other databases will be case-insensitive. For performing a case-insensitive <code class=\"inline\">like</code> in PostgreSQL, see <a href=\"#ilike/2\"><code class=\"inline\">ilike/2</code></a>.</p>    <h3 class=\"detail-header function\" id=\"map/2\">  <span class=\"signature\">map(source, fields)</span>  </h3>  <p>Used in <code class=\"inline\">select</code> to specify which fields should be returned as a map.</p> <p>For example, if you don’t need all fields to be returned or neither need a struct, you can use <a href=\"#map/2\"><code class=\"inline\">map/2</code></a> to achieve both:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post,\n  select: map(p, [:title, :body])</code></pre> <p><a href=\"#map/2\"><code class=\"inline\">map/2</code></a> can also be used to dynamically select fields:</p> <pre data-language=\"elixir\"><code class=\"elixir\">fields = [:title, :body]\nfrom p in Post, select: map(p, ^fields)</code></pre> <p><a href=\"#map/2\"><code class=\"inline\">map/2</code></a> is also useful when you want to limit the fields of different structs:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from(city in City, join: country in assoc(city, :country),\n     select: {map(city, [:country_id, :name]), map(country, [:id, :population])}</code></pre> <p>For preloads, the selected fields may be specified from the parent:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from(city in City, preload: :country,\n     select: map(city, [:country_id, :name, country: [:id, :population]]))</code></pre> <p><strong>IMPORTANT</strong>: When filtering fields for associations, you MUST include the foreign keys used in the relationship, otherwise Ecto will be unable to find associated records.</p>    <h3 class=\"detail-header function\" id=\"max/1\">  <span class=\"signature\">max(value)</span>  </h3>  <p>Calculates the maximum for the given entry.</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Payment, select: max(p.value)</code></pre>    <h3 class=\"detail-header function\" id=\"min/1\">  <span class=\"signature\">min(value)</span>  </h3>  <p>Calculates the minimum for the given entry.</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Payment, select: min(p.value)</code></pre>    <h3 class=\"detail-header function\" id=\"not/1\">  <span class=\"signature\">not value</span>  </h3>  <p>Unary <code class=\"inline\">not</code> operation.</p>    <h3 class=\"detail-header function\" id=\"or/2\">  <span class=\"signature\">left or right</span>  </h3>  <p>Binary <code class=\"inline\">or</code> operation.</p>    <h3 class=\"detail-header function\" id=\"struct/2\">  <span class=\"signature\">struct(source, fields)</span>  </h3>  <p>Used in <code class=\"inline\">select</code> to specify which struct fields should be returned.</p> <p>For example, if you don’t need all fields to be returned as part of a struct, you can filter it to include only certain fields by using <a href=\"#struct/2\"><code class=\"inline\">struct/2</code></a>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post,\n  select: struct(p, [:title, :body])</code></pre> <p><a href=\"#struct/2\"><code class=\"inline\">struct/2</code></a> can also be used to dynamically select fields:</p> <pre data-language=\"elixir\"><code class=\"elixir\">fields = [:title, :body]\nfrom p in Post, select: struct(p, ^fields)</code></pre> <p>As a convenience, <code class=\"inline\">select</code> allows developers to take fields without an explicit call to <a href=\"#struct/2\"><code class=\"inline\">struct/2</code></a>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post, select: [:title, :body]</code></pre> <p>Or even dynamically:</p> <pre data-language=\"elixir\"><code class=\"elixir\">fields = [:title, :body]\nfrom p in Post, select: ^fields</code></pre> <p>However, <a href=\"#struct/2\"><code class=\"inline\">struct/2</code></a> is still useful when you want to limit the fields of different structs:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from(city in City, join: country in assoc(city, :country),\n     select: {struct(city, [:country_id, :name]), struct(country, [:id, :population])}</code></pre> <p>For preloads, the selected fields may be specified from the parent:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from(city in City, preload: :country,\n     select: struct(city, [:country_id, :name, country: [:id, :population]]))</code></pre> <p><strong>IMPORTANT</strong>: When filtering fields for associations, you MUST include the foreign keys used in the relationship, otherwise Ecto will be unable to find associated records.</p>    <h3 class=\"detail-header function\" id=\"sum/1\">  <span class=\"signature\">sum(value)</span>  </h3>  <p>Calculates the sum for the given entry.</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Payment, select: sum(p.value)</code></pre>    <h3 class=\"detail-header function\" id=\"type/2\">  <span class=\"signature\">type(interpolated_value, type)</span>  </h3>  <p>Casts the given value to the given type.</p> <p>Most of the times, Ecto is able to proper cast interpolated values due to its type checking mechanism. In some situations though, in particular when using fragments with <a href=\"#fragment/1\"><code class=\"inline\">fragment/1</code></a>, you may want to tell Ecto you are expecting a particular type:</p> <pre data-language=\"elixir\"><code class=\"elixir\">fragment(\"lower(?)\", p.title) == type(^title, :string)</code></pre> <p>It is also possible to say the type must match the same of a column:</p> <pre data-language=\"elixir\"><code class=\"elixir\">fragment(\"lower(?)\", p.title) == type(^title, p.title)</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Query.API.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Query.API.html</a>\n  </p>\n</div>\n","ecto/ecto.repo":"<h1>  Ecto.Repo <small>behaviour</small>  </h1>  <p>Defines a repository.</p> <p>A repository maps to an underlying data store, controlled by the adapter. For example, Ecto ships with a Postgres adapter that stores data into a PostgreSQL database.</p> <p>When used, the repository expects the <code class=\"inline\">:otp_app</code> as option. The <code class=\"inline\">:otp_app</code> should point to an OTP application that has the repository configuration. For example, the repository:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Repo do\n  use Ecto.Repo, otp_app: :my_app\nend</code></pre> <p>Could be configured with:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :my_app, Repo,\n  adapter: Ecto.Adapters.Postgres,\n  database: \"ecto_simple\",\n  username: \"postgres\",\n  password: \"postgres\",\n  hostname: \"localhost\"</code></pre> <p>Most of the configuration that goes into the <code class=\"inline\">config</code> is specific to the adapter, so check <a href=\"ecto.adapters.postgres\"><code class=\"inline\">Ecto.Adapters.Postgres</code></a> documentation for more information. However, some configuration is shared across all adapters, they are:</p> <ul> <li>\n<p><code class=\"inline\">:priv</code> - the directory where to keep repository data, like migrations, schema and more. Defaults to “priv/YOUR_REPO”. It must always point to a subdirectory inside the priv directory.</p> </li> <li>\n<p><code class=\"inline\">:url</code> - an URL that specifies storage information. Read below for more information</p> </li> <li>\n<code class=\"inline\">:loggers</code> - a list of <code class=\"inline\">{mod, fun, args}</code> tuples that are invoked by adapters for logging queries and other events. The given module and function will be called with a log entry (see <a href=\"ecto.logentry.html)\"><code class=\"inline\">Ecto.LogEntry</code></a> and the given arguments. The invoked function must return the <a href=\"ecto.logentry\"><code class=\"inline\">Ecto.LogEntry</code></a> as result. The default value is: <code class=\"inline\">[{Ecto.LogEntry, :log, []}]</code>, which will call <a href=\"ecto.logentry#log/1\"><code class=\"inline\">Ecto.LogEntry.log/1</code></a> that will use Elixir’s <code class=\"inline\">Logger</code> in <code class=\"inline\">:debug</code> mode. You may pass any desired mod-fun-args triplet or <code class=\"inline\">[{Ecto.LogEntry, :log, [:info]}]</code> if you want to keep the current behaviour but use another log level. </li> </ul> <h2 id=\"module-urls\" class=\"section-heading\">  URLs </h2> <p>Repositories by default support URLs. For example, the configuration above could be rewritten to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :my_app, Repo,\n  url: \"ecto://postgres:postgres@localhost/ecto_simple\"</code></pre> <p>The schema can be of any value. The path represents the database name while options are simply merged in.</p> <p>URLs also support <code class=\"inline\">{:system, \"KEY\"}</code> to be given, telling Ecto to load the configuration from the system environment instead:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :my_app, Repo,\n  url: {:system, \"DATABASE_URL\"}</code></pre> <h2 id=\"module-shared-options\" class=\"section-heading\">  Shared options </h2> <p>Almost all of the repository operations below accept the following options:</p> <ul> <li>\n<code class=\"inline\">:timeout</code> - The time in milliseconds to wait for the query call to finish, <code class=\"inline\">:infinity</code> will wait indefinitely (default: 15000); </li> <li>\n<code class=\"inline\">:pool_timeout</code> - The time in milliseconds to wait for calls to the pool to finish, <code class=\"inline\">:infinity</code> will wait indefinitely (default: 5000); </li> <li>\n<code class=\"inline\">:log</code> - When false, does not log the query </li> </ul> <p>Such cases will be explicitly documented as well as any extra option.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:__adapter__/0\">__adapter__()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the adapter tied to the repository</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:__log__/1\">__log__(entry)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A callback invoked by adapters that logs the given action</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:aggregate/4\">aggregate(queryable, aggregate, field, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calculate the given <code class=\"inline\">aggregate</code> over the given <code class=\"inline\">field</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:all/2\">all(queryable, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches all entries from the data store matching the given query</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:config/0\">config()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the adapter configuration stored in the <code class=\"inline\">:otp_app</code> environment</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:delete/2\">delete(struct, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes a struct using its primary key</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:delete!/2\">delete!(struct, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <code class=\"inline\">delete/2</code> but returns the struct or raises if the changeset is invalid</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:delete_all/2\">delete_all(queryable, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes all entries matching the given query</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:get/3\">get(queryable, id, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches a single struct from the data store where the primary key matches the given id</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:get!/3\">get!(queryable, id, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Similar to <code class=\"inline\">get/3</code> but raises <a href=\"ecto.noresultserror\"><code class=\"inline\">Ecto.NoResultsError</code></a> if no record was found</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:get_by/3\">get_by(queryable, clauses, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches a single result from the query</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:get_by!/3\">get_by!(queryable, clauses, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Similar to <code class=\"inline\">get_by/3</code> but raises <a href=\"ecto.noresultserror\"><code class=\"inline\">Ecto.NoResultsError</code></a> if no record was found</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:in_transaction?/0\">in_transaction?()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns true if the current process is inside a transaction</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:insert/2\">insert(struct, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts a struct or a changeset</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:insert!/2\">insert!(struct, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <code class=\"inline\">insert/2</code> but returns the struct or raises if the changeset is invalid</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:insert_all/3\">insert_all(schema_or_source, entries, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts all entries into the repository</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:insert_or_update/2\">insert_or_update(changeset, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts or updates a changeset depending on whether the struct is persisted or not</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:insert_or_update!/2\">insert_or_update!(changeset, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <code class=\"inline\">insert_or_update/2</code> but returns the struct or raises if the changeset is invalid</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:one/2\">one(queryable, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches a single result from the query</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:one!/2\">one!(queryable, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Similar to <code class=\"inline\">one/2</code> but raises <a href=\"ecto.noresultserror\"><code class=\"inline\">Ecto.NoResultsError</code></a> if no record was found</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:preload/3\">preload(struct_or_structs, preloads, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Preloads all associations on the given struct or structs</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:rollback/1\">rollback(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Rolls back the current transaction</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:start_link/1\">start_link(opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts any connection pooling or supervision and return <code class=\"inline\">{:ok, pid}</code> or just <code class=\"inline\">:ok</code> if nothing needs to be done</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:stop/2\">stop(pid, timeout)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Shuts down the repository represented by the given pid</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:transaction/2\">transaction(fun_or_multi, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Runs the given function or <a href=\"ecto.multi\"><code class=\"inline\">Ecto.Multi</code></a> inside a transaction</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:update/2\">update(struct, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates a changeset using its primary key</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:update!/2\">update!(struct, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <code class=\"inline\">update/2</code> but returns the struct or raises if the changeset is invalid</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:update_all/3\">update_all(queryable, updates, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates all entries matching the given query with the given values</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: module</code></pre> </div>    <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:__adapter__/0\">  <span class=\"signature\">__adapter__()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">__adapter__ :: <a href=\"ecto.adapter#t:t/0\">Ecto.Adapter.t</a></code></pre>    <p>Returns the adapter tied to the repository.</p>    <h3 class=\"detail-header callback\" id=\"c:__log__/1\">  <span class=\"signature\">__log__(entry)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">__log__(entry :: <a href=\"ecto.logentry#t:t/0\">Ecto.LogEntry.t</a>) :: <a href=\"ecto.logentry#t:t/0\">Ecto.LogEntry.t</a></code></pre>    <p>A callback invoked by adapters that logs the given action.</p> <p>See <a href=\"ecto.logentry\"><code class=\"inline\">Ecto.LogEntry</code></a> for more information and <a href=\"ecto.repo#content\"><code class=\"inline\">Ecto.Repo</code></a> module documentation on setting up your own loggers.</p>    <h3 class=\"detail-header callback\" id=\"c:aggregate/4\">  <span class=\"signature\">aggregate(queryable, aggregate, field, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">aggregate(queryable :: <a href=\"ecto.queryable#t:t/0\">Ecto.Queryable.t</a>, aggregate :: :avg | :count | :max | :min | :sum, field :: atom, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  term |\n  nil</code></pre>    <p>Calculate the given <code class=\"inline\">aggregate</code> over the given <code class=\"inline\">field</code>.</p> <p>If the query has a limit, offset or distinct set, it will be automatically wrapped in a subquery in order to return the proper result.</p> <p>Any preload or select in the query will be ignored in favor of the column being aggregated.</p> <p>The aggregation will fail if any <code class=\"inline\">group_by</code> field is set.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Returns the number of visits per blog post\nRepo.aggregate(Post, :avg, :visits)\n\n# Returns the average number of visits for the top 10\nquery = from Post, limit: 10\nRepo.aggregate(query, :avg, :visits)</code></pre>    <h3 class=\"detail-header callback\" id=\"c:all/2\">  <span class=\"signature\">all(queryable, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">all(queryable :: <a href=\"ecto.query#t:t/0\">Ecto.Query.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  [<a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>] |\n  no_return</code></pre>    <p>Fetches all entries from the data store matching the given query.</p> <p>May raise <a href=\"ecto.queryerror\"><code class=\"inline\">Ecto.QueryError</code></a> if query validation fails.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Fetch all post titles\nquery = from p in Post,\n     select: p.title\nMyRepo.all(query)</code></pre>    <h3 class=\"detail-header callback\" id=\"c:config/0\">  <span class=\"signature\">config()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">config :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a></code></pre>    <p>Returns the adapter configuration stored in the <code class=\"inline\">:otp_app</code> environment.</p>    <h3 class=\"detail-header callback\" id=\"c:delete/2\">  <span class=\"signature\">delete(struct, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete(struct :: <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>} |\n  {:error, <a href=\"ecto.changeset#t:t/0\">Ecto.Changeset.t</a>}</code></pre>    <p>Deletes a struct using its primary key.</p> <p>If the struct has no primary key, <a href=\"ecto.noprimarykeyfielderror\"><code class=\"inline\">Ecto.NoPrimaryKeyFieldError</code></a> will be raised.</p> <p>It returns <code class=\"inline\">{:ok, struct}</code> if the struct has been successfully deleted or <code class=\"inline\">{:error, changeset}</code> if there was a validation or a known constraint error.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">post = MyRepo.get!(Post, 42)\ncase MyRepo.delete post do\n  {:ok, struct}       -&gt; # Deleted with success\n  {:error, changeset} -&gt; # Something went wrong\nend</code></pre>    <h3 class=\"detail-header callback\" id=\"c:delete!/2\">  <span class=\"signature\">delete!(struct, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete!(struct :: <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> |\n  no_return</code></pre>    <p>Same as <code class=\"inline\">delete/2</code> but returns the struct or raises if the changeset is invalid.</p>    <h3 class=\"detail-header callback\" id=\"c:delete_all/2\">  <span class=\"signature\">delete_all(queryable, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete_all(queryable :: <a href=\"ecto.queryable#t:t/0\">Ecto.Queryable.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {integer, nil | [term]} |\n  no_return</code></pre>    <p>Deletes all entries matching the given query.</p> <p>It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in DELETE statements or no return result was selected, the second element will be <code class=\"inline\">nil</code>.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:returning</code> - selects which fields to return. When <code class=\"inline\">true</code>, returns all fields in the given struct. May be a list of fields, where a struct is still returned but only with the given fields. Or <code class=\"inline\">false</code>, where nothing is returned (the default). This option is not supported by all databases. </li> </ul> <p>See the “Shared options” section at the module documentation for remaining options.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">MyRepo.delete_all(Post)\n\nfrom(p in Post, where: p.id &lt; 10) |&gt; MyRepo.delete_all</code></pre>    <h3 class=\"detail-header callback\" id=\"c:get/3\">  <span class=\"signature\">get(queryable, id, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get(queryable :: <a href=\"ecto.queryable#t:t/0\">Ecto.Queryable.t</a>, id :: term, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> |\n  nil |\n  no_return</code></pre>    <p>Fetches a single struct from the data store where the primary key matches the given id.</p> <p>Returns <code class=\"inline\">nil</code> if no result was found. If the struct in the queryable has no or more than one primary key, it will raise an argument error.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">MyRepo.get(Post, 42)</code></pre>    <h3 class=\"detail-header callback\" id=\"c:get!/3\">  <span class=\"signature\">get!(queryable, id, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get!(queryable :: <a href=\"ecto.queryable#t:t/0\">Ecto.Queryable.t</a>, id :: term, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> |\n  nil |\n  no_return</code></pre>    <p>Similar to <code class=\"inline\">get/3</code> but raises <a href=\"ecto.noresultserror\"><code class=\"inline\">Ecto.NoResultsError</code></a> if no record was found.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">MyRepo.get!(Post, 42)</code></pre>    <h3 class=\"detail-header callback\" id=\"c:get_by/3\">  <span class=\"signature\">get_by(queryable, clauses, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_by(queryable :: <a href=\"ecto.queryable#t:t/0\">Ecto.Queryable.t</a>, clauses :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a> | map, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> |\n  nil |\n  no_return</code></pre>    <p>Fetches a single result from the query.</p> <p>Returns <code class=\"inline\">nil</code> if no result was found.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">MyRepo.get_by(Post, title: \"My post\")</code></pre>    <h3 class=\"detail-header callback\" id=\"c:get_by!/3\">  <span class=\"signature\">get_by!(queryable, clauses, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_by!(queryable :: <a href=\"ecto.queryable#t:t/0\">Ecto.Queryable.t</a>, clauses :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a> | map, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> |\n  nil |\n  no_return</code></pre>    <p>Similar to <code class=\"inline\">get_by/3</code> but raises <a href=\"ecto.noresultserror\"><code class=\"inline\">Ecto.NoResultsError</code></a> if no record was found.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">MyRepo.get_by!(Post, title: \"My post\")</code></pre>    <h3 class=\"detail-header callback\" id=\"c:in_transaction?/0\">  <span class=\"signature\">in_transaction?()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">in_transaction? :: boolean</code></pre>    <p>Returns true if the current process is inside a transaction.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">MyRepo.in_transaction?\n#=&gt; false\n\nMyRepo.transaction(fn -&gt;\n  MyRepo.in_transaction? #=&gt; true\nend)</code></pre>    <h3 class=\"detail-header callback\" id=\"c:insert/2\">  <span class=\"signature\">insert(struct, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">insert(struct :: <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> | <a href=\"ecto.changeset#t:t/0\">Ecto.Changeset.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>} |\n  {:error, <a href=\"ecto.changeset#t:t/0\">Ecto.Changeset.t</a>}</code></pre>    <p>Inserts a struct or a changeset.</p> <p>In case a struct is given, the struct is converted into a changeset with all non-nil fields as part of the changeset.</p> <p>In case a changeset is given, the changes in the changeset are merged with the struct fields, and all of them are sent to the database.</p> <p>It returns <code class=\"inline\">{:ok, struct}</code> if the struct has been successfully inserted or <code class=\"inline\">{:error, changeset}</code> if there was a validation or a known constraint error.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">case MyRepo.insert %Post{title: \"Ecto is great\"} do\n  {:ok, struct}       -&gt; # Inserted with success\n  {:error, changeset} -&gt; # Something went wrong\nend</code></pre>    <h3 class=\"detail-header callback\" id=\"c:insert!/2\">  <span class=\"signature\">insert!(struct, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">insert!(struct :: <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> |\n  no_return</code></pre>    <p>Same as <code class=\"inline\">insert/2</code> but returns the struct or raises if the changeset is invalid.</p>    <h3 class=\"detail-header callback\" id=\"c:insert_all/3\">  <span class=\"signature\">insert_all(schema_or_source, entries, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">insert_all(schema_or_source :: binary | {binary | nil, binary} | <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>, entries :: [map | <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>], opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {integer, nil | [term]} |\n  no_return</code></pre>    <p>Inserts all entries into the repository.</p> <p>It expects a schema (<code class=\"inline\">MyApp.User</code>) or a source (<code class=\"inline\">\"users\"</code> or <code class=\"inline\">{\"prefix\", \"users\"}</code>) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps.</p> <p>It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in UPDATE statements or no return result was selected, the second element will be <code class=\"inline\">nil</code>.</p> <p>When a schema is given, the values given will be properly dumped before being sent to the database. If the schema contains an autogenerated ID field, it will be handled either at the adapter or the storage layer. However any other autogenerated value, like timestamps, won’t be autogenerated when using <code class=\"inline\">c:insert_all/3</code>. This is by design as this function aims to be a more direct way to insert data into the database without the conveniences of <code class=\"inline\">c:insert/2</code>. This is also consistent with <code class=\"inline\">c:update_all/3</code> that does not handle timestamps as well.</p> <p>If a source is given, without a schema, the given fields are passed as is to the adapter.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:returning</code> - selects which fields to return. When <code class=\"inline\">true</code>, returns all fields in the given struct. May be a list of fields, where a struct is still returned but only with the given fields. Or <code class=\"inline\">false</code>, where nothing is returned (the default). This option is not supported by all databases. </li> </ul> <p>See the “Shared options” section at the module documentation for remaining options.</p>    <h3 class=\"detail-header callback\" id=\"c:insert_or_update/2\">  <span class=\"signature\">insert_or_update(changeset, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">insert_or_update(changeset :: <a href=\"ecto.changeset#t:t/0\">Ecto.Changeset.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>} |\n  {:error, <a href=\"ecto.changeset#t:t/0\">Ecto.Changeset.t</a>}</code></pre>    <p>Inserts or updates a changeset depending on whether the struct is persisted or not.</p> <p>The distinction whether to insert or update will be made on the <a href=\"ecto.schema.metadata\"><code class=\"inline\">Ecto.Schema.Metadata</code></a> field <code class=\"inline\">:state</code>. The <code class=\"inline\">:state</code> is automatically set by Ecto when loading or building a schema.</p> <p>Please note that for this to work, you will have to load existing structs from the database. So even if the struct exists, this won’t work:</p> <pre data-language=\"elixir\"><code class=\"elixir\">struct = %Post{id: 'existing_id', ...}\nMyRepo.insert_or_update changeset\n# =&gt; {:error, \"id already exists\"}</code></pre> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">result =\n  case MyRepo.get(Post, id) do\n    nil  -&gt; %Post{id: id} # Post not found, we build one\n    post -&gt; post          # Post exists, let's use it\n  end\n  |&gt; Post.changeset(changes)\n  |&gt; MyRepo.insert_or_update\n\ncase result do\n  {:ok, struct}       -&gt; # Inserted or updated with success\n  {:error, changeset} -&gt; # Something went wrong\nend</code></pre>    <h3 class=\"detail-header callback\" id=\"c:insert_or_update!/2\">  <span class=\"signature\">insert_or_update!(changeset, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">insert_or_update!(changeset :: <a href=\"ecto.changeset#t:t/0\">Ecto.Changeset.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> |\n  no_return</code></pre>    <p>Same as <code class=\"inline\">insert_or_update/2</code> but returns the struct or raises if the changeset is invalid.</p>    <h3 class=\"detail-header callback\" id=\"c:one/2\">  <span class=\"signature\">one(queryable, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">one(queryable :: <a href=\"ecto.queryable#t:t/0\">Ecto.Queryable.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> |\n  nil |\n  no_return</code></pre>    <p>Fetches a single result from the query.</p> <p>Returns <code class=\"inline\">nil</code> if no result was found. Raises if more than one entry.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p>    <h3 class=\"detail-header callback\" id=\"c:one!/2\">  <span class=\"signature\">one!(queryable, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">one!(queryable :: <a href=\"ecto.queryable#t:t/0\">Ecto.Queryable.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> |\n  no_return</code></pre>    <p>Similar to <code class=\"inline\">one/2</code> but raises <a href=\"ecto.noresultserror\"><code class=\"inline\">Ecto.NoResultsError</code></a> if no record was found.</p> <p>Raises if more than one entry.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p>    <h3 class=\"detail-header callback\" id=\"c:preload/3\">  <span class=\"signature\">preload(struct_or_structs, preloads, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">preload(struct_or_structs, preloads :: term, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: struct_or_structs when struct_or_structs: [<a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>] | <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a></code></pre>    <p>Preloads all associations on the given struct or structs.</p> <p>This is similar to <a href=\"ecto.query#preload/3\"><code class=\"inline\">Ecto.Query.preload/3</code></a> except it allows you to preload structs after they have been fetched from the database.</p> <p>In case the association was already loaded, preload won’t attempt to reload it.</p> <h4>Options</h4> <p>Besides the “Shared options” section at the module documentation, it accepts:</p> <ul> <li>\n<code class=\"inline\">:force</code> - By default, Ecto won’t preload associations that are already loaded. By setting this option to true, any existing association will be discarded and reloaded. </li> <li>\n<code class=\"inline\">:in_parallel</code> - If the preloads must be done in parallel. It can only be performed when we have more than one preload and the repository is not in a transaction. Defaults to <code class=\"inline\">true</code>. </li> <li>\n<code class=\"inline\">:prefix</code> - the prefix to fetch preloads from. By default, queries will use the same prefix as the one in the given collection. This option allows the prefix to be changed. </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">posts = Repo.preload posts, :comments\nposts = Repo.preload posts, comments: :permalinks\nposts = Repo.preload posts, comments: from(c in Comment, order_by: c.published_at)</code></pre>    <h3 class=\"detail-header callback\" id=\"c:rollback/1\">  <span class=\"signature\">rollback(value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rollback(value :: any) :: no_return</code></pre>    <p>Rolls back the current transaction.</p> <p>The transaction will return the value given as <code class=\"inline\">{:error, value}</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:start_link/1\">  <span class=\"signature\">start_link(opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_link(opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, pid} |\n  {:error, {:already_started, pid}} |\n  {:error, term}</code></pre>    <p>Starts any connection pooling or supervision and return <code class=\"inline\">{:ok, pid}</code> or just <code class=\"inline\">:ok</code> if nothing needs to be done. </p> <p>Returns <code class=\"inline\">{:error, {:already_started, pid}}</code> if the repo is already started or <code class=\"inline\">{:error, term}</code> in case anything else goes wrong.</p> <h4>Options</h4> <p>See the configuration in the moduledoc for options shared between adapters, for adapter-specific configuration see the adapter’s documentation.</p>    <h3 class=\"detail-header callback\" id=\"c:stop/2\">  <span class=\"signature\">stop(pid, timeout)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stop(pid, timeout) :: :ok</code></pre>    <p>Shuts down the repository represented by the given pid.</p>    <h3 class=\"detail-header callback\" id=\"c:transaction/2\">  <span class=\"signature\">transaction(fun_or_multi, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">transaction(fun_or_multi :: (... -&gt; any) | <a href=\"ecto.multi#t:t/0\">Ecto.Multi.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, any} |\n  {:error, any} |\n  {:error, atom, any, %{optional(atom) =&gt; any}}</code></pre>    <p>Runs the given function or <a href=\"ecto.multi\"><code class=\"inline\">Ecto.Multi</code></a> inside a transaction.</p> <h4>Use with function</h4> <p>If an unhandled error occurs the transaction will be rolled back and the error will bubble up from the transaction function. If no error occurred the transaction will be committed when the function returns. A transaction can be explicitly rolled back by calling <code class=\"inline\">rollback/1</code>, this will immediately leave the function and return the value given to <code class=\"inline\">rollback</code> as <code class=\"inline\">{:error, value}</code>.</p> <p>A successful transaction returns the value returned by the function wrapped in a tuple as <code class=\"inline\">{:ok, value}</code>.</p> <p>If <code class=\"inline\">transaction/2</code> is called inside another transaction, the function is simply executed, without wrapping the new transaction call in any way. If there is an error in the inner transaction and the error is rescued, or the inner transaction is rolled back, the whole outer transaction is marked as tainted, guaranteeing nothing will be committed.</p> <h4>Use with Ecto.Multi</h4> <p>Besides functions transaction can be used with an Ecto.Multi struct. Transaction will be started, all operations applied and in case of success committed returning <code class=\"inline\">{:ok, changes}</code>. In case of any errors the transaction will be rolled back and <code class=\"inline\">{:error, failed_operation, failed_value, changes_so_far}</code> will be returned.</p> <p>You can read more about using transactions with <a href=\"ecto.multi\"><code class=\"inline\">Ecto.Multi</code></a> as well as see some examples in the <a href=\"ecto.multi\"><code class=\"inline\">Ecto.Multi</code></a> documentation.</p> <h4>Options</h4> <p>See the “Shared options” section at the module documentation.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">MyRepo.transaction(fn -&gt;\n  MyRepo.update!(%{alice | balance: alice.balance - 10})\n  MyRepo.update!(%{bob | balance: bob.balance + 10})\nend)\n\n# Roll back a transaction explicitly\nMyRepo.transaction(fn -&gt;\n  p = MyRepo.insert!(%Post{})\n  if not Editor.post_allowed?(p) do\n    MyRepo.rollback(:posting_not_allowed)\n  end\nend)\n\n# With Ecto.Multi\nEcto.Multi.new\n|&gt; Ecto.Multi.insert(:post, %Post{})\n|&gt; MyRepo.transaction</code></pre>    <h3 class=\"detail-header callback\" id=\"c:update/2\">  <span class=\"signature\">update(struct, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update(struct :: <a href=\"ecto.changeset#t:t/0\">Ecto.Changeset.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>} |\n  {:error, <a href=\"ecto.changeset#t:t/0\">Ecto.Changeset.t</a>}</code></pre>    <p>Updates a changeset using its primary key.</p> <p>A changeset is required as it is the only mechanism for tracking dirty changes.</p> <p>If the struct has no primary key, <a href=\"ecto.noprimarykeyfielderror\"><code class=\"inline\">Ecto.NoPrimaryKeyFieldError</code></a> will be raised.</p> <p>It returns <code class=\"inline\">{:ok, struct}</code> if the struct has been successfully updated or <code class=\"inline\">{:error, changeset}</code> if there was a validation or a known constraint error.</p> <h4>Options</h4> <p>Besides the “Shared options” section at the module documentation, it accepts:</p> <ul> <li>\n<code class=\"inline\">:force</code> - By default, if there are no changes in the changeset, <code class=\"inline\">update!/2</code> is a no-op. By setting this option to true, update callbacks will always be executed, even if there are no changes (including timestamps). </li> </ul> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">post = MyRepo.get!(Post, 42)\npost = Ecto.Changeset.change post, title: \"New title\"\ncase MyRepo.update post do\n  {:ok, struct}       -&gt; # Updated with success\n  {:error, changeset} -&gt; # Something went wrong\nend</code></pre>    <h3 class=\"detail-header callback\" id=\"c:update!/2\">  <span class=\"signature\">update!(struct, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update!(struct :: <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> |\n  no_return</code></pre>    <p>Same as <code class=\"inline\">update/2</code> but returns the struct or raises if the changeset is invalid.</p>    <h3 class=\"detail-header callback\" id=\"c:update_all/3\">  <span class=\"signature\">update_all(queryable, updates, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update_all(queryable :: <a href=\"ecto.queryable#t:t/0\">Ecto.Queryable.t</a>, updates :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>, opts :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {integer, nil | [term]} |\n  no_return</code></pre>    <p>Updates all entries matching the given query with the given values.</p> <p>It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in UPDATE statements or no return result was selected, the second element will be <code class=\"inline\">nil</code>.</p> <p>Keep in mind this <code class=\"inline\">update_all</code> will not update autogenerated fields like the <code class=\"inline\">updated_at</code> columns.</p> <p>See <a href=\"ecto.query#update/3\"><code class=\"inline\">Ecto.Query.update/3</code></a> for update operations that can be performed on fields.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:returning</code> - selects which fields to return. When <code class=\"inline\">true</code>, returns all fields in the given struct. May be a list of fields, where a struct is still returned but only with the given fields. Or <code class=\"inline\">false</code>, where nothing is returned (the default). This option is not supported by all databases. </li> </ul> <p>See the “Shared options” section at the module documentation for remaining options.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">MyRepo.update_all(Post, set: [title: \"New title\"])\n\nMyRepo.update_all(Post, inc: [visits: 1])\n\nfrom(p in Post, where: p.id &lt; 10)\n|&gt; MyRepo.update_all(set: [title: \"New title\"])\n\nfrom(p in Post, where: p.id &lt; 10, update: [set: [title: \"New title\"]])\n|&gt; MyRepo.update_all([])\n\nfrom(p in Post, where: p.id &lt; 10, update: [set: [title: fragment(\"?\", new_title)]])\n|&gt; MyRepo.update_all([])</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Repo.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Repo.html</a>\n  </p>\n</div>\n","ecto/ecto.subquery":"<h1>  Ecto.SubQuery  </h1>  <p>Stores subquery information.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.SubQuery.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.SubQuery.html</a>\n  </p>\n</div>\n","ecto/ecto.type":"<h1>  Ecto.Type <small>behaviour</small>  </h1>  <p>Defines functions and the <a href=\"ecto.type#content\"><code class=\"inline\">Ecto.Type</code></a> behaviour for implementing custom types.</p> <p>A custom type expects 4 functions to be implemented, all documented and described below. We also provide two examples of how custom types can be used in Ecto to augment existing types or providing your own types.</p> <h2 id=\"module-augmenting-types\" class=\"section-heading\">  Augmenting types </h2> <p>Imagine you want to support your id field to be looked up as a permalink. For example, you want the following query to work:</p> <pre data-language=\"elixir\"><code class=\"elixir\">permalink = \"10-how-to-be-productive-with-elixir\"\nfrom p in Post, where: p.id == ^permalink</code></pre> <p>If <code class=\"inline\">id</code> is an integer field, Ecto will fail in the query above because it cannot cast the string to an integer. By using a custom type, we can provide special casting behaviour while still keeping the underlying Ecto type the same:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Permalink do\n  @behaviour Ecto.Type\n  def type, do: :integer\n\n  # Provide our own casting rules.\n  def cast(string) when is_binary(string) do\n    case Integer.parse(string) do\n      {int, _} -&gt; {:ok, int}\n      :error   -&gt; :error\n    end\n  end\n\n  # We should still accept integers\n  def cast(integer) when is_integer(integer), do: {:ok, integer}\n\n  # Everything else is a failure though\n  def cast(_), do: :error\n\n  # When loading data from the database, we are guaranteed to\n  # receive an integer (as databases are strict) and we will\n  # just return it to be stored in the schema struct.\n  def load(integer) when is_integer(integer), do: {:ok, integer}\n\n  # When dumping data to the database, we *expect* an integer\n  # but any value could be inserted into the struct, so we need\n  # guard against them.\n  def dump(integer) when is_integer(integer), do: {:ok, integer}\n  def dump(_), do: :error\nend</code></pre> <p>Now we can use our new field above as our primary key type in schemas:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Post do\n  use Ecto.Schema\n\n  @primary_key {:id, Permalink, autogenerate: true}\n  schema \"posts\" do\n    ...\n  end\nend</code></pre> <h2 id=\"module-new-types\" class=\"section-heading\">  New types </h2> <p>In the previous example, we say we were augmenting an existing type because we were keeping the underlying representation the same, the value stored in the struct and the database was always an integer.</p> <p>Ecto types also allow developers to dump and load new types. In order for this to work, callbacks should take care of encoding your custom Ecto type into its DB representation, as well as decoding it from the DB back into the Ecto type. Each callback should behave as follows:</p> <ul> <li>\n<code class=\"inline\">type</code> should output the name of the DB type </li> <li>\n<code class=\"inline\">cast</code> should receive any type and output your custom Ecto type </li> <li>\n<code class=\"inline\">load</code> should receive the DB type and output your custom Ecto type </li> <li>\n<code class=\"inline\">dump</code> should receive your custom Ecto type and output the DB type </li> </ul> <p><a href=\"ecto.datetime\"><code class=\"inline\">Ecto.DateTime</code></a> is an example of a custom type. Developers often use <a href=\"ecto.datetime\"><code class=\"inline\">Ecto.DateTime</code></a> in their schemas and Ecto takes care of converting between types whenever the schema information is available. Developers may also implement <a href=\"ecto.datatype\"><code class=\"inline\">Ecto.DataType</code></a> for <a href=\"ecto.datetime\"><code class=\"inline\">Ecto.DateTime</code></a>, allowing <a href=\"ecto.datetime\"><code class=\"inline\">Ecto.DateTime</code></a> to behave as the database <code class=\"inline\">:datetime</code> even in the absence of schema information.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:custom/0\">custom()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Custom types are represented by user-defined modules</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:primitive/0\">primitive()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Primitive Ecto types (handled by Ecto)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt> <dd class=\"summary-synopsis\">\n<p>An Ecto type, primitive or custom</p> </dd>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#base?/1\">base?(atom)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the given atom can be used as base type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cast/2\">cast(type, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Casts a value to the given type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#composite?/1\">composite?(atom)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the given atom can be used as composite type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dump/3\">dump(type, value, dumper \\\\ &amp;dump/2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dumps a value to the given type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#load/3\">load(type, value, loader \\\\ &amp;load/2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Loads a value with the given type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#match?/2\">match?(schema_type, query_type)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if a given type matches with a primitive type that can be found in queries</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#primitive?/1\">primitive?(base)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if we have a primitive type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#type/1\">type(type)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Retrieves the underlying schema type for the given, possibly custom, type</p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:cast/1\">cast(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Casts the given input to the custom type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:dump/1\">dump(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dumps the given term into an Ecto native type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:load/1\">load(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Loads the given term into a custom type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:type/0\">type()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the underlying schema type for the custom type</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:custom/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:custom/0\">custom</a> :: atom</code></pre> <p>Custom types are represented by user-defined modules.</p>  </div> <div id=\"t:primitive/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:primitive/0\">primitive</a> :: base | composite</code></pre> <p>Primitive Ecto types (handled by Ecto).</p>  </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: <a href=\"#t:primitive/0\">primitive</a> | <a href=\"#t:custom/0\">custom</a></code></pre> <p>An Ecto type, primitive or custom.</p>  </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"base?/1\">  <span class=\"signature\">base?(atom)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">base?(atom) :: boolean</code></pre>    <p>Checks if the given atom can be used as base type.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; base?(:string)\ntrue\niex&gt; base?(:array)\nfalse\niex&gt; base?(Custom)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"cast/2\">  <span class=\"signature\">cast(type, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cast(<a href=\"#t:t/0\">t</a>, term) :: {:ok, term} | :error</code></pre>    <p>Casts a value to the given type.</p> <p><a href=\"#cast/2\"><code class=\"inline\">cast/2</code></a> is used by the finder queries and changesets to cast outside values to specific types.</p> <p>Note that nil can be cast to all primitive types as data stores allow nil to be set on any column.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; cast(:any, \"whatever\")\n{:ok, \"whatever\"}\n\niex&gt; cast(:any, nil)\n{:ok, nil}\niex&gt; cast(:string, nil)\n{:ok, nil}\n\niex&gt; cast(:integer, 1)\n{:ok, 1}\niex&gt; cast(:integer, \"1\")\n{:ok, 1}\niex&gt; cast(:integer, \"1.0\")\n:error\n\niex&gt; cast(:id, 1)\n{:ok, 1}\niex&gt; cast(:id, \"1\")\n{:ok, 1}\niex&gt; cast(:id, \"1.0\")\n:error\n\niex&gt; cast(:float, 1.0)\n{:ok, 1.0}\niex&gt; cast(:float, 1)\n{:ok, 1.0}\niex&gt; cast(:float, \"1\")\n{:ok, 1.0}\niex&gt; cast(:float, \"1.0\")\n{:ok, 1.0}\niex&gt; cast(:float, \"1-foo\")\n:error\n\niex&gt; cast(:boolean, true)\n{:ok, true}\niex&gt; cast(:boolean, false)\n{:ok, false}\niex&gt; cast(:boolean, \"1\")\n{:ok, true}\niex&gt; cast(:boolean, \"0\")\n{:ok, false}\niex&gt; cast(:boolean, \"whatever\")\n:error\n\niex&gt; cast(:string, \"beef\")\n{:ok, \"beef\"}\niex&gt; cast(:binary, \"beef\")\n{:ok, \"beef\"}\n\niex&gt; cast(:decimal, Decimal.new(1.0))\n{:ok, Decimal.new(1.0)}\niex&gt; cast(:decimal, Decimal.new(\"1.0\"))\n{:ok, Decimal.new(1.0)}\n\niex&gt; cast({:array, :integer}, [1, 2, 3])\n{:ok, [1, 2, 3]}\niex&gt; cast({:array, :integer}, [\"1\", \"2\", \"3\"])\n{:ok, [1, 2, 3]}\niex&gt; cast({:array, :string}, [1, 2, 3])\n:error\niex&gt; cast(:string, [1, 2, 3])\n:error</code></pre>    <h3 class=\"detail-header function\" id=\"composite?/1\">  <span class=\"signature\">composite?(atom)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">composite?(atom) :: boolean</code></pre>    <p>Checks if the given atom can be used as composite type.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; composite?(:array)\ntrue\niex&gt; composite?(:string)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"dump/3\">  <span class=\"signature\">dump(type, value, dumper \\\\ &amp;dump/2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">dump(<a href=\"#t:t/0\">t</a>, term, (<a href=\"#t:t/0\">t</a>, term -&gt; {:ok, term} | :error)) ::\n  {:ok, term} |\n  :error</code></pre>    <p>Dumps a value to the given type.</p> <p>Opposite to casting, dumping requires the returned value to be a valid Ecto type, as it will be sent to the underlying data store.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; dump(:string, nil)\n{:ok, nil}\niex&gt; dump(:string, \"foo\")\n{:ok, \"foo\"}\n\niex&gt; dump(:integer, 1)\n{:ok, 1}\niex&gt; dump(:integer, \"10\")\n:error\n\niex&gt; dump(:binary, \"foo\")\n{:ok, \"foo\"}\niex&gt; dump(:binary, 1)\n:error\n\niex&gt; dump({:array, :integer}, [1, 2, 3])\n{:ok, [1, 2, 3]}\niex&gt; dump({:array, :integer}, [1, \"2\", 3])\n:error\niex&gt; dump({:array, :binary}, [\"1\", \"2\", \"3\"])\n{:ok, [\"1\", \"2\", \"3\"]}</code></pre> <p>A <code class=\"inline\">dumper</code> function may be given for handling recursive types.</p>    <h3 class=\"detail-header function\" id=\"load/3\">  <span class=\"signature\">load(type, value, loader \\\\ &amp;load/2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">load(<a href=\"#t:t/0\">t</a>, term, (<a href=\"#t:t/0\">t</a>, term -&gt; {:ok, term} | :error)) ::\n  {:ok, term} |\n  :error</code></pre>    <p>Loads a value with the given type.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; load(:string, nil)\n{:ok, nil}\niex&gt; load(:string, \"foo\")\n{:ok, \"foo\"}\n\niex&gt; load(:integer, 1)\n{:ok, 1}\niex&gt; load(:integer, \"10\")\n:error</code></pre> <p>A <code class=\"inline\">loader</code> function may be given for handling recursive types.</p>    <h3 class=\"detail-header function\" id=\"match?/2\">  <span class=\"signature\">match?(schema_type, query_type)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">match?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:primitive/0\">primitive</a>) :: boolean</code></pre>    <p>Checks if a given type matches with a primitive type that can be found in queries.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; match?(:string, :any)\ntrue\niex&gt; match?(:any, :string)\ntrue\niex&gt; match?(:string, :string)\ntrue\n\niex&gt; match?({:array, :string}, {:array, :any})\ntrue\n\niex&gt; match?(Ecto.DateTime, :datetime)\ntrue\niex&gt; match?(Ecto.DateTime, :string)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"primitive?/1\">  <span class=\"signature\">primitive?(base)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">primitive?(<a href=\"#t:t/0\">t</a>) :: boolean</code></pre>    <p>Checks if we have a primitive type.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; primitive?(:string)\ntrue\niex&gt; primitive?(Another)\nfalse\n\niex&gt; primitive?({:array, :string})\ntrue\niex&gt; primitive?({:array, Another})\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"type/1\">  <span class=\"signature\">type(type)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">type(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Retrieves the underlying schema type for the given, possibly custom, type.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; type(:string)\n:string\niex&gt; type(Ecto.DateTime)\n:datetime\n\niex&gt; type({:array, :string})\n{:array, :string}\niex&gt; type({:array, Ecto.DateTime})\n{:array, :datetime}\n\niex&gt; type({:map, Ecto.DateTime})\n{:map, :datetime}</code></pre>     <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:cast/1\">  <span class=\"signature\">cast(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cast(term) :: {:ok, term} | :error</code></pre>    <p>Casts the given input to the custom type.</p> <p>This callback is called on external input and can return any type, as long as the <code class=\"inline\">dump/1</code> function is able to convert the returned value back into an Ecto native type. There are two situations where this callback is called:</p> <ol> <li>When casting values by <a href=\"ecto.changeset\"><code class=\"inline\">Ecto.Changeset</code></a> </li> <li>When passing arguments to <a href=\"ecto.query\"><code class=\"inline\">Ecto.Query</code></a> </li> </ol>    <h3 class=\"detail-header callback\" id=\"c:dump/1\">  <span class=\"signature\">dump(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">dump(term) :: {:ok, term} | :error</code></pre>    <p>Dumps the given term into an Ecto native type.</p> <p>This callback is called with any term that was stored in the struct and it needs to validate them and convert it to an Ecto native type.</p>    <h3 class=\"detail-header callback\" id=\"c:load/1\">  <span class=\"signature\">load(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">load(term) :: {:ok, term} | :error</code></pre>    <p>Loads the given term into a custom type.</p> <p>This callback is called when loading data from the database and receive an Ecto native type. It can return any type, as long as the <code class=\"inline\">dump/1</code> function is able to convert the returned value back into an Ecto native type.</p>    <h3 class=\"detail-header callback\" id=\"c:type/0\">  <span class=\"signature\">type()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">type :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns the underlying schema type for the custom type.</p> <p>For example, if you want to provide your own datetime structures, the type function should return <code class=\"inline\">:datetime</code>.</p> <p>Note this function is not required to return Ecto primitive types, the type is only required to be known by the adapter.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Type.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Type.html</a>\n  </p>\n</div>\n","ecto/mix.tasks.ecto":"<h1>  Mix.Tasks.Ecto  </h1>  <p>Prints Ecto tasks and their information.</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix ecto</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Mix.Tasks.Ecto.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Mix.Tasks.Ecto.html</a>\n  </p>\n</div>\n","ecto/mix.tasks.ecto.drop":"<h1>  Mix.Tasks.Ecto.Drop  </h1>  <p>Drop the storage for the given repository.</p> <p>The repository must be set under <code class=\"inline\">:ecto_repos</code> in the current app configuration or given via the <code class=\"inline\">-r</code> option.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <pre data-language=\"elixir\"><code class=\"elixir\">mix ecto.drop\nmix ecto.drop -r Custom.Repo</code></pre> <h2 id=\"module-command-line-options\" class=\"section-heading\">  Command line options </h2> <ul> <li>\n<code class=\"inline\">-r</code>, <code class=\"inline\">--repo</code> - the repo to drop </li> <li>\n<code class=\"inline\">--no-compile</code> - do not compile before stopping </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Drop.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Drop.html</a>\n  </p>\n</div>\n","ecto/mix.tasks.ecto.gen.migration":"<h1>  Mix.Tasks.Ecto.Gen.Migration  </h1>  <p>Generates a migration.</p> <p>The repository must be set under <code class=\"inline\">:ecto_repos</code> in the current app configuration or given via the <code class=\"inline\">-r</code> option.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <pre data-language=\"elixir\"><code class=\"elixir\">mix ecto.gen.migration add_posts_table\nmix ecto.gen.migration add_posts_table -r Custom.Repo</code></pre> <p>By default, the migration will be generated to the “priv/YOUR_REPO/migrations” directory of the current application but it can be configured to be any subdirectory of <code class=\"inline\">priv</code> by specifying the <code class=\"inline\">:priv</code> key under the repository configuration.</p> <p>This generator will automatically open the generated file if you have <code class=\"inline\">ECTO_EDITOR</code> set in your environment variable.</p> <h2 id=\"module-command-line-options\" class=\"section-heading\">  Command line options </h2> <ul> <li>\n<code class=\"inline\">-r</code>, <code class=\"inline\">--repo</code> - the repo to generate migration for </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Gen.Migration.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Gen.Migration.html</a>\n  </p>\n</div>\n","ecto/ecto.migration":"<h1>  Ecto.Migration  </h1>  <p>Migrations are used to modify your database schema over time.</p> <p>This module provides many helpers for migrating the database, allowing developers to use Elixir to alter their storage in a way that is database independent.</p> <p>Here is an example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyRepo.Migrations.CreatePosts do\n  use Ecto.Migration\n\n  def up do\n    create table(:weather) do\n      add :city,    :string, size: 40\n      add :temp_lo, :integer\n      add :temp_hi, :integer\n      add :prcp,    :float\n\n      timestamps\n    end\n  end\n\n  def down do\n    drop table(:weather)\n  end\nend</code></pre> <p>Note migrations have an <code class=\"inline\">up/0</code> and <code class=\"inline\">down/0</code> instructions, where <code class=\"inline\">up/0</code> is used to update your database and <code class=\"inline\">down/0</code> rolls back the prompted changes.</p> <p>Ecto provides some mix tasks to help developers work with migrations:</p> <ul> <li>\n<code class=\"inline\">mix ecto.gen.migration add_weather_table</code> - generates a migration that the user can fill in with particular commands </li> <li>\n<code class=\"inline\">mix ecto.migrate</code> - migrates a repository </li> <li>\n<code class=\"inline\">mix ecto.rollback</code> - rolls back a particular migration </li> </ul> <p>Run the <code class=\"inline\">mix help COMMAND</code> for more information.</p> <h2 id=\"module-change\" class=\"section-heading\">  Change </h2> <p>Migrations can also be automatically reversible by implementing <code class=\"inline\">change/0</code> instead of <code class=\"inline\">up/0</code> and <code class=\"inline\">down/0</code>. For example, the migration above can be written as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyRepo.Migrations.CreatePosts do\n  use Ecto.Migration\n\n  def change do\n    create table(:weather) do\n      add :city,    :string, size: 40\n      add :temp_lo, :integer\n      add :temp_hi, :integer\n      add :prcp,    :float\n\n      timestamps\n    end\n  end\nend</code></pre> <p>Notice not all commands are reversible though. Trying to rollback a non-reversible command will raise an <a href=\"ecto.migrationerror\"><code class=\"inline\">Ecto.MigrationError</code></a>.</p> <h2 id=\"module-field-types\" class=\"section-heading\">  Field Types </h2> <p>The Ecto primitive types are mapped to the appropriate database type by the various database adapters. For example, <code class=\"inline\">:string</code> is converted to <code class=\"inline\">:varchar</code>, <code class=\"inline\">:datetime</code> to the underlying <code class=\"inline\">:datetime</code> or <code class=\"inline\">:timestamp</code> type, <code class=\"inline\">:binary</code> to <code class=\"inline\">:bits</code> or <code class=\"inline\">:blob</code>, and so on.</p> <p>Similarly, you can pass any field type supported by your database as long as it maps to an Ecto type. For instance, you can use <code class=\"inline\">:text</code>, <code class=\"inline\">:varchar</code> or <code class=\"inline\">:char</code> in your migrations as <code class=\"inline\">add :field_name, :text</code>. In your Ecto schema, they will all map to the same <code class=\"inline\">:string</code> type.</p> <h2 id=\"module-prefixes\" class=\"section-heading\">  Prefixes </h2> <p>Migrations support specifying a table prefix or index prefix which will target either a schema if using Postgres, or a different database if using MySQL. If no prefix is provided, the default schema or database is used. Any reference declared in the table migration refers by default to the table with the same declared prefix. The prefix is specified in the table options:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def up do\n  create table(:weather, prefix: :north_america) do\n    add :city,    :string, size: 40\n    add :temp_lo, :integer\n    add :temp_hi, :integer\n    add :prcp,    :float\n    add :group_id, references(:groups)\n\n    timestamps\n  end\n\n  create index(:weather, [:city], prefix: :north_america)\nend</code></pre> <p>Note: if using MySQL with a prefixed table, you must use the same prefix for the references since cross database references are not supported.</p> <p>For both MySQL and Postgres with a prefixed table, you must use the same prefix for the index field to ensure you index the prefix qualified table.</p> <h2 id=\"module-transactions\" class=\"section-heading\">  Transactions </h2> <p>By default, Ecto runs all migrations inside a transaction. That’s not always ideal: for example, PostgreSQL allows to create/drop indexes concurrently but only outside of any transaction (see the <a href=\"http://www.postgresql.org/docs/9.2/static/sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY)\">PostgreSQL docs</a>.</p> <p>Migrations can be forced to run outside a transaction by setting the <code class=\"inline\">@disable_ddl_transaction</code> module attribute to <code class=\"inline\">true</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyRepo.Migrations.CreateIndexes do\n  use Ecto.Migration\n  @disable_ddl_transaction true\n\n  def change do\n    create index(:posts, [:slug], concurrently: true)\n  end\nend</code></pre> <p>Since running migrations outside a transaction can be dangerous, consider performing very few operations in such migrations.</p> <p>See the <a href=\"#index/3\"><code class=\"inline\">index/3</code></a> function for more information on creating/dropping indexes concurrently.</p> <h2 id=\"module-comments\" class=\"section-heading\">  Comments </h2> <p>Migrations where you create or alter a table support specifying table and column comments, the same can be done when creating constraints and indexes. At the moment there is support only for Postgres.</p> <pre data-language=\"elixir\"><code class=\"elixir\">def up do\n  create index(:posts, [:name], comment: \"Index Comment\")\n  create constraint(:products, \"price_must_be_positive\", check: \"price &gt; 0\", comment: \"Index Comment\")\n  create table(:weather, prefix: :north_america, comment: \"Table Comment\") do\n    add :city, :string, size: 40, comment: \"Column Comment\"\n    timestamps\n  end\nend</code></pre> <h2 id=\"module-schema-migrations-table\" class=\"section-heading\">  Schema Migrations table </h2> <p>Version numbers of migrations will be saved in <code class=\"inline\">schema_migrations</code> table. But you can configure the table via:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :app, App.Repo, migration_source: \"my_migrations\"</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#add/3\">add(column, type, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds a column when creating or altering a table</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#constraint/3\">constraint(table, name, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a constraint (either a check constraint or an exclusion constraint) to be evaluated by the database when a row is inserted or updated</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#create/1\">create(index)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates one of the following</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#create_if_not_exists/1\">create_if_not_exists(index)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates an index or a table with only <code class=\"inline\">:id</code> field if one does not yet exist</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#direction/0\">direction()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the migrator direction</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#drop/1\">drop(index_or_table_or_constraint)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Drops one of the following</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#drop_if_exists/1\">drop_if_exists(index_or_table)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Drops a table or index if it exists</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#execute/1\">execute(command)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Executes arbitrary SQL or a keyword command in NoSQL databases</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#flush/0\">flush()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Executes queue migration commands</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fragment/1\">fragment(expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a fragment to be used as default value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#index/3\">index(table, columns, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an index struct that can be used on <code class=\"inline\">create</code>, <code class=\"inline\">drop</code>, etc</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#modify/3\">modify(column, type, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Modifies the type of column when altering a table</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#prefix/0\">prefix()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the migrator prefix</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#references/2\">references(table, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a foreign key</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#remove/1\">remove(column)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes a column when altering a table</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rename/2\">rename(table_current, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Renames a table</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rename/3\">rename(table, current_column, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Renames a column outside of the <code class=\"inline\">alter</code> statement</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#table/2\">table(name, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a table struct that can be given on create, alter, etc</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#timestamps/1\">timestamps(opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds <code class=\"inline\">:inserted_at</code> and <code class=\"inline\">:updated_at</code> timestamps columns</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unique_index/3\">unique_index(table, columns, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Shortcut for creating a unique index</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#alter/2\">alter(object, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Alters a table</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#create/2\">create(object, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a table</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#create_if_not_exists/2\">create_if_not_exists(object, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a table if it does not exist</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"add/3\">  <span class=\"signature\">add(column, type, opts \\\\ [])</span>  </h3>  <p>Adds a column when creating or altering a table.</p> <p>This function also accepts Ecto primitive types as column types and they are normalized by the database adapter. For example, <code class=\"inline\">:string</code> is converted to <code class=\"inline\">:varchar</code>, <code class=\"inline\">:datetime</code> to the underlying <code class=\"inline\">:datetime</code> or <code class=\"inline\">:timestamp</code> type, <code class=\"inline\">:binary</code> to <code class=\"inline\">:bits</code> or <code class=\"inline\">:blob</code>, and so on.</p> <p>However, the column type is not always the same as the type used in your schema. For example, a schema that has a <code class=\"inline\">:string</code> field, can be supported by columns of types <code class=\"inline\">:char</code>, <code class=\"inline\">:varchar</code>, <code class=\"inline\">:text</code> and others. For this reason, this function also accepts <code class=\"inline\">:text</code> and other columns, which are sent as is to the underlying database.</p> <p>To sum up, the column type may be either an Ecto primitive type, which is normalized in cases the database does not understand it, like <code class=\"inline\">:string</code> or <code class=\"inline\">:binary</code>, or a database type which is passed as is. Custom Ecto types, like <code class=\"inline\">Ecto.Datetime</code>, are not supported because they are application level concern and may not always map to the database.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">create table(:posts) do\n  add :title, :string, default: \"Untitled\"\nend\n\nalter table(:posts) do\n  add :summary, :text # Database type\n  add :object,  :json\nend</code></pre> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:primary_key</code> - when true, marks this field as the primary key </li> <li>\n<code class=\"inline\">:default</code> - the column’s default value. can be a string, number or a fragment generated by <a href=\"#fragment/1\"><code class=\"inline\">fragment/1</code></a> </li> <li>\n<code class=\"inline\">:null</code> - when <code class=\"inline\">false</code>, the column does not allow null values </li> <li>\n<code class=\"inline\">:size</code> - the size of the type (for example the numbers of characters). Default is no size, except for <code class=\"inline\">:string</code> that defaults to 255. </li> <li>\n<code class=\"inline\">:precision</code> - the precision for a numeric type. Default is no precision </li> <li>\n<code class=\"inline\">:scale</code> - the scale of a numeric type. Default is 0 scale </li> </ul>    <h3 class=\"detail-header function\" id=\"constraint/3\">  <span class=\"signature\">constraint(table, name, opts \\\\ [])</span>  </h3>  <p>Defines a constraint (either a check constraint or an exclusion constraint) to be evaluated by the database when a row is inserted or updated.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">create constraint(:users, :price_must_be_positive, check: \"price &gt; 0\")\ncreate constraint(:size_ranges, :no_overlap, exclude: ~s|gist (int4range(\"from\", \"to\", '[]') WITH &amp;&amp;)|\ndrop   constraint(:products, \"price_must_be_positive\")</code></pre> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:check</code> - The expression to evaluate on a row. Required when creating. </li> <li>\n<code class=\"inline\">:name</code> - The name of the constraint - required. </li> </ul>    <h3 class=\"detail-header function\" id=\"create/1\">  <span class=\"signature\">create(index)</span>  </h3>  <p>Creates one of the following:</p> <ul> <li>an index </li> <li>a table with only an <code class=\"inline\">:id</code> field </li> <li>a constraint </li> </ul> <p>When reversing (in <code class=\"inline\">change</code> running backward) indexes are only dropped if they exist and no errors are raised. To enforce dropping an index use <a href=\"#drop/1\"><code class=\"inline\">drop/1</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">create index(:posts, [:name])\ncreate table(:version)\ncreate constraint(:products, \"price_must_be_positive\", check: \"price &gt; 0\")</code></pre>    <h3 class=\"detail-header function\" id=\"create_if_not_exists/1\">  <span class=\"signature\">create_if_not_exists(index)</span>  </h3>  <p>Creates an index or a table with only <code class=\"inline\">:id</code> field if one does not yet exist.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">create_if_not_exists index(:posts, [:name])\n\ncreate_if_not_exists table(:version)</code></pre>    <h3 class=\"detail-header function\" id=\"direction/0\">  <span class=\"signature\">direction()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">direction :: :up | :down</code></pre>    <p>Gets the migrator direction.</p>    <h3 class=\"detail-header function\" id=\"drop/1\">  <span class=\"signature\">drop(index_or_table_or_constraint)</span>  </h3>  <p>Drops one of the following:</p> <ul> <li>an index </li> <li>a table </li> <li>a constraint </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">drop index(:posts, [:name])\ndrop table(:posts)\ndrop constraint(:products, name: \"price_must_be_positive\")</code></pre>    <h3 class=\"detail-header function\" id=\"drop_if_exists/1\">  <span class=\"signature\">drop_if_exists(index_or_table)</span>  </h3>  <p>Drops a table or index if it exists.</p> <p>Does not raise an error if table or index does not exist.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">drop_if_exists index(:posts, [:name])\ndrop_if_exists table(:posts)</code></pre>    <h3 class=\"detail-header function\" id=\"execute/1\">  <span class=\"signature\">execute(command)</span>  </h3>  <p>Executes arbitrary SQL or a keyword command in NoSQL databases.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">execute \"UPDATE posts SET published_at = NULL\"\n\nexecute create: \"posts\", capped: true, size: 1024</code></pre>    <h3 class=\"detail-header function\" id=\"flush/0\">  <span class=\"signature\">flush()</span>  </h3>  <p>Executes queue migration commands.</p> <p>Reverses the order commands are executed when doing a rollback on a change/0 function and resets commands queue.</p>    <h3 class=\"detail-header function\" id=\"fragment/1\">  <span class=\"signature\">fragment(expr)</span>  </h3>  <p>Generates a fragment to be used as default value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">create table(:posts) do\n  add :inserted_at, :datetime, default: fragment(\"now()\")\nend</code></pre>    <h3 class=\"detail-header function\" id=\"index/3\">  <span class=\"signature\">index(table, columns, opts \\\\ [])</span>  </h3>  <p>Returns an index struct that can be used on <code class=\"inline\">create</code>, <code class=\"inline\">drop</code>, etc.</p> <p>Expects the table name as first argument and the index fields as second. The field can be an atom, representing a column, or a string representing an expression that is sent as is to the database.</p> <p>Indexes are non-unique by default.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:name</code> - the name of the index. Defaults to “#{table}_#{column}_index” </li> <li>\n<code class=\"inline\">:unique</code> - if the column(s) is unique or not </li> <li>\n<code class=\"inline\">:concurrently</code> - if the index should be created/dropped concurrently </li> <li>\n<code class=\"inline\">:using</code> - configures the index type </li> <li>\n<code class=\"inline\">:prefix</code> - prefix for the index </li> <li>\n<code class=\"inline\">:where</code> - the conditions for a partial index </li> </ul> <h4>Adding/dropping indexes concurrently</h4> <p>PostgreSQL supports adding/dropping indexes concurrently (see the <a href=\"http://www.postgresql.org/docs/9.4/static/sql-createindex.html)\">docs</a>. In order to take advantage of this, the <code class=\"inline\">:concurrently</code> option needs to be set to <code class=\"inline\">true</code> when the index is created/dropped.</p> <p><strong>Note</strong>: in order for the <code class=\"inline\">:concurrently</code> option to work, the migration must not be run inside a transaction. See the <a href=\"ecto.migration#content\"><code class=\"inline\">Ecto.Migration</code></a> docs for more information on running migrations outside of a transaction.</p> <h4>Index types</h4> <p>PostgreSQL supports several index types like B-tree, Hash or GiST. When creating an index, the index type defaults to B-tree, but it can be specified with the <code class=\"inline\">:using</code> option. The <code class=\"inline\">:using</code> option can be an atom or a string; its value is passed to the <code class=\"inline\">USING</code> clause as is.</p> <p>More information on index types can be found in the <a href=\"http://www.postgresql.org/docs/9.4/static/indexes-types.html\">PostgreSQL docs</a>.</p> <h4>Partial indexes</h4> <p>Databases like PostgreSQL and MSSQL supports partial indexes.</p> <p>A partial index is an index built over a subset of a table. The subset is defined by a conditional expression using the <code class=\"inline\">:where</code> option. The <code class=\"inline\">:where</code> option can be an atom or a string; its value is passed to the <code class=\"inline\">WHERE</code> clause as is.</p> <p>More information on partial indexes can be found in the <a href=\"http://www.postgresql.org/docs/9.4/static/indexes-partial.html\">PostgreSQL docs</a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Without a name, index defaults to products_category_id_sku_index\ncreate index(:products, [:category_id, :sku], unique: true)\n\n# Name can be given explicitly though\ndrop index(:products, [:category_id, :sku], name: :my_special_name)\n\n# Indexes can be added concurrently\ncreate index(:products, [:category_id, :sku], concurrently: true)\n\n# The index type can be specified\ncreate index(:products, [:name], using: :hash)\n\n# Create an index on custom expressions\ncreate index(:products, [\"lower(name)\"], name: :products_lower_name_index)\n\n# Create a partial index\ncreate index(:products, [:user_id], where: \"price = 0\", name: :free_products_index)</code></pre>    <h3 class=\"detail-header function\" id=\"modify/3\">  <span class=\"signature\">modify(column, type, opts \\\\ [])</span>  </h3>  <p>Modifies the type of column when altering a table.</p> <p>This command is not reversible as Ecto does not know what is the current type to revert it back to.</p> <p>See <a href=\"#add/3\"><code class=\"inline\">add/3</code></a> for more information on supported types.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">alter table(:posts) do\n  modify :title, :text\nend</code></pre> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:null</code> - sets to null or not null </li> <li>\n<code class=\"inline\">:default</code> - changes the default </li> <li>\n<code class=\"inline\">:size</code> - the size of the type (for example the numbers of characters). Default is no size. </li> <li>\n<code class=\"inline\">:precision</code> - the precision for a numeric type. Default is no precision. </li> <li>\n<code class=\"inline\">:scale</code> - the scale of a numeric type. Default is 0 scale. </li> </ul>    <h3 class=\"detail-header function\" id=\"prefix/0\">  <span class=\"signature\">prefix()</span>  </h3>  <p>Gets the migrator prefix.</p>    <h3 class=\"detail-header function\" id=\"references/2\">  <span class=\"signature\">references(table, opts \\\\ [])</span>  </h3>  <p>Defines a foreign key.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">create table(:products) do\n  add :group_id, references(:groups)\nend</code></pre> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:name</code> - The name of the underlying reference, defaults to “#{table}_#{column}_fkey” </li> <li>\n<code class=\"inline\">:column</code> - The foreign key column, default is <code class=\"inline\">:id</code> </li> <li>\n<code class=\"inline\">:type</code> - The foreign key type, default is <code class=\"inline\">:serial</code> </li> <li>\n<code class=\"inline\">:on_delete</code> - What to perform if the entry is deleted. May be <code class=\"inline\">:nothing</code>, <code class=\"inline\">:delete_all</code> or <code class=\"inline\">:nilify_all</code>. Defaults to <code class=\"inline\">:nothing</code>. </li> <li>\n<code class=\"inline\">:on_update</code> - What to perform if the entry is updated. May be <code class=\"inline\">:nothing</code>, <code class=\"inline\">:update_all</code> or <code class=\"inline\">:nilify_all</code>. Defaults to <code class=\"inline\">:nothing</code>. </li> </ul>    <h3 class=\"detail-header function\" id=\"remove/1\">  <span class=\"signature\">remove(column)</span>  </h3>  <p>Removes a column when altering a table.</p> <p>This command is not reversible as Ecto does not know what is the current type to add the column back as.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">alter table(:posts) do\n  remove :title\nend</code></pre>    <h3 class=\"detail-header function\" id=\"rename/2\">  <span class=\"signature\">rename(table_current, list)</span>  </h3>  <p>Renames a table.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">rename table(:posts), to: table(:new_posts)</code></pre>    <h3 class=\"detail-header function\" id=\"rename/3\">  <span class=\"signature\">rename(table, current_column, list)</span>  </h3>  <p>Renames a column outside of the <code class=\"inline\">alter</code> statement.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">rename table(:posts), :title, to: :summary</code></pre>    <h3 class=\"detail-header function\" id=\"table/2\">  <span class=\"signature\">table(name, opts \\\\ [])</span>  </h3>  <p>Returns a table struct that can be given on create, alter, etc.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">create table(:products) do\n  add :name, :string\n  add :price, :decimal\nend\n\ndrop table(:products)\n\ncreate table(:products, primary_key: false) do\n  add :name, :string\n  add :price, :decimal\nend</code></pre> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:primary_key</code> - when false, does not generate primary key on table creation </li> <li>\n<code class=\"inline\">:engine</code> - customizes the table storage for supported databases. For MySQL, the default is InnoDB </li> <li>\n<code class=\"inline\">:options</code> - provide custom options that will be appended after generated statement, for example “WITH”, “INHERITS” or “ON COMMIT” clauses </li> </ul>    <h3 class=\"detail-header function\" id=\"timestamps/1\">  <span class=\"signature\">timestamps(opts \\\\ [])</span>  </h3>  <p>Adds <code class=\"inline\">:inserted_at</code> and <code class=\"inline\">:updated_at</code> timestamps columns.</p> <p>Those columns are of <code class=\"inline\">:datetime</code> type and by default cannot be null. <code class=\"inline\">opts</code> can be given to customize the generated fields.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:inserted_at</code> - the name of the column for insertion times </li> <li>\n<code class=\"inline\">:updated_at</code> - the name of the column for update times </li> </ul>    <h3 class=\"detail-header function\" id=\"unique_index/3\">  <span class=\"signature\">unique_index(table, columns, opts \\\\ [])</span>  </h3>  <p>Shortcut for creating a unique index.</p> <p>See <a href=\"#index/3\"><code class=\"inline\">index/3</code></a> for more information.</p>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"alter/2\">  <span class=\"signature\">alter(object, list)</span>  </h3>  <p>Alters a table.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">alter table(:posts) do\n  add :summary, :text\n  modify :title, :text\n  remove :views\nend</code></pre>    <h3 class=\"detail-header macro\" id=\"create/2\">  <span class=\"signature\">create(object, list)</span>  </h3>  <p>Creates a table.</p> <p>By default, the table will also include a primary_key of name <code class=\"inline\">:id</code> and type <code class=\"inline\">:serial</code>. Check <a href=\"#table/2\"><code class=\"inline\">table/2</code></a> docs for more information.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">create table(:posts) do\n  add :title, :string, default: \"Untitled\"\n  add :body,  :text\n\n  timestamps\nend</code></pre>    <h3 class=\"detail-header macro\" id=\"create_if_not_exists/2\">  <span class=\"signature\">create_if_not_exists(object, list)</span>  </h3>  <p>Creates a table if it does not exist.</p> <p>Works just like <a href=\"#create/2\"><code class=\"inline\">create/2</code></a> but does not raise an error when table already exists.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Migration.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Migration.html</a>\n  </p>\n</div>\n","ecto/mix.tasks.ecto.dump":"<h1>  Mix.Tasks.Ecto.Dump  </h1>  <p>Dumps the current environment’s database structure for the given repository into a structure file.</p> <p>The repository must be set under <code class=\"inline\">:ecto_repos</code> in the current app configuration or given via the <code class=\"inline\">-r</code> option.</p> <h2 id=\"module-example\" class=\"section-heading\">  Example </h2> <pre data-language=\"elixir\"><code class=\"elixir\">mix ecto.dump</code></pre> <h2 id=\"module-command-line-options\" class=\"section-heading\">  Command line options </h2> <ul> <li>\n<code class=\"inline\">-r</code>, <code class=\"inline\">--repo</code> - the repo to load the structure info from </li> <li>\n<code class=\"inline\">-d</code>, <code class=\"inline\">--dump-path</code> - the path of the dump file to create </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#run/1\">run(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"run/1\">  <span class=\"signature\">run(args)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Dump.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Dump.html</a>\n  </p>\n</div>\n","ecto/mix.tasks.ecto.load":"<h1>  Mix.Tasks.Ecto.Load  </h1>  <p>Loads the current environment’s database structure for the given repository from a previously dumped structure file.</p> <p>The repository must be set under <code class=\"inline\">:ecto_repos</code> in the current app configuration or given via the <code class=\"inline\">-r</code> option.</p> <h2 id=\"module-example\" class=\"section-heading\">  Example </h2> <pre data-language=\"elixir\"><code class=\"elixir\">mix ecto.load</code></pre> <h2 id=\"module-command-line-options\" class=\"section-heading\">  Command line options </h2> <ul> <li>\n<code class=\"inline\">-r</code>, <code class=\"inline\">--repo</code> - the repo to load the structure info into </li> <li>\n<code class=\"inline\">-d</code>, <code class=\"inline\">--dump-path</code> - the path of the dump file to load from </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#run/1\">run(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"run/1\">  <span class=\"signature\">run(args)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Mix.Task.run/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Load.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Load.html</a>\n  </p>\n</div>\n","ecto/ecto.uuid":"<h1>  Ecto.UUID  </h1>  <p>An Ecto type for UUIDs strings.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#bingenerate/0\">bingenerate()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a version 4 (random) UUID in the binary format</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cast/1\">cast(u)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Casts to UUID</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dump/1\">dump(arg1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a string representing a UUID into a binary</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#generate/0\">generate()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a version 4 (random) UUID</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#load/1\">load(uuid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a binary UUID into a string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#type/0\">type()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The Ecto type</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"bingenerate/0\">  <span class=\"signature\">bingenerate()</span>  </h3>  <p>Generates a version 4 (random) UUID in the binary format.</p>    <h3 class=\"detail-header function\" id=\"cast/1\">  <span class=\"signature\">cast(u)</span>  </h3>  <p>Casts to UUID.</p>    <h3 class=\"detail-header function\" id=\"dump/1\">  <span class=\"signature\">dump(arg1)</span>  </h3>  <p>Converts a string representing a UUID into a binary.</p>    <h3 class=\"detail-header function\" id=\"generate/0\">  <span class=\"signature\">generate()</span>  </h3>  <p>Generates a version 4 (random) UUID.</p>    <h3 class=\"detail-header function\" id=\"load/1\">  <span class=\"signature\">load(uuid)</span>  </h3>  <p>Converts a binary UUID into a string.</p>    <h3 class=\"detail-header function\" id=\"type/0\">  <span class=\"signature\">type()</span>  </h3>  <p>The Ecto type.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.UUID.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.UUID.html</a>\n  </p>\n</div>\n","ecto/mix.tasks.ecto.create":"<h1>  Mix.Tasks.Ecto.Create  </h1>  <p>Create the storage for the given repository.</p> <p>The repository must be set under <code class=\"inline\">:ecto_repos</code> in the current app configuration or given via the <code class=\"inline\">-r</code> option.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <pre data-language=\"elixir\"><code class=\"elixir\">mix ecto.create\nmix ecto.create -r Custom.Repo</code></pre> <h2 id=\"module-command-line-options\" class=\"section-heading\">  Command line options </h2> <ul> <li>\n<code class=\"inline\">-r</code>, <code class=\"inline\">--repo</code> - the repo to create </li> <li>\n<code class=\"inline\">--no-compile</code> - do not compile before creating </li> <li>\n<code class=\"inline\">--quiet</code> - do not log output </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Create.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Create.html</a>\n  </p>\n</div>\n","ecto/mix.tasks.ecto.gen.repo":"<h1>  Mix.Tasks.Ecto.Gen.Repo  </h1>  <p>Generates a new repository.</p> <p>The repository will be placed in the <code class=\"inline\">lib</code> directory.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <pre data-language=\"elixir\"><code class=\"elixir\">mix ecto.gen.repo -r Custom.Repo</code></pre> <p>This generator will automatically open the config/config.exs after generation if you have <code class=\"inline\">ECTO_EDITOR</code> set in your environment variable.</p> <h2 id=\"module-command-line-options\" class=\"section-heading\">  Command line options </h2> <ul> <li>\n<code class=\"inline\">-r</code>, <code class=\"inline\">--repo</code> - the repo to generate </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Gen.Repo.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Gen.Repo.html</a>\n  </p>\n</div>\n","ecto/mix.tasks.ecto.migrations":"<h1>  Mix.Tasks.Ecto.Migrations  </h1>  <p>Displays the up / down migration status for the given repository.</p> <p>The repository must be set under <code class=\"inline\">:ecto_repos</code> in the current app configuration or given via the <code class=\"inline\">-r</code> option.</p> <p>By default, migrations are expected at “priv/YOUR_REPO/migrations” directory of the current application but it can be configured by specifying the <code class=\"inline\">:priv</code> key under the repository configuration.</p> <p>If the repository has not been started yet, one will be started outside our application supervision tree and shutdown afterwards.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <pre data-language=\"elixir\"><code class=\"elixir\">mix ecto.migrations\nmix ecto.migrations -r Custom.Repo</code></pre> <h2 id=\"module-command-line-options\" class=\"section-heading\">  Command line options </h2> <ul> <li>\n<code class=\"inline\">-r</code>, <code class=\"inline\">--repo</code> - the repo to obtain the status for </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Migrations.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Migrations.html</a>\n  </p>\n</div>\n","ecto/mix.tasks.ecto.migrate":"<h1>  Mix.Tasks.Ecto.Migrate  </h1>  <p>Runs the pending migrations for the given repository.</p> <p>The repository must be set under <code class=\"inline\">:ecto_repos</code> in the current app configuration or given via the <code class=\"inline\">-r</code> option.</p> <p>By default, migrations are expected at “priv/YOUR_REPO/migrations” directory of the current application but it can be configured to be any subdirectory of <code class=\"inline\">priv</code> by specifying the <code class=\"inline\">:priv</code> key under the repository configuration.</p> <p>Runs all pending migrations by default. To migrate up to a version number, supply <code class=\"inline\">--to version_number</code>. To migrate up a specific number of times, use <code class=\"inline\">--step n</code>.</p> <p>If the repository has not been started yet, one will be started outside our application supervision tree and shutdown afterwards.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <pre data-language=\"elixir\"><code class=\"elixir\">mix ecto.migrate\nmix ecto.migrate -r Custom.Repo\n\nmix ecto.migrate -n 3\nmix ecto.migrate --step 3\n\nmix ecto.migrate -v 20080906120000\nmix ecto.migrate --to 20080906120000</code></pre> <h2 id=\"module-command-line-options\" class=\"section-heading\">  Command line options </h2> <ul> <li>\n<code class=\"inline\">-r</code>, <code class=\"inline\">--repo</code> - the repo to migrate </li> <li>\n<code class=\"inline\">--all</code> - run all pending migrations </li> <li>\n<code class=\"inline\">--step</code> / <code class=\"inline\">-n</code> - run n number of pending migrations </li> <li>\n<code class=\"inline\">--to</code> / <code class=\"inline\">-v</code> - run all migrations up to and including version </li> <li>\n<code class=\"inline\">--quiet</code> - do not log migration commands </li> <li>\n<code class=\"inline\">--prefix</code> - the prefix to run migrations on </li> <li>\n<code class=\"inline\">--pool-size</code> - the pool size if the repository is started only for the task (defaults to 1) </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Migrate.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Migrate.html</a>\n  </p>\n</div>\n","ecto/mix.tasks.ecto.rollback":"<h1>  Mix.Tasks.Ecto.Rollback  </h1>  <p>Reverts applied migrations in the given repository.</p> <p>The repository must be set under <code class=\"inline\">:ecto_repos</code> in the current app configuration or given via the <code class=\"inline\">-r</code> option.</p> <p>By default, migrations are expected at “priv/YOUR_REPO/migrations” directory of the current application but it can be configured by specifying the <code class=\"inline\">:priv</code> key under the repository configuration.</p> <p>Runs the latest applied migration by default. To roll back to to a version number, supply <code class=\"inline\">--to version_number</code>. To roll back a specific number of times, use <code class=\"inline\">--step n</code>. To undo all applied migrations, provide <code class=\"inline\">--all</code>.</p> <p>If the repository has not been started yet, one will be started outside our application supervision tree and shutdown afterwards.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <pre data-language=\"elixir\"><code class=\"elixir\">mix ecto.rollback\nmix ecto.rollback -r Custom.Repo\n\nmix ecto.rollback -n 3\nmix ecto.rollback --step 3\n\nmix ecto.rollback -v 20080906120000\nmix ecto.rollback --to 20080906120000</code></pre> <h2 id=\"module-command-line-options\" class=\"section-heading\">  Command line options </h2> <ul> <li>\n<code class=\"inline\">-r</code>, <code class=\"inline\">--repo</code> - the repo to rollback </li> <li>\n<code class=\"inline\">--all</code> - revert all applied migrations </li> <li>\n<code class=\"inline\">--step</code> / <code class=\"inline\">-n</code> - revert n number of applied migrations </li> <li>\n<code class=\"inline\">--to</code> / <code class=\"inline\">-v</code> - revert all migrations down to and including version </li> <li>\n<code class=\"inline\">--quiet</code> - do not log migration commands </li> <li>\n<code class=\"inline\">--prefix</code> - the prefix to run migrations on </li> <li>\n<code class=\"inline\">--pool-size</code> - the pool size if the repository is started only for the task (defaults to 1) </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Rollback.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Mix.Tasks.Ecto.Rollback.html</a>\n  </p>\n</div>\n","ecto/ecto.invalidchangeseterror":"<h1>  Ecto.InvalidChangesetError <small>exception</small>  </h1>  <p>Raised when we cannot perform an action because the changeset is invalid.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(map)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(map)</span>  </h3>  <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.InvalidChangesetError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.InvalidChangesetError.html</a>\n  </p>\n</div>\n","ecto/ecto.invalidurlerror":"<h1>  Ecto.InvalidURLError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.InvalidURLError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.InvalidURLError.html</a>\n  </p>\n</div>\n","ecto/ecto.multi":"<h1>  Ecto.Multi  </h1>  <p>Ecto.Multi is a data structure that allows grouping multiple Repo operations together.</p> <p>Ecto.Multi makes it possible to pack operations that should be performed together (in a single database transaction) and gives a way to introspect the queued operations without actually performing them. Each operation is given a name that is unique and will identify its result or will help to identify the place of failure in case it occurs.</p> <p>All operations will be executed in the order they were added.</p> <p>The <a href=\"ecto.multi#content\"><code class=\"inline\">Ecto.Multi</code></a> structure should be considered opaque. You can use <code class=\"inline\">%Ecto.Multi{}</code> to pattern match the type, but accessing fields or directly modifying them is not advised. <a href=\"ecto.multi#to_list/1\"><code class=\"inline\">Ecto.Multi.to_list/1</code></a> returns a canonical representation of the structure that can be used for introspection.</p> <h2 id=\"module-changesets\" class=\"section-heading\">  Changesets </h2> <p>If Multi contains operations that accept changesets (like <a href=\"#insert/4\"><code class=\"inline\">insert/4</code></a>, <a href=\"#update/4\"><code class=\"inline\">update/4</code></a> or <a href=\"#delete/4)\"><code class=\"inline\">delete/4</code></a> they will be checked before starting the transaction. If any changeset has errors, the transaction won’t even be started and the error will be immediately returned.</p> <h2 id=\"module-run\" class=\"section-heading\">  Run </h2> <p>Multi allows you to run arbitrary functions as part of your transaction via the <a href=\"#run/3\"><code class=\"inline\">run/3</code></a> and <a href=\"#run/5\"><code class=\"inline\">run/5</code></a>. Those functions will receive changes so far as the first argument and have to return <code class=\"inline\">{:ok, value}</code> or <code class=\"inline\">{:error, value}</code> as their result. Returning an error will abort any further operations and make the whole multi fail.</p> <h2 id=\"module-example\" class=\"section-heading\">  Example </h2> <p>Let’s look at an example definition and usage. The use case we’ll be looking into is resetting a password. We need to update the account with proper information, log the request and remove all current sessions. We define a function creating the Multi structure probably in some sort of service layer:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Service do\n  alias Ecto.Multi\n  import Ecto\n\n  def password_reset(account, params) do\n    Multi.new\n    |&gt; Multi.update(:account, Account.password_reset_changeset(account, params))\n    |&gt; Multi.insert(:log, Log.password_reset_changeset(account, params))\n    |&gt; Multi.delete_all(:sessions, assoc(account, :sessions))\n  end\nend</code></pre> <p>We can later execute it in the integration layer using Repo:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Repo.transaction(Service.password_reset(account, params))</code></pre> <p>By pattern matching on the result we can differentiate different conditions:</p> <pre data-language=\"elixir\"><code class=\"elixir\">case result do\n  {:ok, %{account: account, log: log, sessions: sessions}} -&gt;\n    # Operation was successful, we can access results (exactly the same\n    # we would get from running corresponding Repo functions)\n    # under keys we used for naming the operations.\n  {:error, failed_operation, failed_value, changes_so_far} -&gt;\n    # One of the operations failed. We can access the operation's failure\n    # value (like changeset for operations on changesets) to prepare a\n    # proper response. We also get access to the results of any operations\n    # that succeeded before the indicated operation failed. However, any\n    # successful operations would have been rolled back.\nend</code></pre> <p>We can also easily unit test our transaction without actually running it. Since changesets can use in-memory-data, we can use an account that is constructed in memory as well (without persisting it to the database):</p> <pre data-language=\"elixir\"><code class=\"elixir\">test \"dry run password_reset\" do\n  account = %Account{password: \"letmein\"}\n  multi = Service.password_reset(account, params)\n\n  assert [\n    {:account, {:update, account_changeset, []}},\n    {:log, {:insert, log_changeset, []}},\n    {:sessions, {:delete_all, query, []}}\n  ] = Ecto.Multi.to_list(multi)\n\n  # We can introspect changesets and query to see if everything\n  # is as expected, for example:\n  assert account_changeset.valid?\n  assert log_changeset.valid?\n  assert inspect(query) == \"#Ecto.Query&lt;from a in Session&gt;\"\nend</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:merge/0\">merge()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:name/0\">name()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:run/0\">run()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#append/2\">append(lhs, rhs)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Appends the second multi to the first one</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete/4\">delete(multi, name, changeset_or_struct, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds a delete operation to the multi</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete_all/4\">delete_all(multi, name, queryable, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds a delete_all operation to the multi</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#insert/4\">insert(multi, name, changeset_or_struct, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds an insert operation to the multi</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#insert_all/5\">insert_all(multi, name, schema_or_source, entries, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds an insert_all operation to the multi</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#merge/2\">merge(multi, merge)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Merges a dynamically created multi</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#merge/4\">merge(multi, mod, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Merges a dynamically created multi</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/0\">new()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an empty <a href=\"ecto.multi#content\"><code class=\"inline\">Ecto.Multi</code></a> struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#prepend/2\">prepend(lhs, rhs)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prepends the second multi to the first one</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#run/3\">run(multi, name, run)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds a function to run as part of the multi</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#run/5\">run(multi, name, mod, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds a function to run as part of the multi</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_list/1\">to_list(multi)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Transforms the <a href=\"ecto.multi#content\"><code class=\"inline\">Ecto.Multi</code></a> into a list of operations to be performed. Inspecting the <a href=\"ecto.multi#content\"><code class=\"inline\">Ecto.Multi</code></a> struct internals directly is discouraged</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update/4\">update(multi, name, changeset, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds an update operation to the multi</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update_all/5\">update_all(multi, name, queryable, updates, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds an update_all operation to the multi</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:merge/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:merge/0\">merge</a> :: (map -&gt; <a href=\"#t:t/0\">t</a>) | {module, atom, [any]}</code></pre> </div> <div id=\"t:name/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:name/0\">name</a> :: any</code></pre> </div> <div id=\"t:run/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:run/0\">run</a> ::\n  (<a href=\"#t:t/0\">t</a> -&gt; {:ok | :error, any}) |\n  {module, atom, [any]}</code></pre> </div> <div id=\"t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a></code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"append/2\">  <span class=\"signature\">append(lhs, rhs)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">append(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Appends the second multi to the first one.</p> <p>All names must be unique between both structures.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; lhs = Ecto.Multi.new |&gt; Ecto.Multi.run(:left, &amp;{:ok, &amp;1})\niex&gt; rhs = Ecto.Multi.new |&gt; Ecto.Multi.run(:right, &amp;{:error, &amp;1})\niex&gt; Ecto.Multi.append(lhs, rhs) |&gt; Ecto.Multi.to_list |&gt; Keyword.keys\n[:left, :right]</code></pre>    <h3 class=\"detail-header function\" id=\"delete/4\">  <span class=\"signature\">delete(multi, name, changeset_or_struct, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete(<a href=\"#t:t/0\">t</a>, <a href=\"#t:name/0\">name</a>, <a href=\"ecto.changeset#t:t/0\">Ecto.Changeset.t</a> | <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Adds a delete operation to the multi.</p> <p>Accepts the same arguments and options as <code class=\"inline\">Ecto.Repo.delete/3</code> does.</p>    <h3 class=\"detail-header function\" id=\"delete_all/4\">  <span class=\"signature\">delete_all(multi, name, queryable, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete_all(<a href=\"#t:t/0\">t</a>, <a href=\"#t:name/0\">name</a>, <a href=\"ecto.queryable#t:t/0\">Ecto.Queryable.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Adds a delete_all operation to the multi.</p> <p>Accepts the same arguments and options as <code class=\"inline\">Ecto.Repo.delete_all/4</code> does.</p>    <h3 class=\"detail-header function\" id=\"insert/4\">  <span class=\"signature\">insert(multi, name, changeset_or_struct, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">insert(<a href=\"#t:t/0\">t</a>, <a href=\"#t:name/0\">name</a>, <a href=\"ecto.changeset#t:t/0\">Ecto.Changeset.t</a> | <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Adds an insert operation to the multi.</p> <p>Accepts the same arguments and options as <code class=\"inline\">Ecto.Repo.insert/3</code> does.</p>    <h3 class=\"detail-header function\" id=\"insert_all/5\">  <span class=\"signature\">insert_all(multi, name, schema_or_source, entries, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">insert_all(<a href=\"#t:t/0\">t</a>, <a href=\"#t:name/0\">name</a>, schema_or_source, [entry], <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a> when schema_or_source: binary | {binary | nil, binary} | <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a>, entry: map | <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a></code></pre>    <p>Adds an insert_all operation to the multi.</p> <p>Accepts the same arguments and options as <code class=\"inline\">Ecto.Repo.insert_all/4</code> does.</p>    <h3 class=\"detail-header function\" id=\"merge/2\">  <span class=\"signature\">merge(multi, merge)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">merge(<a href=\"#t:t/0\">t</a>, <a href=\"#t:merge/0\">merge</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Merges a dynamically created multi</p> <p>The function should return an Ecto.Multi, and receives changes so far as an argument.</p> <p>Duplicated operations are not allowed.</p>    <h3 class=\"detail-header function\" id=\"merge/4\">  <span class=\"signature\">merge(multi, mod, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">merge(<a href=\"#t:t/0\">t</a>, module, function, args) :: <a href=\"#t:t/0\">t</a> when function: atom, args: [any]</code></pre>    <p>Merges a dynamically created multi</p> <p>Similar to <a href=\"#merge/2\"><code class=\"inline\">merge/2</code></a>, but allows to pass module name, function and arguments. The function should return an Ecto.Multi, and receives changes so far as the first argument (prepened to those passed in the call to the function).</p> <p>Duplicated operations are not allowed.</p>    <h3 class=\"detail-header function\" id=\"new/0\">  <span class=\"signature\">new()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns an empty <a href=\"ecto.multi#content\"><code class=\"inline\">Ecto.Multi</code></a> struct.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Ecto.Multi.new |&gt; Ecto.Multi.to_list\n[]</code></pre>    <h3 class=\"detail-header function\" id=\"prepend/2\">  <span class=\"signature\">prepend(lhs, rhs)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">prepend(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Prepends the second multi to the first one.</p> <p>All names must be unique between both structures.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; lhs = Ecto.Multi.new |&gt; Ecto.Multi.run(:left, &amp;{:ok, &amp;1})\niex&gt; rhs = Ecto.Multi.new |&gt; Ecto.Multi.run(:right, &amp;{:error, &amp;1})\niex&gt; Ecto.Multi.prepend(lhs, rhs) |&gt; Ecto.Multi.to_list |&gt; Keyword.keys\n[:right, :left]</code></pre>    <h3 class=\"detail-header function\" id=\"run/3\">  <span class=\"signature\">run(multi, name, run)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">run(<a href=\"#t:t/0\">t</a>, <a href=\"#t:name/0\">name</a>, <a href=\"#t:run/0\">run</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Adds a function to run as part of the multi</p> <p>The function should return either <code class=\"inline\">{:ok, value}</code> or <code class=\"inline\">{:error, value}</code>, and receives changes so far as an argument.</p>    <h3 class=\"detail-header function\" id=\"run/5\">  <span class=\"signature\">run(multi, name, mod, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">run(<a href=\"#t:t/0\">t</a>, <a href=\"#t:name/0\">name</a>, module, function, args) :: <a href=\"#t:t/0\">t</a> when function: atom, args: [any]</code></pre>    <p>Adds a function to run as part of the multi</p> <p>Similar to <a href=\"#run/3\"><code class=\"inline\">run/3</code></a>, but allows to pass module name, function and arguments. The function should return either <code class=\"inline\">{:ok, value}</code> or <code class=\"inline\">{:error, value}</code>, and will receive changes so far as the first argument (prepened to those passed in the call to the function).</p>    <h3 class=\"detail-header function\" id=\"to_list/1\">  <span class=\"signature\">to_list(multi)</span>  </h3>  <p>Transforms the <a href=\"ecto.multi#content\"><code class=\"inline\">Ecto.Multi</code></a> into a list of operations to be performed. Inspecting the <a href=\"ecto.multi#content\"><code class=\"inline\">Ecto.Multi</code></a> struct internals directly is discouraged.</p>    <h3 class=\"detail-header function\" id=\"update/4\">  <span class=\"signature\">update(multi, name, changeset, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update(<a href=\"#t:t/0\">t</a>, <a href=\"#t:name/0\">name</a>, <a href=\"ecto.changeset#t:t/0\">Ecto.Changeset.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Adds an update operation to the multi.</p> <p>Accepts the same arguments and options as <code class=\"inline\">Ecto.Repo.update/2</code> does.</p>    <h3 class=\"detail-header function\" id=\"update_all/5\">  <span class=\"signature\">update_all(multi, name, queryable, updates, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update_all(<a href=\"#t:t/0\">t</a>, <a href=\"#t:name/0\">name</a>, <a href=\"ecto.queryable#t:t/0\">Ecto.Queryable.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Adds an update_all operation to the multi.</p> <p>Accepts the same arguments and options as <code class=\"inline\">Ecto.Repo.update_all/4</code> does.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Multi.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Multi.html</a>\n  </p>\n</div>\n","ecto/ecto.time":"<h1>  Ecto.Time  </h1>  <p>An Ecto type for time.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#cast/1\">cast(t)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Casts the given value to time</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cast!/1\">cast!(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#cast/1\"><code class=\"inline\">cast/1</code></a> but raises <a href=\"ecto.casterror\"><code class=\"inline\">Ecto.CastError</code></a> on invalid times</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compare/2\">compare(t1, t2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compare two times</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dump/1\">dump(arg1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a> into a time tuple (in the form <code class=\"inline\">{hour, min, sec,\nusec}</code>)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_erl/1\">from_erl(arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a> from an Erlang time tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#load/1\">load(time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a time tuple like the one returned by <a href=\"#dump/1\"><code class=\"inline\">dump/1</code></a> into an <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_erl/1\">to_erl(time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an Erlang time tuple from an <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_iso8601/1\">to_iso8601(time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a> to its ISO 8601 representation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a> to a string representation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#type/0\">type()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The Ecto primitive type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#utc/1\">utc(precision \\\\ :sec)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a> in UTC</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"cast/1\">  <span class=\"signature\">cast(t)</span>  </h3>  <p>Casts the given value to time.</p> <p>It supports:</p> <ul> <li>a binary in the “HH:MM:SS” format (may be followed by “Z”, as in <code class=\"inline\">12:00:00Z</code>) </li> <li>a binary in the “HH:MM:SS.USEC” format (may be followed by “Z”, as in <code class=\"inline\">12:00:00.005Z</code>) </li> <li>a map with <code class=\"inline\">\"hour\"</code>, <code class=\"inline\">\"minute\"</code> keys with <code class=\"inline\">\"second\"</code> and <code class=\"inline\">\"microsecond\"</code> as optional keys and values are integers or binaries </li> <li>a map with <code class=\"inline\">:hour</code>, <code class=\"inline\">:minute</code> keys with <code class=\"inline\">:second</code> and <code class=\"inline\">:microsecond</code> as optional keys and values are integers or binaries </li> <li>a tuple with <code class=\"inline\">{hour, min, sec}</code> as integers or binaries </li> <li>a tuple with <code class=\"inline\">{hour, min, sec, usec}</code> as integers or binaries </li> <li>an <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a> struct itself </li> </ul>    <h3 class=\"detail-header function\" id=\"cast!/1\">  <span class=\"signature\">cast!(value)</span>  </h3>  <p>Same as <a href=\"#cast/1\"><code class=\"inline\">cast/1</code></a> but raises <a href=\"ecto.casterror\"><code class=\"inline\">Ecto.CastError</code></a> on invalid times.</p>    <h3 class=\"detail-header function\" id=\"compare/2\">  <span class=\"signature\">compare(t1, t2)</span>  </h3>  <p>Compare two times.</p> <p>Receives two times and compares the <code class=\"inline\">t1</code> against <code class=\"inline\">t2</code> and returns <code class=\"inline\">:lt</code>, <code class=\"inline\">:eq</code> or <code class=\"inline\">:gt</code>.</p>    <h3 class=\"detail-header function\" id=\"dump/1\">  <span class=\"signature\">dump(arg1)</span>  </h3>  <p>Converts an <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a> into a time tuple (in the form <code class=\"inline\">{hour, min, sec,\nusec}</code>).</p>    <h3 class=\"detail-header function\" id=\"from_erl/1\">  <span class=\"signature\">from_erl(arg)</span>  </h3>  <p>Returns an <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a> from an Erlang time tuple.</p>    <h3 class=\"detail-header function\" id=\"load/1\">  <span class=\"signature\">load(time)</span>  </h3>  <p>Converts a time tuple like the one returned by <a href=\"#dump/1\"><code class=\"inline\">dump/1</code></a> into an <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a>.</p>    <h3 class=\"detail-header function\" id=\"to_erl/1\">  <span class=\"signature\">to_erl(time)</span>  </h3>  <p>Returns an Erlang time tuple from an <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a>.</p>    <h3 class=\"detail-header function\" id=\"to_iso8601/1\">  <span class=\"signature\">to_iso8601(time)</span>  </h3>  <p>Converts <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a> to its ISO 8601 representation.</p>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(time)</span>  </h3>  <p>Converts <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a> to a string representation.</p>    <h3 class=\"detail-header function\" id=\"type/0\">  <span class=\"signature\">type()</span>  </h3>  <p>The Ecto primitive type.</p>    <h3 class=\"detail-header function\" id=\"utc/1\">  <span class=\"signature\">utc(precision \\\\ :sec)</span>  </h3>  <p>Returns an <a href=\"ecto.time#content\"><code class=\"inline\">Ecto.Time</code></a> in UTC.</p> <p><code class=\"inline\">precision</code> can be <code class=\"inline\">:sec</code> or <code class=\"inline\">:usec.</code></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Time.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Time.html</a>\n  </p>\n</div>\n","ecto/ecto.casterror":"<h1>  Ecto.CastError <small>exception</small>  </h1>  <p>Raised when a changeset can’t cast a value.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.CastError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.CastError.html</a>\n  </p>\n</div>\n","ecto/ecto.changeerror":"<h1>  Ecto.ChangeError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.ChangeError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.ChangeError.html</a>\n  </p>\n</div>\n","ecto/ecto.migrationerror":"<h1>  Ecto.MigrationError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.MigrationError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.MigrationError.html</a>\n  </p>\n</div>\n","ecto/ecto.constrainterror":"<h1>  Ecto.ConstraintError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.ConstraintError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.ConstraintError.html</a>\n  </p>\n</div>\n","ecto/ecto.query.casterror":"<h1>  Ecto.Query.CastError <small>exception</small>  </h1>  <p>Raised at runtime when a value cannot be cast.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Query.CastError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Query.CastError.html</a>\n  </p>\n</div>\n","ecto/ecto.queryerror":"<h1>  Ecto.QueryError <small>exception</small>  </h1>  <p>Raised at runtime when the query is invalid.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.QueryError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.QueryError.html</a>\n  </p>\n</div>\n","ecto/ecto.noprimarykeyfielderror":"<h1>  Ecto.NoPrimaryKeyFieldError <small>exception</small>  </h1>  <p>Raised at runtime when an operation that requires a primary key is invoked with a schema that does not define a primary key by using <code class=\"inline\">@primary_key false</code></p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.NoPrimaryKeyFieldError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.NoPrimaryKeyFieldError.html</a>\n  </p>\n</div>\n","ecto/ecto.noprimarykeyvalueerror":"<h1>  Ecto.NoPrimaryKeyValueError <small>exception</small>  </h1>  <p>Raised at runtime when an operation that requires a primary key is invoked with a schema missing value for its primary key</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.NoPrimaryKeyValueError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.NoPrimaryKeyValueError.html</a>\n  </p>\n</div>\n","ecto/ecto.datatype":"<h1>  Ecto.DataType <small>protocol</small>  </h1>  <p>Casts and dumps a given struct into an Ecto type.</p> <p>While <a href=\"ecto.type\"><code class=\"inline\">Ecto.Type</code></a> allows developers to cast/load/dump any value from the storage into the struct based on the schema, <a href=\"ecto.datatype#content\"><code class=\"inline\">Ecto.DataType</code></a> allows developers to convert existing data types into existing Ecto types without the schema information.</p> <p>For example, <a href=\"ecto.date\"><code class=\"inline\">Ecto.Date</code></a> is a custom type, represented by the <code class=\"inline\">%Ecto.Date{}</code> struct that can be used in place of Ecto’s primitive <code class=\"inline\">:date</code> type. Therefore, we need to tell Ecto how to convert <code class=\"inline\">%Ecto.Date{}</code> into <code class=\"inline\">:date</code>, even in the absence of schema information, and such is done with the <a href=\"ecto.datatype#content\"><code class=\"inline\">Ecto.DataType</code></a> protocol:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defimpl Ecto.DataType, for: Ecto.Date do\n  # Dumps to the default representation. In this case, :date.\n  def dump(value) do\n    cast(value, :date)\n  end\n\n  # Implement any other desired casting rule.\n  def cast(%Ecto.Date{day: day, month: month, year: year}, :date) do\n    {:ok, {year, month, day}}\n  end\n\n  def cast(_, _) do\n    :error\n  end\nend</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#cast/2\">cast(value, type)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked when attempting to cast this data structure to another type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dump/1\">dump(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked when the data structure has not been cast along the way and must fallback to its database representation</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: term</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"cast/2\">  <span class=\"signature\">cast(value, type)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cast(term, <a href=\"ecto.type#t:t/0\">Ecto.Type.t</a>) :: {:ok, term} | :error</code></pre>    <p>Invoked when attempting to cast this data structure to another type.</p>    <h3 class=\"detail-header function\" id=\"dump/1\">  <span class=\"signature\">dump(value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">dump(term) :: {:ok, term} | :error</code></pre>    <p>Invoked when the data structure has not been cast along the way and must fallback to its database representation.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.DataType.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.DataType.html</a>\n  </p>\n</div>\n","ecto/ecto.multipleresultserror":"<h1>  Ecto.MultipleResultsError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.MultipleResultsError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.MultipleResultsError.html</a>\n  </p>\n</div>\n","ecto/ecto.noresultserror":"<h1>  Ecto.NoResultsError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.NoResultsError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.NoResultsError.html</a>\n  </p>\n</div>\n","ecto/ecto.query.compileerror":"<h1>  Ecto.Query.CompileError <small>exception</small>  </h1>  <p>Raised at compilation time when the query cannot be compiled.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Query.CompileError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Query.CompileError.html</a>\n  </p>\n</div>\n","ecto/ecto.changeset":"<h1>  Ecto.Changeset  </h1>  <p>Changesets allow filtering, casting, validation and definition of constraints when manipulating structs.</p> <p>There is an example of working with changesets in the introductory documentation in the <a href=\"ecto\"><code class=\"inline\">Ecto</code></a> module. The functions <a href=\"#change/2\"><code class=\"inline\">change/2</code></a> and <a href=\"#cast/3\"><code class=\"inline\">cast/3</code></a> are the usual entry points for creating changesets, while the remaining functions are useful for manipulating them.</p> <h2 id=\"module-validations-and-constraints\" class=\"section-heading\">  Validations and constraints </h2> <p>Ecto changesets provide both validations and constraints which are ultimately turned into errors in case something goes wrong.</p> <p>The difference between them is that validations can be executed without a need to interact with the database and, therefore, are always executed before attempting to insert or update the entry in the database.</p> <p>However, constraints can only be checked in a safe way when performing the operation in the database. As a consequence, validations are always checked before constraints. Constraints won’t even be checked in case validations failed.</p> <p>Let’s see an example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"users\" do\n    field :name\n    field :email\n    field :age, :integer\n  end\n\n  def changeset(user, params \\\\ %{}) do\n    user\n    |&gt; cast(params, [:name, :email, :age])\n    |&gt; validate_required([:name, :email])\n    |&gt; validate_format(:email, ~r/@/)\n    |&gt; validate_inclusion(:age, 18..100)\n    |&gt; unique_constraint(:email)\n  end\nend</code></pre> <p>In the <code class=\"inline\">changeset/2</code> function above, we define three validations - one after another they check that <code class=\"inline\">name</code> and <code class=\"inline\">email</code> fields are present in the changeset, the e-mail is of the specified format, and the age is between 18 and 100 - as well as a unique constraint in the email field.</p> <p>Let’s suppose the e-mail is given but the age is invalid. The changeset would have the following errors:</p> <pre data-language=\"elixir\"><code class=\"elixir\">changeset = User.changeset(%User{}, %{age: 0, email: \"mary@example.com\"})\n{:error, changeset} = Repo.insert(changeset)\nchangeset.errors #=&gt; [age: {\"is invalid\", []}, name: {\"can't be blank\", []}]</code></pre> <p>In this case, we haven’t checked the unique constraint in the e-mail field because the data did not validate. Let’s fix the age and assume, however, that the e-mail already exists in the database:</p> <pre data-language=\"elixir\"><code class=\"elixir\">changeset = User.changeset(%User{}, %{age: 42, email: \"mary@example.com\"})\n{:error, changeset} = Repo.insert(changeset)\nchangeset.errors #=&gt; [email: {\"has already been taken\", []}]</code></pre> <p>Validations and constraints define an explicit boundary when the check happens. By moving constraints to the database, we also provide a safe, correct and data-race free means of checking the user input.</p> <h2 id=\"module-empty-values\" class=\"section-heading\">  Empty values </h2> <p>Many times, the data given on cast needs to be further pruned, specially regarding to empty values. For example, if you are gathering data to be cast from the command line or through an HTML form or any other text based format, it is likely those means cannot express nil values. For those reasons, changesets include the concept of empty values, which are values that will be automatically converted to nil on <a href=\"#cast/3\"><code class=\"inline\">cast/3</code></a>. Those values are stored in the changeset <code class=\"inline\">empty_values</code> field and defaults to <code class=\"inline\">[\"\"]</code>.</p> <h2 id=\"module-the-ecto-changeset-struct\" class=\"section-heading\">  The Ecto.Changeset struct </h2> <p>The fields are:</p> <ul> <li>\n<code class=\"inline\">valid?</code> - Stores if the changeset is valid </li> <li>\n<code class=\"inline\">data</code> - The changeset source data, for example, a struct </li> <li>\n<code class=\"inline\">params</code> - The parameters as given on changeset creation </li> <li>\n<code class=\"inline\">changes</code> - The <code class=\"inline\">changes</code> from parameters that were approved in casting </li> <li>\n<code class=\"inline\">errors</code> - All errors from validations </li> <li>\n<code class=\"inline\">validations</code> - All validations performed in the changeset </li> <li>\n<code class=\"inline\">constraints</code> - All constraints defined in the changeset </li> <li>\n<code class=\"inline\">required</code> - All required fields as a list of atoms </li> <li>\n<code class=\"inline\">filters</code> - Filters (as a map <code class=\"inline\">%{field =&gt; value}</code>) to narrow the scope of update/delete queries </li> <li>\n<code class=\"inline\">action</code> - The action to be performed with the changeset </li> <li>\n<code class=\"inline\">types</code> - Cache of the data’s field types </li> <li>\n<code class=\"inline\">repo</code> - The repository applying the changeset (only set after a Repo function is called) </li> <li>\n<code class=\"inline\">opts</code> - The options given to the repository </li> <li>\n<code class=\"inline\">empty_values</code> - A list of values to be considered empty </li> </ul> <h2 id=\"module-on-replace\" class=\"section-heading\">  On replace </h2> <p>Using changesets you can work with associations as well as with embedded structs. Sometimes related data may be replaced by incoming data and by default Ecto won’t allow such. Such behaviour can be changed when defining the relation by setting <code class=\"inline\">:on_replace</code> option according to the values below:</p> <ul> <li>\n<code class=\"inline\">:raise</code> (default) - do not allow removing association or embedded data via parent changesets, </li> <li>\n<code class=\"inline\">:mark_as_invalid</code> - if attempting to remove the association or embedded data via parent changeset - an error will be added to the parent changeset, and it will be marked as invalid, </li> <li>\n<code class=\"inline\">:nilify</code> - sets owner reference column to <code class=\"inline\">nil</code> (available only for associations), </li> <li>\n<p><code class=\"inline\">:delete</code> - removes the association or related data from the database. This option has to be used carefully. You should consider adding a separate boolean virtual field to the changeset function that will allow you to manually mark it for deletion, as in the example below:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Comment do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"comments\" do\n    field :body, :string\n    field :delete, :boolean, virtual: true\n  end\n\n  def changeset(comment, params) do\n    cast(comment, params, [:body, :delete])\n    |&gt; maybe_mark_for_deletion\n  end\n\n  defp maybe_mark_for_deletion(changeset) do\n    if get_change(changeset, :delete) do\n      %{changeset | action: :delete}\n    else\n      changeset\n    end\n  end\nend</code></pre> </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:action/0\">action()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:constraint/0\">constraint()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:data/0\">data()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:error/0\">error()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:types/0\">types()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#add_error/4\">add_error(changeset, key, message, keys \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds an error to the changeset</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#apply_changes/1\">apply_changes(changeset)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Applies the changeset changes to the changeset data</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#assoc_constraint/3\">assoc_constraint(changeset, assoc, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks the associated field exists</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cast/3\">cast(data, params, allowed)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Applies the given <code class=\"inline\">params</code> as changes for the given <code class=\"inline\">data</code> according to the given set of keys. Returns a changeset</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cast/4\">cast(data, params, required, optional)</a> </dt> <dd class=\"summary-synopsis\">\n<p>WARNING: This function is deprecated in favor of <a href=\"#cast/3\"><code class=\"inline\">cast/3</code></a> + <a href=\"#validate_required/3\"><code class=\"inline\">validate_required/3</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cast_assoc/3\">cast_assoc(changeset, name, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Casts the given association</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cast_embed/3\">cast_embed(changeset, name, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Casts the given embed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#change/2\">change(data, changes \\\\ %{})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Wraps the given data in a changeset or adds changes to a changeset</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#check_constraint/3\">check_constraint(changeset, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks for a check constraint in the given field</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete_change/2\">delete_change(changeset, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes a change with the given key</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#exclusion_constraint/3\">exclusion_constraint(changeset, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks for a exclusion constraint in the given field</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch_change/2\">fetch_change(changeset, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches a change from the given changeset</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch_field/2\">fetch_field(changeset, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches the given field from changes or from the data</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#force_change/3\">force_change(changeset, key, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Forces a change on the given <code class=\"inline\">key</code> with <code class=\"inline\">value</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#foreign_key_constraint/3\">foreign_key_constraint(changeset, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks for foreign key constraint in the given field</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_change/3\">get_change(changeset, key, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets a change or returns a default value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_field/3\">get_field(changeset, key, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets a field from changes or from the data</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#merge/2\">merge(changeset1, changeset2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Merges two changesets</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#no_assoc_constraint/3\">no_assoc_constraint(changeset, assoc, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks the associated field does not exist</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#optimistic_lock/3\">optimistic_lock(data_or_changeset, field, incrementer \\\\ &amp;(&amp;1 + 1))</a> </dt> <dd class=\"summary-synopsis\">\n<p>Applies optimistic locking to the changeset</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#prepare_changes/2\">prepare_changes(changeset, function)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Provides a function to run before emitting changes to the repository</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_assoc/4\">put_assoc(changeset, name, value, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts the given association as change in the changeset</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_change/3\">put_change(changeset, key, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts a change on the given <code class=\"inline\">key</code> with <code class=\"inline\">value</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_embed/4\">put_embed(changeset, name, value, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts the given embed as change in the changeset</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#traverse_errors/2\">traverse_errors(changeset, msg_func)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Traverses changeset errors and applies function to error messages</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unique_constraint/3\">unique_constraint(changeset, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks for a unique constraint in the given field</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update_change/3\">update_change(changeset, key, function)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates a change</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate_acceptance/3\">validate_acceptance(changeset, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Validates the given parameter was given as true</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate_change/3\">validate_change(changeset, field, validator)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Validates the given <code class=\"inline\">field</code> change</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate_change/4\">validate_change(changeset, field, metadata, validator)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stores the validation <code class=\"inline\">metadata</code> and validates the given <code class=\"inline\">field</code> change</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate_confirmation/3\">validate_confirmation(changeset, field, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Validates that the given field matches the confirmation parameter of that field</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate_exclusion/4\">validate_exclusion(changeset, field, data, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Validates a change is not included in the given enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate_format/4\">validate_format(changeset, field, format, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Validates a change has the given format</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate_inclusion/4\">validate_inclusion(changeset, field, data, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Validates a change is included in the given enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate_length/3\">validate_length(changeset, field, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Validates a change is a string or list of the given length</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate_number/3\">validate_number(changeset, field, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Validates the properties of a number</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate_required/3\">validate_required(changeset, fields, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Validates that one or more fields are present in the changeset</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate_subset/4\">validate_subset(changeset, field, data, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Validates a change, of type enum, is a subset of the given enumerable. Like validate_inclusion/4 for lists</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:action/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:action/0\">action</a> :: nil | :insert | :update | :delete | :replace</code></pre> </div> <div id=\"t:constraint/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:constraint/0\">constraint</a> :: %{type: :unique, constraint: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, match: :exact | :suffix, field: atom, message: <a href=\"#t:error/0\">error</a>}</code></pre> </div> <div id=\"t:data/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:data/0\">data</a> :: map</code></pre> </div> <div id=\"t:error/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:error/0\">error</a> :: {<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>}</code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Ecto.Changeset{action: <a href=\"#t:action/0\">action</a>, changes: %{optional(atom) =&gt; term}, constraints: [<a href=\"#t:constraint/0\">constraint</a>], data: <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> | nil, empty_values: term, errors: [{atom, <a href=\"#t:error/0\">error</a>}], filters: %{optional(atom) =&gt; term}, params: %{optional(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) =&gt; term} | nil, prepare: [(<a href=\"#t:t/0\">t</a> -&gt; <a href=\"#t:t/0\">t</a>)], repo: atom | nil, required: [atom], types: nil | %{optional(atom) =&gt; <a href=\"ecto.type#t:t/0\">Ecto.Type.t</a>}, valid?: boolean, validations: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>}</code></pre> </div> <div id=\"t:types/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:types/0\">types</a> :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a> | map</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"add_error/4\">  <span class=\"signature\">add_error(changeset, key, message, keys \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">add_error(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Adds an error to the changeset.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = change(%Post{}, %{title: \"\"})\niex&gt; changeset = add_error(changeset, :title, \"empty\")\niex&gt; changeset.errors\n[title: {\"empty\", []}]\niex&gt; changeset.valid?\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"apply_changes/1\">  <span class=\"signature\">apply_changes(changeset)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">apply_changes(<a href=\"#t:t/0\">t</a>) :: <a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a></code></pre>    <p>Applies the changeset changes to the changeset data.</p> <p>This operation will return the underlying data with changes regardless if the changeset is valid or not.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">apply_changes(changeset)</code></pre>    <h3 class=\"detail-header function\" id=\"assoc_constraint/3\">  <span class=\"signature\">assoc_constraint(changeset, assoc, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">assoc_constraint(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"#t:t/0\">t</a> |\n  no_return</code></pre>    <p>Checks the associated field exists.</p> <p>This is similar to <a href=\"#foreign_key_constraint/3\"><code class=\"inline\">foreign_key_constraint/3</code></a> except that the field is inflected from the association definition. This is useful to guarantee that a child will only be created if the parent exists in the database too. Therefore, it only applies to <code class=\"inline\">belongs_to</code> associations.</p> <p>As the name says, a constraint is required in the database for this function to work. Such constraint is often added as a reference to the child table:</p> <pre data-language=\"elixir\"><code class=\"elixir\">create table(:comments) do\n  add :post_id, references(:posts)\nend</code></pre> <p>Now, when inserting a comment, it is possible to forbid any comment to be added if the associated post does not exist:</p> <pre data-language=\"elixir\"><code class=\"elixir\">comment\n|&gt; Ecto.Changeset.cast(params, [:post_id])\n|&gt; Ecto.Changeset.assoc_constraint(:post)\n|&gt; Repo.insert</code></pre> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message in case the constraint check fails, defaults to “does not exist” </li> <li>\n<code class=\"inline\">:name</code> - the constraint name. By default, the constraint name is inflected from the table + association field. May be required explicitly for complex cases </li> </ul>    <h3 class=\"detail-header function\" id=\"cast/3\">  <span class=\"signature\">cast(data, params, allowed)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cast(<a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> | <a href=\"#t:t/0\">t</a> | {<a href=\"#t:data/0\">data</a>, <a href=\"#t:types/0\">types</a>}, %{optional(binary) =&gt; term} | %{optional(atom) =&gt; term} | :invalid, [<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a> | atom]) ::\n  <a href=\"#t:t/0\">t</a> |\n  no_return</code></pre>    <p>Applies the given <code class=\"inline\">params</code> as changes for the given <code class=\"inline\">data</code> according to the given set of keys. Returns a changeset.</p> <p>The given <code class=\"inline\">data</code> may be either a changeset, a struct or a <code class=\"inline\">{data, types}</code> tuple. The second argument is a map of <code class=\"inline\">params</code> that are cast according to the type information from <code class=\"inline\">data</code>. <code class=\"inline\">params</code> is a map with string keys or a map with atom keys containing potentially unsafe data.</p> <p>During casting, all <code class=\"inline\">allowed</code> parameters will have their key name converted to an atom and stored as a change in the <code class=\"inline\">:changes</code> field of the changeset. All parameters that are not explicitly allowed are ignored.</p> <p>If casting of all fields is successful, the changeset is returned as valid.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = cast(post, params, [:title])\niex&gt; if changeset.valid? do\n...&gt;   Repo.update!(changeset)\n...&gt; end</code></pre> <p>Passing a changeset as the first argument:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = cast(post, %{title: \"Hello\"}, [:title])\niex&gt; new_changeset = cast(changeset, %{title: \"Foo\", body: \"Bar\"}, [:body])\niex&gt; new_changeset.params\n%{\"title\" =&gt; \"Foo\", \"body\" =&gt; \"Bar\"}</code></pre> <p>Or creating a changeset from a simple map with types:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; data = %{title: \"hello\"}\niex&gt; types = %{title: :string}\niex&gt; changeset = cast({data, types}, %{title: \"world\"}, [:title])\niex&gt; apply_changes(changeset)\n%{title: \"world\"}</code></pre> <h4>Composing casts</h4> <p><a href=\"#cast/3\"><code class=\"inline\">cast/3</code></a> also accepts a changeset as its first argument. In such cases, all the effects caused by the call to <a href=\"#cast/3\"><code class=\"inline\">cast/3</code></a> (additional errors and changes) are simply added to the ones already present in the argument changeset. Parameters are merged (<strong>not deep-merged</strong>) and the ones passed to <a href=\"#cast/3\"><code class=\"inline\">cast/3</code></a> take precedence over the ones already in the changeset.</p>    <h3 class=\"detail-header function\" id=\"cast/4\">  <span class=\"signature\">cast(data, params, required, optional)</span>  </h3>  <p>WARNING: This function is deprecated in favor of <a href=\"#cast/3\"><code class=\"inline\">cast/3</code></a> + <a href=\"#validate_required/3\"><code class=\"inline\">validate_required/3</code></a>.</p> <p>Converts the given <code class=\"inline\">params</code> into a changeset for <code class=\"inline\">data</code> keeping only the set of <code class=\"inline\">required</code> and <code class=\"inline\">optional</code> keys.</p>    <h3 class=\"detail-header function\" id=\"cast_assoc/3\">  <span class=\"signature\">cast_assoc(changeset, name, opts \\\\ [])</span>  </h3>  <p>Casts the given association.</p> <p>The parameters for the given association will be retrieved from <code class=\"inline\">changeset.params</code> and the changeset function in the association module will be invoked. The function to be invoked may also be configured by using the <code class=\"inline\">:with</code> option.</p> <p>The changeset must have been previously <code class=\"inline\">cast</code> using <a href=\"#cast/3\"><code class=\"inline\">cast/3</code></a> before this function is invoked.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:with</code> - the function to build the changeset from params. Defaults to the changeset/2 function in the association module </li> <li>\n<code class=\"inline\">:required</code> - if the association is a required field </li> <li>\n<code class=\"inline\">:required_message</code> - the message on failure, defaults to “can’t be blank” </li> <li>\n<code class=\"inline\">:invalid_message</code> - the message on failure, defaults to “is invalid” </li> </ul>    <h3 class=\"detail-header function\" id=\"cast_embed/3\">  <span class=\"signature\">cast_embed(changeset, name, opts \\\\ [])</span>  </h3>  <p>Casts the given embed.</p> <p>The parameters for the given embed will be retrieved from <code class=\"inline\">changeset.params</code> and the changeset function in the embed module will be invoked. The function to be invoked may also be configured by using the <code class=\"inline\">:with</code> option.</p> <p>The changeset must have been previously <code class=\"inline\">cast</code> using <a href=\"#cast/3\"><code class=\"inline\">cast/3</code></a> before this function is invoked.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:with</code> - the function to build the changeset from params. Defaults to the changeset/2 function in the embed module </li> <li>\n<code class=\"inline\">:required</code> - if the embed is a required field </li> <li>\n<code class=\"inline\">:required_message</code> - the message on failure, defaults to “can’t be blank” </li> <li>\n<code class=\"inline\">:invalid_message</code> - the message on failure, defaults to “is invalid” </li> </ul>    <h3 class=\"detail-header function\" id=\"change/2\">  <span class=\"signature\">change(data, changes \\\\ %{})</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">change(<a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> | <a href=\"#t:t/0\">t</a> | {<a href=\"#t:data/0\">data</a>, <a href=\"#t:types/0\">types</a>}, %{optional(atom) =&gt; term} | <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"#t:t/0\">t</a> |\n  no_return</code></pre>    <p>Wraps the given data in a changeset or adds changes to a changeset.</p> <p>Changed attributes will only be added if the change does not have the same value as the field in the data.</p> <p>This function is useful for:</p> <ul> <li>wrapping a struct inside a changeset </li> <li>directly changing a struct without performing castings nor validations </li> <li>directly bulk-adding changes to a changeset </li> </ul> <p>Since neither validation nor casting is performed, <a href=\"#change/2\"><code class=\"inline\">change/2</code></a> expects the keys in <code class=\"inline\">changes</code> to be atoms. <code class=\"inline\">changes</code> can be a map as well as a keyword list.</p> <p>When a changeset is passed as the first argument, the changes passed as the second argument are merged over the changes already in the changeset if they differ from the values in the struct. If <code class=\"inline\">changes</code> is an empty map, this function is a no-op.</p> <p>When a <code class=\"inline\">{data, types}</code> is passed as the first argument, a changeset is created with the given data and types and marked as valid.</p> <p>See <a href=\"#cast/3\"><code class=\"inline\">cast/3</code></a> if you’d prefer to cast and validate external parameters.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = change(%Post{})\n%Ecto.Changeset{...}\niex&gt; changeset.valid?\ntrue\niex&gt; changeset.changes\n%{}\n\niex&gt; changeset = change(%Post{author: \"bar\"}, title: \"title\")\niex&gt; changeset.changes\n%{title: \"title\"}\n\niex&gt; changeset = change(%Post{title: \"title\"}, title: \"title\")\niex&gt; changeset.changes\n%{}\n\niex&gt; changeset = change(changeset, %{title: \"new title\", body: \"body\"})\niex&gt; changeset.changes.title\n\"new title\"\niex&gt; changeset.changes.body\n\"body\"</code></pre>    <h3 class=\"detail-header function\" id=\"check_constraint/3\">  <span class=\"signature\">check_constraint(changeset, field, opts \\\\ [])</span>  </h3>  <p>Checks for a check constraint in the given field.</p> <p>The check constraint works by relying on the database to check if the check constraint has been violated or not and, if so, Ecto converts it into a changeset error.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message in case the constraint check fails. Defaults to “is invalid” </li> <li>\n<code class=\"inline\">:name</code> - the name of the constraint. Required. </li> <li>\n<code class=\"inline\">:match</code> - how the changeset constraint name it matched against the repo constraint, may be <code class=\"inline\">:exact</code> or <code class=\"inline\">:suffix</code>. Default is <code class=\"inline\">:exact</code>. <code class=\"inline\">:suffix</code> matches any repo constraint which <code class=\"inline\">ends_with?</code> <code class=\"inline\">:name</code> to this changeset constraint. </li> </ul>    <h3 class=\"detail-header function\" id=\"delete_change/2\">  <span class=\"signature\">delete_change(changeset, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete_change(<a href=\"#t:t/0\">t</a>, atom) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Deletes a change with the given key.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = change(%Post{}, %{title: \"foo\"})\niex&gt; changeset = delete_change(changeset, :title)\niex&gt; get_change(changeset, :title)\nnil</code></pre>    <h3 class=\"detail-header function\" id=\"exclusion_constraint/3\">  <span class=\"signature\">exclusion_constraint(changeset, field, opts \\\\ [])</span>  </h3>  <p>Checks for a exclusion constraint in the given field.</p> <p>The exclusion constraint works by relying on the database to check if the exclusion constraint has been violated or not and, if so, Ecto converts it into a changeset error.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message in case the constraint check fails, defaults to “violates an exclusion constraint” </li> <li>\n<code class=\"inline\">:name</code> - the constraint name. By default, the constraint name is inflected from the table + field. May be required explicitly for complex cases </li> <li>\n<code class=\"inline\">:match</code> - how the changeset constraint name it matched against the repo constraint, may be <code class=\"inline\">:exact</code> or <code class=\"inline\">:suffix</code>. Default is <code class=\"inline\">:exact</code>. <code class=\"inline\">:suffix</code> matches any repo constraint which <code class=\"inline\">ends_with?</code> <code class=\"inline\">:name</code> to this changeset constraint. </li> </ul>    <h3 class=\"detail-header function\" id=\"fetch_change/2\">  <span class=\"signature\">fetch_change(changeset, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch_change(<a href=\"#t:t/0\">t</a>, atom) :: {:ok, term} | :error</code></pre>    <p>Fetches a change from the given changeset.</p> <p>This function only looks at the <code class=\"inline\">:changes</code> field of the given <code class=\"inline\">changeset</code> and returns <code class=\"inline\">{:ok, value}</code> if the change is present or <code class=\"inline\">:error</code> if it’s not.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = change(%Post{body: \"foo\"}, %{title: \"bar\"})\niex&gt; fetch_change(changeset, :title)\n{:ok, \"bar\"}\niex&gt; fetch_change(changeset, :body)\n:error</code></pre>    <h3 class=\"detail-header function\" id=\"fetch_field/2\">  <span class=\"signature\">fetch_field(changeset, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch_field(<a href=\"#t:t/0\">t</a>, atom) ::\n  {:changes, term} |\n  {:data, term} |\n  :error</code></pre>    <p>Fetches the given field from changes or from the data.</p> <p>While <a href=\"#fetch_change/2\"><code class=\"inline\">fetch_change/2</code></a> only looks at the current <code class=\"inline\">changes</code> to retrieve a value, this function looks at the changes and then falls back on the data, finally returning <code class=\"inline\">:error</code> if no value is available.</p> <p>For relations, this functions will return the changeset original data with changes applied. To retrieve raw changesets, please use <a href=\"#fetch_change/2\"><code class=\"inline\">fetch_change/2</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; post = %Post{title: \"Foo\", body: \"Bar baz bong\"}\niex&gt; changeset = change(post, %{title: \"New title\"})\niex&gt; fetch_field(changeset, :title)\n{:changes, \"New title\"}\niex&gt; fetch_field(changeset, :body)\n{:data, \"Bar baz bong\"}\niex&gt; fetch_field(changeset, :not_a_field)\n:error</code></pre>    <h3 class=\"detail-header function\" id=\"force_change/3\">  <span class=\"signature\">force_change(changeset, key, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">force_change(<a href=\"#t:t/0\">t</a>, atom, term) :: <a href=\"#t:t/0\">t</a> | no_return</code></pre>    <p>Forces a change on the given <code class=\"inline\">key</code> with <code class=\"inline\">value</code>.</p> <p>If the change is already present, it is overridden with the new value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = change(%Post{author: \"bar\"}, %{title: \"foo\"})\niex&gt; changeset = force_change(changeset, :title, \"bar\")\niex&gt; changeset.changes\n%{title: \"bar\"}\n\niex&gt; changeset = force_change(changeset, :author, \"bar\")\niex&gt; changeset.changes\n%{title: \"bar\", author: \"bar\"}</code></pre>    <h3 class=\"detail-header function\" id=\"foreign_key_constraint/3\">  <span class=\"signature\">foreign_key_constraint(changeset, field, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">foreign_key_constraint(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Checks for foreign key constraint in the given field.</p> <p>The foreign key constraint works by relying on the database to check if the associated data exists or not. This is useful to guarantee that a child will only be created if the parent exists in the database too.</p> <p>In order to use the foreign key constraint the first step is to define the foreign key in a migration. This is often done with references. For example, imagine you are creating a comments table that belongs to posts. One would have:</p> <pre data-language=\"elixir\"><code class=\"elixir\">create table(:comments) do\n  add :post_id, references(:posts)\nend</code></pre> <p>By default, Ecto will generate a foreign key constraint with name “comments_post_id_fkey” (the name is configurable).</p> <p>Now that a constraint exists, when creating comments, we could annotate the changeset with foreign key constraint so Ecto knows how to convert it into an error message:</p> <pre data-language=\"elixir\"><code class=\"elixir\">cast(comment, params, [:post_id])\n|&gt; foreign_key_constraint(:post_id)</code></pre> <p>Now, when invoking <code class=\"inline\">Repo.insert/2</code> or <code class=\"inline\">Repo.update/2</code>, if the associated post does not exist, it will be converted into an error and <code class=\"inline\">{:error, changeset}</code> returned by the repository.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message in case the constraint check fails, defaults to “does not exist” </li> <li>\n<code class=\"inline\">:name</code> - the constraint name. By default, the constraint name is inflected from the table + field. May be required explicitly for complex cases </li> </ul>    <h3 class=\"detail-header function\" id=\"get_change/3\">  <span class=\"signature\">get_change(changeset, key, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_change(<a href=\"#t:t/0\">t</a>, atom, term) :: term</code></pre>    <p>Gets a change or returns a default value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = change(%Post{body: \"foo\"}, %{title: \"bar\"})\niex&gt; get_change(changeset, :title)\n\"bar\"\niex&gt; get_change(changeset, :body)\nnil</code></pre>    <h3 class=\"detail-header function\" id=\"get_field/3\">  <span class=\"signature\">get_field(changeset, key, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_field(<a href=\"#t:t/0\">t</a>, atom, term) :: term</code></pre>    <p>Gets a field from changes or from the data.</p> <p>While <a href=\"#get_change/3\"><code class=\"inline\">get_change/3</code></a> only looks at the current <code class=\"inline\">changes</code> to retrieve a value, this function looks at the changes and then falls back on the data, finally returning <code class=\"inline\">default</code> if no value is available.</p> <p>For relations this functions will return the changeset data with changes applied. To retrieve raw changesets, please use <a href=\"#get_change/3\"><code class=\"inline\">get_change/3</code></a>.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; post = %Post{title: \"A title\", body: \"My body is a cage\"}\niex&gt; changeset = change(post, %{title: \"A new title\"})\niex&gt; get_field(changeset, :title)\n\"A new title\"\niex&gt; get_field(changeset, :not_a_field, \"Told you, not a field!\")\n\"Told you, not a field!\"</code></pre>    <h3 class=\"detail-header function\" id=\"merge/2\">  <span class=\"signature\">merge(changeset1, changeset2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">merge(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a> | no_return</code></pre>    <p>Merges two changesets.</p> <p>This function merges two changesets provided they have been applied to the same data (their <code class=\"inline\">:data</code> field is equal); if the data differs, an <code class=\"inline\">ArgumentError</code> exception is raised. If one of the changesets has a <code class=\"inline\">:repo</code> field which is not <code class=\"inline\">nil</code>, then the value of that field is used as the <code class=\"inline\">:repo</code> field of the resulting changeset; if both changesets have a non-<code class=\"inline\">nil</code> and different <code class=\"inline\">:repo</code> field, an <code class=\"inline\">ArgumentError</code> exception is raised.</p> <p>The other fields are merged with the following criteria:</p> <ul> <li>\n<code class=\"inline\">params</code> - params are merged (not deep-merged) giving precedence to the params of <code class=\"inline\">changeset2</code> in case of a conflict. If both changesets have their <code class=\"inline\">:params</code> fields set to <code class=\"inline\">nil</code>, the resulting changeset will have its params set to <code class=\"inline\">nil</code> too. </li> <li>\n<code class=\"inline\">changes</code> - changes are merged giving precedence to the <code class=\"inline\">changeset2</code> changes. </li> <li>\n<code class=\"inline\">errors</code> and <code class=\"inline\">validations</code> - they are simply concatenated. </li> <li>\n<code class=\"inline\">required</code> - required fields are merged; all the fields that appear in the required list of both changesets are moved to the required list of the resulting changeset. </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset1 = cast(%Post{}, %{title: \"Title\"}, [:title])\niex&gt; changeset2 = cast(%Post{}, %{title: \"New title\", body: \"Body\"}, [:title, :body])\niex&gt; changeset = merge(changeset1, changeset2)\niex&gt; changeset.changes\n%{body: \"Body\", title: \"New title\"}\n\niex&gt; changeset1 = cast(%Post{body: \"Body\"}, %{title: \"Title\"}, [:title])\niex&gt; changeset2 = cast(%Post{}, %{title: \"New title\"}, [:title])\niex&gt; merge(changeset1, changeset2)\n** (ArgumentError) different :data when merging changesets</code></pre>    <h3 class=\"detail-header function\" id=\"no_assoc_constraint/3\">  <span class=\"signature\">no_assoc_constraint(changeset, assoc, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">no_assoc_constraint(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"#t:t/0\">t</a> |\n  no_return</code></pre>    <p>Checks the associated field does not exist.</p> <p>This is similar to <a href=\"#foreign_key_constraint/3\"><code class=\"inline\">foreign_key_constraint/3</code></a> except that the field is inflected from the association definition. This is useful to guarantee that parent can only be deleted (or have its primary key changed) if no child exists in the database. Therefore, it only applies to <code class=\"inline\">has_*</code> associations.</p> <p>As the name says, a constraint is required in the database for this function to work. Such constraint is often added as a reference to the child table:</p> <pre data-language=\"elixir\"><code class=\"elixir\">create table(:comments) do\n  add :post_id, references(:posts)\nend</code></pre> <p>Now, when deleting the post, it is possible to forbid any post to be deleted if they still have comments attached to it:</p> <pre data-language=\"elixir\"><code class=\"elixir\">post\n|&gt; Ecto.Changeset.change\n|&gt; Ecto.Changeset.no_assoc_constraint(:comments)\n|&gt; Repo.delete</code></pre> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message in case the constraint check fails, defaults to “is still associated to this entry” (for has_one) and “are still associated to this entry” (for has_many) </li> <li>\n<code class=\"inline\">:name</code> - the constraint name. By default, the constraint name is inflected from the association table + association field. May be required explicitly for complex cases </li> </ul>    <h3 class=\"detail-header function\" id=\"optimistic_lock/3\">  <span class=\"signature\">optimistic_lock(data_or_changeset, field, incrementer \\\\ &amp;(&amp;1 + 1))</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">optimistic_lock(<a href=\"ecto.schema#t:t/0\">Ecto.Schema.t</a> | <a href=\"#t:t/0\">t</a>, atom, (integer -&gt; integer)) ::\n  <a href=\"#t:t/0\">t</a> |\n  no_return</code></pre>    <p>Applies optimistic locking to the changeset.</p> <p><a href=\"http://en.wikipedia.org/wiki/Optimistic_concurrency_control\">Optimistic locking</a> (or <em>optimistic concurrency control</em>) is a technique that allows concurrent edits on a single record. While pessimistic locking works by locking a resource for an entire transaction, optimistic locking only checks if the resource changed before updating it.</p> <p>This is done by regularly fetching the record from the database, then checking whether another user has made changes to the record <em>only when updating the record</em>. This behaviour is ideal in situations where the chances of concurrent updates to the same record are low; if they’re not, pessimistic locking or other concurrency patterns may be more suited.</p> <h4>Usage</h4> <p>Optimistic locking works by keeping a “version” counter for each record; this counter gets incremented each time a modification is made to a record. Hence, in order to use optimistic locking, a field must exist in your schema for versioning purpose. Such field is usually an integer but other types are supported.</p> <h4>Examples</h4> <p>Assuming we have a <code class=\"inline\">Post</code> schema (stored in the <code class=\"inline\">posts</code> table), the first step is to add a version column to the <code class=\"inline\">posts</code> table:</p> <pre data-language=\"elixir\"><code class=\"elixir\">alter table(:posts) do\n  add :lock_version, :integer, default: 1\nend</code></pre> <p>The column name is arbitrary and doesn’t need to be <code class=\"inline\">:lock_version</code>. Now add a field to the schema too:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Post do\n  use Ecto.Schema\n\n  schema \"posts\" do\n    field :title, :string\n    field :lock_version, :integer, default: 1\n  end\n\n  def changeset(:update, struct, params \\\\ %{}) do\n    struct\n    |&gt; Ecto.Changeset.cast(params, [:title])\n    |&gt; Ecto.Changeset.optimistic_lock(:lock_version)\n  end\nend</code></pre> <p>Now let’s take optimistic locking for a spin:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; post = Repo.insert!(%Post{title: \"foo\"})\n%Post{id: 1, title: \"foo\", lock_version: 1}\niex&gt; valid_change = Post.changeset(:update, post, %{title: \"bar\"})\niex&gt; stale_change = Post.changeset(:update, post, %{title: \"baz\"})\niex&gt; Repo.update!(valid_change)\n%Post{id: 1, title: \"bar\", lock_version: 2}\niex&gt; Repo.update!(stale_change)\n** (Ecto.StaleEntryError) attempted to update a stale entry:\n\n%Post{id: 1, title: \"baz\", lock_version: 1}</code></pre> <p>When a conflict happens (a record which has been previously fetched is being updated, but that same record has been modified since it was fetched), an <a href=\"ecto.staleentryerror\"><code class=\"inline\">Ecto.StaleEntryError</code></a> exception is raised.</p> <p>Optimistic locking also works with delete operations. Just call the <code class=\"inline\">optimistic_lock</code> function with the data before delete:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = Ecto.Changeset.optimistic_lock(post, :lock_version)\niex&gt; Repo.delete(changeset)</code></pre> <p><a href=\"#optimistic_lock/3\"><code class=\"inline\">optimistic_lock/3</code></a> by default assumes the field being used as a lock is an integer. If you want to use another type, you need to pass the third argument customizing how the next value is generated:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Ecto.Changeset.optimistic_lock(post, :lock_uuid, fn _ -&gt; Ecto.UUID.generate end)</code></pre>    <h3 class=\"detail-header function\" id=\"prepare_changes/2\">  <span class=\"signature\">prepare_changes(changeset, function)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">prepare_changes(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:t/0\">t</a> -&gt; <a href=\"#t:t/0\">t</a>)) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Provides a function to run before emitting changes to the repository.</p> <p>Such function receives the changeset and must return a changeset, allowing developers to do final adjustments to the changeset or to issue data consistency commands.</p> <p>The given function is guaranteed to run inside the same transaction as the changeset operation for databases that do support transactions.</p> <h4>Example</h4> <p>A common use case is updating a counter cache, in this case updating a post’s comment count when a comment is created:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def create_comment(comment, params) do\n  comment\n  |&gt; cast(params, [:body, :post_id])\n  |&gt; prepare_changes(fn changeset -&gt;\n    assoc(changeset.data, :post)\n    |&gt; changeset.repo.update_all(inc: [comment_count: 1])\n    changeset\n  end)\nend</code></pre> <p>We retrieve the repo and from the comment changeset it self, and use update_all to update the counter cache in one query. Finally the original changeset must be returned.</p>    <h3 class=\"detail-header function\" id=\"put_assoc/4\">  <span class=\"signature\">put_assoc(changeset, name, value, opts \\\\ [])</span>  </h3>  <p>Puts the given association as change in the changeset.</p> <p>The given value may either be the association struct, a changeset for the given association or a map or keyword list of changes to be applied to the current association. If a map or keyword list are given and there is no association, one will be created.</p> <p>If the association has no changes, it will be skipped. If the association is invalid, the changeset will be marked as invalid. If the given value is not an association, it will raise.</p>    <h3 class=\"detail-header function\" id=\"put_change/3\">  <span class=\"signature\">put_change(changeset, key, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_change(<a href=\"#t:t/0\">t</a>, atom, term) :: <a href=\"#t:t/0\">t</a> | no_return</code></pre>    <p>Puts a change on the given <code class=\"inline\">key</code> with <code class=\"inline\">value</code>.</p> <p>If the change is already present, it is overridden with the new value, also, if the change has the same value as in the changeset data, it is not added to the list of changes.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = change(%Post{author: \"bar\"}, %{title: \"foo\"})\niex&gt; changeset = put_change(changeset, :title, \"bar\")\niex&gt; changeset.changes\n%{title: \"bar\"}\n\niex&gt; changeset = put_change(changeset, :author, \"bar\")\niex&gt; changeset.changes\n%{title: \"bar\"}</code></pre>    <h3 class=\"detail-header function\" id=\"put_embed/4\">  <span class=\"signature\">put_embed(changeset, name, value, opts \\\\ [])</span>  </h3>  <p>Puts the given embed as change in the changeset.</p> <p>The given value may either be the embed struct, a changeset for the given embed or a map or keyword list of changes to be applied to the current embed. If a map or keyword list are given and there is no embed, one will be created.</p> <p>If the embed has no changes, it will be skipped. If the embed is invalid, the changeset will be marked as invalid. If the given value is not an embed, it will raise.</p>    <h3 class=\"detail-header function\" id=\"traverse_errors/2\">  <span class=\"signature\">traverse_errors(changeset, msg_func)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">traverse_errors(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:error/0\">error</a> -&gt; <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>)) :: %{optional(atom) =&gt; [<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>]}</code></pre>    <p>Traverses changeset errors and applies function to error messages.</p> <p>This function is particularly useful when associations and embeds are cast in the changeset as it will traverse all associations and embeds and place all errors in a series of nested maps.</p> <p>A changeset is supplied along with a function to apply to each error message as the changeset is traversed. The error message function receives an error tuple <code class=\"inline\">{msg, opts}</code>, for example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{\"should be at least %{count} characters\", [count: 3]}</code></pre> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; traverse_errors(changeset, fn {msg, opts} -&gt;\n...&gt;   Enum.reduce(opts, msg, fn {key, value}, acc -&gt;\n...&gt;     String.replace(msg, \"%{#{key}}\", to_string(value))\n...&gt;   end)\n...&gt; end)\n%{title: [\"should be at least 3 characters\"]}</code></pre>    <h3 class=\"detail-header function\" id=\"unique_constraint/3\">  <span class=\"signature\">unique_constraint(changeset, field, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unique_constraint(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Checks for a unique constraint in the given field.</p> <p>The unique constraint works by relying on the database to check if the unique constraint has been violated or not and, if so, Ecto converts it into a changeset error.</p> <p>In order to use the uniqueness constraint the first step is to define the unique index in a migration:</p> <pre data-language=\"elixir\"><code class=\"elixir\">create unique_index(:users, [:email])</code></pre> <p>Now that a constraint exists, when modifying users, we could annotate the changeset with unique constraint so Ecto knows how to convert it into an error message:</p> <pre data-language=\"elixir\"><code class=\"elixir\">cast(user, params, [:email])\n|&gt; unique_constraint(:email)</code></pre> <p>Now, when invoking <code class=\"inline\">Repo.insert/2</code> or <code class=\"inline\">Repo.update/2</code>, if the email already exists, it will be converted into an error and <code class=\"inline\">{:error, changeset}</code> returned by the repository. Note that the error will occur only after hitting the database so it will not be visible until all other validations pass.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message in case the constraint check fails, defaults to “has already been taken” </li> <li>\n<code class=\"inline\">:name</code> - the constraint name. By default, the constraint name is inflected from the table + field. May be required explicitly for complex cases </li> <li>\n<code class=\"inline\">:match</code> - how the changeset constraint name it matched against the repo constraint, may be <code class=\"inline\">:exact</code> or <code class=\"inline\">:suffix</code>. Default is <code class=\"inline\">:exact</code>. <code class=\"inline\">:suffix</code> matches any repo constraint which <code class=\"inline\">ends_with?</code> <code class=\"inline\">:name</code> to this changeset constraint. </li> </ul> <h4>Complex constraints</h4> <p>Because the constraint logic is in the database, we can leverage all the database functionality when defining them. For example, let’s suppose the e-mails are scoped by company id. We would write in a migration:</p> <pre data-language=\"elixir\"><code class=\"elixir\">create unique_index(:users, [:email, :company_id])</code></pre> <p>Because such indexes have usually more complex names, we need to explicitly tell the changeset which constraint name to use:</p> <pre data-language=\"elixir\"><code class=\"elixir\">cast(user, params, [:email])\n|&gt; unique_constraint(:email, name: :posts_special_email_index)</code></pre> <p>Alternatively, you can give both <code class=\"inline\">unique_index</code> and <code class=\"inline\">unique_constraint</code> the same name:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># In the migration\ncreate unique_index(:users, [:email, :company_id], name: :posts_email_company_id_index)\n\n# In the changeset function\ncast(user, params, [:email])\n|&gt; unique_constraint(:email, name: :posts_email_company_id_index)</code></pre> <h4>Case sensitivity</h4> <p>Unfortunately, different databases provide different guarantees when it comes to case-sensitiveness. For example, in MySQL, comparisons are case-insensitive by default. In Postgres, users can define case insensitive column by using the <code class=\"inline\">:citext</code> type/extension.</p> <p>If for some reason your database does not support case insensitive columns, you can explicitly downcase values before inserting/updating them:</p> <pre data-language=\"elixir\"><code class=\"elixir\">cast(data, params, [:email])\n|&gt; update_change(:email, &amp;String.downcase/1)\n|&gt; unique_constraint(:email)</code></pre>    <h3 class=\"detail-header function\" id=\"update_change/3\">  <span class=\"signature\">update_change(changeset, key, function)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update_change(<a href=\"#t:t/0\">t</a>, atom, (term -&gt; term)) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Updates a change.</p> <p>The given <code class=\"inline\">function</code> is invoked with the change value only if there is a change for the given <code class=\"inline\">key</code>. Note that the value of the change can still be <code class=\"inline\">nil</code> (unless the field was marked as required on <a href=\"#cast/3)\"><code class=\"inline\">cast/3</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = change(%Post{}, %{impressions: 1})\niex&gt; changeset = update_change(changeset, :impressions, &amp;(&amp;1 + 1))\niex&gt; changeset.changes.impressions\n2</code></pre>    <h3 class=\"detail-header function\" id=\"validate_acceptance/3\">  <span class=\"signature\">validate_acceptance(changeset, field, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">validate_acceptance(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Validates the given parameter was given as true.</p> <p>This validation is used to check for one specific parameter being true and as such does not require the field to effectively exist in the schema or the data being validated.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message on failure, defaults to “must be accepted” </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">validate_acceptance(changeset, :terms_of_service)\nvalidate_acceptance(changeset, :rules, message: \"please accept rules\")</code></pre>    <h3 class=\"detail-header function\" id=\"validate_change/3\">  <span class=\"signature\">validate_change(changeset, field, validator)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">validate_change(<a href=\"#t:t/0\">t</a>, atom, (atom, term -&gt; [<a href=\"#t:error/0\">error</a>])) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Validates the given <code class=\"inline\">field</code> change.</p> <p>It invokes the <code class=\"inline\">validator</code> function to perform the validation only if a change for the given <code class=\"inline\">field</code> exists and the change value is not <code class=\"inline\">nil</code>. The function must return a list of errors (with an empty list meaning no errors).</p> <p>In case there’s at least one error, the list of errors will be appended to the <code class=\"inline\">:errors</code> field of the changeset and the <code class=\"inline\">:valid?</code> flag will be set to <code class=\"inline\">false</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = change(%Post{}, %{title: \"foo\"})\niex&gt; changeset = validate_change changeset, :title, fn :title, title  -&gt;\n...&gt;   # Value must not be \"foo\"!\n...&gt;   if title == \"foo\" do\n...&gt;     [title: \"cannot be foo\"]\n...&gt;   else\n...&gt;     []\n...&gt;   end\n...&gt; end\niex&gt; changeset.errors\n[title: {\"cannot be foo\", []}]</code></pre>    <h3 class=\"detail-header function\" id=\"validate_change/4\">  <span class=\"signature\">validate_change(changeset, field, metadata, validator)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">validate_change(<a href=\"#t:t/0\">t</a>, atom, term, (atom, term -&gt; [<a href=\"#t:error/0\">error</a>])) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Stores the validation <code class=\"inline\">metadata</code> and validates the given <code class=\"inline\">field</code> change.</p> <p>Similar to <a href=\"#validate_change/3\"><code class=\"inline\">validate_change/3</code></a> but stores the validation metadata into the changeset validators. The validator metadata is often used as a reflection mechanism, to automatically generate code based on the available validations.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; changeset = change(%Post{}, %{title: \"foo\"})\niex&gt; changeset = validate_change changeset, :title, :useless_validator, fn\n...&gt;   _, _ -&gt; []\n...&gt; end\niex&gt; changeset.validations\n[title: :useless_validator]</code></pre>    <h3 class=\"detail-header function\" id=\"validate_confirmation/3\">  <span class=\"signature\">validate_confirmation(changeset, field, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">validate_confirmation(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Validates that the given field matches the confirmation parameter of that field.</p> <p>By calling <code class=\"inline\">validate_confirmation(changeset, :email)</code>, this validation will check if both “email” and “email_confirmation” in the parameter map matches.</p> <p>Note that if the confirmation field is nil or missing, by default this does not add a validation error. You can specify that the confirmation field is required in the options (see below). Note “email_confirmation” does not need to be added as a virtual field in your schema.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message on failure, defaults to “does not match” </li> <li>\n<code class=\"inline\">:required</code> - boolean, sets whether existence of confirmation parameter is required for addition of error. Defaults to false </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">validate_confirmation(changeset, :email)\nvalidate_confirmation(changeset, :password, message: \"does not match password\")\n\ncast(data, params, [:password])\n|&gt; validate_confirmation(:password, message: \"does not match password\")</code></pre>    <h3 class=\"detail-header function\" id=\"validate_exclusion/4\">  <span class=\"signature\">validate_exclusion(changeset, field, data, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">validate_exclusion(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Enum.html#t:t/0\">Enum.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Validates a change is not included in the given enumerable.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message on failure, defaults to “is reserved” </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">validate_exclusion(changeset, :name, ~w(admin superadmin))</code></pre>    <h3 class=\"detail-header function\" id=\"validate_format/4\">  <span class=\"signature\">validate_format(changeset, field, format, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">validate_format(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Regex.html#t:t/0\">Regex.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Validates a change has the given format.</p> <p>The format has to be expressed as a regular expression.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message on failure, defaults to “has invalid format” </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">validate_format(changeset, :email, ~r/@/)</code></pre>    <h3 class=\"detail-header function\" id=\"validate_inclusion/4\">  <span class=\"signature\">validate_inclusion(changeset, field, data, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">validate_inclusion(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Enum.html#t:t/0\">Enum.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Validates a change is included in the given enumerable.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message on failure, defaults to “is invalid” </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">validate_inclusion(changeset, :gender, [\"man\", \"woman\", \"other\", \"prefer not to say\"])\nvalidate_inclusion(changeset, :age, 0..99)</code></pre>    <h3 class=\"detail-header function\" id=\"validate_length/3\">  <span class=\"signature\">validate_length(changeset, field, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">validate_length(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Validates a change is a string or list of the given length.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:is</code> - the length must be exactly this value </li> <li>\n<code class=\"inline\">:min</code> - the length must be greater than or equal to this value </li> <li>\n<code class=\"inline\">:max</code> - the length must be less than or equal to this value </li> <li>\n<p><code class=\"inline\">:message</code> - the message on failure, depending on the validation, is one of:</p> <ul> <li>for strings: </li> <li>“should be %{count} character(s)” </li> <li>“should be at least %{count} character(s)” </li> <li>“should be at most %{count} character(s)” </li> <li>for lists: </li> <li>“should have %{count} item(s)” </li> <li>“should have at least %{count} item(s)” </li> <li>“should have at most %{count} item(s)” </li> </ul> </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">validate_length(changeset, :title, min: 3)\nvalidate_length(changeset, :title, max: 100)\nvalidate_length(changeset, :title, min: 3, max: 100)\nvalidate_length(changeset, :code, is: 9)\nvalidate_length(changeset, :topics, is: 2)</code></pre>    <h3 class=\"detail-header function\" id=\"validate_number/3\">  <span class=\"signature\">validate_number(changeset, field, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">validate_number(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  <a href=\"#t:t/0\">t</a> |\n  no_return</code></pre>    <p>Validates the properties of a number.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:less_than</code> </li> <li>\n<code class=\"inline\">:greater_than</code> </li> <li>\n<code class=\"inline\">:less_than_or_equal_to</code> </li> <li>\n<code class=\"inline\">:greater_than_or_equal_to</code> </li> <li>\n<code class=\"inline\">:equal_to</code> </li> <li>\n<p><code class=\"inline\">:message</code> - the message on failure, defaults to one of:</p> <ul> <li>“must be less than %{count}” </li> <li>“must be greater than %{count}” </li> <li>“must be less than or equal to %{count}” </li> <li>“must be greater than or equal to %{count}” </li> <li>“must be equal to %{count}” </li> </ul> </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">validate_number(changeset, :count, less_than: 3)\nvalidate_number(changeset, :pi, greater_than: 3, less_than: 4)\nvalidate_number(changeset, :the_answer_to_life_the_universe_and_everything, equal_to: 42)</code></pre>    <h3 class=\"detail-header function\" id=\"validate_required/3\">  <span class=\"signature\">validate_required(changeset, fields, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">validate_required(<a href=\"#t:t/0\">t</a>, list | atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Validates that one or more fields are present in the changeset.</p> <p>If the value of a field is <code class=\"inline\">nil</code> or a string made only of whitespace, the changeset is marked as invalid and an error is added. Note the error won’t be added though if the field already has an error.</p> <p>You can pass a single field name or a list of field names that are required.</p> <p>Do not use this function to validate associations are required, instead pass the <code class=\"inline\">:required</code> option to <a href=\"#cast_assoc/3\"><code class=\"inline\">cast_assoc/3</code></a>.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message on failure, defaults to “can’t be blank” </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">validate_required(changeset, :title)\nvalidate_required(changeset, [:title, :body])</code></pre>    <h3 class=\"detail-header function\" id=\"validate_subset/4\">  <span class=\"signature\">validate_subset(changeset, field, data, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">validate_subset(<a href=\"#t:t/0\">t</a>, atom, <a href=\"http://elixir-lang.org/docs/stable/elixir/Enum.html#t:t/0\">Enum.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Validates a change, of type enum, is a subset of the given enumerable. Like validate_inclusion/4 for lists.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:message</code> - the message on failure, defaults to “has an invalid entry” </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">validate_subset(changeset, :pets, [\"cat\", \"dog\", \"parrot\"])\nvalidate_subset(changeset, :lottery_numbers, 0..99)</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Changeset.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Changeset.html</a>\n  </p>\n</div>\n","ecto/ecto.query":"<h1>  Ecto.Query  </h1>  <p>Provides the Query DSL.</p> <p>Queries are used to retrieve and manipulate data from a repository (see <a href=\"ecto.repo.html)\"><code class=\"inline\">Ecto.Repo</code></a>. Ecto queries come in two flavors: keyword-based and macro-based. Most examples will use the keyword-based syntax, the macro one will be explored in later sections.</p> <p>Let’s see a sample query:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Imports only from/2 of Ecto.Query\nimport Ecto.Query, only: [from: 2]\n\n# Create a query\nquery = from u in \"users\",\n          where: u.age &gt; 18,\n          select: u.name\n\n# Send the query to the repository\nRepo.all(query)</code></pre> <p>In the example above, we are directly querying the “users” table from the database.</p> <h2 id=\"module-query-expressions\" class=\"section-heading\">  Query expressions </h2> <p>Ecto allows a limited set of expressions inside queries. In the query below, for example, we use <code class=\"inline\">u.age</code> to access a field, the <code class=\"inline\">&gt;</code> comparison operator and the literal <code class=\"inline\">0</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">query = from u in \"users\", where: u.age &gt; 0, select: u.name</code></pre> <p>You can find the full list of operations in <a href=\"ecto.query.api\"><code class=\"inline\">Ecto.Query.API</code></a>. Besides the operations listed there, the following literals are supported in queries:</p> <ul> <li>Integers: <code class=\"inline\">1</code>, <code class=\"inline\">2</code>, <code class=\"inline\">3</code> </li> <li>Floats: <code class=\"inline\">1.0</code>, <code class=\"inline\">2.0</code>, <code class=\"inline\">3.0</code> </li> <li>Booleans: <code class=\"inline\">true</code>, <code class=\"inline\">false</code> </li> <li>Binaries: <code class=\"inline\">&lt;&lt;1, 2, 3&gt;&gt;</code> </li> <li>Strings: <code class=\"inline\">\"foo bar\"</code>, <code class=\"inline\">~s(this is a string)</code> </li> <li>Arrays: <code class=\"inline\">[1, 2, 3]</code>, <code class=\"inline\">~w(interpolate words)</code> </li> </ul> <p>All other types and dynamic values must be passed as a parameter using interpolation as explained below.</p> <h2 id=\"module-interpolation-and-casting\" class=\"section-heading\">  Interpolation and casting </h2> <p>External values and Elixir expressions can be injected into a query expression with <code class=\"inline\">^</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def with_minimum(age, height_ft) do\n  from u in \"users\",\n    where: u.age &gt; ^age and u.height &gt; ^(height_ft * 3.28),\n    select: u.name\nend\n\nwith_minimum(18, 5.0)</code></pre> <p>When interpolating values, you may want to explicitly tell Ecto what is the expected type of the value being interpolated:</p> <pre data-language=\"elixir\"><code class=\"elixir\">age = \"18\"\nRepo.all(from u in \"users\",\n          where: u.age &gt; type(^age, :integer),\n          select: u.name)</code></pre> <p>In the example above, Ecto will cast the age to type integer. When a value cannot be cast, <a href=\"ecto.query.casterror\"><code class=\"inline\">Ecto.Query.CastError</code></a> is raised.</p> <p>To avoid the repetition of always specifying the types, you may define an <a href=\"ecto.schema\"><code class=\"inline\">Ecto.Schema</code></a>. In such cases, Ecto will analyze your queries and automatically cast the interpolated “age” when compared to the <code class=\"inline\">u.age</code> field, as long as the age field is defined with type <code class=\"inline\">:integer</code> in your schema:</p> <pre data-language=\"elixir\"><code class=\"elixir\">age = \"18\"\nRepo.all(from u in User, where: u.age &gt; ^age, select: u.name)</code></pre> <p>Another advantage of using schemas is that we no longer need to specify the select option in queries, as by default Ecto will retrieve all fields specified in the schema:</p> <pre data-language=\"elixir\"><code class=\"elixir\">age = \"18\"\nRepo.all(from u in User, where: u.age &gt; ^age)</code></pre> <p>For this reason, we will use schemas on the remaining examples but remember Ecto does not require them in order to write queries.</p> <h2 id=\"module-composition\" class=\"section-heading\">  Composition </h2> <p>Ecto queries are composable. For example, the query above can actually be defined in two parts:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Create a query\nquery = from u in User, where: u.age &gt; 18\n\n# Extend the query\nquery = from u in query, select: u.name</code></pre> <p>Composing queries uses the same syntax as creating a query. The difference is that, instead of passing a schema like <code class=\"inline\">Weather</code> on the right side of <code class=\"inline\">in</code>, we passed the query itself.</p> <p>Any value can be used on the right-side of <code class=\"inline\">in</code> as long as it implements the <a href=\"ecto.queryable\"><code class=\"inline\">Ecto.Queryable</code></a> protocol. For now, we know such protocols is implemented for both atoms (like <code class=\"inline\">User</code>) and strings (like “users”).</p> <p>In any case, regardless if a schema has been given or not, Ecto queries are always composable thanks to its binding system.</p> <h3>Query bindings</h3> <p>On the left side of <code class=\"inline\">in</code> we specify the query bindings. This is done inside from and join clauses. In the query below <code class=\"inline\">u</code> is a binding and <code class=\"inline\">u.age</code> is a field access using this binding.</p> <pre data-language=\"elixir\"><code class=\"elixir\">query = from u in User, where: u.age &gt; 18</code></pre> <p>Bindings are not exposed from the query. When composing queries you must specify bindings again for each refinement query. For example to further narrow-down above query we again need to tell Ecto what bindings to expect:</p> <pre data-language=\"elixir\"><code class=\"elixir\">query = from u in query, select: u.city</code></pre> <p>Bindings in Ecto are positional, and the names do not have to be consistent between input and refinement queries. For example, the query above could also be written as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">query = from q in query, select: q.city</code></pre> <p>It would make no difference to Ecto. This is important because it allows developers to compose queries without caring about the bindings used in the initial query.</p> <p>When using joins, the bindings should be matched in the order they are specified:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Create a query\nquery = from p in Post,\n          join: c in Comment, where: c.post_id == p.id\n\n# Extend the query\nquery = from [p, c] in query,\n          select: {p.title, c.body}</code></pre> <p>You are not required to specify all bindings when composing. For example, if we would like to order the results above by post insertion date, we could further extend it as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">query = from q in query, order_by: q.inserted_at</code></pre> <p>The example above will work if the input query has 1 or 10 bindings. In the example above, we will always sort by the <code class=\"inline\">inserted_at</code> column from the <code class=\"inline\">from</code> source.</p> <h3>Bindingless operations</h3> <p>Although bindings are extremely useful when working with joins, they are not necessary when the query has only the <code class=\"inline\">from</code> clause. For such cases, Ecto supports a way for building queries without specifying the binding:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from Post,\n  where: [category: \"fresh and new\"],\n  order_by: [desc: :published_at],\n  select: [:id, :title, :body]</code></pre> <p>The query above will select all posts with category “fresh and new”, order by the most recently published, and return Post structs with only the id, title and body fields set. It is equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post,\n  where: p.category == \"fresh and new\",\n  order_by: [desc: p.published_at],\n  select: struct(p, [:id, :title, :body])</code></pre> <p>One advantage of bindingless queries is that they are data-driven and therefore useful for dynamically building queries. For example, the query above could also be written as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">where = [category: \"fresh and new\"]\norder_by = [desc: :published_at]\nselect = [:id, :title, :body]\nfrom Post, where: ^where, order_by: ^order_by, select: ^select</code></pre> <p>This feature is very useful when queries need to be built based on some user input, like web search forms, CLIs and so on.</p> <h2 id=\"module-fragments\" class=\"section-heading\">  Fragments </h2> <p>If you need an escape hatch, Ecto provides fragments (see <a href=\"ecto.query.api#fragment/1)\"><code class=\"inline\">Ecto.Query.API.fragment/1</code></a> to inject SQL (and non-SQL) fragments into queries.</p> <p>For example, to get all posts while running the “lower(?)” function in the database where <code class=\"inline\">p.title</code> is interpolated in place of <code class=\"inline\">?</code>, one can write:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from p in Post,\n  where: is_nil(p.published_at) and\n         fragment(\"lower(?)\", p.title) == ^title</code></pre> <p>Also, most adapters provide direct APIs for queries, like <a href=\"ecto.adapters.sql#query/4\"><code class=\"inline\">Ecto.Adapters.SQL.query/4</code></a>, allowing developers to completely bypass Ecto queries.</p> <h2 id=\"module-macro-api\" class=\"section-heading\">  Macro API </h2> <p>In all examples so far we have used the <strong>keywords query syntax</strong> to create a query:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import Ecto.Query\nfrom u in \"users\", where: u.age &gt; 18, select: u.name</code></pre> <p>Due to the prevalence of the pipe operator in Elixir, Ecto also supports a pipe-based syntax:</p> <pre data-language=\"elixir\"><code class=\"elixir\">\"users\"\n|&gt; where([u], u.age &gt; 18)\n|&gt; select([u], u.name)</code></pre> <p>The keyword-based and pipe-based examples are equivalent. The downside of using macros is that the binding must be specified for every operation. However, since keyword-based and pipe-based examples are equivalent, the bindingless syntax also works for macros:</p> <pre data-language=\"elixir\"><code class=\"elixir\">\"users\"\n|&gt; where([u], u.age &gt; 18)\n|&gt; select([:name])</code></pre> <p>Such allows developers to write queries using bindings only in more complex query expressions.</p> <p>This module documents each of those macros, providing examples in both the keywords query and pipe expression formats.</p> <h2 id=\"module-query-prefix\" class=\"section-heading\">  Query Prefix </h2> <p>It is possible to set a prefix for the queries. For Postgres users, this will specify the schema where the table is located, while for MySQL users this will specify the database where the table is located. When no prefix is set, Postgres queries are assumed to be in the public schema, while MySQL queries are assumed to be in the database set in the config for the repo.</p> <p>To set the prefix on a query:</p> <pre data-language=\"elixir\"><code class=\"elixir\">results =\n  query # May be User or an Ecto.Query itself\n  |&gt; Ecto.Queryable.to_query\n  |&gt; Map.put(:prefix, \"foo\")\n  |&gt; Repo.all</code></pre> <p>When a prefix is set in a query, all loaded structs will belong to that prefix, so operations like update and delete will be applied to the proper prefix. In case you want to manually set the prefix for new data, specially on insert, use <a href=\"ecto#put_meta/2\"><code class=\"inline\">Ecto.put_meta/2</code></a>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exclude/2\">exclude(query, field)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Resets a previously set field on a query</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#first/2\">first(queryable, order_by \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Restricts the query to return the first result ordered by primary key</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#last/2\">last(queryable, order_by \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Restricts the query to return the last result ordered by primary key</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subquery/1\">subquery(subquery)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a query into a subquery</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#distinct/3\">distinct(query, binding \\\\ [], expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A distinct query expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from/2\">from(expr, kw \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a query</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#group_by/3\">group_by(query, binding \\\\ [], expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A group by query expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#having/3\">having(query, binding \\\\ [], expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A having query expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#join/5\">join(query, qual, binding \\\\ [], expr, on \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A join query expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#limit/3\">limit(query, binding \\\\ [], expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A limit query expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#lock/2\">lock(query, expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A lock query expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#offset/3\">offset(query, binding \\\\ [], expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>An offset query expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#order_by/3\">order_by(query, binding \\\\ [], expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>An order by query expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#preload/3\">preload(query, bindings \\\\ [], expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Preloads the associations into the given struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#select/3\">select(query, binding \\\\ [], expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A select query expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update/3\">update(query, binding \\\\ [], expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>An update query expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#where/3\">where(query, binding \\\\ [], expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A where query expression</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a></code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exclude/2\">  <span class=\"signature\">exclude(query, field)</span>  </h3>  <p>Resets a previously set field on a query.</p> <p>It can reset any query field except the query source (<code class=\"inline\">from</code>).</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">query |&gt; Ecto.Query.exclude(:select)</code></pre>    <h3 class=\"detail-header function\" id=\"first/2\">  <span class=\"signature\">first(queryable, order_by \\\\ nil)</span>  </h3>  <p>Restricts the query to return the first result ordered by primary key.</p> <p>The query will be automatically ordered by the primary key unless <code class=\"inline\">order_by</code> is given or <code class=\"inline\">order_by</code> is set in the query. Limit is always set to 1.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Post |&gt; first |&gt; Repo.one\nquery |&gt; first(:inserted_at) |&gt; Repo.one</code></pre>    <h3 class=\"detail-header function\" id=\"last/2\">  <span class=\"signature\">last(queryable, order_by \\\\ nil)</span>  </h3>  <p>Restricts the query to return the last result ordered by primary key.</p> <p>The query ordering will be automatically reversed, with ASC columns becoming DESC columns (and vice-versa) and limit is set to 1. If there is no ordering, the query will be automatically ordered decreasingly by primary key.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Post |&gt; last |&gt; Repo.one\nquery |&gt; last(:inserted_at) |&gt; Repo.one</code></pre>    <h3 class=\"detail-header function\" id=\"subquery/1\">  <span class=\"signature\">subquery(subquery)</span>  </h3>  <p>Converts a query into a subquery.</p> <p>If a subquery is given, returns the subquery itself. If any other value is given, it is converted to a query via <a href=\"ecto.queryable\"><code class=\"inline\">Ecto.Queryable</code></a> and wrapped in the <a href=\"ecto.subquery\"><code class=\"inline\">Ecto.SubQuery</code></a> struct.</p> <p>Subqueries are currently only supported in the <code class=\"inline\">from</code> and <code class=\"inline\">join</code> fields.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Get the average salary of the top 10 highest salaries\nquery = from Employee, order_by: [desc: :salary], limit: 10\nfrom e in subquery(query), select: avg(e.salary)</code></pre>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"distinct/3\">  <span class=\"signature\">distinct(query, binding \\\\ [], expr)</span>  </h3>  <p>A distinct query expression.</p> <p>When true, only keeps distinct values from the resulting select expression.</p> <p>If supported by your database, you can also pass query expressions to distinct and it will generate a query with DISTINCT ON. In such cases, the row that is being kept depends on the ordering of the rows. When an <code class=\"inline\">order_by</code> expression is also added to the query, all fields in the <code class=\"inline\">distinct</code> expression are automatically referenced <code class=\"inline\">order_by</code> too.</p> <p><code class=\"inline\">distinct</code> also accepts a list of atoms where each atom refers to a field in source.</p> <h4>Keywords examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Returns the list of different categories in the Post schema\nfrom(p in Post, distinct: true, select: p.category)\n\n# If your database supports DISTINCT ON(),\n# you can pass expressions to distinct too\nfrom(p in Post,\n   distinct: p.category,\n   order_by: [p.date])\n\n# Using atoms\nfrom(p in Post, distinct: :category, order_by: :date)</code></pre> <h4>Expressions example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Post\n|&gt; distinct(true)\n|&gt; order_by([p], [p.category, p.author])</code></pre>    <h3 class=\"detail-header macro\" id=\"from/2\">  <span class=\"signature\">from(expr, kw \\\\ [])</span>  </h3>  <p>Creates a query.</p> <p>It can either be a keyword query or a query expression.</p> <p>If it is a keyword query the first argument must be either an <code class=\"inline\">in</code> expression, or a value that implements the <a href=\"ecto.queryable\"><code class=\"inline\">Ecto.Queryable</code></a> protocol. If the query needs a reference to the data source in any other part of the expression, then an <code class=\"inline\">in</code> must be used to create a reference variable. The second argument should be a keyword query where the keys are expression types and the values are expressions.</p> <p>If it is a query expression the first argument must be a value that implements the <a href=\"ecto.queryable\"><code class=\"inline\">Ecto.Queryable</code></a> protocol and the second argument the expression.</p> <h4>Keywords example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">from(c in City, select: c)</code></pre> <h4>Expressions example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">City |&gt; select([c], c)</code></pre> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">def paginate(query, page, size) do\n  from query,\n    limit: ^size,\n    offset: ^((page-1) * size)\nend</code></pre> <p>The example above does not use <code class=\"inline\">in</code> because <code class=\"inline\">limit</code> and <code class=\"inline\">offset</code> do not require a reference to the data source. However, extending the query with a where expression would require the use of <code class=\"inline\">in</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def published(query) do\n  from p in query, where: not(is_nil(p.published_at))\nend</code></pre> <p>Notice we have created a <code class=\"inline\">p</code> variable to reference the query’s original data source. This assumes that the original query only had one source. When the given query has more than one source, a variable must be given for each in the order they were bound:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def published_multi(query) do\n  from [p,o] in query,\n  where: not(is_nil(p.published_at)) and not(is_nil(o.published_at))\nend</code></pre> <p>Note the variables <code class=\"inline\">p</code> and <code class=\"inline\">o</code> can be named whatever you like as they have no importance in the query sent to the database.</p>    <h3 class=\"detail-header macro\" id=\"group_by/3\">  <span class=\"signature\">group_by(query, binding \\\\ [], expr)</span>  </h3>  <p>A group by query expression.</p> <p>Groups together rows from the schema that have the same values in the given fields. Using <code class=\"inline\">group_by</code> “groups” the query giving it different semantics in the <code class=\"inline\">select</code> expression. If a query is grouped, only fields that were referenced in the <code class=\"inline\">group_by</code> can be used in the <code class=\"inline\">select</code> or if the field is given as an argument to an aggregate function.</p> <p><code class=\"inline\">group_by</code> also accepts a list of atoms where each atom refers to a field in source.</p> <h4>Keywords examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Returns the number of posts in each category\nfrom(p in Post,\n  group_by: p.category,\n  select: {p.category, count(p.id)})\n\n# Group on all fields on the Post schema\nfrom(p in Post, group_by: p, select: p)\n\n# Using atoms\nfrom(p in Post, group_by: :category, select: {p.category, count(p.id)})</code></pre> <h4>Expressions example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Post |&gt; group_by([p], p.category) |&gt; select([p], count(p.id))</code></pre>    <h3 class=\"detail-header macro\" id=\"having/3\">  <span class=\"signature\">having(query, binding \\\\ [], expr)</span>  </h3>  <p>A having query expression.</p> <p>Like <code class=\"inline\">where</code>, <code class=\"inline\">having</code> filters rows from the schema, but after the grouping is performed giving it the same semantics as <code class=\"inline\">select</code> for a grouped query (see <a href=\"#group_by/3)\"><code class=\"inline\">group_by/3</code></a>. <code class=\"inline\">having</code> groups the query even if the query has no <code class=\"inline\">group_by</code> expression.</p> <h4>Keywords example</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Returns the number of posts in each category where the\n# average number of comments is above ten\nfrom(p in Post,\n  group_by: p.category,\n  having: avg(p.num_comments) &gt; 10,\n  select: {p.category, count(p.id)})</code></pre> <h4>Expressions example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Post\n|&gt; group_by([p], p.category)\n|&gt; having([p], avg(p.num_comments) &gt; 10)\n|&gt; select([p], count(p.id))</code></pre>    <h3 class=\"detail-header macro\" id=\"join/5\">  <span class=\"signature\">join(query, qual, binding \\\\ [], expr, on \\\\ nil)</span>  </h3>  <p>A join query expression.</p> <p>Receives a source that is to be joined to the query and a condition for the join. The join condition can be any expression that evaluates to a boolean value. The join is by default an inner join, the qualifier can be changed by giving the atoms: <code class=\"inline\">:inner</code>, <code class=\"inline\">:left</code>, <code class=\"inline\">:right</code> or <code class=\"inline\">:full</code>. For a keyword query the <code class=\"inline\">:join</code> keyword can be changed to: <code class=\"inline\">:inner_join</code>, <code class=\"inline\">:left_join</code>, <code class=\"inline\">:right_join</code> or <code class=\"inline\">:full_join</code>.</p> <p>It is also possible to use the atoms <code class=\"inline\">:inner_lateral</code> and <code class=\"inline\">:left_lateral</code> using the Postgres adapter. See “Joining with fragments” below.</p> <p>Currently it is possible to join on an Ecto.Schema (a module), an existing source (a binary representing a table), an association or a fragment. For a lateral join it is only possible to join on a fragment since the join query must be able to access columns from the left side of the join. See the examples below:</p> <h4>Keywords examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">from c in Comment,\n  join: p in Post, on: c.post_id == p.id,\n  select: {p.title, c.text}\n\nfrom p in Post,\n  left_join: c in assoc(p, :comments),\n  select: {p, c}</code></pre> <h4>Expressions examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Comment\n|&gt; join(:inner, [c], p in Post, c.post_id == p.id)\n|&gt; select([c, p], {p.title, c.text})\n\nPost\n|&gt; join(:left, [p], c in assoc(p, :comments))\n|&gt; select([p, c], {p, c})\n\nPost\n|&gt; join(:left, [p], c in Comment, c.post_id == p.id and c.is_visible == true)\n|&gt; select([p, c], {p, c})</code></pre> <h4>Joining with fragments</h4> <p>When you need to join on a complex expression that cannot be expressed via Ecto associations, Ecto supports fragments in joins:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Comment\n|&gt; join(:inner, [c], p in fragment(\"SOME COMPLEX QUERY\", c.id, ^some_param))</code></pre> <p>Although using fragments in joins is discouraged in favor of Ecto Query syntax, they are necessary when writing lateral joins as lateral joins require a subquery that refer to previous bindings:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Game\n|&gt; join(:inner_lateral, [g], gs in fragment(\"SELECT * FROM games_sold AS gs WHERE gs.game_id = ? ORDER BY gs.sold_on LIMIT 2\", g.id))\n|&gt; select([g, gs], {g.name, gs.sold_on})</code></pre>    <h3 class=\"detail-header macro\" id=\"limit/3\">  <span class=\"signature\">limit(query, binding \\\\ [], expr)</span>  </h3>  <p>A limit query expression.</p> <p>Limits the number of rows returned from the result. Can be any expression but has to evaluate to an integer value and it can’t include any field.</p> <p>If <code class=\"inline\">limit</code> is given twice, it overrides the previous value.</p> <h4>Keywords example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">from(u in User, where: u.id == ^current_user, limit: 1)</code></pre> <h4>Expressions example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">User |&gt; where([u], u.id == ^current_user) |&gt; limit(1)</code></pre>    <h3 class=\"detail-header macro\" id=\"lock/2\">  <span class=\"signature\">lock(query, expr)</span>  </h3>  <p>A lock query expression.</p> <p>Provides support for row-level pessimistic locking using <code class=\"inline\">SELECT ... FOR UPDATE</code> or other, database-specific, locking clauses. <code class=\"inline\">expr</code> can be any expression but has to evaluate to a boolean value or to a string and it can’t include any fields.</p> <p>If <code class=\"inline\">lock</code> is used more than once, the last one used takes precedence.</p> <p>Ecto also supports <a href=\"http://en.wikipedia.org/wiki/Optimistic_concurrency_control\">optimistic locking</a> but not through queries. For more information on optimistic locking, have a look at the <a href=\"ecto.changeset#optimistic_lock/3\"><code class=\"inline\">Ecto.Changeset.optimistic_lock/3</code></a> function</p> <h4>Keywords example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">from(u in User, where: u.id == ^current_user, lock: \"FOR SHARE NOWAIT\")</code></pre> <h4>Expressions example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">User |&gt; where(u.id == ^current_user) |&gt; lock(\"FOR SHARE NOWAIT\")</code></pre>    <h3 class=\"detail-header macro\" id=\"offset/3\">  <span class=\"signature\">offset(query, binding \\\\ [], expr)</span>  </h3>  <p>An offset query expression.</p> <p>Offsets the number of rows selected from the result. Can be any expression but it must evaluate to an integer value and it can’t include any field.</p> <p>If <code class=\"inline\">offset</code> is given twice, it overrides the previous value.</p> <h4>Keywords example</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Get all posts on page 4\nfrom(p in Post, limit: 10, offset: 30)</code></pre> <h4>Expressions example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Post |&gt; limit(10) |&gt; offset(30)</code></pre>    <h3 class=\"detail-header macro\" id=\"order_by/3\">  <span class=\"signature\">order_by(query, binding \\\\ [], expr)</span>  </h3>  <p>An order by query expression.</p> <p>Orders the fields based on one or more fields. It accepts a single field or a list of fields. The default direction is ascending (<code class=\"inline\">:asc</code>) and can be customized in a keyword list as shown in the examples. There can be several order by expressions in a query.</p> <p><code class=\"inline\">order_by</code> also accepts a list of atoms where each atom refers to a field in source or a keyword list where the direction is given as key and the field to order as value.</p> <h4>Keywords examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">from(c in City, order_by: c.name, order_by: c.population)\nfrom(c in City, order_by: [c.name, c.population])\nfrom(c in City, order_by: [asc: c.name, desc: c.population])\n\nfrom(c in City, order_by: [:name, :population])\nfrom(c in City, order_by: [asc: :name, desc: :population])</code></pre> <p>A keyword list can also be interpolated:</p> <pre data-language=\"elixir\"><code class=\"elixir\">values = [asc: :name, desc: :population]\nfrom(c in City, order_by: ^values)</code></pre> <h4>Expressions example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">City |&gt; order_by([c], asc: c.name, desc: c.population)\nCity |&gt; order_by(asc: :name) # Sorts by the cities name</code></pre>    <h3 class=\"detail-header macro\" id=\"preload/3\">  <span class=\"signature\">preload(query, bindings \\\\ [], expr)</span>  </h3>  <p>Preloads the associations into the given struct.</p> <p>Preloading allows developers to specify associations that are preloaded into the struct. Consider this example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Repo.all from p in Post, preload: [:comments]</code></pre> <p>The example above will fetch all posts from the database and then do a separate query returning all comments associated to the given posts.</p> <p>However, often times, you want posts and comments to be selected and filtered in the same query. For such cases, you can explicitly tell the association to be preloaded into the struct:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Repo.all from p in Post,\n           join: c in assoc(p, :comments),\n           where: c.published_at &gt; p.updated_at,\n           preload: [comments: c]</code></pre> <p>In the example above, instead of issuing a separate query to fetch comments, Ecto will fetch posts and comments in a single query.</p> <p>Nested associations can also be preloaded in both formats:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Repo.all from p in Post,\n           preload: [comments: :likes]\n\nRepo.all from p in Post,\n           join: c in assoc(p, :comments),\n           join: l in assoc(c, :likes),\n           where: l.inserted_at &gt; c.updated_at,\n           preload: [comments: {c, likes: l}]</code></pre> <p>Keep in mind neither format can be nested arbitrarily. For example, the query below is invalid because we cannot preload likes with the join association <code class=\"inline\">c</code>.</p> <pre data-language=\"elixir\"><code class=\"elixir\">Repo.all from p in Post,\n           join: c in assoc(p, :comments),\n           preload: [comments: {c, :likes}]</code></pre> <h4>Preload queries</h4> <p>Preload also allows queries to be given, allowing you to filter or customize how the preloads are fetched:</p> <pre data-language=\"elixir\"><code class=\"elixir\">comments_query = from c in Comment, order_by: c.published_at\nRepo.all from p in Post, preload: [comments: ^comments_query]</code></pre> <p>The example above will issue two queries, one for loading posts and then another for loading the comments associated with the posts. Comments will be ordered by <code class=\"inline\">published_at</code>.</p> <p>Note: keep in mind operations like limit and offset in the preload query will affect the whole result set and not each association. For example, the query below:</p> <pre data-language=\"elixir\"><code class=\"elixir\">comments_query = from c in Comment, order_by: c.popularity, limit: 5\nRepo.all from p in Post, preload: [comments: ^comments_query]</code></pre> <p>won’t bring the top of comments per post. Rather, it will only bring the 5 top comments across all posts.</p> <h4>Preload functions</h4> <p>Preload also allows functions to be given. In such cases, the function receives the IDs to be fetched and it must return the associated data. This data will then be mapped and sorted:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Repo.all from p in Post, preload: [comments: fn _ -&gt; previously_loaded_comments end]</code></pre> <p>This is useful when the whole dataset was already loaded or must be explicitly fetched from elsewhere.</p> <h4>Keywords example</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Returns all posts, their associated comments, and the associated\n# likes for those comments.\nfrom(p in Post,\n  preload: [:comments, comments: :likes],\n  select: p)</code></pre> <h4>Expressions examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Post |&gt; preload(:comments) |&gt; select([p], p)\nPost |&gt; join(:left, [p], c in assoc(p, :comments)) |&gt; preload([p, c], [:user, comments: c]) |&gt; select([p], p)</code></pre>    <h3 class=\"detail-header macro\" id=\"select/3\">  <span class=\"signature\">select(query, binding \\\\ [], expr)</span>  </h3>  <p>A select query expression.</p> <p>Selects which fields will be selected from the schema and any transformations that should be performed on the fields. Any expression that is accepted in a query can be a select field.</p> <p>The sub-expressions in the query can be wrapped in lists, tuples or maps as shown in the examples. A full schema can also be selected.</p> <p>There can only be one select expression in a query, if the select expression is omitted, the query will by default select the full schema.</p> <p><code class=\"inline\">select</code> also accepts a list of atoms where each atom refers to a field in the source to be selected.</p> <h4>Keywords examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">from(c in City, select: c) # returns the schema as a struct\nfrom(c in City, select: {c.name, c.population})\nfrom(c in City, select: [c.name, c.county])\nfrom(c in City, select: {c.name, ^to_string(40 + 2), 43})\nfrom(c in City, select: %{n: c.name, answer: 42})</code></pre> <p>It is also possible to select a struct and limit the returned fields at the same time:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from(City, select: [:name])</code></pre> <p>The syntax above is equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from(city in City, select: struct(city, [:name]))</code></pre> <p>You can also write:</p> <pre data-language=\"elixir\"><code class=\"elixir\">from(city in City, select: map(city, [:name]))</code></pre> <p>If you want a map with only the selected fields to be returned. For more information, read the docs for <a href=\"ecto.query.api#struct/2\"><code class=\"inline\">Ecto.Query.API.struct/2</code></a> and <a href=\"ecto.query.api#map/2\"><code class=\"inline\">Ecto.Query.API.map/2</code></a>.</p> <h4>Expressions examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">City |&gt; select([c], c)\nCity |&gt; select([c], {c.name, c.country})\nCity |&gt; select([c], %{\"name\" =&gt; c.name})\nCity |&gt; select([:name])\nCity |&gt; select([c], struct(c, [:name]))\nCity |&gt; select([c], map(c, [:name]))</code></pre>    <h3 class=\"detail-header macro\" id=\"update/3\">  <span class=\"signature\">update(query, binding \\\\ [], expr)</span>  </h3>  <p>An update query expression.</p> <p>Updates are used to update the filtered entries. In order for updates to be applied, <code class=\"inline\">Ecto.Repo.update_all/3</code> must be invoked.</p> <h4>Keywords example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">from(u in User, update: [set: [name: \"new name\"]])</code></pre> <h4>Expressions example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">User |&gt; update([u], set: [name: \"new name\"])\nUser |&gt; update(set: [name: \"new name\"])</code></pre> <h4>Operators</h4> <p>The update expression in Ecto supports the following operators:</p> <ul> <li>\n<p><code class=\"inline\">set</code> - sets the given field in the table to the given value</p> <pre data-language=\"elixir\"><code class=\"elixir\">from(u in User, update: [set: [name: \"new name\"]])</code></pre> </li> <li>\n<p><code class=\"inline\">inc</code> - increments (or decrements if the value is negative) the given field in the table by the given value</p> <pre data-language=\"elixir\"><code class=\"elixir\">from(u in User, update: [inc: [accesses: 1]])</code></pre> </li> <li>\n<p><code class=\"inline\">push</code> - pushes (appends) the given value to the end of the array field</p> <pre data-language=\"elixir\"><code class=\"elixir\">from(u in User, update: [push: [tags: \"cool\"]])</code></pre> </li> <li>\n<p><code class=\"inline\">pull</code> - pulls (removes) the given value from the array field</p> <pre data-language=\"elixir\"><code class=\"elixir\">from(u in User, update: [pull: [tags: \"not cool\"]])</code></pre> </li> </ul>    <h3 class=\"detail-header macro\" id=\"where/3\">  <span class=\"signature\">where(query, binding \\\\ [], expr)</span>  </h3>  <p>A where query expression.</p> <p><code class=\"inline\">where</code> expressions are used to filter the result set. If there is more than one where expression, they are combined with an <code class=\"inline\">and</code> operator. All where expressions have to evaluate to a boolean value.</p> <p><code class=\"inline\">where</code> also accepts a keyword list where the field given as key is going to be compared with the given value. The fields will always refer to the source given in <code class=\"inline\">from</code>.</p> <h4>Keywords example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">from(c in City, where: c.state == \"Sweden\")\nfrom(c in City, where: [state: \"Sweden\"])</code></pre> <p>It is also possible to interpolate the whole keyword list, allowing you to dynamically filter the source:</p> <pre data-language=\"elixir\"><code class=\"elixir\">filters = [state: \"Sweden\"]\nfrom(c in City, where: ^filters)</code></pre> <h4>Expressions example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">City |&gt; where([c], c.state == \"Sweden\")\nCity |&gt; where(state: \"Sweden\")</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Query.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Query.html</a>\n  </p>\n</div>\n","ecto/ecto.staleentryerror":"<h1>  Ecto.StaleEntryError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.StaleEntryError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.StaleEntryError.html</a>\n  </p>\n</div>\n","ecto/ecto.queryable":"<h1>  Ecto.Queryable <small>protocol</small>  </h1>  <p>Converts a data structure into an <a href=\"ecto.query\"><code class=\"inline\">Ecto.Query</code></a>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#to_query/1\">to_query(data)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given <code class=\"inline\">data</code> into an <a href=\"ecto.query\"><code class=\"inline\">Ecto.Query</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: term</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"to_query/1\">  <span class=\"signature\">to_query(data)</span>  </h3>  <p>Converts the given <code class=\"inline\">data</code> into an <a href=\"ecto.query\"><code class=\"inline\">Ecto.Query</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Queryable.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Queryable.html</a>\n  </p>\n</div>\n","phoenix_pubsub/phoenix.pubsub.local":"<h1>  Phoenix.PubSub.Local </h1>  <p>PubSub implementation for handling local-node process groups.</p> <p>This module is used by Phoenix pubsub adapters to handle their local node subscriptions and it is usually not accessed directly. See <code>Phoenix.PubSub.PG2</code> for an example integration.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#broadcast/6\">broadcast(fastlane, pubsub_server, pool_size, from, topic, msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends a message to all subscribers of a topic</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/2\">start_link(server_name, gc_name)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts the server</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subscribe/5\">subscribe(pubsub_server, pool_size, pid, topic, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Subscribes the pid to the topic</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subscribers/3\">subscribers(pubsub_server, topic, shard)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a set of subscribers pids for the given topic</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subscribers_with_fastlanes/3\">subscribers_with_fastlanes(pubsub_server, topic, shard)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a set of subscribers pids for the given topic with fastlane tuples. See <code>subscribers/1</code> for more information</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unsubscribe/4\">unsubscribe(pubsub_server, pool_size, pid, topic)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Unsubscribes the pid from the topic</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"broadcast/6\">  <span class=\"signature\">broadcast(fastlane, pubsub_server, pool_size, from, topic, msg)</span> </h3>  <p>Sends a message to all subscribers of a topic.</p> <ul> <li>\n<code>pubsub_server</code> - The registered server name</li> <li>\n<code>pool_size</code> - The size of the pool</li> <li>\n<code>topic</code> - The string topic, for example \"users:123\"</li> </ul> <h4 id=\"examples\">Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; broadcast(MyApp.PubSub, 1, self, \"foo\")\n:ok\niex&gt; broadcast(MyApp.PubSub, 1, :none, \"bar\")\n:ok</code></pre>    <h3 class=\"detail-header function\" id=\"start_link/2\">  <span class=\"signature\">start_link(server_name, gc_name)</span> </h3>  <p>Starts the server.</p> <ul> <li>\n<code>server_name</code> - The name to register the server under</li> </ul>    <h3 class=\"detail-header function\" id=\"subscribe/5\">  <span class=\"signature\">subscribe(pubsub_server, pool_size, pid, topic, opts \\\\ [])</span> </h3>  <p>Subscribes the pid to the topic.</p> <ul> <li>\n<code>pubsub_server</code> - The registered server name</li> <li>\n<code>pool_size</code> - The size of the pool</li> <li>\n<code>pid</code> - The subscriber pid</li> <li>\n<code>topic</code> - The string topic, for example \"users:123\"</li> <li>\n<code>opts</code> - The optional list of options. Supported options only include <code>:link</code> to link the subscriber to local</li> </ul> <h4 id=\"examples\">Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; subscribe(MyApp.PubSub, 1, self, \"foo\")\n:ok</code></pre>    <h3 class=\"detail-header function\" id=\"subscribers/3\">  <span class=\"signature\">subscribers(pubsub_server, topic, shard)</span> </h3>  <p>Returns a set of subscribers pids for the given topic.</p> <ul> <li>\n<code>pubsub_server</code> - The registered server name or pid</li> <li>\n<code>topic</code> - The string topic, for example \"users:123\"</li> <li>\n<code>shard</code> - The shard, for example <code>1</code>\n</li> </ul> <h4 id=\"examples\">Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; subscribers(:pubsub_server, \"foo\", 1)\n[#PID&lt;0.48.0&gt;, #PID&lt;0.49.0&gt;]</code></pre>    <h3 class=\"detail-header function\" id=\"subscribers_with_fastlanes/3\">  <span class=\"signature\">subscribers_with_fastlanes(pubsub_server, topic, shard)</span> </h3>  <p>Returns a set of subscribers pids for the given topic with fastlane tuples. See <code>subscribers/1</code> for more information.</p>    <h3 class=\"detail-header function\" id=\"unsubscribe/4\">  <span class=\"signature\">unsubscribe(pubsub_server, pool_size, pid, topic)</span> </h3>  <p>Unsubscribes the pid from the topic.</p> <ul> <li>\n<code>pubsub_server</code> - The registered server name</li> <li>\n<code>pool_size</code> - The size of the pool</li> <li>\n<code>pid</code> - The subscriber pid</li> <li>\n<code>topic</code> - The string topic, for example \"users:123\"</li> </ul> <h4 id=\"examples\">Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; unsubscribe(MyApp.PubSub, 1, self, \"foo\")\n:ok</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.Local.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.Local.html</a>\n  </p>\n</div>\n","phoenix_pubsub/phoenix.pubsub.localsupervisor":"<h1>  Phoenix.PubSub.LocalSupervisor </h1>  <p>Local PubSub server supervisor.</p> <p>Used by PubSub adapters to handle \"local\" subscriptions. Defines an ets dispatch table for routing subcription requests. Extendable by PubSub adapters by providing a list of <code>dispatch_rules</code> to extend the dispatch table.</p> <p>See <code>Phoenix.PubSub.PG2</code> for example usage.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#start_link/3\">start_link(server, pool_size, dispatch_rules)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"start_link/3\">  <span class=\"signature\">start_link(server, pool_size, dispatch_rules)</span> </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.LocalSupervisor.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.LocalSupervisor.html</a>\n  </p>\n</div>\n","phoenix_pubsub/phoenix.pubsub.supervisor":"<h1>  Phoenix.PubSub.Supervisor </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#start/2\">start(type, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code>c:Application.start/2</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"start/2\">  <span class=\"signature\">start(type, args)</span> </h3>  <p>Callback implementation for <code>c:Application.start/2</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.Supervisor.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.Supervisor.html</a>\n  </p>\n</div>\n","ecto/ecto.subqueryerror":"<h1>  Ecto.SubQueryError <small>exception</small>  </h1>  <p>Raised at runtime when a subquery is invalid.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.SubQueryError.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.SubQueryError.html</a>\n  </p>\n</div>\n","phoenix_pubsub/phoenix.pubsub.gc":"<h1>  Phoenix.PubSub.GC </h1>  <p>A garbage collector process that cleans up the table used by <a href=\"phoenix.pubsub.local\"><code>Phoenix.PubSub.Local</code></a>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#down/2\">down(gc_server, pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Force table clean up because the given pid is down asynchronously</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/2\">start_link(server_name, local_name)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts the server</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"down/2\">  <span class=\"signature\">down(gc_server, pid)</span> </h3>  <p>Force table clean up because the given pid is down asynchronously.</p> <ul> <li>\n<code>gc_server</code> - The registered server name or pid</li> <li>\n<code>pid</code> - The subscriber pid</li> </ul> <h4 id=\"examples\">Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; down(:gc_server, self)\n:ok</code></pre>    <h3 class=\"detail-header function\" id=\"start_link/2\">  <span class=\"signature\">start_link(server_name, local_name)</span> </h3>  <p>Starts the server.</p> <ul> <li>\n<code>server_name</code> - The name to register the server under</li> <li>\n<code>table_name</code> - The name of the local table</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.GC.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.GC.html</a>\n  </p>\n</div>\n","ecto/ecto.schema":"<h1>  Ecto.Schema  </h1>  <p>Defines a schema.</p> <p>An Ecto schema is used to map any data source into an Elixir struct. One of such use cases is to map data coming from a repository, usually a table, into Elixir structs.</p> <h2 id=\"module-example\" class=\"section-heading\">  Example </h2> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  use Ecto.Schema\n\n  schema \"users\" do\n    field :name, :string\n    field :age, :integer, default: 0\n    has_many :posts, Post\n  end\nend</code></pre> <p>By default, a schema will generate a primary key, named <code class=\"inline\">id</code> and of type <code class=\"inline\">:integer</code>, and <code class=\"inline\">belongs_to</code> associations in the schema will generate foreign keys of type <code class=\"inline\">:integer</code>. These settings can be seen below.</p> <h2 id=\"module-schema-attributes\" class=\"section-heading\">  Schema attributes </h2> <p>Supported attributes, to be set beforehand, for configuring the defined schema.</p> <p>These attributes are:</p> <ul> <li>\n<p><code class=\"inline\">@primary_key</code> - configures the schema primary key. It expects a tuple <code class=\"inline\">{field_name, type, options}</code> with the primary key field name, type (typically <code class=\"inline\">:id</code> or <code class=\"inline\">:binary_id</code>, but can be any type) and options. Defaults to <code class=\"inline\">{:id, :id, autogenerate: true}</code>. When set to <code class=\"inline\">false</code>, does not define a primary key in the schema;</p> </li> <li>\n<p><code class=\"inline\">@schema_prefix</code> - configures the schema prefix. Defaults to <code class=\"inline\">nil</code>, which generates structs and queries without prefix. When set, the prefix will be used by every built struct as well as queries where the <code class=\"inline\">from</code> is the current schema. In PostgreSQL, the prefix is called “SCHEMA” (typically set with schema search_path). In MySQL the prefix points to databases.</p> </li> <li>\n<p><code class=\"inline\">@foreign_key_type</code> - configures the default foreign key type used by <code class=\"inline\">belongs_to</code> associations. Defaults to <code class=\"inline\">:integer</code>;</p> </li> <li>\n<p><code class=\"inline\">@timestamps_opts</code> - configures the default timestamps type used by <code class=\"inline\">timestamps</code>. Defaults to <code class=\"inline\">[type: Ecto.DateTime, usec: false]</code>;</p> </li> <li>\n<code class=\"inline\">@derive</code> - the same as <code class=\"inline\">@derive</code> available in <code class=\"inline\">Kernel.defstruct/1</code> as the schema defines a struct behind the scenes; </li> </ul> <p>The advantage of configuring the schema via those attributes is that they can be set with a macro to configure application wide defaults.</p> <p>For example, if your database does not support autoincrementing primary keys and requires something like UUID or a RecordID, you can configure and use<code class=\"inline\">:binary_id</code> as your primary key type as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Define a module to be used as base\ndefmodule MyApp.Schema do\n  defmacro __using__(_) do\n    quote do\n      use Ecto.Schema\n      @primary_key {:id, :binary_id, autogenerate: true}\n      @foreign_key_type :binary_id\n    end\n  end\nend\n\n# Now use MyApp.Schema to define new schemas\ndefmodule MyApp.Comment do\n  use MyApp.Schema\n\n  schema \"comments\" do\n    belongs_to :post, MyApp.Post\n  end\nend</code></pre> <p>Any schemas using <code class=\"inline\">MyApp.Schema</code> will get the <code class=\"inline\">:id</code> field with type <code class=\"inline\">:binary_id</code> as the primary key. We explain what the <code class=\"inline\">:binary_id</code> type entails in the next section.</p> <p>The <code class=\"inline\">belongs_to</code> association on <code class=\"inline\">MyApp.Comment</code> will also define a <code class=\"inline\">:post_id</code> field with <code class=\"inline\">:binary_id</code> type that references the <code class=\"inline\">:id</code> field of the <code class=\"inline\">MyApp.Post</code> schema.</p> <h2 id=\"module-primary-keys\" class=\"section-heading\">  Primary keys </h2> <p>Ecto supports two ID types, called <code class=\"inline\">:id</code> and <code class=\"inline\">:binary_id</code>, which are often used as the type for primary keys and associations.</p> <p>The <code class=\"inline\">:id</code> type is used when the primary key is an integer while the <code class=\"inline\">:binary_id</code> is used for primary keys in particular binary formats, which may be <a href=\"ecto.uuid\"><code class=\"inline\">Ecto.UUID</code></a> for databases like PostgreSQL and MySQL, or some specific ObjectID or RecordID often imposed by NoSQL databases.</p> <p>In both cases, both types have their semantics specified by the underlying adapter/database. If you use the <code class=\"inline\">:id</code> type with <code class=\"inline\">:autogenerate</code>, it means the database will be responsible for auto-generation of the id. This is often the case for primary keys in relational databases which are auto-incremented.</p> <p>Similarly, the <code class=\"inline\">:binary_id</code> type may be generated in the adapter for cases like UUID but it may also be handled by the database if required. In any case, both scenarios are handled transparently by Ecto.</p> <p>Besides <code class=\"inline\">:id</code> and <code class=\"inline\">:binary_id</code>, which are often used by primary and foreign keys, Ecto provides a huge variety of types to be used by any column.</p> <h2 id=\"module-types-and-casting\" class=\"section-heading\">  Types and casting </h2> <p>When defining the schema, types need to be given. Types are split into two categories, primitive types and custom types.</p> <h3>Primitive types</h3> <p>The primitive types are:</p> <table> <colgroup> <col> <col> <col> </colgroup> <thead> <tr> <th style=\"text-align: left\">Ecto type</th>\n<th style=\"text-align: left\">Elixir type</th>\n<th style=\"text-align: left\">Literal syntax in query</th> </tr> </thead> <tr> <td style=\"text-align: left\"><code class=\"inline\">:id</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">integer</code></td>\n<td style=\"text-align: left\">1, 2, 3</td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">:binary_id</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">binary</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">&lt;&lt;int, int, int, ...&gt;&gt;</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">:integer</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">integer</code></td>\n<td style=\"text-align: left\">1, 2, 3</td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">:float</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">float</code></td>\n<td style=\"text-align: left\">1.0, 2.0, 3.0</td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">:boolean</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">boolean</code></td>\n<td style=\"text-align: left\">true, false</td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">:string</code></td>\n<td style=\"text-align: left\">UTF-8 encoded <code class=\"inline\">string</code>\n</td>\n<td style=\"text-align: left\">“hello”</td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">:binary</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">binary</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">&lt;&lt;int, int, int, ...&gt;&gt;</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">{:array, inner_type}</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">list</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">[value, value, value, ...]</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">:decimal</code></td>\n<td style=\"text-align: left\"><a href=\"https://github.com/ericmj/decimal\"><code class=\"inline\">Decimal</code></a></td>\n<td style=\"text-align: left\"></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">:map</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">map</code></td>\n<td style=\"text-align: left\"></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">{:map, inner_type}</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">map</code></td>\n<td style=\"text-align: left\"></td> </tr> </table> <p><strong>Note:</strong> For the <code class=\"inline\">{:array, inner_type}</code> and <code class=\"inline\">{:map, inner_type}</code> type, replace <code class=\"inline\">inner_type</code> with one of the valid types, such as <code class=\"inline\">:string</code>.</p> <h3>Custom types</h3> <p>Besides providing primitive types, Ecto allows custom types to be implemented by developers, allowing Ecto behaviour to be extended.</p> <p>A custom type is a module that implements the <a href=\"ecto.type\"><code class=\"inline\">Ecto.Type</code></a> behaviour. By default, Ecto provides the following custom types:</p> <table> <colgroup> <col> <col> <col> </colgroup> <thead> <tr> <th style=\"text-align: left\">Custom type</th>\n<th style=\"text-align: left\">Database type</th>\n<th style=\"text-align: left\">Elixir type</th> </tr> </thead> <tr> <td style=\"text-align: left\"><a href=\"ecto.datetime\"><code class=\"inline\">Ecto.DateTime</code></a></td>\n<td style=\"text-align: left\"><code class=\"inline\">:datetime</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">%Ecto.DateTime{}</code></td> </tr> <tr> <td style=\"text-align: left\"><a href=\"ecto.date\"><code class=\"inline\">Ecto.Date</code></a></td>\n<td style=\"text-align: left\"><code class=\"inline\">:date</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">%Ecto.Date{}</code></td> </tr> <tr> <td style=\"text-align: left\"><a href=\"ecto.time\"><code class=\"inline\">Ecto.Time</code></a></td>\n<td style=\"text-align: left\"><code class=\"inline\">:time</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">%Ecto.Time{}</code></td> </tr> <tr> <td style=\"text-align: left\"><a href=\"ecto.uuid\"><code class=\"inline\">Ecto.UUID</code></a></td>\n<td style=\"text-align: left\"><code class=\"inline\">:uuid</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">uuid-string</code></td> </tr> </table> <p>Read the <a href=\"ecto.type\"><code class=\"inline\">Ecto.Type</code></a> documentation for more information on implementing your own types.</p> <p>Finally, schemas can also have virtual fields by passing the <code class=\"inline\">virtual: true</code> option. These fields are not persisted to the database and can optionally not be type checked by declaring type <code class=\"inline\">:any</code>.</p> <h3>The map type</h3> <p>The map type allows developers to store an Elixir map directly in the database:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># In your migration\ncreate table(:users) do\n  add :data, :map\nend\n\n# In your schema\nfield :data, :map\n\n# Now in your code\nuser = Repo.insert! %User{data: %{\"foo\" =&gt; \"bar\"}}</code></pre> <p>Keep in mind that we advise the map keys to be strings or integers instead of atoms. Atoms may be accepted depending on how maps are serialized but the database will always return atom keys as strings due to security reasons.</p> <p>In order to support maps, different databases may employ different techniques. For example, PostgreSQL will store those values in jsonb fields, allowing you to just query parts of it. MySQL and MSSQL, on the other hand, do not yet provide a JSON type, so the value will be stored in a text field.</p> <p>For maps to work in such databases, Ecto will need a JSON library. By default Ecto will use <a href=\"http://github.com/devinus/poison\">Poison</a> which needs to be added your deps in <code class=\"inline\">mix.exs</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:poison, \"~&gt; 1.0\"}</code></pre> <p>You can however tell Ecto to use any other library by configuring it:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :ecto, :json_library, YourLibraryOfChoice</code></pre> <h3>Casting</h3> <p>When directly manipulating the struct, it is the responsibility of the developer to ensure the field values have the proper type. For example, you can create a user struct with an invalid value for <code class=\"inline\">age</code>:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; user = %User{age: \"0\"}\niex&gt; user.age\n\"0\"</code></pre> <p>However, if you attempt to persist the struct above, an error will be raised since Ecto validates the types when sending them to the adapter/database.</p> <p>Therefore, when working with and manipulating external data, it is recommended to use <a href=\"ecto.changeset\"><code class=\"inline\">Ecto.Changeset</code></a>’s that are able to filter and properly cast external data:</p> <pre data-language=\"elixir\"><code class=\"elixir\">changeset = Ecto.Changeset.cast(%User{}, %{\"age\" =&gt; \"0\"}, [:age])\nuser = Repo.insert!(changeset)</code></pre> <p><strong>You can use Ecto schemas and changesets to cast and validate any kind of data, regardless if the data will be persisted to an Ecto repository or not</strong>.</p> <h2 id=\"module-reflection\" class=\"section-heading\">  Reflection </h2> <p>Any schema module will generate the <code class=\"inline\">__schema__</code> function that can be used for runtime introspection of the schema:</p> <ul> <li>\n<code class=\"inline\">__schema__(:source)</code> - Returns the source as given to <a href=\"#schema/2\"><code class=\"inline\">schema/2</code></a>; </li> <li>\n<code class=\"inline\">__schema__(:prefix)</code> - Returns optional prefix for source provided by <code class=\"inline\">@schema_prefix</code> schema attribute; </li> <li>\n<p><code class=\"inline\">__schema__(:primary_key)</code> - Returns a list of primary key fields (empty if there is none);</p> </li> <li>\n<code class=\"inline\">__schema__(:fields)</code> - Returns a list of all non-virtual field names; </li> <li>\n<code class=\"inline\">__schema__(:type, field)</code> - Returns the type of the given non-virtual field; </li> <li>\n<p><code class=\"inline\">__schema__(:types)</code> - Returns a map of all non-virtual field names and their type;</p> </li> <li>\n<code class=\"inline\">__schema__(:associations)</code> - Returns a list of all association field names; </li> <li>\n<p><code class=\"inline\">__schema__(:association, assoc)</code> - Returns the association reflection of the given assoc;</p> </li> <li>\n<code class=\"inline\">__schema__(:embeds)</code> - Returns a list of all embedded field names; </li> <li>\n<p><code class=\"inline\">__schema__(:embed, embed)</code> - Returns the embedding reflection of the given embed;</p> </li> <li>\n<p><code class=\"inline\">__schema__(:read_after_writes)</code> - Non-virtual fields that must be read back from the database after every write (insert or update);</p> </li> <li>\n<code class=\"inline\">__schema__(:autogenerate_id)</code> - Primary key that is auto generated on insert; </li> </ul> <p>Furthermore, both <code class=\"inline\">__struct__</code> and <code class=\"inline\">__changeset__</code> functions are defined so structs and changeset functionalities are available.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#belongs_to/3\">belongs_to(name, queryable, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Indicates a one-to-one or many-to-one association with another schema</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#embedded_schema/1\">embedded_schema(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines an embedded schema</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#embeds_many/3\">embeds_many(name, schema, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Indicates an embedding of many schemas</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#embeds_one/3\">embeds_one(name, schema, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Indicates an embedding of a schema</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#field/3\">field(name, type \\\\ :string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a field on the schema with given name and type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#has_many/3\">has_many(name, queryable, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Indicates a one-to-many association with another schema</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#has_one/3\">has_one(name, queryable, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Indicates a one-to-one association with another schema</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#many_to_many/3\">many_to_many(name, queryable, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Indicates a many-to-many association with another schema</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#schema/2\">schema(source, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a schema with a source name and field definitions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#timestamps/1\">timestamps(opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates <code class=\"inline\">:inserted_at</code> and <code class=\"inline\">:updated_at</code> timestamp fields</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %atom{}</code></pre> </div>    <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"belongs_to/3\">  <span class=\"signature\">belongs_to(name, queryable, opts \\\\ [])</span>  </h3>  <p>Indicates a one-to-one or many-to-one association with another schema.</p> <p>The current schema belongs to zero or one records of the other schema. The other schema often has a <code class=\"inline\">has_one</code> or a <code class=\"inline\">has_many</code> field with the reverse association.</p> <p>You should use <code class=\"inline\">belongs_to</code> in the table that contains the foreign key. Imagine a company &lt;-&gt; manager relationship. If the company contains the <code class=\"inline\">manager_id</code> in the underlying database table, we say the company belongs to manager.</p> <p>In fact, when you invoke this macro, a field with the name of foreign key is automatically defined in the schema for you.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:foreign_key</code> - Sets the foreign key field name, defaults to the name of the association suffixed by <code class=\"inline\">_id</code>. For example, <code class=\"inline\">belongs_to :company</code> will define foreign key of <code class=\"inline\">:company_id</code></p> </li> <li>\n<p><code class=\"inline\">:references</code> - Sets the key on the other schema to be used for the association, defaults to: <code class=\"inline\">:id</code></p> </li> <li>\n<p><code class=\"inline\">:define_field</code> - When false, does not automatically define a <code class=\"inline\">:foreign_key</code> field, implying the user is defining the field manually elsewhere</p> </li> <li>\n<p><code class=\"inline\">:type</code> - Sets the type of automatically defined <code class=\"inline\">:foreign_key</code>. Defaults to: <code class=\"inline\">:id</code> and can be set per schema via <code class=\"inline\">@foreign_key_type</code></p> </li> <li>\n<p><code class=\"inline\">:on_replace</code> - The action taken on associations when the record is replaced when casting or manipulating parent changeset. May be <code class=\"inline\">:raise</code> (default), <code class=\"inline\">:mark_as_invalid</code>, <code class=\"inline\">:nilify</code>, or <code class=\"inline\">:delete</code>. See <a href=\"ecto.changeset\"><code class=\"inline\">Ecto.Changeset</code></a>’s section on related data for more info.</p> </li> <li>\n<code class=\"inline\">:defaults</code> - Default values to use when building the association </li> </ul> <p>All other options are forwarded to the underlying foreign key definition and therefore accept the same options as <a href=\"#field/3\"><code class=\"inline\">field/3</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Comment do\n  use Ecto.Schema\n\n  schema \"comments\" do\n    belongs_to :post, Post\n  end\nend\n\n# The post can come preloaded on the comment record\n[comment] = Repo.all(from(c in Comment, where: c.id == 42, preload: :post))\ncomment.post #=&gt; %Post{...}</code></pre> <h4>Polymorphic associations</h4> <p>One common use case for belongs to associations is to handle polymorphism. For example, imagine you have defined a Comment schema and you wish to use it for commenting on both tasks and posts.</p> <p>Some abstractions would force you to define some sort of polymorphic association with two fields in your database:</p> <pre data-language=\"elixir\"><code class=\"elixir\">* commentable_type\n* commentable_id</code></pre> <p>The problem with this approach is that it breaks references in the database. You can’t use foreign keys and it is very inefficient, both in terms of query time and storage.</p> <p>In Ecto, we have two ways to solve this issue. The simplest is to define multiple fields in the Comment schema, one for each association:</p> <pre data-language=\"elixir\"><code class=\"elixir\">* task_id\n* post_id</code></pre> <p>Unless you have dozens of columns, this is simpler for the developer, more DB friendly and more efficient in all aspects.</p> <p>Alternatively, because Ecto does not tie a schema to a given table, we can use separate tables for each association. Let’s start over and define a new Comment schema:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Comment do\n  use Ecto.Schema\n\n  schema \"abstract table: comments\" do\n    # This will be used by associations on each \"concrete\" table\n    field :assoc_id, :integer\n  end\nend</code></pre> <p>Notice we have changed the table name to “abstract table: comments”. You can choose whatever name you want, the point here is that this particular table will never exist.</p> <p>Now in your Post and Task schemas:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Post do\n  use Ecto.Schema\n\n  schema \"posts\" do\n    has_many :comments, {\"posts_comments\", Comment}, foreign_key: :assoc_id\n  end\nend\n\ndefmodule Task do\n  use Ecto.Schema\n\n  schema \"tasks\" do\n    has_many :comments, {\"tasks_comments\", Comment}, foreign_key: :assoc_id\n  end\nend</code></pre> <p>Now each association uses its own specific table, “posts_comments” and “tasks_comments”, which must be created on migrations. The advantage of this approach is that we never store unrelated data together, also ensuring we keep database references fast and correct.</p> <p>When using this technique, the only limitation is that you cannot build comments directly. For example, the command below</p> <pre data-language=\"elixir\"><code class=\"elixir\">Repo.insert!(%Comment{})</code></pre> <p>will attempt to use the abstract table. Instead, one should use</p> <pre data-language=\"elixir\"><code class=\"elixir\">Repo.insert!(build_assoc(post, :comments))</code></pre> <p>where <code class=\"inline\">build_assoc/3</code> is defined in <a href=\"ecto\"><code class=\"inline\">Ecto</code></a>. You can also use <code class=\"inline\">assoc/2</code> in both <a href=\"ecto\"><code class=\"inline\">Ecto</code></a> and in the query syntax to easily retrieve associated comments to a given post or task:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Fetch all comments associated to the given task\nRepo.all(assoc(task, :comments))</code></pre> <p>Finally, if for some reason you wish to query one of comments tables directly, you can also specify the tuple source in the query syntax:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Repo.all from(c in {\"posts_comments\", Comment}), ...)</code></pre>    <h3 class=\"detail-header macro\" id=\"embedded_schema/1\">  <span class=\"signature\">embedded_schema(list)</span>  </h3>  <p>Defines an embedded schema.</p> <p>An embedded schema does not require a source name and it does not include a metadata field.</p> <p>Embedded schemas by default set the primary key type to <code class=\"inline\">:binary_id</code> but such can be configured with the <code class=\"inline\">@primary_key</code> attribute.</p>    <h3 class=\"detail-header macro\" id=\"embeds_many/3\">  <span class=\"signature\">embeds_many(name, schema, opts \\\\ [])</span>  </h3>  <p>Indicates an embedding of many schemas.</p> <p>The current schema has zero or more records of the other schema embedded inside of it. Embeds have all the things regular schemas have.</p> <p>It is recommended to declare your <a href=\"#embeds_many/3\"><code class=\"inline\">embeds_many/3</code></a> field with type <code class=\"inline\">{:array, :map}</code> and default value of <code class=\"inline\">[]</code> at the database level. In fact, Ecto will automatically translate <code class=\"inline\">nil</code> values from the database into empty lists for embeds many (this behaviour is specific to <a href=\"#embeds_many/3\"><code class=\"inline\">embeds_many/3</code></a> fields in order to mimic <a href=\"#has_many/3)\"><code class=\"inline\">has_many/3</code></a>.</p> <p>For encoding and decoding of embeds, please read the docs for <a href=\"#embeds_one/3\"><code class=\"inline\">embeds_one/3</code></a>.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:on_replace</code> - The action taken on associations when the embed is replaced when casting or manipulating parent changeset. May be <code class=\"inline\">:raise</code> (default), <code class=\"inline\">:mark_as_invalid</code>, or <code class=\"inline\">:delete</code>. See <a href=\"ecto.changeset\"><code class=\"inline\">Ecto.Changeset</code></a>’s section on related data for more info. </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Order do\n  use Ecto.Schema\n\n  schema \"orders\" do\n    embeds_many :items, Item\n  end\nend\n\ndefmodule Item do\n  use Ecto.Schema\n\n  embedded_schema do\n    field :name\n  end\nend\n\n# The items are loaded with the order\norder = Repo.get!(Order, 42)\norder.items #=&gt; [%Item{...}, ...]</code></pre> <p>Adding and removal of embeds can only be done via the <a href=\"ecto.changeset\"><code class=\"inline\">Ecto.Changeset</code></a> API so Ecto can properly track the embed life-cycle:</p> <pre data-language=\"elixir\"><code class=\"elixir\">order = Repo.get!(Order, 42)\n\n# Generate a changeset\nchangeset = Ecto.Changeset.change(order)\n\n# Change, put a new one or remove all items\nchangeset = Ecto.Changeset.put_change(changeset, :items, [])\n\n# Update the order\nchangeset = Repo.update!(changeset)</code></pre>    <h3 class=\"detail-header macro\" id=\"embeds_one/3\">  <span class=\"signature\">embeds_one(name, schema, opts \\\\ [])</span>  </h3>  <p>Indicates an embedding of a schema.</p> <p>The current schema has zero or one records of the other schema embedded inside of it. It uses a field similar to the <code class=\"inline\">:map</code> type for storage, but allows embeds to have all the things regular schema can.</p> <p>You must declare your <a href=\"#embeds_one/3\"><code class=\"inline\">embeds_one/3</code></a> field with type <code class=\"inline\">:map</code> at the database level.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:on_replace</code> - The action taken on associations when the embed is replaced when casting or manipulating parent changeset. May be <code class=\"inline\">:raise</code> (default), <code class=\"inline\">:mark_as_invalid</code>, or <code class=\"inline\">:delete</code>. See <a href=\"ecto.changeset\"><code class=\"inline\">Ecto.Changeset</code></a>’s section on related data for more info. </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Order do\n  use Ecto.Schema\n\n  schema \"orders\" do\n    embeds_one :item, Item\n  end\nend\n\ndefmodule Item do\n  use Ecto.Schema\n\n  # A required field for all embedded documents\n  @primary_key {:id, :binary_id, autogenerate: true}\n  schema \"\" do\n    field :name\n  end\nend\n\n# The item is loaded with the order\norder = Repo.get!(Order, 42)\norder.item #=&gt; %Item{...}</code></pre> <p>Adding and removal of embeds can only be done via the <a href=\"ecto.changeset\"><code class=\"inline\">Ecto.Changeset</code></a> API so Ecto can properly track the embed life-cycle:</p> <pre data-language=\"elixir\"><code class=\"elixir\">order = Repo.get!(Order, 42)\n\n# Generate a changeset\nchangeset = Ecto.Changeset.change(order)\n\n# Change, put a new one or remove an item\nchangeset = Ecto.Changeset.put_change(changeset, :item, nil)\n\n# Update the order\nchangeset = Repo.update!(changeset)</code></pre> <h4>Encoding and decoding</h4> <p>Because many databases do not support direct encoding and decoding of embeds, it is often emulated by Ecto by using specific encoding and decoding rules.</p> <p>For example, PostgreSQL will store embeds on top of JSONB columns, which means types in embedded schemas won’t go through the usual dump-&gt;DB-&gt;load cycle but rather encode-&gt;DB-&gt;decode-&gt;cast. This means that, when using embedded schemas with databases like PG or MySQL, make sure all of your types can be JSON encoded/decoded correctly. Ecto provides this guarantee for all built-in types.</p>    <h3 class=\"detail-header macro\" id=\"field/3\">  <span class=\"signature\">field(name, type \\\\ :string, opts \\\\ [])</span>  </h3>  <p>Defines a field on the schema with given name and type.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:default</code> - Sets the default value on the schema and the struct. The default value is calculated at compilation time, so don’t use expressions like <code class=\"inline\">Ecto.DateTime.utc</code> or <code class=\"inline\">Ecto.UUID.generate</code> as they would then be the same for all records</p> </li> <li>\n<p><code class=\"inline\">:autogenerate</code> - Annotates the field to be autogenerated before insertion if value is not set. It will call the <code class=\"inline\">autogenerate/0</code> function in the field’s type.</p> </li> <li>\n<p><code class=\"inline\">:read_after_writes</code> - When true, the field is always read back from the database after insert and updates.</p> <p>For relational databases, this means the RETURNING option of those statements is used. For this reason, MySQL does not support this option and will raise an error if a schema is inserted/updated with read after writes fields.</p> </li> <li>\n<code class=\"inline\">:virtual</code> - When true, the field is not persisted to the database. Notice virtual fields do not support <code class=\"inline\">:autogenerate</code> nor <code class=\"inline\">:read_after_writes</code>. </li> </ul>    <h3 class=\"detail-header macro\" id=\"has_many/3\">  <span class=\"signature\">has_many(name, queryable, opts \\\\ [])</span>  </h3>  <p>Indicates a one-to-many association with another schema.</p> <p>The current schema has zero or more records of the other schema. The other schema often has a <code class=\"inline\">belongs_to</code> field with the reverse association.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:foreign_key</code> - Sets the foreign key, this should map to a field on the other schema, defaults to the underscored name of the current schema suffixed by <code class=\"inline\">_id</code></p> </li> <li>\n<p><code class=\"inline\">:references</code> - Sets the key on the current schema to be used for the association, defaults to the primary key on the schema</p> </li> <li>\n<p><code class=\"inline\">:through</code> - If this association must be defined in terms of existing associations. Read below for more information</p> </li> <li>\n<p><code class=\"inline\">:on_delete</code> - The action taken on associations when parent record is deleted. May be <code class=\"inline\">:nothing</code> (default), <code class=\"inline\">:nilify_all</code> and <code class=\"inline\">:delete_all</code>. Notice <code class=\"inline\">:on_delete</code> may also be set in migrations when creating a reference. If supported, relying on the database via migrations is preferred. <code class=\"inline\">:nilify_all</code> and <code class=\"inline\">:delete_all</code> will not cascade to child records unless set via database migrations.</p> </li> <li>\n<p><code class=\"inline\">:on_replace</code> - The action taken on associations when the record is replaced when casting or manipulating parent changeset. May be <code class=\"inline\">:raise</code> (default), <code class=\"inline\">:mark_as_invalid</code>, <code class=\"inline\">:nilify</code>, or <code class=\"inline\">:delete</code>. See <a href=\"ecto.changeset\"><code class=\"inline\">Ecto.Changeset</code></a>’s section on related data for more info.</p> </li> <li>\n<code class=\"inline\">:defaults</code> - Default values to use when building the association </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Post do\n  use Ecto.Schema\n  schema \"posts\" do\n    has_many :comments, Comment\n  end\nend\n\n# Get all comments for a given post\npost = Repo.get(Post, 42)\ncomments = Repo.all assoc(post, :comments)\n\n# The comments can come preloaded on the post struct\n[post] = Repo.all(from(p in Post, where: p.id == 42, preload: :comments))\npost.comments #=&gt; [%Comment{...}, ...]</code></pre> <h4>has_many/has_one :through</h4> <p>Ecto also supports defining associations in terms of other associations via the <code class=\"inline\">:through</code> option. Let’s see an example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Post do\n  use Ecto.Schema\n\n  schema \"posts\" do\n    has_many :comments, Comment\n    has_one :permalink, Permalink\n\n    # In the has_many :through example below, the `:comments`\n    # in the list [:comments, :author] refers to the\n    # `has_many :comments` in the Post own schema and the\n    # `:author` refers to the `belongs_to :author` of the\n    # Comment's schema (the module below).\n    # (see the description below for more details)\n    has_many :comments_authors, through: [:comments, :author]\n\n    # Specify the association with custom source\n    has_many :tags, {\"posts_tags\", Tag}\n  end\nend\n\ndefmodule Comment do\n  use Ecto.Schema\n\n  schema \"comments\" do\n    belongs_to :author, Author\n    belongs_to :post, Post\n    has_one :post_permalink, through: [:post, :permalink]\n  end\nend</code></pre> <p>In the example above, we have defined a <code class=\"inline\">has_many :through</code> association named <code class=\"inline\">:comments_authors</code>. A <code class=\"inline\">:through</code> association always expects a list and the first element of the list must be a previously defined association in the current module. For example, <code class=\"inline\">:comments_authors</code> first points to <code class=\"inline\">:comments</code> in the same module (Post), which then points to <code class=\"inline\">:author</code> in the next schema, <code class=\"inline\">Comment</code>.</p> <p>This <code class=\"inline\">:through</code> association will return all authors for all comments that belongs to that post:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Get all comments for a given post\npost = Repo.get(Post, 42)\nauthors = Repo.all assoc(post, :comments_authors)</code></pre> <p><code class=\"inline\">:through</code> associations are read-only as they are useful for avoiding repetition, allowing the developer to easily retrieve data that is often seen together but stored across different tables.</p> <p><code class=\"inline\">:through</code> associations can also be preloaded. In such cases, not only the <code class=\"inline\">:through</code> association is preloaded but all intermediate steps are preloaded too:</p> <pre data-language=\"elixir\"><code class=\"elixir\">[post] = Repo.all(from(p in Post, where: p.id == 42, preload: :comments_authors))\npost.comments_authors #=&gt; [%Author{...}, ...]\n\n# The comments for each post will be preloaded too\npost.comments #=&gt; [%Comment{...}, ...]\n\n# And the author for each comment too\nhd(post.comments).author #=&gt; %Author{...}</code></pre> <p>Finally, <code class=\"inline\">:through</code> can be used with multiple associations (not only 2) and with associations of any kind, including <code class=\"inline\">belongs_to</code> and other <code class=\"inline\">:through</code> associations. When the <code class=\"inline\">:through</code> association is expected to return one or zero items, <code class=\"inline\">has_one :through</code> should be used instead, as in the example at the beginning of this section:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># How we defined the association above\nhas_one :post_permalink, through: [:post, :permalink]\n\n# Get a preloaded comment\n[comment] = Repo.all(Comment) |&gt; Repo.preload(:post_permalink)\ncomment.post_permalink #=&gt; %Permalink{...}</code></pre>    <h3 class=\"detail-header macro\" id=\"has_one/3\">  <span class=\"signature\">has_one(name, queryable, opts \\\\ [])</span>  </h3>  <p>Indicates a one-to-one association with another schema.</p> <p>The current schema has zero or one records of the other schema. The other schema often has a <code class=\"inline\">belongs_to</code> field with the reverse association.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:foreign_key</code> - Sets the foreign key, this should map to a field on the other schema, defaults to the underscored name of the current schema suffixed by <code class=\"inline\">_id</code></p> </li> <li>\n<p><code class=\"inline\">:references</code> - Sets the key on the current schema to be used for the association, defaults to the primary key on the schema</p> </li> <li>\n<p><code class=\"inline\">:through</code> - If this association must be defined in terms of existing associations. Read the section in <a href=\"#has_many/3\"><code class=\"inline\">has_many/3</code></a> for more information</p> </li> <li>\n<p><code class=\"inline\">:on_delete</code> - The action taken on associations when parent record is deleted. May be <code class=\"inline\">:nothing</code> (default), <code class=\"inline\">:nilify_all</code> and <code class=\"inline\">:delete_all</code>. Notice <code class=\"inline\">:on_delete</code> may also be set in migrations when creating a reference. If supported, relying on the database via migrations is preferred. <code class=\"inline\">:nilify_all</code> and <code class=\"inline\">:delete_all</code> will not cascade to child records unless set via database migrations.</p> </li> <li>\n<p><code class=\"inline\">:on_replace</code> - The action taken on associations when the record is replaced when casting or manipulating parent changeset. May be <code class=\"inline\">:raise</code> (default), <code class=\"inline\">:mark_as_invalid</code>, <code class=\"inline\">:nilify</code>, or <code class=\"inline\">:delete</code>. See <a href=\"ecto.changeset\"><code class=\"inline\">Ecto.Changeset</code></a>’s section on related data for more info.</p> </li> <li>\n<code class=\"inline\">:defaults</code> - Default values to use when building the association </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Post do\n  use Ecto.Schema\n\n  schema \"posts\" do\n    has_one :permalink, Permalink\n\n    # Specify the association with custom source\n    has_one :category, {\"posts_categories\", Category}\n  end\nend\n\n# The permalink can come preloaded on the post struct\n[post] = Repo.all(from(p in Post, where: p.id == 42, preload: :permalink))\npost.permalink #=&gt; %Permalink{...}</code></pre>    <h3 class=\"detail-header macro\" id=\"many_to_many/3\">  <span class=\"signature\">many_to_many(name, queryable, opts \\\\ [])</span>  </h3>  <p>Indicates a many-to-many association with another schema.</p> <p>The association happens through a join schema or source, containing foreign keys to the associated schemas. For example, the association below:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># from MyApp.Post\nmany_to_many :tags, MyApp.Tag, join_through: \"posts_tags\"</code></pre> <p>is backed by relational databases through a join table as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\">[Post] &lt;-&gt; [posts_tags] &lt;-&gt; [Tag]\n  id   &lt;--   post_id\n              tag_id    --&gt;  id</code></pre> <p>More information on the migration for creating such a schema is shown below.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:join_through</code> - specifies the source of the associated data. It may be a string, like “posts_tags”, representing the underlying storage table or an atom, like <code class=\"inline\">MyApp.PostTag</code>, representing a schema. This option is required.</p> </li> <li>\n<p><code class=\"inline\">:join_keys</code> - specifies how the schemas are associated. It expects a keyword list with two entries, the first being how the join table should reach the current schema and the second how the join table should reach the associated schema. In the example above, it defaults to: <code class=\"inline\">[post_id: :id, tag_id: :id]</code>. The keys are inflected from the schema names.</p> </li> <li>\n<p><code class=\"inline\">:on_delete</code> - The action taken on associations when the parent record is deleted. May be <code class=\"inline\">:nothing</code> (default) or <code class=\"inline\">:delete_all</code>. <code class=\"inline\">:delete_all</code> will only remove data from the join source, never the associated records. Notice <code class=\"inline\">:on_delete</code> may also be set in migrations when creating a reference. If supported, relying on the database via migrations is preferred. <code class=\"inline\">:nilify_all</code> and <code class=\"inline\">:delete_all</code> will not cascade to child records unless set via database migrations.</p> </li> <li>\n<p><code class=\"inline\">:on_replace</code> - The action taken on associations when the record is replaced when casting or manipulating parent changeset. May be <code class=\"inline\">:raise</code> (default), <code class=\"inline\">:mark_as_invalid</code>, or <code class=\"inline\">:delete</code>. <code class=\"inline\">:delete</code> will only remove data from the join source, never the associated records. See <a href=\"ecto.changeset\"><code class=\"inline\">Ecto.Changeset</code></a>’s section on related data for more info.</p> </li> <li>\n<code class=\"inline\">:defaults</code> - Default values to use when building the association </li> </ul> <h4>Removing data</h4> <p>If you attempt to remove associated <code class=\"inline\">many_to_many</code> data, be it by setting <code class=\"inline\">:on_replace</code> to <code class=\"inline\">:delete</code>, <code class=\"inline\">:on_delete</code> to <code class=\"inline\">:delete_all</code> or by using <code class=\"inline\">Ecto.Changeset.put_assoc/3</code> and <a href=\"ecto.changeset#cast_assoc/3\"><code class=\"inline\">Ecto.Changeset.cast_assoc/3</code></a>, <strong>Ecto will always remove data from the join schema and never from the target associations</strong>. For example, if a <code class=\"inline\">Post</code> has a many to many relationship with <code class=\"inline\">Tag</code>, setting <code class=\"inline\">:on_delete</code> to <code class=\"inline\">:delete_all</code> will only delete entries from the “posts_tags” table in case <code class=\"inline\">Post</code> is deleted.</p> <h4>Migration</h4> <p>How your migration should be structured depends on the value you pass in <code class=\"inline\">:join_through</code>. If <code class=\"inline\">:join_through</code> is simply a string, representing a table, you may define a table without primary keys and you must not include any further columns, as those values won’t be set by Ecto:</p> <pre data-language=\"elixir\"><code class=\"elixir\">create table(:posts_tags, primary_key: false) do\n  add :post_id, references(:posts)\n  add :tag_id, references(:tags)\nend</code></pre> <p>However, if your <code class=\"inline\">:join_through</code> is a schema, like <code class=\"inline\">MyApp.PostTag</code>, your join table may be structured as any other table in your codebase, including timestamps:</p> <pre data-language=\"elixir\"><code class=\"elixir\">create table(:posts_tags) do\n  add :post_id, references(:posts)\n  add :tag_id, references(:tags)\n  timestamps\nend</code></pre> <p>Because <code class=\"inline\">:join_through</code> contains a schema, in such cases, autogenerated values and primary keys will be automatically handled by Ecto.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Post do\n  use Ecto.Schema\n  schema \"posts\" do\n    many_to_many :tags, Tag, join_through: \"posts_tags\"\n  end\nend\n\n# Get all tags for a given post\npost = Repo.get(Post, 42)\ntags = Repo.all assoc(post, :tags)\n\n# The tags can come preloaded on the post struct\n[post] = Repo.all(from(p in Post, where: p.id == 42, preload: :tags))\npost.tags #=&gt; [%Tag{...}, ...]</code></pre>    <h3 class=\"detail-header macro\" id=\"schema/2\">  <span class=\"signature\">schema(source, list)</span>  </h3>  <p>Defines a schema with a source name and field definitions.</p>    <h3 class=\"detail-header macro\" id=\"timestamps/1\">  <span class=\"signature\">timestamps(opts \\\\ [])</span>  </h3>  <p>Generates <code class=\"inline\">:inserted_at</code> and <code class=\"inline\">:updated_at</code> timestamp fields.</p> <p>The fields generated by this macro will automatically be set to the current time when inserting and updating values in a repository.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:type</code> - the timestamps type, defaults to <a href=\"ecto.datetime\"><code class=\"inline\">Ecto.DateTime</code></a>. </li> <li>\n<code class=\"inline\">:usec</code> - boolean, sets whether microseconds are used in timestamps. Microseconds will be 0 if false. Defaults to false. </li> <li>\n<code class=\"inline\">:inserted_at</code> - the name of the column for insertion times or <code class=\"inline\">false</code> </li> <li>\n<code class=\"inline\">:updated_at</code> - the name of the column for update times or <code class=\"inline\">false</code> </li> <li>\n<code class=\"inline\">:autogenerate</code> - a module-function-args tuple used for generating both <code class=\"inline\">inserted_at</code> and <code class=\"inline\">updated_at</code> timestamps </li> </ul> <p>All options can be pre-configured by setting <code class=\"inline\">@timestamps_opts</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/ecto/Ecto.Schema.html\" class=\"_attribution-link\">https://hexdocs.pm/ecto/Ecto.Schema.html</a>\n  </p>\n</div>\n","phoenix_pubsub/phoenix.pubsub.pg2":"<h1>  Phoenix.PubSub.PG2 </h1>  <p>Phoenix PubSub adapter based on PG2.</p> <p>To use it as your PubSub adapter, simply add it to your Endpoint's config:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :my_app, MyApp.Endpoint,\n  pubsub: [name: MyApp.PubSub,\n           adapter: Phoenix.PubSub.PG2]</code></pre> <h2 id=\"options\">Options</h2> <ul> <li><p><code>:name</code> - The registered name and optional node name to for the PubSub processes, for example: <code>MyApp.PubSub</code>, <code>{MyApp.PubSub, :node@host}</code>. When only a server name is provided, the node name defaults to <code>node()</code>.</p></li> <li><p><code>:pool_size</code> - Both the size of the local pubsub server pool and subscriber shard size. Defaults the number of schedulers (cores). A single pool is often enough for most use-cases, but for high subscriber counts on a single topic or greater than 1M clients, a pool size equal to the number of schedulers (cores) is a well rounded size.</p></li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#start_link/2\">start_link(name, opts)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"start_link/2\">  <span class=\"signature\">start_link(name, opts)</span> </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.PG2.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.PG2.html</a>\n  </p>\n</div>\n","phoenix_pubsub/phoenix.pubsub.broadcasterror":"<h1>  Phoenix.PubSub.BroadcastError <small>exception</small> </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code>c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code>c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code>c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html#t:t/0\">Exception.t</a>) :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code>c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.BroadcastError.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.BroadcastError.html</a>\n  </p>\n</div>\n","plug/plug.adapters.cowboy":"<h1>  Plug.Adapters.Cowboy  </h1>  <p>Adapter interface to the Cowboy webserver.</p> <h2 id=\"module-options\" class=\"section-heading\">  Options </h2> <ul> <li>\n<p><code class=\"inline\">:ip</code> - the ip to bind the server to. Must be a tuple in the format <code class=\"inline\">{x, y, z, w}</code>.</p> </li> <li>\n<p><code class=\"inline\">:port</code> - the port to run the server. Defaults to 4000 (http) and 4040 (https).</p> </li> <li>\n<p><code class=\"inline\">:acceptors</code> - the number of acceptors for the listener. Defaults to 100.</p> </li> <li>\n<p><code class=\"inline\">:max_connections</code> - max number of connections supported. Defaults to <code class=\"inline\">16384</code>.</p> </li> <li>\n<p><code class=\"inline\">:dispatch</code> - manually configure Cowboy’s dispatch. If this option is used, the given plug won’t be initialized nor dispatched to (and doing so becomes the user’s responsibility).</p> </li> <li>\n<p><code class=\"inline\">:ref</code> - the reference name to be used. Defaults to <code class=\"inline\">plug.HTTP</code> (http) and <code class=\"inline\">plug.HTTPS</code> (https). This is the value that needs to be given on shutdown.</p> </li> <li>\n<p><code class=\"inline\">:compress</code> - Cowboy will attempt to compress the response body. Defaults to false.</p> </li> <li>\n<p><code class=\"inline\">:timeout</code> - Time in ms with no requests before Cowboy closes the connection. Defaults to 5000ms.</p> </li> <li>\n<code class=\"inline\">:protocol_options</code> - Specifies remaining protocol options, see <a href=\"http://ninenines.eu/docs/en/cowboy/1.0/manual/cowboy_protocol/\">Cowboy protocol docs</a>. </li> </ul> <p>All other options are given to the underlying transport.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#child_spec/4\">child_spec(scheme, plug, opts, cowboy_options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a child spec to be supervised by your application</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#http/3\">http(plug, opts, cowboy_options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Run cowboy under http</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#https/3\">https(plug, opts, cowboy_options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Run cowboy under https</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#shutdown/1\">shutdown(ref)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Shutdowns the given reference</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"child_spec/4\">  <span class=\"signature\">child_spec(scheme, plug, opts, cowboy_options \\\\ [])</span>  </h3>  <p>Returns a child spec to be supervised by your application.</p> <h4>Example</h4> <p>Presuming your Plug module is named <code class=\"inline\">MyRouter</code> you can add it to your supervision tree like so using this function:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp do\n  use Application\n\n  def start(_type, _args) do\n    import Supervisor.Spec\n\n    children = [\n      Plug.Adapters.Cowboy.child_spec(:http, MyRouter, [], [port: 4001])\n    ]\n\n    opts = [strategy: :one_for_one, name: MyApp.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\nend</code></pre>    <h3 class=\"detail-header function\" id=\"http/3\">  <span class=\"signature\">http(plug, opts, cowboy_options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">http(module, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, pid} |\n  {:error, :eaddrinuse} |\n  {:error, term}</code></pre>    <p>Run cowboy under http.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Starts a new interface\nPlug.Adapters.Cowboy.http MyPlug, [], port: 80\n\n# The interface above can be shutdown with\nPlug.Adapters.Cowboy.shutdown MyPlug.HTTP</code></pre>    <h3 class=\"detail-header function\" id=\"https/3\">  <span class=\"signature\">https(plug, opts, cowboy_options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">https(module, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, pid} |\n  {:error, :eaddrinuse} |\n  {:error, term}</code></pre>    <p>Run cowboy under https.</p> <p>Besides the options described in the module documentation, this module also accepts all options defined in [the `ssl` erlang module] (<a href=\"http://www.erlang.org/doc/man/ssl.html\">http://www.erlang.org/doc/man/ssl.html</a>), like keyfile, certfile, cacertfile, dhfile and others.</p> <p>The certificate files can be given as a relative path. For such, the <code class=\"inline\">:otp_app</code> option must also be given and certificates will be looked from the priv directory of the given application.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Starts a new interface\nPlug.Adapters.Cowboy.https MyPlug, [],\n  port: 443,\n  password: \"SECRET\",\n  otp_app: :my_app,\n  keyfile: \"priv/ssl/key.pem\",\n  certfile: \"priv/ssl/cert.pem\",\n  dhfile: \"priv/ssl/dhparam.pem\"\n\n# The interface above can be shutdown with\nPlug.Adapters.Cowboy.shutdown MyPlug.HTTPS</code></pre>    <h3 class=\"detail-header function\" id=\"shutdown/1\">  <span class=\"signature\">shutdown(ref)</span>  </h3>  <p>Shutdowns the given reference.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://hexdocs.pm/plug/Plug.Adapters.Cowboy.html\" class=\"_attribution-link\">https://hexdocs.pm/plug/Plug.Adapters.Cowboy.html</a>\n  </p>\n</div>\n","phoenix_pubsub/phoenix.tracker":"<h1>  Phoenix.Tracker <small>behaviour</small> </h1>  <p>Provides distributed Presence tracking to processes.</p> <p>Tracker servers use a heartbeat protocol and CRDT to replicate presence information across a cluster in an eventually consistent, conflict-free manner. Under this design, there is no single source of truth or global process. Instead, each node runs one or more <a href=\"phoenix.tracker#content\"><code>Phoenix.Tracker</code></a> servers and node-local changes are replicated across the cluster and handled locally as a diff of changes.</p> <ul> <li>\n<code>tracker</code> - The name of the tracker handler module implementing the <a href=\"phoenix.tracker#content\"><code>Phoenix.Tracker</code></a> behaviour</li> <li>\n<code>tracker_opts</code> - The list of options to pass to the tracker handler</li> <li>\n<code>server_opts</code> - The list of options to pass to the tracker server</li> </ul> <h2 id=\"required-server_opts\">Required <code>server_opts</code>:</h2> <ul> <li>\n<code>:name</code> - The name of the server, such as: <code>MyApp.Tracker</code>\n</li> <li>\n<code>:pubsub_server</code> - The name of the PubSub server, such as: <code>MyApp.PubSub</code>\n</li> </ul> <h2 id=\"optional-server_opts\">Optional <code>server_opts</code>:</h2> <ul> <li>\n<code>broadcast_period</code> - The interval in milliseconds to send delta broadcats across the cluster. Default <code>1500</code>\n</li> <li>\n<code>max_silent_periods</code> - The max integer of broadcast periods for which no delta broadcasts have been sent. Defaults <code>10</code> (15s heartbeat)</li> <li>\n<code>down_period</code> - The interval in milliseconds to flag a replica as down temporarily down. Default <code>broadcast_period * max_silent_periods * 2</code> (30s down detection). Note: This must be at least 2x the <code>broadcast_period</code>.</li> <li>\n<code>permdown_period</code> - The interval in milliseconds to flag a replica as permanently down, and discard its state. Note: This must be at least greater than the <code>down_period</code>. Default <code>1_200_000</code> (20 minutes)</li> <li>\n<code>clock_sample_periods</code> - The numbers of heartbeat windows to sample remote clocks before collapsing and requesting transfer. Default <code>2</code>\n</li> <li>\n<code>max_delta_sizes</code> - The list of delta generation sizes to keep before falling back to sending entire state. Defaults <code>[100, 1000, 10_000]</code>.</li> <li>log_level - The log level to log events, defaults <code>:debug</code> and can be disabled with <code>false</code>\n</li> </ul> <h2 id=\"implementing-a-tracker\">Implementing a Tracker</h2> <p>To start a tracker, first add the tracker to your supervision tree:</p> <pre data-language=\"elixir\"><code class=\"elixir\">worker(MyTracker, [[name: MyTracker, pubsub_server: MyPubSub]])</code></pre> <p>Next, implement <code>MyTracker</code> with support for the <a href=\"phoenix.tracker#content\"><code>Phoenix.Tracker</code></a> behaviour callbacks. An example of a minimal tracker could include:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyTracker do\n  @behaviour Phoenix.Tracker\n\n  def start_link(opts) do\n    opts = Keyword.merge([name: __MODULE__], opts)\n    GenServer.start_link(Phoenix.Tracker, [__MODULE__, opts, opts], name: __MODULE__)\n  end\n\n  def init(opts) do\n    server = Keyword.fetch!(opts, :pubsub_server)\n    {:ok, %{pubsub_server: server, node_name: Phoenix.PubSub.node_name(server)}}\n  end\n\n  def handle_diff(diff, state) do\n    for {topic, {joins, leaves}} &lt;- diff do\n      for {key, meta} &lt;- joins do\n        IO.puts \"presence join: key \\\"#{key}\\\" with meta #{inspect meta}\"\n        msg = {:join, key, meta}\n        Phoenix.PubSub.direct_broadcast!(state.node_name, state.pubsub_server, topic, msg)\n      end\n      for {key, meta} &lt;- leaves do\n        IO.puts \"presence leave: key \\\"#{key}\\\" with meta #{inspect meta}\"\n        msg = {:leave, key, meta}\n        Phoenix.PubSub.direct_broadcast!(state.node_name, state.pubsub_server, topic, msg)\n      end\n    end\n    {:ok, state}\n  end\nend</code></pre> <p>Trackers must implement <code>start_link/1</code>, <code>init/1</code>, and <code>handle_diff/2</code>. The <code>init/1</code> callback allows the tracker to manage its own state when running within the <a href=\"phoenix.tracker#content\"><code>Phoenix.Tracker</code></a> server. The <code>handle_diff</code> callback is invoked with a diff of presence join and leave events, grouped by topic. As replicas heartbeat and replicate data, the local tracker state is merged with the remote data, and the diff is sent to the callback. The handler can use this information to notify subscribers of events, as done above.</p> <h2 id=\"special-considerations\">Special Considerations</h2> <p>Operations within <code>handle_diff/2</code> happen <em>in the tracker server's context</em>. Therefore, blocking operations should be avoided when possible, and offloaded to a supervised task when required. Also, a crash in the <code>handle_diff/2</code> will crash the tracker server, so operations that may crash the server should be offloaded with a <code>Task.Supervisor</code> spawned process.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:presence/0\">presence()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:topic/0\">topic()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#graceful_permdown/1\">graceful_permdown(server_name)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gracefully shuts down by broadcasting permdown to all replicas</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#list/2\">list(server_name, topic)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Lists all presences tracked under a given topic</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/3\">start_link(tracker, tracker_opts, server_opts)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#track/5\">track(server_name, pid, topic, key, meta)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Tracks a presence</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#untrack/2\">untrack(server_name, pid)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#untrack/4\">untrack(server_name, pid, topic, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Untracks a presence</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update/5\">update(server_name, pid, topic, key, meta)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates a presence's metadata</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate_down_period/2\">validate_down_period(d_period, b_period)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#validate_permdown_period/2\">validate_permdown_period(p_period, d_period)</a> </dt>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:handle_diff/2\">handle_diff(%{}, state)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:init/1\">init(arg0)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:presence/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:presence/0\">presence</a> :: {key :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a>, meta :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Map.html#t:t/0\">Map.t</a>}</code></pre> </div> <div id=\"t:topic/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:topic/0\">topic</a> :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"graceful_permdown/1\">  <span class=\"signature\">graceful_permdown(server_name)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">graceful_permdown(atom) :: :ok</code></pre>    <p>Gracefully shuts down by broadcasting permdown to all replicas.</p> <h4 id=\"examples\">Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Tracker.graceful_permdown(MyTracker)\n:ok</code></pre>    <h3 class=\"detail-header function\" id=\"list/2\">  <span class=\"signature\">list(server_name, topic)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">list(atom, <a href=\"#t:topic/0\">topic</a>) :: [<a href=\"#t:presence/0\">presence</a>]</code></pre>    <p>Lists all presences tracked under a given topic.</p> <ul> <li>\n<code>server_name</code> - The registered name of the tracker server</li> <li>\n<code>topic</code> - The <a href=\"phoenix.pubsub\"><code>Phoenix.PubSub</code></a> topic to update for this presence</li> </ul> <p>Returns a lists of presences in key/metadata tuple pairs.</p> <h4 id=\"examples\">Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Tracker.list(MyTracker, \"lobby\")\n[{123, %{name: \"user 123\"}}, {456, %{name: \"user 456\"}}]</code></pre>    <h3 class=\"detail-header function\" id=\"start_link/3\">  <span class=\"signature\">start_link(tracker, tracker_opts, server_opts)</span> </h3>     <h3 class=\"detail-header function\" id=\"track/5\">  <span class=\"signature\">track(server_name, pid, topic, key, meta)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">track(atom, pid, <a href=\"#t:topic/0\">topic</a>, term, <a href=\"http://elixir-lang.org/docs/stable/elixir/Map.html#t:t/0\">Map.t</a>) ::\n  {:ok, ref :: binary} |\n  {:error, reason :: term}</code></pre>    <p>Tracks a presence.</p> <ul> <li>\n<code>server_name</code> - The registered name of the tracker server</li> <li>\n<code>pid</code> - The Pid to track</li> <li>\n<code>topic</code> - The <a href=\"phoenix.pubsub\"><code>Phoenix.PubSub</code></a> topic for this presence</li> <li>\n<code>key</code> - The key identifying this presence</li> <li>\n<code>meta</code> - The map of metadata to attach to this presence</li> </ul> <h4 id=\"examples\">Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Tracker.track(MyTracker, self, \"lobby\", u.id, %{stat: \"away\"})\n{:ok, \"1WpAofWYIAA=\"}</code></pre>    <h3 class=\"detail-header function\" id=\"untrack/2\">  <span class=\"signature\">untrack(server_name, pid)</span> </h3>     <h3 class=\"detail-header function\" id=\"untrack/4\">  <span class=\"signature\">untrack(server_name, pid, topic, key)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">untrack(atom, pid, <a href=\"#t:topic/0\">topic</a>, term) :: :ok</code></pre>    <p>Untracks a presence.</p> <ul> <li>\n<code>server_name</code> - The registered name of the tracker server</li> <li>\n<code>pid</code> - The Pid to untrack</li> <li>\n<code>topic</code> - The <a href=\"phoenix.pubsub\"><code>Phoenix.PubSub</code></a> topic to untrack for this presence</li> <li>\n<code>key</code> - The key identifying this presence</li> </ul> <p>All presences for a given Pid can be untracked by calling the <code>Phoenix.Tracker.track/2</code> signature of this function.</p> <h4 id=\"examples\">Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Tracker.untrack(MyTracker, self, \"lobby\", u.id)\n:ok\niex&gt; Phoenix.Tracker.untrack(MyTracker, self)\n:ok</code></pre>    <h3 class=\"detail-header function\" id=\"update/5\">  <span class=\"signature\">update(server_name, pid, topic, key, meta)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update(atom, pid, <a href=\"#t:topic/0\">topic</a>, term, <a href=\"http://elixir-lang.org/docs/stable/elixir/Map.html#t:t/0\">Map.t</a>) ::\n  {:ok, ref :: binary} |\n  {:error, reason :: term}</code></pre>    <p>Updates a presence's metadata.</p> <ul> <li>\n<code>server_name</code> - The registered name of the tracker server</li> <li>\n<code>pid</code> - The Pid being tracked</li> <li>\n<code>topic</code> - The <a href=\"phoenix.pubsub\"><code>Phoenix.PubSub</code></a> topic to update for this presence</li> <li>\n<code>key</code> - The key identifying this presence</li> </ul> <p>All presences for a given Pid can be untracked by calling the <code>Phoenix.Tracker.track/2</code> signature of this function.</p> <h4 id=\"examples\">Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Tracker.update(MyTracker, self, \"lobby\", u.id, %{stat: \"zzz\"})\n{:ok, \"1WpAofWYIAA=\"}</code></pre>    <h3 class=\"detail-header function\" id=\"validate_down_period/2\">  <span class=\"signature\">validate_down_period(d_period, b_period)</span> </h3>     <h3 class=\"detail-header function\" id=\"validate_permdown_period/2\">  <span class=\"signature\">validate_permdown_period(p_period, d_period)</span> </h3>      <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:handle_diff/2\">  <span class=\"signature\">handle_diff(%{}, state)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_diff(%{optional(<a href=\"#t:topic/0\">topic</a>) =&gt; {joins :: [<a href=\"#t:presence/0\">presence</a>], leaves :: [<a href=\"#t:presence/0\">presence</a>]}}, state :: term) :: {:ok, state :: term}</code></pre>       <h3 class=\"detail-header callback\" id=\"c:init/1\">  <span class=\"signature\">init(arg0)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">init(<a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  {:ok, pid} |\n  {:error, reason :: term}</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_pubsub/Phoenix.Tracker.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_pubsub/Phoenix.Tracker.html</a>\n  </p>\n</div>\n","phoenix_pubsub/phoenix.pubsub":"<h1>  Phoenix.PubSub </h1>  <p>Front-end to Phoenix pubsub layer.</p> <p>Used internally by Channels for pubsub broadcast but also provides an API for direct usage.</p> <h2 id=\"adapters\">Adapters</h2> <p>Phoenix pubsub was designed to be flexible and support multiple backends. We currently ship with two backends:</p> <ul> <li><p><code>Phoenix.PubSub.PG2</code> - uses Distributed Elixir, directly exchanging notifications between servers</p></li> <li><p><code>Phoenix.PubSub.Redis</code> - uses Redis to exchange data between servers</p></li> </ul> <p>Pubsub adapters are often configured in your endpoint:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :my_app, MyApp.Endpoint,\n  pubsub: [adapter: Phoenix.PubSub.PG2,\n           pool_size: 1,\n           name: MyApp.PubSub]</code></pre> <p>The configuration above takes care of starting the pubsub backend and exposing its functions via the endpoint module. If no adapter but a name is given, nothing will be started, but the pubsub system will work by sending events and subscribing to the given name.</p> <h2 id=\"direct-usage\">Direct usage</h2> <p>It is also possible to use <a href=\"phoenix.pubsub#content\"><code>Phoenix.PubSub</code></a> directly or even run your own pubsub backends outside of an Endpoint.</p> <p>The first step is to start the adapter of choice in your supervision tree:</p> <pre data-language=\"elixir\"><code class=\"elixir\">supervisor(Phoenix.PubSub.Redis, [:my_redis_pubsub, host: \"192.168.100.1\"])</code></pre> <p>The configuration above will start a Redis pubsub and register it with name <code>:my_redis_pubsub</code>.</p> <p>You can now use the functions in this module to subscribe and broadcast messages:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; PubSub.subscribe MyApp.PubSub, self, \"user:123\"\n:ok\niex&gt; Process.info(self)[:messages]\n[]\niex&gt; PubSub.broadcast MyApp.PubSub, \"user:123\", {:user_update, %{id: 123, name: \"Shane\"}}\n:ok\niex&gt; Process.info(self)[:messages]\n{:user_update, %{id: 123, name: \"Shane\"}}</code></pre> <h2 id=\"implementing-your-own-adapter\">Implementing your own adapter</h2> <p>PubSub adapters run inside their own supervision tree. If you are interested in providing your own adapter, let's call it <code>Phoenix.PubSub.MyQueue</code>, the first step is to provide a supervisor module that receives the server name and a bunch of options on <code>start_link/2</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Phoenix.PubSub.MyQueue do\n  def start_link(name, options) do\n    Supervisor.start_link(__MODULE__, {name, options},\n                          name: Module.concat(name, Supervisor))\n  end\n\n  def init({name, options}) do\n    ...\n  end\nend</code></pre> <p>On <code>init/1</code>, you will define the supervision tree and use the given <code>name</code> to register the main pubsub process locally. This process must be able to handle the following GenServer calls:</p> <ul> <li><p><code>subscribe</code> - subscribes the given pid to the given topic sends: <code>{:subscribe, pid, topic, opts}</code> respond with: <code>:ok | {:error, reason} | {:perform, {m, f, a}}</code></p></li> <li><p><code>unsubscribe</code> - unsubscribes the given pid from the given topic sends: <code>{:unsubscribe, pid, topic}</code> respond with: <code>:ok | {:error, reason} | {:perform, {m, f, a}}</code></p></li> <li><p><code>broadcast</code> - broadcasts a message on the given topic sends: <code>{:broadcast, :none | pid, topic, message}</code> respond with: <code>:ok | {:error, reason} | {:perform, {m, f, a}}</code></p></li> </ul> <h3 id=\"offloading-work-to-clients-via-mfa-response\">Offloading work to clients via MFA response</h3> <p>The <a href=\"phoenix.pubsub#content\"><code>Phoenix.PubSub</code></a> API allows any of its functions to handle a response from the adapter matching <code>{:perform, {m, f, a}}</code>. The PubSub client will recursively invoke all MFA responses until a result is returned. This is useful for offloading work to clients without blocking your PubSub adapter. See <code>Phoenix.PubSub.PG2</code> implementation for examples.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:node_name/0\">node_name()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#broadcast/3\">broadcast(server, topic, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Broadcasts message on given topic</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#broadcast!/3\">broadcast!(server, topic, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Broadcasts message on given topic</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#broadcast_from/4\">broadcast_from(server, from_pid, topic, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Broadcasts message to all but <code>from_pid</code> on given topic. See <a href=\"phoenix.pubsub#broadcast/3\"><code>Phoenix.PubSub.broadcast/3</code></a> for usage details</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#broadcast_from!/4\">broadcast_from!(server, from_pid, topic, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Broadcasts message to all but <code>from_pid</code> on given topic</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#direct_broadcast/4\">direct_broadcast(node_name, server, topic, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Broadcasts message on given topic, to a single node</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#direct_broadcast!/4\">direct_broadcast!(node_name, server, topic, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Broadcasts message on given topic, to a single node</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#direct_broadcast_from/5\">direct_broadcast_from(node_name, server, from_pid, topic, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Broadcasts message to all but <code>from_pid</code> on given topic, to a single node. See <a href=\"phoenix.pubsub#broadcast/3\"><code>Phoenix.PubSub.broadcast/3</code></a> for usage details</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#direct_broadcast_from!/5\">direct_broadcast_from!(node_name, server, from_pid, topic, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Broadcasts message to all but <code>from_pid</code> on given topic, to a single node</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#node_name/1\">node_name(server)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the node name of the PubSub server</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subscribe/2\">subscribe(server, topic)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#subscribe/3\">subscribe(server, pid, topic)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Subscribes the caller to the PubSub adapter's topic</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subscribe/4\">subscribe(server, pid, topic, opts)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#unsubscribe/2\">unsubscribe(server, topic)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#unsubscribe/3\">unsubscribe(server, pid, topic)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Unsubscribes the caller from the PubSub adapter's topic</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:node_name/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:node_name/0\">node_name</a> :: atom :: binary</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"broadcast/3\">  <span class=\"signature\">broadcast(server, topic, message)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">broadcast(atom, binary, term) ::\n  :ok |\n  {:error, term}</code></pre>    <p>Broadcasts message on given topic.</p> <ul> <li>\n<code>server</code> - The Pid or registered server name and optional node to scope the broadcast, for example: <code>MyApp.PubSub</code>, <code>{MyApp.PubSub, :a@node}</code>\n</li> <li>\n<code>topic</code> - The topic to broadcast to, ie: <code>\"users:123\"</code>\n</li> <li>\n<code>message</code> - The payload of the broadcast</li> </ul>    <h3 class=\"detail-header function\" id=\"broadcast!/3\">  <span class=\"signature\">broadcast!(server, topic, message)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">broadcast!(atom, binary, term) :: :ok | no_return</code></pre>    <p>Broadcasts message on given topic.</p> <p>Raises <a href=\"phoenix.pubsub.broadcasterror\"><code>Phoenix.PubSub.BroadcastError</code></a> if broadcast fails. See <a href=\"phoenix.pubsub#broadcast/3\"><code>Phoenix.PubSub.broadcast/3</code></a> for usage details.</p>    <h3 class=\"detail-header function\" id=\"broadcast_from/4\">  <span class=\"signature\">broadcast_from(server, from_pid, topic, message)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">broadcast_from(atom, pid, binary, term) ::\n  :ok |\n  {:error, term}</code></pre>    <p>Broadcasts message to all but <code>from_pid</code> on given topic. See <a href=\"phoenix.pubsub#broadcast/3\"><code>Phoenix.PubSub.broadcast/3</code></a> for usage details.</p>    <h3 class=\"detail-header function\" id=\"broadcast_from!/4\">  <span class=\"signature\">broadcast_from!(server, from_pid, topic, message)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">broadcast_from!(atom | {atom, atom}, pid, binary, term) ::\n  :ok |\n  no_return</code></pre>    <p>Broadcasts message to all but <code>from_pid</code> on given topic.</p> <p>Raises <a href=\"phoenix.pubsub.broadcasterror\"><code>Phoenix.PubSub.BroadcastError</code></a> if broadcast fails. See <a href=\"phoenix.pubsub#broadcast/3\"><code>Phoenix.PubSub.broadcast/3</code></a> for usage details.</p>    <h3 class=\"detail-header function\" id=\"direct_broadcast/4\">  <span class=\"signature\">direct_broadcast(node_name, server, topic, message)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">direct_broadcast(<a href=\"#t:node_name/0\">node_name</a>, atom, binary, term) ::\n  :ok |\n  {:error, term}</code></pre>    <p>Broadcasts message on given topic, to a single node.</p> <ul> <li>\n<code>server</code> - The Pid or registered server name and optional node to scope the broadcast, for example: <code>MyApp.PubSub</code>, <code>{MyApp.PubSub, :a@node}</code>\n</li> <li>\n<code>topic</code> - The topic to broadcast to, ie: <code>\"users:123\"</code>\n</li> <li>\n<code>message</code> - The payload of the broadcast</li> </ul>    <h3 class=\"detail-header function\" id=\"direct_broadcast!/4\">  <span class=\"signature\">direct_broadcast!(node_name, server, topic, message)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">direct_broadcast!(<a href=\"#t:node_name/0\">node_name</a>, atom, binary, term) ::\n  :ok |\n  no_return</code></pre>    <p>Broadcasts message on given topic, to a single node.</p> <p>Raises <a href=\"phoenix.pubsub.broadcasterror\"><code>Phoenix.PubSub.BroadcastError</code></a> if broadcast fails. See <a href=\"phoenix.pubsub#broadcast/3\"><code>Phoenix.PubSub.broadcast/3</code></a> for usage details.</p>    <h3 class=\"detail-header function\" id=\"direct_broadcast_from/5\">  <span class=\"signature\">direct_broadcast_from(node_name, server, from_pid, topic, message)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">direct_broadcast_from(<a href=\"#t:node_name/0\">node_name</a>, atom, pid, binary, term) ::\n  :ok |\n  {:error, term}</code></pre>    <p>Broadcasts message to all but <code>from_pid</code> on given topic, to a single node. See <a href=\"phoenix.pubsub#broadcast/3\"><code>Phoenix.PubSub.broadcast/3</code></a> for usage details.</p>    <h3 class=\"detail-header function\" id=\"direct_broadcast_from!/5\">  <span class=\"signature\">direct_broadcast_from!(node_name, server, from_pid, topic, message)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">direct_broadcast_from!(<a href=\"#t:node_name/0\">node_name</a>, atom, pid, binary, term) ::\n  :ok |\n  no_return</code></pre>    <p>Broadcasts message to all but <code>from_pid</code> on given topic, to a single node.</p> <p>Raises <a href=\"phoenix.pubsub.broadcasterror\"><code>Phoenix.PubSub.BroadcastError</code></a> if broadcast fails. See <a href=\"phoenix.pubsub#broadcast/3\"><code>Phoenix.PubSub.broadcast/3</code></a> for usage details.</p>    <h3 class=\"detail-header function\" id=\"node_name/1\">  <span class=\"signature\">node_name(server)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">node_name(atom) :: atom :: binary</code></pre>    <p>Returns the node name of the PubSub server.</p>    <h3 class=\"detail-header function\" id=\"subscribe/2\">  <span class=\"signature\">subscribe(server, topic)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">subscribe(atom, binary) :: :ok | {:error, term}</code></pre>       <h3 class=\"detail-header function\" id=\"subscribe/3\">  <span class=\"signature\">subscribe(server, pid, topic)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">subscribe(atom, binary, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  :ok |\n  {:error, term}</code></pre>    <p>Subscribes the caller to the PubSub adapter's topic.</p> <ul> <li>\n<code>server</code> - The Pid registered name of the server</li> <li>\n<code>topic</code> - The topic to subscribe to, ie: <code>\"users:123\"</code>\n</li> <li>\n<code>opts</code> - The optional list of options. See below.</li> </ul> <h4 id=\"duplicate-subscriptions\">Duplicate Subscriptions</h4> <p>Callers should only subscribe to a given topic a single time. Duplicate subscriptions for a Pid/topic pair are allowed and will cause duplicate events to be sent; however, when using <a href=\"phoenix.pubsub#unsubscribe/3\"><code>Phoenix.PubSub.unsubscribe/3</code></a>, all duplicate subscriptions will be dropped.</p> <h4 id=\"options\">Options</h4> <ul> <li>\n<code>:link</code> - links the subscriber to the pubsub adapter</li> <li>\n<p><code>:fastlane</code> - Provides a fastlane path for the broadcasts for <code>%Phoenix.Socket.Broadcast{}</code> events. The fastlane process is notified of a cached message instead of the normal subscriber. Fastlane handlers must implement <code>fastlane/1</code> callbacks which accepts a <code>Phoenix.Socket.Broadcast</code> structs and returns a fastlaned format for the handler. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">PubSub.subscribe(MyApp.PubSub, \"topic1\",\n  fastlane: {fast_pid, Phoenix.Transports.WebSocketSerializer, [\"event1\"]})</code></pre>\n</li> </ul>    <h3 class=\"detail-header function\" id=\"subscribe/4\">  <span class=\"signature\">subscribe(server, pid, topic, opts)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">subscribe(atom, pid, binary, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  :ok |\n  {:error, term}</code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">subscribe(atom, pid, binary, <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0\">Keyword.t</a>) ::\n  :ok |\n  {:error, term}</code></pre>       <h3 class=\"detail-header function\" id=\"unsubscribe/2\">  <span class=\"signature\">unsubscribe(server, topic)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unsubscribe(atom, binary) :: :ok | {:error, term}</code></pre>       <h3 class=\"detail-header function\" id=\"unsubscribe/3\">  <span class=\"signature\">unsubscribe(server, pid, topic)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unsubscribe(atom, pid, binary) ::\n  :ok |\n  {:error, term}</code></pre>    <p>Unsubscribes the caller from the PubSub adapter's topic.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html</a>\n  </p>\n</div>\n","phoenix_pubsub/phoenix.tracker.state":"<h1>  Phoenix.Tracker.State </h1>  <p>Provides an ORSWOT CRDT.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:clock/0\">clock()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:cloud/0\">cloud()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:context/0\">context()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:delta/0\">delta()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:ets_id/0\">ets_id()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:key/0\">key()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:meta/0\">meta()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:name/0\">name()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:pid_lookup/0\">pid_lookup()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:tag/0\">tag()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:topic/0\">topic()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:value/0\">value()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:values/0\">values()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#clocks/1\">clocks(state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the causal context for the set</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compact/1\">compact(state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compacts a sets causal history</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delta_size/1\">delta_size(state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the dize of the delta</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#extract/1\">extract(state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Extracts the set's elements from ets into a mergeable list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_by_pid/2\">get_by_pid(state, pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all elements for the pid</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_by_pid/4\">get_by_pid(state, pid, topic, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the element matching the pid, topic, and key</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_by_topic/2\">get_by_topic(state, topic)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of elements for the topic who belong to an online replica</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#has_delta?/1\">has_delta?(state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if set has a non-empty delta</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#join/5\">join(state, pid, topic, key, meta \\\\ %{})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds a new element to the set</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#leave/2\">leave(state, pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes all elements from the set for the given pid</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#leave/4\">leave(state, pid, topic, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes an element from the set</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#merge/2\">merge(local, remote)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Merges two sets, or a delta into a set</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#merge_deltas/2\">merge_deltas(local, remote)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#new/1\">new(replica)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a new set for the replica</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#online_list/1\">online_list(state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of elements in the set belonging to an online replica</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#remove_down_replicas/2\">remove_down_replicas(state, replica)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes all elements for replicas that are permanently gone</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#replica_down/2\">replica_down(state, replica)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Marks a replica as down in the set and returns left users</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#replica_up/2\">replica_up(state, replica)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Marks a replica as up in the set and returns rejoined users</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reset_delta/1\">reset_delta(state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Resets the set's delta</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:clock/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:clock/0\">clock</a> :: pos_integer</code></pre> </div> <div id=\"t:cloud/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:cloud/0\">cloud</a> :: <a href=\"http://elixir-lang.org/docs/stable/elixir/MapSet.html#t:t/0\">MapSet.t</a></code></pre> </div> <div id=\"t:context/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:context/0\">context</a> :: %{optional(<a href=\"#t:name/0\">name</a>) =&gt; <a href=\"#t:clock/0\">clock</a>}</code></pre> </div> <div id=\"t:delta/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:delta/0\">delta</a> :: %Phoenix.Tracker.State{cloud: term, context: term, delta: term, mode: :delta, pids: term, range: term, replica: term, replicas: term, values: term}</code></pre> </div> <div id=\"t:ets_id/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:ets_id/0\">ets_id</a> :: pos_integer</code></pre> </div> <div id=\"t:key/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:key/0\">key</a> :: term</code></pre> </div> <div id=\"t:meta/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:meta/0\">meta</a> :: <a href=\"http://elixir-lang.org/docs/stable/elixir/Map.html#t:t/0\">Map.t</a></code></pre> </div> <div id=\"t:name/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:name/0\">name</a> :: term</code></pre> </div> <div id=\"t:pid_lookup/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:pid_lookup/0\">pid_lookup</a> :: {pid, <a href=\"#t:topic/0\">topic</a>, <a href=\"#t:key/0\">key</a>}</code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Phoenix.Tracker.State{cloud: <a href=\"#t:cloud/0\">cloud</a>, context: <a href=\"#t:context/0\">context</a>, delta: :unset | <a href=\"#t:delta/0\">delta</a>, mode: :unset | :delta | :normal, pids: <a href=\"#t:ets_id/0\">ets_id</a>, range: {<a href=\"#t:context/0\">context</a>, <a href=\"#t:context/0\">context</a>}, replica: <a href=\"#t:name/0\">name</a>, replicas: %{optional(<a href=\"#t:name/0\">name</a>) =&gt; :up | :down}, values: <a href=\"#t:values/0\">values</a>}</code></pre> </div> <div id=\"t:tag/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:tag/0\">tag</a> :: {<a href=\"#t:name/0\">name</a>, <a href=\"#t:clock/0\">clock</a>}</code></pre> </div> <div id=\"t:topic/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:topic/0\">topic</a> :: <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html#t:t/0\">String.t</a></code></pre> </div> <div id=\"t:value/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:value/0\">value</a> :: {{<a href=\"#t:topic/0\">topic</a>, pid, <a href=\"#t:key/0\">key</a>}, <a href=\"#t:meta/0\">meta</a>, <a href=\"#t:tag/0\">tag</a>}</code></pre> </div> <div id=\"t:values/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:values/0\">values</a> ::\n  <a href=\"#t:ets_id/0\">ets_id</a> |\n  :extracted |\n  %{optional(<a href=\"#t:tag/0\">tag</a>) =&gt; {pid, <a href=\"#t:topic/0\">topic</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:meta/0\">meta</a>}}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"clocks/1\">  <span class=\"signature\">clocks(state)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">clocks(<a href=\"#t:t/0\">t</a>) :: {<a href=\"#t:name/0\">name</a>, <a href=\"#t:context/0\">context</a>}</code></pre>    <p>Returns the causal context for the set.</p>    <h3 class=\"detail-header function\" id=\"compact/1\">  <span class=\"signature\">compact(state)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">compact(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Compacts a sets causal history.</p> <p>Called as needed and after merges.</p>    <h3 class=\"detail-header function\" id=\"delta_size/1\">  <span class=\"signature\">delta_size(state)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delta_size(<a href=\"#t:delta/0\">delta</a>) :: pos_integer</code></pre>    <p>Returns the dize of the delta.</p>    <h3 class=\"detail-header function\" id=\"extract/1\">  <span class=\"signature\">extract(state)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">extract(<a href=\"#t:t/0\">t</a>) :: {<a href=\"#t:t/0\">t</a>, <a href=\"#t:values/0\">values</a>}</code></pre>    <p>Extracts the set's elements from ets into a mergeable list.</p> <p>Used when merging two sets.</p>    <h3 class=\"detail-header function\" id=\"get_by_pid/2\">  <span class=\"signature\">get_by_pid(state, pid)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_by_pid(<a href=\"#t:t/0\">t</a>, pid) :: [<a href=\"#t:value/0\">value</a>]</code></pre>    <p>Returns all elements for the pid.</p>    <h3 class=\"detail-header function\" id=\"get_by_pid/4\">  <span class=\"signature\">get_by_pid(state, pid, topic, key)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_by_pid(<a href=\"#t:t/0\">t</a>, pid, <a href=\"#t:topic/0\">topic</a>, <a href=\"#t:key/0\">key</a>) :: <a href=\"#t:value/0\">value</a> | nil</code></pre>    <p>Returns the element matching the pid, topic, and key.</p>    <h3 class=\"detail-header function\" id=\"get_by_topic/2\">  <span class=\"signature\">get_by_topic(state, topic)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_by_topic(<a href=\"#t:t/0\">t</a>, <a href=\"#t:topic/0\">topic</a>) :: [<a href=\"#t:value/0\">value</a>]</code></pre>    <p>Returns a list of elements for the topic who belong to an online replica.</p>    <h3 class=\"detail-header function\" id=\"has_delta?/1\">  <span class=\"signature\">has_delta?(state)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">has_delta?(<a href=\"#t:t/0\">t</a>) :: boolean</code></pre>    <p>Checks if set has a non-empty delta.</p>    <h3 class=\"detail-header function\" id=\"join/5\">  <span class=\"signature\">join(state, pid, topic, key, meta \\\\ %{})</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">join(<a href=\"#t:t/0\">t</a>, pid, <a href=\"#t:topic/0\">topic</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:meta/0\">meta</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Adds a new element to the set.</p>    <h3 class=\"detail-header function\" id=\"leave/2\">  <span class=\"signature\">leave(state, pid)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">leave(<a href=\"#t:t/0\">t</a>, pid) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Removes all elements from the set for the given pid.</p>    <h3 class=\"detail-header function\" id=\"leave/4\">  <span class=\"signature\">leave(state, pid, topic, key)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">leave(<a href=\"#t:t/0\">t</a>, pid, <a href=\"#t:topic/0\">topic</a>, <a href=\"#t:key/0\">key</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Removes an element from the set.</p>    <h3 class=\"detail-header function\" id=\"merge/2\">  <span class=\"signature\">merge(local, remote)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">merge(local :: <a href=\"#t:t/0\">t</a>, {remote :: <a href=\"#t:t/0\">t</a>, <a href=\"#t:values/0\">values</a>} | <a href=\"#t:delta/0\">delta</a>) :: {new_local :: <a href=\"#t:t/0\">t</a>, joins :: [<a href=\"#t:value/0\">value</a>], leaves :: [<a href=\"#t:value/0\">value</a>]}</code></pre>    <p>Merges two sets, or a delta into a set.</p> <p>Returns a 3-tuple of the updated set, and the joined and left elements.</p> <h4 id=\"examples\">Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; {s1, joined, left} =\n     Phoenix.Tracker.State.merge(s1, Phoenix.Tracker.State.extract(s2))\n\n{%Phoenix.Tracker.State{}, [...], [...]}</code></pre>    <h3 class=\"detail-header function\" id=\"merge_deltas/2\">  <span class=\"signature\">merge_deltas(local, remote)</span> </h3>     <h3 class=\"detail-header function\" id=\"new/1\">  <span class=\"signature\">new(replica)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new(<a href=\"#t:name/0\">name</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Creates a new set for the replica.</p> <h4 id=\"examples\">Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Phoenix.Tracker.State.new(:replica1)\n%Phoenix.Tracker.State{...}</code></pre>    <h3 class=\"detail-header function\" id=\"online_list/1\">  <span class=\"signature\">online_list(state)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">online_list(<a href=\"#t:t/0\">t</a>) :: [<a href=\"#t:value/0\">value</a>]</code></pre>    <p>Returns a list of elements in the set belonging to an online replica.</p>    <h3 class=\"detail-header function\" id=\"remove_down_replicas/2\">  <span class=\"signature\">remove_down_replicas(state, replica)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">remove_down_replicas(<a href=\"#t:t/0\">t</a>, <a href=\"#t:name/0\">name</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Removes all elements for replicas that are permanently gone.</p>    <h3 class=\"detail-header function\" id=\"replica_down/2\">  <span class=\"signature\">replica_down(state, replica)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">replica_down(<a href=\"#t:t/0\">t</a>, <a href=\"#t:name/0\">name</a>) :: {<a href=\"#t:t/0\">t</a>, joins :: [], leaves :: [<a href=\"#t:values/0\">values</a>]}</code></pre>    <p>Marks a replica as down in the set and returns left users.</p>    <h3 class=\"detail-header function\" id=\"replica_up/2\">  <span class=\"signature\">replica_up(state, replica)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">replica_up(<a href=\"#t:t/0\">t</a>, <a href=\"#t:name/0\">name</a>) :: {<a href=\"#t:t/0\">t</a>, joins :: [<a href=\"#t:values/0\">values</a>], leaves :: []}</code></pre>    <p>Marks a replica as up in the set and returns rejoined users.</p>    <h3 class=\"detail-header function\" id=\"reset_delta/1\">  <span class=\"signature\">reset_delta(state)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reset_delta(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Resets the set's delta.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>\n    <a href=\"https://hexdocs.pm/phoenix_pubsub/Phoenix.Tracker.State.html\" class=\"_attribution-link\">https://hexdocs.pm/phoenix_pubsub/Phoenix.Tracker.State.html</a>\n  </p>\n</div>\n"}