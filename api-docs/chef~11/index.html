<h1 id="an-overview-of-chef">An Overview of Chef</h1> <p>Welcome to Chef!</p> <p>Chef is a powerful automation platform that transforms complex infrastructure into code, bringing your servers and services to life. Whether you’re operating in the cloud, on-premises, or a hybrid, Chef automates how applications are configured, deployed, and managed across your network, no matter its size.</p> <p>Chef is built around simple concepts: achieving desired state, centralized modeling of IT infrastructure, and resource primitives that serve as building blocks. These concepts enable you to quickly manage any infrastructure with Chef. These very same concepts allow Chef to handle the most difficult infrastructure challenges on the planet. Anything that can run the chef-client can be managed by Chef.</p>  <h2 id="chef-components">Chef Components</h2> <p>The following diagram shows the relationships between the various elements of Chef, including the nodes, the server, and the workstations. These elements work together to provide the chef-client the information and instruction that it needs so that it can do its job. As you are reviewing the rest of this doc, use the icons in the tables to refer back to this image.</p> <img alt="_images/overview_chef_11-16.png" src="https://docs.chef.io/release/11-18/_images/overview_chef_11-16.png"> <p>Chef comprises three main elements: a server, one (or more) nodes, and at least one workstation.</p> <ul class="simple"> <li>The Chef server acts as a hub that is available to every node in the organization. This ensures that the right cookbooks (and recipes) are available, that the right policies are being applied, that the node object used during the previous chef-client run is available to the current chef-client run, and that all of the nodes that will be maintained by the chef-client are registered and known to the Chef server.</li> <li>The workstation is the location from which cookbooks (and recipes) are authored, cookbooks (and recipes) are tested, policy data (such as roles, environments, and data bags) are defined, data is synchronized with the chef-repo, and data is uploaded to the Chef server.</li> <li>Each node contains a chef-client that performs the various infrastructure automation tasks that are required, including pulling configuration data from the Chef server as it is required during the chef-client run.</li> </ul> <p>The following sections discuss these elements (and their various components) in more detail.</p>   <h2 id="nodes">Nodes</h2> <p>A node is any machine—physical, virtual, cloud, network device, etc.—that is under management by Chef.</p> <p>The types of nodes that can be managed by Chef include, but are not limited to, the following:</p> <table class="docutils"> <colgroup> <col width="19%"> <col width="81%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Node Type</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_node_type_server.svg" width="100px">  </td> <td>A physical node is typically a server or a virtual machine, but it can be any active device attached to a network that is capable of sending, receiving, and forwarding information over a communications channel. In other words, a physical node is any active device attached to a network that can run a chef-client and also allow that chef-client to communicate with a Chef server.</td> </tr> <tr class="row-odd">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_node_type_cloud_public.svg" width="100px">  </td> <td>A cloud-based node is hosted in an external cloud-based service, such as Amazon Web Services (AWS), OpenStack, Rackspace, Google Compute Engine, or Microsoft Azure. Plugins are available for knife that provide support for external cloud-based services. knife can use these plugins to create instances on cloud-based services. Once created, the chef-client can be used to deploy, configure, and maintain those instances.</td> </tr> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_node_virtual_machine.svg" width="100px">  </td> <td>A virtual node is a machine that runs only as a software implementation, but otherwise behaves much like a physical machine.</td> </tr> <tr class="row-odd">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_node_type_network_device.svg" width="100px">  </td> <td>A network node is any networking device—a switch, a router—that is being managed by a chef-client, such as networking devices by Juniper Networks, Arista, Cisco, and F5. Use Chef to automate common network configurations, such physical and logical Ethernet link properties and VLANs, on these devices.</td> </tr> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_node_type_container.svg" width="100px">  </td> <td>Containers are an approach to virtualization that allows a single operating system to host many working configurations, where each working configuration—a container—is assigned a single responsibility that is isolated from all other responsibilities. Containers are popular as a way to manage distributed and scalable applications and services.</td> </tr> </tbody> </table> <p>The key components of nodes that are under management by Chef include:</p> <table class="docutils"> <colgroup> <col width="19%"> <col width="81%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Component</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_chef_client.svg" width="100px">  </td> <td>
<p class="first">A chef-client is an agent that runs locally on every node that is under management by Chef. When a chef-client is run, it will perform all of the steps that are required to bring the node into the expected state, including:</p> <ul class="simple"> <li>Registering and authenticating the node with the Chef server</li> <li>Building the node object</li> <li>Synchronizing cookbooks</li> <li>Compiling the resource collection by loading each of the required cookbooks, including recipes, attributes, and all other dependencies</li> <li>Taking the appropriate and required actions to configure the node</li> <li>Looking for exceptions and notifications, handling each as required</li> </ul> <p class="last">RSA public key-pairs are used to authenticate the chef-client with the Chef server every time a chef-client needs access to data that is stored on the Chef server. This prevents any node from accessing data that it shouldn’t and it ensures that only nodes that are properly registered with the Chef server can be managed.</p> </td> </tr> <tr class="row-odd">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_ohai.svg" width="100px">  </td> <td>
<p class="first">Ohai is a tool that is used to detect attributes on a node, and then provide these attributes to the chef-client at the start of every chef-client run. Ohai is required by the chef-client and must be present on a node. (Ohai is installed on a node as part of the chef-client install process.)</p> <p>The types of attributes Ohai collects include (but are not limited to):</p> <ul class="simple"> <li>Platform details</li> <li>Network usage</li> <li>Memory usage</li> <li>CPU data</li> <li>Kernel data</li> <li>Host names</li> <li>Fully qualified domain names</li> <li>Other configuration details</li> </ul> <p class="last">Attributes that are collected by Ohai are automatic attributes, in that these attributes are used by the chef-client to ensure that these attributes remain unchanged after the chef-client is done configuring the node.</p> </td> </tr> </tbody> </table>   <h2 id="workstations">Workstations</h2> <p>A workstation is a computer that is configured to run various Chef command-line tools that synchronize with a chef-repo, author cookbooks, interact with the Chef server, interact with nodes, or applications like Delivery.</p> <p>The workstation is the location from which most users do most of their work, including:</p> <ul class="simple"> <li>Developing cookbooks and recipes (and authoring them using Ruby syntax and patterns)</li> <li>Keeping the chef-repo synchronized with version source control</li> <li>Using command-line tools</li> <li>Configuring organizational policy, including defining roles and environments and ensuring that critical data is stored in data bags</li> <li>Interacting with nodes, as (or when) required, such as performing a bootstrap operation</li> </ul> <p>Some important components of workstations include:</p> <table class="docutils"> <colgroup> <col width="19%"> <col width="81%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Component</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_ctl_knife.svg" width="100px">  </td> <td>Chef incudes the knife command-line tool to interact with nodes or work with objects on the Chef server</td> </tr> <tr class="row-odd">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_repository.svg" width="100px">  </td> <td>
<p class="first">The chef-repo is the repository structure in which cookbooks are authored, tested, and maintained:</p> <ul class="simple"> <li>Cookbooks contain recipes, attributes, custom resources, libraries, definitions, files, templates, tests, and metadata</li> <li>The chef-repo should be synchronized with a version control system (such as git), and then managed as if it were source code</li> </ul> <p class="last">The directory structure within the chef-repo varies. Some organizations prefer to keep all of their cookbooks in a single chef-repo, while other organizations prefer to use a chef-repo for every cookbook.</p> </td> </tr> </tbody> </table> <p>System administrators and developers know best about how their infrastructure should be put together. Therefore, the chef-client makes as few decisions on its own as possible. When a decision must be made, the chef-client uses a reasonable default setting that can be easily changed by the system administrators and developers, most often by defining attributes in cookbooks that take precedence over the default attributes present on nodes.</p>   <h2 id="the-server">The Server</h2> <p>The Chef server acts as a hub for configuration data. The Chef server stores cookbooks, the policies that are applied to nodes, and metadata that describes each registered node that is being managed by the chef-client. Nodes use the chef-client to ask the Chef server for configuration details, such as recipes, templates, and file distributions. The chef-client then does as much of the configuration work as possible on the nodes themselves (and not on the Chef server). This scalable approach distributes the configuration effort throughout the organization.</p> <p>There are three types of servers:</p> <table class="docutils"> <colgroup> <col width="13%"> <col width="88%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Server</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>Enterprise Chef</td> <td>Enterprise Chef evolved out of a need for customers to have a highly scalable server with the same functionality as hosted Enterprise Chef, but located on-premises and managed from behind the firewall.</td> </tr> <tr class="row-odd">
<td>Hosted Enterprise Chef</td> <td>The hosted Chef server is a version of the Chef server that is hosted by Chef. The hosted Chef server is cloud-based, scalable, and available (24x7/365), with resource-based access control. The hosted Chef server has the same automation capabilities of any Chef server, but without requiring it to be set up and managed from behind the firewall.</td> </tr> <tr class="row-even">
<td>Open Source Chef</td> <td>The Open Source Chef server is a free version of the Chef server. Each instance of the Open Source Chef server must be configured and managed locally, including data migrations, applying updates, and ensuring that the local infrastructure scales appropriately. The Open Source Chef server includes support from the community. Support from Chef is optional.</td> </tr> </tbody> </table> <p>An API client is any machine that has permission to use the Chef server API to communicate with the Chef server. An API client is typically a node (on which the chef-client runs) or a workstation (on which knife runs), but can also be any other machine configured to use the Chef server API.</p> <p>In addition to node objects, policy, and cookbooks, a Chef server includes:</p> <table class="docutils"> <colgroup> <col width="13%"> <col width="88%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Feature</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_search.svg" width="100px">  </td> <td>Search indexes allow queries to be made for any type of data that is indexed by the Chef server, including data bags (and data bag items), environments, nodes, and roles. A defined query syntax is used to support search patterns like exact, wildcard, range, and fuzzy. A search is a full-text query that can be done from several locations, including from within a recipe, by using the <code class="docutils literal">search</code> subcommand in knife, the <code class="docutils literal">search</code> method in the Recipe DSL, the search box in the Chef management console, and by using the <code class="docutils literal">/search</code> or <code class="docutils literal">/search/INDEX</code> endpoints in the Chef server API. The search engine is based on Apache Solr and is run from the Chef server.</td> </tr> <tr class="row-odd">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_manage.svg" width="100px">  </td> <td>
<p class="first">Chef management console is a web-based interface for the Chef server that provides users a way to manage the following objects:</p> <ul class="last simple"> <li>Nodes</li> <li>Cookbooks and recipes</li> <li>Roles</li> <li>Stores of JSON data (data bags), including encrypted data</li> <li>Environments</li> <li>Searching of indexed data</li> <li>User accounts and user data for the individuals who have permission to log on to and access the Chef server</li> </ul> </td> </tr> </tbody> </table>  <h3 id="node-objects">Node Objects</h3> <p>For the chef-client, two important aspects of nodes are groups of attributes and run-lists. An attribute is a specific piece of data about the node, such as a network interface, a file system, the number of clients a service running on a node is capable of accepting, and so on. A run-list is an ordered list of recipes and/or roles that are run in an exact order. The node object consists of the run-list and node attributes, which is a JSON file that is stored on the Chef server. The chef-client gets a copy of the node object from the Chef server during each chef-client run and places an updated copy on the Chef server at the end of each chef-client run.</p> <p>Some important node objects include:</p> <table class="docutils"> <colgroup> <col width="13%"> <col width="88%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Feature</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_node_attribute.svg" width="100px">  </td> <td>
<p class="first">An attribute is a specific detail about a node. Attributes are used by the chef-client to understand:</p> <ul class="simple"> <li>The current state of the node</li> <li>What the state of the node was at the end of the previous chef-client run</li> <li>What the state of the node should be at the end of the current chef-client run</li> </ul> <p>Attributes are defined by:</p> <ul class="simple"> <li>The state of the node itself</li> <li>Cookbooks (in attribute files and/or recipes)</li> <li>Roles</li> <li>Environments</li> </ul> <p>During every chef-client run, the chef-client builds the attribute list using:</p> <ul class="simple"> <li>Data about the node collected by Ohai</li> <li>The node object that was saved to the Chef server at the end of the previous chef-client run</li> <li>The rebuilt node object from the current chef-client run, after it is updated for changes to cookbooks (attribute files and/or recipes), roles, and/or environments, and updated for any changes to the state of the node itself</li> </ul> <p class="last">After the node object is rebuilt, all of attributes are compared, and then the node is updated based on attribute precedence. At the end of every chef-client run, the node object that defines the current state of the node is uploaded to the Chef server so that it can be indexed for search.</p> </td> </tr> <tr class="row-odd">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_run_lists.svg" width="100px">  </td> <td>
<p class="first">A run-list defines all of the information necessary for Chef to configure a node into the desired state. A run-list is:</p> <ul class="last simple"> <li>An ordered list of roles and/or recipes that are run in the exact order defined in the run-list; if a recipe appears more than once in the run-list, the chef-client will not run it twice</li> <li>Always specific to the node on which it runs; nodes may have a run-list that is identical to the run-list used by other nodes</li> <li>Stored as part of the node object on the Chef server</li> <li>Maintained using knife, and then uploaded from the workstation to the Chef server, or is maintained using the Chef management console</li> </ul> </td> </tr> </tbody> </table>   <h3 id="policy">Policy</h3> <p>Policy maps business and operational requirements, process, and workflow to settings and objects stored on the Chef server:</p> <ul class="simple"> <li>Roles define server types, such as “web server” or “database server”</li> <li>Environments define process, such as “dev”, “staging”, or “production”</li> <li>Certain types of data—passwords, user account data, and other sensitive items—can be placed in data bags, which are located in a secure sub-area on the Chef server that can only be accessed by nodes that authenticate to the Chef server with the correct SSL certificates</li> <li>The cookbooks (and cookbook versions) in which organization-specific configuration policies are maintained</li> </ul> <p>Some important aspects of policy include:</p> <table class="docutils"> <colgroup> <col width="13%"> <col width="88%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Feature</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_roles.svg" width="100px">  </td> <td>A role is a way to define certain patterns and processes that exist across nodes in an organization as belonging to a single job function. Each role consists of zero (or more) attributes and a run-list. Each node can have zero (or more) roles assigned to it. When a role is run against a node, the configuration details of that node are compared against the attributes of the role, and then the contents of that role’s run-list are applied to the node’s configuration details. When a chef-client runs, it merges its own attributes and run-lists with those contained within each assigned role.</td> </tr> <tr class="row-odd">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_data_bags.svg" width="100px">  </td> <td>A data bag is a global variable that is stored as JSON data and is accessible from a Chef server. A data bag is indexed for searching and can be loaded by a recipe or accessed during a search.</td> </tr> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_environments.svg" width="100px">  </td> <td>An environment is a way to map an organization’s real-life workflow to what can be configured and managed when using Chef server. Every organization begins with a single environment called the <code class="docutils literal">_default</code> environment, which cannot be modified (or deleted). Additional environments can be created to reflect each organization’s patterns and workflow. For example, creating <code class="docutils literal">production</code>, <code class="docutils literal">staging</code>, <code class="docutils literal">testing</code>, and <code class="docutils literal">development</code> environments. Generally, an environment is also associated with one (or more) cookbook versions.</td> </tr> </tbody> </table>   <h3 id="cookbooks">Cookbooks</h3> <p>A cookbook is the fundamental unit of configuration and policy distribution. A cookbook defines a scenario and contains everything that is required to support that scenario:</p> <ul class="simple"> <li>Recipes that specify the resources to use and the order in which they are to be applied</li> <li>Attribute values</li> <li>File distributions</li> <li>Templates</li> <li>Extensions to Chef, such as libraries, definitions, and custom resources</li> </ul> <p>The chef-client uses Ruby as its reference language for creating cookbooks and defining recipes, with an extended DSL for specific resources. A reasonable set of resources are available to the chef-client, enough to support many of the most common infrastructure automation scenarios; however, this DSL can also be extended when additional resources and capabilities are required.</p> <p>Cookbooks are comprised of the following components:</p> <table class="docutils"> <colgroup> <col width="19%"> <col width="81%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Component</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_cookbook_attributes.svg" width="100px">  </td> <td>An attribute can be defined in a cookbook (or a recipe) and then used to override the default settings on a node. When a cookbook is loaded during a chef-client run, these attributes are compared to the attributes that are already present on the node. Attributes that are defined in attribute files are first loaded according to cookbook order. For each cookbook, attributes in the <code class="docutils literal">default.rb</code> file are loaded first, and then additional attribute files (if present) are loaded in lexical sort order. When the cookbook attributes take precedence over the default attributes, the chef-client will apply those new settings and values during the chef-client run on the node.</td> </tr> <tr class="row-odd">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_cookbook_definitions.svg" width="100px">  </td> <td>
<p class="first">A definition is code that is reused across recipes, similar to a compile-time macro. A definition is created using arbitrary code wrapped around built-in chef-client resources—<strong>file</strong>, <strong>execute</strong>, <strong>template</strong>, and so on—by declaring those resources into the definition as if they were declared in a recipe. A definition is then used in one (or more) recipes as if it were a resource.</p> <p>Though a definition behaves like a resource, some key differences exist. A definition:</p> <ul class="simple"> <li>Is not a resource or a custom resource</li> <li>Is defined from within the <code class="docutils literal">/definitions</code> directory of a cookbook</li> <li>Is loaded before resources during the chef-client run; this ensures the definition is available to all of the resources that may need it</li> <li>May not notify resources in the resource collection because a definition is loaded <strong>before</strong> the resource collection itself is created; however, a resource in a definition <strong>may</strong> notify a resource that exists within the same definition</li> <li>Automatically supports why-run mode, unlike custom resources</li> </ul> <p class="last">Use a defintion when repeating patterns exist across resources and/or when a simple, direct approach is desired. There is no limit to the number of resources that may be included in a definition: use as many built-in chef-client resources as necessary.</p> </td> </tr> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_cookbook_files.svg" width="100px">  </td> <td>Use the <strong>cookbook_file</strong> resource to transfer files from a sub-directory of <code class="docutils literal">COOKBOOK_NAME/files/</code> to a specified path located on a host that is running the chef-client. The file is selected according to file specificity, which allows different source files to be used based on the hostname, host platform (operating system, distro, or as appropriate), or platform version. Files that are located in the <code class="docutils literal">COOKBOOK_NAME/files/default</code> sub-directory may be used on any platform.</td> </tr> <tr class="row-odd">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_cookbook_libraries.svg" width="100px">  </td> <td>A library allows arbitrary Ruby code to be included in a cookbook, either as a way of extending the classes that are built-in to the chef-client—<code class="docutils literal">Chef::Recipe</code>, for example—or for implementing entirely new functionality, similar to a mixin in Ruby. A library file is a Ruby file that is located within a cookbook’s <code class="docutils literal">/libraries</code> directory. Because a library is built using Ruby, anything that can be done with Ruby can be done in a library file.</td> </tr> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_cookbook_metadata.svg" width="100px">  </td> <td>Every cookbook requires a small amount of metadata. A file named metadata.rb is located at the top of every cookbook directory structure. The contents of the metadata.rb file provides hints to the Chef server to help ensure that cookbooks are deployed to each node correctly.</td> </tr> <tr class="row-odd">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_cookbook_recipes.svg" width="100px">  <img src="https://docs.chef.io/release/11-18/_images/icon_recipe_dsl.svg" width="100px">  </td> <td>
<p class="first">A recipe is the most fundamental configuration element within the organization. A recipe:</p> <ul class="simple"> <li>Is authored using Ruby, which is a programming language designed to read and behave in a predictable manner</li> <li>Is mostly a collection of resources, defined using patterns (resource names, attribute-value pairs, and actions); helper code is added around this using Ruby, when needed</li> <li>Must define everything that is required to configure part of a system</li> <li>Must be stored in a cookbook</li> <li>May be included in a recipe</li> <li>May use the results of a search query and read the contents of a data bag (including an encrypted data bag)</li> <li>May have a dependency on one (or more) recipes</li> <li>May tag a node to facilitate the creation of arbitrary groupings</li> <li>Must be added to a run-list before it can be used by the chef-client</li> <li>Is always executed in the same order as listed in a run-list</li> </ul> <p>The chef-client will run a recipe only when asked. When the chef-client runs the same recipe more than once, the results will be the same system state each time. When a recipe is run against a system, but nothing has changed on either the system or in the recipe, the chef-client won’t change anything.</p> <p class="last">The Recipe DSL is a Ruby DSL that is primarily used to declare resources from within a recipe. The Recipe DSL also helps ensure that recipes interact with nodes (and node properties) in the desired manner. Most of the methods in the Recipe DSL are used to find a specific parameter and then tell the chef-client what action(s) to take, based on whether that parameter is present on a node.</p> </td> </tr> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_cookbook_resources.svg" width="100px">  <img src="https://docs.chef.io/release/11-18/_images/icon_cookbook_providers.svg" width="100px">  </td> <td>
<p class="first">A resource is a statement of configuration policy that:</p> <ul class="simple"> <li>Describes the desired state for a configuration item</li> <li>Declares the steps needed to bring that item to the desired state</li> <li>Specifies a resource type—such as <code class="docutils literal">package</code>, <code class="docutils literal">template</code>, or <code class="docutils literal">service</code>
</li> <li>Lists additional details (also known as resource properties), as necessary</li> <li>Are grouped into recipes, which describe working configurations</li> </ul> <p>Where a resource represents a piece of the system (and its desired state), a provider defines the steps that are needed to bring that piece of the system from its current state into the desired state.</p> <p class="last">Chef has <a class="reference external" href="https://docs.chef.io/resources.html">many built-in resources</a> that cover all of the most common actions across all of the most common platforms. You can <a class="reference external" href="https://docs.chef.io/lwrp.html">build your own resources</a> for handle any situation that isn’t covered by a built-in resource.</p> </td> </tr> <tr class="row-odd">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_cookbook_templates.svg" width="100px">  </td> <td>A cookbook template is an Embedded Ruby (ERB) template that is used to dynamically generate static text files. Templates may contain Ruby expressions and statements, and are a great way to manage configuration files. Use the <strong>template</strong> resource to add cookbook templates to recipes; place the corresponding Embedded Ruby (ERB) template file in a cookbook’s <code class="docutils literal">/templates</code> directory.</td> </tr> <tr class="row-even">
<td>
<img src="https://docs.chef.io/release/11-18/_images/icon_cookbook_tests.svg" width="100px">  </td> <td>Testing cookbooks improves the quality of those cookbooks by ensuring they are doing what they are supposed to do and that they are authored in a consistent manner. Unit and integration testing validates the recipes in cookbooks. Syntax testing—often called linting—validates the quality of the code itself. The following tools are popular tools used for testing Chef recipes: Kitchen, ChefSpec, and Foodcritic.</td> </tr> </tbody> </table>    <h2 id="conclusion">Conclusion</h2> <p>Chef is a thin DSL (domain-specific language) built on top of Ruby. This approach allows Chef to provide just enough abstraction to make reasoning about your infrastructure easy. Chef includes a built-in taxonomy of all the basic resources one might configure on a system, plus a defined mechanism to extend that taxonomy using the full power of the Ruby language. Ruby was chosen because it provides the flexibility to use both the simple built-in taxonomy, as well being able to handle any customization path your organization requires.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Chef Software, Inc.<br>Licensed under the Creative Commons Attribution 3.0 Unported License.<br>The Chef&trade; Mark and Chef Logo are either registered trademarks/service marks or trademarks/servicemarks of Chef, in the United States and other countries and are used with Chef Inc's permission.<br>We are not affiliated with, endorsed or sponsored by Chef Inc.<br>
    <a href="https://docs.chef.io/release/11-18/chef_overview.html" class="_attribution-link">https://docs.chef.io/release/11-18/chef_overview.html</a>
  </p>
</div>
