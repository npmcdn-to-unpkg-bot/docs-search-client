{"index":"<h1 itemprop=\"alternativeHeadline\">Backbone.Marionette</h1>  <h2> Table of Contents </h2> <ul class=\"index-nav\"> <li> <a href=\"installation\">Installing Marionette</a> </li> <li> <a href=\"upgrade\">Upgrade Guide</a> </li> <li> <a href=\"marionette.application\">Application</a> </li> <li> <a href=\"marionette.approuter\">AppRouter</a> </li> <li> <a href=\"marionette.object\">Object</a> </li> <li> <a href=\"marionette.view\">View</a> </li> <li> <a href=\"marionette.collectionview\">CollectionView</a> </li> <li> <a href=\"marionette.compositeview\">CompositeView</a> </li> <li> <a href=\"marionette.region\">Regions</a> </li> <li> <a href=\"backbone.radio\">Backbone Radio</a> </li> <li> <a href=\"basics\">Common Concepts</a> </li> <li> <a href=\"events\">Events</a> </li> <li> <a href=\"marionette.behavior\">Behavior</a> </li> <li> <a href=\"marionette.behaviors\">Behaviors</a> </li> <li> <a href=\"marionette.collectionviewadvanced\">Advanced CollectionView Usage</a> </li> <li> <a href=\"marionette.features\">Features</a> </li> <li> <a href=\"marionette.functions\">Functions</a> </li> <li> <a href=\"marionette.renderer\">Renderer</a> </li> <li> <a href=\"marionette.templatecache\">TemplateCache</a> </li> <li> <a href=\"template\">Template Rendering</a> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/index\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/index</a>\n  </p>\n</div>\n","installation":"<h1>\nInstalling Marionette</h1>\n<p>As with all JavaScript libraries, there are a number of ways to get started witha Marionette application. In this section we'll cover the most common ways.</p> <h2 id=\"quick-start-using-npm-and-webpack\">\nQuick start using NPM and Webpack</h2>\n<p><a href=\"https://webpack.github.io/\">Webpack</a> is a build tool that makes it easy to pull your dependenciestogether into a single bundle to be delivered to your browser's <code>&lt;script&gt;</code> tag.It works particularly well with Marionette and jQuery.</p> <p><a href=\"https://github.com/marionettejs/marionette-integrations/tree/master/webpack\">Here</a>we prepared simple marionettejs skeleton with Webpack.</p> <h2 id=\"quick-start-using-npm-and-brunch\">\nQuick start using NPM and Brunch</h2>\n<p><a href=\"http://brunch.io/\">Brunch</a> is fast front-end web app build tool with simple declarative config,seamless incremental compilation for rapid development, an opinionated pipelineand workflow, and core support for source maps.</p> <p><a href=\"https://github.com/marionettejs/marionette-integrations/tree/master/brunch\">Here</a>we prepared simple marionettejs skeleton with Brunch.</p> <h2 id=\"quick-start-using-npm-and-browserify\">\nQuick start using NPM and Browserify</h2>\n<p><a href=\"http://browserify.org/\">Browserify</a> is a build tool that makes it easy to bundle NPMmodules into your application, so you can <code>require</code> them as you would importdependencies in any other language.</p> <p><a href=\"https://github.com/marionettejs/marionette-integrations/tree/master/browserify\">Here</a>we prepared simple marionettejs skeleton with Browserify.</p> <h3 id=\"browserify-and-grunt\">\nBrowserify and Grunt</h3>\n<p><a href=\"http://gruntjs.com/\">Grunt</a> is task runner. <a href=\"https://github.com/marionettejs/marionette-integrations/tree/master/browserify_grunt\">Here</a> is simple Browserify + Grunt skeleton.</p> <h3 id=\"browserify-and-gulp\">\nBrowserify and Gulp</h3>\n<p><a href=\"http://gulpjs.com/\">Gulp</a> is streaming build system. <a href=\"https://github.com/marionettejs/marionette-integrations/tree/master/browserify-gulp\">Here</a> is simple Browserify + Gulp skeleton.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/installation.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/installation.html</a>\n  </p>\n</div>\n","marionette.application":"<h1>\nMarionette.Application</h1>\n<p>The <code>Application</code> is used to model your Marionette application under a singleentry point. The application provides:</p> <ul> <li>An obvious entry point to your app</li> <li>A clear hook for global events e.g. the <code>AppRouter</code>\n</li> <li>An interface to let you inject variables from the wider context into your app</li> </ul> <p>The Application comes with a <code>start</code> method. This can be used to accomplishtasks before the rest of your application begins. Let's take a quick look at anexample:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-comment\">// Create our Application</span>\n<span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-keyword\">new</span> Mn.Application();\n\n<span class=\"hljs-comment\">// Start history when our application is ready</span>\napp.on(<span class=\"hljs-string\">'start'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n  Bb.history.start();\n});\n\n<span class=\"hljs-comment\">// Load some initial data, and then start our application</span>\nloadInitialData().then(app.start);\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/kk266551/\">Live example</a></p> <p>In the simple example above, we could have just as easily started history afterour initial data had loaded. This pattern becomes more useful as the startupphase of your application becomes more complex.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#root-layout\">Root Layout</a></li> <li><a href=\"#initialize\">Initialize</a></li> <li><a href=\"#application-events\">Application Events</a></li> <li><a href=\"#starting-an-application\">Starting An Application</a></li> <li><a href=\"#application-methods\">Application Methods</a></li> </ul> <h2 id=\"root-layout\">\nRoot Layout</h2>\n<p>As the <code>Application</code> is the entry point to your app, it makes sense that it willhold a reference to the root entry of your View tree. Marionette 3 has addedthis with the <code>region</code> attribute and <code>showView</code>. This example demonstrates howwe can use this:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> RootView = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./views/root'</span>);\n\n\n<span class=\"hljs-keyword\">var</span> App = Mn.Application.extend({\n  region: <span class=\"hljs-string\">'#root-element'</span>,\n\n  onStart: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showView(<span class=\"hljs-keyword\">new</span> RootView());\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myApp = <span class=\"hljs-keyword\">new</span> App();\nmyApp.start();\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/uzc8or6u/\">Live example</a></p> <p>This will immediately render <code>RootView</code> and fire the usual triggers such as<code>before:attach</code> and <code>attach</code> in addition to the <code>before:render</code> and <code>render</code>triggers.</p> <h2 id=\"initialize\">\nInitialize</h2>\n<p>Like other objects in Backbone and Marionette, Applications have an <code>initialize</code>method. It is called immediately after the Application has been instantiated,and is invoked with the same arguments that the constructor received.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> App = Mn.Application.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'My value:'</span>, options.model.get(<span class=\"hljs-string\">'key'</span>));\n  }\n});\n\n<span class=\"hljs-comment\">// The application won't attach a model by default - this merely passes it into</span>\n<span class=\"hljs-comment\">// the options object to be, potentially, passed into views.</span>\n<span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-keyword\">new</span> App({model: <span class=\"hljs-keyword\">new</span> Bb.Model({key: <span class=\"hljs-string\">'value'</span>})});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/5qsmsu2x/\">Live example</a></p> <h2 id=\"application-triggers\">\nApplication Triggers</h2>\n<p>The <code>Application</code> object will fire two triggers:</p> <h3 id=\"beforestart\">\n<code>before:start</code>\n</h3>\n<p>Fired just before the application is started. Use this to prepare theapplication with anything it will need to start, for example setting uprouters, models, and collections.</p> <h3 id=\"start\">\n<code>start</code>\n</h3>\n<p>Fired as part of the application startup. This is where you should be showingyour views and starting <code>Backbone.history</code>.</p> <h3 id=\"application-lifecycle\">\nApplication Lifecycle</h3>\n<p>When <code>Application</code> was initialized and <code>start</code> method was calleda set of events will be called in a specific order.</p> <table> <thead> <tr> <th style=\"text-align:center\">Order</th> <th>Event</th> </tr> </thead> <tbody> <tr> <td style=\"text-align:center\">1</td> <td><code>before:start</code></td> </tr> <tr> <td style=\"text-align:center\">2</td> <td><code>start</code></td> </tr> </tbody> </table> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyModel = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./mymodel'</span>);\n<span class=\"hljs-keyword\">var</span> MyView = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./myview'</span>);\n\n<span class=\"hljs-keyword\">var</span> App = Mn.Application.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initialize'</span>);\n  },\n\n  onBeforeStart: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.model = <span class=\"hljs-keyword\">new</span> MyModel(options.data);\n  },\n\n  onStart: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showView(<span class=\"hljs-keyword\">new</span> MyView({model: <span class=\"hljs-keyword\">this</span>.model}));\n    Bb.history.start();\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-keyword\">new</span> App(options);\napp.start();\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/yovad75L/\">Live example</a></p> <p>As we'll see below, the <code>options</code> object is passed into the Application as anargument to <code>start</code>.</p> <h2 id=\"starting-an-application\">\nStarting An Application</h2>\n<p>Once you have your application configured, you can kick everything off bycalling: <code>MyApp.start(options)</code>.</p> <p>This function takes a single optional parameter. This parameter will be passedto each of your initializer functions, as well as the initialize events. Thisallows you to provide extra configuration for various parts of your app throughout theinitialization sequence.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-keyword\">new</span> App();\n\napp.start({\n  data: {\n    id: <span class=\"hljs-number\">1</span>,\n    text: <span class=\"hljs-string\">'value'</span>\n  }\n});\n</pre> <h2 id=\"method-reference\">\nMethod Reference</h2>\n<p>The Marionette Application provides helper methods for managing its attachedregion.</p> <h3 id=\"getregion\">\n<code>getRegion()</code>\n</h3>\n<p>Return the attached <a href=\"marionette.region\">region object</a> for the Application.</p> <h3 id=\"showview-view\">\n<code>showView(View)</code>\n</h3>\n<p>Display <code>View</code> in the region attached to the Application. This runs the sameview lifecycle as <a href=\"'./marionette.view.html'\"><code>View.showChildView</code></a>.</p> <h3 id=\"getview\">\n<code>getView()</code>\n</h3>\n<p>Return the view currently being displayed in the Application's attached<code>region</code>. If the Application is not currently displaying a view, this methodreturns <code>undefined</code>.</p> <h3 id=\"marionetteobject-methods\">\nMarionette.Object Methods</h3>\n<p><code>Marionette.Application</code> extends <code>Marionette.Object</code> and, as such, implementsthe same method interface. See the <a href=\"marionette.object\"><code>Object</code></a>reference for the full list.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.application.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.application.html</a>\n  </p>\n</div>\n","upgrade":"<h1>\nUpgrade Guide</h1>\n<p>Marionette 3 introduces a number of breaking changes. This upgrade guide will gothrough the major changes and describe how to change your application toaccommodate them.</p> <p>An <a href=\"https://github.com/marionettejs/marionette-v3-compat\">upgrade tool</a> is availableand covers the breaking changes in detail.</p> <p>Where possible, we will document how to make the changes in Marionette 2.x sothat your applications can continue to work and to ease the burden of upgradingto Marionette 3.</p> <h2 id=\"views\">\nViews</h2>\n<p>The most noticeable change to Marionette 3 is the consolidation of <code>ItemView</code>and <code>LayoutView</code> into <code>View</code>. In addition, <code>CompositeView</code> has been removed andits functionality merged into <code>CollectionView</code> and <code>View</code>.</p> <h3 id=\"removing-layoutview-and-itemview\">\nRemoving <code>LayoutView</code> and <code>ItemView</code>\n</h3>\n<p>Using separate <code>View</code> <code>LayoutView</code> and <code>ItemView</code> was complicating the API forMarionette needlessly. The new <code>View</code> replaces all of this and sets a clearrecommendation for building layout trees.</p> <h4>\nUpgrading for Marionette 2.x</h4>\n<p>For updating in Marionette 2.x, it is recommended you change all instances of<code>ItemView</code> to <code>LayoutView</code>.</p> <h4>\nUpgrading to Marionette 3</h4>\n<p>Change all instances of <code>LayoutView</code> and <code>ItemView</code> to <code>View</code>. Any views thatpreviously extended <code>View</code> with a custom <code>render</code> should work relativelyunchanged.</p> <h3 id=\"removing-compositeview\">\nRemoving <code>CompositeView</code>\n</h3>\n<p>The <code>CompositeView</code> was deprecated in favor of using <code>View</code> and<code>CollectionView</code>. The <code>CompositeView</code> will be completely removed in Marionette4.</p> <p>See <a href=\"marionette.collectionview#rendering-collectionviews\"><code>CollectionView</code></a>for detail on upgrading to Marionette 3. This technique works in both Marionette2.x and Marionette 3.</p> <h3 id=\"child-event-handlers\">\nChild event handlers</h3>\n<p>The <code>childEvents</code> attribute was renamed to <code>childViewEvents</code>.</p> <p>Child event bubbling above one level is now removed in most instances anddeprecated pending removal everywhere else. This can no longer be relied upon.To pass events further up the chain, you must explicitly using<code>childViewTriggers</code> to convert the event from the child into an event on theparent. These can be chained all the way up to the level you require them to be.</p> <p>Bubbled child events no longer pass the <code>childView</code> implicitly and only pass thearguments passed as part of <code>triggerMethod</code>. This means that the argumentspassed to <code>onEvent</code> and <code>onChildviewEvent</code> are now identical.</p> <p>In Marionette 2, <code>childEvents</code> where bound on every event. In Marionette 3,<code>childViewEvents</code> are bound once and cached. This means that you cannot add newevents after the view has been created.</p> <h3 id=\"view-triggers\">\nView <code>triggers</code>\n</h3>\n<p>The view <code>triggers</code> attribute no longer passes an <code>options</code> attribute to eventhandlers, instead passing the view instance that triggered the event.</p> <h2 id=\"events\">\nEvents</h2>\n<p>A number of lifecycle events were changed or removed from Marionette 3.Information on which ones were removed, changed, or added will be found herewith recommendations on how to update your code.</p> <h3 id=\"show-and-beforeshow\">\n<code>show</code> and <code>before:show</code>\n</h3>\n<p>The <code>show</code> events were removed completely as they were redundant and were beingused incorrectly to show child regions. The <code>show</code> event was fired after theview had been attached, meaning the DOM was being constantly updated, leading todeteriorated performance.</p> <h4>\nUpgrading for Marionette 2.x</h4>\n<p>Replace all instances of <code>onShow</code>, <code>on('show')</code>, <code>onBeforeShow</code> and<code>on('before:show')</code> to use the <code>render</code> and <code>before:render</code> events. This is therecommendation for Marionette 3 and ensures the DOM tree is built in-memorybefore modifying the DOM.</p> <h4>\nUpgrading to Marionette 3</h4>\n<p>Replace all instances of <code>show</code> and <code>before:show</code> with <code>render</code> and<code>before:render</code>. If you want the view to be visible in the DOM, then listen tothe <code>dom:refresh</code> event.</p> <h2 id=\"templates\">\nTemplates</h2>\n<p>The biggest change to templates is renaming <code>templateHelpers</code> to<code>templateContext</code> - the aim is to be more in-line with terminology from otherframeworks.</p> <h3 id=\"upgrading-to-marionette-3\">\nUpgrading to Marionette 3</h3>\n<p>Simply replace all instances of <code>templateHelpers</code> with <code>templateContext</code></p> <h2 id=\"regions\">\nRegions</h2>\n<p>There are a number of changes to how regions behave - the biggest change beingthe removal of the ability to access regions as attributes</p> <h3 id=\"removing-viewregion\">\nRemoving <code>view.region</code>\n</h3>\n<p>The <code>view.&lt;region_name&gt;</code> syntax has been removed in favor of <code>view.getRegion()</code>,<code>view.getChildView()</code> and <code>view.showChildView()</code>.</p> <h4>\nUpgrading for Marionette 2.x</h4>\n<p>Change all references to <code>view.region</code> to <code>view.getRegion('region')</code>. Forexample, in Mn 2.x and below:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> AnotherView = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./anotherview'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.LayoutView.extend({\n  regions: {\n    myregion: <span class=\"hljs-string\">'.regionname'</span>\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.myregion.show(<span class=\"hljs-keyword\">new</span> AnotherView());\n  }\n});\n</pre> <p>This does not work in Mn 3 - instead do:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> AnotherView = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./anotherview'</span>);\n\n<span class=\"hljs-comment\">/* In Mn 2.x we can just use LayoutView */</span>\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  regions: {\n    myregion: <span class=\"hljs-string\">'.regionname'</span>\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'myregion'</span>, <span class=\"hljs-keyword\">new</span> AnotherView());\n  }\n});\n</pre> <p>See the documentation for <a href=\"marionette.view#laying-out-views---regions\">views</a>to learn more about how to manage regions in Marionette 3.</p> <h2 id=\"modules\">\nModules</h2>\n<p>Marionette Modules have been completely removed in favor of using the morestandard JavaScript module loaders e.g.<a href=\"installation#quick-start-using-npm-and-webpack\">Webpack</a> or<a href=\"installation#quick-start-using-npm-and-browserify\">Browserify</a>. See the<a href=\"installation\">installation</a> documentation for a list of potential options.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/upgrade.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/upgrade.html</a>\n  </p>\n</div>\n","marionette.approuter":"<h1>\nMarionette.AppRouter</h1>\n<p>The Marionette <code>AppRouter</code> extends the <a href=\"http://backbonejs.org/#Router\"><code>Backbone.Router</code></a> tomake it easier to construct a large number of routes for your app. This isparticularly useful if you want to build a large single-page app while keepingyour router's core logic readable.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#using-the-approuter\">Using the AppRouter</a></li> <li>\n<a href=\"#configure-routes\">Configure Routes</a><ul> <li><a href=\"#configure-routes-in-constructor\">Configure Routes In Constructor</a></li> <li><a href=\"#add-routes-at-runtime\">Add Routes At Runtime</a></li> </ul> </li> <li>\n<a href=\"#specify-a-controller\">Specify A Controller</a><ul> <li><a href=\"#using-marionette-object\">Using Marionette.Object</a></li> </ul> </li> <li><a href=\"#multiple-routers\">Multiple Routers</a></li> <li><a href=\"#backbone-history\">Backbone History</a></li> <li><a href=\"#handling-route-changes\">Handling Route Changes</a></li> </ul> <h2 id=\"using-the-approuter\">\nUsing the AppRouter</h2>\n<p>The Marionette AppRouter is typically used to set up your app when the userloads a specific endpoint directly. Typically, in a single-page app, users willexpect to be able to easily navigate back to a section of the application bybookmarking a URL and loading it directly. Let's look at a concrete example:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> EmailController = {\n  showEmail: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(email)</span> </span>{\n    <span class=\"hljs-comment\">// Look up the email and display it in our main layout</span>\n  }\n};\n\n<span class=\"hljs-keyword\">var</span> EmailRouter = Mn.AppRouter.extend({\n  controller: EmailController,\n\n  appRoutes: {\n    <span class=\"hljs-string\">'emails/:email'</span>: <span class=\"hljs-string\">'showEmail'</span>\n  }\n});\n</pre> <p>Assuming our application is served from the root, whenever the user accesses<code>http://ourapplication.com/#emails/email-subject-line-123</code>, the method<code>showEmail</code> will be called with <code>email-subject-line-123</code> as its argument. Thiswill be covered in more detail below.</p> <h2 id=\"configure-routes\">\nConfigure Routes</h2>\n<p>The AppRouter uses the <code>appRoutes</code> option to define how we respond to routesbeing accessed. To define routes, set the route as your key and the method tocall as a string referencing a method on your controller. For more informationon route definitions, see the [Backbone documentation][#backbone-routes].</p> <p>The major difference between <code>appRoutes</code> and <code>routes</code> is that we providecallbacks on a controller instead of directly on the router itself. This allowsyou to define a simpler router and keep your controller logic closer to themodules it interacts directly with:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> EmailController = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./emails/controller/email'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyRouter = Mn.AppRouter.extend({\n  controller: EmailController,\n\n  <span class=\"hljs-comment\">// \"someMethod\" must exist at controller.someMethod</span>\n  appRoutes: {\n    <span class=\"hljs-string\">'email'</span>: <span class=\"hljs-string\">'listEmails'</span>,\n    <span class=\"hljs-string\">'email/:email'</span>: <span class=\"hljs-string\">'showEmail'</span>\n  }\n});\n</pre> <p>As the <code>AppRouter</code> extends <code>Backbone.Router</code>, you can also define a <code>routes</code>attribute whose callbacks must be present on the <code>AppRouter</code>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyRouter = Mn.AppRouter.extend({\n  routes: {\n    <span class=\"hljs-string\">'email/:email'</span>: <span class=\"hljs-string\">'showEmail'</span>\n  },\n\n  showEmail: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(email)</span> </span>{\n    <span class=\"hljs-comment\">// show the email</span>\n  }\n})\n</pre> <p>See the <a href=\"http://backbonejs.org/#Router-routes\">Backbone documentation</a> for more information aboutdefining <code>routes</code>.</p> <h3 id=\"configure-routes-in-constructor\">\nConfigure Routes In Constructor</h3>\n<p>If you want more control when managing your routes, you can define your routes<a href=\"basics#binding-attributes-on-instantiation\">on router instantiation</a>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> EmailController = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./emails/controllers/email'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyRouter = <span class=\"hljs-keyword\">new</span> Mn.AppRouter({\n  controller: EmailController,\n  appRoutes: {\n    <span class=\"hljs-string\">'email/'</span>: <span class=\"hljs-string\">'listEmails'</span>,\n    <span class=\"hljs-string\">'email/:email'</span>: <span class=\"hljs-string\">'showEmail'</span>\n  }\n});\n</pre> <h3 id=\"add-routes-at-runtime\">\nAdd Routes At Runtime</h3>\n<p>In addition to setting the <code>appRoutes</code> for an AppRouter, you can add app routesat runtime, to an instance of a router. This is done with the <code>appRoute()</code>method call. It works the same as the built-in <code>router.route()</code> call fromBackbone's Router, but has all the same semantics and behavior of the<code>appRoutes</code> configuration.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyRouter = Mn.AppRouter.extend({});\n\n<span class=\"hljs-keyword\">var</span> router = <span class=\"hljs-keyword\">new</span> MyRouter();\nrouter.appRoute(<span class=\"hljs-string\">\"/foo\"</span>, <span class=\"hljs-string\">\"fooThat\"</span>);\n</pre> <p>Also you can specify a controller with the multiple routes at runtime with the<code>processAppRoutes</code> method. This will preserve the existing controller as well:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyRouter = Mn.AppRouter.extend({});\n\n<span class=\"hljs-keyword\">var</span> router = <span class=\"hljs-keyword\">new</span> MyRouter();\nrouter.processAppRoutes(myController, {\n  <span class=\"hljs-string\">\"foo\"</span>: <span class=\"hljs-string\">\"doFoo\"</span>,\n  <span class=\"hljs-string\">\"bar/:id\"</span>: <span class=\"hljs-string\">\"doBar\"</span>\n});\n</pre> <h2 id=\"specify-a-controller\">\nSpecify A Controller</h2>\n<p>App routers can only use one <code>controller</code> object. You can either specify thisdirectly in the router definition:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> someController = {\n  someMethod: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{ <span class=\"hljs-comment\">/*...*/</span> }\n};\n\nMn.AppRouter.extend({\n  controller: someController\n});\n</pre> <p>The object that is used as the <code>controller</code> has no requirements, other than itwill contain the methods that you specified in the <code>appRoutes</code>.</p> <h3 id=\"using-marionetteobject\">\nUsing Marionette.Object</h3>\n<p>A controller can also be an instance of<a href=\"marionette.object\"><code>Marionette.Object</code></a> - this is useful for cases whereyou want to access the helper tools of the Object API and pass throughinformation on instantiation.</p> <h2 id=\"multiple-routers\">\nMultiple Routers</h2>\n<p>Marionette allows you to run multiple AppRouters in a single application. It'srecommended that you break your routing into multiple sections, each with itsown router and/or controller setting up the views for their own components. Thiswill make it much easier to find and manage your route-handling logic as yourapplication grows in complexity.</p> <h2 id=\"backbone-history\">\nBackbone History</h2>\n<p>The <a href=\"http://backbonejs.org/#History\">Backbone History API</a> monitors the browser's location barand triggers route changes on your app routers. It also provides a set ofmethods to change the contents of the location bar manually when you want toexpose functionality to your user via a URL:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> EmailView = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./email/views/email'</span>);\n\n<span class=\"hljs-keyword\">var</span> EmailList = Mn.View.extend({\n  regions: {\n    layout: <span class=\"hljs-string\">'.layout-hook'</span>\n  },\n\n  showEmail: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(model)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'layout'</span>, <span class=\"hljs-keyword\">new</span> EmailView({model: model}));\n    Bb.history.navigate(<span class=\"hljs-string\">'email/'</span> + model.id);\n  }\n});\n</pre> <p>As stated in the Backbone documentation, <code>navigate</code> takes an <code>options</code> argumentthat lets you <code>trigger</code> on route change. We recommend against using this as ittends to cause side-effects like making it hard to ensure the route is onlynavigated to once, or unintentionally firing different route changes.</p> <h2 id=\"handling-route-changes\">\nHandling Route Changes</h2>\n<p>When the user navigates to a new route in your application that matches a routein your <code>AppRouter</code>, the <code>route</code> event will be fired. Listening to this will letyou perform extra custom behavior:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> Controller = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./email/controller'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyRouter = Mn.AppRouter.extend({\n  controller: Controller,\n\n  appRoutes: {\n    <span class=\"hljs-string\">'emails/:email'</span>: <span class=\"hljs-string\">'showEmail'</span>\n  },\n\n  onRoute: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name, path, args)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'User navigated to '</span> + path);\n  }\n});\n</pre> <p>This event handler takes three arguments:</p> <ol> <li>\n<code>name</code> - Name of the route</li> <li>\n<code>path</code> - Path that triggered this event</li> <li>\n<code>args</code> - Arguments passed into the route</li> </ol><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.approuter.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.approuter.html</a>\n  </p>\n</div>\n","marionette.object":"<h1>\nMarionette.Object</h1>\n<p>A base class which other classes can extend from.Object incorporates many backbone conventions and utilitieslike <code>initialize</code> and <code>Backbone.Events</code>.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#initialize\">initialize</a></li> <li><a href=\"#events\">events</a></li> <li><a href=\"#destroying-a-object\">Destroying An Object</a></li> <li><a href=\"#mergeoptions\">mergeOptions</a></li> <li><a href=\"#getoption\">getOption</a></li> <li><a href=\"#bindentityevents\">bindEntityEvents</a></li> <li><a href=\"#basic-use\">Basic Use</a></li> </ul> <h2 id=\"initialize\">\nInitialize</h2>\n<p>Initialize is called immediately after the Object has been instantiated,and is invoked with the same arguments that the constructor received.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> Friend = Mn.Object.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n    <span class=\"hljs-built_in\">console</span>.log(options.name);\n  }\n});\n\n<span class=\"hljs-keyword\">new</span> Friend({name: <span class=\"hljs-string\">'John'</span>});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/1ytrwyog/\">Live example</a></p> <h2 id=\"events\">\nEvents</h2>\n<p><code>Marionette.Object</code> extends <code>Backbone.Events</code> and includes <code>triggerMethod</code>.This makes it easy for Objects to emit events that other objects can listen forwith <code>on</code> or <code>listenTo</code>.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> Friend = Mn.Object.extend({\n  graduate: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.triggerMethod(<span class=\"hljs-string\">'announce'</span>, <span class=\"hljs-string\">'I graduated!!!'</span>);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> john = <span class=\"hljs-keyword\">new</span> Friend({name: <span class=\"hljs-string\">'John'</span>});\n\njohn.on(<span class=\"hljs-string\">'announce'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(message)</span> </span>{\n  <span class=\"hljs-built_in\">console</span>.log(message); <span class=\"hljs-comment\">// I graduated!!!</span>\n})\n\njohn.graduate();\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/cd0dodwr/\">Live example</a></p> <h2 id=\"radio-events\">\nRadio Events</h2>\n<p><code>Marionette.Object</code> integrates with <code>Backbone.Radio</code> to provide powerful messaging capabilities.Objects can respond to both of Radio's message types: <code>Events</code> and <code>Requests</code>.If radio either <code>Events</code> or <code>Requests</code> wanted to be used then <code>channelName</code> property is required to be set.</p> <pre data-language=\"javascript\">channelName: <span class=\"hljs-string\">'myChannel'</span>,\nradioEvents: {\n  <span class=\"hljs-string\">'some:event'</span>: <span class=\"hljs-string\">'eventHandler'</span>\n},\n\nradioRequests: {\n  <span class=\"hljs-string\">'some:request'</span>: <span class=\"hljs-string\">'requestHandler'</span>\n},\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/3seo87o1/\">Live example</a></p> <p>means that the object will listen for the <code>doFoo</code> request on the <code>app</code> channel, and run the 'executeFoo' method. When using Radio Requests with Objects, the same rules and restrictions that normal Radio use implies also apply here: a single handler can be associated with a request, either through manual use of the reply functions, or through the Object API.</p> <h2 id=\"mergeoptions\">\nmergeOptions</h2>\n<p>Merge keys from the <code>options</code> object directly onto the instance. This is the preferred way to access optionspassed into the Object.</p> <p>More information at <a href=\"marionette.functions#marionettemergeoptions\">mergeOptions</a></p> <h2 id=\"getoption\">\ngetOption</h2>\n<p>Retrieve an object's attribute either directly from the object, or from the object's this.options, with this.options taking precedence.</p> <p>More information <a href=\"marionette.functions#marionettegetoption\">getOption</a>.</p> <h2 id=\"bindentityevents\">\nbindEntityEvents</h2>\n<p>Helps bind a backbone \"entity\" to methods on a target object. More information <a href=\"marionette.functions#marionettebindentityevents\">bindEntityEvents</a>.</p> <h2 id=\"destroying-a-object\">\nDestroying A Object</h2>\n<p>Objects have a <code>destroy</code> method that unbind the events that are directly attached to theinstance.</p> <p>Invoking the <code>destroy</code> method will trigger a \"before:destroy\" event and corresponding<code>onBeforeDestroy</code> method call. These calls will be passed any arguments <code>destroy</code>was invoked with. Invoking <code>destroy</code> will return the object, this can be useful for chaining.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-comment\">// define a object with an onDestroy method</span>\n<span class=\"hljs-keyword\">var</span> MyObject = Mn.Object.extend({\n\n  onBeforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(arg1, arg2)</span></span>{\n    <span class=\"hljs-comment\">// put custom code here, to destroy this object</span>\n  }\n\n});\n\n<span class=\"hljs-comment\">// create a new object instance</span>\n<span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> MyObject();\n\n<span class=\"hljs-comment\">// add some event handlers</span>\nobj.on(<span class=\"hljs-string\">\"before:destroy\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(arg1, arg2)</span></span>{ ... });\nobj.listenTo(something, <span class=\"hljs-string\">\"bar\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{...});\n\n<span class=\"hljs-comment\">// destroy the object: unbind all of the</span>\n<span class=\"hljs-comment\">// event handlers, trigger the \"destroy\" event and</span>\n<span class=\"hljs-comment\">// call the onDestroy method</span>\nobj.destroy(arg1, arg2);\n</pre> <h2 id=\"basic-use\">\nBasic Use</h2>\n<p>Selections is a simple Object that manages a selection of things.Because Selections extends from Object, it gets <code>initialize</code> and <code>Events</code>for free.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> Selections = Mn.Object.extend({\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n    <span class=\"hljs-keyword\">this</span>.selections = {};\n  },\n\n  select: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(key, item)</span></span>{\n    <span class=\"hljs-keyword\">this</span>.triggerMethod(<span class=\"hljs-string\">\"select\"</span>, key, item);\n    <span class=\"hljs-keyword\">this</span>.selections[key] = item;\n  },\n\n  deselect: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(key, item)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.triggerMethod(<span class=\"hljs-string\">\"deselect\"</span>, key, item);\n    <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>.selections[key];\n  }\n\n});\n\n<span class=\"hljs-keyword\">var</span> selections = <span class=\"hljs-keyword\">new</span> Selections({\n  filters: Filters\n});\n\n<span class=\"hljs-comment\">// use the built in EventBinder</span>\nselections.listenTo(selections, <span class=\"hljs-string\">\"select\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(key, item)</span></span>{\n  <span class=\"hljs-built_in\">console</span>.log(item);\n});\n\nselections.select(<span class=\"hljs-string\">'toy'</span>, Truck);\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.object.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.object.html</a>\n  </p>\n</div>\n","marionette.compositeview":"<h1>\nMarionette.CompositeView</h1>\n<p><strong><em>DEPRECATED: <code>CompositeView</code> is deprecated. See<br><a href=\"marionette.collectionview#rendering-collectionviews\">CollectionView</a><br>to see how to build equivalent views in Marionette 3</em></strong></p> <p>A <code>CompositeView</code> extends from <code>CollectionView</code> to be used as acomposite view for scenarios where it should represent both abranch and leaf in a tree structure, or for scenarios where acollection needs to be rendered within a wrapper template. By default the<code>CompositeView</code> will maintain a sorted collection's orderin the DOM. This behavior can be disabled by specifying <code>{sort: false}</code> on initialize.</p> <p>Please see<a href=\"marionette.collectionview\">the Marionette.CollectionView documentation</a>for more information on available features and functionality.</p> <h2 id=\"example-usage-tree-view\">\nExample Usage: Tree View</h2>\n<p>For example, if you're rendering a tree-view control, you maywant to render a collection view with a model and template sothat it will show a parent child with children in the tree.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> CompositeView = Marionette.CompositeView.extend({\n  template: <span class=\"hljs-string\">\"#leaf-branch-template\"</span>\n});\n\n<span class=\"hljs-keyword\">new</span> CompositeView({\n  model: someModel,\n  collection: someCollection\n});\n</pre> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#composite-model-template\">Composite Model <code>template</code></a></li> <li><a href=\"#compositeviews-childview\">CompositeView's <code>childView</code></a></li> <li><a href=\"#compositeviews-childviewcontainer\">CompositeView's <code>childViewContainer</code></a></li> <li><a href=\"#compositeviews-attachhtml\">CompositeView's <code>attachHtml</code></a></li> <li><a href=\"#compositeviews-renderchildren\">CompositeView's <code>renderChildren</code></a></li> <li><a href=\"#recursive-by-default\">Recursive By Default</a></li> <li><a href=\"#model-and-collection-rendering\">Model And Collection Rendering</a></li> <li><a href=\"#events-and-callbacks\">Events And Callbacks</a></li> <li><a href=\"#organizing-ui-elements\">Organizing UI elements</a></li> <li><a href=\"#modelevents-and-collectionevents\">modelEvents and collectionEvents</a></li> </ul> <h2 id=\"composite-model-template\">\nComposite Model <code>template</code>\n</h2>\n<p>When a <code>CompositeView</code> is rendered, the <code>model</code> will be renderedwith the <code>template</code> that the view is configured with. You canoverride the template by passing it in as a constructor option:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">new</span> MyComp({\n  template: <span class=\"hljs-string\">\"#some-template\"</span>\n});\n</pre> <p>The <code>collection</code> option is not passed to the template context bydefault. If your <code>template</code> needs access to the collection, you'llneed to pass it via <code>templateContext</code>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">new</span> MyComp({\n  template: <span class=\"hljs-string\">\"#some-template\"</span>,\n  templateContext: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> { items: <span class=\"hljs-keyword\">this</span>.collection.toJSON() };\n  }\n})\n</pre> <h2 id=\"compositeviews-childview\">\nCompositeView's <code>childView</code>\n</h2>\n<p>Each childView will be rendered using the <code>childView</code>'s template. The <code>CompositeView</code>'stemplate is rendered and the childView's templates are added to this.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> ChildView = Marionette.View.extend({});\n\n<span class=\"hljs-keyword\">var</span> CompView = Marionette.CompositeView.extend({\n  childView: ChildView\n});\n</pre> <p>You can also define <code>childView</code> as a function, which allows you to choose the view classto be rendered at runtime.</p> <p>For more information see the <a href=\"marionette.collectionview#collectionviews-childview\">CollectionView's documentation</a>.</p> <h2 id=\"compositeviews-childviewcontainer\">\nCompositeView's <code>childViewContainer</code>\n</h2>\n<p>By default the composite view uses the same <code>attachHtml</code> method that thecollection view provides. This means the view will call jQuery's <code>.append</code>to move the HTML contents from the child view instance in to the collectionview's <code>el</code>.</p> <p>This is typically not very useful as a composite view will usually rendera container DOM element in which the child views should be placed.</p> <p>For example, if you are building a table view, and want to append eachchild from the collection in to the <code>&lt;tbody&gt;</code> of the table, you mightdo this with a template:</p> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"row-template\"</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"text/html\"</span>&gt;</span><span class=\"javascript\">\n  &lt;td&gt;<span class=\"xml\"><span class=\"vbscript\">&lt;%= someData %&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">td</span>&gt;</span><span class=\"vbscript\">&lt;%= moreData %&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">td</span>&gt;</span><span class=\"vbscript\">&lt;%= stuff %&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"table-template\"</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"text/html\"</span>&gt;</span><span class=\"javascript\">\n  &lt;table&gt;\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">thead</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tr</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">th</span>&gt;</span>Some Column<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">th</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">th</span>&gt;</span>Another Column<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">th</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">th</span>&gt;</span>Still More<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">th</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tr</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">thead</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- want to insert collection children, here --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tbody</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tbody</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tfoot</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tr</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">td</span> <span class=\"hljs-attribute\">colspan</span>=<span class=\"hljs-value\">\"3\"</span>&gt;</span>some footer information<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tr</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tfoot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">table</span>&gt;</span>\n</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</pre> <p>To get your childView instances to render within the <code>&lt;tbody&gt;</code> of thistable structure, specify an <code>childViewContainer</code> in your composite view,like this:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> RowView = Marionette.View.extend({\n  tagName: <span class=\"hljs-string\">\"tr\"</span>,\n  template: <span class=\"hljs-string\">\"#row-template\"</span>\n});\n\n<span class=\"hljs-keyword\">var</span> TableView = Marionette.CompositeView.extend({\n  childView: RowView,\n\n  <span class=\"hljs-comment\">// specify a jQuery selector to put the `childView` instances into</span>\n  childViewContainer: <span class=\"hljs-string\">\"tbody\"</span>,\n\n  template: <span class=\"hljs-string\">\"#table-template\"</span>\n});\n</pre> <p>This will put all of the <code>childView</code> instances into the <code>&lt;tbody&gt;</code> tag ofthe composite view's rendered template, correctly producing the tablestructure.</p> <p>Alternatively, you can specify a function as the <code>childViewContainer</code>. Thisfunction needs to return a jQuery selector string, or a jQuery selectorobject.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> TableView = Marionette.CompositeView.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  childViewContainer: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"#my-tbody\"</span>\n  }\n});\n</pre> <p>Using a function allows for logic to be used for the selector. However,only one value can be returned. Upon returning the first value, it willbe cached and that value will be used for the remainder of that viewinstance' lifecycle.</p> <p>Alternatively, the <code>childViewContainer</code> can be supplied in the constructorfunction options:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> myComp = <span class=\"hljs-keyword\">new</span> Marionette.CompositeView({\n  <span class=\"hljs-comment\">// ...,</span>\n\n  childViewContainer: <span class=\"hljs-string\">\"#my-tbody\"</span>\n});\n</pre> <h2 id=\"compositeviews-attachhtml\">\nCompositeView's <code>attachHtml</code>\n</h2>\n<p>Sometimes the <code>childViewContainer</code> configuration is insufficient forspecifying where the <code>childView</code> instance should be placed. If this is thecase, you can override the <code>attachHtml</code> method with your own implementation.</p> <p>For more information on this method, see the <a href=\"marionette.collectionview#collectionviews-attachhtml\">CollectionView's documentation</a>.</p> <h2 id=\"compositeviews-childview-container-selection\">\nCompositeView's <code>childView</code> container selection</h2>\n<p>The <code>getChildViewContainer</code> method is passed a second <code>childView</code> parameter which, when overridden, allows for a finer tuned container selection by being able to access the <code>childView</code> which is about to be appended to the <code>containerView</code> returned by <code>getChildViewContainer</code>.</p> <h2 id=\"compositeviews-renderchildren\">\nCompositeView's <code>renderChildren</code>\n</h2>\n<p>The <code>renderChildren</code> method re-renders the views within the <code>childViewContainer</code> for the collection without re-rendering the surrouding template.</p> <h2 id=\"recursive-by-default\">\nRecursive By Default</h2>\n<p>The default rendering mode for a <code>CompositeView</code> assumes ahierarchical, recursive structure. If you configure a compositeview without specifying an <code>childView</code>, you'll get the samecomposite view class rendered for each child in the collection.</p> <h2 id=\"model-and-collection-rendering\">\nModel And Collection Rendering</h2>\n<p>The model and collection for the composite view will re-renderthemselves under the following conditions:</p> <ul> <li>When the collection's \"reset\" event is fired, it will only re-render the collection within the composite, and not the wrapper template</li> <li>When the collection has a model added to it (the \"add\" event is fired), it will render that one child into the list</li> <li>When the collection has a model removed (the \"remove\" event is fired), it will remove that one child from the rendered list</li> </ul> <p>As with item view instances, the composite view instance is passed as thethird argument to the <code>Renderer</code> object's <code>render</code> method, which isuseful in custom <code>Renderer</code> implementations.</p> <h2 id=\"events-and-callbacks\">\nEvents And Callbacks</h2>\n<p>During the course of rendering a composite, several events willbe triggered. These events are triggered with the <a href=\"marionette.functions#marionettetriggermethod\">Marionette.triggerMethod</a>function, which calls a corresponding \"on{EventName}\" method on the view.</p> <ul> <li>\"before:render:children\" / <code>onBeforeRenderChildren</code> - before the collection of models is rendered</li> <li>\"render:children\" / <code>onRenderChildren</code> - after the collection of models has been rendered</li> <li>\"before:render\" / <code>onBeforeRender</code> - before anything has been rendered</li> <li>\"render\" / <code>onRender</code> - after everything has been rendered</li> </ul> <p>Additionally, after the composite view has been rendered, an<code>onRender</code> method will be called. You can implement this inyour view to provide custom code for dealing with the view's<code>el</code> after it has been rendered:</p> <pre data-language=\"javascript\">Marionette.CompositeView.extend({\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// do stuff here</span>\n  }\n});\n</pre> <h2 id=\"organizing-ui-elements\">\nOrganizing UI elements</h2>\n<p>Similar to View, you can organize the UI elements inside theCompositeView by specifying them in the <code>UI</code> hash. It should benoted that the elements that can be accessed via this hash arethe elements that are directly rendered by the composite viewtemplate, not those belonging to the collection.</p> <p>The UI elements will be accessible as soon as the composite viewtemplate is rendered (and before the collection is rendered),which means you can even access them in the <code>onBeforeRender</code> method.</p> <h2 id=\"modelevents-and-collectionevents\">\nmodelEvents and collectionEvents</h2>\n<p>CompositeViews can bind directly to model events and collection eventsin a declarative manner:</p> <pre data-language=\"javascript\">Marionette.CompositeView.extend({\n  modelEvents: {\n    <span class=\"hljs-string\">\"change\"</span>: <span class=\"hljs-string\">\"modelChanged\"</span>\n  },\n\n  collectionEvents: {\n    <span class=\"hljs-string\">\"add\"</span>: <span class=\"hljs-string\">\"modelAdded\"</span>\n  }\n});\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.compositeview.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.compositeview.html</a>\n  </p>\n</div>\n","basics":"<h1>\nCommon Marionette Concepts</h1>\n<p>This document covers the basic usage patterns and concepts across Marionette.This includes things like calling conventions, setting attributes, common optionpatterns etc.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li>\n<a href=\"#class-based-inheritance\">Class-based Inheritance</a><ul> <li><a href=\"#value-attributes\">Value Attributes</a></li> <li><a href=\"#functions-returning-values\">Functions Returning Values</a></li> <li><a href=\"#binding-attributes-on-instantiation\">Binding Attributes on Instantiation</a></li> </ul> </li> <li>\n<a href=\"#setting-options\">Setting Options</a><ul> <li><a href=\"#the-getoption-method\">The <code>getOption</code> Method</a></li> <li><a href=\"#the-mergeoptions-method\">The <code>mergeOptions</code> Method</a></li> </ul> </li> </ul> <h2 id=\"class-based-inheritance\">\nClass-based Inheritance</h2>\n<p>Backbone and Marionette utilize the <code>_.extend</code> function to simulate class-basedinheritance. All built-in classes, such as <code>Marionette.View</code>,<code>Marionette.Object</code> and everything that extend these provide an <code>extend</code> methodfor just this purpose.</p> <p>In the below example, we create a new pseudo-class called <code>MyView</code>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({});\n</pre> <p>You can now create instances of <code>MyView</code> with JavaScript's <code>new</code> keyword:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> MyView();\n</pre> <h3 id=\"value-attributes\">\nValue Attributes</h3>\n<p>When we extend classes, we can provide class attributes with specific values bydefining them in the object we pass as the <code>extend</code> parameter:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  className: <span class=\"hljs-string\">'bg-success'</span>,\n\n  template: <span class=\"hljs-string\">'#template-identifier'</span>,\n\n  regions: {\n    myRegion: <span class=\"hljs-string\">'.my-region'</span>\n  },\n\n  modelEvents: {\n    change: <span class=\"hljs-string\">'removeBackground'</span>\n  },\n\n  removeBackground: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.$el.removeClass(<span class=\"hljs-string\">'bg-success'</span>);\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/k93pejyb/\">Live example</a></p> <p>When we instantiate <code>MyView</code>, each instance will be given a <code>.bg-success</code> classwith a <code>myRegion</code> region created on the <code>.my-region</code> element.</p> <h3 id=\"functions-returning-values\">\nFunctions Returning Values</h3>\n<p>In almost every instance where we can set a value, we can also assign a functionto figure out the value at runtime. In this case, Marionette will run thefunction on instantiation and use the returned value:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  className: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.model.successful() ? <span class=\"hljs-string\">'bg-success'</span> : <span class=\"hljs-string\">'bg-error'</span>;\n  },\n\n  template: <span class=\"hljs-string\">'#template-identifier'</span>,\n\n  regions: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> {\n      myRegion: <span class=\"hljs-string\">'.my-region'</span>\n    };\n  },\n\n  modelEvents: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">var</span> wasSuccessful = <span class=\"hljs-keyword\">this</span>.model.successful();\n    <span class=\"hljs-keyword\">return</span> {\n      change: wasSuccessful ? <span class=\"hljs-string\">'removeBackground'</span> : <span class=\"hljs-string\">'alert'</span>\n    };\n  },\n\n  removeBackground: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.$el.removeClass(<span class=\"hljs-string\">'bg-success'</span>);\n  },\n\n  alert: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'model changed'</span>);\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/nn1754fc/\">Live example</a></p> <p>As we can see, almost all of the attributes here can be worked out dynamically.In most cases, Marionette will call the function once at instantiation, or firstrender, and preserve the value throughout the lifetime of the View. There aresome exceptions to this rule - these will be referred to with their respectivedocumentation.</p> <h3 id=\"function-context\">\nFunction Context</h3>\n<p>When using functions to set attributes, Marionette will assign the instance ofyour new class as <code>this</code>. You can use this feature to ensure you're able toaccess your object in cases where <code>this</code> isn't what you might expect it to be.For example, the value or result of<a href=\"template#template-context\"><code>templateContext</code></a> is<a href=\"template#binding-of-this\">bound to its data object</a> so using afunction is the only way to access the view's context directly.</p> <h3 id=\"binding-attributes-on-instantiation\">\nBinding Attributes on Instantiation</h3>\n<p>In Marionette, most attributes can be bound on class instantiation in additionto being set when the <a href=\"#class-based-inheritance\">class is defined</a>. You can usethis to bind events, triggers, models, and collections at runtime:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: <span class=\"hljs-string\">'#template-identifier'</span>\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView({\n  triggers: {\n    <span class=\"hljs-string\">'click a'</span>: <span class=\"hljs-string\">'show:link'</span>\n  }\n});\n</pre> <p>This will set a trigger called <code>show:link</code> that will be fired whenever the userclicks an <code>&lt;a&gt;</code> inside the view.</p> <p>Options set here will override options set on class definition. So, for example:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: <span class=\"hljs-string\">'#template-identifier'</span>,\n\n  triggers: {\n    <span class=\"hljs-string\">'click @ui.save'</span>: <span class=\"hljs-string\">'save:form'</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView({\n  triggers: {\n    <span class=\"hljs-string\">'click a'</span>: <span class=\"hljs-string\">'show:link'</span>\n  }\n});\n</pre> <p>In this example, the trigger for <code>safe:form</code> will no longer be fired, as thetrigger for <code>show:link</code> completely overrides it.</p> <h2 id=\"setting-options\">\nSetting Options</h2>\n<p>Marionette can set options when you instantiate a class. This lets you overridemany class-based attributes when you need to. You can also pass new informationspecific to the object in question that it can access through special helpermethods.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  checkOption: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.getOption(<span class=\"hljs-string\">'foo'</span>));\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> MyView({\n  foo: <span class=\"hljs-string\">'some text'</span>\n});\n\n<span class=\"hljs-built_in\">console</span>.log(view.checkOption());  <span class=\"hljs-comment\">// prints 'some text'</span>\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/6n02ex1m/\">Live example</a></p> <h3 id=\"the-getoption-method\">\nThe <code>getOption</code> Method</h3>\n<p>To access an option, we use the <code>getOption</code> method.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  className: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">var</span> defaultClass = <span class=\"hljs-string\">'table'</span>;\n    <span class=\"hljs-keyword\">var</span> extraClasses = <span class=\"hljs-keyword\">this</span>.getOption(<span class=\"hljs-string\">'extraClasses'</span>) || <span class=\"hljs-string\">''</span>;\n    <span class=\"hljs-keyword\">return</span> defaultClass + <span class=\"hljs-string\">' '</span> + extraClasses;\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView({\n  model: <span class=\"hljs-keyword\">new</span> MyModel(),\n  extraClasses: <span class=\"hljs-string\">'table-striped'</span>\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/ekvb8wwa/\">Live example</a></p> <p>This only works for custom options - arguments that belong to the standardBackbone/Marionette attributes, such as <code>model</code> and <code>collection</code>, are notaccessible via <code>getOption</code> and should be accessed as just <code>view.model</code> or<code>view.collection</code>.</p> <h3 id=\"the-mergeoptions-method\">\nThe <code>mergeOptions</code> Method</h3>\n<p>The <code>mergeOptions</code> method takes two arguments: an <code>options</code> object and <code>keys</code> topull from the options object. Any matching <code>keys</code> will be merged onto theclass instance. For example:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyObject = Mn.Object.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.mergeOptions(options, [<span class=\"hljs-string\">'model'</span>, <span class=\"hljs-string\">'something'</span>]);\n    <span class=\"hljs-comment\">// this.model and this.something will now be available</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myObject = <span class=\"hljs-keyword\">new</span> MyObject({\n  model: <span class=\"hljs-keyword\">new</span> Backbone.Model(),\n  something: <span class=\"hljs-string\">'test'</span>,\n  another: <span class=\"hljs-string\">'value'</span>\n});\n\n<span class=\"hljs-built_in\">console</span>.log(myObject.model);\n<span class=\"hljs-built_in\">console</span>.log(myObject.something);\n<span class=\"hljs-built_in\">console</span>.log(myObject.getOption(<span class=\"hljs-string\">'another'</span>));\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/ub510cbx/\">Live example</a></p> <p>In this example, <code>model</code> and <code>something</code> are directly available on the<code>MyObject</code> instance, while <code>another</code> must be accessed via <code>getOption</code>. This ishandy when you want to add extra keys that will be used heavily throughout thedefined class.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/basics.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/basics.html</a>\n  </p>\n</div>\n","marionette.behaviors":"<h1>\nMarionette.Behaviors</h1>\n<p><strong>_DEPRECATED: The <code>behaviorsLookup</code> is deprecated pending removal. See the<br><a href=\"marionette.behavior\">documentation for Behavior</a> to learn how to map<br>behaviors to views in Marionette 3.</strong></p> <p>'Marionette.Behaviors' is a utility class that takes care of gluing your <code>Behavior</code> instances to their given <code>View</code>.The most important thing to understand when using this class is that you <strong>MUST</strong> override the class level <code>behaviorsLookup</code> method or set the option <code>behaviorClass</code> for things to work properly.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li>\n<a href=\"#api\">API</a><ul> <li><a href=\"#behaviorslookup\">Behaviors Lookup</a></li> <li><a href=\"#getbehaviorclass\">getBehaviorClass</a></li> <li><a href=\"#behaviorclass\">behaviorClass</a></li> </ul> </li> </ul> <h2 id=\"api\">\nAPI</h2>\n<p>There are two class level methods that you can override on the <code>Behaviors</code> class. The rest of the class is tied to under the hood implementation details of Views.</p> <h3 id=\"behaviorslookup\">\nbehaviorsLookup</h3>\n<p>This method defines where your Behavior classes are stored. A simple implementation might look something like this.</p> <pre data-language=\"javascript\">Marionette.Behaviors.behaviorsLookup = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">window</span>.Behaviors;\n}\n</pre> <p>There are 2 different syntaxes for attaching Behaviors to a View. The first is an object syntax where the Behaviors are looked up by their key value in a given View's behavior hash. The second is an array syntax where you can pass the Behavior class directly.</p> <p>In this sample, which uses the object syntax, your code will expect the following Behaviors to be present in <code>window.Behaviors.DestroyWarn</code> and <code>window.Behaviors.ToolTip</code></p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> MyView = Marionette.View.extend({\n    behaviors: {\n        ToolTip: {},\n        DestroyWarn: {\n            message: <span class=\"hljs-string\">\"you are destroying all your data is now gone!\"</span>\n        }\n    }\n});\n</pre> <p>If you use a module loader like <a href=\"http://requirejs.org/\">requirejs</a> or <a href=\"http://browserify.org/\">browserify</a> you can use the array based syntax, where you pass in a Behavior Class directly or include it as a behaviorClass property on your options object.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Tooltip = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'behaviors/tooltip'</span>);\n<span class=\"hljs-keyword\">var</span> DestroyWarn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'behaviors/destroy-warn'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Marionette.View.extend({\n    behaviors: [Tooltip, {\n        behaviorClass: DestroyWarn,\n        message: <span class=\"hljs-string\">\"you are destroying all your data is now gone!\"</span>\n    }]\n});\n</pre> <h3 id=\"getbehaviorclass\">\ngetBehaviorClass</h3>\n<p>This method has a default implementation that is simple to override. It is responsible for the lookup of single Behavior when given an options object and a key, and is used for both the array and object based notations.</p> <pre data-language=\"javascript\">getBehaviorClass: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options, key)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (options.behaviorClass) {\n        <span class=\"hljs-keyword\">return</span> options.behaviorClass;\n        <span class=\"hljs-comment\">//treat functions as a Behavior constructor</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(_.isFunction(options)) {\n        <span class=\"hljs-keyword\">return</span> options;\n    }\n    <span class=\"hljs-comment\">// behaviorsLookup can be either a flat object or a method</span>\n    <span class=\"hljs-keyword\">return</span> Marionette._getValue(Behaviors.behaviorsLookup, <span class=\"hljs-keyword\">this</span>, [options, key])[key];\n}\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.behaviors.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.behaviors.html</a>\n  </p>\n</div>\n","marionette.features":"<h1>\nFeatures</h1>\n<p>Marionette Features are opt-in functionality. That you can enable by setting <code>Marionette.FEATURES</code> in your app.</p> <h5>\nGoals:</h5>\n<ul> <li>make it possible to add breaking changes in a minor release</li> <li>give community members a chance to provide feedback for new functionality</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.features.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.features.html</a>\n  </p>\n</div>\n","marionette.region":"<h1>\nRegions</h1>\n<p>Regions provide consistent methods to manage, show and destroyviews in your applications and layouts. You can use a jQuery selector toidentify where your region must be displayed.</p> <p>See the documentation for <a href=\"marionette.view\">View</a> for an introduction inmanaging regions throughout your application.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#defining-the-application-region\">Defining the Application Region</a></li> <li>\n<a href=\"#defining-regions\">Defining Regions</a><ul> <li><a href=\"#string-selector\">String Selector</a></li> <li><a href=\"#additional-options\">Additional Options</a></li> <li><a href=\"#specifying-regions-as-a-function\">Specifying regions as a Function</a></li> <li><a href=\"#adding-regions\">Adding Regions</a></li> </ul> </li> <li>\n<a href=\"#showing-a-view\">Showing a View</a><ul> <li><a href=\"#hiding-a-view\">Hiding a View</a></li> <li><a href=\"#preserving-existing-views\">Preserving Existing Views</a></li> </ul> </li> <li><a href=\"#checking-whether-a-region-is-showing-a-view\">Checking whether a region is showing a view</a></li> <li><a href=\"#reset-a-region\"><code>reset</code> A Region</a></li> </ul> <h2 id=\"defining-the-application-region\">\nDefining the Application Region</h2>\n<p>The Application defines a single region <code>el</code> using the <code>region</code> attribute. Thiscan be accessed through <code>getRegion()</code> or have a view displayed directly with<code>showView()</code>. Below is a short example:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> SomeView = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./view'</span>);\n\n<span class=\"hljs-keyword\">var</span> App = Mn.Application.extend({\n  region: <span class=\"hljs-string\">'#main-content'</span>,\n\n  onStart: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">var</span> main = <span class=\"hljs-keyword\">this</span>.getRegion();  <span class=\"hljs-comment\">// Has all the properties of a `Region`</span>\n    main.show(<span class=\"hljs-keyword\">new</span> SomeView());\n  }\n});\n</pre> <p>For more information, see the<a href=\"marionette.application#root-layout\">Application docs</a>.</p> <h2 id=\"defining-regions\">\nDefining Regions</h2>\n<p>Marionette supports multiple ways to define regions on your <code>Application</code> or<code>View</code>. This section will document the different types as applied to <code>View</code>,although they will work for <code>Application</code> as well - just replace <code>regions</code> with<code>region</code> in your definition.</p> <h3 id=\"string-selector\">\nString Selector</h3>\n<p>You can use a jQuery string selector to define regions.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  regions: {\n    mainRegion: <span class=\"hljs-string\">'#main'</span>\n  }\n});\n</pre> <h3 id=\"additional-options\">\nAdditional Options</h3>\n<p>You can define regions with an object literal. Object literal definitions expectan <code>el</code> property - the jQuery selector string to hook the region into. Theobject literal is the most common way to define whether showing the regionoverwrites the <code>el</code> or just overwrites the content (the default behavior).</p> <p>To overwrite the parent <code>el</code> of the region with the rendered contents of theinner View, use <code>replaceElement</code> as so:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> OverWriteView = Mn.View.extend({\n  className: <span class=\"hljs-string\">'.new-class'</span>\n});\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  regions: {\n    main: {\n      el: <span class=\"hljs-string\">'.overwrite-me'</span>,\n      replaceElement: <span class=\"hljs-literal\">true</span>\n    }\n  }\n});\n<span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> MyView();\nview.render();\n\n<span class=\"hljs-built_in\">console</span>.log(view.$(<span class=\"hljs-string\">'.overwrite-me'</span>).length); <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-built_in\">console</span>.log(view.$(<span class=\"hljs-string\">'.new-class'</span>).length); <span class=\"hljs-comment\">// 0</span>\n\nview.showChildView(<span class=\"hljs-string\">'main'</span>, <span class=\"hljs-keyword\">new</span> OverWriteView());\n\n<span class=\"hljs-built_in\">console</span>.log(view.$(<span class=\"hljs-string\">'.overwrite-me'</span>).length); <span class=\"hljs-comment\">// 0</span>\n<span class=\"hljs-built_in\">console</span>.log(view.$(<span class=\"hljs-string\">'.new-class'</span>).length); <span class=\"hljs-comment\">// 1</span>\n</pre> <p>When the instance of <code>MyView</code> is rendered, the <code>.overwrite-me</code> element will beremoved from the DOM and replaced with an element of <code>.new-class</code> - this letsus do things like rendering views inside <code>table</code> or <code>select</code> more easily -these elements are usually very strict on what content they will allow.</p> <h3 id=\"specifying-regions-as-a-function\">\nSpecifying regions as a Function</h3>\n<p>The <code>regions</code> attribute on a view can be a<a href=\"basics#functions-returning-values\">function returning an object</a>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  regions: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n    <span class=\"hljs-keyword\">return</span> {\n      firstRegion: <span class=\"hljs-string\">'#first-region'</span>\n    };\n  }\n});\n</pre> <p>The <code>options</code> argument contains the options passed to the view on instantiation.As the view has not been constructed yet, <code>this.getOption()</code> is not able toreturn any options from the view - use <code>options</code> instead.</p> <h3 id=\"adding-regions\">\nAdding Regions</h3>\n<p>To add regions to a view after it has been instantiated, simply use the<code>addRegion</code> method:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> MyView = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./myview'</span>);\n\nmyView = <span class=\"hljs-keyword\">new</span> MyView();\nmyView.addRegion(<span class=\"hljs-string\">'thirdRegion'</span>, <span class=\"hljs-string\">'#third-region'</span>);\n</pre> <p>Now we can access <code>thirdRegion</code> as we would the others.</p> <h2 id=\"showing-a-view\">\nShowing a View</h2>\n<p>Once a region is defined, you can call its <code>show</code>and <code>empty</code> methods to display and shut-down a view:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n<span class=\"hljs-keyword\">var</span> childView = <span class=\"hljs-keyword\">new</span> MyChildView();\n<span class=\"hljs-keyword\">var</span> mainRegion = myView.getRegion(<span class=\"hljs-string\">'main'</span>);\n\n<span class=\"hljs-comment\">// render and display the view</span>\nmainRegion.show(childView);\n</pre> <p>This is equivalent to a view's <code>showChildView</code> which can be used as:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n<span class=\"hljs-keyword\">var</span> childView = <span class=\"hljs-keyword\">new</span> MyChildView();\n\n<span class=\"hljs-comment\">// render and display the view</span>\nmyView.showChildView(<span class=\"hljs-string\">'main'</span>, childView);\n</pre> <p>Both forms take an <code>options</code> object that will be passed to the<a href=\"#events-raised-during-show\">events fired during <code>show</code></a>.</p> <p>For more information on <code>showChildView</code> and <code>getChildView</code>, see the<a href=\"marionette.view#managing-sub-views\">Documentation for Views</a></p> <h3 id=\"hiding-a-view\">\nHiding a View</h3>\n<p>You can remove a view from a region (effectively \"unshowing\" it) with<code>region.empty()</code> on a region:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n\nmyView.showChildView(<span class=\"hljs-string\">'main'</span>, <span class=\"hljs-keyword\">new</span> OtherView());\n<span class=\"hljs-keyword\">var</span> mainRegion = myView.getRegion(<span class=\"hljs-string\">'main'</span>);\nmainRegion.empty();\n</pre> <p>This will destroy the view, cleaning up any event handlers and remove it fromthe DOM.</p> <h3 id=\"preserving-existing-views\">\nPreserving Existing Views</h3>\n<p>If you replace the current view with a new view by calling <code>show</code>,by default it will automatically destroy the previous view.You can prevent this behavior by passing <code>{preventDestroy: true}</code> in the optionsparameter. Several events will also be triggered on the views.</p> <pre data-language=\"javascript\"><span class=\"hljs-comment\">// Show the first view.</span>\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n<span class=\"hljs-keyword\">var</span> childView = <span class=\"hljs-keyword\">new</span> MyChildView();\n\n<span class=\"hljs-keyword\">var</span> mainRegion = myView.getRegion(<span class=\"hljs-string\">'main'</span>);\n\nmainRegion.show(childView);\n\n<span class=\"hljs-comment\">// Replace the view with another. The</span>\n<span class=\"hljs-comment\">// `destroy` method is called for you</span>\n<span class=\"hljs-keyword\">var</span> anotherView = <span class=\"hljs-keyword\">new</span> AnotherView();\nmainRegion.show(anotherView);\n\n<span class=\"hljs-comment\">// Replace the view with another.</span>\n<span class=\"hljs-comment\">// Prevent `destroy` from being called</span>\n<span class=\"hljs-keyword\">var</span> anotherView2 = <span class=\"hljs-keyword\">new</span> AnotherView();\nmainRegion.show(anotherView2, {preventDestroy: <span class=\"hljs-literal\">true</span>});\nmainRegion.empty({preventDestroy: <span class=\"hljs-literal\">true</span>});\n</pre> <p><strong>NOTE</strong> When using <code>preventDestroy: true</code> you must be careful to cleanup yourold views manually to prevent memory leaks.</p> <h3 id=\"checking-whether-a-region-is-showing-a-view\">\nChecking whether a region is showing a view</h3>\n<p>If you wish to check whether a region has a view, you can use the <code>hasView</code>function. This will return a boolean value depending whether or not the regionis showing a view.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n<span class=\"hljs-keyword\">var</span> mainRegion = myView.getRegion(<span class=\"hljs-string\">'main'</span>);\n\nmainRegion.hasView() <span class=\"hljs-comment\">// false</span>\nmainRegion.show(<span class=\"hljs-keyword\">new</span> OtherView());\nmainRegion.hasView() <span class=\"hljs-comment\">// true</span>\n</pre> <h3 id=\"reset-a-region\">\n<code>reset</code> A Region</h3>\n<p>A region can be <code>reset</code> at any time. This destroys any existing viewbeing displayed, and deletes the cached <code>el</code>. The next time theregion shows a view, the region's <code>el</code> is queried fromthe DOM.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\nmyView.showChildView(<span class=\"hljs-string\">'main'</span>, <span class=\"hljs-keyword\">new</span> OtherView());\n<span class=\"hljs-keyword\">var</span> mainRegion = myView.getRegion(<span class=\"hljs-string\">'main'</span>);\nmyRegion.reset();\n</pre> <p>This can be useful in unit testing your views.</p> <h3 id=\"set-how-views-el-is-attached\">\nSet How View's <code>el</code> Is Attached</h3>\n<p>Override the region's <code>attachHtml</code> method to change how the view is attachedto the DOM. This method receives one parameter - the view to show.</p> <p>The default implementation of <code>attachHtml</code> is:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.Region.prototype.attachHtml = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view)</span></span>{\n  <span class=\"hljs-keyword\">this</span>.$el.empty().append(view.el);\n}\n</pre> <p>This replaces the contents of the region with the view's<code>el</code> / content. You can override <code>attachHtml</code> for transition effects and more.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.Region.prototype.attachHtml = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view)</span></span>{\n  <span class=\"hljs-keyword\">this</span>.$el.hide();\n  <span class=\"hljs-keyword\">this</span>.$el.html(view.el);\n  <span class=\"hljs-keyword\">this</span>.$el.slideDown(<span class=\"hljs-string\">\"fast\"</span>);\n}\n</pre> <p>It is also possible to define a custom render method for a single region byextending from the Region class and including a custom attachHtml method.</p> <p>This example will make a view slide down from the top of the screen instead of justappearing in place:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> ModalRegion = Mn.Region.extend({\n  attachHtml: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(view)</span></span>{\n    <span class=\"hljs-comment\">// Some effect to show the view:</span>\n    <span class=\"hljs-keyword\">this</span>.$el.empty().append(view.el);\n    <span class=\"hljs-keyword\">this</span>.$el.hide().slideDown(<span class=\"hljs-string\">'fast'</span>);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  regions: {\n    mainRegion: <span class=\"hljs-string\">'#main-region'</span>,\n    modalRegion: {\n      regionClass: ModalRegion,\n      el: <span class=\"hljs-string\">'#modal-region'</span>\n    }\n  }\n});\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.region.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.region.html</a>\n  </p>\n</div>\n","backbone.radio":"<h1>\nBackbone Radio</h1>\n<p>The Backbone Radio provides easy support for a number of messaging patterns forBackbone and Marionette. This is provided through two basic constructs:</p> <ul> <li>Events - trigger events on a global object</li> <li>Requests - a global request/reply implementation</li> </ul> <p>Radio takes these two constructs and adds the channel implementation - providingnamespaces for events and requests. In short, Radio is a global, namespaced,message bus system designed to allow two otherwise unrelated objects tocommunicate and share information.</p> <p>Let's look at a simplified example in Marionette:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> NotificationHandler = Mn.Object.extend({\n  channelName: <span class=\"hljs-string\">'notify'</span>,\n\n  radioRequests: {\n    <span class=\"hljs-string\">'show:success'</span>: <span class=\"hljs-string\">'showSuccessMessage'</span>,\n    <span class=\"hljs-string\">'show:error'</span>: <span class=\"hljs-string\">'showErrorMessage'</span>\n  },\n\n  radioEvents: {\n    <span class=\"hljs-string\">'user:logged:in'</span>: <span class=\"hljs-string\">'showProfileButton'</span>,\n    <span class=\"hljs-string\">'user:logged:out'</span>: <span class=\"hljs-string\">'hideProfileButton'</span>\n  },\n\n  showSuccessMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(message)</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n  },\n\n  showErrorMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(message)</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n  },\n\n  showProfileButton: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(user)</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n  },\n\n  hideProfileButton: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(user)</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n  }\n});\n</pre> <p>In an unrelated module:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Radio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.radio'</span>);\n<span class=\"hljs-keyword\">var</span> User = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./models/user'</span>);\n\n<span class=\"hljs-keyword\">var</span> notifyChannel = Radio.channel(<span class=\"hljs-string\">'notify'</span>);\n<span class=\"hljs-keyword\">var</span> userModel = <span class=\"hljs-keyword\">new</span> User();\n\n<span class=\"hljs-comment\">// The following will call Notification.showErrorMessage(message)</span>\nnotifyChannel.request(<span class=\"hljs-string\">'show:error'</span>, <span class=\"hljs-string\">'A generic error occurred!'</span>);\n\n<span class=\"hljs-comment\">// The following will call Notification.showProfileButton(user)</span>\nnotifyChannel.trigger(<span class=\"hljs-string\">'user:logged:in'</span>, userModel);\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/dv40a0t2/\">Live example</a></p> <p>In addition to this documentation, the Radio documentation can be found on<a href=\"https://github.com/marionettejs/backbone.radio\">Github</a>.</p> <p>In addition to the standard documentation, the Radio has been integrated inMarionette 3 to provide clearer interfaces to the existing API. This is detailedin the documentation below. Anything that extends from <code>Mn.Object</code> hasaccess to this API.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li>\n<a href=\"#channel\">Channel</a><ul> <li><a href=\"#assigning-channels-to-objects\">Assigning Channels to Objects</a></li> </ul> </li> <li>\n<a href=\"#event\">Event</a><ul> <li><a href=\"#listening-to-events-on-objects\">Listening to Events on Objects</a></li> <li><a href=\"#when-to-use-events\">When to use Events</a></li> </ul> </li> <li>\n<a href=\"#request\">Request</a><ul> <li><a href=\"#returning-values-from-reply\">Returning Values from Reply</a></li> <li><a href=\"#listening-to-requests-on-objects\">Listening to Requests on Objects</a></li> <li><a href=\"#when-to-use-requests\">When to use Requests</a></li> </ul> </li> </ul> <h2 id=\"channel\">\nChannel</h2>\n<p>The <code>channel</code> is the biggest reason to use <code>Radio</code> as our event aggregator - itprovides a clean point for dividing global events. To retrieve a channel, use<code>Radio.channel(channelName)</code>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Radio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.radio'</span>);\n\n<span class=\"hljs-keyword\">var</span> myChannel = Radio.channel(<span class=\"hljs-string\">'basic'</span>);\n\nmyChannel.on(<span class=\"hljs-string\">'some:event'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-comment\">// ...</span>\n});\n</pre> <p>The channel is accessible everywhere in your application. Simply import Radioand call <code>channel()</code> to add listeners, fire callbacks, or send requests.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Radio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.radio'</span>);\n\n<span class=\"hljs-keyword\">var</span> someChannel = Radio.channel(<span class=\"hljs-string\">'basic'</span>);  <span class=\"hljs-comment\">// Exactly the same channel as above</span>\n\nsomeChannel.trigger(<span class=\"hljs-string\">'some:event'</span>);  <span class=\"hljs-comment\">// Will fire the function call above</span>\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/0bejfju0/\">Live example</a></p> <h3 id=\"assigning-channels-to-objects\">\nAssigning Channels to Objects</h3>\n<p>As of Marionette 3, it is now possible to assign Radio channels directly toinstances of <code>Marionette.Object</code> and assign listeners. To assign a channel, weuse the <code>channelName</code> attribute. We then retrieve the channel instance with<code>getChannel()</code>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> ChannelHandler = Mn.Object.extend({\n  channelName: <span class=\"hljs-string\">'basic'</span>,\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">var</span> channel = <span class=\"hljs-keyword\">this</span>.getChannel();\n    <span class=\"hljs-keyword\">this</span>.listenTo(channel, <span class=\"hljs-string\">'log'</span>, <span class=\"hljs-keyword\">this</span>.logMsg);\n  },\n\n  logMsg: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(msg)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(msg);\n  }\n})\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/tmeraxd2/\">Live example</a></p> <h2 id=\"event\">\nEvent</h2>\n<p>The <code>Radio Event</code> works almost exactly the same way as regular <code>Backbone Events</code>like model/collection events. They also expose exactly the same API:</p> <ul> <li>\n<code>channel.on('event', callback, context)</code> - when <code>event</code> fires, call <code>callback</code>\n</li> <li>\n<code>channel.off('event')</code> - stop listening to event</li> <li>\n<code>channel.trigger('event', ..args)</code> - fires <code>event</code> and passes args into the<br>resulting <code>callback</code>\n</li> </ul> <p>Events are typically used to alert other parts of the system that somethinghappened. For example, a user login expired or the user performed a specificaction.</p> <p>As the Radio can be imported anywhere, we can use it as a global eventaggregator as such:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Radio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.radio'</span>);\n\n<span class=\"hljs-keyword\">var</span> myChannel = Radio.channel(<span class=\"hljs-string\">'star'</span>);\n\nmyChannel.on(<span class=\"hljs-string\">'left:building'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(person)</span> </span>{\n  <span class=\"hljs-built_in\">console</span>.log(person.get(<span class=\"hljs-string\">'name'</span>) + <span class=\"hljs-string\">' has left the building!'</span>);\n});\n\n<span class=\"hljs-keyword\">var</span> elvis = <span class=\"hljs-keyword\">new</span> Bb.Model({name: <span class=\"hljs-string\">'Elvis'</span>});\nmyChannel.trigger(<span class=\"hljs-string\">'left:building'</span>, elvis);\n\nmyChannel.off(<span class=\"hljs-string\">'left:building'</span>);\n</pre> <p>Just like Backbone Events, the Radio respects the <code>listenTo</code> handler as well:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> Radio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.radio'</span>);\n\n\n<span class=\"hljs-keyword\">var</span> Star = Mn.Object.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">var</span> starChannel = Radio.channel(<span class=\"hljs-string\">'star'</span>);\n\n    <span class=\"hljs-keyword\">this</span>.listenTo(starChannel, <span class=\"hljs-string\">'left:building'</span>, <span class=\"hljs-keyword\">this</span>.leftBuilding);\n  },\n\n  leftBuilding: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(person)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(person.get(<span class=\"hljs-string\">'name'</span>) + <span class=\"hljs-string\">' has left the building!'</span>);\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/s8nff8vz/\">Live example</a></p> <p>As with Backbone, this will bind <code>this</code> to our <code>Star</code> instance. See the<a href=\"http://backbonejs.org/#Events\">Backbone documentation</a> for the full list ofEvent handling methods.</p> <h3 id=\"listening-to-events-on-objects\">\nListening to Events on Objects</h3>\n<p>The <code>Marionette.Object</code> class provides bindings to provide automatic eventlisteners on your object instances. This works with a bound <code>channelName</code> to letus provide listeners using the <code>radioEvents</code> attributes.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n\n<span class=\"hljs-keyword\">var</span> Star = Mn.Object.extend({\n  channelName: <span class=\"hljs-string\">'star'</span>,\n\n  radioEvents: {\n    <span class=\"hljs-string\">'left:building'</span>: <span class=\"hljs-string\">'leftBuilding'</span>\n  },\n\n  leftBuilding: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(person)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(person.get(<span class=\"hljs-string\">'name'</span>) + <span class=\"hljs-string\">' has left the building!'</span>);\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/tf9467x4/\">Live example</a></p> <p>This gives us a clear definition of how this object interacts with the <code>star</code>radio channel.</p> <h3 id=\"when-to-use-events\">\nWhen to use Events</h3>\n<p>The Event is a simple notification that <em>something happened</em> and you may or maynot want other objects in your application to react to that. A few keyprinciples to bear in mind are:</p> <ul> <li>If you don't know what could act on the event, or don't care, use an <code>Event</code>\n</li> <li>If you find yourself calling it an action that occurred, use an <code>Event</code>\n</li> <li>If it's fine for many objects to perform an action, use an <code>Event</code>\n</li> <li>If you don't mind that no objects react, use an <code>Event</code>\n</li> </ul> <p>If your use case isn't covered here, consider whether you want to<a href=\"#when-to-use-requests\">use a request</a> instead.</p> <h2 id=\"request\">\nRequest</h2>\n<p>The Request API provides a uniform way for unrelated parts of the system tocommunicate with each other. For example, displaying notifications in responseto system activity. To attach a listener to a request channel, use <code>reply</code> or<code>replyOnce</code> to attach a listener that immediately detaches after one call.</p> <p>As with request, any arguments passed in <code>channel.request</code> will be passed intothe callback.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> Radio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.radio'</span>);\n\n<span class=\"hljs-keyword\">var</span> channel = Radio.channel(<span class=\"hljs-string\">'notify'</span>);\n\n<span class=\"hljs-keyword\">var</span> Notification = Mn.Object.extend({\n  channelName: <span class=\"hljs-string\">'notify'</span>,\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    channel.reply(<span class=\"hljs-string\">'show:success'</span>, <span class=\"hljs-keyword\">this</span>.showSuccessMessage);\n    channel.reply(<span class=\"hljs-string\">'show:error'</span>, <span class=\"hljs-keyword\">this</span>.showErrorMessage);\n  },\n\n  showSuccessMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(msg)</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n  },\n\n  showErrorMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(msg)</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n  }\n});\n</pre> <p>So, for example, when a model sync fails:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> Radio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.radio'</span>);\n\n<span class=\"hljs-keyword\">var</span> channel = Radio.channel(<span class=\"hljs-string\">'notify'</span>);\n\n<span class=\"hljs-keyword\">var</span> ModelView = Mn.View.extend({\n  modelEvents: {\n    error: <span class=\"hljs-string\">'showErrorMessage'</span>\n  },\n\n  showErrorMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    channel.request(<span class=\"hljs-string\">'show:error'</span>, <span class=\"hljs-string\">'An error occurred contacting the server'</span>);\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/4uuyLe1q/\">Live example</a></p> <p>Now, whenever the model attached to this View is unable to sync with the server,we can display an error message to the user.</p> <h3 id=\"returning-values-from-reply\">\nReturning Values from Reply</h3>\n<p>The Request API is also able to return values, making it extremely useful foraccessing objects that would be otherwise difficult to access. As an example,let's assume we attach the currently logged-in user to the <code>Application</code> objectand we want to know if they're still logged-in.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> Radio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.radio'</span>);\n\n<span class=\"hljs-keyword\">var</span> channel = Radio.channel(<span class=\"hljs-string\">'user'</span>);\n\n<span class=\"hljs-keyword\">var</span> App = Mn.Application.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    channel.reply(<span class=\"hljs-string\">'user:logged:in'</span>, <span class=\"hljs-keyword\">this</span>.isLoggedIn);\n  },\n\n  isLoggedIn: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.model.getLoggedIn();\n  }\n});\n</pre> <p>Then, from another view, instead of trying to find the User model. we simply<code>request</code> it:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Radio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.radio'</span>);\n\n<span class=\"hljs-keyword\">var</span> channel = Radio.channel(<span class=\"hljs-string\">'user'</span>);\n\n<span class=\"hljs-keyword\">var</span> loggedIn = channel.request(<span class=\"hljs-string\">'user:logged:in'</span>);  <span class=\"hljs-comment\">// App.model.getLoggedIn()</span>\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/zaje1rLj/\">Live example</a></p> <h3 id=\"listening-to-requests-on-objects\">\nListening to Requests on Objects</h3>\n<p>Marionette 3 integrates Request/Reply directly onto its <code>Object</code> class through<code>radioRequests</code>. This will simplify the <code>Notification</code> quite a bit:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> Notification = Mn.Object.extend({\n  channelName: <span class=\"hljs-string\">'notify'</span>,\n\n  radioRequests: {\n    <span class=\"hljs-string\">'show:success'</span>: <span class=\"hljs-string\">'showSuccessMessage'</span>,\n    <span class=\"hljs-string\">'show:error'</span>: <span class=\"hljs-string\">'showErrorMessage'</span>\n  },\n\n  showSuccessMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(msg)</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n  },\n\n  showErrorMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(msg)</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/j2qgfk3s/\">Live example</a></p> <p>We now have a clear API for communicating with the <code>Notification</code> across theapplication. Don't forget to define the <code>channelName</code> on your <code>Object</code>definition.</p> <p>As with a normal request/reply, we can return values from these bound handlers:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> App = Mn.Application.extend({\n  channelName: <span class=\"hljs-string\">'user'</span>,\n\n  radioRequests: {\n    <span class=\"hljs-string\">'user:logged:in'</span>: <span class=\"hljs-string\">'isLoggedIn'</span>\n  },\n\n  isLoggedIn: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.model.getLoggedIn();\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/52rpd3zg/\">Live example</a></p> <p>As above, define your <code>channelName</code> attribute, then simply add the <code>reply</code>handler to <code>radioRequests</code> to bind it to your <code>Object</code> (<code>Application</code> in thiscase).</p> <h3 id=\"when-to-use-requests\">\nWhen to use Requests</h3>\n<p>A Request is, as you might guess, a request for information or for something tohappen. You will probably want to use requests when:</p> <ul> <li>You call the request an action to perform e.g. <code>show:notification</code>\n</li> <li>You want to get the return value of the request</li> <li>You want to call <em>exactly one</em> function</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/backbone.radio.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/backbone.radio.html</a>\n  </p>\n</div>\n","marionette.behavior":"<h1>\nMarionette.Behavior</h1>\n<p>A <code>Behavior</code> provides a clean separation of concerns to your view logic,allowing you to share common user-facing operations between your views.</p> <p>Behaviors are particularly good at factoring out the common user, model andcollection interactions to be utilized across your application.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li>\n<a href=\"#using-behaviors\">Using Behaviors</a><ul> <li><a href=\"#defining-and-attaching-behaviors\">Defining and Attaching Behaviors</a></li> <li><a href=\"#behavior-options\">Behavior Options</a></li> </ul> </li> <li><a href=\"#nesting-behaviors\">Nesting Behaviors</a></li> <li>\n<a href=\"#view-proxy\">View Proxy</a><ul> <li><a href=\"#listening-to-view-events\">Listening to View Events</a></li> <li><a href=\"#proxy-handlers\">Proxy Handlers</a></li> <li><a href=\"#template-and-view\">Template and View</a></li> <li><a href=\"#%24\">$</a></li> <li><a href=\"#%24el-and-el\">$el and el</a></li> <li><a href=\"#defaults\">Defaults</a></li> <li><a href=\"#view\">View</a></li> </ul> </li> </ul> <h2 id=\"using-behaviors\">\nUsing Behaviors</h2>\n<p>The easiest way to see how to use the <code>Behavior</code> class is to take an exampleview and factor out common behavior to be shared across other views.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  ui: {\n    destroy: <span class=\"hljs-string\">'.destroy-btn'</span>\n  },\n\n  events: {\n    <span class=\"hljs-string\">'click @ui.destroy'</span>: <span class=\"hljs-string\">'warnBeforeDestroy'</span>\n  },\n\n  warnBeforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    alert(<span class=\"hljs-string\">'You are about to destroy all your data!'</span>);\n    <span class=\"hljs-keyword\">this</span>.destroy();\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.ui.destroy.tooltip({\n      text: <span class=\"hljs-string\">'What a nice mouse you have.'</span>\n    });\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/pa8ryv03/\">Live example</a></p> <p>Interaction points, such as tooltips and warning messages, are generic concepts.There is no need to recode them within your Views so they are prime candidatesto be extracted into <code>Behavior</code> classes.</p> <h3 id=\"defining-and-attaching-behaviors\">\nDefining and Attaching Behaviors</h3>\n<pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> DestroyWarn = Mn.Behavior.extend({\n  <span class=\"hljs-comment\">// You can set default options</span>\n  <span class=\"hljs-comment\">// just like you can in your Backbone Models.</span>\n  <span class=\"hljs-comment\">// They will be overridden if you pass in an option with the same key.</span>\n  defaults: {\n    message: <span class=\"hljs-string\">'You are destroying!'</span>\n  },\n  ui: {\n    destroy: <span class=\"hljs-string\">'.destroy-btn'</span>\n  },\n\n  <span class=\"hljs-comment\">// Behaviors have events that are bound to the views DOM.</span>\n  events: {\n    <span class=\"hljs-string\">'click @ui.destroy'</span>: <span class=\"hljs-string\">'warnBeforeDestroy'</span>\n  },\n\n  warnBeforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-keyword\">this</span>.getOption(<span class=\"hljs-string\">'message'</span>);\n    <span class=\"hljs-built_in\">window</span>.alert(message);\n    <span class=\"hljs-comment\">// Every Behavior has a hook into the</span>\n    <span class=\"hljs-comment\">// view that it is attached to.</span>\n    <span class=\"hljs-keyword\">this</span>.view.destroy();\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> ToolTip = Mn.Behavior.extend({\n  defaults: {\n    text: <span class=\"hljs-string\">''</span>\n  },\n  ui: {\n    tooltip: <span class=\"hljs-string\">'.tooltip'</span>\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.ui.tooltip.tooltip({\n      text: <span class=\"hljs-keyword\">this</span>.getOption(<span class=\"hljs-string\">'text'</span>)\n    });\n  }\n});\n</pre> <p>We've passed in a <code>defaults</code> attribute that sets default options.<a href=\"#defaults\">This will be covered in default soon</a>. With the warning and tooltipbehaviors extracted, we just need to attach them to our view:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  behaviors: [DestroyWarn, ToolTip]\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/b1awta6u/\">Live example</a></p> <p>Each behavior will now be able to respond to user interactions as though theevent handlers were attached to the view directly. In addition to using arraynotation, Behaviors can be attached using an object:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  behaviors: {\n    destroy: DestroyWarn,\n    tooltip: ToolTip\n  }\n});\n</pre> <h4>\nBehavior Options</h4>\n<p>When we attach behaviors to views, we can also pass in options to add to thebehavior. This tends to be static information relating to what the behaviorshould do. In our above example, we want to override the message to our<code>DestroyWarn</code> and <code>Tooltip</code> behaviors to match the original message on the View:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  behaviors: [\n    {\n      behaviorClass: DestroyWarn,\n      message: <span class=\"hljs-string\">'You are about to destroy all your data!'</span>\n    },\n    {\n      behaviorClass: ToolTip,\n      text: <span class=\"hljs-string\">'What a nice mouse you have.'</span>\n    }\n  ]\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/vq9k3c69/\">Live example</a></p> <p>Using an object, we must define the <code>behaviorClass</code> attribute to refer to ourbehaviors and then add any extra options with keys matching the option we wantto override. Any passed options will override the <code>defaults</code> passed.</p> <p>Here is the syntax for declaring which behaviors get used within a View.</p> <ul> <li>You can pass behaviors either as a set of key-value pairs where the keys are used to lookup the behavior class, or as an array.</li> <li>The options for each <code>Behavior</code> are also passed through to the <code>Behavior</code> during initialization.</li> <li>The options are then stored within each <code>Behavior</code> under <code>options</code>.</li> </ul> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  ui: {\n    destroy: <span class=\"hljs-string\">'.destroy-btn'</span>\n  },\n\n  behaviors: {\n    DestroyWarn: {\n      message: <span class=\"hljs-string\">'you are destroying all your data is now gone!'</span>\n    },\n    ToolTip: {\n      text: <span class=\"hljs-string\">'what a nice mouse you have'</span>\n    }\n  }\n});\n</pre> <p>Now let's create the <code>DestroyWarn</code> <code>Behavior</code>.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> DestroyWarn = Mn.Behavior.extend({\n  <span class=\"hljs-comment\">// You can set default options</span>\n  <span class=\"hljs-comment\">// just like you can in your Backbone Models.</span>\n  <span class=\"hljs-comment\">// They will be overridden if you pass in an option with the same key.</span>\n  defaults: {\n    message: <span class=\"hljs-string\">'You are destroying!'</span>\n  },\n\n  <span class=\"hljs-comment\">// Behaviors have events that are bound to the views DOM.</span>\n  events: {\n    <span class=\"hljs-string\">'click @ui.destroy'</span>: <span class=\"hljs-string\">'warnBeforeDestroy'</span>\n  },\n\n  warnBeforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    alert(<span class=\"hljs-keyword\">this</span>.options.message);\n    <span class=\"hljs-comment\">// Every Behavior has a hook into the</span>\n    <span class=\"hljs-comment\">// view that it is attached to.</span>\n    <span class=\"hljs-keyword\">this</span>.view.destroy();\n  }\n});\n</pre> <p>And onto the <code>Tooltip</code> behavior.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> ToolTip = Mn.Behavior.extend({\n  ui: {\n    tooltip: <span class=\"hljs-string\">'.tooltip'</span>\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.ui.tooltip.tooltip({\n      text: <span class=\"hljs-keyword\">this</span>.options.text\n    });\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/p8vymo4j/\">Live example</a></p> <h2 id=\"nesting-behaviors\">\nNesting Behaviors</h2>\n<p>In addition to extending a <code>View</code> with <code>Behavior</code>, a <code>Behavior</code> can itself useother Behaviors. The syntax is identical to that used for a <code>View</code>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> Modal = Mn.Behavior.extend({\n  behaviors: {\n    DestroyWarn: {\n      message: <span class=\"hljs-string\">'Whoa! You sure about this?'</span>\n    }\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/7ffnqff3/\">Live example</a></p> <p>Nested Behaviors act as if they were direct Behaviors of the parent <code>Behavior</code>'sview instance.</p> <h2 id=\"view-proxy\">\nView Proxy</h2>\n<p>The <code>Behavior</code> class provides proxies for a selection of <code>View</code> functionality.This includes listening to events on the view, being able to handle events onmodels and collections, and being able to directly interact with the attachedtemplate.</p> <h3 id=\"listening-to-view-events\">\nListening to View Events</h3>\n<p>Behaviors are powered by an event proxy. This means that any events that aretriggered on a <code>View</code> are passed to all attached <code>behaviors</code>. This includes:</p> <ul> <li>Events fired by <code>triggerMethod</code>\n</li> <li>Events fired from <code>triggers</code>\n</li> <li>Events fired by <code>childViewTriggers</code>\n</li> <li>Events fired from <code>childView</code>\n</li> </ul> <p>These handlers work exactly as they do on <code>View</code> -<a href=\"marionette.view#events\">see the <code>View</code> documentation</a></p> <h3 id=\"proxy-handlers\">\nProxy Handlers</h3>\n<p>Behaviors provide proxies to a number of the view event handling attributesincluding:</p> <ul> <li><a href=\"marionette.view#view-events\"><code>events</code></a></li> <li><a href=\"marionette.view#view-triggers\"><code>triggers</code></a></li> <li><a href=\"marionette.view#model-events\"><code>modelEvents</code></a></li> <li><a href=\"marionette.view#collection-events\"><code>collectionEvents</code></a></li> </ul> <h4>\nUsing <code>ui</code>\n</h4>\n<p>As in views, <code>events</code> and <code>triggers</code> can use the <code>ui</code> references in theirlisteners. These can be defined on either the Behavior or the View:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyBehavior = Mn.Behavior.extend({\n  ui: {\n    saveForm: <span class=\"hljs-string\">'.btn-save'</span>\n  },\n\n  events: {\n    <span class=\"hljs-string\">'click @ui.saveForm'</span>: <span class=\"hljs-string\">'saveForm'</span>\n  },\n\n  modelEvents: {\n    invalid: <span class=\"hljs-string\">'showError'</span>\n  },\n\n  saveForm: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.view.model.save();\n  },\n\n  showError: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    alert(<span class=\"hljs-string\">'You have errors'</span>);\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/6b8o3pmz/\">Live example</a></p> <h3 id=\"template-and-view\">\nTemplate and View</h3>\n<p>The <code>Behavior</code> has a number of proxies attributes that directly refer to therelated attribute on a view:</p> <ul> <li><code>$</code></li> <li><code>el</code></li> <li><code>$el</code></li> </ul> <p>In addition, each behavior is able to reference the view they are attached tothrough the <code>view</code> attribute:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> ViewBehavior = Mn.Behavior.extend({\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.view.model.get(<span class=\"hljs-string\">'selected'</span>)) {\n      <span class=\"hljs-keyword\">this</span>.$el.addClass(<span class=\"hljs-string\">'highlight'</span>);\n    }\n    <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">this</span>.$el.removeClass(<span class=\"hljs-string\">'highlight'</span>);\n    }\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/8dmk30Lq/\">Live example</a></p> <h4>\nReferencing the DOM</h4>\n<p>Behaviors, like views, have a <code>ui</code> attribute that can reference and cache DOMelements, just as in the <code>View</code>. For more detail, see the<a href=\"marionette.view#organising-your-view\"><code>ui</code> documentation for views</a>.</p> <p>If your <code>ui</code> keys clash with keys on the attached view, references within thebehavior will always use the definition on the behavior itself. As views areonly peripherally aware of their behaviors, their <code>ui</code> keys will not be changedwhen accessed within the <code>View</code>. For example:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyBehavior = Mn.Behavior.extend({\n  ui: {\n    saveForm: <span class=\"hljs-string\">'.btn-save'</span>\n  },\n\n  events: {\n    <span class=\"hljs-string\">'click @ui.saveForm'</span>: <span class=\"hljs-string\">'saveForm'</span>  <span class=\"hljs-comment\">// .btn-save</span>\n  },\n\n  saveForm: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.view.model.save();\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> FirstView = Mn.View.extend({\n  behaviors: [MyBehavior],\n\n  ui: {\n    saveForm: <span class=\"hljs-string\">'.btn-primary'</span>\n  },\n\n  events: {\n    <span class=\"hljs-string\">'click @ui.saveForm'</span>: <span class=\"hljs-string\">'checkForm'</span>  <span class=\"hljs-comment\">// .btn-primary</span>\n  },\n\n  checkForm: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/xoy56gpv/\">Live example</a></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.behavior.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.behavior.html</a>\n  </p>\n</div>\n","events":"<h1>\nMarionette Events</h1>\n<p>The Marionette Event system provides a system for objects to communicate witheach other in a uniform way. In Marionette, this typically involves objects(models, collections, and views) triggering events that other objects(typically views) listen to and act on.</p> <p>This section will mostly deal with View events and the semantics and methods ofresponding to events.</p> <p><strong>This section will not cover events from models and collections. See the<br><a href=\"marionette.view#model-and-collection-events\">documentation for View</a>.</strong></p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li>\n<a href=\"#triggering-and-listening-to-events\">Triggering and Listening to Events</a><ul> <li><a href=\"#view-triggermethod\">View <code>triggerMethod</code></a></li> <li>\n<a href=\"#listening-to-events\">Listening to Events</a><ul> <li><a href=\"#magic-method-binding\">Magic Method Binding</a></li> </ul> </li> <li><a href=\"#view-events-and-triggers\">View events and triggers</a></li> </ul> </li> <li>\n<a href=\"#child-view-events\">Child View Events</a><ul> <li><a href=\"#event-bubbling\">Event Bubbling</a></li> <li><a href=\"#explicit-event-listeners\">Explicit Event Listeners</a></li> <li><a href=\"#triggering-events-on-child-events\">Triggering Events on Child Events</a></li> </ul> </li> <li><a href=\"#lifecycle-events\">Lifecycle Events</a></li> </ul> <h2 id=\"triggering-and-listening-to-events\">\nTriggering and Listening to Events</h2>\n<p>The traditional <a href=\"http://backbonejs.org/#Events\">event handling system in Backbone</a>is also supported in Marionette. Marionette, however, provides an alternativeevent system using the <code>triggerMethod</code> method on <code>Marionette.Object</code> - the keydifference between the two is that <code>triggerMethod</code> triggers magically namedevent handlers on views. This section covers how <code>triggerMethod</code> works and howlisteners are set up to handle it.</p> <h3 id=\"view-triggermethod\">\nView <code>triggerMethod</code>\n</h3>\n<p>The <code>triggerMethod</code> method fires the named event on the view - any listenerswill then be triggered on the event. If there are no listeners, this call willstill succeed. All arguments after the first argument will be passed to allevent handlers.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  callMethod: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(myString)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(myString + <span class=\"hljs-string\">' was passed'</span>);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n<span class=\"hljs-comment\">/* See Backbone.listenTo */</span>\nmyView.on(<span class=\"hljs-string\">'something:happened'</span>, myView.callMethod, myView);\n\n<span class=\"hljs-comment\">/* Calls callMethod('foo'); */</span>\nmyView.triggerMethod(<span class=\"hljs-string\">'something:happened'</span>, <span class=\"hljs-string\">'foo'</span>);\n</pre> <p><strong>The <code>triggerMethod</code> call comes from the <code>trigger-method</code> mixin that is also<br>part of <code>Marionette.Object</code> and its subclasses like <code>Marionette.Application</code>.<br>This documentation also applies.</strong></p> <h3 id=\"listening-to-events\">\nListening to Events</h3>\n<p>Marionette's event triggers work just like regular Backbone events - you canuse <code>view.on</code> and <code>view.listenTo</code> to act on events:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.on(<span class=\"hljs-string\">'event:happened'</span>, <span class=\"hljs-keyword\">this</span>.logCall);\n  },\n\n  logCall: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(myVal)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(myVal);\n  }\n});\n</pre> <p>You can also use <code>listenTo</code> as in Backbone:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> OtherView = Mn.View.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(someView)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.listenTo(someView, <span class=\"hljs-string\">'event:happened'</span>, <span class=\"hljs-keyword\">this</span>.logCall);\n  },\n\n  logCall: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(myVal)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(myVal);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend();\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n\n<span class=\"hljs-keyword\">var</span> otherView = <span class=\"hljs-keyword\">new</span> OtherView(myView);\n</pre> <p>As in <a href=\"http://backbonejs.org/#Events\">Backbone</a>, <code>listenTo</code> will pass the objectit is called on in as the context variable. These behave exactly as in Backbone,so using <code>object.on</code> will require you to unhook any event handlers yourself toprevent memory leaks. Marionette, however, does provide extra helpers as part ofthe view lifecycle that bind and unbind event handlers for you. this is thecore of Magic Method Binding.</p> <h4>\nMagic Method Binding</h4>\n<p>The major difference between <code>Backbone.trigger</code> and <code>View.triggerMethod</code> isthat <code>triggerMethod</code> can fire specially named events on the attached view. Forinstance, a view that has been rendered will fire <code>view.triggerMethod('render')</code>and call <code>onRender</code> - providing a handy way to add behavior to your views.</p> <p>Determining what method an event will call is easy, we will outline this with anexample using <code>before:dom:refresh</code> though this also works with any custom eventsyou want to fire:</p> <ol> <li>Split the words around the <code>:</code> characters - so <code>before</code>, <code>dom</code>, <code>refresh</code>\n</li> <li>Capitalize the first letter of each word - <code>Before</code>, <code>Dom</code>, <code>Refresh</code>\n</li> <li>Add a leading <code>on</code> - <code>on</code>, <code>Before</code>, <code>Dom</code>, <code>Refresh</code>\n</li> <li>Mash it into a single call - <code>onBeforeDomRefresh</code>\n</li> </ol> <p>Using this process, <code>before:dom:refresh</code> will call the <code>onBeforeDomRefresh</code>method. Let's see it in action with a custom event:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  onMyEvent: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(myVal)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(myVal);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n\nmyView.triggerMethod(<span class=\"hljs-string\">'my:event'</span>, <span class=\"hljs-string\">'someValue'</span>); <span class=\"hljs-comment\">// Logs 'someValue'</span>\n</pre> <p>As before, all arguments passed into <code>triggerMethod</code> will make their way intothe event handler. Using this method ensures there will be no unexpectedmemory leaks.</p> <h3 id=\"view-events-and-triggers\">\nView events and triggers</h3>\n<p>Views can automatically bind DOM events to methods and View events with <code>events</code>and <code>triggers</code> respectively:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  events: {\n    <span class=\"hljs-string\">'click a'</span>: <span class=\"hljs-string\">'showModal'</span>\n  },\n\n  triggers: {\n    <span class=\"hljs-string\">'keyup input'</span>: <span class=\"hljs-string\">'data:entered'</span>\n  },\n\n  showModal: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(event)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Show the modal'</span>);\n  },\n\n  onDataEntered: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Data was entered'</span>);\n  }\n});\n</pre> <p>For more information, see the <a href=\"marionette.view#binding-to-user-input\">view documentation</a>.</p> <h2 id=\"child-view-events\">\nChild View Events</h2>\n<p>The <a href=\"marionette.view\"><code>View</code></a> and <a href=\"marionette.collectionview\"><code>CollectionView</code></a>are able to monitor and act on events on any children they own. Any events firedon a view are automatically propagated to their direct parents as well. Let'ssee a quick example:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> Item = Mn.View.extend({\n  tagName: <span class=\"hljs-string\">'li'</span>,\n\n  triggers: {\n    <span class=\"hljs-string\">'click a'</span>: <span class=\"hljs-string\">'select:item'</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> Collection = Mn.CollectionView.extend({\n  tagName: <span class=\"hljs-string\">'ul'</span>,\n\n  childViewEvents: {\n    <span class=\"hljs-string\">'select:item'</span>: <span class=\"hljs-string\">'itemSelected'</span>\n  },\n\n  itemSelected: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'item selected: '</span> + childView.model.id);\n  }\n});\n</pre> <h3 id=\"event-bubbling\">\nEvent Bubbling</h3>\n<p>Events fired on a view bubble up to their direct parent views, calling anymagic methods using the <code>childview:</code> prefix (more on that shortly) and anymethods bound to the <code>childViewEvents</code> attribute. This works for built-inevents, custom events fired with <code>triggerMethod</code> and bound events using<code>triggers</code>.</p> <p>When using implicit listeners, the <code>childview:*</code> event prefix is used whichneeds to be included as part of the handler:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  triggers: {\n    click: <span class=\"hljs-string\">'click:view'</span>\n  },\n\n  doSomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.triggerMethod(<span class=\"hljs-string\">'did:something'</span>);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> ParentView = Mn.View.extend({\n  regions: {\n    foo: <span class=\"hljs-string\">'.foo-hook'</span>\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-keyword\">new</span> MyView());\n  },\n\n  onChildviewClickView: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'View clicked '</span> + childView);\n  },\n\n  onChildviewDidSomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Something was done to '</span> + childView);\n  }\n})\n</pre> <p>The <code>view</code> gets passed into the handlers as the first argument.</p> <h4>\nUsing <code>CollectionView</code>\n</h4>\n<p>This works exactly the same way for the <code>CollectionView</code> and its <code>childView</code>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyChild = Mn.View.extend({\n  triggers: {\n    click: <span class=\"hljs-string\">'click:child'</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> MyList = Mn.CollectionView.extend({\n  onChildviewClickChild: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Childview '</span> + childView + <span class=\"hljs-string\">' was clicked'</span>);\n  }\n});\n</pre> <p>Just like with the <code>View</code> and its regions, the event handler will receive the<code>view</code> that triggered the event as its first argument.</p> <h3 id=\"explicit-event-listeners\">\nExplicit Event Listeners</h3>\n<p>To call specific functions on event triggers, use the <code>childViewEvents</code>attribute to map child events to methods on the parent view. This takes eventsfired on child views - <em>without the <code>childview:</code> prefix</em> - and calls themethod referenced or attached function.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  triggers: {\n    click: <span class=\"hljs-string\">'view:clicked'</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> ParentView = Mn.View.extend({\n  regions: {\n    foo: <span class=\"hljs-string\">'.foo-hook'</span>\n  },\n\n  childViewEvents: {\n    <span class=\"hljs-string\">'view:clicked'</span>: <span class=\"hljs-string\">'displayMessage'</span>\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-keyword\">new</span> MyView());\n  },\n\n  displayMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Displaying message for '</span> + childView);\n  }\n});\n</pre> <h4>\nAttaching Functions</h4>\n<p>The <code>childViewEvents</code> attribute can also attach functions directly to be eventhandlers:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  triggers: {\n    click: <span class=\"hljs-string\">'view:clicked'</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> ParentView = Mn.View.extend({\n  regions: {\n    foo: <span class=\"hljs-string\">'.foo-hook'</span>\n  },\n\n  childViewEvents: {\n    <span class=\"hljs-string\">'view:clicked'</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span> </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Function called for '</span> + childView);\n    }\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-keyword\">new</span> MyView());\n  }\n});\n</pre> <h3 id=\"triggering-events-on-child-events\">\nTriggering Events on Child Events</h3>\n<p>Marionette 3 adds a new feature that allows selected events to fire eventsdirectly, allowing them to be propagated up the view hierarchy more easily andexplicitly. The values of the hash should be a string of the event to trigger onthe parent.</p> <pre data-language=\"javascript\"><span class=\"hljs-comment\">// The child view fires a custom event, `show:message`</span>\n<span class=\"hljs-keyword\">var</span> ChildView = Marionette.View.extend({\n\n  <span class=\"hljs-comment\">// Events hash defines local event handlers that in turn may call `triggerMethod`.</span>\n  events: {\n    <span class=\"hljs-string\">'click .button'</span>: <span class=\"hljs-string\">'onClickButton'</span>\n  },\n\n  triggers: {\n    <span class=\"hljs-string\">'submit form'</span>: <span class=\"hljs-string\">'submit:form'</span>\n  },\n\n  onClickButton: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// Both `trigger` and `triggerMethod` events will be caught by parent.</span>\n    <span class=\"hljs-keyword\">this</span>.trigger(<span class=\"hljs-string\">'show:message'</span>, <span class=\"hljs-string\">'foo'</span>);\n    <span class=\"hljs-keyword\">this</span>.triggerMethod(<span class=\"hljs-string\">'show:message'</span>, <span class=\"hljs-string\">'bar'</span>);\n  }\n});\n\n<span class=\"hljs-comment\">// The parent uses childViewEvents to catch the child view's custom event</span>\n<span class=\"hljs-keyword\">var</span> ParentView = Marionette.CollectionView.extend({\n  childView: ChildView,\n\n  childViewTriggers: {\n    <span class=\"hljs-string\">'show:message'</span>: <span class=\"hljs-string\">'child:show:message'</span>,\n    <span class=\"hljs-string\">'submit:form'</span>: <span class=\"hljs-string\">'child:submit:form'</span>\n  },\n\n  onChildShowMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(message)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view fired show:message with '</span> + message);\n  },\n\n  onChildSubmitForm: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(childView)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view fired submit:form'</span>);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> GrantParentView = Marionette.View.extend({\n  regions: {\n    list: <span class=\"hljs-string\">'.list'</span>\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'list'</span>, <span class=\"hljs-keyword\">new</span> ParentView({\n      collection: <span class=\"hljs-keyword\">this</span>.collection\n    }));\n  },\n\n  childViewEvents: {\n    <span class=\"hljs-string\">'child:submit:message'</span>: <span class=\"hljs-string\">'showMessage'</span>\n  },\n\n  showMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child ('</span> + childView + <span class=\"hljs-string\">') fired an event'</span>);\n  }\n});\n</pre> <h2 id=\"lifecycle-events\">\nLifecycle Events</h2>\n<p>Marionette Views fire events during their creation and destruction lifecycle.For more information see <a href=\"marionette.view#lifecycle-events\"><code>View</code> Lifecycle</a>and <a href=\"marionette.collectionview#collectionview-events-and-callbacks\"><code>CollectionView</code> Lifecycle</a> events.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/events.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/events.html</a>\n  </p>\n</div>\n","marionette.view":"<h1>\nMarionette.View</h1>\n<p>A <code>View</code> is a view that represents an item to be displayed with a template.This is typically a <code>Backbone.Model</code>, <code>Backbone.Collection</code>, or nothing at all.</p> <p>Views are also used to build up your application hierarchy - you can easily nestmultiple views through the <code>regions</code> attribute.</p> <p><strong><em>Note: From Marionette v3.x, <code>Marionette.View</code> replaces<br><code>Marionette.LayoutView</code> and <code>Marionette.ItemView</code>.</em></strong></p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#rendering-a-template\">Rendering a Template</a></li> <li><a href=\"#managing-an-existing-page\">Managing an Existing Page</a></li> <li>\n<a href=\"#laying-out-views-regions\">Laying out Views - Regions</a><ul> <li>\n<a href=\"#class-definition\">Class Definition</a><ul> <li><a href=\"#specifying-regions-as-function\">Specifying 'regions' as function</a></li> <li><a href=\"#regions-on-view-instantiation\">Regions on View Instantiation</a></li> </ul> </li> <li>\n<a href=\"#managing-sub-views\">Managing Sub-views</a><ul> <li><a href=\"#showing-a-view\">Showing a view</a></li> <li><a href=\"#accessing-a-child-view\">Accessing a child view</a></li> </ul> </li> </ul> </li> <li><a href=\"#organizing-your-view\">Organizing your View</a></li> <li>\n<a href=\"#events\">Events</a><ul> <li><a href=\"#onevent-listeners\">onEvent Listeners</a></li> <li>\n<a href=\"#lifecycle-events\">Lifecycle Events</a><ul> <li><a href=\"#view-creation-lifecycle\">View Creation Lifecycle</a></li> <li><a href=\"#view-destruction-lifecycle\">View Destruction Lifecycle</a></li> <li><a href=\"#view-creation-events\">View Creation Events</a></li> <li><a href=\"#view-destruction-events\">View Destruction Events</a></li> <li><a href=\"#other-view-events\">Other View Events</a></li> </ul> </li> <li>\n<a href=\"#binding-custom-events\">Binding To User Input</a><ul> <li><a href=\"#view-events\">View <code>events</code></a></li> <li><a href=\"#view-triggers\">View <code>triggers</code></a></li> </ul> </li> </ul> </li> <li>\n<a href=\"#model-and-collection-events\">Model and Collection Events</a><ul> <li><a href=\"#model-events\">Model Events</a></li> <li><a href=\"#collection-events\">Collection Events</a></li> </ul> </li> <li><a href=\"#advanced-view-topics\">Advanced View Topics</a></li> </ul> <h2 id=\"rendering-a-template\">\nRendering a Template</h2>\n<p>The Marionette View implements a powerful render method which, given a template,will build your HTML from that template, mixing in model information and anyextra template context.</p> <p><strong>Overriding <code>render</code></strong> If you want to add extra behavior to your view's render,you would be best off doing your logic in the<a href=\"#lifecycle-events\"><code>onBeforeRender</code> or <code>onRender</code> handlers</a>.</p> <p>To render a template, set the <code>template</code> attribute on your view:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> _ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'underscore'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  tagName: <span class=\"hljs-string\">'h1'</span>,\n  template: _.template(<span class=\"hljs-string\">'Contents'</span>)\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\nmyView.render();\n</pre> <p>For more detail on how to render templates, see the<a href=\"template\">Template documentation</a>.</p> <h2 id=\"managing-an-existing-page\">\nManaging an Existing Page</h2>\n<p>Marionette is able to manage pre-generated pages - either static orserver-generated - and treat them as though they were generated from Marionette.</p> <p>To use the existing page, set the <code>template</code> attribute to <code>false</code>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View({\n  el: <span class=\"hljs-string\">'#base-element'</span>,\n  template: <span class=\"hljs-literal\">false</span>\n});\n</pre> <p>Marionette will then attach all the usual<a href=\"#events-and-callback-methods\"><code>event</code></a> and <a href=\"#organizing-your-view\"><code>ui</code></a>handlers to the view using the existing HTML. Though the View has no template,you can still listen to the <code>before:render</code> and <code>render</code> events that will fireas usual when <code>render</code> is called - or when you execute <code>region.show(view)</code>.</p> <h3 id=\"setting-a-falsy-template-value\">\nSetting a falsy <code>template</code> value</h3>\n<p>When using an existing page, Marionette explicitly looks for <code>false</code> - any otherfalsy value will cause Marionette to raise an error when attempting to renderthe template.</p> <h2 id=\"laying-out-views-regions\">\nLaying out Views - Regions</h2>\n<p>The <code>Marionette.View</code> class lets us manage a hierarchy of views using <code>regions</code>.Regions are a hook point that lets us show views inside views, manage theshow/hide lifecycles, and act on events inside the children.</p> <p><strong>This Section only covers the basics. For more information on regions, see the<br><a href=\"marionette.region\">Regions Documentation.</a></strong></p> <p>Regions are ideal for rendering application layouts by isolating concerns insideanother view. This is especially useful for independently re-rendering chunksof your application without having to completely re-draw the entire screen everytime some data is updated.</p> <p>Regions can be added to a View at class definition, with <code>regions</code>, or atruntime using <code>addRegion</code>.</p> <p>When you extend <code>View</code>, we use the <code>regions</code> attribute to point to the selectorwhere the new view will be displayed:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n    template: <span class=\"hljs-string\">'#tpl-view-with-regions'</span>,\n\n    regions: {\n        firstRegion: <span class=\"hljs-string\">'#first-region'</span>,\n        secondRegion: <span class=\"hljs-string\">'#second-region'</span>\n    }\n});\n</pre> <p>If we have the following template:</p> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"x-template/underscore\"</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"tpl-view-with-regions\"</span>&gt;</span><span class=\"javascript\">\n  &lt;div id=<span class=\"hljs-string\">\"first-region\"</span>&gt;<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"second-region\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"third-region\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">div</span>&gt;</span>\n</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</pre> <p>When we show views in the region, the contents of <code>#first-region</code> and<code>#second-region</code> will be replaced with the contents of the view we show. Thevalue in the <code>regions</code> hash is just a jQuery selector, and any valid jQuerysyntax will suffice.</p> <h3 id=\"managing-sub-views\">\nManaging Sub-views</h3>\n<p><code>View</code> provides a simple interface for managing sub-views with <code>showChildView</code>and <code>getChildView</code>:</p> <h4>\nShowing a view</h4>\n<p>To show a view inside a region, simply call <code>showChildView(region, view)</code>. Thiswill handle rendering the view's HTML and attaching it to the DOM for you:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> SubView = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./subview'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: <span class=\"hljs-string\">'#tpl-view-with-regions'</span>,\n\n  regions: {\n    firstRegion: <span class=\"hljs-string\">'#first-region'</span>\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'firstRegion'</span>, <span class=\"hljs-keyword\">new</span> SubView());\n  }\n});\n</pre> <h4>\nAccessing a child view</h4>\n<p>To access the child view of a <code>View</code> - use the <code>getChildView(region)</code> method.This will return the view instance that is current being displayed at thatregion, or <code>null</code>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> SubView = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./subview'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: <span class=\"hljs-string\">'#tpl-view-with-regions'</span>,\n\n  regions: {\n    firstRegion: <span class=\"hljs-string\">'#first-region'</span>\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'firstRegion'</span>, <span class=\"hljs-keyword\">new</span> SubView());\n  },\n\n  onSomeEvent: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">var</span> first = <span class=\"hljs-keyword\">this</span>.getChildView(<span class=\"hljs-string\">'firstRegion'</span>);\n    first.doSomething();\n  }\n});\n</pre> <p>If no view is available, <code>getChildView</code> returns <code>null</code>.</p> <h3 id=\"region-availability\">\nRegion availability</h3>\n<p>Any defined regions within a <code>View</code> will be available to the <code>View</code> or anycalling code immediately after instantiating the <code>View</code>. This allows a View tobe attached to an existing DOM element in an HTML page, without the need to calla render method or anything else, to create the regions.</p> <p>However, a region will only be able to populate itself if the <code>View</code> has accessto the elements specified within the region definitions. That is, if your viewhas not yet rendered, your regions may not be able to find the element thatyou've specified for them to manage. In that scenario, using the region willresult in no changes to the DOM.</p> <h3 id=\"efficient-nested-view-structures\">\nEfficient nested view structures</h3>\n<p>When your views get some more regions, you may want to think of the mostefficient way to render your views. Since manipulating the DOM is performanceheavy, it's best practice to render most of your views at once.</p> <p>Marionette provides a simple mechanism to infinitely nest views in a singlepaint: just render all of the children in the onRender callback.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> ParentView = Mn.View.extend({\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'header'</span>, <span class=\"hljs-keyword\">new</span> HeaderView());\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'footer'</span>, <span class=\"hljs-keyword\">new</span> FooterView());\n  }\n});\n\nmyRegion.show(<span class=\"hljs-keyword\">new</span> ParentView(), options);\n</pre> <p>In this example, the doubly-nested view structure will be rendered in a singlepaint.</p> <p>This system is recursive, so it works for any deeply nested structure. The childviews you show can render their own child views within their onRender callbacks!</p> <h3 id=\"listening-to-events-on-children\">\nListening to events on children</h3>\n<p>Using regions lets you listen to the events that fire on child views - viewsattached inside a region. This lets a parent view take action depending on whatis happening in views it directly owns.</p> <p><strong>To see more information about events, see the <a href=\"#events\">events</a> section</strong></p> <h4>\nDefining <code>childViewEvents</code>\n</h4>\n<p>The <code>childViewEvents</code> hash defines the events to listen to on a view's childrenmapped to the method to call. The method will receive a <code>child</code> objectreferencing the view that triggered the event.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  regions: {\n    product: <span class=\"hljs-string\">'.product-hook'</span>\n  },\n\n  childViewEvents: {\n    <span class=\"hljs-string\">'add:item'</span>: <span class=\"hljs-string\">'updateBasketValue'</span>\n  },\n\n  <span class=\"hljs-comment\">/** Assume item is the model belonging to the child */</span>\n  updateBasketValue: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(child, item)</span> </span>{\n    <span class=\"hljs-keyword\">var</span> initialValue = <span class=\"hljs-keyword\">this</span>.model.get(<span class=\"hljs-string\">'value'</span>);\n    <span class=\"hljs-keyword\">this</span>.model.set({\n      value: item.get(<span class=\"hljs-string\">'value'</span>) * item.get(<span class=\"hljs-string\">'quantity'</span>)\n    });\n  }\n});\n</pre> <p>You can also directly define a function to call in <code>childViewEvents</code> like so:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  regions: {\n    product: <span class=\"hljs-string\">'.product-hook'</span>\n  },\n\n  childViewEvents: {\n    <span class=\"hljs-string\">'add:item'</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(child, item)</span> </span>{\n      <span class=\"hljs-keyword\">var</span> initialValue = <span class=\"hljs-keyword\">this</span>.model.get(<span class=\"hljs-string\">'value'</span>);\n      <span class=\"hljs-keyword\">this</span>.model.set({\n        value: item.get(<span class=\"hljs-string\">'value'</span>) * item.get(<span class=\"hljs-string\">'quantity'</span>)\n      });\n    }\n  }\n});\n</pre> <h2 id=\"organizing-your-view\">\nOrganizing your View</h2>\n<p>The <code>View</code> provides a mechanism to name parts of your template to be usedthroughout the view with the <code>ui</code> attribute. This provides a number of benefits:</p> <ol> <li>Provide a reference to commonly used UI elements</li> <li>Cache the jQuery selector</li> <li>Change the selector later in only one place in your view</li> </ol> <h3 id=\"defining-ui\">\nDefining <code>ui</code>\n</h3>\n<p>To define your <code>ui</code> hash, just set an object of key to jQuery selectors to the<code>ui</code> attribute of your View:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: <span class=\"hljs-string\">'#my-template'</span>,\n  ui: {\n    save: <span class=\"hljs-string\">'#save-button'</span>,\n    close: <span class=\"hljs-string\">'.close-button'</span>\n  }\n});\n</pre> <p>Inside your view, the <code>save</code> and <code>close</code> references will point to the jQueryselectors <code>#save-button</code> and <code>.close-button</code> respectively.</p> <h3 id=\"accessing-ui-elements\">\nAccessing UI elements</h3>\n<p>To get the handles to your UI elements, use the <code>getUI(ui)</code> method:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: <span class=\"hljs-string\">'#my-template'</span>,\n  ui: {\n    save: <span class=\"hljs-string\">'#save-button'</span>,\n    close: <span class=\"hljs-string\">'.close-button'</span>\n  },\n\n  onDoSomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">var</span> saveButton = <span class=\"hljs-keyword\">this</span>.getUI(<span class=\"hljs-string\">'save'</span>);\n    saveButton.addClass(<span class=\"hljs-string\">'disabled'</span>);\n    saveButton.attr(<span class=\"hljs-string\">'disabled'</span>, <span class=\"hljs-string\">'disabled'</span>);\n  }\n});\n</pre> <p>As <code>saveButton</code> here is a jQuery selector, you can call any jQuery methods onit, according to the jQuery documentation.</p> <h4>\nReferencing UI in events</h4>\n<p>The UI attribute is especially useful when setting handlers in the<a href=\"#view-events\"><code>events</code></a> and <a href=\"#view-triggers\"><code>triggers</code></a> objects - simply usethe <code>@ui.</code> prefix:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: <span class=\"hljs-string\">'#my-template'</span>,\n  ui: {\n    save: <span class=\"hljs-string\">'#save-button'</span>,\n    close: <span class=\"hljs-string\">'.close-button'</span>\n  },\n\n  events: {\n    <span class=\"hljs-string\">'click @ui.save'</span>: <span class=\"hljs-string\">'handleSave'</span>\n  },\n\n  triggers: {\n    <span class=\"hljs-string\">'click @ui.close'</span>: <span class=\"hljs-string\">'close:view'</span>\n  },\n\n  handleSave: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.model.save();\n  }\n});\n</pre> <p>In this example, when the user clicks on <code>#save-button</code>, <code>handleSave</code> will becalled. If the user clicks on <code>.close-button</code>, then the event <code>close:view</code> willbe fired on <code>MyView</code>.</p> <p>By prefixing with <code>@ui</code>, we can change the underlying template without having tohunt through our view for every place where that selector is referenced - justupdate the <code>ui</code> object.</p> <h2 id=\"events\">\nEvents</h2>\n<p>Firing events on views allows you to communicate that something has happenedon that view and allowing it to decide whether to act on it or not.</p> <p>During the create/destroy lifecycle for a <code>View</code>, Marionette will call a numberof events on the view being created and attached. You can listen to these eventsand act on them in two ways:</p> <ol> <li>The typical Backbone manner: <code>view.on('render', function() {})</code>\n</li> <li>Overriding the onEvent listener methods: <code>onRender: function() {}</code>\n</li> </ol> <h3 id=\"onevent-listeners\">\nonEvent Listeners</h3>\n<p>Marionette creates onEvent listeners for all events fired using<code>view.triggerMethod('event')</code> - if there is an <code>onEvent</code> method, Marionette willcall it for you. An example:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Fired whenever view.triggerMethod('render') is called.\"</span>);\n  },\n\n  onOtherEvent: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(argument)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Fired other:event with '\"</span> + argument + <span class=\"hljs-string\">\"' as an argument\"</span>);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> MyView();\n\nview.triggerMethod(<span class=\"hljs-string\">'other:event'</span>, <span class=\"hljs-string\">'test argument'</span>);\n</pre> <p>This will display in the console:<code>Fired other:event with 'test argument' as an argument</code></p> <p>To set up handlers for events, see the rules in the<a href=\"events#magic-method-binding\">Documentation for Events</a>.</p> <h3 id=\"lifecycle-events\">\nLifecycle Events</h3>\n<p>Marionette views defined a number of events during the creation and destructionlifecycle - when the view is displayed in and emptied from a region. In thedocumentation, we will reference the event name, though <code>onEvent</code> handling canbe used.</p> <h4>\nView Creation Lifecycle</h4>\n<p>When a view is initialized and then displayed inside a region (using<code>showChildView()</code>) a set of events will be called in a specific order.</p> <table> <thead> <tr> <th style=\"text-align:center\">Order</th> <th>Event</th> </tr> </thead> <tbody> <tr> <td style=\"text-align:center\">1</td> <td><code>before:render</code></td> </tr> <tr> <td style=\"text-align:center\">2</td> <td><code>render</code></td> </tr> <tr> <td style=\"text-align:center\">3</td> <td><code>before:attach</code></td> </tr> <tr> <td style=\"text-align:center\">4</td> <td><code>attach</code></td> </tr> <tr> <td style=\"text-align:center\">5</td> <td><code>dom:refresh</code></td> </tr> </tbody> </table> <h4>\nView Destruction Lifecycle</h4>\n<p>When <code>region.empty()</code> is called, the view will be destroyed, calling events aspart of the destruction lifecycle.</p> <table> <thead> <tr> <th style=\"text-align:center\">Order</th> <th>Event</th> </tr> </thead> <tbody> <tr> <td style=\"text-align:center\">1</td> <td><code>before:destroy</code></td> </tr> <tr> <td style=\"text-align:center\">2</td> <td><code>before:detach</code></td> </tr> <tr> <td style=\"text-align:center\">3</td> <td><code>detach</code></td> </tr> <tr> <td style=\"text-align:center\">4</td> <td><code>destroy</code></td> </tr> </tbody> </table> <h4>\nView Creation Events</h4>\n<p>These events are fired during the view's creation and rendering in a region.</p> <h5>\nView <code>before:render</code>\n</h5>\n<p>Triggered before a View is rendered.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.View.extend({\n  onBeforeRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// set up final bits just before rendering the view's `el`</span>\n  }\n});\n</pre> <h5>\nView <code>render</code>\n</h5>\n<p>Triggered after the view has been rendered.You can implement this in your view to provide custom code for dealingwith the view's <code>el</code> after it has been rendered.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.View.extend({\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'el exists but is not visible in the DOM'</span>);\n  }\n});\n</pre> <h5>\nView <code>before:attach</code>\n</h5>\n<p>Triggered after the View has been rendered but just before it is first boundinto the page DOM. This will only be triggered once per <code>region.show()</code> - ifyou want something that will be triggered every time the DOM changes,you may want <code>render</code> or <code>before:render</code>.</p> <h5>\nView <code>attach</code>\n</h5>\n<p>Triggered once the View has been bound into the DOM. This is only triggeredonce - the first time the View is attached to the DOM. If you want an event thattriggers every time the DOM changes visibly, you may want <code>dom:refresh</code></p> <h5>\nView <code>dom:refresh</code>\n</h5>\n<p>Triggered after the first <code>attach</code> event fires <em>and</em> every time the visible DOMchanges.</p> <p><strong>Note for upgrading from Marionette 2</strong> If you were using the <code>show</code> event -the <code>dom:refresh</code> event may be a better event than <code>attach</code> when you want to besure something will run once your <code>el</code> has been attached to the DOM and updates.</p> <h4>\nView Destruction Events</h4>\n<p>These events are fired during the view's destruction and removal from a region.</p> <h5>\nView <code>before:destroy</code>\n</h5>\n<p>Triggered just prior to destroying the view, when the view's <code>destroy()</code> method has been called.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.View.extend({\n  onBeforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// manipulate the `el` here. it's already</span>\n    <span class=\"hljs-comment\">// been rendered, and is full of the view's</span>\n    <span class=\"hljs-comment\">// HTML, ready to go.</span>\n  }\n});\n</pre> <h5>\nView <code>before:detach</code>\n</h5>\n<p>The <code>View</code> will trigger the \"before:detach\" event when the view is rendered andis about to be removed from the DOM.If the view has not been rendered before, this event will not be fired.</p> <h5>\nView <code>detach</code>\n</h5>\n<p>The <code>View</code> will trigger the \"detach\" event when the view was rendered and hasjust been destroyed.</p> <h5>\nView <code>destroy</code>\n</h5>\n<p>Triggered just after the view has been destroyed. At this point, the view hasbeen completely removed from the DOM.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.View.extend({\n  onDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// custom destroying and cleanup goes here</span>\n  }\n});\n</pre> <h4>\nOther View Events</h4>\n<p>These events are fired on specific actions performed on the view.</p> <h5>\nView <code>before:add:region</code>\n</h5>\n<p>When you add a region to a view - through <code>addRegion()</code> - the<code>before:add:region</code> event will fire just before the region is actually added.</p> <h5>\nView <code>add:region</code>\n</h5>\n<p>When a region is added to a view - through <code>addRegion()</code> - the <code>add:region</code>event will be fired. This happens just after the region is added and isavailable to use on the view.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  onAddRegion: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name, region)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Region called '</span> + name + <span class=\"hljs-string\">' was added'</span>);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\nmyView.addRegion(<span class=\"hljs-string\">'regionName'</span>, <span class=\"hljs-string\">'#selector'</span>);\n</pre> <h5>\nView <code>before:remove:region</code>\n</h5>\n<p>The <code>View</code> will trigger a \"before:remove:region\"event before a region is removed from the view.This allows you to perform any cleanup operations before the region is removed.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  onBeforeRemoveRegion: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Region called '</span> + name + <span class=\"hljs-string\">' is about to be removed'</span>);\n  },\n\n  regions: {\n    regionName: <span class=\"hljs-string\">'#selector'</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\nmyView.removeRegion(<span class=\"hljs-string\">\"foo\"</span>);\n</pre> <h5>\nView <code>remove:region</code>\n</h5>\n<p>The <code>View</code> will trigger a \"remove:region\"event when a region is removed from the view.This allows you to use the region instance one lasttime, or remove the region from an object that has areference to it:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> Mn.View();\n\nview.on(<span class=\"hljs-string\">\"remove:region\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name, region)</span> </span>{\n  <span class=\"hljs-comment\">// add the region instance to an object</span>\n  <span class=\"hljs-keyword\">delete</span> myObject[name];\n});\n\nview.addRegion(<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"#bar\"</span>);\n\nview.removeRegion(<span class=\"hljs-string\">\"foo\"</span>);\n</pre> <h3 id=\"binding-to-user-input\">\nBinding To User Input</h3>\n<p>Views can bind custom events whenever users perform some interaction with theDOM. Using the view <code>events</code> and <code>triggers</code> handlers lets us either bind userinput directly to an action or fire a generic trigger that may or may not behandled.</p> <h4>\nView <code>events</code>\n</h4>\n<p>The view <code>events</code> attribute binds DOM events to functions or methods on theview. The simplest form is to reference a method on the view:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  events: {\n    <span class=\"hljs-string\">'click a'</span>: <span class=\"hljs-string\">'showModal'</span>\n  },\n\n  showModal: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(event)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Show the modal'</span>);\n  }\n});\n</pre> <p>The DOM event gets passed in as the first argument, allowing you to see anyinformation passed as part of the event.</p> <p><strong>When passing a method reference, the method must exist on the View.</strong></p> <h5>\nDefining Listeners</h5>\n<p>Listeners are defined as:</p> <pre data-language=\"javascript\">eventname jqueryselector\n</pre> <ul> <li>The <code>eventname</code> part refers to a jQuery DOM event e.g. <code>click</code> or <code>change</code>.</li> <li>The <code>jqueryselector</code> part is a jQuery selector string e.g. <code>.myclass</code>\n</li> </ul> <p>You can also pass just the eventname part causing the event handler to fire onthe entire view. This is especially useful for buttons and click handlers:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> ButtonView = Mn.View.extend({\n  tagName: <span class=\"hljs-string\">'button'</span>,\n\n  events: {\n    click: <span class=\"hljs-string\">'showAlert'</span>\n  },\n\n  showAlert: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    alert(<span class=\"hljs-string\">'Button was clicked'</span>);\n  }\n});\n</pre> <h5>\nPassing a Function</h5>\n<p>The <code>events</code> attribute can also directly bind functions:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  events: {\n    <span class=\"hljs-string\">'click a'</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(event)</span> </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Show the modal'</span>);\n    }\n  }\n});\n</pre> <p>As when passing a string reference to a view method, the <code>events</code> attributepasses in the <code>event</code> as the argument to the function called.</p> <h4>\nView <code>triggers</code>\n</h4>\n<p>The view <code>triggers</code> attribute binds DOM events to Marionette View events thatcan be responded to at the view or parent level. For more information on events,see the <a href=\"events\">events documentation</a>. This section will justcover how to bind these events to views.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  triggers: {\n    <span class=\"hljs-string\">'click a'</span>: <span class=\"hljs-string\">'link:clicked'</span>\n  },\n\n  onLinkClicked: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Show the modal'</span>);\n  }\n});\n</pre> <p>When the <code>a</code> tag is clicked here, the <code>link:click</code> event is fired. This eventcan be listened to using the<a href=\"events#magic-method-binding\">Magic Method Binding</a> techniquediscussed in the <a href=\"events\">events documentation</a>.</p> <h5>\nDefining Listeners</h5>\n<p>Listeners are defined as:</p> <pre data-language=\"javascript\">eventname jqueryselector\n</pre> <ul> <li>The <code>eventname</code> part refers to a jQuery DOM event e.g. <code>click</code> or <code>change</code>.</li> <li>The <code>jqueryselector</code> part is a jQuery selector string e.g. <code>.myclass</code>\n</li> </ul> <p>You can also pass just the eventname part causing the event handler to fire onthe entire view. This is especially useful for buttons and click handlers:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> ButtonView = Mn.View.extend({\n  tagName: <span class=\"hljs-string\">'button'</span>,\n\n  events: {\n    click: <span class=\"hljs-string\">'entire:view:clicked'</span>\n  },\n\n  onEntireViewClicked: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    alert(<span class=\"hljs-string\">'Button was clicked'</span>);\n  }\n});\n</pre> <h5>\nEvent Bubbling</h5>\n<p>The major benefit of the <code>triggers</code> attribute over <code>events</code> is that triggeredevents can bubble up to any parent views. For a full explanation of bubblingevents and listening to child events, see the<a href=\"marionette.events#child-view-events\">event bubbling documentation</a>.</p> <h2 id=\"model-and-collection-events\">\nModel and Collection events</h2>\n<p>The Marionette View can bind to events that occur on attached models andcollections - this includes both [standard][backbone-events] and custom events.</p> <h3 id=\"model-events\">\nModel Events</h3>\n<p>For example, to listen to a model's events:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  modelEvents: {\n    <span class=\"hljs-string\">'change:attribute'</span>: <span class=\"hljs-string\">'actOnChange'</span>\n  },\n\n  actOnChange: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(value, model)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'New value: '</span> + value);\n  }\n});\n</pre> <p>The <code>modelEvents</code> attribute passes through all the arguments that are passedto <code>model.trigger('event', arguments)</code>.</p> <p>The <code>modelEvents</code> attribute can also take a<a href=\"basics#functions-returning-values\">function returning an object</a>.</p> <h4>\nFunction callback</h4>\n<p>You can also bind a function callback directly in the <code>modelEvents</code> attribute:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  modelEvents: {\n    <span class=\"hljs-string\">'change:attribute'</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'attribute was changed'</span>);\n    }\n  }\n})\n</pre> <h3 id=\"collection-events\">\nCollection Events</h3>\n<p>Collection events work exactly the same way as <a href=\"#model-events\"><code>modelEvents</code></a>with their own <code>collectionEvents</code> key:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  collectionEvents: {\n    sync: <span class=\"hljs-string\">'actOnSync'</span>\n  },\n\n  actOnSync: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(collection)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Collection was synchronised with the server'</span>);\n  }\n});\n</pre> <p>The <code>collectionEvents</code> attribute can also take a<a href=\"basics#functions-returning-values\">function returning an object</a>.</p> <p>Just as in <code>modelEvents</code>, you can bind function callbacks directly inside the<code>collectionEvents</code> object:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  collectionEvents: {\n    <span class=\"hljs-string\">'update'</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'the collection was updated'</span>);\n    }\n  }\n})\n</pre> <h3 id=\"listening-to-both\">\nListening to both</h3>\n<p>If your view has a <code>model</code> and <code>collection</code> attached, it will listen for eventson both:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  modelEvents: {\n    <span class=\"hljs-string\">'change:someattribute'</span>: <span class=\"hljs-string\">'changeMyAttribute'</span>\n  },\n\n  collectionEvents: {\n    update: <span class=\"hljs-string\">'modelsChanged'</span>\n  },\n\n  changeMyAttribute: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'someattribute was changed'</span>);\n  },\n\n  modelsChanged: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'models were added or removed in the collection'</span>);\n  }\n})\n</pre> <p>In this case, Marionette will bind event handlers to both.</p> <h2 id=\"advanced-view-topics\">\nAdvanced View Topics</h2>\n<p>This method is used to convert a View's <code>model</code> or <code>collection</code>into a usable form for a template.</p> <p>Item Views are called such because they process only a single itemat a time. Consequently, only the <code>model</code> <strong>or</strong> the <code>collection</code> willbe serialized. If both exist, only the <code>model</code> will be serialized.</p> <p>By default, models are serialized by cloning the attributes of the model.</p> <p>Collections are serialized into an object of this form:</p> <pre data-language=\"javascript\">{\n  items: [modelOne, modelTwo]\n}\n</pre> <p>where each model in the collection will have its attributes cloned.</p> <p>The result of <code>serializeData</code> is included in the data passed tothe view's template.</p> <p>Let's take a look at some examples of how serializing data works.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> myModel = <span class=\"hljs-keyword\">new</span> MyModel({foo: <span class=\"hljs-string\">\"bar\"</span>});\n\n<span class=\"hljs-keyword\">new</span> MyView({\n  template: <span class=\"hljs-string\">\"#myItemTemplate\"</span>,\n  model: myModel\n});\n\nMyView.render();\n</pre> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"myItemTemplate\"</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"template\"</span>&gt;</span><span class=\"javascript\">\n  Foo is: <span class=\"xml\"><span class=\"vbscript\">&lt;%= foo %&gt;</span>\n</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</pre> <p>If the serialization is a collection, the results are passed in as an<code>items</code> array:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> myCollection = <span class=\"hljs-keyword\">new</span> MyCollection([{foo: <span class=\"hljs-string\">\"bar\"</span>}, {foo: <span class=\"hljs-string\">\"baz\"</span>}]);\n\n<span class=\"hljs-keyword\">new</span> MyView({\n  template: <span class=\"hljs-string\">\"#myCollectionTemplate\"</span>,\n  collection: myCollection\n});\n\nMyView.render();\n</pre> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"myCollectionTemplate\"</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"template\"</span>&gt;</span><span class=\"javascript\">\n  &lt;% _.each(items, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(item)</span></span>{ %&gt;\n    Foo is: <span class=\"xml\"><span class=\"vbscript\">&lt;%= foo %&gt;</span>\n  <span class=\"vbscript\">&lt;% }); %&gt;</span>\n</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</pre> <p>If you need to serialize the View's <code>model</code> or <code>collection</code> in a custom way,then you should override either <code>serializeModel</code> or <code>serializeCollection</code>.</p> <p>On the other hand, you should not use this method to add arbitrary extra datato your template. Instead, use <a href=\"template#templatecontext\">View.templateContext</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.view.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.view.html</a>\n  </p>\n</div>\n","marionette.renderer":"<h1>\nMarionette.Renderer</h1>\n<p>The <code>Renderer</code> object was extracted from the <code>View</code> rendering process, in orderto create a consistent and re-usable method of rendering a template with orwithout data.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#basic-usage\">Basic Usage</a></li> <li><a href=\"#pre-compiled-templates\">Pre-compiled Templates</a></li> <li><a href=\"#custom-template-selection-and-rendering\">Custom Template Selection And Rendering</a></li> <li><a href=\"#using-pre-compiled-templates\">Using Pre-compiled Templates</a></li> </ul> <h2 id=\"basic-usage\">\nBasic Usage</h2>\n<p>The basic usage of the <code>Renderer</code> is to call the <code>render</code> method. This methodreturns a string containing the result of applying the template using the <code>data</code>object as the context.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> template = <span class=\"hljs-string\">'#some-template'</span>;\n<span class=\"hljs-keyword\">var</span> data = {foo: <span class=\"hljs-string\">'bar'</span>};\n<span class=\"hljs-keyword\">var</span> html = Mn.Renderer.render(template, data);\n\n<span class=\"hljs-comment\">// do something with the HTML here</span>\n</pre> <p>If you pass a <code>template</code> that coerces to a falsy value -<a href=\"marionette.view#managing-an-existing-page\">but not false</a> - the <code>render</code>method will throw an exception stating that there was no template provided.</p> <h2 id=\"pre-compiled-templates\">\nPre-compiled Templates</h2>\n<p>If the <code>template</code> parameter of the <code>render</code> function is itself a function,the renderer treats this as a pre-compiled template and does not try tocompile it again. This allows any view that supports a <code>template</code> parameterto specify a pre-compiled template function as the <code>template</code> setting.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> myTemplate = _.template(<span class=\"hljs-string\">'&lt;div&gt;foo&lt;/div&gt;'</span>);\n\nMn.View.extend({\n  template: myTemplate\n});\n</pre> <p>The template function does not have to be any specific template engine. Itonly needs to be a function that returns valid HTML as a string from the<code>data</code> parameter passed to the function.</p> <h2 id=\"custom-template-selection-and-rendering\">\nCustom Template Selection And Rendering</h2>\n<p>By default, the renderer will take a jQuery selector object as the firstparameter, and a JSON data object as the optional second parameter. It then usesthe <code>TemplateCache</code> to load the template by the specified selector, and rendersthe template with the data provided (if any) using underscore templates.</p> <p>If you wish to override the way the template is loaded, see the <code>TemplateCache</code>object.</p> <p>If you wish to override the template engine used, change the <code>render</code> method towork however you want:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.Renderer.render = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(template, data)</span></span>{\n  <span class=\"hljs-keyword\">return</span> $(template).tmpl(data);\n};\n</pre> <p>This implementation will replace the default underscore rendering with jQuerytemplates rendering.</p> <p>If you override the <code>render</code> method and wish to use the <code>TemplateCache</code>mechanism, remember to include the code necessary to fetch the template from thecache in your <code>render</code> method:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.Renderer.render = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(template, data)</span></span>{\n  <span class=\"hljs-keyword\">var</span> template = Mn.TemplateCache.get(template);\n  <span class=\"hljs-comment\">// Do something with the template here</span>\n};\n</pre> <p>See the <a href=\"marionette.templatecache\">Documentation for <code>TemplateCache</code></a> formore detailed information.</p> <h2 id=\"using-pre-compiled-templates\">\nUsing Pre-compiled Templates</h2>\n<p>You can easily replace the standard template rendering functionality with apre-compiled template, such as those provided by the JST or TPL plugins forAMD/RequireJS.</p> <p>To do this, just override the <code>render</code> method to return your executed templatewith the data.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.Renderer.render = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(template, data)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> template(data);\n};\n</pre> <p>Then you can specify the pre-compiled template function as your view's<code>template</code> attribute:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> myPrecompiledTemplate = _.template(<span class=\"hljs-string\">'&lt;div&gt;some template&lt;/div&gt;'</span>);\n\nMn.View.extend({\n  template: myPrecompiledTemplate\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/kzths849/\">Live example</a></p> <p>For more information on templates in general, see the<a href=\"template\">Documentation for templates</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.renderer.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.renderer.html</a>\n  </p>\n</div>\n","marionette.templatecache":"<h1>\nMarionette.TemplateCache</h1>\n<p>The <code>TemplateCache</code> provides a cache for retrieving templates from script blocksin your HTML. This improved the speed of subsequent calls to get a template.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li>\n<a href=\"#basic-usage\">Basic Usage</a><ul> <li><a href=\"#clear-all-templates-from-cache\">Clear All Templates from cache</a></li> <li><a href=\"#clear-specific-templates-from-cache\">Clear Specific Templates from Cache</a></li> </ul> </li> <li>\n<a href=\"#customizing-template-access\">Customizing Template Access</a><ul> <li><a href=\"#override-template-retrieval\">Override Template Retrieval</a></li> <li><a href=\"#override-template-compilation\">Override Template Compilation</a></li> </ul> </li> </ul> <h2 id=\"basic-usage\">\nBasic Usage</h2>\n<p>To use the <code>TemplateCache</code>, call the <code>get</code> method on TemplateCache directly.Internally, instances of the TemplateCache class will be created and storedbut you do not have to manually create these instances yourself. <code>get</code> willreturn a compiled template function.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> template = Mn.TemplateCache.get(<span class=\"hljs-string\">\"#my-template\"</span>, {option: <span class=\"hljs-string\">'value'</span>});\n<span class=\"hljs-comment\">// use the template</span>\ntemplate({param1:<span class=\"hljs-string\">'value1'</span>, paramN:<span class=\"hljs-string\">'valueN'</span>});\n</pre> <p>Making multiple calls to get the same template will retrieve the template fromthe cache on subsequence calls.</p> <h3 id=\"clear-all-templates-from-cache\">\nClear All Templates from Cache</h3>\n<p>You can clear one or more, or all items from the cache using the <code>clear</code> method.Clearing a template from the cache will force it to re-load from the DOM (viathe <code>loadTemplate</code> function which can be overridden, see below) the next time itis retrieved.</p> <p>If you do not specify any parameters, all items will be cleared from the cache:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.TemplateCache.get(<span class=\"hljs-string\">\"#my-template\"</span>);\nMn.TemplateCache.get(<span class=\"hljs-string\">\"#this-template\"</span>);\nMn.TemplateCache.get(<span class=\"hljs-string\">\"#that-template\"</span>);\n\n<span class=\"hljs-comment\">// clear all templates from the cache</span>\nMn.TemplateCache.clear()\n</pre> <h3 id=\"clear-specific-templates-from-cache\">\nClear Specific Templates from Cache</h3>\n<p>To clear only specific templates from the cache, specify the jQuery selectorthat was passed in <code>get</code> to your <code>clear</code> call:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-comment\">// Pre-load our cache</span>\nMn.TemplateCache.get(<span class=\"hljs-string\">\"#my-template\"</span>);\nMn.TemplateCache.get(<span class=\"hljs-string\">\"#this-template\"</span>);\nMn.TemplateCache.get(<span class=\"hljs-string\">\"#that-template\"</span>);\n\n<span class=\"hljs-comment\">// clear 2 of 3 templates from the cache</span>\nMn.TemplateCache.clear(<span class=\"hljs-string\">\"#my-template\"</span>, <span class=\"hljs-string\">\"#this-template\"</span>)\n</pre> <h2 id=\"customizing-template-access\">\nCustomizing Template Access</h2>\n<p>If you want to use an alternate template engine while still taking advantage ofthe template caching functionality, or want to customize how templates arestored and retrieved, you will need to customize the <code>TemplateCache object</code>. Thedefault operation of <code>TemplateCache</code>, is to retrieve templates from the DOMbased on the containing element's id attribute, and compile the html in thatelement with the <a href=\"http://underscorejs.org#template\">underscore.js <code>template</code></a>function.</p> <h3 id=\"override-template-retrieval\">\nOverride Template Retrieval</h3>\n<p>The default template retrieval is to select the template contents from the DOMusing jQuery. If you wish to change the way this works, you can override the<code>loadTemplate</code> method on the <code>TemplateCache</code> object.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> myTemplateFunc = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(selector)</span> </span>{\n  <span class=\"hljs-comment\">// custom template logic</span>\n};\n\nMn.TemplateCache.prototype.loadTemplate = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(templateId, options)</span></span>{\n  <span class=\"hljs-comment\">// load your template here, returning the data needed for the compileTemplate</span>\n  <span class=\"hljs-comment\">// function. For example, you have a function that creates templates based on the</span>\n  <span class=\"hljs-comment\">// value of templateId</span>\n  <span class=\"hljs-keyword\">var</span> myTemplate = myTemplateFunc(templateId);\n\n  <span class=\"hljs-comment\">// send the template back</span>\n  <span class=\"hljs-keyword\">return</span> myTemplate;\n};\n</pre> <h3 id=\"override-template-compilation\">\nOverride Template Compilation</h3>\n<p>The default template compilation passes the results from <code>loadTemplate</code> to the<code>compileTemplate</code> function, which returns an underscore.js compiled templatefunction. When overriding <code>compileTemplate</code> remember that it must return afunction which takes an object of parameters and values and returns a formattedHTML string.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Handlebars = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'handlebars'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.TemplateCache.prototype.compileTemplate = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(rawTemplate, options)</span> </span>{\n  <span class=\"hljs-comment\">// use Handlebars.js to compile the template</span>\n  <span class=\"hljs-keyword\">return</span> Handlebars.compile(rawTemplate);\n};\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.templatecache.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.templatecache.html</a>\n  </p>\n</div>\n","template":"<h1>\nTemplate Rendering</h1>\n<p>The Marionette View's primary purpose is to render your model and collectiondata into the template you assign it. The basic syntax for setting a templateis similar to the syntax for<a href=\"http://backbonejs.org/#View-template\">Backbone.js View <code>template</code></a>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> _ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'underscore'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  tagName: <span class=\"hljs-string\">'h1'</span>,\n  template: _.template(<span class=\"hljs-string\">'Contents'</span>)\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\nmyView.render();\n</pre> <p>This will cause the contents of the <code>template</code> attribute to be rendered insidea <code>&lt;h1&gt;</code> tag.</p> <p><a href=\"https://jsfiddle.net/marionettejs/h762zjua/\">Live example</a></p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li>\n<a href=\"#rendering-a-template\">Rendering a Template</a><ul> <li><a href=\"#jquery-selector\">jQuery Selector</a></li> <li><a href=\"#template-function\">Template Function</a></li> <li><a href=\"#the-gettemplate-function\">The <code>getTemplate</code> function</a></li> </ul> </li> <li>\n<a href=\"#models-and-collections\">Models and Collections</a><ul> <li><a href=\"#rendering-a-model\">Rendering a Model</a></li> <li><a href=\"#rendering-a-collection\">Rendering a Collection</a></li> <li><a href=\"#user-interaction-with-collections\">User Interaction with Collections</a></li> <li><a href=\"#model-collection-rendering-rules\">Model/Collection Rendering Rules</a></li> </ul> </li> <li>\n<a href=\"#template-context\">Template Context</a><ul> <li><a href=\"#context-object\">Context Object</a></li> <li><a href=\"#binding-of-this\">Binding of <code>this</code></a></li> </ul> </li> </ul> <h2 id=\"rendering-a-template\">\nRendering a Template</h2>\n<h3 id=\"jquery-selector\">\njQuery Selector</h3>\n<p>If your index page contains a pre-formatted template, you can simply pass in thejQuery selector for it to <code>template</code> and Marionette will look it up:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nexport.MyView = Mn.View.extend({\n  template: <span class=\"hljs-string\">'#template-layout'</span>\n});\n</pre> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"template-layout\"</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"x-template/underscore\"</span>&gt;</span><span class=\"javascript\">\n&lt;h1&gt;Hello, world&lt;<span class=\"hljs-regexp\">/h1&gt;\n</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/z4sd7ssh/\">Live example</a></p> <p>Marionette will look up the template above and render it for you when <code>MyView</code>gets rendered.</p> <h3 id=\"template-function\">\nTemplate Function</h3>\n<p>A more common way of setting a template is to assign a function to <code>template</code>that renders its argument. This will commonly be the <code>_.template</code> function:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> _ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'underscore'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nexport.MyView = Mn.View.extend({\n  template: _.template(<span class=\"hljs-string\">'&lt;h1&gt;Hello, world&lt;/h1&gt;'</span>)\n});\n</pre> <p>This doesn't have to be an underscore template, you can pass your own renderingfunction:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> Handlebars = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'handlebars'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(data)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> Handlebars.compile(<span class=\"hljs-string\">'&lt;h1&gt;Hello, {{ name }}'</span>)(data);\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/ep0e4qkt/\">Live example</a></p> <p>Using a custom function can give you a lot of control over the output of yourview after its context is calculated. If this logic is common, you may be best<a href=\"marionette.renderer\">overriding your renderer</a> to change your defaulttemplate renderer.</p> <h3 id=\"the-gettemplate-function\">\nThe <code>getTemplate</code> function</h3>\n<p>The <code>getTemplate</code> function is used to choose the template to render after theview has been instantiated. You can use this to change the template based onsome simple logic such as the value of a specific attribute in the view's model.The returned value can be either a jQuery selector or a compiled templatefunction that will be called with the view's data and context.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  getTemplate: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.model.get(<span class=\"hljs-string\">'is_active'</span>)){\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'#template-when-active'</span>;\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'#template-when-inactive'</span>;\n    }\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/9k5v4p92/\">Live example</a></p> <p>This differs from setting <code>template</code> as this method must be executed andcalculated when the view is rendered. If your template is always the same, usethe <code>template</code> attribute directly.</p> <h2 id=\"models-and-collections\">\nModels and Collections</h2>\n<h3 id=\"rendering-a-model\">\nRendering a Model</h3>\n<p>Marionette will happily render a template without a model. This won't give us aparticularly interesting result. As with Backbone, we can attach a model to ourviews and render the data they represent:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyModel = Bb.Model.extend({\n  defaults: {\n    name: <span class=\"hljs-string\">'world'</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: _.template(<span class=\"hljs-string\">'&lt;h1&gt;Hello, &lt;%- name %&gt;&lt;/h1&gt;'</span>)\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView({model: <span class=\"hljs-keyword\">new</span> MyModel()});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/warfa6rL/\">Live example</a></p> <p>Now our template has full access to the attributes on the model passed into theview.</p> <h3 id=\"rendering-a-collection\">\nRendering a Collection</h3>\n<p>The <code>Marionette.View</code> also provides a simple tool for rendering collections intoa template. Simply pass in the collection as <code>collection</code> and Marionette willprovide an <code>items</code> attribute to render:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyCollection = Bb.Collection.extend({\n});\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: <span class=\"hljs-string\">'#hello-template'</span>\n});\n\n<span class=\"hljs-keyword\">var</span> collection = <span class=\"hljs-keyword\">new</span> MyCollection([\n  {name: <span class=\"hljs-string\">'Steve'</span>}, {name: <span class=\"hljs-string\">'Helen'</span>}\n]);\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView({collection: collection});\n</pre> <p>For clarity, we've moved the template into this script tag:</p> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"hello-template\"</span> <span class=\"hljs-attribute\">type</span>=<span class=\"hljs-value\">\"x-template/underscore\"</span>&gt;</span><span class=\"javascript\">\n&lt;ul&gt;\n  <span class=\"xml\"><span class=\"vbscript\">&lt;% _.<span class=\"hljs-keyword\">each</span>(items, <span class=\"hljs-keyword\">function</span>(item) { %&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">li</span>&gt;</span><span class=\"vbscript\">&lt;%- item.name %&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">li</span>&gt;</span>\n  <span class=\"vbscript\">&lt;% }) %&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ul</span>&gt;</span>\n</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">script</span>&gt;</span>\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/qyodkakf/\">Live example</a></p> <p>As you can see, <code>items</code> is provided to the template representing each record inthe collection.</p> <h3 id=\"user-interaction-with-collections\">\nUser Interaction with Collections</h3>\n<p>While possible, reacting to user interaction with individual items in yourcollection is tricky with just a <code>View</code>. If you want to act on individual items,it's recommended that you use <a href=\"marionette.collectionview\"><code>CollectionView</code></a>and handle the behavior at the individual item level.</p> <h3 id=\"modelcollection-rendering-rules\">\nModel/Collection Rendering Rules</h3>\n<p>Marionette uses a simple method to determine whether to make a model orcollection available to the template:</p> <ol> <li>If <code>view.model</code> is set, the attributes from <code>model</code>\n</li> <li>If <code>view.model</code> is not set, but <code>view.collection</code> is, set <code>items</code> to the<br>individual items in the collection</li> <li>If neither are set, an empty object is used</li> </ol> <p>The result of this is mixed into the<a href=\"#template-context\"><code>templateContext</code> object</a> and made available to yourtemplate. Using this means you can setup a wrapper <code>View</code> that can act on<code>collectionEvents</code> but will render its <code>model</code> attribute - if your <code>model</code> hasand <code>items</code> attribute then that will always be used.</p> <h2 id=\"template-context\">\nTemplate Context</h2>\n<p>The <code>Marionette.View</code> provides a <code>templateContext</code> attribute that is used to addextra information to your templates. This can be either an object, or a functionreturning an object. The keys on the returned object will be mixed into themodel or collection keys and made available to the template.</p> <h3 id=\"context-object\">\nContext Object</h3>\n<p>Using the context object, simply attach an object to <code>templateContext</code> as so:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> _ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'underscore'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: _.template(<span class=\"hljs-string\">'&lt;h1&gt;Hello, &lt;%- contextKey %&gt;&lt;/h1&gt;'</span>),\n\n  templateContext: {\n    contextKey: <span class=\"hljs-string\">'world'</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/rw09r7e6/\">Live example</a></p> <p>The <code>myView</code> instance will be rendered without errors even though we have nomodel or collection - <code>contextKey</code> is provided by <code>templateContext</code>.</p> <p>The <code>templateContext</code> attribute can also<a href=\"basics#functions-returning-values\">take a function</a>.</p> <h3 id=\"context-function\">\nContext Function</h3>\n<p>The <code>templateContext</code> object can also be a function returning an object. This isuseful when you want to access<a href=\"#binding-of-this\">information from the surrounding view</a> (e.g. model methods).</p> <p>To use a <code>templateContext</code>, simply assign a function:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> _ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'underscore'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: _.template(<span class=\"hljs-string\">'&lt;h1&gt;Hello, &lt;%- contextKey %&gt;&lt;/h1&gt;'</span>),\n\n  templateContext: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> {\n      contextKey: <span class=\"hljs-keyword\">this</span>.getOption(<span class=\"hljs-string\">'contextKey'</span>)\n    }\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView({contextKey: <span class=\"hljs-string\">'world'</span>});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/4qxk99ya/\">Live example</a></p> <p>Here, we've passed an option that can be accessed from the <code>templateContext</code>function using <code>getOption()</code>. More information on <code>getOption</code> can be found inthe <a href=\"marionette.object#getoption\">documentation for <code>Marionette.Object</code></a>.</p> <h3 id=\"binding-of-this\">\nBinding of <code>this</code>\n</h3>\n<p>When using functions in the <code>templateContext</code> it's important to know that <code>this</code>is <em>bound to the result of <code>serializeData()</code> and <strong>not the view</strong></em>. Anillustrative example:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> _ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'underscore'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  template: _.template(<span class=\"hljs-string\">'&lt;h1&gt;Hello, &lt;%- contextKey() %&gt;&lt;/h1&gt;'</span>),\n\n  templateContext: {\n    contextKey: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.getOption(<span class=\"hljs-string\">'contextKey'</span>);  <span class=\"hljs-comment\">// ERROR</span>\n    }\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView({contextKey: <span class=\"hljs-string\">'world'</span>});\n</pre> <p>The above code will fail because the context object in the template<em>cannot see</em> the view's <code>getOption</code>. This would also apply to functionsreturned by a <code>templateContext</code> function, even though the function itself isbound to the view context.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/template.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/template.html</a>\n  </p>\n</div>\n","marionette.collectionviewadvanced":"<h1>\nAdvanced CollectionView Usage</h1>\n<p><code>CollectionView</code> provides a lot of possibilities to sort, filter and manages children.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li>\n<p><a href=\"#collectionviews-children\">CollectionView's children</a></p> <ul> <li><a href=\"#collectionviews-buildchildview\">CollectionView's <code>buildChildView</code></a></li> <li><a href=\"#collectionviews-addchildview\">CollectionView's <code>addChildView</code></a></li> <li>\n<a href=\"#collectionview-retrieve-child-views\">CollectionView: Retrieve Child Views</a><ul> <li><a href=\"#collectionview-childviews-findbycid\">CollectionView childView's: <code>findByCid</code></a></li> <li><a href=\"#collectionview-childviews-findbymodel\">CollectionView childView's: <code>findByModel</code></a></li> <li><a href=\"#collectionview-childviews-findbymodelcid\">CollectionView childView's: <code>findByModelCid</code></a></li> <li><a href=\"#collectionview-childviews-findbycustom\">CollectionView childView's: <code>findByCustom</code></a></li> <li><a href=\"#collectionview-childviews-findbyindex\">CollectionView childView's: <code>findByIndex</code></a></li> </ul> </li> <li><a href=\"#collectionviews-removechildview\">CollectionView's <code>removeChildView</code></a></li> <li><a href=\"#collectionview-childview-iterators-and-collection-functions\">CollectionView childView Iterators And Collection Functions</a></li> </ul> </li> <li>\n<p><a href=\"#collectionviews-filter\">CollectionView's <code>filter</code></a></p> <ul> <li><a href=\"#collectionviews-setfilter\">CollectionView's <code>setFilter</code></a></li> <li><a href=\"#collectionviews-removefilter\">CollectionView's <code>removeFilter</code></a></li> </ul> </li> <li>\n<p><a href=\"#collectionviews-sort\">CollectionView's <code>sort</code></a></p> <ul> <li><a href=\"#collectionviews-viewcomparator\">CollectionView's <code>viewComparator</code></a></li> <li><a href=\"#collectionviews-getviewcomparator\">CollectionView's <code>getViewComparator</code></a></li> <li>\n<a href=\"#collectionviews-reorderonsort\">CollectionView's <code>reorderOnSort</code></a><br><a href=\"#collectionviews-reorder\">CollectionView's <code>reorder</code></a>\n</li> <li><a href=\"#collectionviews-resortview\">CollectionView's <code>resortView</code></a></li> </ul> </li> </ul> <h2 id=\"collectionviews-children\">\nCollectionView's children</h2>\n<p>The <code>CollectionView</code> can store and manage its child views. This allows you to easily accessthe views within the collection view, iterate them, find them bya given indexer such as the view's model or collection, and more.</p> <h3 id=\"collectionviews-buildchildview\">\nCollectionView's <code>buildChildView</code>\n</h3>\n<p>The <code>buildChildView</code> is responsible for taking the ChildView class andinstantiating it with the appropriate data. This method takes threeparameters and returns a view instance to be used as thechild view.</p> <pre data-language=\"javascript\">buildChildView: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(child, ChildViewClass, childViewOptions)</span></span>{\n  <span class=\"hljs-comment\">// build the final list of options for the childView class</span>\n  <span class=\"hljs-keyword\">var</span> options = _.extend({model: child}, childViewOptions);\n  <span class=\"hljs-comment\">// create the child view instance</span>\n  <span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> ChildViewClass(options);\n  <span class=\"hljs-comment\">// return it</span>\n  <span class=\"hljs-keyword\">return</span> view;\n},\n</pre> <p>Override this method when you need a more complicated build, but use <a href=\"#collectionviews-childview\"><code>childView</code></a>if you need to determine <em>which</em> View class to instantiate.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n  childView: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(child)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (child.get(<span class=\"hljs-string\">'type'</span>) === <span class=\"hljs-string\">'list'</span>) {\n      <span class=\"hljs-keyword\">return</span> MyListView;\n    }\n\n    <span class=\"hljs-keyword\">return</span> MyView;\n  },\n  buildChildView: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(child, ChildViewClass, childViewOptions)</span> </span>{\n    <span class=\"hljs-keyword\">var</span> options = {};\n\n    <span class=\"hljs-keyword\">if</span> (child.get(<span class=\"hljs-string\">'type'</span>) === <span class=\"hljs-string\">'list'</span>) {\n      <span class=\"hljs-keyword\">var</span> childList = <span class=\"hljs-keyword\">new</span> Bb.Collection(child.get(<span class=\"hljs-string\">'list'</span>));\n      options = _.extend({collection: childList}, childViewOptions);\n    } <span class=\"hljs-keyword\">else</span> {\n      options = _.extend({model: child}, childViewOptions);\n    }\n\n    <span class=\"hljs-comment\">// create the child view instance</span>\n    <span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-keyword\">new</span> ChildViewClass(options);\n    <span class=\"hljs-comment\">// return it</span>\n    <span class=\"hljs-keyword\">return</span> view;\n  }\n\n});\n</pre> <h3 id=\"collectionviews-addchildview\">\nCollectionView's <code>addChildView</code>\n</h3>\n<p>The <code>addChildView</code> method can be used to add a view that is independent of your<code>Backbone.Collection</code>. Note that this added view will be subject to filteringand ordering and may be difficult to manage in complex situations. Use withcare.</p> <p>This method takes two parameters, the child view instance and the index forwhere it should be placed within the <a href=\"#collectionviews-children\">CollectionView's children</a>.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> buttonView = <span class=\"hljs-keyword\">new</span> ButtonView();\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.addChildView(buttonView, <span class=\"hljs-keyword\">this</span>.collection.length);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myCollectionView = <span class=\"hljs-keyword\">new</span> MyCollectionView();\n\nmyCollectionView.render();\n</pre> <h3 id=\"collectionview-retrieve-child-views\">\nCollectionView: Retrieve Child Views</h3>\n<p>You can retrieve a view by any of the index. If the findBy* method cannot find the view, it will return undefined.</p> <h4>\nCollectionView childView's: <code>findByCid</code>\n</h4>\n<p>Find a view by it's cid.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> bView = myCollectionView.children.findByCid(buttonView.cid);\n</pre> <h4>\nCollectionView childView's: <code>findByModel</code>\n</h4>\n<p>Find a view by model.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> bView = myCollectionView.children.findByModel(buttonView.model);\n</pre> <h4>\nCollectionView childView's: <code>findByModelCid</code>\n</h4>\n<p>Find a view by model cid.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> bView = myCollectionView.children.findByModelCid(buttonView.model.cid);\n</pre> <h4>\nCollectionView childView's: <code>findByCustom</code>\n</h4>\n<p>Find by custom key.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> bView = myCollectionView.children.findByCustom(<span class=\"hljs-string\">'cutom_key'</span>);\n</pre> <h4>\nCollectionView childView's: <code>findByIndex</code>\n</h4>\n<p>Find by numeric index (unstable)</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> bView = myCollectionView.children.findByIndex(<span class=\"hljs-number\">0</span>);\n</pre> <h3 id=\"collectionviews-removechildview\">\nCollectionView's <code>removeChildView</code>\n</h3>\n<p>The <code>removeChildView</code> method is useful if you need to remove a view from the <code>CollectionView</code> without affecting the view's collection. In most cases it is better to use the data to determine what the <code>CollectionView</code> should display.</p> <p>This method the child view instance to remove as its parameter.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.CollectionView.extend({\n  onChildViewClose: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView, model)</span> </span>{\n    <span class=\"hljs-comment\">// NOTE: we must wait for the server to confirm</span>\n    <span class=\"hljs-comment\">// the destroy PRIOR to removing it from the collection</span>\n    model.destroy({wait: <span class=\"hljs-literal\">true</span>});\n\n    <span class=\"hljs-comment\">// but go ahead and remove it visually</span>\n    <span class=\"hljs-keyword\">this</span>.removeChildView(childView);\n  }\n});\n</pre> <h3 id=\"collectionview-childview-iterators-and-collection-functions\">\nCollectionView childView Iterators And Collection Functions</h3>\n<p>The container object borrows several functions from <a href=\"http://underscorejs.org/\">Underscore.js</a>, to provide iterators and other collection functions, including:</p> <ul> <li><a href=\"http://underscorejs.org/#each\">each</a></li> <li><a href=\"http://underscorejs.org/#map\">map</a></li> <li><a href=\"http://underscorejs.org/#reduce\">reduce</a></li> <li><a href=\"http://underscorejs.org/#find\">find</a></li> <li><a href=\"http://underscorejs.org/#filter\">filter</a></li> <li><a href=\"http://underscorejs.org/#reject\">reject</a></li> <li><a href=\"http://underscorejs.org/#every\">every</a></li> <li><a href=\"http://underscorejs.org/#some\">some</a></li> <li><a href=\"http://underscorejs.org/#contains\">contains</a></li> <li><a href=\"http://underscorejs.org/#invoke\">invoke</a></li> <li><a href=\"http://underscorejs.org/#toArray\">toArray</a></li> <li><a href=\"http://underscorejs.org/#first\">first</a></li> <li><a href=\"http://underscorejs.org/#initial\">initial</a></li> <li><a href=\"http://underscorejs.org/#rest\">rest</a></li> <li><a href=\"http://underscorejs.org/#last\">last</a></li> <li><a href=\"http://underscorejs.org/#without\">without</a></li> <li><a href=\"http://underscorejs.org/#isEmpty\">isEmpty</a></li> <li><a href=\"http://underscorejs.org/#pluck\">pluck</a></li> </ul> <p>These methods can be called directly on the container, to iterate and process the views held by the container.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> collectionView = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  collection: <span class=\"hljs-keyword\">new</span> Bb.Collection()\n});\n\ncollectionView.render();\n\n<span class=\"hljs-comment\">// iterate over all of the views and process them</span>\ncollectionView.children.each(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span> </span>{\n  <span class=\"hljs-comment\">// process the `childView` here</span>\n});\n</pre> <h2 id=\"collectionviews-filter\">\nCollectionView's <code>filter</code>\n</h2>\n<p><code>CollectionView</code> allows for a custom <code>filter</code> option if you want to prevent some of theunderlying <code>collection</code>'s models from being rendered as child views.The filter function takes a model from the collection and returns a truthy value if the child should be rendered,and a falsey value if it should not.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  childView: SomeChildView,\n  emptyView: SomeEmptyView,\n  collection: <span class=\"hljs-keyword\">new</span> Bb.Collection([\n    { value: <span class=\"hljs-number\">1</span> },\n    { value: <span class=\"hljs-number\">2</span> },\n    { value: <span class=\"hljs-number\">3</span> },\n    { value: <span class=\"hljs-number\">4</span> }\n  ]),\n\n  <span class=\"hljs-comment\">// Only show views with even values</span>\n  filter: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(child, index, collection)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> child.get(<span class=\"hljs-string\">'value'</span>) % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>;\n  }\n});\n\n<span class=\"hljs-comment\">// renders the views with values '2' and '4'</span>\ncv.render();\n\n<span class=\"hljs-comment\">// change the filter</span>\n<span class=\"hljs-comment\">// renders the views with values '1' and '3'</span>\ncv.setFilter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(child, index, collection)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> child.get(<span class=\"hljs-string\">'value'</span>) % <span class=\"hljs-number\">2</span> !== <span class=\"hljs-number\">0</span>;\n});\n\n<span class=\"hljs-comment\">// renders all views</span>\ncv.removeFilter();\n</pre> <h3 id=\"collectionviews-setfilter\">\nCollectionView's <code>setFilter</code>\n</h3>\n<p>The <code>setFilter</code> method modifies the <code>CollectionView</code>'s filter attribute, andrenders the new <code>ChildViews</code> in a efficient way, instead ofrendering the whole DOM structure again.Passing <code>{ preventRender: true }</code> in the options argument will prevent the view being rendered.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\n<span class=\"hljs-keyword\">var</span> newFilter = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(child, index, collection)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> child.get(<span class=\"hljs-string\">'value'</span>) % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>;\n};\n\n<span class=\"hljs-comment\">// Note: the setFilter is preventing the automatic re-render</span>\ncv.setFilter(newFilter, { preventRender: <span class=\"hljs-literal\">true</span> });\n\n<span class=\"hljs-comment\">//Render the new state of the ChildViews instead of the whole DOM.</span>\ncv.render();\n</pre> <h3 id=\"collectionviews-removefilter\">\nCollectionView's <code>removeFilter</code>\n</h3>\n<p>This function is actually an alias of <code>setFilter(null, options)</code>. It is useful for removing filters.<code>removeFilter</code> also accepts <code>preventRender</code> as a option.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\ncv.setFilter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(child, index, collection)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> child.get(<span class=\"hljs-string\">'value'</span>) % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>;\n});\n\n<span class=\"hljs-comment\">//Remove the current filter without rendering again.</span>\ncv.removeFilter({ preventRender: <span class=\"hljs-literal\">true</span> });\n</pre> <h2 id=\"collectionviews-sort\">\nCollectionView's <code>sort</code>\n</h2>\n<p>By default the <code>CollectionView</code> will maintain a sorted collection's orderin the DOM. This behavior can be disabled by specifying <code>{sort: false}</code> on initialize. The <code>sort</code> flag cannot be changed after instantiation.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> myCollection = <span class=\"hljs-keyword\">new</span> Bb.Collection([\n  { id: <span class=\"hljs-number\">1</span> },\n  { id: <span class=\"hljs-number\">4</span> },\n  { id: <span class=\"hljs-number\">3</span> },\n  { id: <span class=\"hljs-number\">2</span> }\n]);\n\nmyCollection.comparator = <span class=\"hljs-string\">'id'</span>;\n\n<span class=\"hljs-keyword\">var</span> mySortedColView = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  <span class=\"hljs-comment\">//...</span>\n  collection: myCollection\n});\n\n<span class=\"hljs-keyword\">var</span> myUnsortedColView = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  <span class=\"hljs-comment\">//...</span>\n  collection: myCollection,\n  sort: <span class=\"hljs-literal\">false</span>\n});\n\nmySortedColView.render(); <span class=\"hljs-comment\">// 1 4 3 2</span>\nmyUnsortedColView.render(); <span class=\"hljs-comment\">// 1 4 3 2</span>\n\n<span class=\"hljs-comment\">// mySortedColView auto-renders 1 2 3 4</span>\n<span class=\"hljs-comment\">// myUnsortedColView has no change</span>\nmyCollection.sort();\n</pre> <h3 id=\"collectionviews-viewcomparator\">\nCollectionView's <code>viewComparator</code>\n</h3>\n<p><code>CollectionView</code> allows for a custom <code>viewComparator</code> option if you want your <code>CollectionView</code>'s children to be rendered with a different sort order than the underlying Backbone collection uses.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  collection: someCollection,\n  viewComparator: <span class=\"hljs-string\">'otherFieldToSortOn'</span>\n});\n</pre> <p>The <code>viewComparator</code> can take any of the acceptable <code>Backbone.Collection</code><a href=\"http://backbonejs.org/#Collection-comparator\">comparator formats</a> -- a sortBy(pass a function that takes a single argument), as a sort (pass a comparatorfunction that expects two arguments), or as a string indicating the attribute tosort by.</p> <h3 id=\"collectionviews-getviewcomparator\">\nCollectionView's <code>getViewComparator</code>\n</h3>\n<p>Override this method to determine which <code>viewComparator</code> to use.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n  sortAsc: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(model)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> -model.get(<span class=\"hljs-string\">'order'</span>);\n  },\n  sortDesc: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(model)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> model.get(<span class=\"hljs-string\">'order'</span>);\n  },\n  getViewComparator: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// The collectionView's model</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.model.get(<span class=\"hljs-string\">'sorted'</span>) === <span class=\"hljs-string\">'ASC'</span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.sortAsc;\n    }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.sortDesc;\n  }\n});\n</pre> <h3 id=\"collectionviews-reorderonsort\">\nCollectionView's <code>reorderOnSort</code>\n</h3>\n<p>This option is useful when you have performance issues when you resort your <code>CollectionView</code>.Without this option, your <code>CollectionView</code> will be completely re-rendered, which can becostly if you have a large number of elements or if your <code>ChildView</code>s are complex. If this optionis activated, when you sort your <code>Collection</code>, there will be no re-rendering, only the DOM nodeswill be reordered. This can be a problem if your <code>ChildView</code>s use their collection's indexin their rendering. In this case, you cannot use this option as you need to re-render each<code>ChildView</code>.</p> <p>If you combine this option with a <a href=\"#collectionviews-filter\">filter</a> that changes the views that areto be displayed, <code>reorderOnSort</code> will be bypassed to render new children and remove those that are rejected by the filter.</p> <h3 id=\"collectionviews-reorder\">\nCollectionView's <code>reorder</code>\n</h3>\n<p>If <a href=\"#collectionviews-reorderonsort\"><code>reorderOnSort</code></a> is set to true, this function will be used instead of re-rendering all children. It can be called directly to prevent the collection from being completely re-rendered. This may only be useful if models are added or removed silently or if <a href=\"#collectionviews-sort\"><code>sort</code></a> was set to false on the <code>CollectionView</code>.</p> <h3 id=\"collectionviews-resortview\">\nCollectionView's <code>resortView</code>\n</h3>\n<p><a href=\"#collectionviews-sort\">By default</a> the <code>CollectionView</code> will maintain the order of its <code>collection</code>in the DOM. However on occasions the view may need to re-render to make thispossible, for example if you were to change the comparator on the collection.The <code>CollectionView</code> will re-render its children or <a href=\"#collectionviews-reorder\"><code>reorder</code></a> them depending on <a href=\"#collectionviews-reorderonsort\"><code>reorderOnSort</code></a>.Override this function if you need further customization.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n  resortView: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// provide custom logic for rendering after sorting the collection</span>\n  }\n});\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.collectionviewadvanced.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.collectionviewadvanced.html</a>\n  </p>\n</div>\n","marionette.functions":"<h1>\nMarionette functions</h1>\n<p>Marionette provides a set of utility / helper functions that are used tofacilitate common behaviors throughout the framework. These functions maybe useful to those that are building on top of Marionette, as they providea way to get the same behaviors and conventions from your own code.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li><a href=\"#marionetteextend\">Marionette.extend</a></li> <li><a href=\"#marionetteisnodeattached\">Marionette.isNodeAttached</a></li> <li><a href=\"#marionettemergeoptions\">Marionette.mergeOptions</a></li> <li><a href=\"#marionettegetoption\">Marionette.getOption</a></li> <li><a href=\"#marionettetriggermethod\">Marionette.triggerMethod</a></li> <li><a href=\"#marionettetriggermethodon\">Marionette.triggerMethodOn</a></li> <li><a href=\"#marionettebindevents\">Marionette.bindEvents</a></li> <li><a href=\"#marionetteunbindevents\">Marionette.unbindEvents</a></li> <li><a href=\"#marionettebindrequests\">Marionette.bindRequests</a></li> <li><a href=\"#marionetteunbindrequests\">Marionette.unbindRequests</a></li> <li><a href=\"#marionettenormalizemethods\">Marionette.normalizeMethods</a></li> </ul> <h2 id=\"marionetteextend\">\nMarionette.extend</h2>\n<p>Backbone's <code>extend</code> function is a useful utility to have, and is used invarious places in Marionette. To make the use of this method more consistent,Backbone's <code>extend</code> has been aliased to <code>Marionette.extend</code>. This allowsyou to get the extend functionality for your object without having todecide if you want to use Backbone.View or Backbone.Model or anotherBackbone object to grab the method from.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> Foo = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{};\n\n<span class=\"hljs-comment\">// use Marionette.extend to make Foo extendable, just like other</span>\n<span class=\"hljs-comment\">// Backbone and Marionette objects</span>\nFoo.extend = Mn.extend;\n\n<span class=\"hljs-comment\">// Now Foo can be extended to create a new class, with methods</span>\n<span class=\"hljs-keyword\">var</span> Bar = Foo.extend({\n\n  someMethod: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{ ... }\n\n  <span class=\"hljs-comment\">// ...</span>\n});\n\n<span class=\"hljs-comment\">// Create an instance of Bar</span>\n<span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">new</span> Bar();\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/w5avq89r/\">Live example</a></p> <h2 id=\"marionetteisnodeattached\">\nMarionette.isNodeAttached</h2>\n<p>Determines whether the passed-in node is a child of the <code>document</code> or not.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> div = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'div'</span>);\nMn.isNodeAttached(div);\n<span class=\"hljs-comment\">// =&gt; false</span>\n\n$(<span class=\"hljs-string\">'body'</span>).append(div);\nMn.isNodeAttached(div);\n<span class=\"hljs-comment\">// =&gt; true</span>\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/azn1fo3z/\">Live example</a></p> <h2 id=\"marionettemergeoptions\">\nMarionette.mergeOptions</h2>\n<p>A handy function to pluck certain <code>options</code> and attach them directly to an instance.Most Marionette Classes, such as the Views, come with this method.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  myViewOptions: [<span class=\"hljs-string\">'color'</span>, <span class=\"hljs-string\">'size'</span>, <span class=\"hljs-string\">'country'</span>],\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.mergeOptions(options, <span class=\"hljs-keyword\">this</span>.myViewOptions);\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// The merged options will be attached directly to the prototype</span>\n    <span class=\"hljs-keyword\">this</span>.$el.addClass(<span class=\"hljs-keyword\">this</span>.color);\n  }\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/gv5psrdu/\">Live example</a></p> <h2 id=\"marionettegetoption\">\nMarionette.getOption</h2>\n<p>Retrieve an object's attribute either directly from the object, or fromthe object's <code>this.options</code>, with <code>this.options</code> taking precedence.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> Model = Bb.Model.extend({\n  foo: <span class=\"hljs-string\">'bar'</span>,\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(attributes, options)</span></span>{\n    <span class=\"hljs-keyword\">this</span>.options = options;\n    <span class=\"hljs-keyword\">var</span> foo = Mn.getOption(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">'foo'</span>);\n    <span class=\"hljs-built_in\">console</span>.log(foo);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> model1 = <span class=\"hljs-keyword\">new</span> Model(); <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n\n<span class=\"hljs-keyword\">var</span> model2 = <span class=\"hljs-keyword\">new</span> Model({}, { foo: <span class=\"hljs-string\">'quux'</span> }); <span class=\"hljs-comment\">// =&gt; \"quux\"</span>\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/4rt6exaq/\">Live example</a></p> <p>This is useful when building an object that can have configuration setin either the object definition or the object's constructor options.</p> <h3 id=\"falsey-values\">\nFalsey values</h3>\n<p>The <code>getOption</code> function will return any falsey value from the <code>options</code>,other than <code>undefined</code>. If an object's options has an undefined value, it willattempt to read the value from the object directly.</p> <p>For example:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> Model = Bb.Model.extend({\n  foo: <span class=\"hljs-string\">'bar'</span>,\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">var</span> foo = Mn.getOption(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">'foo'</span>);\n    <span class=\"hljs-built_in\">console</span>.log(foo);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> model1 = <span class=\"hljs-keyword\">new</span> Model(); <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n\n<span class=\"hljs-keyword\">var</span> foo;\n<span class=\"hljs-keyword\">var</span> model2 = <span class=\"hljs-keyword\">new</span> Model({}, { foo: foo }); <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/2ddk28ap/\">Live example</a></p> <p>In this example, \"bar\" is returned both times because the secondexample has an undefined value for <code>f</code>.</p> <h2 id=\"marionettetriggermethod\">\nMarionette.triggerMethod</h2>\n<p>Trigger an event and a corresponding method on the target object.</p> <p>When an event is triggered, the first letter of each section of theevent name is capitalized, and the word \"on\" is tagged on to the frontof it. Examples:</p> <ul> <li>\n<code>triggerMethod(\"render\")</code> fires the \"onRender\" function</li> <li>\n<code>triggerMethod(\"before:destroy\")</code> fires the \"onBeforeDestroy\" function</li> </ul> <p>All arguments that are passed to the triggerMethod call are passed along to both the event and the method, with the exception of the event name not being passed to the corresponding method.</p> <p><code>triggerMethod(\"foo\", bar)</code> will call <code>onFoo: function(bar){...})</code></p> <p>Note that <code>triggerMethod</code> can be called on objects that do not have<code>Backbone.Events</code> mixed in to them. These objects will not have a <code>trigger</code>method, and no attempt to call <code>.trigger()</code> will be made. The <code>on{Name}</code>callback methods will still be called, though.</p> <h2 id=\"marionettetriggermethodon\">\nMarionette.triggerMethodOn</h2>\n<p>Invoke <code>triggerMethod</code> on a specific context.</p> <p>This is useful when it's not clear that the object has <code>triggerMethod</code> defined. In the case of views, <code>Marionette.AbstractView</code> defines <code>triggerMethod</code>, but <code>Backbone.View</code> does not.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.triggerMethodOn(ctx, <span class=\"hljs-string\">\"foo\"</span>, bar);\n<span class=\"hljs-comment\">// will invoke `onFoo: function(bar){...})`</span>\n<span class=\"hljs-comment\">// will trigger \"foo\" on ctx</span>\n</pre> <h2 id=\"marionettebindevents\">\nMarionette.bindEvents</h2>\n<p>This method is used to bind a backbone \"entity\" (e.g. collection/model)to methods on a target object.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nBb.View.extend({\n\n  modelEvents: {\n    <span class=\"hljs-string\">'change:foo'</span>: <span class=\"hljs-string\">'doSomething'</span>\n  },\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    Mn.bindEvents(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>.model, <span class=\"hljs-keyword\">this</span>.modelEvents);\n  },\n\n  doSomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// the \"change:foo\" event was fired from the model</span>\n    <span class=\"hljs-comment\">// respond to it appropriately, here.</span>\n  }\n\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/L640ecac/\">Live example</a></p> <p>The first parameter, <code>target</code>, must have the Backbone.Events module mixed in.</p> <p>The second parameter is the <code>entity</code> (Backbone.Model, Backbone.Collection orany object that has Backbone.Events mixed in) to bind the events from.</p> <p>The third parameter is a hash of { \"event:name\": \"eventHandler\" }configuration. Multiple handlers can be separated by a space. Afunction can be supplied instead of a string handler name.</p> <h2 id=\"marionetteunbindevents\">\nMarionette.unbindEvents</h2>\n<p>This method can be used to unbind callbacks from entities' (e.g. collection/model) events. It'sthe opposite of bindEvents, described above. Consequently, the APIs are identical for each method.</p> <pre data-language=\"javascript\"><span class=\"hljs-comment\">// Just like the above example we bind our model events.</span>\n<span class=\"hljs-comment\">// This time, however, we unbind them on close.</span>\n<span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nBb.View.extend({\n\n  modelEvents: {\n    <span class=\"hljs-string\">'change:foo'</span>: <span class=\"hljs-string\">'doSomething'</span>\n  },\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    Mn.bindEvents(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>.model, <span class=\"hljs-keyword\">this</span>.modelEvents);\n  },\n\n  doSomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-comment\">// the \"change:foo\" event was fired from the model</span>\n    <span class=\"hljs-comment\">// respond to it appropriately, here.</span>\n  },\n\n  onClose: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    Mn.unbindEvents(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>.model, <span class=\"hljs-keyword\">this</span>.modelEvents);\n  }\n\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/yvsfm65c/\">Live example</a></p> <h2 id=\"marionettebindrequests\">\nMarionette.bindRequests</h2>\n<p>This method is used to bind a radio requeststo methods on a target object.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> Radio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.radio'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  channelName: <span class=\"hljs-string\">'myChannelName'</span>,\n\n  radioRequests: {\n    <span class=\"hljs-string\">'foo:bar'</span>: <span class=\"hljs-string\">'fooBar'</span>\n  },\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">var</span> channel = Radio.channel(<span class=\"hljs-keyword\">this</span>.channelName);\n    Mn.bindRequests(<span class=\"hljs-keyword\">this</span>, channel, <span class=\"hljs-keyword\">this</span>.radioRequests);\n  },\n\n  fooBar: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'foo:bar event was called'</span>)\n  }\n });\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n<span class=\"hljs-keyword\">var</span> channel = Radio.channel(<span class=\"hljs-string\">'myChannelName'</span>);\nchannel.request(<span class=\"hljs-string\">'foo:bar'</span>); <span class=\"hljs-comment\">// Logs 'foo:bar event was called'</span>\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/hmjgkg7w/\">Live example</a></p> <p>The first parameter, <code>this</code>, is a context of current entity.</p> <p>The second parameter, <code>channel</code>, reference to a channel by name.</p> <p>The third parameter is a hash either { \"event:name\": \"eventHandler\" } or{ \"event:name\": \"eventHandler\", \"event:otherName\": \"otherEventHandler\", ...} ofconfiguration.</p> <h2 id=\"marionetteunbindrequests\">\nMarionette.unbindRequests</h2>\n<p>This method is used to unbind a radio requeststo methods on a target object.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n<span class=\"hljs-keyword\">var</span> Radio = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.radio'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.View.extend({\n  channelName: <span class=\"hljs-string\">'myChannelName'</span>,\n\n  radioRequests: {\n    <span class=\"hljs-string\">'foo:bar'</span>: <span class=\"hljs-string\">'fooBar'</span>\n  },\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">var</span> channel = Radio.channel(<span class=\"hljs-keyword\">this</span>.channelName);\n    Mn.bindRadioRequests(<span class=\"hljs-keyword\">this</span>, channel, <span class=\"hljs-keyword\">this</span>.radioRequests);\n  },\n\n  onDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">var</span> channel = Radio.channel(<span class=\"hljs-keyword\">this</span>.channelName);\n    Mn.unbindRequests(<span class=\"hljs-keyword\">this</span>, channel, <span class=\"hljs-keyword\">this</span>.radioRequests);\n  }\n });\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\nmyView.destroy();\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/r5kmwwke/\">Live examples</a></p> <p>The first parameter, <code>this</code>, is a context of current entity.</p> <p>The second parameter, <code>channel</code>, reference to a channel by name.</p> <p>The third parameter is a hash either { \"event:name\": \"eventHandler\" } or{ \"event:name\": \"eventHandler\", \"event:otherName\": \"otherEventHandler\", ...} ofconfiguration.</p> <h2 id=\"marionettenormalizemethods\">\nMarionette.normalizeMethods</h2>\n<p>Receives a hash of event names and functions and/or function names, and returns thesame hash with the function names replaced with the function references themselves.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> View = Mn.View.extend({\n\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">var</span> hash = {\n      <span class=\"hljs-string\">'event:one'</span>: <span class=\"hljs-string\">'handleEventOne'</span>, <span class=\"hljs-comment\">// This will become a reference to `this.someFn`</span>\n      <span class=\"hljs-string\">'event:two'</span>: <span class=\"hljs-keyword\">this</span>.someOtherFn\n    };\n\n    <span class=\"hljs-keyword\">this</span>.normalizedHash = <span class=\"hljs-keyword\">this</span>.normalizeMethods(hash);\n\n    Mn.bindEvents(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>.normalizedHash);\n  },\n\n  destroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n      Mn.unbindEvents(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>.normalizedHash);\n  },\n\n  handleEventOne: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'event:one was fired'</span>);\n  },\n\n  handleEventTwo: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'event:two was fired'</span>);\n  }\n\n});\n</pre> <p><a href=\"https://jsfiddle.net/marionettejs/zzjhm4p1/\">Live example</a></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.functions.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.functions.html</a>\n  </p>\n</div>\n","marionette.collectionview":"<h1>\nMarionette.CollectionView</h1>\n<p>The <code>CollectionView</code> will loop through all of the models in thespecified collection, render each of them using a specified <code>childView</code>,then append the results of the child view's <code>el</code> to the collection view's<code>el</code>. By default the <code>CollectionView</code> will maintain a sorted collection's orderin the DOM. This behavior can be disabled by specifying <code>{sort: false}</code> on initialize.</p> <p><code>CollectionView</code> has the base functionality provided by the View Mixin.</p> <h2 id=\"documentation-index\">\nDocumentation Index</h2>\n<ul> <li>\n<a href=\"#collectionviews-childview\">CollectionView's <code>childView</code></a><ul> <li><a href=\"#collectionviews-childviewoptions\">CollectionView's <code>childViewOptions</code></a></li> <li><a href=\"#collectionviews-childvieweventprefix\">CollectionView's <code>childViewEventPrefix</code></a></li> <li><a href=\"#collectionviews-childviewevents\">CollectionView's <code>childViewEvents</code></a></li> <li><a href=\"#collectionviews-childviewtriggers\">CollectionView's <code>childViewTriggers</code></a></li> </ul> </li> <li>\n<a href=\"#collectionviews-emptyview\">CollectionView's <code>emptyView</code></a><ul> <li><a href=\"#collectionviews-emptyviewoptions\">CollectionView's <code>emptyViewOptions</code></a></li> <li><a href=\"#collectionviews-isempty\">CollectionView's <code>isEmpty</code></a></li> </ul> </li> <li>\n<a href=\"#collectionviews-render\">CollectionView's <code>render</code></a><ul> <li><a href=\"#collectionview-automatic-rendering\">CollectionView: Automatic Rendering</a></li> <li><a href=\"#collectionview-re-render-collection\">CollectionView: Re-render Collection</a></li> <li><a href=\"#collectionviews-attachhtml\">CollectionView's <code>attachHtml</code></a></li> <li><a href=\"#collectionviews-attachbuffer\">CollectionView's <code>attachBuffer</code></a></li> </ul> </li> <li><a href=\"#collectionviews-destroy\">CollectionView's <code>destroy</code></a></li> <li>\n<a href=\"#collectionviews-filter\">CollectionView's <code>filter</code></a><ul> <li><a href=\"#collectionviews-setfilter\">CollectionView's <code>setFilter</code></a></li> <li><a href=\"#collectionviews-removefilter\">CollectionView's <code>removeFilter</code></a></li> </ul> </li> <li>\n<a href=\"#collectionviews-sort\">CollectionView's <code>sort</code></a><ul> <li><a href=\"#collectionviews-viewcomparator\">CollectionView's <code>viewComparator</code></a></li> <li><a href=\"#collectionviews-getviewcomparator\">CollectionView's <code>getViewComparator</code></a></li> <li>\n<a href=\"#collectionviews-reorderonsort\">CollectionView's <code>reorderOnSort</code></a><br><a href=\"#collectionviews-reorder\">CollectionView's <code>reorder</code></a>\n</li> <li><a href=\"#collectionviews-resortview\">CollectionView's <code>resortView</code></a></li> </ul> </li> <li>\n<a href=\"#collectionview-events\">Events</a><ul> <li><a href=\"#child-event-bubbling\">Child Event Bubbling</a></li> <li>\n<a href=\"#lifecycle-events\">Lifecycle Events</a><ul> <li><a href=\"#creation-lifecycle\">Creation Lifecycle</a></li> <li><a href=\"#destruction-lifecycle\">Destruction Lifecycle</a></li> <li><a href=\"#creation-events\">Creation Events</a></li> <li><a href=\"#destruction-events\">Destruction Events</a></li> <li><a href=\"#other-events\">Other Events</a></li> </ul> </li> </ul> </li> <li>\n<a href=\"#rendering-collectionviews\">Rendering <code>CollectionView</code>s</a><ul> <li><a href=\"#rendering-lists\">Rendering Lists</a></li> <li>\n<a href=\"#rendering-tables\">Rendering Tables</a><ul> <li><a href=\"#tables-using-marionette-2\">Tables Using Marionette 2</a></li> <li><a href=\"#tables-using-marionette-3\">Tables Using Marionette 3</a></li> </ul> </li> <li>\n<a href=\"#rendering-trees\">Rendering Trees</a><ul> <li><a href=\"#trees-in-marionette-2\">Trees in Marionette 2</a></li> <li><a href=\"#trees-in-marionette-3\">Trees in Marionette 3</a></li> </ul> </li> </ul> </li> </ul> <h2 id=\"collectionviews-childview\">\nCollectionView's <code>childView</code>\n</h2>\n<p>Specify a <code>childView</code> in your collection view definition. This must bea Backbone view class definition, not an instance. It can be any<code>Backbone.View</code> or be derived from <code>Marionette.View</code>.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyChildView = Mn.View.extend({});\n\nMn.CollectionView.extend({\n  childView: MyChildView\n});\n</pre> <p>Child views must be defined before they are referenced by the<code>childView</code> attribute in a collection view definition.</p> <p>Alternatively, you can specify a <code>childView</code> in the options forthe constructor:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({...});\n\n<span class=\"hljs-keyword\">new</span> MyCollectionView({\n  childView: MyChildView\n});\n</pre> <p>If you do not specify a <code>childView</code>, an exception will be thrownstating that you must specify a <code>childView</code>.</p> <p>You can also define <code>childView</code> as a function. In this form, the valuereturned by this method is the <code>ChildView</code> class that will be instantiatedwhen a <code>Model</code> needs to be initially rendered. This method also gives youthe ability to customize per <code>Model</code> <code>ChildViews</code>.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> FooBar = Bb.Model.extend({\n  defaults: {\n    isFoo: <span class=\"hljs-literal\">false</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> FooView = Mn.View.extend({\n  template: <span class=\"hljs-string\">'#foo-template'</span>\n});\n<span class=\"hljs-keyword\">var</span> BarView = Mn.View.extend({\n  template: <span class=\"hljs-string\">'#bar-template'</span>\n});\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n  childView: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(item)</span> </span>{\n    <span class=\"hljs-comment\">// Choose which view class to render,</span>\n    <span class=\"hljs-comment\">// depending on the properties of the item model</span>\n    <span class=\"hljs-keyword\">if</span>  (item.get(<span class=\"hljs-string\">'isFoo'</span>)) {\n      <span class=\"hljs-keyword\">return</span> FooView;\n    }\n    <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> BarView;\n    }\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> collectionView = <span class=\"hljs-keyword\">new</span> MyCollectionView();\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">new</span> FooBar({\n  isFoo: <span class=\"hljs-literal\">true</span>\n});\n<span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-keyword\">new</span> FooBar({\n  isFoo: <span class=\"hljs-literal\">false</span>\n});\n\n<span class=\"hljs-comment\">// Renders a FooView</span>\ncollectionView.collection.add(foo);\n\n<span class=\"hljs-comment\">// Renders a BarView</span>\ncollectionView.collection.add(bar);\n</pre> <h3 id=\"collectionviews-childviewoptions\">\nCollectionView's <code>childViewOptions</code>\n</h3>\n<p>There may be scenarios where you need to pass data from your parentcollection view in to each of the childView instances. To do this, providea <code>childViewOptions</code> definition on your collection view as an objectliteral. This will be passed to the constructor of your childView as partof the <code>options</code>.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> ChildView = Mn.View.extend({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(options.foo); <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> CollectionView = Mn.CollectionView.extend({\n  childView: ChildView,\n\n  childViewOptions: {\n    foo: <span class=\"hljs-string\">'bar'</span>\n  }\n});\n</pre> <p>You can also specify the <code>childViewOptions</code> as a function, if you need tocalculate the values to return at runtime. The model will be passed intothe function should you need access to it when calculating<code>childViewOptions</code>. The function must return an object, and the attributesof the object will be copied to the <code>childView</code> instance's options.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> CollectionView = Mn.CollectionView.extend({\n  childViewOptions: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(model, index)</span> </span>{\n    <span class=\"hljs-comment\">// do some calculations based on the model</span>\n    <span class=\"hljs-keyword\">return</span> {\n      foo: <span class=\"hljs-string\">'bar'</span>,\n      childIndex: index\n    }\n  }\n});\n</pre> <h3 id=\"collectionviews-childvieweventprefix\">\nCollectionView's <code>childViewEventPrefix</code>\n</h3>\n<p>You can customize the event prefix for events that are forwardedthrough the collection view. To do this, set the <code>childViewEventPrefix</code>on the collection view. For more information on the <code>childViewEventPrefix</code> see<a href=\"#childview-event-bubbling-from-child-views\">\"childview:*\" event bubbling from child views</a></p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> CV = Mn.CollectionView.extend({\n  childViewEventPrefix: <span class=\"hljs-string\">'some:prefix'</span>\n});\n\n<span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-keyword\">new</span> CV({\n  collection: myCol\n});\n\nc.on(<span class=\"hljs-string\">'some:prefix:render'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n  <span class=\"hljs-comment\">// child view was rendered</span>\n});\n\nc.render();\n</pre> <p>The <code>childViewEventPrefix</code> can be provided in the view definition orin the constructor function call, to get a view instance.</p> <h3 id=\"collectionviews-childviewevents\">\nCollectionView's <code>childViewEvents</code>\n</h3>\n<p>A <code>childViewEvents</code> hash or method permits handling of child view events withoutmanually setting bindings. The values of the hash can either be a function or a stringmethod name on the collection view.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-comment\">// childViewEvents can be specified as a hash...</span>\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n\n  childViewEvents: {\n    <span class=\"hljs-comment\">// This callback will be called whenever a child is rendered or emits a `render` event</span>\n    render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view has been rendered.'</span>);\n    }\n  }\n});\n\n<span class=\"hljs-comment\">// ...or as a function that returns a hash.</span>\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n\n  childViewEvents: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> {\n      render: <span class=\"hljs-keyword\">this</span>.onChildRendered\n    }\n  },\n\n  onChildRendered: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view has been rendered.'</span>);\n  }\n});\n</pre> <p><code>childViewEvents</code> also catches custom events fired by a child view.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-comment\">// The child view fires a custom event, `show:message`</span>\n<span class=\"hljs-keyword\">var</span> ChildView = Mn.View.extend({\n\n  <span class=\"hljs-comment\">// Events hash defines local event handlers that in turn may call `triggerMethod`.</span>\n  events: {\n    <span class=\"hljs-string\">'click .button'</span>: <span class=\"hljs-string\">'onClickButton'</span>\n  },\n\n  <span class=\"hljs-comment\">// Triggers hash converts DOM events directly to view events catchable on the parent.</span>\n  <span class=\"hljs-comment\">// Note that `triggers` automatically pass the first argument as the child view.</span>\n  triggers: {\n    <span class=\"hljs-string\">'submit form'</span>: <span class=\"hljs-string\">'submit:form'</span>\n  },\n\n  onClickButton: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// Both `trigger` and `triggerMethod` events will be caught by parent.</span>\n    <span class=\"hljs-keyword\">this</span>.trigger(<span class=\"hljs-string\">'show:message'</span>, <span class=\"hljs-string\">'foo'</span>);\n    <span class=\"hljs-keyword\">this</span>.triggerMethod(<span class=\"hljs-string\">'show:message'</span>, <span class=\"hljs-string\">'bar'</span>);\n  }\n});\n\n<span class=\"hljs-comment\">// The parent uses childViewEvents to catch the child view's custom event</span>\n<span class=\"hljs-keyword\">var</span> ParentView = Mn.CollectionView.extend({\n\n  childView: ChildView,\n\n  childViewEvents: {\n    <span class=\"hljs-string\">'show:message'</span>: <span class=\"hljs-string\">'onChildShowMessage'</span>,\n    <span class=\"hljs-string\">'submit:form'</span>: <span class=\"hljs-string\">'onChildSubmitForm'</span>\n  },\n\n  onChildShowMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(message)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view fired show:message with '</span> + message);\n  },\n\n  onChildSubmitForm: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(childView)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view fired submit:form'</span>);\n  }\n});\n</pre> <h3 id=\"collectionviews-childviewtriggers\">\nCollectionView's <code>childViewTriggers</code>\n</h3>\n<p>A <code>childViewTriggers</code> hash or method permits proxying of child view events without manuallysetting bindings. The values of the hash should be a string of the event to trigger on the parent.</p> <p><code>childViewTriggers</code> is sugar on top of <a href=\"#collectionviews-childviewevents\"><code>childViewEvents</code></a> muchin the same way that <a href=\"#abstractviewtriggers\">View <code>triggers</code></a> are sugar for <a href=\"#abstractviewevents\">View <code>events</code></a>.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-comment\">// The child view fires a custom event, `show:message`</span>\n<span class=\"hljs-keyword\">var</span> ChildView = Mn.View.extend({\n\n  <span class=\"hljs-comment\">// Events hash defines local event handlers that in turn may call `triggerMethod`.</span>\n  events: {\n    <span class=\"hljs-string\">'click .button'</span>: <span class=\"hljs-string\">'onClickButton'</span>\n  },\n\n  <span class=\"hljs-comment\">// Triggers hash converts DOM events directly to view events catchable on the parent.</span>\n  <span class=\"hljs-comment\">// Note that `triggers` automatically pass the first argument as the child view.</span>\n  triggers: {\n    <span class=\"hljs-string\">'submit form'</span>: <span class=\"hljs-string\">'submit:form'</span>\n  },\n\n  onClickButton: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// Both `trigger` and `triggerMethod` events will be caught by parent.</span>\n    <span class=\"hljs-keyword\">this</span>.trigger(<span class=\"hljs-string\">'show:message'</span>, <span class=\"hljs-string\">'foo'</span>);\n    <span class=\"hljs-keyword\">this</span>.triggerMethod(<span class=\"hljs-string\">'show:message'</span>, <span class=\"hljs-string\">'bar'</span>);\n  }\n});\n\n<span class=\"hljs-comment\">// The parent uses childViewEvents to catch the child view's custom event</span>\n<span class=\"hljs-keyword\">var</span> ParentView = Mn.CollectionView.extend({\n\n  childView: ChildView,\n\n  childViewTriggers: {\n    <span class=\"hljs-string\">'show:message'</span>: <span class=\"hljs-string\">'child:show:message'</span>,\n    <span class=\"hljs-string\">'submit:form'</span>: <span class=\"hljs-string\">'child:submit:form'</span>\n  },\n\n  onChildShowMessage: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(message)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view fired show:message with '</span> + message);\n  },\n\n  onChildSubmitForm: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(childView)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'A child view fired submit:form'</span>);\n  }\n});\n</pre> <h2 id=\"collectionviews-emptyview\">\nCollectionView's <code>emptyView</code>\n</h2>\n<p>When a collection has no children, and you need to render a view other thanthe list of childViews, you can specify an <code>emptyView</code> attribute on yourcollection view. The <code>emptyView</code> just like the <a href=\"#collectionviews-childview\"><code>childView</code></a> can also be passed as an option on instantiation or can be afunction that returns the <code>emptyView</code>.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyEmptyView = Mn.View.extend({\n  template: _.template(<span class=\"hljs-string\">'Nothing to display.'</span>)\n});\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n  <span class=\"hljs-comment\">// ...</span>\n\n  emptyView: MyEmptyView\n});\n</pre> <h3 id=\"collectionviews-emptyviewoptions\">\nCollectionView's <code>emptyViewOptions</code>\n</h3>\n<p>Similar to <a href=\"#collectionviews-childview\"><code>childView</code></a> and <a href=\"#collectionviews-childviewoptions\"><code>childViewOptions</code></a>, there is an <code>emptyViewOptions</code> property that will be passed to the <code>emptyView</code> constructor. It can be provided as an object literal or as a function.</p> <p>If <code>emptyViewOptions</code> aren't provided the <code>CollectionView</code> will default to passing the <code>childViewOptions</code> to the <code>emptyView</code>.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> EmptyView = Mn.View({\n  initialize: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span></span>{\n    <span class=\"hljs-built_in\">console</span>.log(options.foo); <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> CollectionView = Mn.CollectionView({\n  emptyView: EmptyView,\n\n  emptyViewOptions: {\n    foo: <span class=\"hljs-string\">'bar'</span>\n  }\n});\n</pre> <h3 id=\"collectionviews-isempty\">\nCollectionView's <code>isEmpty</code>\n</h3>\n<p>If you want to control when the empty view is rendered, you can override<code>isEmpty</code>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n  isEmpty: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> </span>{\n    <span class=\"hljs-comment\">// some logic to calculate if the view should be rendered as empty</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.collection.length &lt; <span class=\"hljs-number\">2</span>;\n  }\n});\n</pre> <h2 id=\"collectionviews-render\">\nCollectionView's <code>render</code>\n</h2>\n<p>The <code>render</code> method of the collection view is responsible forrendering the entire collection. It loops through each of thechildren in the collection and renders them individually as a<code>childView</code>. By default when a <code>collectionView</code> is fully rendered it buffers the DOM changes for a single <a href=\"#collectionviews-attachbuffer\"><code>attachBuffer</code></a> DOM change.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({...});\n\n<span class=\"hljs-comment\">// all of the children views will now be rendered.</span>\n<span class=\"hljs-keyword\">new</span> MyCollectionView().render();\n</pre> <p>For more information on rendering techiniques see: <a href=\"#rendering-collectionviews\">Rendering <code>CollectionView</code>s</a>.</p> <h3 id=\"collectionview-automatic-rendering\">\nCollectionView: Automatic Rendering</h3>\n<p>After the initial render the collection view binds to the \"add\", \"remove\" and\"reset\" events of the collection that is specified.</p> <p>When the collection for the view is \"reset\", the view will call <code>render</code> onitself and re-render the entire collection.</p> <p>When a model is added to the collection, the collection view will render thatone model in to the collection of child views.</p> <p>When a model is removed from a collection (or destroyed / deleted), the collectionview will destroy and remove that model's child view.</p> <p>When the collection for the view is sorted, the view will automatically re-sort its child views.If the <a href=\"#collectionviews-reorderonsort\"><code>reorderOnSort</code></a> option is set it will attempt to reorder the DOM and do this without a full re-render, otherwise it will re-render if the order has changed. Please Note that if you apply a filter to the collection view and the filtered views change during a sort then it will always re-render.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> collection = <span class=\"hljs-keyword\">new</span> Bb.Collection();\n\n<span class=\"hljs-keyword\">var</span> MyChildView = Mn.View.extend({\n  template: <span class=\"hljs-literal\">false</span>\n});\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n  childView: MyChildView,\n  collection: collection,\n});\n\n<span class=\"hljs-keyword\">var</span> myCollectionView = <span class=\"hljs-keyword\">new</span> MyCollectionView();\n\n<span class=\"hljs-comment\">// Collection view will not re-render as it has not been rendered</span>\ncollection.reset([{foo: <span class=\"hljs-string\">'foo'</span>}]);\n\nmyCollectionView.render();\n\n<span class=\"hljs-comment\">// Collection view will re-render displaying the new model</span>\ncollection.reset([{foo: <span class=\"hljs-string\">'bar'</span>}]);\n</pre> <h3 id=\"collectionview-re-render-collection\">\nCollectionView: Re-render Collection</h3>\n<p>If you need to re-render the entire collection, you can call the<code>view.render</code> method. This method takes care of destroying all ofthe child views that may have previously been opened.</p> <h3 id=\"collectionviews-attachhtml\">\nCollectionView's <code>attachHtml</code>\n</h3>\n<p>By default the collection view will append the HTML of each ChildViewinto the element buffer, and then call jQuery's <code>.append</code> once at theend to move the HTML into the collection view's <code>el</code>.</p> <p>You can override this by specifying an <code>attachHtml</code> method in yourview definition. This method takes three parameters and has no returnvalue.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\nMn.CollectionView.extend({\n\n  <span class=\"hljs-comment\">// The default implementation:</span>\n  attachHtml: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(collectionView, childView, index)</span></span>{\n    <span class=\"hljs-keyword\">if</span> (collectionView._isBuffering) {\n      <span class=\"hljs-comment\">// buffering happens on reset events and initial renders</span>\n      <span class=\"hljs-comment\">// in order to reduce the number of inserts into the</span>\n      <span class=\"hljs-comment\">// document, which are expensive.</span>\n      collectionView._bufferedChildren.splice(index, <span class=\"hljs-number\">0</span>, childView);\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// If we've already rendered the main collection, append</span>\n      <span class=\"hljs-comment\">// the new child into the correct order if we need to. Otherwise</span>\n      <span class=\"hljs-comment\">// append to the end.</span>\n      <span class=\"hljs-keyword\">if</span> (!collectionView._insertBefore(childView, index)){\n        collectionView._insertAfter(childView);\n      }\n    }\n  }\n\n});\n</pre> <p>The first parameter is the instance of the collection view thatwill receive the HTML from the second parameter, the current childview instance.</p> <p>The third parameter, <code>index</code>, is the index of themodel that this <code>childView</code> instance represents, in the collectionthat the model came from. This is useful for understanding the sort order of the children.</p> <p>Overrides of <code>attachHtml</code> that don't take into account the elementbuffer will work fine, but won't take advantage of the 60x performanceincrease the buffer provides.</p> <h3 id=\"collectionviews-attachbuffer\">\nCollectionView's <code>attachBuffer</code>\n</h3>\n<p>When overriding <a href=\"#collectionviews-attachhtml\"><code>attachHtml</code></a> it may be necessary to also override how the buffer is attached. This method receives two parameters. The <code>collectionView</code> and the buffer HTML of all of the child views.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n  <span class=\"hljs-comment\">// The default implementation:</span>\n  <span class=\"hljs-comment\">// Called after all children have been appended into the buffer</span>\n  attachBuffer: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(collectionView, buffer)</span> </span>{\n    collectionView.$el.append(buffer);\n  }\n});\n</pre> <h2 id=\"collectionviews-destroy\">\nCollectionView's <code>destroy</code>\n</h2>\n<p><code>CollectionView</code> implements a <code>destroy</code> method which automaticallydestroys its children and cleans up listeners.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyChildView = Mn.View.extend({\n  template: _.template(<span class=\"hljs-string\">'ChildView'</span>),\n  onDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'I will get destroyed'</span>);\n  }\n})\n\n<span class=\"hljs-keyword\">var</span> myCollectionView = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  childView: MyChildView,\n  collection: <span class=\"hljs-keyword\">new</span> Bb.Collection([{ id: <span class=\"hljs-number\">1</span> }])\n});\n\nmyCollectionView.render();\n\nmyCollectionView.destroy(); <span class=\"hljs-comment\">// logs \"I will get destroyed\"</span>\n</pre> <h2 id=\"collectionviews-filter\">\nCollectionView's <code>filter</code>\n</h2>\n<p><code>CollectionView</code> allows for a custom <code>filter</code> option if you want to prevent some of theunderlying <code>collection</code>'s models from being rendered as child views.The filter function takes a model from the collection and returns a truthy value if the child should be rendered,and a falsey value if it should not.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  childView: SomeChildView,\n  emptyView: SomeEmptyView,\n  collection: <span class=\"hljs-keyword\">new</span> Bb.Collection([\n    { value: <span class=\"hljs-number\">1</span> },\n    { value: <span class=\"hljs-number\">2</span> },\n    { value: <span class=\"hljs-number\">3</span> },\n    { value: <span class=\"hljs-number\">4</span> }\n  ]),\n\n  <span class=\"hljs-comment\">// Only show views with even values</span>\n  filter: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(child, index, collection)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> child.get(<span class=\"hljs-string\">'value'</span>) % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>;\n  }\n});\n\n<span class=\"hljs-comment\">// renders the views with values '2' and '4'</span>\ncv.render();\n\n<span class=\"hljs-comment\">// change the filter</span>\n<span class=\"hljs-comment\">// renders the views with values '1' and '3'</span>\ncv.setFilter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(child, index, collection)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> child.get(<span class=\"hljs-string\">'value'</span>) % <span class=\"hljs-number\">2</span> !== <span class=\"hljs-number\">0</span>;\n});\n\n<span class=\"hljs-comment\">// renders all views</span>\ncv.removeFilter();\n</pre> <h3 id=\"collectionviews-setfilter\">\nCollectionView's <code>setFilter</code>\n</h3>\n<p>The <code>setFilter</code> method modifies the <code>CollectionView</code>'s filter attribute, andrenders the new <code>ChildViews</code> in a efficient way, instead ofrendering the whole DOM structure again.Passing <code>{ preventRender: true }</code> in the options argument will prevent the view being rendered.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\n<span class=\"hljs-keyword\">var</span> newFilter = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(child, index, collection)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> child.get(<span class=\"hljs-string\">'value'</span>) % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>;\n};\n\n<span class=\"hljs-comment\">// Note: the setFilter is preventing the automatic re-render</span>\ncv.setFilter(newFilter, { preventRender: <span class=\"hljs-literal\">true</span> });\n\n<span class=\"hljs-comment\">//Render the new state of the ChildViews instead of the whole DOM.</span>\ncv.render();\n</pre> <h3 id=\"collectionviews-removefilter\">\nCollectionView's <code>removeFilter</code>\n</h3>\n<p>This function is actually an alias of <code>setFilter(null, options)</code>. It is useful for removing filters.<code>removeFilter</code> also accepts <code>preventRender</code> as a option.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  collection: someCollection\n});\n\ncv.render();\n\ncv.setFilter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(child, index, collection)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> child.get(<span class=\"hljs-string\">'value'</span>) % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>;\n});\n\n<span class=\"hljs-comment\">//Remove the current filter without rendering again.</span>\ncv.removeFilter({ preventRender: <span class=\"hljs-literal\">true</span> });\n</pre> <h2 id=\"collectionviews-sort\">\nCollectionView's <code>sort</code>\n</h2>\n<p>By default the <code>CollectionView</code> will maintain a sorted collection's orderin the DOM. This behavior can be disabled by specifying <code>{sort: false}</code> on initialize. The <code>sort</code> flag cannot be changed after instantiation.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> myCollection = <span class=\"hljs-keyword\">new</span> Bb.Collection([\n  { id: <span class=\"hljs-number\">1</span> },\n  { id: <span class=\"hljs-number\">4</span> },\n  { id: <span class=\"hljs-number\">3</span> },\n  { id: <span class=\"hljs-number\">2</span> }\n]);\n\nmyCollection.comparator = <span class=\"hljs-string\">'id'</span>;\n\n<span class=\"hljs-keyword\">var</span> mySortedColView = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  <span class=\"hljs-comment\">//...</span>\n  collection: myCollection\n});\n\n<span class=\"hljs-keyword\">var</span> myUnsortedColView = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  <span class=\"hljs-comment\">//...</span>\n  collection: myCollection,\n  sort: <span class=\"hljs-literal\">false</span>\n});\n\nmySortedColView.render(); <span class=\"hljs-comment\">// 1 4 3 2</span>\nmyUnsortedColView.render(); <span class=\"hljs-comment\">// 1 4 3 2</span>\n\n<span class=\"hljs-comment\">// mySortedColView auto-renders 1 2 3 4</span>\n<span class=\"hljs-comment\">// myUnsortedColView has no change</span>\nmyCollection.sort();\n</pre> <h3 id=\"collectionviews-viewcomparator\">\nCollectionView's <code>viewComparator</code>\n</h3>\n<p><code>CollectionView</code> allows for a custom <code>viewComparator</code> option if you want your <code>CollectionView</code>'s children to be rendered with a different sort order than the underlying Backbone collection uses.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> cv = <span class=\"hljs-keyword\">new</span> Mn.CollectionView({\n  collection: someCollection,\n  viewComparator: <span class=\"hljs-string\">'otherFieldToSortOn'</span>\n});\n</pre> <p>The <code>viewComparator</code> can take any of the acceptable <code>Backbone.Collection</code><a href=\"http://backbonejs.org/#Collection-comparator\">comparator formats</a> -- a sortBy(pass a function that takes a single argument), as a sort (pass a comparatorfunction that expects two arguments), or as a string indicating the attribute tosort by.</p> <h3 id=\"collectionviews-getviewcomparator\">\nCollectionView's <code>getViewComparator</code>\n</h3>\n<p>Override this method to determine which <code>viewComparator</code> to use.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n  sortAsc: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(model)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> -model.get(<span class=\"hljs-string\">'order'</span>);\n  },\n  sortDesc: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(model)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> model.get(<span class=\"hljs-string\">'order'</span>);\n  },\n  getViewComparator: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// The collectionView's model</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.model.get(<span class=\"hljs-string\">'sorted'</span>) === <span class=\"hljs-string\">'ASC'</span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.sortAsc;\n    }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.sortDesc;\n  }\n});\n</pre> <h3 id=\"collectionviews-reorderonsort\">\nCollectionView's <code>reorderOnSort</code>\n</h3>\n<p>This option is useful when you have performance issues when you resort your <code>CollectionView</code>.Without this option, your <code>CollectionView</code> will be completely re-rendered, which can becostly if you have a large number of elements or if your <code>ChildView</code>s are complex. If this optionis activated, when you sort your <code>Collection</code>, there will be no re-rendering, only the DOM nodeswill be reordered. This can be a problem if your <code>ChildView</code>s use their collection's indexin their rendering. In this case, you cannot use this option as you need to re-render each<code>ChildView</code>.</p> <p>If you combine this option with a <a href=\"#collectionviews-filter\">filter</a> that changes the views that areto be displayed, <code>reorderOnSort</code> will be bypassed to render new children and remove those that are rejected by the filter.</p> <h3 id=\"collectionviews-reorder\">\nCollectionView's <code>reorder</code>\n</h3>\n<p>If <a href=\"#collectionviews-reorderonsort\"><code>reorderOnSort</code></a> is set to true, this function will be used instead of re-rendering all children. It can be called directly to prevent the collection from being completely re-rendered. This may only be useful if models are added or removed silently or if <a href=\"#collectionviews-sort\"><code>sort</code></a> was set to false on the <code>CollectionView</code>.</p> <h3 id=\"collectionviews-resortview\">\nCollectionView's <code>resortView</code>\n</h3>\n<p><a href=\"#collectionviews-sort\">By default</a> the <code>CollectionView</code> will maintain the order of its <code>collection</code>in the DOM. However on occasions the view may need to re-render to make thispossible, for example if you were to change the comparator on the collection.The <code>CollectionView</code> will re-render its children or <a href=\"#collectionviews-reorder\"><code>reorder</code></a> them depending on <a href=\"#collectionviews-reorderonsort\"><code>reorderOnSort</code></a>.Override this function if you need further customization.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyCollectionView = Mn.CollectionView.extend({\n  resortView: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// provide custom logic for rendering after sorting the collection</span>\n  }\n});\n</pre> <h2 id=\"events\">\nEvents</h2>\n<p>The <code>CollectionView</code>, like <code>View</code>, is able to trigger and respond to eventsoccurring during their lifecycle. The <a href=\"events\">Documentation for Events</a>has the complete documentation for how to set and handle events on views.</p> <h3 id=\"child-event-bubbling\">\nChild Event Bubbling</h3>\n<p>When a child view triggers an event, that event will bubble up one level to theparent collection view. For an example:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> Item = Mn.View.extend({\n  tagName: <span class=\"hljs-string\">'li'</span>,\n\n  triggers: {\n    <span class=\"hljs-string\">'click a'</span>: <span class=\"hljs-string\">'select:item'</span>\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> Collection = Mn.CollectionView.extend({\n  tagName: <span class=\"hljs-string\">'ul'</span>,\n\n  onChildviewSelectItem: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(childView)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'item selected: '</span> + childView.model.id);\n  }\n});\n</pre> <p>The event will receive a <code>childview:</code> prefix before going through the magicmethod binding logic. See the<a href=\"events#child-view-events\">Documentation for Child View Events</a> for moreinformation.</p> <h3 id=\"lifecycle-events\">\nLifecycle Events</h3>\n<p>The <code>CollectionView</code> has its own lifecycle around the standard <code>View</code> eventrendering lifecycle. This section covers the events that get triggered and whatthey indicate.</p> <h4>\nCreation Lifecycle</h4>\n<p>The <code>CollectionView</code> creation lifecycle can go down two paths depending onwhether the collection is populated or empty. The below table shows the order ofrendering events firing:</p> <table> <thead> <tr> <th style=\"text-align:center\">Order</th> <th>Event</th> </tr> </thead> <tbody> <tr> <td style=\"text-align:center\">1</td> <td><code>before:render</code></td> </tr> <tr> <td style=\"text-align:center\">2*</td> <td><code>before:render:empty</code></td> </tr> <tr> <td style=\"text-align:center\">2+</td> <td><code>before:render:children</code></td> </tr> <tr> <td style=\"text-align:center\">3</td> <td><code>before:add:child</code></td> </tr> <tr> <td style=\"text-align:center\">4</td> <td><code>add:child</code></td> </tr> <tr> <td style=\"text-align:center\">5*</td> <td><code>render:empty</code></td> </tr> <tr> <td style=\"text-align:center\">5+</td> <td><code>render:children</code></td> </tr> <tr> <td style=\"text-align:center\">6</td> <td><code>render</code></td> </tr> <tr> <td style=\"text-align:center\">7</td> <td><code>before:attach</code></td> </tr> <tr> <td style=\"text-align:center\">8</td> <td><code>attach</code></td> </tr> <tr> <td style=\"text-align:center\">9</td> <td><code>dom:refresh</code></td> </tr> </tbody> </table> <p>The events marked with \"*\" only fire on empty collections and events markedwith \"+\" fire on collections with items.</p> <h4>\nDestruction Lifecycle</h4>\n<p>When a <code>CollectionView</code> is destroyed it fires a series of events in order toreflect the different stages of the destruction process.</p> <table> <thead> <tr> <th style=\"text-align:center\">Order</th> <th>Event</th> </tr> </thead> <tbody> <tr> <td style=\"text-align:center\">1</td> <td><code>before:destroy</code></td> </tr> <tr> <td style=\"text-align:center\">2</td> <td><code>before:detach</code></td> </tr> <tr> <td style=\"text-align:center\">3</td> <td><code>detach</code></td> </tr> <tr> <td style=\"text-align:center\">4</td> <td><code>before:destroy:children</code></td> </tr> <tr> <td style=\"text-align:center\">5*</td> <td><code>before:remove:empty</code></td> </tr> <tr> <td style=\"text-align:center\">5+</td> <td><code>before:remove:child</code></td> </tr> <tr> <td style=\"text-align:center\">6*</td> <td><code>remove:child</code></td> </tr> <tr> <td style=\"text-align:center\">6+</td> <td><code>remove:empty</code></td> </tr> <tr> <td style=\"text-align:center\">7</td> <td><code>destroy</code></td> </tr> </tbody> </table> <p>The events marked with \"*\" only fire on empty collections and events markedwith \"+\" fire on collections with items.</p> <h4>\nCreation Events</h4>\n<h5>\nCollectionView <code>before:render</code>\n</h5>\n<p>Triggers before the <code>CollectionView</code> render process starts. See the<a href=\"#marionette.view.html#view-before-render\"><code>before:render</code> Documentation</a> for anexample.</p> <h5>\nCollectionView <code>before:render:empty</code>\n</h5>\n<p>Triggers just before rendering a collection <code>emptyView</code>. This won't be fired ifthe collection has 1 or more elements in.</p> <h5>\nCollectionView <code>before:render:children</code>\n</h5>\n<p>This event fires just before rendering the children in the <code>CollectionView</code>.This only fires if the collection has at least one item.</p> <h5>\nCollectionView <code>before:add:child</code>\n</h5>\n<p>This event fires before each child is added to the view. If the collection isempty, this fires exactly once for the <code>emptyView</code>.</p> <h5>\nCollectionView <code>add:child</code>\n</h5>\n<p>This event fires after each child is added to the view. This fires once for eachitem in the attached collection.</p> <p>If the collection is empty, this event fires exactly once for the <code>emptyView</code>.</p> <h5>\nCollectionView <code>render:empty</code>\n</h5>\n<p>This event fires once the <code>emptyView</code> has been rendered. This will only fire ifthe attached collection is empty.</p> <h5>\nCollectionView <code>render:children</code>\n</h5>\n<p>This event fires once all the collection's child views have been rendered. Thisonly fires if the collection has at least one item. This may also fire when<a href=\"#collectionviews-reorderonsort\"><code>reorderOnSort</code></a> is false:</p> <pre data-language=\"javascript\">var Bb = require('backbone');\nvar Mn = require('backbone.marionette');\n\nvar MyView = Mn.CollectionView.extend({\n  onRenderChildren: function({\n    console.log('The collectionview children have been rendered');\n  })\n});\n\nvar myView = new MyView({\n  collection: new Bb.Collection([{ id: 1 }]);\n});\n\nmyView.render();\n</pre> <h5>\nCollectionView <code>render</code>\n</h5>\n<p>Fires when the collection has completely finished rendering. See the<a href=\"marionette.view#view-render\"><code>render</code> Documentation</a> for more information.</p> <h4>\nDestruction Events</h4>\n<h5>\nCollectionView <code>before:destroy</code>\n</h5>\n<p>Fires as the destruction process is beginning. This is best used to perform anynecessary cleanup within the <code>CollectionView</code>.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.CollectionView.extend({\n  onBeforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'The CollectionView is about to be destroyed'</span>);\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView();\n\nmyView.destroy();\n</pre> <h5>\nCollectionView <code>before:detach</code>\n</h5>\n<p>Fires just before the <code>CollectionView</code> is removed from the DOM. If you need toremove any event handlers or UI modifications, this would be the best time to dothat.</p> <h5>\nCollectionView <code>detach</code>\n</h5>\n<p>Fires just after the <code>CollectionView</code> is removed from the DOM. The view'selements will still exist in memory if you need to access them.</p> <h5>\nCollectionView <code>before:destroy:children</code>\n</h5>\n<p>This is triggered just before the <code>childView</code> items are destroyed.</p> <p>Triggered when the <code>collectionView</code> is destroyed or before the <code>collectionView</code>'s children are re-rendered.</p> <h5>\nCollectionView <code>before:remove:empty</code>\n</h5>\n<p>This is triggered just before the <code>emptyView</code> is removed from the<code>CollectionView</code>. <em>This only fires if the attached <code>collection</code> has no items.</em></p> <p>The <code>emptyView</code> will then go through the its own<a href=\"marionette.view#view-destruction-lifecycle\">destruction lifecycle</a></p> <h5>\nCollectionView <code>before:remove:child</code>\n</h5>\n<p>This is triggered for each <code>childView</code> that is removed from the<code>CollectionView</code>. This can <em>only</em> fire if the <code>collection</code> contains items.</p> <p>Each item in the <code>CollectionView</code> will undergo the<a href=\"marionette.view#view-destruction-lifecycle\">destruction lifecycle</a></p> <h5>\nCollectionView <code>remove:empty</code>\n</h5>\n<p>Fired after the <code>emptyView</code> has been removed and its destruction lifecycle hasbeen completed. <em>This only fires if the attached <code>collection</code> has no items.</em></p> <h5>\nCollectionView <code>remove:child</code>\n</h5>\n<p>Fired for each view that is removed from the <code>CollectionView</code>. This can onlyfire if the <code>collection</code> has items.</p> <h5>\nCollectionView <code>destroy</code>\n</h5>\n<p>Fired once the <code>CollectionView</code> has been destroyed and no longer exists.</p> <h4>\nOther Events</h4>\n<p>Collection views can fire other events as part of their normal use.</p> <h5>\n\"reorder\" / \"before:reorder\" events</h5>\n<p>When <a href=\"#collectionviews-resortview\"><code>reorderOnSort</code></a> is set to <code>true</code>, theseevents are fired for the reordering of the collection.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> MyView = Mn.CollectionView.extend({...});\n\n<span class=\"hljs-keyword\">var</span> myCol = <span class=\"hljs-keyword\">new</span> Bb.Collection({ comparator: ... })\n<span class=\"hljs-keyword\">var</span> myView = <span class=\"hljs-keyword\">new</span> MyView({ reorderOnSort: <span class=\"hljs-literal\">true</span> });\n\nmyView.render();\nmyCol.comparator = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.get(<span class=\"hljs-string\">'foo'</span>); };\n\nmyView.on({\n  <span class=\"hljs-string\">'remove:empty'</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'the collection view has been reordered following its collection'</span>);\n  },\n  <span class=\"hljs-string\">'before:remove:empty'</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'the collection view is about to be reordered'</span>);\n  }\n});\n\nmyCol.sort()\n</pre> <h2 id=\"rendering-collectionview-s\">\nRendering <code>CollectionView</code>s</h2>\n<p>Marionette 3 has completely removed the <code>CompositeView</code> in favor of making the<code>View</code> and <code>CollectionView</code> a lot more flexible. This section will cover themost common use cases for <code>CollectionView</code> and how to replace <code>CompositeView</code>.</p> <h3 id=\"rendering-lists\">\nRendering Lists</h3>\n<p>Lists are possibly the simplest use of <code>CollectionView</code> - simply set a<code>childView</code> option:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> ListItemView = Mn.View.extend({\n  tagName: <span class=\"hljs-string\">'li'</span>,\n  template: <span class=\"hljs-string\">'#list-item-text'</span>\n});\n\n<span class=\"hljs-keyword\">var</span> ListView = Mn.View.extend({\n  tagName: <span class=\"hljs-string\">'ul'</span>,\n  className: <span class=\"hljs-string\">'list-unstyled'</span>,\n\n  childView: ListItemView\n});\n\n<span class=\"hljs-keyword\">var</span> list = <span class=\"hljs-keyword\">new</span> Bb.Collection([\n  {id: <span class=\"hljs-number\">1</span>, text: <span class=\"hljs-string\">'My text'</span>},\n  {id: <span class=\"hljs-number\">2</span>, text: <span class=\"hljs-string\">'Another Item'</span>}\n]);\n\n<span class=\"hljs-keyword\">var</span> listView = <span class=\"hljs-keyword\">new</span> ListView({\n  collection: list\n});\n\nlistview.render();\n</pre> <p>With the template:</p> <pre>&lt;%- text %&gt;\n</pre>\n<p>This will render the following:</p> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ul</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"list-unstyled\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">li</span>&gt;</span>My text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">li</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">li</span>&gt;</span>Another Item<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ul</span>&gt;</span>\n</pre> <h3 id=\"rendering-tables\">\nRendering Tables</h3>\n<p>Marionette 3 introduced a major improvement to <code>View</code> to make it possible toimplement tables using only <code>View</code> and <code>CollectionView</code>. This section willdemonstrate how to build a table in Marionette 3, with the equivalent inMarionette 2 using <code>CompositeView</code>.</p> <h4>\nTables Using Marionette 2</h4>\n<p><strong><em>The following code is deprecated and for demonstration purposes only </em></strong></p> <p>To build a table in Marionette 2 requires the <code>CompositeView</code> which we'll buildas such:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> RowView = Mn.LayoutView.extend({\n  tagName: <span class=\"hljs-string\">'tr'</span>,\n  template: <span class=\"hljs-string\">'#table-row'</span>\n});\n\n<span class=\"hljs-keyword\">var</span> TableView = Mn.CompositeView.extend({\n  tagName: <span class=\"hljs-string\">'table'</span>,\n  className: <span class=\"hljs-string\">'table table-hover'</span>,\n  template: <span class=\"hljs-string\">'#table'</span>,\n  childView: RowView,\n  childViewContainer: <span class=\"hljs-string\">'tbody'</span>\n});\n\n<span class=\"hljs-keyword\">var</span> list = <span class=\"hljs-keyword\">new</span> Bb.Collection([\n  {id: <span class=\"hljs-number\">1</span>, text: <span class=\"hljs-string\">'My text'</span>},\n  {id: <span class=\"hljs-number\">2</span>, text: <span class=\"hljs-string\">'Another Item'</span>}\n]);\n\n<span class=\"hljs-keyword\">var</span> myTable = <span class=\"hljs-keyword\">new</span> TableView({\n  collection: list\n});\n\nmyTable.render();\n</pre> <p>Given the following <code>#table</code> and <code>#table-row</code> templates:</p> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">thead</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tr</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">th</span>&gt;</span>ID<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">th</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">th</span>&gt;</span>Body<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">th</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tr</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">thead</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tbody</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tbody</span>&gt;</span>\n</pre> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">td</span>&gt;</span><span class=\"vbscript\">&lt;%- id %&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">td</span>&gt;</span><span class=\"vbscript\">&lt;%- text %&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n</pre> <p>Will render the following:</p> <pre data-language=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">table</span> <span class=\"hljs-attribute\">class</span>=<span class=\"hljs-value\">\"table table-hover\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">thead</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tr</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">th</span>&gt;</span>ID<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">th</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">th</span>&gt;</span>Body<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">th</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tr</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">thead</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tbody</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tr</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">td</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">td</span>&gt;</span>My text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tr</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">tr</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">td</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">td</span>&gt;</span>Another Item<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">td</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tr</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">tbody</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">table</span>&gt;</span>\n</pre> <h2 id=\"\">\n#</h2>\n<p>A major downside of this method was that it was impossible to add extra regionsinside the <code>CompositeView</code> - if a header item needed to be re-rendered based onuser input, then the entire table must be re-rendered, or the DOM must bemanipulated with <code>ui</code> items.</p> <p>To resolve this issue, Marionette 3 improves the <code>View</code> to make it possible tobuild tables without <code>CompositeView</code>.</p> <h4>\nTables Using Marionette 3</h4>\n<p>Marionette 3 doesn't use <code>CompositeView</code> any more. We now build tables using<code>View</code>s and <code>regions</code>. The following code will render the same table as in<a href=\"#tables-using-marionette-2\">Marionette 2</a>:</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> RowView = Mn.View.extend({\n  tagName: <span class=\"hljs-string\">'tr'</span>,\n  template: <span class=\"hljs-string\">'#row-template'</span>\n});\n\n<span class=\"hljs-keyword\">var</span> TableBody = Mn.CollectionView.extend({\n  tagName: <span class=\"hljs-string\">'tbody'</span>,\n  childView: RowView\n});\n\n<span class=\"hljs-keyword\">var</span> TableView = Mn.View.extend({\n  tagName: <span class=\"hljs-string\">'table'</span>,\n  className: <span class=\"hljs-string\">'table table-hover'</span>,\n  template: <span class=\"hljs-string\">'#table'</span>,\n\n  regions: {\n    body: {\n      el: <span class=\"hljs-string\">'tbody'</span>,\n      replaceElement: <span class=\"hljs-literal\">true</span>\n    }\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'body'</span>, <span class=\"hljs-keyword\">new</span> TableBody({\n      collection: <span class=\"hljs-keyword\">this</span>.collection\n    }));\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> list = <span class=\"hljs-keyword\">new</span> Bb.Collection([\n  {id: <span class=\"hljs-number\">1</span>, text: <span class=\"hljs-string\">'My text'</span>},\n  {id: <span class=\"hljs-number\">2</span>, text: <span class=\"hljs-string\">'Another Item'</span>}\n]);\n\n<span class=\"hljs-keyword\">var</span> myTable = <span class=\"hljs-keyword\">new</span> TableView({\n  collection: list\n});\n\nmyTable.render();\n</pre> <p>We can leave the templates as-is for this example. The major advantage of thisstyle is that we can create a region in any part of <code>TableView</code> as well as in<code>RowView</code> and treat it just as any independent widget.</p> <h3 id=\"rendering-trees\">\nRendering Trees</h3>\n<p>Tree structures are extremely useful layouts for nesting the same type of dataover and over. A common example of this would be the Windows Explorer filepicker.</p> <h4>\nTrees in Marionette 2</h4>\n<pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> TreeView = Mn.CompositeView.extend({\n  tagName: <span class=\"hljs-string\">'ul'</span>,\n  template: <span class=\"hljs-string\">'#tree-template'</span>\n});\n\n<span class=\"hljs-keyword\">var</span> TreeRoot = Mn.CollectionView.extend({\n  tagName: <span class=\"hljs-string\">'ul'</span>,\n  childView: TreeView\n});\n\n\n<span class=\"hljs-keyword\">var</span> tree = <span class=\"hljs-keyword\">new</span> Bb.Collection([\n  {\n    id: <span class=\"hljs-number\">5</span>,\n    nodes: [\n      {id: <span class=\"hljs-number\">9</span>, nodes: []},\n      {id: <span class=\"hljs-number\">1</span>, nodes: [...]}\n    ],\n  },\n  {\n    id: <span class=\"hljs-number\">12</span>,\n    nodes: []\n  }\n]);\n\n<span class=\"hljs-keyword\">new</span> TreeRoot({\n  collection: tree\n});\n</pre> <p>In Marionette 2, the <code>CompositeView</code> defaults to setting <code>childView</code> to itself.While good for building tree structures, this behavior changed for Marionette 3with the introduction of a more general view.</p> <h4>\nTrees in Marionette 3</h4>\n<p>As in tables, trees in Marionette 3 require us to combine <code>View</code> and<code>CollectionView</code> to build up the tree in a more explicit manner than theimplicit version provided by Marionette 2.</p> <pre data-language=\"javascript\"><span class=\"hljs-keyword\">var</span> Bb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone'</span>);\n<span class=\"hljs-keyword\">var</span> Mn = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'backbone.marionette'</span>);\n\n<span class=\"hljs-keyword\">var</span> TreeNode = Mn.View.extend({\n  tagName: <span class=\"hljs-string\">'li'</span>,\n  template: <span class=\"hljs-string\">'#tree-template'</span>,\n\n  regions: {\n    tree: {\n      el: <span class=\"hljs-string\">'ul'</span>,\n      replaceElement: <span class=\"hljs-literal\">true</span>\n    }\n  },\n\n  onRender: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.showChildView(<span class=\"hljs-string\">'tree'</span>, <span class=\"hljs-keyword\">new</span> TreeView({\n      collection: <span class=\"hljs-keyword\">new</span> Bb.Collection(<span class=\"hljs-keyword\">this</span>.model.get(<span class=\"hljs-string\">'nodes'</span>))\n    }));\n  }\n});\n\n<span class=\"hljs-keyword\">var</span> TreeView = Mn.CollectionView.extend({\n  tagName: <span class=\"hljs-string\">'ul'</span>,\n  childView: TreeNode\n});\n\n<span class=\"hljs-keyword\">var</span> tree = <span class=\"hljs-keyword\">new</span> Bb.Collection([\n  {\n    id: <span class=\"hljs-number\">5</span>,\n    nodes: [\n      {id: <span class=\"hljs-number\">9</span>, nodes: []},\n      {id: <span class=\"hljs-number\">1</span>, nodes: [...]}\n    ],\n  },\n  {\n    id: <span class=\"hljs-number\">12</span>,\n    nodes: []\n  }\n]);\n\n<span class=\"hljs-keyword\">new</span> TreeView({\n  collection: tree\n});\n</pre> <p>This more explicit style gives us two major benefits:</p> <ul> <li>Fewer bugs - it's no longer possible to accidentally create a tree structure</li> <li>More regions to hook different views in, something that's impossible with<br><code>CompositeView</code>\n</li> </ul> <p>For getting advanced information about filtering, sorting or managing <code>CollectionView</code> look at<a href=\"marionette.collectionviewadvanced\">Advanced CollectionView usage</a></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>\n    <a href=\"http://marionettejs.com/docs/v3.0.0/marionette.collectionview.html\" class=\"_attribution-link\">http://marionettejs.com/docs/v3.0.0/marionette.collectionview.html</a>\n  </p>\n</div>\n"}