{"index":"<h1>How to use</h1> <h3 id=\"installing\">Installing</h3> <pre data-language=\"javascript\">$ npm install socket.io</pre> <h3 id=\"using-with-node-http-server\">Using with Node http server</h3> <div class=\"ezcol ezcol-one-half\"> <h4 id=\"server-app-js\">Server (app.js)</h4> <pre data-language=\"javascript\">var app = require('http').createServer(handler)\r\nvar io = require('socket.io')(app);\r\nvar fs = require('fs');\r\n\r\napp.listen(80);\r\n\r\nfunction handler (req, res) {\r\n  fs.readFile(__dirname + '/index.html',\r\n  function (err, data) {\r\n    if (err) {\r\n      res.writeHead(500);\r\n      return res.end('Error loading index.html');\r\n    }\r\n\r\n    res.writeHead(200);\r\n    res.end(data);\r\n  });\r\n}\r\n\r\nio.on('connection', function (socket) {\r\n  socket.emit('news', { hello: 'world' });\r\n  socket.on('my other event', function (data) {\r\n    console.log(data);\r\n  });\r\n});</pre> </div> <div class=\"ezcol ezcol-one-half ezcol-last\"> <h4 id=\"client-index-html\">Client (index.html)</h4> <pre data-language=\"html\">&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;\r\n&lt;script&gt;\r\n  var socket = io('http://localhost');\r\n  socket.on('news', function (data) {\r\n    console.log(data);\r\n    socket.emit('my other event', { my: 'data' });\r\n  });\r\n&lt;/script&gt;</pre> </div>\n <h3 id=\"using-with-express-3-4\">Using with Express 3/4</h3> <div class=\"ezcol ezcol-one-half\"> <h4 id=\"server-app-js\">Server (app.js)</h4> <pre data-language=\"javascript\">var app = require('express')();\r\nvar server = require('http').Server(app);\r\nvar io = require('socket.io')(server);\r\n\r\nserver.listen(80);\r\n\r\napp.get('/', function (req, res) {\r\n  res.sendfile(__dirname + '/index.html');\r\n});\r\n\r\nio.on('connection', function (socket) {\r\n  socket.emit('news', { hello: 'world' });\r\n  socket.on('my other event', function (data) {\r\n    console.log(data);\r\n  });\r\n});</pre> </div> <div class=\"ezcol ezcol-one-half ezcol-last\"> <h4 id=\"client-index-html\">Client (index.html)</h4> <pre data-language=\"html\">&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;\r\n&lt;script&gt;\r\n  var socket = io.connect('http://localhost');\r\n  socket.on('news', function (data) {\r\n    console.log(data);\r\n    socket.emit('my other event', { my: 'data' });\r\n  });\r\n&lt;/script&gt;</pre> </div>\n <h3 id=\"using-with-the-express-framework\">Using with the Express framework</h3> <div class=\"ezcol ezcol-one-half\"> <h4 id=\"server-app-js\">Server (app.js)</h4> <pre data-language=\"javascript\">var app = require('express').createServer();\r\nvar io = require('socket.io')(app);\r\n\r\napp.listen(80);\r\n\r\napp.get('/', function (req, res) {\r\n  res.sendfile(__dirname + '/index.html');\r\n});\r\n\r\nio.on('connection', function (socket) {\r\n  socket.emit('news', { hello: 'world' });\r\n  socket.on('my other event', function (data) {\r\n    console.log(data);\r\n  });\r\n});</pre> </div> <div class=\"ezcol ezcol-one-half ezcol-last\"> <h4 id=\"client-index-html\">Client (index.html)</h4> <pre data-language=\"html\">&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;\r\n&lt;script&gt;\r\n  var socket = io.connect('http://localhost');\r\n  socket.on('news', function (data) {\r\n    console.log(data);\r\n    socket.emit('my other event', { my: 'data' });\r\n  });\r\n&lt;/script&gt;</pre> </div>\n <h3 id=\"sending-and-receiving-events\">Sending and receiving events</h3> <p>Socket.IO allows you to emit and receive custom events. Besides <code>connect</code>, <code>message</code> and <code>disconnect</code>, you can emit custom events:</p> <h4 id=\"server\">Server</h4> <pre data-language=\"javascript\">// note, io(&lt;port&gt;) will create a http server for you\nvar io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  io.emit('this', { will: 'be received by everyone'});\n\n  socket.on('private message', function (from, msg) {\n    console.log('I received a private message by ', from, ' saying ', msg);\n  });\n\n  socket.on('disconnect', function () {\n    io.emit('user disconnected');\n  });\n});</pre> <h3 id=\"restricting-yourself-to-a-namespace\">Restricting yourself to a namespace</h3> <p>If you have control over all the messages and events emitted for a particular application, using the default / namespace works. If you want to leverage 3rd-party code, or produce code to share with others, socket.io provides a way of namespacing a socket.</p> <p>This has the benefit of <code>multiplexing</code> a single connection. Instead of socket.io using two <code>WebSocket</code> connections, it’ll use one.</p> <div class=\"ezcol ezcol-one-half\"> <h4 id=\"server-app-js\">Server (app.js)</h4> <pre data-language=\"javascript\">var io = require('socket.io')(80);\r\nvar chat = io\r\n  .of('/chat')\r\n  .on('connection', function (socket) {\r\n    socket.emit('a message', {\r\n        that: 'only'\r\n      , '/chat': 'will get'\r\n    });\r\n    chat.emit('a message', {\r\n        everyone: 'in'\r\n      , '/chat': 'will get'\r\n    });\r\n  });\r\n\r\nvar news = io\r\n  .of('/news')\r\n  .on('connection', function (socket) {\r\n    socket.emit('item', { news: 'item' });\r\n  });</pre> </div> <div class=\"ezcol ezcol-one-half ezcol-last\"> <h4 id=\"client-index-html\">Client (index.html)</h4> <pre data-language=\"html\">&lt;script&gt;\r\n  var chat = io.connect('http://localhost/chat')\r\n    , news = io.connect('http://localhost/news');\r\n  \r\n  chat.on('connect', function () {\r\n    chat.emit('hi!');\r\n  });\r\n  \r\n  news.on('news', function () {\r\n    news.emit('woot');\r\n  });\r\n&lt;/script&gt;</pre> </div>\n <h3 id=\"sending-volatile-messages\">Sending volatile messages</h3> <p>Sometimes certain messages can be dropped. Let’s say you have an app that shows realtime tweets for the keyword <code>bieber</code>.</p> <p>If a certain client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle), if they doesn’t receive ALL the tweets related to bieber your application won’t suffer.</p> <p>In that case, you might want to send those messages as volatile messages.</p> <h4 id=\"server\">Server</h4> <pre data-language=\"javascript\">var io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  var tweets = setInterval(function () {\n    getBieberTweet(function (tweet) {\n      socket.volatile.emit('bieber tweet', tweet);\n    });\n  }, 100);\n\n  socket.on('disconnect', function () {\n    clearInterval(tweets);\n  });\n});</pre> <h3 id=\"sending-and-getting-data-acknowledgements\">Sending and getting data (acknowledgements)</h3> <p>Sometimes, you might want to get a callback when the client confirmed the message reception.</p> <p>To do this, simply pass a function as the last parameter of <code>.send</code> or <code>.emit</code>. What’s more, when you use <code>.emit</code>, the acknowledgement is done by you, which means you can also pass data along:</p> <div class=\"ezcol ezcol-one-half\"> <h4 id=\"server-app-js\">Server (app.js)</h4> <pre data-language=\"javascript\">var io = require('socket.io')(80);\r\n\r\nio.on('connection', function (socket) {\r\n  socket.on('ferret', function (name, fn) {\r\n    fn('woot');\r\n  });\r\n});</pre> </div> <div class=\"ezcol ezcol-one-half ezcol-last\"> <h4 id=\"client-index-html\">Client (index.html)</h4> <pre data-language=\"html\">&lt;script&gt;\r\n  var socket = io(); // TIP: io() with no args does auto-discovery\r\n  socket.on('connect', function () { // TIP: you can avoid listening on `connect` and listen on events directly too!\r\n    socket.emit('ferret', 'tobi', function (data) {\r\n      console.log(data); // data will be 'woot'\r\n    });\r\n  });\r\n&lt;/script&gt;</pre> </div>\n <h3 id=\"broadcasting-messages\">Broadcasting messages</h3> <p>To broadcast, simply add a <code>broadcast</code> flag to <code>emit</code> and <code>send</code> method calls. Broadcasting means sending a message to everyone else except for the socket that starts it.</p> <h4 id=\"server\">Server</h4> <pre data-language=\"javascript\">var io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  socket.broadcast.emit('user connected');\n});</pre> <h3 id=\"using-it-just-as-a-cross-browser-websocket\">Using it just as a cross-browser WebSocket</h3> <p>If you just want the WebSocket semantics, you can do that too. Simply leverage <code>send</code> and listen on the <code>message</code> event:</p> <div class=\"ezcol ezcol-one-half\"> <h4 id=\"server-app-js\">Server (app.js)</h4> <pre data-language=\"javascript\">var io = require('socket.io')(80);\r\n\r\nio.on('connection', function (socket) {\r\n  socket.on('message', function () { });\r\n  socket.on('disconnect', function () { });\r\n});</pre> </div> <div class=\"ezcol ezcol-one-half ezcol-last\"> <h4 id=\"client-index-html\">Client (index.html)</h4> <pre data-language=\"html\">&lt;script&gt;\r\n  var socket = io('http://localhost/');\r\n  socket.on('connect', function () {\r\n    socket.send('hi');\r\n\r\n    socket.on('message', function (msg) {\r\n      // my msg\r\n    });\r\n  });\r\n&lt;/script&gt;</pre> </div>\n <p>If you don’t care about reconnection logic and such, take a look at <a href=\"https://github.com/Automattic/engine.io\">Engine.IO</a>, which is the WebSocket semantics transport layer Socket.IO uses.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014&ndash;2015 Automattic<br>Licensed under the MIT License.<br>\n    <a href=\"http://socket.io/docs/\" class=\"_attribution-link\">http://socket.io/docs/</a>\n  </p>\n</div>\n","server-api":"<h1>Server API</h1> <h3 id=\"server\">Server</h3> <p>Exposed by <code>require('socket.io')</code>.</p> <h3 id=\"server\">Server()</h3> <p>Creates a new <code>Server</code>. Works with and without <code>new</code>:</p> <pre data-language=\"javascript\">var io = require('socket.io')();\n// or\nvar Server = require('socket.io');\nvar io = new Server();</pre> <h3 id=\"server-opts-object\">Server(opts:Object)</h3> <p>Optionally, the first or second argument (see below) of the <code>Server</code> constructor can be an options object.</p> <p>The following options are supported:</p> <ul> <li>\n<code>serveClient</code> sets the value for Server#serveClient()</li> <li>\n<code>path</code> sets the value for Server#path()</li> </ul> <p>The same options passed to socket.io are always passed to the <code>engine.io</code> <code>Server</code> that gets created. See engine.io <a href=\"https://github.com/learnboost/engine.io#methods-1\">options</a> as reference.</p> <h3 id=\"server-srv-http-server-opts-object\">Server(srv:http#Server, opts:Object)</h3> <p>Creates a new <code>Server</code> and attaches it to the given <code>srv</code>. Optionally <code>opts</code> can be passed.</p> <h3 id=\"server-port-number-opts-object\">Server(port:Number, opts:Object)</h3> <p>Binds socket.io to a new <code>http.Server</code> that listens on <code>port</code>.</p> <h3 id=\"server-serveclient-v-boolean-server\">Server#serveClient(v:Boolean):Server</h3> <p>If <code>v</code> is <code>true</code> the attached server (see <code>Server#attach</code>) will serve the client files. Defaults to <code>true</code>.</p> <p>This method has no effect after <code>attach</code> is called.</p> <pre data-language=\"javascript\">// pass a server and the `serveClient` option\nvar io = require('socket.io')(http, { serveClient: false });\n\n// or pass no server and then you can call the method\nvar io = require('socket.io')();\nio.serveClient(false);\nio.attach(http);</pre> <p>If no arguments are supplied this method returns the current value.</p> <h3 id=\"server-path-v-string-server\">Server#path(v:String):Server</h3> <p>Sets the path <code>v</code> under which <code>engine.io</code> and the static files will be served. Defaults to <code>/socket.io</code>.</p> <p>If no arguments are supplied this method returns the current value.</p> <h3 id=\"server-adapter-v-adapter-server\">Server#adapter(v:Adapter):Server</h3> <p>Sets the adapter <code>v</code>. Defaults to an instance of the <code>Adapter</code> that ships with socket.io which is memory based. See <a href=\"https://github.com/learnboost/socket.io-adapter\">socket.io-adapter</a>.</p> <p>If no arguments are supplied this method returns the current value.</p> <h3 id=\"server-origins-v-string-server\">Server#origins(v:String):Server</h3> <p>Sets the allowed origins <code>v</code>. Defaults to any origins being allowed.</p> <p>If no arguments are supplied this method returns the current value.</p> <h3 id=\"server-sockets-namespace\">Server#sockets:Namespace</h3> <p>The default (<code>/</code>) namespace.</p> <h3 id=\"server-attach-srv-http-server-opts-object-server\">Server#attach(srv:http#Server, opts:Object):Server</h3> <p>Attaches the <code>Server</code> to an engine.io instance on <code>srv</code> with the supplied <code>opts</code> (optionally).</p> <h3 id=\"server-attach-port-number-opts-object-server\">Server#attach(port:Number, opts:Object):Server</h3> <p>Attaches the <code>Server</code> to an engine.io instance that is bound to <code>port</code> with the given <code>opts</code> (optionally).</p> <h3 id=\"server-listen\">Server#listen</h3> <p>Synonym of <code>Server#attach</code>.</p> <h3 id=\"server-bind-srv-engine-server-server\">Server#bind(srv:engine#Server):Server</h3> <p>Advanced use only. Binds the server to a specific engine.io <code>Server</code> (or compatible API) instance.</p> <h3 id=\"server-onconnection-socket-engine-socket-server\">Server#onconnection(socket:engine#Socket):Server</h3> <p>Advanced use only. Creates a new <code>socket.io</code> client from the incoming engine.io (or compatible API) <code>socket</code>.</p> <h3 id=\"server-of-nsp-string-namespace\">Server#of(nsp:String):Namespace</h3> <p>Initializes and retrieves the given <code>Namespace</code> by its pathname identifier <code>nsp</code>.</p> <p>If the namespace was already initialized it returns it right away.</p> <h3 id=\"server-emit\">Server#emit</h3> <p>Emits an event to all connected clients. The following two are equivalent:</p> <pre data-language=\"javascript\">var io = require('socket.io')();\nio.sockets.emit('an event sent to all connected clients');\nio.emit('an event sent to all connected clients');</pre> <p>For other available methods, see <code>Namespace</code> below.</p> <h3 id=\"server-use\">Server#use</h3> <p>See <code>Namespace#use</code> below.</p> <h3 id=\"namespace\">Namespace</h3> <p>Represents a pool of sockets connected under a given scope identified by a pathname (eg: <code>/chat</code>).</p> <p>By default the client always connects to <code>/</code>.</p> <h4 id=\"events\">Events</h4> <ul> <li>\n<code>connection</code> / <code>connect</code>. Fired upon a connection. <p>Parameters:</p> <ul> <li>\n<code>Socket</code> the incoming socket.</li> </ul> </li> </ul> <h3 id=\"namespace-name-string\">Namespace#name:String</h3> <p>The namespace identifier property.</p> <h3 id=\"namespace-connected-object\">Namespace#connected:Object\n</h3> <p>Hash of <code>Socket</code> objects that are connected to this namespace indexed by <code>id</code>.</p> <h3 id=\"namespace-use-fn-function-namespace\">Namespace#use(fn:Function):Namespace</h3> <p>Registers a middleware, which is a function that gets executed for every incoming <code>Socket</code> and receives as parameter the socket and a function to optionally defer execution to the next registered middleware.</p> <pre data-language=\"javascript\">var io = require('socket.io')();\nio.use(function(socket, next){\n  if (socket.request.headers.cookie) return next();\n  next(new Error('Authentication error'));\n});</pre> <p>Errors passed to middleware callbacks are sent as special <code>error</code> packets to clients.</p> <h3 id=\"socket\">Socket</h3> <p>A <code>Socket</code> is the fundamental class for interacting with browser clients. A <code>Socket</code> belongs to a certain <code>Namespace</code> (by default <code>/</code>) and uses an underlying <code>Client</code> to communicate.</p> <h3 id=\"socket-rooms-array\">Socket#rooms:Array</h3> <p>A list of strings identifying the rooms this socket is in.</p> <h3 id=\"socket-client-client\">Socket#client:Client</h3> <p>A reference to the underlying <code>Client</code> object.</p> <h3 id=\"socket-conn-socket\">Socket#conn:Socket</h3> <p>A reference to the underyling <code>Client</code> transport connection (engine.io <code>Socket</code> object).</p> <h3 id=\"socket-request-request\">Socket#request:Request</h3> <p>A getter proxy that returns the reference to the <code>request</code> that originated the underlying engine.io <code>Client</code>. Useful for accessing request headers such as <code>Cookie</code> or <code>User-Agent</code>.</p> <h3 id=\"socket-id-string\">Socket#id:String</h3> <p>A unique identifier for the socket session, that comes from the underlying <code>Client</code>.</p> <h3 id=\"socket-emit-name-string-socket\">Socket#emit(name:String[, …]):Socket</h3> <p>Emits an event to the socket identified by the string <code>name</code>. Any other parameters can be included.</p> <p>All datastructures are supported, including <code>Buffer</code>. JavaScript functions can’t be serialized/deserialized.</p> <pre data-language=\"javascript\">var io = require('socket.io')();\nio.on('connection', function(socket){\n  socket.emit('an event', { some: 'data' });\n});</pre> <h3 id=\"socket-join-name-string-fn-function-socket\">Socket#join(name:String[, fn:Function]):Socket</h3> <p>Adds the socket to the <code>room</code>, and fires optionally a callback <code>fn</code> with <code>err</code> signature (if any).</p> <p>The socket is automatically a member of a room identified with its session id (see <code>Socket#id</code>).</p> <p>The mechanics of joining rooms are handled by the <code>Adapter</code> that has been configured (see <code>Server#adapter</code> above), defaulting to <a href=\"https://github.com/socket.io/socket.io-adapter\">socket.io-adapter</a>.</p> <h3 id=\"socket-leave-name-string-fn-function-socket\">Socket#leave(name:String[, fn:Function]):Socket</h3> <p>Removes the socket from <code>room</code>, and fires optionally a callback <code>fn</code> with <code>err</code> signature (if any).</p> <p><strong>Rooms are left automatically upon disconnection</strong>.</p> <p>The mechanics of leaving rooms are handled by the <code>Adapter</code> that has been configured (see <code>Server#adapter</code> above), defaulting to <a href=\"https://github.com/socket.io/socket.io-adapter\">socket.io-adapter</a>.</p> <h3 id=\"socket-to-room-string-socket\">Socket#to(room:String):Socket</h3> <h3 id=\"socket-in-room-string-socket\">Socket#in(room:String):Socket</h3> <p>Sets a modifier for a subsequent event emission that the event will only be <em>broadcasted</em> to sockets that have joined the given <code>room</code>.</p> <p>To emit to multiple rooms, you can call <code>to</code> several times.</p> <pre data-language=\"javascript\">var io = require('socket.io')();\nio.on('connection', function(socket){\n  socket.to('others').emit('an event', { some: 'data' });\n});</pre> <h3 id=\"client\">Client</h3> <p>The <code>Client</code> class represents an incoming transport (engine.io) connection. A <code>Client</code> can be associated with many multiplexed <code>Socket</code> that belong to different <code>Namespace</code>s.</p> <h3 id=\"client-conn\">Client#conn</h3> <p>A reference to the underlying <code>engine.io</code> <code>Socket</code> connection.</p> <h3 id=\"client-request\">Client#request</h3> <p>A getter proxy that returns the reference to the <code>request</code> that originated the engine.io connection. Useful for accessing request headers such as <code>Cookie</code> or <code>User-Agent</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014&ndash;2015 Automattic<br>Licensed under the MIT License.<br>\n    <a href=\"http://socket.io/docs/server-api\" class=\"_attribution-link\">http://socket.io/docs/server-api</a>\n  </p>\n</div>\n","client-api":"<h1>Client API</h1> <h3 id=\"io-url-string-opts-object-socket\">IO(url:String, opts:Object):Socket</h3> <p>Exposed as the <code>io</code> global in <code>window</code> if using the standalone build (eg: <code>/socket.io/socket.io.js</code> or the CDN), or the result of calling <code>require('socket.io-client')</code>.</p> <p>When called, it creates a new <code>Manager</code> for the given URL, and attempts to reuse an existing <code>Manager</code> for subsequent calls, unless the <code>multiplex</code> option is passed with <code>false</code>. Passing this option is the equivalent of passing <code>'force new connection': true</code>.</p> <p>The rest of the options are passed to the <code>Manager</code> constructor (see below for details).</p> <p>A <code>Socket</code> instance is returned for the namespace specified by the pathname in the URL, defaulting to <code>/</code>. For example, if the <code>url</code> is <code>http://localhost/users</code>, a transport connection will be established to <code>http://localhost</code> and a Socket.IO connection will be established to <code>/users</code>.</p> <h3 id=\"io-protocol\">IO#protocol</h3> <p>Socket.io protocol revision number this client works with.</p> <h3 id=\"io-socket\">IO#Socket</h3> <p>Reference to the <code>Socket</code> constructor.</p> <h3 id=\"io-manager\">IO#Manager</h3> <p>Reference to the <code>Manager</code> constructor.</p> <h3 id=\"io-emitter\">IO#Emitter</h3> <p>Reference to the <code>Emitter</code> constructor.</p> <h3 id=\"manager-url-string-opts-object\">Manager(url:String, opts:Object)</h3> <p>A <code>Manager</code> represents a connection to a given Socket.IO server. One or more <code>Socket</code> instances are associated with the manager. The manager can be accessed through the <code>io</code> property of each <code>Socket</code> instance.</p> <p>The <code>opts</code> are also passed to <code>engine.io</code> upon initialization of the underlying <code>Socket</code>.</p> <p>Options: – <code>reconnection</code> whether to reconnect automatically (<code>true</code>) – <code>reconnectionDelay</code> how long to wait before attempting a new reconnection (<code>1000</code>) – <code>reconnectionDelayMax</code> maximum amount of time to wait between reconnections (<code>5000</code>). Each attempt increases the reconnection by the amount specified by <code>reconnectionDelay</code>. – <code>timeout</code> connection timeout before a <code>connect_error</code> and <code>connect_timeout</code> events are emitted (<code>20000</code>)</p> <h4 id=\"events\">Events</h4> <ul> <li>\n<code>connect</code>. Fired upon a successful connection.</li> <li>\n<code>connect_error</code>. Fired upon a connection error.<br> Parameters: <ul> <li>\n<code>Object</code> error object</li> </ul> </li> <li>\n<code>connect_timeout</code>. Fired upon a connection timeout.</li> <li>\n<code>reconnect</code>. Fired upon a successful reconnection.<br> Parameters: <ul> <li>\n<code>Number</code> reconnection attempt number</li> </ul> </li> <li>\n<code>reconnect_attempt</code>. Fired upon an attempt to reconnect.</li> <li>\n<code>reconnecting</code>. Fired upon an attempt to reconnect.<br> Parameters: <ul> <li>\n<code>Number</code> reconnection attempt number</li> </ul> </li> <li>\n<code>reconnect_error</code>. Fired upon a reconnection attempt error.<br> Parameters: <ul> <li>\n<code>Object</code> error object</li> </ul> </li> <li>\n<code>reconnect_failed</code>. Fired when couldn’t reconnect within <code>reconnectionAttempts</code>\n</li> </ul> <p>The events above are also emitted on the individual sockets that reconnect that depend on this <code>Manager</code>.</p> <h3 id=\"manager-reconnection-v-boolean-manager\">Manager#reconnection(v:Boolean):Manager</h3> <p>Sets the <code>reconnection</code> option, or returns it if no parameters are passed.</p> <h3 id=\"manager-reconnectionattempts-v-boolean-manager\">Manager#reconnectionAttempts(v:Boolean):Manager</h3> <p>Sets the <code>reconnectionAttempts</code> option, or returns it if no parameters are passed.</p> <h3 id=\"manager-reconnectiondelay-v-boolean-manager\">Manager#reconnectionDelay(v:Boolean):Manager</h3> <p>Sets the <code>reconectionDelay</code> option, or returns it if no parameters are passed.</p> <h3 id=\"manager-reconnectiondelaymax-v-boolean-manager\">Manager#reconnectionDelayMax(v:Boolean):Manager</h3> <p>Sets the <code>reconectionDelayMax</code> option, or returns it if no parameters are passed.</p> <h3 id=\"manager-timeout-v-boolean-manager\">Manager#timeout(v:Boolean):Manager</h3> <p>Sets the <code>timeout</code> option, or returns it if no parameters are passed.</p> <h3 id=\"socket\">Socket</h3> <h4 id=\"events\">Events</h4> <ul> <li>\n<code>connect</code>. Fired upon connecting.</li> <li>\n<code>error</code>. Fired upon a connection error<br> Parameters: <ul> <li>\n<code>Object</code> error data</li> </ul> </li> <li>\n<code>disconnect</code>. Fired upon a disconnection.</li> <li>\n<code>reconnect</code>. Fired upon a successful reconnection.<br> Parameters: <ul> <li>\n<code>Number</code> reconnection attempt number</li> </ul> </li> <li>\n<code>reconnect_attempt</code>. Fired upon an attempt to reconnect.</li> <li>\n<code>reconnecting</code>. Fired upon an attempt to reconnect.<br> Parameters: <ul> <li>\n<code>Number</code> reconnection attempt number</li> </ul> </li> <li>\n<code>reconnect_error</code>. Fired upon a reconnection attempt error.<br> Parameters: <ul> <li>\n<code>Object</code> error object</li> </ul> </li> <li>\n<code>reconnect_failed</code>. Fired when couldn’t reconnect within <code>reconnectionAttempts</code>\n</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014&ndash;2015 Automattic<br>Licensed under the MIT License.<br>\n    <a href=\"http://socket.io/docs/client-api\" class=\"_attribution-link\">http://socket.io/docs/client-api</a>\n  </p>\n</div>\n","logging-and-debugging":"<h1>Logging and Debugging</h1> <p>Socket.IO is now completely instrumented by a minimalistic yet tremendously powerful utility called <a href=\"https://github.com/visionmedia/debug\">debug</a> by TJ Holowaychuk.</p> <p>Before 1.0, the Socket.IO server would default to logging everything out to the console. This turned out to be annoyingly verbose for many users (although extremely useful for others), so now we default to being completely silent by default.</p> <p>The basic idea is that each module used by Socket.IO provides different debugging scopes that give you insight into the internals. By default, all output is suppressed, and you can opt into seeing messages by supplying the <code>DEBUG</code> env variable (Node.JS) or the <code>localStorage.debug</code> property (Browsers).</p> <p>You can see it in action for example on our homepage:</p>  <h3 id=\"available-debugging-scopes\">Available debugging scopes</h3> <p>The best way to see what information is available is to use the <code>*</code>:</p> <pre data-language=\"javascript\">DEBUG=* node yourfile.js</pre> <p>or in the browser:</p> <pre data-language=\"javascript\">localStorage.debug = '*';</pre> <p>And then filter by the scopes you’re interested in. You can use <code>,</code> to separate them.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014&ndash;2015 Automattic<br>Licensed under the MIT License.<br>\n    <a href=\"http://socket.io/docs/logging-and-debugging\" class=\"_attribution-link\">http://socket.io/docs/logging-and-debugging</a>\n  </p>\n</div>\n","migrating-from-0-9":"<h1>Migration from 0.9</h1> <p>For most applications, the transition to 1.0 should be completely seamless and devoid of any hiccups. That said, we’ve done some work to streamline some APIs, and we have changed some internals, so this is a recommended read for most existing users.</p> <h3 id=\"authentication-differences\">Authentication differences</h3> <h4 id=\"socket-io-uses-middleware-now\">Socket.io uses middleware now</h4> <p>You can give a Socket.io server arbitrary functions via <code>io.use()</code> that are run when a socket is created. Check out this example:</p> <pre data-language=\"javascript\">var srv = require('http').createServer();\nvar io = require('socket.io')(srv);\nvar run = 0;\nio.use(function(socket, next){\n  run++; // 0 -&gt; 1\n  next();\n});\nio.use(function(socket, next) {\n  run++; // 1 -&gt; 2\n  next();\n});\nvar socket = require('socket.io-client')();\nsocket.on('connect', function(){\n  // run == 2 at this time\n});</pre> <h4 id=\"so-its-cleaner-to-do-auth-via-middleware-now\">… so its cleaner to do auth via middleware now</h4> <p>The old <code>io.set()</code> and <code>io.get()</code> methods are deprecated and only supported for backwards compatibility. Here is a translation of an old authorization example into middleware-style.</p> <pre data-language=\"javascript\">io.set('authorization', function (handshakeData, callback) {\n  // make sure the handshake data looks good\n  callback(null, true); // error first, 'authorized' boolean second \n});</pre> <p>vs.</p> <pre data-language=\"javascript\">io.use(function(socket, next) {\n  var handshakeData = socket.request;\n  // make sure the handshake data looks good as before\n  // if error do this:\n    // next(new Error('not authorized');\n  // else just call next\n  next();\n});</pre> <h4 id=\"namespace-authorization\">Namespace authorization?</h4> <pre data-language=\"javascript\">io.of('/namespace').use(function(socket, next) {\n  var handshakeData = socket.request;\n  next();\n});</pre> <h3 id=\"log-differences\">Log differences</h3> <h4 id=\"logging-is-now-based-on-debug\">Logging is now based on debug</h4> <p>To print all debug logging, set the environment variable DEBUG to *. ie: <code>DEBUG=* node index.js</code></p> <p>To print only socket.io related logging: <code>DEBUG=socket.io:* node index.js</code>.</p> <p>To print logging only from the socket object: <code>DEBUG=socket.io:socket node index.js</code>.</p> <p>This pattern should hopefully be making sense at this point. The names of the files in socket.io/lib are equivalent to their debug names.</p> <p>Debug also works in the browser; logs are persisted to localstorage. To use: open the developer console and type <code>localStorage.debug = 'socket.io:*'</code> (or any debug level) and then refresh the page. Everything is logged until you run <code>localStorage.debug = ''</code></p> <p>See more at the debug documentation <a href=\"https://www.npmjs.org/package/debug\">here</a>.</p> <h3 id=\"shortcuts\">Shortcuts</h3> <p>In general there are some new shortcuts for common things. The old versions should still work, but shortcuts are nice.</p> <h4 id=\"broadcasting-to-all-clients-in-default-namespace\">Broadcasting to all clients in default namespace</h4> <p>Previously:</p> <pre data-language=\"javascript\">io.sockets.emit('eventname', 'eventdata');</pre> <p>Now:</p> <pre data-language=\"javascript\">io.emit('eventname', 'eventdata');</pre> <p>Neat. Note that in both cases, these messages reach all clients connected to the default ‘/’ namespace, but not clients in other namespaces.</p> <h4 id=\"starting-the-server\">Starting the server</h4> <p>Previously:</p> <pre data-language=\"javascript\">var io = require('socket.io');\nvar socket = io.listen(80, { /* options */ });</pre> <p>Now:</p> <pre data-language=\"javascript\">var io = require('socket.io');\nvar socket = io({ /* options */ });</pre> <h3 id=\"configuration-differences\">Configuration differences</h3> <h4 id=\"io-set-is-gone\">io.set is gone</h4> <p>Instead do configuration in server initialization like this:</p> <pre data-language=\"javascript\">var socket = require('socket.io')({\n  // options go here\n});</pre> <p>Options like log-level are gone. <code>io.set('transports')</code>, <code>io.set('heartbeat interval')</code>, <code>io.set('heartbeat timeout'</code>, and <code>io.set('resource')</code> are still supported for backwards compatibility.</p> <h4 id=\"setting-resource-path\">Setting resource path</h4> <p>The previous <code>resource</code> option is equivalent to the new <code>path</code> option, but needs a <code>/</code> in the beginning. For example, the following configuration</p> <pre data-language=\"javascript\">var socket = io.connect('localhost:3000', {\n  'resource': 'path/to/socket.io';\n});</pre> <p>becomes</p> <pre data-language=\"javascript\">var socket = io.connect('localhost:3000', {\n  'path': '/path/to/socket.io';\n});</pre> <h3 id=\"parser-protocol-differences\">Parser / Protocol differences</h3> <p>This is only relevant for updating things like socket.io implementations in other languages, custom socket.io clients, etc.</p> <h4 id=\"difference-1-packet-encoding\">Difference 1 – packet encoding</h4> <p>Parsing is now class based and asynchronous. Instead of returning a single encoded string, encode calls callback with an array of encodings as the only argument. Each encoding should be written to the transport in order. This is more flexible and makes binary data transport work. Here’s an example:</p> <pre data-language=\"javascript\">var encoding = parser.encode(packet);\nconsole.log(encoding); // fully encoded packet</pre> <p>vs.</p> <pre data-language=\"javascript\">var encoder = new parser.Encoder();\nencoder.encode(packet, function(encodings) {\n  for (var i = 0; i &lt; encodings.length; i++) {\n    console.log(encodings[i]); // encoded parts of the packet\n  }\n});</pre> <h4 id=\"difference-2-packet-decoding\">Difference 2 – packet decoding</h4> <p>Decoding takes things a step further and is event-based. This is done because some objects (binary-containing) are both encoded and decoded in multiple parts. This example should help:</p> <pre data-language=\"javascript\">var packet = parser.decode(decoding);\nconsole.log(packet); // formed socket.io packet to handle</pre> <p>vs.</p> <pre data-language=\"javascript\">var decoder = new parser.Decoder();\ndecoder.on('decoded', function(packet) {\n  console.log(packet); // formed socket.io packet to handle\n});\ndecoder.add(encodings[0]); // say encodings is array of two encodings received from transport\ndecoder.add(encodings[1]); // after adding the last element, 'decoded' is emitted from decoder</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014&ndash;2015 Automattic<br>Licensed under the MIT License.<br>\n    <a href=\"http://socket.io/docs/migrating-from-0-9\" class=\"_attribution-link\">http://socket.io/docs/migrating-from-0-9</a>\n  </p>\n</div>\n","rooms-and-namespaces":"<h1>Namespaces</h1> <p>Socket.IO allows you to “namespace” your sockets, which essentially means assigning different <em>endpoints</em> or <em>paths</em>.</p> <p>This is a useful feature to minimize the number of resources (TCP connections) and at the same time separate concerns within your application by introducing separation between communication channels.</p> <h3 id=\"default-namespace\">Default namespace</h3> <p>We call the default namespace <code>/</code> and it’s the one Socket.IO clients connect to by default, and the one the server listens to by default.</p> <p>This namespace is identified by <code>io.sockets</code> or simply <code>io</code>:</p> <pre data-language=\"javascript\">// the following two will emit to all the sockets connected to `/`\nio.sockets.emit('hi', 'everyone');\nio.emit('hi', 'everyone'); // short form</pre> <p>Each namespace emits a <code>connection</code> event that receives each <code>Socket</code> instance as a parameter</p> <pre data-language=\"javascript\">io.on('connection', function(socket){\n  socket.on('disconnect', function(){ });\n});</pre> <h3 id=\"custom-namespaces\">Custom namespaces</h3> <p>To set up a custom namespace, you can call the <code>of</code> function on the server-side:</p> <pre data-language=\"javascript\">var nsp = io.of('/my-namespace');\nnsp.on('connection', function(socket){\n  console.log('someone connected'):\n});\nnsp.emit('hi', 'everyone!');</pre> <p>On the client side, you tell Socket.IO client to connect to that namespace:</p> <pre data-language=\"javascript\">var socket = io('/my-namespace');</pre> <p><strong>Important note:</strong> The namespace is an implementation detail of the Socket.IO protocol, and is not related to the actual URL of the underlying transport, which defaults to <code>/socket.io/…</code>.</p> <h2 id=\"rooms\">Rooms</h2> <p>Within each namespace, you can also define arbitrary channels that sockets can <code>join</code> and <code>leave</code>.</p> <h3 id=\"joining-and-leaving\">Joining and leaving</h3> <p>You can call <code>join</code> to subscribe the socket to a given channel:</p> <pre data-language=\"javascript\">io.on('connection', function(socket){\n  socket.join('some room');\n});</pre> <p>And then simply use <code>to</code> or <code>in</code> (they are the same) when broadcasting or emitting:</p> <pre data-language=\"javascript\">io.to('some room').emit('some event'):</pre> <p>To leave a channel you call <code>leave</code> in the same fashion as <code>join</code>.</p> <h3 id=\"default-room\">Default room</h3> <p>Each <code>Socket</code> in Socket.IO is identified by a random, unguessable, unique identifier <code>Socket#id</code>. For your convenience, each socket automatically joins a room identified by this id.</p> <p>This makes it easy to broadcast messages to other sockets:</p> <pre data-language=\"javascript\">io.on('connection', function(socket){\n  socket.on('say to someone', function(id, msg){\n    socket.broadcast.to(id).emit('my message', msg);\n  });\n});</pre> <h3 id=\"disconnection\">Disconnection</h3> <p>Upon disconnection, sockets <code>leave</code> all the channels they were part of automatically, and no specially teardown is needed on your part.</p> <h2 id=\"sending-messages-from-the-outside-world\">Sending messages from the outside-world</h2> <p>In some cases, you might want to emit events to sockets in Socket.IO namespaces / rooms from outside the context of your Socket.IO processes.</p> <p>There’s several ways to tackle this problem, like implementing your own channel to send messages into the process.</p> <p>To facilitate this use case, we created two modules:</p> <ul> <li><a href=\"http://github.com/automattic/socket.io-redis\">socket.io-redis</a></li> <li><a href=\"http://github.com/automattic/socket.io-emitter\">socket.io-emitter</a></li> </ul> <p>By implementing the Redis <code>Adapter</code>:</p> <pre data-language=\"javascript\">var io = require('socket.io')(3000);\nvar redis = require('socket.io-redis');\nio.adapter(redis({ host: 'localhost', port: 6379 }));</pre> <p>you can then <code>emit</code> messages from any other process to any channel</p> <pre data-language=\"javascript\">var io = require('socket.io-emitter')();\nsetInterval(function(){\n  io.emit('time', new Date);\n}, 5000);</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014&ndash;2015 Automattic<br>Licensed under the MIT License.<br>\n    <a href=\"http://socket.io/docs/rooms-and-namespaces\" class=\"_attribution-link\">http://socket.io/docs/rooms-and-namespaces</a>\n  </p>\n</div>\n","using-multiple-nodes":"<h1>Using multiple nodes</h1> <h3 id=\"sticky-load-balancing\">Sticky load balancing</h3> <p>If you plan to distribute the load of connections among different processes or machines, you have to make sure that requests associated with a particular session id connect to the process that originated them.</p> <p>This is due to certain transports like XHR Polling or JSONP Polling relying on firing several requests during the lifetime of the “socket”.</p> <p>To illustrate why this is needed, consider the example of emitting an event to all connected clients:</p> <pre data-language=\"javascript\">io.emit('hi', 'all sockets');</pre> <p>Chances are that some of those clients might have an active bi-directional communication channel like <code>WebSocket</code> that we can write to immediately, but some of them might be using long-polling.</p> <p>If they’re using long polling, they might or might not have sent a request that we can write to. They could be “in between” those requests. In those situations, it means we have to buffer messages in the process. In order for the client to successfully claim those messages when he sends his request, the easiest way is for him to connect to be routed to that same process.</p> <p>An easy way to do that is by routing clients based on their originating address. An example follows using the NginX server:</p> <h3 id=\"nginx-configuration\">NginX configuration</h3> <p>Within the <code>http { }</code> section of your <code>nginx.conf</code> file, you can declare a <code>upstream</code> section with a list of Socket.IO process you want to balance load between:</p> <pre data-language=\"javascript\">upstream io_nodes {\n  ip_hash;\n  server 127.0.0.1:6001;\n  server 127.0.0.1:6002;\n  server 127.0.0.1:6003;\n  server 127.0.0.1:6004;\n}</pre> <p>Notice the <code>ip_hash</code> instruction that indicates the connections will be sticky.</p> <p>In the same <code>http { }</code> section, you can declare a <code>server { }</code> that points to this upstream. In order for NginX to support and forward the <code>WebSocket</code> protocol, we explicitly pass along the required <code>Upgrade</code> headers:</p> <pre data-language=\"javascript\">server {\n  listen 3000;\n  server_name io.yourhost.com;\n  location / {\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header Host $host;\n    proxy_http_version 1.1;\n    proxy_pass http://io_nodes;\n  }\n}</pre> <p>Make sure you also configure <code>worker_processes</code> in the topmost level to indicate how many workers NginX should use. You might also want to look into tweaking the <code>worker_connections</code> setting within the <code>events { }</code> block.</p> <h3 id=\"using-node-js-cluster\">Using Node.JS Cluster</h3> <p>Just like NginX, Node.JS comes with built-in clustering support through the <code>cluster</code> module.</p> <p>Fedor Indutny has created a module called <a href=\"https://github.com/indutny/sticky-session\">sticky session</a> that ensures file descriptors (ie: connections) are routed based on the originating <code>remoteAddress</code> (ie: IP).</p> <h3 id=\"passing-events-between-nodes\">Passing events between nodes</h3> <p>Now that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to everyone (or even everyone in a certain <a href=\"http://new.socket.io/docs/rooms-and-namespaces/\">room</a>) you’ll need some way of passing messages between processes or computers.</p> <p>The interface in charge of routing messages is what we call the <code>Adapter</code>. You can implement your own on top of the <a href=\"https://github.com/automattic/socket.io-adapter\">socket.io-adapter</a> (by inheriting from it) or you can use the one we provide on top of <a href=\"http://redis.io\">Redis</a>: <a href=\"https://github.com/automattic/socket.io-redis\">socket.io-redis</a>:</p> <pre data-language=\"javascript\">var io = require('socket.io')(3000);\nvar redis = require('socket.io-redis');\nio.adapter(redis({ host: 'localhost', port: 6379 }));</pre> <p>If you want to pass messages to it from non-socket.io processes, you should look into <a href=\"rooms-and-namespaces#sending-messages-from-the-outside-world\">“Sending messages from the outside-world”</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2014&ndash;2015 Automattic<br>Licensed under the MIT License.<br>\n    <a href=\"http://socket.io/docs/using-multiple-nodes\" class=\"_attribution-link\">http://socket.io/docs/using-multiple-nodes</a>\n  </p>\n</div>\n"}