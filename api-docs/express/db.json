{"advanced/developing-template-engines":"<h1 id=\"developing-template-engines-for-express\">Developing template engines for Express</h1> <p>Use the <code>app.engine(ext, callback)</code> method to create your own template engine. <code>ext</code> refers to the file extension, and <code>callback</code> is the template engine function, which accepts the following items as parameters: the location of the file, the options object, and the callback function.</p> <p>The following code is an example of implementing a very simple template engine for rendering <code>.ntl</code> files.</p> <pre data-language=\"js\">var fs = require('fs'); // this engine requires the fs module\napp.engine('ntl', function (filePath, options, callback) { // define the template engine\n  fs.readFile(filePath, function (err, content) {\n    if (err) return callback(new Error(err));\n    // this is an extremely simple template engine\n    var rendered = content.toString().replace('#title#', '&lt;title&gt;'+ options.title +'&lt;/title&gt;')\n    .replace('#message#', '&lt;h1&gt;'+ options.message +'&lt;/h1&gt;');\n    return callback(null, rendered);\n  });\n});\napp.set('views', './views'); // specify the views directory\napp.set('view engine', 'ntl'); // register the template engine\n</pre> <p>Your app will now be able to render <code>.ntl</code> files. Create a file named <code>index.ntl</code> in the <code>views</code> directory with the following content.</p> <pre data-language=\"js\">#title#\n#message#\n</pre> <p>Then, create the following route in your app.</p> <pre data-language=\"js\">app.get('/', function (req, res) {\n  res.render('index', { title: 'Hey', message: 'Hello there!'});\n});\n</pre> <p>When you make a request to the home page, <code>index.ntl</code> will be rendered as HTML.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/advanced/developing-template-engines.html\" class=\"_attribution-link\">http://expressjs.com/en/advanced/developing-template-engines.html</a>\n  </p>\n</div>\n","starter/installing":"<h1 id=\"installing\">Installing</h1> <p>Assuming you’ve already installed <a href=\"https://nodejs.org/\">Node.js</a>, create a directory to hold your application, and make that your working directory.</p> <pre data-language=\"sh\">$ mkdir myapp\n$ cd myapp\n</pre> <p>Use the <code>npm init</code> command to create a <code>package.json</code> file for your application. For more information on how <code>package.json</code> works, see <a href=\"https://docs.npmjs.com/files/package.json\">Specifics of npm’s package.json handling</a>.</p> <pre data-language=\"sh\">$ npm init\n</pre> <p>This command prompts you for a number of things, such as the name and version of your application. For now, you can simply hit RETURN to accept the defaults for most of them, with the following exception:</p> <pre data-language=\"sh\">entry point: (index.js)\n</pre> <p>Enter <code>app.js</code>, or whatever you want the name of the main file to be. If you want it to be <code>index.js</code>, hit RETURN to accept the suggested default file name.</p> <p>Now install Express in the <code>app</code> directory and save it in the dependencies list. For example:</p> <pre data-language=\"sh\">$ npm install express --save\n</pre> <p>To install Express temporarily and not add it to the dependencies list, omit the <code>--save</code> option:</p> <pre data-language=\"sh\">$ npm install express\n</pre> <div class=\"doc-box doc-info\"> <p>Node modules installed with the <code>--save</code> option are added to the <code>dependencies</code> list in the <code>package.json</code> file. Afterwards, running <code>npm install</code> in the <code>app</code> directory will automatically install modules in the dependencies list.</p> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/starter/installing.html\" class=\"_attribution-link\">http://expressjs.com/en/starter/installing.html</a>\n  </p>\n</div>\n","guide/routing":"<h1 id=\"routing\">Routing</h1> <p><em>Routing</em> refers to the definition of application end points (URIs) and how they respond to client requests. For an introduction to routing, see <a href=\"../starter/basic-routing\">Basic routing</a>.</p> <p>The following code is an example of a very basic route.</p> <pre data-language=\"js\">var express = require('express');\nvar app = express();\n\n// respond with \"hello world\" when a GET request is made to the homepage\napp.get('/', function(req, res) {\n  res.send('hello world');\n});\n</pre> <h2 id=\"route-methods\">Route methods</h2> <p>A route method is derived from one of the HTTP methods, and is attached to an instance of the <code>express</code> class.</p> <p>The following code is an example of routes that are defined for the GET and the POST methods to the root of the app.</p> <pre data-language=\"js\">// GET method route\napp.get('/', function (req, res) {\n  res.send('GET request to the homepage');\n});\n\n// POST method route\napp.post('/', function (req, res) {\n  res.send('POST request to the homepage');\n});\n</pre> <p>Express supports the following routing methods that correspond to HTTP methods: <code>get</code>, <code>post</code>, <code>put</code>, <code>head</code>, <code>delete</code>, <code>options</code>, <code>trace</code>, <code>copy</code>, <code>lock</code>, <code>mkcol</code>, <code>move</code>, <code>purge</code>, <code>propfind</code>, <code>proppatch</code>, <code>unlock</code>, <code>report</code>, <code>mkactivity</code>, <code>checkout</code>, <code>merge</code>, <code>m-search</code>, <code>notify</code>, <code>subscribe</code>, <code>unsubscribe</code>, <code>patch</code>, <code>search</code>, and <code>connect</code>.</p> <div class=\"doc-box doc-info\"> <p>To route methods that translate to invalid JavaScript variable names, use the bracket notation. For example, <code>app['m-search']('/', function ...</code></p> </div> <p>There is a special routing method, <code>app.all()</code>, which is not derived from any HTTP method. This method is used for loading middleware functions at a path for all request methods.</p> <p>In the following example, the handler will be executed for requests to “/secret” whether you are using GET, POST, PUT, DELETE, or any other HTTP request method that is supported in the <a href=\"https://nodejs.org/api/http.html#http_http_methods\">http module</a>.</p> <pre data-language=\"js\">app.all('/secret', function (req, res, next) {\n  console.log('Accessing the secret section ...');\n  next(); // pass control to the next handler\n});\n</pre> <h2 id=\"route-paths\">Route paths</h2> <p>Route paths, in combination with a request method, define the endpoints at which requests can be made. Route paths can be strings, string patterns, or regular expressions.</p> <div class=\"doc-box doc-info\"> <p>Express uses <a href=\"https://www.npmjs.com/package/path-to-regexp\">path-to-regexp</a> for matching the route paths; see the path-to-regexp documentation for all the possibilities in defining route paths. <a href=\"http://forbeslindesay.github.io/express-route-tester/\">Express Route Tester</a> is a handy tool for testing basic Express routes, although it does not support pattern matching.</p> </div> <div class=\"doc-box doc-warn\"> <p>Query strings are not part of the route path.</p> </div> <p>Here are some examples of route paths based on strings.</p> <p>This route path will match requests to the root route, <code>/</code>.</p> <pre data-language=\"js\">app.get('/', function (req, res) {\n  res.send('root');\n});\n</pre> <p>This route path will match requests to <code>/about</code>.</p> <pre data-language=\"js\">app.get('/about', function (req, res) {\n  res.send('about');\n});\n</pre> <p>This route path will match requests to <code>/random.text</code>.</p> <pre data-language=\"js\">app.get('/random.text', function (req, res) {\n  res.send('random.text');\n});\n</pre> <p>Here are some examples of route paths based on string patterns.</p> <p>This route path will match <code>acd</code> and <code>abcd</code>.</p> <pre data-language=\"js\">app.get('/ab?cd', function(req, res) {\n  res.send('ab?cd');\n});\n</pre> <p>This route path will match <code>abcd</code>, <code>abbcd</code>, <code>abbbcd</code>, and so on.</p> <pre data-language=\"js\">app.get('/ab+cd', function(req, res) {\n  res.send('ab+cd');\n});\n</pre> <p>This route path will match <code>abcd</code>, <code>abxcd</code>, <code>abRANDOMcd</code>, <code>ab123cd</code>, and so on.</p> <pre data-language=\"js\">app.get('/ab*cd', function(req, res) {\n  res.send('ab*cd');\n});\n</pre> <p>This route path will match <code>/abe</code> and <code>/abcde</code>.</p> <pre data-language=\"js\">app.get('/ab(cd)?e', function(req, res) {\n res.send('ab(cd)?e');\n});\n</pre> <div class=\"doc-box doc-info\"> <p>The characters ?, +, *, and () are subsets of their regular expression counterparts. The hyphen (-) and the dot (.) are interpreted literally by string-based paths.</p> </div> <p>Examples of route paths based on regular expressions:</p> <p>This route path will match anything with an “a” in the route name.</p> <pre data-language=\"js\">app.get(/a/, function(req, res) {\n  res.send('/a/');\n});\n</pre> <p>This route path will match <code>butterfly</code> and <code>dragonfly</code>, but not <code>butterflyman</code>, <code>dragonfly man</code>, and so on.</p> <pre data-language=\"js\">app.get(/.*fly$/, function(req, res) {\n  res.send('/.*fly$/');\n});\n</pre> <h2 id=\"route-handlers\">Route handlers</h2> <p>You can provide multiple callback functions that behave like <a href=\"using-middleware\">middleware</a> to handle a request. The only exception is that these callbacks might invoke <code>next('route')</code> to bypass the remaining route callbacks. You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p> <p>Route handlers can be in the form of a function, an array of functions, or combinations of both, as shown in the following examples.</p> <p>A single callback function can handle a route. For example:</p> <pre data-language=\"js\">app.get('/example/a', function (req, res) {\n  res.send('Hello from A!');\n});\n</pre> <p>More than one callback function can handle a route (make sure you specify the <code>next</code> object). For example:</p> <pre data-language=\"js\">app.get('/example/b', function (req, res, next) {\n  console.log('the response will be sent by the next function ...');\n  next();\n}, function (req, res) {\n  res.send('Hello from B!');\n});\n</pre> <p>An array of callback functions can handle a route. For example:</p> <pre data-language=\"js\">var cb0 = function (req, res, next) {\n  console.log('CB0');\n  next();\n}\n\nvar cb1 = function (req, res, next) {\n  console.log('CB1');\n  next();\n}\n\nvar cb2 = function (req, res) {\n  res.send('Hello from C!');\n}\n\napp.get('/example/c', [cb0, cb1, cb2]);\n</pre> <p>A combination of independent functions and arrays of functions can handle a route. For example:</p> <pre data-language=\"js\">var cb0 = function (req, res, next) {\n  console.log('CB0');\n  next();\n}\n\nvar cb1 = function (req, res, next) {\n  console.log('CB1');\n  next();\n}\n\napp.get('/example/d', [cb0, cb1], function (req, res, next) {\n  console.log('the response will be sent by the next function ...');\n  next();\n}, function (req, res) {\n  res.send('Hello from D!');\n});\n</pre> <h2 id=\"response-methods\">Response methods</h2> <p>The methods on the response object (<code>res</code>) in the following table can send a response to the client, and terminate the request-response cycle. If none of these methods are called from a route handler, the client request will be left hanging.</p> <table> <thead> <tr> <th>Method</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><a href=\"../4x/api#res.download\">res.download()</a></td> <td>Prompt a file to be downloaded.</td> </tr> <tr> <td><a href=\"../4x/api#res.end\">res.end()</a></td> <td>End the response process.</td> </tr> <tr> <td><a href=\"../4x/api#res.json\">res.json()</a></td> <td>Send a JSON response.</td> </tr> <tr> <td><a href=\"../4x/api#res.jsonp\">res.jsonp()</a></td> <td>Send a JSON response with JSONP support.</td> </tr> <tr> <td><a href=\"../4x/api#res.redirect\">res.redirect()</a></td> <td>Redirect a request.</td> </tr> <tr> <td><a href=\"../4x/api#res.render\">res.render()</a></td> <td>Render a view template.</td> </tr> <tr> <td><a href=\"../4x/api#res.send\">res.send()</a></td> <td>Send a response of various types.</td> </tr> <tr> <td><a href=\"../4x/api#res.sendFile\">res.sendFile()</a></td> <td>Send a file as an octet stream.</td> </tr> <tr> <td><a href=\"../4x/api#res.sendStatus\">res.sendStatus()</a></td> <td>Set the response status code and send its string representation as the response body.</td> </tr> </tbody> </table> <h2 id=\"app-route\">app.route()</h2> <p>You can create chainable route handlers for a route path by using <code>app.route()</code>. Because the path is specified at a single location, creating modular routes is helpful, as is reducing redundancy and typos. For more information about routes, see: <a href=\"../4x/api#router\">Router() documentation</a>.</p> <p>Here is an example of chained route handlers that are defined by using <code>app.route()</code>.</p> <pre data-language=\"js\">app.route('/book')\n  .get(function(req, res) {\n    res.send('Get a random book');\n  })\n  .post(function(req, res) {\n    res.send('Add a book');\n  })\n  .put(function(req, res) {\n    res.send('Update the book');\n  });\n</pre> <h2 id=\"express-router\">express.Router</h2> <p>Use the <code>express.Router</code> class to create modular, mountable route handlers. A <code>Router</code> instance is a complete middleware and routing system; for this reason, it is often referred to as a “mini-app”.</p> <p>The following example creates a router as a module, loads a middleware function in it, defines some routes, and mounts the router module on a path in the main app.</p> <p>Create a router file named <code>birds.js</code> in the app directory, with the following content:</p> <pre data-language=\"js\">var express = require('express');\nvar router = express.Router();\n\n// middleware that is specific to this router\nrouter.use(function timeLog(req, res, next) {\n  console.log('Time: ', Date.now());\n  next();\n});\n// define the home page route\nrouter.get('/', function(req, res) {\n  res.send('Birds home page');\n});\n// define the about route\nrouter.get('/about', function(req, res) {\n  res.send('About birds');\n});\n\nmodule.exports = router;\n</pre> <p>Then, load the router module in the app:</p> <pre data-language=\"js\">var birds = require('./birds');\n...\napp.use('/birds', birds);\n</pre> <p>The app will now be able to handle requests to <code>/birds</code> and <code>/birds/about</code>, as well as call the <code>timeLog</code> middleware function that is specific to the route.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/guide/routing.html\" class=\"_attribution-link\">http://expressjs.com/en/guide/routing.html</a>\n  </p>\n</div>\n","starter/hello-world":"<h1 id=\"hello-world-example\">Hello world example</h1> <div class=\"doc-box doc-info\"> <p>This is essentially going to be the simplest Express app you can create. It is a single file app — <em>not</em> what you’d get if you use the <a href=\"generator\">Express generator</a>, which creates the scaffolding for a full app with numerous JavaScript files, Jade templates, and sub-directories for various purposes.</p> </div> <p>First create a directory named <code>myapp</code>, change to it and run <code>npm init</code>. Then install <code>express</code> as a dependency, as per the <a href=\"installing\">installation guide</a>.</p> <p>In the <code>myapp</code> directory, create a file named <code>app.js</code> and add the following code:</p> <pre data-language=\"js\">var express = require('express');\nvar app = express();\n\napp.get('/', function (req, res) {\n  res.send('Hello World!');\n});\n\napp.listen(3000, function () {\n  console.log('Example app listening on port 3000!');\n});\n</pre> <p>The app starts a server and listens on port 3000 for connections. The app responds with “Hello World!” for requests to the root URL (<code>/</code>) or <em>route</em>. For every other path, it will respond with a <strong>404 Not Found</strong>.</p> <div class=\"doc-box doc-notice\"> <p>The <code>req</code> (request) and <code>res</code> (response) are the exact same objects that Node provides, so you can invoke <code>req.pipe()</code>, <code>req.on('data', callback)</code>, and anything else you would do without Express involved.</p> </div> <p>Run the app with the following command:</p> <pre data-language=\"sh\">$ node app.js\n</pre> <p>Then, load <code>http://localhost:3000/</code> in a browser to see the output.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/starter/hello-world.html\" class=\"_attribution-link\">http://expressjs.com/en/starter/hello-world.html</a>\n  </p>\n</div>\n","starter/generator":"<h1 id=\"express-application-generator\">Express application generator</h1> <p>Use the application generator tool, <code>express-generator</code>, to quickly create an application skeleton.</p> <p>Install <code>express-generator</code> with the following command:</p> <pre data-language=\"sh\">$ npm install express-generator -g\n</pre> <p>Display the command options with the <code>-h</code> option:</p> <pre data-language=\"sh\">$ express -h\n\n  Usage: express [options] [dir]\n\n  Options:\n\n    -h, --help          output usage information\n    -V, --version       output the version number\n    -e, --ejs           add ejs engine support (defaults to jade)\n        --hbs           add handlebars engine support\n    -H, --hogan         add hogan.js engine support\n    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)\n        --git           add .gitignore\n    -f, --force         force on non-empty directory\n</pre> <p>For example, the following creates an Express app named <em>myapp</em> in the current working directory:</p> <pre data-language=\"sh\">$ express myapp\n\n   create : myapp\n   create : myapp/package.json\n   create : myapp/app.js\n   create : myapp/public\n   create : myapp/public/javascripts\n   create : myapp/public/images\n   create : myapp/routes\n   create : myapp/routes/index.js\n   create : myapp/routes/users.js\n   create : myapp/public/stylesheets\n   create : myapp/public/stylesheets/style.css\n   create : myapp/views\n   create : myapp/views/index.jade\n   create : myapp/views/layout.jade\n   create : myapp/views/error.jade\n   create : myapp/bin\n   create : myapp/bin/www\n</pre> <p>Then install dependencies:</p> <pre data-language=\"sh\">$ cd myapp\n$ npm install\n</pre> <p>On MacOS or Linux, run the app with this command:</p> <pre data-language=\"sh\">$ DEBUG=myapp:* npm start\n</pre> <p>On Windows, use this command:</p> <pre data-language=\"sh\">&gt; set DEBUG=myapp:* &amp; npm start\n</pre> <p>Then load <code>http://localhost:3000/</code> in your browser to access the app.</p> <p>The generated app has the following directory structure:</p> <pre data-language=\"sh\">.\n├── app.js\n├── bin\n│   └── www\n├── package.json\n├── public\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n│       └── style.css\n├── routes\n│   ├── index.js\n│   └── users.js\n└── views\n    ├── error.jade\n    ├── index.jade\n    └── layout.jade\n\n7 directories, 9 files\n</pre> <div class=\"doc-box doc-info\"> <p>The app structure created by the generator is just one of many ways to structure Express apps. Feel free to use this structure or modify it to best suit your needs.</p> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/starter/generator.html\" class=\"_attribution-link\">http://expressjs.com/en/starter/generator.html</a>\n  </p>\n</div>\n","advanced/best-practice-performance":"<h1 id=\"production-best-practices-performance-and-reliability\">Production best practices: performance and reliability</h1> <h2 id=\"overview\">Overview</h2> <p>This article discusses performance and reliability best practices for Express applications deployed to production.</p> <p>This topic clearly falls into the “devops” world, spanning both traditional development and operations. Accordingly, the information is divided into two parts:</p> <ul> <li>\n<a href=\"#code\">Things to do in your code</a> (the dev part).</li> <li>\n<a href=\"#env\">Things to do in your environment / setup</a> (the ops part).</li> </ul>  <h2 id=\"things-to-do-in-your-code\">Things to do in your code</h2> <p>Here are some things you can do in your code to improve your application’s performance:</p> <ul> <li>Use gzip compression</li> <li>Don’t use synchronous functions</li> <li>Do logging correctly</li> <li>Handle exceptions properly</li> </ul> <h3 id=\"use-gzip-compression\">Use gzip compression</h3> <p>Gzip compressing can greatly decrease the size of the response body and hence increase the speed of a web app. Use the <a href=\"https://www.npmjs.com/package/compression\">compression</a> middleware for gzip compression in your Express app. For example:</p> <pre data-language=\"js\">var compression = require('compression');\nvar express = require('express');\nvar app = express();\napp.use(compression());\n</pre> <p>For a high-traffic website in production, the best way to put compression in place is to implement it at a reverse proxy level (see <a href=\"#proxy\">Use a reverse proxy</a>). In that case, you do not need to use compression middleware. For details on enabling gzip compression in Nginx, see <a href=\"http://nginx.org/en/docs/http/ngx_http_gzip_module.html\">Module ngx_http_gzip_module</a> in the Nginx documentation.</p> <h3 id=\"dont-use-synchronous-functions\">Don’t use synchronous functions</h3> <p>Synchronous functions and methods tie up the executing process until they return. A single call to a synchronous function might return in a few microseconds or milliseconds, however in high-traffic websites, these calls add up and reduce the performance of the app. Avoid their use in production.</p> <p>Although Node and many modules provide synchronous and asynchronous versions of their functions, always use the asynchronous version in production. The only time when a synchronous function can be justified is upon initial startup.</p> <p>If you are using Node.js 4.0+ or io.js 2.1.0+, you can use the <code>--trace-sync-io</code> command-line flag to print a warning and a stack trace whenever your application uses a synchronous API. Of course, you wouldn’t want to actually use this in production, but rather to ensure that your code is ready for production. See the <a href=\"https://nodejs.org/en/blog/weekly-updates/weekly-update.2015-05-22/#2-1-0\">Weekly update for io.js 2.1.0</a> for more information.</p> <h3 id=\"do-logging-correctly\">Do logging correctly</h3> <p>In general, there are two reasons for logging from your app: For debugging and for logging app activity (essentially, everything else). Using <code>console.log()</code> or <code>console.err()</code> to print log messages to the terminal is common practice in development. But <a href=\"https://nodejs.org/api/console.html#console_console_1\">these functions are synchronous</a> when the destination is a terminal or a file, so they are not suitable for production, unless you pipe the output to another program.</p> <h4 id=\"for-debugging\">For debugging</h4> <p>If you’re logging for purposes of debugging, then instead of using <code>console.log()</code>, use a special debugging module like <a href=\"https://www.npmjs.com/package/debug\">debug</a>. This module enables you to use the DEBUG environment variable to control what debug messages are sent to <code>console.err()</code>, if any. To keep your app purely asynchronous, you’d still want to pipe <code>console.err()</code> to another program. But then, you’re not really going to debug in production, are you?</p> <h4 id=\"for-app-activity\">For app activity</h4> <p>If you’re logging app activity (for example, tracking traffic or API calls), instead of using <code>console.log()</code>, use a logging library like <a href=\"https://www.npmjs.com/package/winston\">Winston</a> or <a href=\"https://www.npmjs.com/package/bunyan\">Bunyan</a>. For a detailed comparison of these two libraries, see the StrongLoop blog post <a href=\"https://strongloop.com/strongblog/compare-node-js-logging-winston-bunyan/\">Comparing Winston and Bunyan Node.js Logging</a>.</p>  <h3 id=\"handle-exceptions-properly\">Handle exceptions properly</h3> <p>Node apps crash when they encounter an uncaught exception. Not handling exceptions and taking appropriate actions will make your Express app crash and go offline. If you follow the advice in <a href=\"#restart\">Ensure your app automatically restarts</a> below, then your app will recover from a crash. Fortunately, Express apps typically have a short startup time. Nevertheless, you want to avoid crashing in the first place, and to do that, you need to handle exceptions properly.</p> <p>To ensure you handle all exceptions, use the following techniques:</p> <ul> <li><a href=\"#try-catch\">Use try-catch</a></li> <li><a href=\"#promises\">Use promises</a></li> </ul> <p>Before diving into these topics, you should have a basic understanding of Node/Express error handling: using error-first callbacks, and propagating errors in middleware. Node uses an “error-first callback” convention for returning errors from asynchronous functions, where the first parameter to the callback function is the error object, followed by result data in succeeding parameters. To indicate no error, pass null as the first parameter. The callback function must correspondingly follow the error-first callback convention to meaningfully handle the error. And in Express, the best practice is to use the next() function to propagate errors through the middleware chain.</p> <p>For more on the fundamentals of error handling, see:</p> <ul> <li><a href=\"https://www.joyent.com/developers/node/design/errors\">Error Handling in Node.js</a></li> <li>\n<a href=\"https://strongloop.com/strongblog/robust-node-applications-error-handling/\">Building Robust Node Applications: Error Handling</a> (StrongLoop blog)</li> </ul> <h4 id=\"what-not-to-do\">What not to do</h4> <p>One thing you should <em>not</em> do is to listen for the <code>uncaughtException</code> event, emitted when an exception bubbles all the way back to the event loop. Adding an event listener for <code>uncaughtException</code> will change the default behavior of the process that is encountering an exception; the process will continue to run despite the exception. This might sound like a good way of preventing your app from crashing, but continuing to run the app after an uncaught exception is a dangerous practice and is not recommended, because the state of the process becomes unreliable and unpredictable.</p> <p>Additionally, using <code>uncaughtException</code> is officially recognized as <a href=\"https://nodejs.org/api/process.html#process_event_uncaughtexception\">crude</a>. So listening for <code>uncaughtException</code> is just a bad idea. This is why we recommend things like multiple processes and supervisors: crashing and restarting is often the most reliable way to recover from an error.</p> <p>We also don’t recommend using <a href=\"https://nodejs.org/api/domain.html\">domains</a>. It generally doesn’t solve the problem and is a deprecated module.</p>  <h4 id=\"use-try-catch\">Use try-catch</h4> <p>Try-catch is a JavaScript language construct that you can use to catch exceptions in synchronous code. Use try-catch, for example, to handle JSON parsing errors as shown below.</p> <p>Use a tool such as <a href=\"http://jshint.com/\">JSHint</a> or <a href=\"http://www.jslint.com/\">JSLint</a> to help you find implicit exceptions like <a href=\"http://www.jshint.com/docs/options/#undef\">reference errors on undefined variables</a>.</p> <p>Here is an example of using try-catch to handle a potential process-crashing exception. This middleware function accepts a query field parameter named “params” that is a JSON object.</p> <pre data-language=\"js\">app.get('/search', function (req, res) {\n  // Simulating async operation\n  setImmediate(function () {\n    var jsonStr = req.query.params;\n    try {\n      var jsonObj = JSON.parse(jsonStr);\n      res.send('Success');\n    } catch (e) {\n      res.status(400).send('Invalid JSON string');\n    }\n  });\n});\n</pre> <p>However, try-catch works only for synchronous code. Because the Node platform is primarily asynchronous (particularly in a production environment), try-catch won’t catch a lot of exceptions.</p>  <h4 id=\"use-promises\">Use promises</h4> <p>Promises will handle any exceptions (both explicit and implicit) in asynchronous code blocks that use <code>then()</code>. Just add <code>.catch(next)</code> to the end of promise chains. For example:</p> <pre data-language=\"js\">app.get('/', function (req, res, next) {\n  // do some sync stuff\n  queryDb()\n    .then(function (data) {\n      // handle data\n      return makeCsv(data)\n    })\n    .then(function (csv) {\n      // handle csv\n    })\n    .catch(next);\n});\n\napp.use(function (err, req, res, next) {\n  // handle error\n});\n</pre> <p>Now all errors asynchronous and synchronous get propagated to the error middleware.</p> <p>However, there are two caveats:</p> <ol> <li>All your asynchronous code must return promises (except emitters). If a particular library does not return promises, convert the base object by using a helper function like <a href=\"http://bluebirdjs.com/docs/api/promise.promisifyall.html\">Bluebird.promisifyAll()</a>.</li> <li>Event emitters (like streams) can still cause uncaught exceptions. So make sure you are handling the error event properly; for example:</li> </ol> <pre data-language=\"js\">app.get('/', wrap(async (req, res, next) =&gt; {\n  let company = await getCompanyById(req.query.id)\n  let stream = getLogoStreamById(company.id)\n  stream.on('error', next).pipe(res)\n}));\n</pre> <p>For more information about error-handling by using promises, see:</p> <ul> <li><a href=\"https://strongloop.com/strongblog/async-error-handling-expressjs-es7-promises-generators/\">Asynchronous Error Handling in Express with Promises, Generators and ES7</a></li> <li><a href=\"https://strongloop.com/strongblog/promises-in-node-js-with-q-an-alternative-to-callbacks/\">Promises in Node.js with Q – An Alternative to Callbacks</a></li> </ul>  <h2 id=\"things-to-do-in-your-environment--setup\">Things to do in your environment / setup</h2> <p>Here are some things you can do in your system environment to improve your app’s performance:</p> <ul> <li>Set NODE_ENV to “production”</li> <li>Ensure your app automatically restarts</li> <li>Run your app in a cluster</li> <li>Cache request results</li> <li>Use a load balancer</li> <li>Use a reverse proxy</li> </ul> <h3 id=\"set-nodeenv-to-production\">Set NODE_ENV to “production”</h3> <p>The NODE_ENV environment variable specifies the environment in which an application is running (usually, development or production). One of the simplest things you can do to improve performance is to set NODE_ENV to “production.”</p> <p>Setting NODE_ENV to “production” makes Express:</p> <ul> <li>Cache view templates.</li> <li>Cache CSS files generated from CSS extensions.</li> <li>Generate less verbose error messages.</li> </ul> <p><a href=\"http://apmblog.dynatrace.com/2015/07/22/the-drastic-effects-of-omitting-node_env-in-your-express-js-applications/\">Tests indicate</a> that just doing this can improve app performance by a factor of three!</p> <p>If you need to write environment-specific code, you can check the value of NODE_ENV with <code>process.env.NODE_ENV</code>. Be aware that checking the value of any environment variable incurs a performance penalty, and so should be done sparingly.</p> <p>In development, you typically set environment variables in your interactive shell, for example by using <code>export</code> or your <code>.bash_profile</code> file. But in general you shouldn’t do that on a production server; instead, use your OS’s init system (systemd or Upstart). The next section provides more details about using your init system in general, but setting NODE_ENV is so important for performance (and easy to do), that it’s highlighted here.</p> <p>With Upstart, use the <code>env</code> keyword in your job file. For example:</p> <pre data-language=\"sh\"># /etc/init/env.conf\n env NODE_ENV=production\n</pre> <p>For more information, see the <a href=\"http://upstart.ubuntu.com/cookbook/#environment-variables\">Upstart Intro, Cookbook and Best Practices</a>.</p> <p>With systemd, use the <code>Environment</code> directive in your unit file. For example:</p> <pre data-language=\"sh\"># /etc/systemd/system/myservice.service\nEnvironment=NODE_ENV=production\n</pre> <p>For more information, see <a href=\"https://coreos.com/os/docs/latest/using-environment-variables-in-systemd-units.html\">Using Environment Variables In systemd Units</a>.</p> <p>If you are using StrongLoop Process Manager, you can also <a href=\"https://docs.strongloop.com/display/SLC/Setting+up+a+production+host#Settingupaproductionhost-Setenvironmentvariables\">set the environment variable when you install StrongLoop PM as a service</a>.</p> <h3 id=\"ensure-your-app-automatically-restarts\">Ensure your app automatically restarts</h3> <p>In production, you don’t want your application to be offline, ever. This means you need to make sure it restarts both if the app crashes and if the server itself crashes. Although you hope that neither of those events occurs, realistically you must account for both eventualities by:</p> <ul> <li>Using a process manager to restart the app (and Node) when it crashes.</li> <li>Using the init system provided by your OS to restart the process manager when the OS crashes. It’s also possible to use the init system without a process manager.</li> </ul> <p>Node applications crash if they encounter an uncaught exception. The foremost thing you need to do is to ensure your app is well-tested and handles all exceptions (see <a href=\"#exceptions\">handle exceptions properly</a> for details). But as a fail-safe, put a mechanism in place to ensure that if and when your app crashes, it will automatically restart.</p> <h4 id=\"use-a-process-manager\">Use a process manager</h4> <p>In development, you started your app simply from the command line with <code>node server.js</code> or something similar. But doing this in production is a recipe for disaster. If the app crashes, it will be offline until you restart it. To ensure your app restarts if it crashes, use a process manager. A process manager is a “container” for applications that facilitates deployment, provides high availability, and enables you to manage the application at runtime.</p> <p>In addition to restarting your app when it crashes, a process manager can enable you to:</p> <ul> <li>Gain insights into runtime performance and resource consumption.</li> <li>Modify settings dynamically to improve performance.</li> <li>Control clustering (StrongLoop PM and pm2).</li> </ul> <p>The most popular process managers for Node are as follows:</p> <ul> <li><a href=\"http://strong-pm.io/\">StrongLoop Process Manager</a></li> <li><a href=\"https://github.com/Unitech/pm2\">PM2</a></li> <li><a href=\"https://www.npmjs.com/package/forever\">Forever</a></li> </ul> <p>For a feature-by-feature comparison of the three process managers, see <a href=\"http://strong-pm.io/compare/\">http://strong-pm.io/compare/</a>. For a more detailed introduction to all three, see <a href=\"pm\">Process managers for Express apps</a>.</p> <p>Using any of these process managers will suffice to keep your application up, even if it does crash from time to time.</p> <p>However, StrongLoop PM has lots of features that specifically target production deployment. You can use it and the related StrongLoop tools to:</p> <ul> <li>Build and package your app locally, then deploy it securely to your production system.</li> <li>Automatically restart your app if it crashes for any reason.</li> <li>Manage your clusters remotely.</li> <li>View CPU profiles and heap snapshots to optimize performance and diagnose memory leaks.</li> <li>View performance metrics for your application.</li> <li>Easily scale to multiple hosts with integrated control for Nginx load balancer.</li> </ul> <p>As explained below, when you install StrongLoop PM as an operating system service using your init system, it will automatically restart when the system restarts. Thus, it will keep your application processes and clusters alive forever.</p> <h4 id=\"use-an-init-system\">Use an init system</h4> <p>The next layer of reliability is to ensure that your app restarts when the server restarts. Systems can still go down for a variety of reasons. To ensure that your app restarts if the server crashes, use the init system built into your OS. The two main init systems in use today are <a href=\"https://wiki.debian.org/systemd\">systemd</a> and <a href=\"http://upstart.ubuntu.com/\">Upstart</a>.</p> <p>There are two ways to use init systems with your Express app:</p> <ul> <li>Run your app in a process manager, and install the process manager as a service with the init system. The process manager will restart your app when the app crashes, and the init system will restart the process manager when the OS restarts. This is the recommended approach.</li> <li>Run your app (and Node) directly with the init system. This is somewhat simpler, but you don’t get the additional advantages of using a process manager.</li> </ul> <h5 id=\"systemd\">Systemd</h5> <p>Systemd is a Linux system and service manager. Most major Linux distributions have adopted systemd as their default init system.</p> <p>A systemd service configuration file is called a <em>unit file</em>, with a filename ending in .service. Here’s an example unit file to manage a Node app directly (replace the bold text with values for your system and app):</p> <pre data-language=\"sh\">[Unit]\nDescription=Awesome Express App\n\n[Service]\nType=simple\nExecStart=/usr/local/bin/node /projects/myapp/index.js\nWorkingDirectory=/projects/myapp\n\nUser=nobody\nGroup=nogroup\n\n# Environment variables:\nEnvironment=NODE_ENV=production\n\n# Allow many incoming connections\nLimitNOFILE=infinity\n\n# Allow core dumps for debugging\nLimitCORE=infinity\n\nStandardInput=null\nStandardOutput=syslog\nStandardError=syslog\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\n</pre> <p>For more information on systemd, see the <a href=\"http://www.freedesktop.org/software/systemd/man/systemd.unit.html\">systemd reference (man page)</a>.</p> <h5 id=\"strongloop-pm-as-a-systemd-service\">StrongLoop PM as a systemd service</h5> <p>You can easily install StrongLoop Process Manager as a systemd service. After you do, when the server restarts, it will automatically restart StrongLoop PM, which will then restart all the apps it is managing.</p> <p>To install StrongLoop PM as a systemd service:</p> <pre data-language=\"sh\">$ sudo sl-pm-install --systemd\n</pre> <p>Then start the service with:</p> <pre data-language=\"sh\">$ sudo /usr/bin/systemctl start strong-pm\n</pre> <p>For more information, see <a href=\"https://docs.strongloop.com/display/SLC/Setting+up+a+production+host#Settingupaproductionhost-RHEL7+,Ubuntu15.04or15.10\">Setting up a production host (StrongLoop documentation)</a>.</p> <h5 id=\"upstart\">Upstart</h5> <p>Upstart is a system tool available on many Linux distributions for starting tasks and services during system startup, stopping them during shutdown, and supervising them. You can configure your Express app or process manager as a service and then Upstart will automatically restart it when it crashes.</p> <p>An Upstart service is defined in a job configuration file (also called a “job”) with filename ending in <code>.conf</code>. The following example shows how to create a job called “myapp” for an app named “myapp” with the main file located at <code>/projects/myapp/index.js</code>.</p> <p>Create a file named <code>myapp.conf</code> at <code>/etc/init/</code> with the following content (replace the bold text with values for your system and app):</p> <pre data-language=\"sh\"># When to start the process\nstart on runlevel [2345]\n\n# When to stop the process\nstop on runlevel [016]\n\n# Increase file descriptor limit to be able to handle more requests\nlimit nofile 50000 50000\n\n# Use production mode\nenv NODE_ENV=production\n\n# Run as www-data\nsetuid www-data\nsetgid www-data\n\n# Run from inside the app dir\nchdir /projects/myapp\n\n# The process to start\nexec /usr/local/bin/node /projects/myapp/index.js\n\n# Restart the process if it is down\nrespawn\n\n# Limit restart attempt to 10 times within 10 seconds\nrespawn limit 10 10\n</pre> <p>NOTE: This script requires Upstart 1.4 or newer, supported on Ubuntu 12.04-14.10.</p> <p>Since the job is configured to run when the system starts, your app will be started along with the operating system, and automatically restarted if the app crashes or the system goes down.</p> <p>Apart from automatically restarting the app, Upstart enables you to use these commands:</p> <ul> <li>\n<code>start myapp</code> – Start the app</li> <li>\n<code>restart myapp</code> – Restart the app</li> <li>\n<code>stop myapp</code> – Stop the app.</li> </ul> <p>For more information on Upstart, see <a href=\"http://upstart.ubuntu.com/cookbook\">Upstart Intro, Cookbook and Best Practises</a>.</p> <h5 id=\"strongloop-pm-as-an-upstart-service\">StrongLoop PM as an Upstart service</h5> <p>You can easily install StrongLoop Process Manager as an Upstart service. After you do, when the server restarts, it will automatically restart StrongLoop PM, which will then restart all the apps it is managing.</p> <p>To install StrongLoop PM as an Upstart 1.4 service:</p> <pre data-language=\"sh\">$ sudo sl-pm-install\n</pre> <p>Then run the service with:</p> <pre data-language=\"sh\">$ sudo /sbin/initctl start strong-pm\n</pre> <p>NOTE: On systems that don’t support Upstart 1.4, the commands are slightly different. See <a href=\"https://docs.strongloop.com/display/SLC/Setting+up+a+production+host#Settingupaproductionhost-RHELLinux5and6,Ubuntu10.04-.10,11.04-.10\">Setting up a production host (StrongLoop documentation)</a> for more information.</p> <h3 id=\"run-your-app-in-a-cluster\">Run your app in a cluster</h3> <p>In a multi-core system, you can increase the performance of a Node app by many times by launching a cluster of processes. A cluster runs multiple instances of the app, ideally one instance on each CPU core, thereby distributing the load and tasks among the instances.</p> <p><img src=\"http://expressjs.com/images/clustering.png\" alt=\"Balancing between application instances using the cluster API\"></p> <p>IMPORTANT: Since the app instances run as separate processes, they do not share the same memory space. That is, objects are local to each instance of the app. Therefore, you cannot maintain state in the application code. However, you can use an in-memory datastore like <a href=\"http://redis.io/\">Redis</a> to store session-related data and state. This caveat applies to essentially all forms of horizontal scaling, whether clustering with multiple processes or multiple physical servers.</p> <p>In clustered apps, worker processes can crash individually without affecting the rest of the processes. Apart from performance advantages, failure isolation is another reason to run a cluster of app processes. Whenever a worker process crashes, always make sure to log the event and spawn a new process using cluster.fork().</p> <h4 id=\"using-nodes-cluster-module\">Using Node’s cluster module</h4> <p>Clustering is made possible with Node’s <a href=\"https://nodejs.org/dist/latest-v4.x/docs/api/cluster.html\">cluster module</a>. This enables a master process to spawn worker processes and distribute incoming connections among the workers. However, rather than using this module directly, it’s far better to use one of the many tools out there that does it for you automatically; for example <a href=\"https://www.npmjs.com/package/node-pm\">node-pm</a> or <a href=\"https://www.npmjs.com/package/cluster-service\">cluster-service</a>.</p> <h4 id=\"using-strongloop-pm\">Using StrongLoop PM</h4> <p>If you deploy your application to StrongLoop Process Manager (PM), then you can take advantage of clustering <em>without</em> modifying your application code.</p> <p>When StrongLoop Process Manager (PM) runs an application, it automatically runs it in a cluster with a number of workers equal to the number of CPU cores on the system. You can manually change the number of worker processes in the cluster using the slc command line tool without stopping the app.</p> <p>For example, assuming you’ve deployed your app to prod.foo.com and StrongLoop PM is listening on port 8701 (the default), then to set the cluster size to eight using slc:</p> <pre data-language=\"sh\">$ slc ctl -C http://prod.foo.com:8701 set-size my-app 8\n</pre> <p>For more information on clustering with StrongLoop PM, see <a href=\"https://docs.strongloop.com/display/SLC/Clustering\">Clustering</a> in StrongLoop documentation.</p> <h3 id=\"cache-request-results\">Cache request results</h3> <p>Another strategy to improve the performance in production is to cache the result of requests, so that your app does not repeat the operation to serve the same request repeatedly.</p> <p>Use a caching server like <a href=\"https://www.varnish-cache.org/\">Varnish</a> or <a href=\"https://www.nginx.com/resources/wiki/start/topics/examples/reverseproxycachingexample/\">Nginx</a> (see also <a href=\"https://serversforhackers.com/nginx-caching/\">Nginx Caching</a>) to greatly improve the speed and performance of your app.</p> <h3 id=\"use-a-load-balancer\">Use a load balancer</h3> <p>No matter how optimized an app is, a single instance can handle only a limited amount of load and traffic. One way to scale an app is to run multiple instances of it and distribute the traffic via a load balancer. Setting up a load balancer can improve your app’s performance and speed, and enable it to scale more than is possible with a single instance.</p> <p>A load balancer is usually a reverse proxy that orchestrates traffic to and from multiple application instances and servers. You can easily set up a load balancer for your app by using <a href=\"http://nginx.org/en/docs/http/load_balancing.html\">Nginx</a> or <a href=\"https://www.digitalocean.com/community/tutorials/an-introduction-to-haproxy-and-load-balancing-concepts\">HAProxy</a>.</p> <p>With load balancing, you might have to ensure that requests that are associated with a particular session ID connect to the process that originated them. This is known as <em>session affinity</em>, or <em>sticky sessions</em>, and may be addressed by the suggestion above to use a data store such as Redis for session data (depending on your application). For a discussion, see <a href=\"http://socket.io/docs/using-multiple-nodes/\">Using multiple nodes</a>.</p> <h4 id=\"using-strongloop-pm-with-an-nginx-load-balancer\">Using StrongLoop PM with an Nginx load balancer</h4> <p><a href=\"http://strong-pm.io/\">StrongLoop Process Manager</a> integrates with an Nginx Controller, making it easy to configure multi-host production environment configurations. For more information, see <a href=\"https://docs.strongloop.com/display/SLC/Scaling+to+multiple+servers\">Scaling to multiple servers</a> (StrongLoop documentation). </p> <h3 id=\"use-a-reverse-proxy\">Use a reverse proxy</h3> <p>A reverse proxy sits in front of a web app and performs supporting operations on the requests, apart from directing requests to the app. It can handle error pages, compression, caching, serving files, and load balancing among other things.</p> <p>Handing over tasks that do not require knowledge of application state to a reverse proxy frees up Express to perform specialized application tasks. For this reason, it is recommended to run Express behind a reverse proxy like <a href=\"https://www.nginx.com/\">Nginx</a> or <a href=\"http://www.haproxy.org/\">HAProxy</a> in production.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/advanced/best-practice-performance.html\" class=\"_attribution-link\">http://expressjs.com/en/advanced/best-practice-performance.html</a>\n  </p>\n</div>\n","index":"<h1>Express</h1>  <h2>express()</h2> <p>Creates an Express application. The <code>express()</code> function is a top-level function exported by the <code>express</code> module.</p> <pre data-language=\"js\">var express = require('express');\nvar app = express();\n</pre> <h3 id=\"express.methods\">Methods</h3>  <h3 id=\"express.static\" class=\"h2\">express.static(root, [options])</h3> <p>This is the only built-in middleware function in Express. It serves static files and is based on <a href=\"https://github.com/expressjs/serve-static\">serve-static</a>.</p> <p>The <code>root</code> argument refers to the root directory from which the static assets are to be served. The file to serve will be determined by combining <code>req.url</code> with the provided <code>root</code> directory. When a file is not found, instead of sending a 404 response, this module will instead call <code>next()</code> to move on to the next middleware, allowing for stacking and fall-backs.</p> <p>The following table describes the properties of the <code>options</code> object.</p> <table> <thead> <tr> <th>Property</th> <th>Description</th> <th>Type</th> <th>Default</th> </tr> </thead> <tbody> <tr> <td><code>dotfiles</code></td> <td>Determines how dotfiles (files or directories that begin with a dot “.”) are treated. <br><br>See <a href=\"#dotfiles\">dotfiles</a> below.</td> <td>String</td> <td>“ignore”</td> </tr> <tr> <td><code>etag</code></td> <td>Enable or disable etag generation <br><br>NOTE: <code>express.static</code> always sends weak ETags.</td> <td>Boolean</td> <td><code>true</code></td> </tr> <tr> <td><code>extensions</code></td> <td>Sets file extension fallbacks: If a file is not found, search for files with the specified extensions and serve the first one found. Example: <code>['html', 'htm']</code>.</td> <td>Boolean</td> <td><code>false</code></td> </tr> <tr> <td><code>fallthrough</code></td> <td>Let client errors fall-through as unhandled requests, otherwise forward a client error. <br><br>See <a href=\"#fallthrough\">fallthrough</a> below.</td> <td>Boolean</td> <td><code>true</code></td> </tr> <tr> <td><code>index</code></td> <td>Sends the specified directory index file. Set to <code>false</code> to disable directory indexing.</td> <td>Mixed</td> <td>“index.html”</td> </tr> <tr> <td><code>lastModified</code></td> <td>Set the <code>Last-Modified</code> header to the last modified date of the file on the OS.</td> <td>Boolean</td> <td><code>true</code></td> </tr> <tr> <td><code>maxAge</code></td> <td>Set the max-age property of the Cache-Control header in milliseconds or a string in <a href=\"https://www.npmjs.org/package/ms\">ms format</a>.</td> <td>Number</td> <td>0</td> </tr> <tr> <td><code>redirect</code></td> <td>Redirect to trailing “/” when the pathname is a directory.</td> <td>Boolean</td> <td><code>true</code></td> </tr> <tr> <td><code>setHeaders</code></td> <td>Function for setting HTTP headers to serve with the file. <br><br>See <a href=\"#setHeaders\">setHeaders</a> below.</td> <td>Function</td> <td> </td> </tr> </tbody> </table> <p>For more information, see <a href=\"http://expressjs.com/starter/static-files.html\">Serving static files in Express</a>.</p> <h5 id=\"dotfiles\"> dotfiles</h5> <p>Possible values for this option are:</p> <ul> <li>“allow” - No special treatment for dotfiles.</li> <li>“deny” - Deny a request for a dotfile, respond with <code>403</code>, then call <code>next()</code>.</li> <li>“ignore” - Act as if the dotfile does not exist, respond with <code>404</code>, then call <code>next()</code>.</li> </ul> <p><strong>NOTE</strong>: With the default value, it will not ignore files in a directory that begins with a dot.</p> <h5 id=\"fallthrough\">fallthrough</h5> <p>When this option is <code>true</code>, client errors such as a bad request or a request to a non-existent file will cause this middleware to simply call <code>next()</code> to invoke the next middleware in the stack. When false, these errors (even 404s), will invoke <code>next(err)</code>.</p> <p>Set this option to <code>true</code> so you can map multiple physical directories to the same web address or for routes to fill in non-existent files.</p> <p>Use <code>false</code> if you have mounted this middleware at a path designed to be strictly a single file system directory, which allows for short-circuiting 404s for less overhead. This middleware will also reply to all methods.</p> <h5 id=\"setHeaders\">setHeaders</h5> <p>For this option, specify a function to set custom response headers. Alterations to the headers must occur synchronously.</p> <p>The signature of the function is:</p> <pre data-language=\"js\">fn(res, path, stat)\n</pre> <p>Arguments:</p> <ul> <li>\n<code>res</code>, the <a href=\"#res\">response object</a>.</li> <li>\n<code>path</code>, the file path that is being sent.</li> <li>\n<code>stat</code>, the <code>stat</code> object of the file that is being sent.</li> </ul>   <h3 id=\"express.router\" class=\"h2\">express.Router([options])</h3> <p>Creates a new <a href=\"#router\">router</a> object.</p> <pre data-language=\"js\">var router = express.Router([options]);\n</pre> <p>The optional <code>options</code> parameter specifies the behavior of the router.</p> <div class=\"table-scroller\"> <table> <thead> <tr> <th>Property</th> <th>Description</th> <th>Default</th> <th>Availability</th> </tr> </thead> <tbody> <tr> <td><code>caseSensitive</code></td> <td>Enable case sensitivity.</td> <td>Disabled by default, treating “/Foo” and “/foo” as the same.</td> <td> </td> </tr> <tr> <td><code>mergeParams</code></td> <td>Preserve the <code>req.params</code> values from the parent router. If the parent and the child have conflicting param names, the child’s value take precedence.</td> <td><code>false</code></td> <td>4.5.0+</td> </tr> <tr> <td><code>strict</code></td> <td>Enable strict routing.</td> <td>Disabled by default, “/foo” and “/foo/” are treated the same by the router.</td> <td> </td> </tr> </tbody> </table> </div> <p>You can add middleware and HTTP method routes (such as <code>get</code>, <code>put</code>, <code>post</code>, and so on) to <code>router</code> just like an application.</p> <p>For more information, see <a href=\"#router\">Router</a>.</p>   <h2>Application</h2> <p>The <code>app</code> object conventionally denotes the Express application. Create it by calling the top-level <code>express()</code> function exported by the Express module:</p> <pre data-language=\"js\">var express = require('express');\nvar app = express();\n\napp.get('/', function(req, res){\n  res.send('hello world');\n});\n\napp.listen(3000);\n</pre> <p>The <code>app</code> object has methods for</p> <ul> <li>Routing HTTP requests; see for example, <a href=\"#app.METHOD\">app.METHOD</a> and <a href=\"#app.param\">app.param</a>.</li> <li>Configuring middleware; see <a href=\"#app.route\">app.route</a>.</li> <li>Rendering HTML views; see <a href=\"#app.render\">app.render</a>.</li> <li>Registering a template engine; see <a href=\"#app.engine\">app.engine</a>.</li> </ul> <p>It also has settings (properties) that affect how the application behaves; for more information, see <a href=\"#app.settings.table\">Application settings</a>.</p> <div class=\"doc-box doc-info\"> <p>The Express application object can be referred from the <a href=\"#req\">request object</a> and the <a href=\"#res\">request object</a> as <code>req.app</code>, and <code>res.app</code>, respectvely.</p> </div> <h3 id=\"app.properties\">Properties</h3>  <h3 id=\"app.locals\">app.locals</h3> <p>The <code>app.locals</code> object has properties that are local variables within the application.</p> <pre data-language=\"js\">app.locals.title\n// =&gt; 'My App'\n\napp.locals.email\n// =&gt; 'me@myapp.com'\n</pre> <p>Once set, the value of <code>app.locals</code> properties persist throughout the life of the application, in contrast with <a href=\"#res.locals\">res.locals</a> properties that are valid only for the lifetime of the request.</p> <p>You can access local variables in templates rendered within the application. This is useful for providing helper functions to templates, as well as application-level data. Local variables are available in middleware via <code>req.app.locals</code> (see <a href=\"#req.app\">req.app</a>)</p> <pre data-language=\"js\">app.locals.title = 'My App';\napp.locals.strftime = require('strftime');\napp.locals.email = 'me@myapp.com';\n</pre>   <h3 id=\"app.mountpath\">app.mountpath</h3> <p>The <code>app.mountpath</code> property contains one or more path patterns on which a sub-app was mounted.</p> <div class=\"doc-box doc-info\"> <p>A sub-app is an instance of <code>express</code> that may be used for handling the request to a route.</p> </div> <pre data-language=\"js\">var express = require('express');\n\nvar app = express(); // the main app\nvar admin = express(); // the sub app\n\nadmin.get('/', function (req, res) {\n  console.log(admin.mountpath); // /admin\n  res.send('Admin Homepage');\n});\n\napp.use('/admin', admin); // mount the sub app\n</pre> <p>It is similar to the <a href=\"#req.baseUrl\">baseUrl</a> property of the <code>req</code> object, except <code>req.baseUrl</code> returns the matched URL path, instead of the matched patterns.</p> <p>If a sub-app is mounted on multiple path patterns, <code>app.mountpath</code> returns the list of patterns it is mounted on, as shown in the following example.</p> <pre data-language=\"js\">var admin = express();\n\nadmin.get('/', function (req, res) {\n  console.log(admin.mountpath); // [ '/adm*n', '/manager' ]\n  res.send('Admin Homepage');\n});\n\nvar secret = express();\nsecret.get('/', function (req, res) {\n  console.log(secret.mountpath); // /secr*t\n  res.send('Admin Secret');\n});\n\nadmin.use('/secr*t', secret); // load the 'secret' router on '/secr*t', on the 'admin' sub app\napp.use(['/adm*n', '/manager'], admin); // load the 'admin' router on '/adm*n' and '/manager', on the parent app\n</pre>  <h3 id=\"app.events\">Events</h3>  <h3 id=\"app.onmount\">app.on('mount', callback(parent))</h3> <p>The <code>mount</code> event is fired on a sub-app, when it is mounted on a parent app. The parent app is passed to the callback function.</p> <div class=\"doc-box doc-info\"> <p><strong>NOTE</strong></p> <p>Sub-apps will:</p> <ul> <li>Not inherit the value of settings that have a default value. You must set the value in the sub-app.</li> <li>Inherit the value of settings with no default value.</li> </ul> <p>For details, see <a href=\"4x/api#app.settings.table\">Application settings</a>.</p> </div> <pre data-language=\"js\">var admin = express();\n\nadmin.on('mount', function (parent) {\n  console.log('Admin Mounted');\n  console.log(parent); // refers to the parent app\n});\n\nadmin.get('/', function (req, res) {\n  res.send('Admin Homepage');\n});\n\napp.use('/admin', admin);\n</pre>  <h3 id=\"app.methods\">Methods</h3>  <h3 id=\"app.all\">app.all(path, callback [, callback ...])</h3> <p>This method is like the standard <a href=\"#app.METHOD\">app.METHOD()</a> methods, except it matches all HTTP verbs.</p> <p>It’s useful for mapping “global” logic for specific path prefixes or arbitrary matches. For example, if you put the following at the top of all other route definitions, it requires that all routes from that point on require authentication, and automatically load a user. Keep in mind that these callbacks do not have to act as end-points: <code>loadUser</code> can perform a task, then call <code>next()</code> to continue matching subsequent routes.</p> <pre data-language=\"js\">app.all('*', requireAuthentication, loadUser);\n</pre> <p>Or the equivalent:</p> <pre data-language=\"js\">app.all('*', requireAuthentication)\napp.all('*', loadUser);\n</pre> <p>Another example is white-listed “global” functionality. The example is similar to the ones above, but it only restricts paths that start with “/api”:</p> <pre data-language=\"js\">app.all('/api/*', requireAuthentication);\n</pre>   <h3 id=\"app.delete.method\">app.delete(path, callback [, callback ...])</h3> <p>Routes HTTP DELETE requests to the specified path with the specified callback functions. For more information, see the <a href=\"http://expressjs.com/guide/routing.html\">routing guide</a>.</p> <p>You can provide multiple callback functions that behave just like middleware, except these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p> <pre data-language=\"js\">app.delete('/', function (req, res) {\n  res.send('DELETE request to homepage');\n});\n</pre>   <h3 id=\"app.disable\">app.disable(name)</h3> <p>Sets the Boolean setting <code>name</code> to <code>false</code>, where <code>name</code> is one of the properties from the <a href=\"#app.settings.table\">app settings table</a>. Calling <code>app.set('foo', false)</code> for a Boolean property is the same as calling <code>app.disable('foo')</code>.</p> <p>For example:</p> <pre data-language=\"js\">app.disable('trust proxy');\napp.get('trust proxy');\n// =&gt; false\n</pre>   <h3 id=\"app.disabled\">app.disabled(name)</h3> <p>Returns <code>true</code> if the Boolean setting <code>name</code> is disabled (<code>false</code>), where <code>name</code> is one of the properties from the <a href=\"#app.settings.table\">app settings table</a>.</p> <pre data-language=\"js\">app.disabled('trust proxy');\n// =&gt; true\n\napp.enable('trust proxy');\napp.disabled('trust proxy');\n// =&gt; false\n</pre>   <h3 id=\"app.enable\">app.enable(name)</h3> <p>Sets the Boolean setting <code>name</code> to <code>true</code>, where <code>name</code> is one of the properties from the <a href=\"#app.settings.table\">app settings table</a>. Calling <code>app.set('foo', true)</code> for a Boolean property is the same as calling <code>app.enable('foo')</code>.</p> <pre data-language=\"js\">app.enable('trust proxy');\napp.get('trust proxy');\n// =&gt; true\n</pre>   <h3 id=\"app.enabled\">app.enabled(name)</h3> <p>Returns <code>true</code> if the setting <code>name</code> is enabled (<code>true</code>), where <code>name</code> is one of the properties from the <a href=\"#app.settings.table\">app settings table</a>.</p> <pre data-language=\"js\">app.enabled('trust proxy');\n// =&gt; false\n\napp.enable('trust proxy');\napp.enabled('trust proxy');\n// =&gt; true\n</pre>   <h3 id=\"app.engine\">app.engine(ext, callback)</h3> <p>Registers the given template engine <code>callback</code> as <code>ext</code>.</p> <p>By default, Express will <code>require()</code> the engine based on the file extension. For example, if you try to render a “foo.pug” file, Express invokes the following internally, and caches the <code>require()</code> on subsequent calls to increase performance.</p> <pre data-language=\"js\">app.engine('pug', require('pug').__express);\n</pre> <p>Use this method for engines that do not provide <code>.__express</code> out of the box, or if you wish to “map” a different extension to the template engine.</p> <p>For example, to map the EJS template engine to “.html” files:</p> <pre data-language=\"js\">app.engine('html', require('ejs').renderFile);\n</pre> <p>In this case, EJS provides a <code>.renderFile()</code> method with the same signature that Express expects: <code>(path, options, callback)</code>, though note that it aliases this method as <code>ejs.__express</code> internally so if you’re using “.ejs” extensions you don’t need to do anything.</p> <p>Some template engines do not follow this convention. The <a href=\"https://github.com/tj/consolidate.js\">consolidate.js</a> library maps Node template engines to follow this convention, so they work seamlessly with Express.</p> <pre data-language=\"js\">var engines = require('consolidate');\napp.engine('haml', engines.haml);\napp.engine('html', engines.hogan);\n</pre>   <h3 id=\"app.get\">app.get(name)</h3> <p>Returns the value of <code>name</code> app setting, where <code>name</code> is one of strings in the <a href=\"#app.settings.table\">app settings table</a>. For example:</p> <pre data-language=\"js\">app.get('title');\n// =&gt; undefined\n\napp.set('title', 'My Site');\napp.get('title');\n// =&gt; \"My Site\"\n</pre>   <h3 id=\"app.get.method\">app.get(path, callback [, callback ...])</h3> <p>Routes HTTP GET requests to the specified path with the specified callback functions. For more information, see the <a href=\"http://expressjs.com/guide/routing.html\">routing guide</a>.</p> <p>You can provide multiple callback functions that behave just like middleware, except these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p> <pre data-language=\"js\">app.get('/', function (req, res) {\n  res.send('GET request to homepage');\n});\n</pre>   <h3 id=\"app.listen\">app.listen(port, [hostname], [backlog], [callback])</h3> <p>Binds and listens for connections on the specified host and port. This method is identical to Node’s <a href=\"http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback\">http.Server.listen()</a>.</p> <pre data-language=\"js\">var express = require('express');\nvar app = express();\napp.listen(3000);\n</pre> <p>The <code>app</code> returned by <code>express()</code> is in fact a JavaScript <code>Function</code>, designed to be passed to Node’s HTTP servers as a callback to handle requests. This makes it easy to provide both HTTP and HTTPS versions of your app with the same code base, as the app does not inherit from these (it is simply a callback):</p> <pre data-language=\"js\">var express = require('express');\nvar https = require('https');\nvar http = require('http');\nvar app = express();\n\nhttp.createServer(app).listen(80);\nhttps.createServer(options, app).listen(443);\n</pre> <p>The <code>app.listen()</code> method returns an <a href=\"https://nodejs.org/api/http.html#http_class_http_server\">http.Server</a> object and (for HTTP) is a convenience method for the following:</p> <pre data-language=\"js\">app.listen = function() {\n  var server = http.createServer(this);\n  return server.listen.apply(server, arguments);\n};\n</pre>   <h3 id=\"app.METHOD\">app.METHOD(path, callback [, callback ...])</h3> <p>Routes an HTTP request, where METHOD is the HTTP method of the request, such as GET, PUT, POST, and so on, in lowercase. Thus, the actual methods are <code>app.get()</code>, <code>app.post()</code>, <code>app.put()</code>, and so on. See below for the complete list.</p> <p>For more information, see the <a href=\"http://expressjs.com/guide/routing.html\">routing guide</a>.</p> <p>Express supports the following routing methods corresponding to the HTTP methods of the same names:</p> <table style=\"border: 0px; background: none\"> <tr> <td style=\"background: none; border: 0px;\"> <ul> <li><code>checkout</code></li> <li><code>copy</code></li> <li><code>delete</code></li> <li><code>get</code></li> <li><code>head</code></li> <li><code>lock</code></li> <li><code>merge</code></li> <li><code>mkactivity</code></li> </ul> </td> <td style=\"background: none; border: 0px;\"> <ul> <li><code>mkcol</code></li> <li><code>move</code></li> <li><code>m-search</code></li> <li><code>notify</code></li> <li><code>options</code></li> <li><code>patch</code></li> <li><code>post</code></li> </ul> </td> <td style=\"background: none; border: 0px;\"> <ul> <li><code>purge</code></li> <li><code>put</code></li> <li><code>report</code></li> <li><code>search</code></li> <li><code>subscribe</code></li> <li><code>trace</code></li> <li><code>unlock</code></li> <li><code>unsubscribe</code></li> </ul> </td> </tr> </table> <div class=\"doc-box doc-info\"> <p>To route methods which translate to invalid JavaScript variable names, use the bracket notation. For example, <code>app['m-search']('/', function ...</code>.</p> </div> <p>You can provide multiple callback functions that behave just like middleware, except that these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.</p> <div class=\"doc-box doc-info\"> <p>The API documentation has explicit entries only for the most popular HTTP methods <code>app.get()</code>, <code>app.post()</code>, <code>app.put()</code>, and <code>app.delete()</code>. However, the other methods listed above work in exactly the same way.</p> </div> <p>There is a special routing method, <code>app.all()</code>, that is not derived from any HTTP method. It loads middleware at a path for all request methods.</p> <p>In the following example, the handler is executed for requests to “/secret” whether using GET, POST, PUT, DELETE, or any other HTTP request method.</p> <pre data-language=\"js\">app.all('/secret', function (req, res, next) {\n  console.log('Accessing the secret section ...')\n  next() // pass control to the next handler\n});\n</pre>   <h3 id=\"app.param\">app.param([name], callback)</h3> <p>Add callback triggers to route parameters, where <code>name</code> is the name of the parameter or an array of them, and <code>callback</code> is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order.</p> <p>If <code>name</code> is an array, the <code>callback</code> trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to <code>next</code> inside the callback will call the callback for the next declared parameter. For the last parameter, a call to <code>next</code> will call the next middleware in place for the route currently being processed, just like it would if <code>name</code> were just a string.</p> <p>For example, when <code>:user</code> is present in a route path, you may map user loading logic to automatically provide <code>req.user</code> to the route, or perform validations on the parameter input.</p> <pre data-language=\"js\">app.param('user', function(req, res, next, id) {\n\n  // try to get the user details from the User model and attach it to the request object\n  User.find(id, function(err, user) {\n    if (err) {\n      next(err);\n    } else if (user) {\n      req.user = user;\n      next();\n    } else {\n      next(new Error('failed to load user'));\n    }\n  });\n});\n</pre> <p>Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers. Hence, param callbacks defined on <code>app</code> will be triggered only by route parameters defined on <code>app</code> routes.</p> <p>All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.</p> <pre data-language=\"js\">app.param('id', function (req, res, next, id) {\n  console.log('CALLED ONLY ONCE');\n  next();\n});\n\napp.get('/user/:id', function (req, res, next) {\n  console.log('although this matches');\n  next();\n});\n\napp.get('/user/:id', function (req, res) {\n  console.log('and this matches too');\n  res.end();\n});\n</pre> <p>On <code>GET /user/42</code>, the following is printed:</p> <pre data-language=\"sh\">CALLED ONLY ONCE\nalthough this matches\nand this matches too\n</pre> <pre data-language=\"js\">app.param(['id', 'page'], function (req, res, next, value) {\n  console.log('CALLED ONLY ONCE with', value);\n  next();\n});\n\napp.get('/user/:id/:page', function (req, res, next) {\n  console.log('although this matches');\n  next();\n});\n\napp.get('/user/:id/:page', function (req, res) {\n  console.log('and this matches too');\n  res.end();\n});\n</pre> <p>On <code>GET /user/42/3</code>, the following is printed:</p> <pre data-language=\"sh\">CALLED ONLY ONCE with 42\nCALLED ONLY ONCE with 3\nalthough this matches\nand this matches too\n</pre> <div class=\"doc-box doc-warn\"> <p>The following section describes <code>app.param(callback)</code>, which is deprecated as of v4.11.0.</p> </div> <p>The behavior of the <code>app.param(name, callback)</code> method can be altered entirely by passing only a function to <code>app.param()</code>. This function is a custom implementation of how <code>app.param(name, callback)</code> should behave - it accepts two parameters and must return a middleware.</p> <p>The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation.</p> <p>The middleware returned by the function decides the behavior of what happens when a URL parameter is captured.</p> <p>In this example, the <code>app.param(name, callback)</code> signature is modified to <code>app.param(name, accessId)</code>. Instead of accepting a name and a callback, <code>app.param()</code> will now accept a name and a number.</p> <pre data-language=\"js\">var express = require('express');\nvar app = express();\n\n// customizing the behavior of app.param()\napp.param(function(param, option) {\n  return function (req, res, next, val) {\n    if (val == option) {\n      next();\n    }\n    else {\n      res.sendStatus(403);\n    }\n  }\n});\n\n// using the customized app.param()\napp.param('id', 1337);\n\n// route to trigger the capture\napp.get('/user/:id', function (req, res) {\n  res.send('OK');\n});\n\napp.listen(3000, function () {\n  console.log('Ready');\n});\n</pre> <p>In this example, the <code>app.param(name, callback)</code> signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id.</p> <pre data-language=\"js\">app.param(function(param, validator) {\n  return function (req, res, next, val) {\n    if (validator(val)) {\n      next();\n    }\n    else {\n      res.sendStatus(403);\n    }\n  }\n});\n\napp.param('id', function (candidate) {\n  return !isNaN(parseFloat(candidate)) &amp;&amp; isFinite(candidate);\n});\n</pre> <div class=\"doc-box doc-info\"> <p>The ‘<code>.</code>’ character can’t be used to capture a character in your capturing regexp. For example you can’t use <code>'/user-.+/'</code> to capture <code>'users-gami'</code>, use <code>[\\\\s\\\\S]</code> or <code>[\\\\w\\\\W]</code> instead (as in <code>'/user-[\\\\s\\\\S]+/'</code>.</p> <p>Examples:</p> <pre data-language=\"js\">\n//captures '1-a_6' but not '543-azser-sder'\nrouter.get('/[0-9]+-[[\\\\w]]*', function);\n\n//captures '1-a_6' and '543-az(ser\"-sder' but not '5-a s'\nrouter.get('/[0-9]+-[[\\\\S]]*', function);\n\n//captures all (equivalent to '.*')\nrouter.get('[[\\\\s\\\\S]]*', function);\n</pre> </div>   <h3 id=\"app.path\">app.path()</h3> <p>Returns the canonical path of the app, a string.</p> <pre data-language=\"js\">var app = express()\n  , blog = express()\n  , blogAdmin = express();\n\napp.use('/blog', blog);\nblog.use('/admin', blogAdmin);\n\nconsole.log(app.path()); // ''\nconsole.log(blog.path()); // '/blog'\nconsole.log(blogAdmin.path()); // '/blog/admin'\n</pre> <p>The behavior of this method can become very complicated in complex cases of mounted apps: it is usually better to use <a href=\"#req.baseUrl\">req.baseUrl</a> to get the canonical path of the app.</p>   <h3 id=\"app.post.method\">app.post(path, callback [, callback ...])</h3> <p>Routes HTTP POST requests to the specified path with the specified callback functions. For more information, see the <a href=\"http://expressjs.com/guide/routing.html\">routing guide</a>.</p> <p>You can provide multiple callback functions that behave just like middleware, except that these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p> <pre data-language=\"js\">app.post('/', function (req, res) {\n  res.send('POST request to homepage');\n});\n</pre>   <h3 id=\"app.put.method\">app.put(path, callback [, callback ...])</h3> <p>Routes HTTP PUT requests to the specified path with the specified callback functions. For more information, see the <a href=\"http://expressjs.com/guide/routing.html\">routing guide</a>.</p> <p>You can provide multiple callback functions that behave just like middleware, except that these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p> <pre data-language=\"js\">app.put('/', function (req, res) {\n  res.send('PUT request to homepage');\n});\n</pre>   <h3 id=\"app.render\">app.render(view, [locals], callback)</h3> <p>Returns the rendered HTML of a view via the <code>callback</code> function. It accepts an optional parameter that is an object containing local variables for the view. It is like <a href=\"#res.render\">res.render()</a>, except it cannot send the rendered view to the client on its own.</p> <div class=\"doc-box doc-info\"> <p>Think of <code>app.render()</code> as a utility function for generating rendered view strings. Internally <code>res.render()</code> uses <code>app.render()</code> to render views.</p> </div> <div class=\"doc-box doc-notice\"> <p>The local variable <code>cache</code> is reserved for enabling view cache. Set it to <code>true</code>, if you want to cache view during development; view caching is enabled in production by default.</p> </div> <pre data-language=\"js\">app.render('email', function(err, html){\n  // ...\n});\n\napp.render('email', { name: 'Tobi' }, function(err, html){\n  // ...\n});\n</pre>   <h3 id=\"app.route\">app.route(path)</h3> <p>Returns an instance of a single route, which you can then use to handle HTTP verbs with optional middleware. Use <code>app.route()</code> to avoid duplicate route names (and thus typo errors).</p> <pre data-language=\"js\">var app = express();\n\napp.route('/events')\n.all(function(req, res, next) {\n  // runs for all HTTP verbs first\n  // think of it as route specific middleware!\n})\n.get(function(req, res, next) {\n  res.json(...);\n})\n.post(function(req, res, next) {\n  // maybe add a new event...\n});\n</pre>   <h3 id=\"app.set\">app.set(name, value)</h3> <p>Assigns setting <code>name</code> to <code>value</code>, where <code>name</code> is one of the properties from the <a href=\"#app.settings.table\">app settings table</a>.</p> <p>Calling <code>app.set('foo', true)</code> for a Boolean property is the same as calling <code>app.enable('foo')</code>. Similarly, calling <code>app.set('foo', false)</code> for a Boolean property is the same as calling <code>app.disable('foo')</code>.</p> <p>Retrieve the value of a setting with <a href=\"#app.get\"><code>app.get()</code></a>.</p> <pre data-language=\"js\">app.set('title', 'My Site');\napp.get('title'); // \"My Site\"\n</pre> <h4 id=\"app.settings.table\">Application Settings</h4> <p>The following table lists application settings.</p> <p>Note that sub-apps will:</p> <ul> <li>Not inherit the value of settings that have a default value. You must set the value in the sub-app.</li> <li>Inherit the value of settings with no default value; these are explicitly noted in the table below.</li> </ul> <p>Exceptions: Sub-apps will inherit the value of <code>trust proxy</code> even though it has a default value (for backward-compatibility); Sub-apps will not inherit the value of <code>view cache</code> in production (when <code>NODE_ENV</code> is “production”).</p> <div class=\"table-scroller\"> <table class=\"doctable\"> <thead><tr>\n<th id=\"app-settings-property\">Property</th>\n<th>Type</th>\n<th>Description</th>\n<th>Default</th>\n</tr></thead> <tbody> <tr> <td> <p><code>case sensitive routing</code></p> </td> <td>Boolean</td> <td>\n<p>Enable case sensitivity. When enabled, \"/Foo\" and \"/foo\" are different routes. When disabled, \"/Foo\" and \"/foo\" are treated the same.</p> <p><b>NOTE</b>: Sub-apps will inherit the value of this setting.</p> </td> <td>N/A (undefined) </td> </tr> <tr> <td> <p><code>env</code></p> </td> <td>String</td> <td>Environment mode. Be sure to set to \"production\" in a production environment; see <a href=\"http://expressjs.com/advanced/best-practice-performance.html#env\">Production best practices: performance and reliability</a>. </td> <td> <p><code>process.env.NODE_ENV</code> (<code>NODE_ENV</code> environment variable) or “development” if <code>NODE_ENV</code> is not set.</p> </td> </tr> <tr> <td> <p><code>etag</code></p> </td> <td>Varied</td> <td> <p>Set the ETag response header. For possible values, see the <a href=\"#etag.options.table\"><code>etag</code> options table</a>.</p> <p><a href=\"http://en.wikipedia.org/wiki/HTTP_ETag\">More about the HTTP ETag header</a>.</p> </td> <td> <p><code>weak</code></p> </td> </tr> <tr> <td> <p><code>jsonp callback name</code></p> </td> <td>String</td> <td>Specifies the default JSONP callback name.</td> <td> <p>“callback”</p> </td> </tr> <tr> <td> <p><code>json replacer</code></p> </td> <td>Varied</td> <td>The <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_replacer_parameter\">'replacer' argument used by `JSON.stringify`</a>. <p><b>NOTE</b>: Sub-apps will inherit the value of this setting.</p> </td> <td>N/A (undefined) </td> </tr> <tr> <td> <p><code>json spaces</code></p> </td> <td>Varied</td> <td>The <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_space_argument\">'space' argument used by `JSON.stringify`</a>. This is typically set to the number of spaces to use to indent prettified JSON. <p><b>NOTE</b>: Sub-apps will inherit the value of this setting.</p> </td> <td>N/A (undefined)</td> </tr> <tr> <td> <p><code>query parser</code></p> </td> <td>Varied</td> <td> <p>Disable query parsing by setting the value to <code>false</code>, or set the query parser to use either “simple” or “extended” or a custom query string parsing function.</p> <p>The simple query parser is based on Node’s native query parser, <a href=\"http://nodejs.org/api/querystring.html\">querystring</a>.</p> <p>The extended query parser is based on <a href=\"https://www.npmjs.org/package/qs\">qs</a>.</p> <p>A custom query string parsing function will receive the complete query string, and must return an object of query keys and their values.</p> </td> <td>\"extended\"</td> </tr> <tr> <td> <p><code>strict routing</code></p> </td> <td>Boolean</td> <td>\n<p>Enable strict routing. When enabled, the router treats \"/foo\" and \"/foo/\" as different. Otherwise, the router treats \"/foo\" and \"/foo/\" as the same.</p> <p><b>NOTE</b>: Sub-apps will inherit the value of this setting.</p> </td> <td>N/A (undefined) </td> </tr> <tr> <td> <p><code>subdomain offset</code></p> </td> <td>Number</td> <td>The number of dot-separated parts of the host to remove to access subdomain.</td> <td>2</td> </tr> <tr> <td> <p><code>trust proxy</code></p> </td> <td>Varied</td> <td> <p>Indicates the app is behind a front-facing proxy, and to use the <code>X-Forwarded-*</code> headers to determine the connection and the IP address of the client. NOTE: <code>X-Forwarded-*</code> headers are easily spoofed and the detected IP addresses are unreliable.</p> <p> When enabled, Express attempts to determine the IP address of the client connected through the front-facing proxy, or series of proxies. The `req.ips` property, then contains an array of IP addresses the client is connected through. To enable it, use the values described in the <a href=\"#trust.proxy.options.table\">trust proxy options table</a>. </p> <p> The `trust proxy` setting is implemented using the <a href=\"https://www.npmjs.org/package/proxy-addr\">proxy-addr</a> package. For more information, see its documentation. </p> <p> <b>NOTE</b>: Sub-apps <i>will</i> inherit the value of this setting, even though it has a default value. </p> </td> <td> <p><code>false</code> (disabled)</p> </td> </tr> <tr> <td> <p><code>views</code></p> </td> <td>String or Array</td> <td>A directory or an array of directories for the application's views. If an array, the views are looked up in the order they occur in the array.</td> <td> <p><code>process.cwd() + '/views'</code></p> </td> </tr> <tr> <td> <p><code>view cache</code></p> </td> <td>Boolean</td> <td>\n<p>Enables view template compilation caching.</p> <p><b>NOTE</b>: Sub-apps will not inherit the value of this setting in production (when `NODE_ENV` is \"production\").</p> </td> <td> <p><code>true</code> in production, otherwise undefined.</p> </td> </tr> <tr> <td> <p><code>view engine</code></p> </td> <td>String</td> <td>The default engine extension to use when omitted. <p><b>NOTE</b>: Sub-apps will inherit the value of this setting.</p> </td> <td>N/A (undefined)</td> </tr> <tr> <td> <p><code>x-powered-by</code></p> </td> <td>Boolean</td> <td>Enables the \"X-Powered-By: Express\" HTTP header.</td> <td> <p><code>true</code></p> </td> </tr> </tbody> </table> <h5 id=\"trust.proxy.options.table\">Options for `trust proxy` setting</h5> <p> Read <a href=\"http://expressjs.com/guide/behind-proxies.html\">Express behind proxies</a> for more information. </p> <table class=\"doctable\"> <thead><tr>\n<th>Type</th>\n<th>Value</th>\n</tr></thead> <tbody> <tr> <td>Boolean</td> <td> <p>If <code>true</code>, the client’s IP address is understood as the left-most entry in the <code>X-Forwarded-*</code> header.</p> <p>If <code>false</code>, the app is understood as directly facing the Internet and the client’s IP address is derived from <code>req.connection.remoteAddress</code>. This is the default setting.</p> </td> </tr> <tr> <td>String<br>String containing comma-separated values<br>Array of strings </td> <td> <p>An IP address, subnet, or an array of IP addresses, and subnets to trust. Pre-configured subnet names are:</p> <ul> <li>loopback - <code>127.0.0.1/8</code>, <code>::1/128</code>\n</li> <li>linklocal - <code>169.254.0.0/16</code>, <code>fe80::/10</code>\n</li> <li>uniquelocal - <code>10.0.0.0/8</code>, <code>172.16.0.0/12</code>, <code>192.168.0.0/16</code>, <code>fc00::/7</code>\n</li> </ul> <p>Set IP addresses in any of the following ways:</p> <p>Specify a single subnet:</p> <pre data-language=\"js\">app.set('trust proxy', 'loopback') \n</pre> <p>Specify a subnet and an address:</p> <pre data-language=\"js\">app.set('trust proxy', 'loopback, 123.123.123.123') \n</pre> <p>Specify multiple subnets as CSV:</p> <pre data-language=\"js\">app.set('trust proxy', 'loopback, linklocal, uniquelocal') \n</pre> <p>Specify multiple subnets as an array:</p> <pre data-language=\"js\">app.set('trust proxy', ['loopback', 'linklocal', 'uniquelocal'])\n</pre> <p>When specified, the IP addresses or the subnets are excluded from the address determination process, and the untrusted IP address nearest to the application server is determined as the client’s IP address.</p> </td> </tr> <tr> <td>Number</td> <td> <p>Trust the <i>n</i><sup>th</sup> hop from the front-facing proxy server as the client.</p> </td> </tr> <tr> <td>Function</td> <td> <p>Custom trust implementation. Use this only if you know what you are doing.</p> <pre data-language=\"js\">app.set('trust proxy', function (ip) {\n    if (ip === '127.0.0.1' || ip === '123.123.123.123') return true; // trusted IPs\n    else return false;\n  });\n</pre> </td> </tr> </tbody> </table> <h5 id=\"etag.options.table\">Options for `etag` setting</h5> <p> <strong>NOTE</strong>: These settings apply only to dynamic files, not static files. The <a href=\"#express.static\">express.static</a> middleware ignores these settings. </p> <p> The ETag functionality is implemented using the <a href=\"https://www.npmjs.org/package/etag\">etag</a> package. For more information, see its documentation. </p> <table class=\"doctable\"> <thead><tr>\n<th>Type</th>\n<th>Value</th>\n</tr></thead> <tbody> <tr> <td>Boolean</td> <td> <p><code>true</code> enables weak ETag. This is the default setting.<br> <code>false</code> disables ETag altogether.</p> </td> </tr> <tr> <td>String</td> <td> If \"strong\", enables strong ETag.<br> If \"weak\", enables weak ETag. </td> </tr> <tr> <td>Function</td> <td> <p>Custom ETag function implementation. Use this only if you know what you are doing.</p> <pre data-language=\"js\"> app.set('etag', function (body, encoding) {\n  return generateHash(body, encoding); // consider the function is defined\n  });\n</pre> </td> </tr> </tbody> </table> </div>   <h3 id=\"app.use\">app.use([path,] function [, function...])</h3> <p>Mounts the specified <a href=\"http://expressjs.com/guide/using-middleware.html\">middleware</a> function or functions at the specified path. If <code>path</code> is not specified, it defaults to “/”.</p> <div class=\"doc-box doc-info\"> <p>A route will match any path that follows its path immediately with a “<code>/</code>”. For example: <code>app.use('/apple', ...)</code> will match “/apple”, “/apple/images”, “/apple/images/news”, and so on.</p> </div> <p>Note that <code>req.originalUrl</code> in a middleware function is a combination of <code>req.baseUrl</code> and <code>req.path</code>, as shown in the following example.</p> <pre data-language=\"js\">app.use('/admin', function(req, res, next) {\n  // GET 'http://www.example.com/admin/new'\n  console.log(req.originalUrl); // '/admin/new'\n  console.log(req.baseUrl); // '/admin'\n  console.log(req.path); // '/new'\n  next();\n});\n</pre> <p>Mounting a middleware function at a <code>path</code> will cause the middleware function to be executed whenever the base of the requested path matches the <code>path</code>.</p> <p>Since <code>path</code> defaults to “/”, middleware mounted without a path will be executed for every request to the app.</p> <pre data-language=\"js\">// this middleware will be executed for every request to the app\napp.use(function (req, res, next) {\n  console.log('Time: %d', Date.now());\n  next();\n});\n</pre> <div class=\"doc-box doc-info\"> <p><strong>NOTE</strong></p> <p>Sub-apps will:</p> <ul> <li>Not inherit the value of settings that have a default value. You must set the value in the sub-app.</li> <li>Inherit the value of settings with no default value.</li> </ul> <p>For details, see <a href=\"4x/api#app.settings.table\">Application settings</a>.</p> </div> <p>Middleware functions are executed sequentially, therefore the order of middleware inclusion is important.</p> <pre data-language=\"js\">// this middleware will not allow the request to go beyond it\napp.use(function(req, res, next) {\n  res.send('Hello World');\n});\n\n// requests will never reach this route\napp.get('/', function (req, res) {\n  res.send('Welcome');\n});\n</pre> <p><code>path</code> can be a string representing a path, a path pattern, a regular expression to match paths, or an array of combinations thereof.</p> <p>The following table provides some simple examples of mounting middleware.</p> <div class=\"table-scroller\"> <table class=\"doctable\"> <thead> <tr> <th> Type </th> <th> Example </th> </tr> </thead> <tbody> <tr> <td>Path</td> <td> This will match paths starting with `/abcd`: <pre data-language=\"js\">app.use('/abcd', function (req, res, next) {\n  next();\n});\n</pre> </td> </tr> <tr> <td>Path Pattern</td> <td> This will match paths starting with `/abcd` and `/abd`: <pre data-language=\"js\">app.use('/abc?d', function (req, res, next) {\n  next();\n});\n</pre> This will match paths starting with `/abcd`, `/abbcd`, `/abbbbbcd`, and so on: <pre data-language=\"js\">\napp.use('/ab+cd', function (req, res, next) {\n  next();\n});</pre> This will match paths starting with `/abcd`, `/abxcd`, `/abFOOcd`, `/abbArcd`, and so on: <pre data-language=\"js\">\napp.use('/ab\\*cd', function (req, res, next) {\n  next();\n});</pre> This will match paths starting with `/ad` and `/abcd`: <pre data-language=\"js\">\napp.use('/a(bc)?d', function (req, res, next) {\n  next();\n});</pre> </td> </tr> <tr> <td>Regular Expression</td> <td> This will match paths starting with `/abc` and `/xyz`: <pre data-language=\"js\">app.use(/\\/abc|\\/xyz/, function (req, res, next) {\n  next();\n});</pre> </td> </tr> <tr> <td>Array</td> <td> This will match paths starting with `/abcd`, `/xyza`, `/lmn`, and `/pqr`: <pre data-language=\"js\">app.use(['/abcd', '/xyza', /\\/lmn|\\/pqr/], function (req, res, next) {\n  next();\n});</pre> </td> </tr> </tbody> </table> </div> <p><code>function</code> can be a middleware function, a series of middleware functions, an array of middleware functions, or a combination of all of them. Since <a href=\"#router\">router</a> and <a href=\"#application\">app</a> implement the middleware interface, you can use them as you would any other middleware function.</p> <table class=\"doctable\"> <thead> <tr> <th>Usage</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td>Single Middleware</td> <td>You can define and mount a middleware function locally. <pre data-language=\"js\">app.use(function (req, res, next) {\n  next();\n});\n</pre> A router is valid middleware. <pre data-language=\"js\">var router = express.Router();\nrouter.get('/', function (req, res, next) {\n  next();\n});\napp.use(router);\n</pre> An Express app is valid middleware. <pre data-language=\"js\">var subApp = express();\nsubApp.get('/', function (req, res, next) {\n  next();\n});\napp.use(subApp);\n</pre> </td> </tr> <tr> <td>Series of Middleware</td> <td> You can specify more than one middleware function at the same mount path. <pre data-language=\"js\">var r1 = express.Router();\nr1.get('/', function (req, res, next) {\n  next();\n});\n\nvar r2 = express.Router();\nr2.get('/', function (req, res, next) {\n  next();\n});\n\napp.use(r1, r2);\n</pre> </td> </tr> <tr> <td>Array</td> <td> Use an array to group middleware logically. If you pass an array of middleware as the first or only middleware parameters, then you <em>must</em> specify the mount path. <pre data-language=\"js\">var r1 = express.Router();\nr1.get('/', function (req, res, next) {\n  next();\n});\n\nvar r2 = express.Router();\nr2.get('/', function (req, res, next) {\n  next();\n});\n\napp.use('/', [r1, r2]);\n</pre> </td> </tr> <tr> <td>Combination</td> <td> You can combine all the above ways of mounting middleware. <pre data-language=\"js\">function mw1(req, res, next) { next(); }\nfunction mw2(req, res, next) { next(); }\n\nvar r1 = express.Router();\nr1.get('/', function (req, res, next) { next(); });\n\nvar r2 = express.Router();\nr2.get('/', function (req, res, next) { next(); });\n\nvar subApp = express();\nsubApp.get('/', function (req, res, next) { next(); });\n\napp.use(mw1, [mw2, r1, r2], subApp);\n</pre> </td> </tr> </tbody> </table> <p>Following are some examples of using the <a href=\"http://expressjs.com/guide/using-middleware.html#middleware.built-in\">express.static</a> middleware in an Express app.</p> <p>Serve static content for the app from the “public” directory in the application directory:</p> <pre data-language=\"js\">// GET /style.css etc\napp.use(express.static(__dirname + '/public'));\n</pre> <p>Mount the middleware at “/static” to serve static content only when their request path is prefixed with “/static”:</p> <pre data-language=\"js\">// GET /static/style.css etc.\napp.use('/static', express.static(__dirname + '/public'));\n</pre> <p>Disable logging for static content requests by loading the logger middleware after the static middleware:</p> <pre data-language=\"js\">app.use(express.static(__dirname + '/public'));\napp.use(logger());\n</pre> <p>Serve static files from multiple directories, but give precedence to “./public” over the others:</p> <pre data-language=\"js\">app.use(express.static(__dirname + '/public'));\napp.use(express.static(__dirname + '/files'));\napp.use(express.static(__dirname + '/uploads'));\n</pre>   <h2>Request</h2> <p>The <code>req</code> object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention, the object is always referred to as <code>req</code> (and the HTTP response is <code>res</code>) but its actual name is determined by the parameters to the callback function in which you’re working.</p> <p>For example:</p> <pre data-language=\"js\">app.get('/user/:id', function(req, res) {\n  res.send('user ' + req.params.id);\n});\n</pre> <p>But you could just as well have:</p> <pre data-language=\"js\">app.get('/user/:id', function(request, response) {\n  response.send('user ' + request.params.id);\n});\n</pre> <p>The <code>req</code> object is an enhanced version of Node’s own request object and supports all <a href=\"https://nodejs.org/api/http.html#http_class_http_incomingmessage\">built-in fields and methods</a>.</p> <h3 id=\"req.properties\">Properties</h3> <div class=\"doc-box doc-notice\"> <p>In Express 4, <code>req.files</code> is no longer available on the <code>req</code> object by default. To access uploaded files on the <code>req.files</code> object, use multipart-handling middleware like <a href=\"#\">busboy</a>, <a href=\"https://www.npmjs.com/package/multer\">multer</a>, <a href=\"https://www.npmjs.com/package/formidable\">formidable</a>, <a href=\"https://www.npmjs.com/package/multiparty\">multiparty</a>, <a href=\"https://www.npmjs.com/package/connect-multiparty\">connect-multiparty</a>, or <a href=\"https://www.npmjs.com/package/pez\">pez</a>.</p> </div>  <h3 id=\"req.app\">req.app</h3> <p>This property holds a reference to the instance of the Express application that is using the middleware.</p> <p>If you follow the pattern in which you create a module that just exports a middleware function and <code>require()</code> it in your main file, then the middleware can access the Express instance via <code>req.app</code></p> <p>For example:</p> <pre data-language=\"js\">//index.js\napp.get('/viewdirectory', require('./mymiddleware.js'))\n</pre> <pre data-language=\"js\">//mymiddleware.js\nmodule.exports = function (req, res) {\n  res.send('The views directory is ' + req.app.get('views'));\n});\n</pre>   <h3 id=\"req.baseUrl\">req.baseUrl</h3> <p>The URL path on which a router instance was mounted.</p> <p>The <code>req.baseUrl</code> property is similar to the <a href=\"#app.mountpath\">mountpath</a> property of the <code>app</code> object, except <code>app.mountpath</code> returns the matched path pattern(s).</p> <p>For example:</p> <pre data-language=\"js\">var greet = express.Router();\n\ngreet.get('/jp', function (req, res) {\n  console.log(req.baseUrl); // /greet\n  res.send('Konichiwa!');\n});\n\napp.use('/greet', greet); // load the router on '/greet'\n</pre> <p>Even if you use a path pattern or a set of path patterns to load the router, the <code>baseUrl</code> property returns the matched string, not the pattern(s). In the following example, the <code>greet</code> router is loaded on two path patterns.</p> <pre data-language=\"js\">app.use(['/gre+t', '/hel{2}o'], greet); // load the router on '/gre+t' and '/hel{2}o'\n</pre> <p>When a request is made to <code>/greet/jp</code>, <code>req.baseUrl</code> is “/greet”. When a request is made to <code>/hello/jp</code>, <code>req.baseUrl</code> is “/hello”.</p>   <h3 id=\"req.body\">req.body</h3> <p>Contains key-value pairs of data submitted in the request body. By default, it is <code>undefined</code>, and is populated when you use body-parsing middleware such as <a href=\"https://www.npmjs.org/package/body-parser\">body-parser</a> and <a href=\"https://www.npmjs.org/package/multer\">multer</a>.</p> <p>The following example shows how to use body-parsing middleware to populate <code>req.body</code>.</p> <pre data-language=\"js\">var app = require('express')();\nvar bodyParser = require('body-parser');\nvar multer = require('multer'); // v1.0.5\nvar upload = multer(); // for parsing multipart/form-data\n\napp.use(bodyParser.json()); // for parsing application/json\napp.use(bodyParser.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded\n\napp.post('/profile', upload.array(), function (req, res, next) {\n  console.log(req.body);\n  res.json(req.body);\n});\n</pre>   <h3 id=\"req.cookies\">req.cookies</h3> <p>When using <a href=\"https://www.npmjs.com/package/cookie-parser\">cookie-parser</a> middleware, this property is an object that contains cookies sent by the request. If the request contains no cookies, it defaults to <code>{}</code>.</p> <pre data-language=\"js\">// Cookie: name=tj\nreq.cookies.name\n// =&gt; \"tj\"\n</pre> <p>For more information, issues, or concerns, see <a href=\"https://github.com/expressjs/cookie-parser\">cookie-parser</a>.</p>   <h3 id=\"req.fresh\">req.fresh</h3> <p>Indicates whether the request is “fresh.” It is the opposite of <code>req.stale</code>.</p> <p>It is true if the <code>cache-control</code> request header doesn’t have a <code>no-cache</code> directive and any of the following are true:</p> <ul> <li>The <code>if-modified-since</code> request header is specified and <code>last-modified</code> request header is equal to or earlier than the <code>modified</code> response header.</li> <li>The <code>if-none-match</code> request header is <code>*</code>.</li> <li>The <code>if-none-match</code> request header, after being parsed into its directives, does not match the <code>etag</code> response header.</li> </ul> <pre data-language=\"js\">req.fresh\n// =&gt; true\n</pre> <p>For more information, issues, or concerns, see <a href=\"https://github.com/jshttp/fresh\">fresh</a>.</p>   <h3 id=\"req.hostname\">req.hostname</h3> <p>Contains the hostname derived from the <code>Host</code> HTTP header.</p> <p>When the <a href=\"http://expressjs.com/4x/api.html#trust.proxy.options.table\"><code>trust proxy</code> setting</a> does not evaluate to <code>false</code>, this property will instead have the value of the <code>X-Forwarded-Host</code> header field. This header can be set by the client or by the proxy.</p> <pre data-language=\"js\">// Host: \"example.com:3000\"\nreq.hostname\n// =&gt; \"example.com\"\n</pre>   <h3 id=\"req.ip\">req.ip</h3> <p>Contains the remote IP address of the request.</p> <p>When the <a href=\"http://expressjs.com/4x/api.html#trust.proxy.options.table\"><code>trust proxy</code> setting</a> does not evaluate to <code>false</code>, the value of this property is derived from the left-most entry in the <code>X-Forwarded-For</code> header. This header can be set by the client or by the proxy.</p> <pre data-language=\"js\">req.ip\n// =&gt; \"127.0.0.1\"\n</pre>   <h3 id=\"req.ips\">req.ips</h3> <p>When the <a href=\"http://expressjs.com/4x/api.html#trust.proxy.options.table\"><code>trust proxy</code> setting</a> does not evaluate to <code>false</code>, this property contains an array of IP addresses specified in the <code>X-Forwarded-For</code> request header. Otherwise, it contains an empty array. This header can be set by the client or by the proxy.</p> <p>For example, if <code>X-Forwarded-For</code> is <code>client, proxy1, proxy2</code>, <code>req.ips</code> would be <code>[\"client\", \"proxy1\", \"proxy2\"]</code>, where <code>proxy2</code> is the furthest downstream.</p>   <h3 id=\"req.method\">req.method</h3> <p>Contains a string corresponding to the HTTP method of the request: <code>GET</code>, <code>POST</code>, <code>PUT</code>, and so on.</p>   <h3 id=\"req.originalUrl\">req.originalUrl</h3> <div class=\"doc-box doc-notice\"> <p><code>req.url</code> is not a native Express property, it is inherited from Node’s <a href=\"https://nodejs.org/api/http.html#http_message_url\">http module</a>.</p> </div> <p>This property is much like <code>req.url</code>; however, it retains the original request URL, allowing you to rewrite <code>req.url</code> freely for internal routing purposes. For example, the “mounting” feature of <a href=\"#app.use\">app.use()</a> will rewrite <code>req.url</code> to strip the mount point.</p> <pre data-language=\"js\">// GET /search?q=something\nreq.originalUrl\n// =&gt; \"/search?q=something\"\n</pre>   <h3 id=\"req.params\">req.params</h3> <p>This property is an object containing properties mapped to the named route “parameters”. For example, if you have the route <code>/user/:name</code>, then the “name” property is available as <code>req.params.name</code>. This object defaults to <code>{}</code>.</p> <pre data-language=\"js\">// GET /user/tj\nreq.params.name\n// =&gt; \"tj\"\n</pre> <p>When you use a regular expression for the route definition, capture groups are provided in the array using <code>req.params[n]</code>, where <code>n</code> is the n<sup>th</sup> capture group. This rule is applied to unnamed wild card matches with string routes such as <code>/file/*</code>:</p> <pre data-language=\"js\">// GET /file/javascripts/jquery.js\nreq.params[0]\n// =&gt; \"javascripts/jquery.js\"\n</pre>   <h3 id=\"req.path\">req.path</h3> <p>Contains the path part of the request URL.</p> <pre data-language=\"js\">// example.com/users?sort=desc\nreq.path\n// =&gt; \"/users\"\n</pre> <div class=\"doc-box doc-info\"> <p>When called from a middleware, the mount point is not included in <code>req.path</code>. See <a href=\"http://expressjs.com/4x/api.html#app.use\">app.use()</a> for more details.</p> </div>   <h3 id=\"req.protocol\">req.protocol</h3> <p>Contains the request protocol string: either <code>http</code> or (for TLS requests) <code>https</code>.</p> <p>When the <a href=\"http://expressjs.com/4x/api.html#trust.proxy.options.table\"><code>trust proxy</code> setting</a> does not evaluate to <code>false</code>, this property will use the value of the <code>X-Forwarded-Proto</code> header field if present. This header can be set by the client or by the proxy.</p> <pre data-language=\"js\">req.protocol\n// =&gt; \"http\"\n</pre>   <h3 id=\"req.query\">req.query</h3> <p>This property is an object containing a property for each query string parameter in the route. If there is no query string, it is the empty object, <code>{}</code>.</p> <pre data-language=\"js\">// GET /search?q=tobi+ferret\nreq.query.q\n// =&gt; \"tobi ferret\"\n\n// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse\nreq.query.order\n// =&gt; \"desc\"\n\nreq.query.shoe.color\n// =&gt; \"blue\"\n\nreq.query.shoe.type\n// =&gt; \"converse\"\n</pre>   <h3 id=\"req.route\">req.route</h3> <p>Contains the currently-matched route, a string. For example:</p> <pre data-language=\"js\">app.get('/user/:id?', function userIdHandler(req, res) {\n  console.log(req.route);\n  res.send('GET');\n});\n</pre> <p>Example output from the previous snippet:</p> <pre data-language=\"js\">{ path: '/user/:id?',\n  stack:\n   [ { handle: [Function: userIdHandler],\n       name: 'userIdHandler',\n       params: undefined,\n       path: undefined,\n       keys: [],\n       regexp: /^\\/?$/i,\n       method: 'get' } ],\n  methods: { get: true } }\n</pre>   <h3 id=\"req.secure\">req.secure</h3> <p>A Boolean property that is true if a TLS connection is established. Equivalent to:</p> <pre data-language=\"js\">'https' == req.protocol;\n</pre>   <h3 id=\"req.signedCookies\">req.signedCookies</h3> <p>When using <a href=\"https://www.npmjs.com/package/cookie-parser\">cookie-parser</a> middleware, this property contains signed cookies sent by the request, unsigned and ready for use. Signed cookies reside in a different object to show developer intent; otherwise, a malicious attack could be placed on <code>req.cookie</code> values (which are easy to spoof). Note that signing a cookie does not make it “hidden” or encrypted; but simply prevents tampering (because the secret used to sign is private).</p> <p>If no signed cookies are sent, the property defaults to <code>{}</code>.</p> <pre data-language=\"js\">// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3\nreq.signedCookies.user\n// =&gt; \"tobi\"\n</pre> <p>For more information, issues, or concerns, see <a href=\"https://github.com/expressjs/cookie-parser\">cookie-parser</a>.</p>   <h3 id=\"req.stale\">req.stale</h3> <p>Indicates whether the request is “stale,” and is the opposite of <code>req.fresh</code>. For more information, see <a href=\"#req.fresh\">req.fresh</a>.</p> <pre data-language=\"js\">req.stale\n// =&gt; true\n</pre>   <h3 id=\"req.subdomains\">req.subdomains</h3> <p>An array of subdomains in the domain name of the request.</p> <pre data-language=\"js\">// Host: \"tobi.ferrets.example.com\"\nreq.subdomains\n// =&gt; [\"ferrets\", \"tobi\"]\n</pre>   <h3 id=\"req.xhr\">req.xhr</h3> <p>A Boolean property that is <code>true</code> if the request’s <code>X-Requested-With</code> header field is “XMLHttpRequest”, indicating that the request was issued by a client library such as jQuery.</p> <pre data-language=\"js\">req.xhr\n// =&gt; true\n</pre>  <h3 id=\"req.methods\">Methods</h3>  <h3 id=\"req.accepts\">req.accepts(types)</h3> <p>Checks if the specified content types are acceptable, based on the request’s <code>Accept</code> HTTP header field. The method returns the best match, or if none of the specified content types is acceptable, returns <code>false</code> (in which case, the application should respond with <code>406 \"Not Acceptable\"</code>).</p> <p>The <code>type</code> value may be a single MIME type string (such as “application/json”), an extension name such as “json”, a comma-delimited list, or an array. For a list or array, the method returns the <em>best</em> match (if any).</p> <pre data-language=\"js\">// Accept: text/html\nreq.accepts('html');\n// =&gt; \"html\"\n\n// Accept: text/*, application/json\nreq.accepts('html');\n// =&gt; \"html\"\nreq.accepts('text/html');\n// =&gt; \"text/html\"\nreq.accepts(['json', 'text']);\n// =&gt; \"json\"\nreq.accepts('application/json');\n// =&gt; \"application/json\"\n\n// Accept: text/*, application/json\nreq.accepts('image/png');\nreq.accepts('png');\n// =&gt; undefined\n\n// Accept: text/*;q=.5, application/json\nreq.accepts(['html', 'json']);\n// =&gt; \"json\"\n</pre> <p>For more information, or if you have issues or concerns, see <a href=\"https://github.com/expressjs/accepts\">accepts</a>.</p>   <h3 id=\"req.acceptsCharsets\">req.acceptsCharsets(charset [, ...])</h3> <p>Returns the first accepted charset of the specified character sets, based on the request’s <code>Accept-Charset</code> HTTP header field. If none of the specified charsets is accepted, returns <code>false</code>.</p> <p>For more information, or if you have issues or concerns, see <a href=\"https://github.com/expressjs/accepts\">accepts</a>.</p>   <h3 id=\"req.acceptsEncodings\">req.acceptsEncodings(encoding [, ...])</h3> <p>Returns the first accepted encoding of the specified encodings, based on the request’s <code>Accept-Encoding</code> HTTP header field. If none of the specified encodings is accepted, returns <code>false</code>.</p> <p>For more information, or if you have issues or concerns, see <a href=\"https://github.com/expressjs/accepts\">accepts</a>.</p>   <h3 id=\"req.acceptsLanguages\">req.acceptsLanguages(lang [, ...])</h3> <p>Returns the first accepted language of the specified languages, based on the request’s <code>Accept-Language</code> HTTP header field. If none of the specified languages is accepted, returns <code>false</code>.</p> <p>For more information, or if you have issues or concerns, see <a href=\"https://github.com/expressjs/accepts\">accepts</a>.</p>   <h3 id=\"req.get\">req.get(field)</h3> <p>Returns the specified HTTP request header field (case-insensitive match). The <code>Referrer</code> and <code>Referer</code> fields are interchangeable.</p> <pre data-language=\"js\">req.get('Content-Type');\n// =&gt; \"text/plain\"\n\nreq.get('content-type');\n// =&gt; \"text/plain\"\n\nreq.get('Something');\n// =&gt; undefined\n</pre> <p>Aliased as <code>req.header(field)</code>.</p>   <h3 id=\"req.is\">req.is(type)</h3> <p>Returns <code>true</code> if the incoming request’s “Content-Type” HTTP header field matches the MIME type specified by the <code>type</code> parameter. Returns <code>false</code> otherwise.</p> <pre data-language=\"js\">// With Content-Type: text/html; charset=utf-8\nreq.is('html');\nreq.is('text/html');\nreq.is('text/*');\n// =&gt; true\n\n// When Content-Type is application/json\nreq.is('json');\nreq.is('application/json');\nreq.is('application/*');\n// =&gt; true\n\nreq.is('html');\n// =&gt; false\n</pre> <p>For more information, or if you have issues or concerns, see <a href=\"https://github.com/expressjs/type-is\">type-is</a>.</p>   <h3 id=\"req.param\">req.param(name [, defaultValue])</h3> <div class=\"doc-box doc-warn\"> <p>Deprecated. Use either <code>req.params</code>, <code>req.body</code> or <code>req.query</code>, as applicable.</p> </div> <p>Returns the value of param <code>name</code> when present.</p> <pre data-language=\"js\">// ?name=tobi\nreq.param('name')\n// =&gt; \"tobi\"\n\n// POST name=tobi\nreq.param('name')\n// =&gt; \"tobi\"\n\n// /user/tobi for /user/:name\nreq.param('name')\n// =&gt; \"tobi\"\n</pre> <p>Lookup is performed in the following order:</p> <ul> <li><code>req.params</code></li> <li><code>req.body</code></li> <li><code>req.query</code></li> </ul> <p>Optionally, you can specify <code>defaultValue</code> to set a default value if the parameter is not found in any of the request objects.</p> <div class=\"doc-box doc-warn\"> <p>Direct access to <code>req.body</code>, <code>req.params</code>, and <code>req.query</code> should be favoured for clarity - unless you truly accept input from each object.</p> <p>Body-parsing middleware must be loaded for <code>req.param()</code> to work predictably. Refer <a href=\"#req.body\">req.body</a> for details.</p> </div>   <h3 id=\"req.range\">req.range(size[, options])</h3> <p><code>Range</code> header parser.</p> <p>The <code>size</code> parameter is the maximum size of the resource.</p> <p>The <code>options</code> parameter is an object that can have the following properties.</p> <table> <thead> <tr> <th>Property</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code>combine</code></td> <td>Boolean</td> <td>Specify if overlapping &amp; adjacent ranges should be combined, defaults to <code>false</code>. When <code>true</code>, ranges will be combined and returned as if they were specified that way in the header.</td> </tr> </tbody> </table> <p>An array of ranges will be returned or negative numbers indicating an error parsing.</p> <ul> <li>\n<code>-2</code> signals a malformed header string</li> <li>\n<code>-1</code> signals an unsatisfiable range</li> </ul> <pre data-language=\"js\">// parse header from request\nvar range = req.range(1000)\n\n// the type of the range\nif (range.type === 'bytes') {\n  // the ranges\n  range.forEach(function (r) {\n    // do something with r.start and r.end\n  })\n}\n</pre>   <h2>Response</h2> <p>The <code>res</code> object represents the HTTP response that an Express app sends when it gets an HTTP request.</p> <p>In this documentation and by convention, the object is always referred to as <code>res</code> (and the HTTP request is <code>req</code>) but its actual name is determined by the parameters to the callback function in which you’re working.</p> <p>For example:</p> <pre data-language=\"js\">app.get('/user/:id', function(req, res){\n  res.send('user ' + req.params.id);\n});\n</pre> <p>But you could just as well have:</p> <pre data-language=\"js\">app.get('/user/:id', function(request, response){\n  response.send('user ' + request.params.id);\n});\n</pre> <p>The <code>res</code> object is an enhanced version of Node’s own response object and supports all <a href=\"https://nodejs.org/api/http.html#http_class_http_serverresponse\">built-in fields and methods</a>.</p> <h3 id=\"res.properties\">Properties</h3>  <h3 id=\"res.app\">res.app</h3> <p>This property holds a reference to the instance of the Express application that is using the middleware.</p> <p><code>res.app</code> is identical to the <a href=\"#req.app\">req.app</a> property in the request object.</p>   <h3 id=\"res.headersSent\">res.headersSent</h3> <p>Boolean property that indicates if the app sent HTTP headers for the response.</p> <pre data-language=\"js\">app.get('/', function (req, res) {\n  console.log(res.headersSent); // false\n  res.send('OK');\n  console.log(res.headersSent); // true\n});\n</pre>   <h3 id=\"res.locals\">res.locals</h3> <p>An object that contains response local variables scoped to the request, and therefore available only to the view(s) rendered during that request / response cycle (if any). Otherwise, this property is identical to <a href=\"#app.locals\">app.locals</a>.</p> <p>This property is useful for exposing request-level information such as the request path name, authenticated user, user settings, and so on.</p> <pre data-language=\"js\">app.use(function(req, res, next){\n  res.locals.user = req.user;\n  res.locals.authenticated = ! req.user.anonymous;\n  next();\n});\n</pre>  <h3 id=\"res.methods\">Methods</h3>  <h3 id=\"res.append\">res.append(field [, value])</h3> <div class=\"doc-box doc-info\"> <p><code>res.append()</code> is supported by Express v4.11.0+</p> </div> <p>Appends the specified <code>value</code> to the HTTP response header <code>field</code>. If the header is not already set, it creates the header with the specified value. The <code>value</code> parameter can be a string or an array.</p> <p>Note: calling <code>res.set()</code> after <code>res.append()</code> will reset the previously-set header value.</p> <pre data-language=\"js\">res.append('Link', ['&lt;http://localhost/&gt;', '&lt;http://localhost:3000/&gt;']);\nres.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');\nres.append('Warning', '199 Miscellaneous warning');\n</pre>   <h3 id=\"res.attachment\">res.attachment([filename])</h3> <p>Sets the HTTP response <code>Content-Disposition</code> header field to “attachment”. If a <code>filename</code> is given, then it sets the Content-Type based on the extension name via <code>res.type()</code>, and sets the <code>Content-Disposition</code> “filename=” parameter.</p> <pre data-language=\"js\">res.attachment();\n// Content-Disposition: attachment\n\nres.attachment('path/to/logo.png');\n// Content-Disposition: attachment; filename=\"logo.png\"\n// Content-Type: image/png\n</pre>   <h3 id=\"res.cookie\">res.cookie(name, value [, options])</h3> <p>Sets cookie <code>name</code> to <code>value</code>. The <code>value</code> parameter may be a string or object converted to JSON.</p> <p>The <code>options</code> parameter is an object that can have the following properties.</p> <table> <thead> <tr> <th>Property</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code>domain</code></td> <td>String</td> <td>Domain name for the cookie. Defaults to the domain name of the app.</td> </tr> <tr> <td><code>encode</code></td> <td>Function</td> <td>A synchronous function used for cookie value encoding. Defaults to <code>encodeURIComponent</code>.</td> </tr> <tr> <td><code>expires</code></td> <td>Date</td> <td>Expiry date of the cookie in GMT. If not specified or set to 0, creates a session cookie.</td> </tr> <tr> <td><code>httpOnly</code></td> <td>Boolean</td> <td>Flags the cookie to be accessible only by the web server.</td> </tr> <tr> <td><code>maxAge</code></td> <td>String</td> <td>Convenient option for setting the expiry time relative to the current time in milliseconds.</td> </tr> <tr> <td><code>path</code></td> <td>String</td> <td>Path for the cookie. Defaults to “/”.</td> </tr> <tr> <td><code>secure</code></td> <td>Boolean</td> <td>Marks the cookie to be used with HTTPS only.</td> </tr> <tr> <td><code>signed</code></td> <td>Boolean</td> <td>Indicates if the cookie should be signed.</td> </tr> </tbody> </table> <div class=\"doc-box doc-notice\"> <p>All <code>res.cookie()</code> does is set the HTTP <code>Set-Cookie</code> header with the options provided. Any option not specified defaults to the value stated in <a href=\"http://tools.ietf.org/html/rfc6265\">RFC 6265</a>.</p> </div> <p>For example:</p> <pre data-language=\"js\">res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true });\nres.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n</pre> <p>The <code>encode</code> option allows you to choose the function used for cookie value encoding. Does not support asynchronous functions.</p> <p>Example use case: You need to set a domain-wide cookie for another site in your organization. This other site (not under your administrative control) does not use URI-encoded cookie values.</p> <pre data-language=\"js\">//Default encoding\nres.cookie('some_cross_domain_cookie', 'http://mysubdomain.example.com',{domain:'example.com'});\n// Result: 'some_cross_domain_cookie=http%3A%2F%2Fmysubdomain.example.com; Domain=example.com; Path=/'\n\n//Custom encoding\nres.cookie('some_cross_domain_cookie', 'http://mysubdomain.example.com',{domain:'example.com', encode: String});\n// Result: 'some_cross_domain_cookie=http://mysubdomain.example.com; Domain=example.com; Path=/;'\n</pre> <p>The <code>maxAge</code> option is a convenience option for setting “expires” relative to the current time in milliseconds. The following is equivalent to the second example above.</p> <pre data-language=\"js\">res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true });\n</pre> <p>You can pass an object as the <code>value</code> parameter; it is then serialized as JSON and parsed by <code>bodyParser()</code> middleware.</p> <pre data-language=\"js\">res.cookie('cart', { items: [1,2,3] });\nres.cookie('cart', { items: [1,2,3] }, { maxAge: 900000 });\n</pre> <p>When using <a href=\"https://www.npmjs.com/package/cookie-parser\">cookie-parser</a> middleware, this method also supports signed cookies. Simply include the <code>signed</code> option set to <code>true</code>. Then <code>res.cookie()</code> will use the secret passed to <code>cookieParser(secret)</code> to sign the value.</p> <pre data-language=\"js\">res.cookie('name', 'tobi', { signed: true });\n</pre> <p>Later you may access this value through the <a href=\"#req.signedCookies\">req.signedCookie</a> object.</p>   <h3 id=\"res.clearCookie\">res.clearCookie(name [, options])</h3> <p>Clears the cookie specified by <code>name</code>. For details about the <code>options</code> object, see <a href=\"#res.cookie\">res.cookie()</a>.</p> <pre data-language=\"js\">res.cookie('name', 'tobi', { path: '/admin' });\nres.clearCookie('name', { path: '/admin' });\n</pre>   <h3 id=\"res.download\">res.download(path [, filename] [, fn])</h3> <p>Transfers the file at <code>path</code> as an “attachment”. Typically, browsers will prompt the user for download. By default, the <code>Content-Disposition</code> header “filename=” parameter is <code>path</code> (this typically appears in the browser dialog). Override this default with the <code>filename</code> parameter.</p> <p>When an error ocurrs or transfer is complete, the method calls the optional callback function <code>fn</code>. This method uses <a href=\"#res.sendFile\">res.sendFile()</a> to transfer the file.</p> <pre data-language=\"js\">res.download('/report-12345.pdf');\n\nres.download('/report-12345.pdf', 'report.pdf');\n\nres.download('/report-12345.pdf', 'report.pdf', function(err){\n  if (err) {\n    // Handle error, but keep in mind the response may be partially-sent\n    // so check res.headersSent\n  } else {\n    // decrement a download credit, etc.\n  }\n});\n</pre>   <h3 id=\"res.end\">res.end([data] [, encoding])</h3> <p>Ends the response process. This method actually comes from Node core, specifically the <a href=\"https://nodejs.org/api/http.html#http_response_end_data_encoding_callback\">response.end() method of http.ServerResponse</a>.</p> <p>Use to quickly end the response without any data. If you need to respond with data, instead use methods such as <a href=\"#res.send\">res.send()</a> and <a href=\"#res.json\">res.json()</a>.</p> <pre data-language=\"js\">res.end();\nres.status(404).end();\n</pre>   <h3 id=\"res.format\">res.format(object)</h3> <p>Performs content-negotiation on the <code>Accept</code> HTTP header on the request object, when present. It uses <a href=\"#req.accepts\">req.accepts()</a> to select a handler for the request, based on the acceptable types ordered by their quality values. If the header is not specified, the first callback is invoked. When no match is found, the server responds with 406 “Not Acceptable”, or invokes the <code>default</code> callback.</p> <p>The <code>Content-Type</code> response header is set when a callback is selected. However, you may alter this within the callback using methods such as <code>res.set()</code> or <code>res.type()</code>.</p> <p>The following example would respond with <code>{ \"message\": \"hey\" }</code> when the <code>Accept</code> header field is set to “application/json” or “*/json” (however if it is “*/*”, then the response will be “hey”).</p> <pre data-language=\"js\">res.format({\n  'text/plain': function(){\n    res.send('hey');\n  },\n\n  'text/html': function(){\n    res.send('&lt;p&gt;hey&lt;/p&gt;');\n  },\n\n  'application/json': function(){\n    res.send({ message: 'hey' });\n  },\n\n  'default': function() {\n    // log the request and respond with 406\n    res.status(406).send('Not Acceptable');\n  }\n});\n</pre> <p>In addition to canonicalized MIME types, you may also use extension names mapped to these types for a slightly less verbose implementation:</p> <pre data-language=\"js\">res.format({\n  text: function(){\n    res.send('hey');\n  },\n\n  html: function(){\n    res.send('&lt;p&gt;hey&lt;/p&gt;');\n  },\n\n  json: function(){\n    res.send({ message: 'hey' });\n  }\n});\n</pre>   <h3 id=\"res.get\">res.get(field)</h3> <p>Returns the HTTP response header specified by <code>field</code>. The match is case-insensitive.</p> <pre data-language=\"js\">res.get('Content-Type');\n// =&gt; \"text/plain\"\n</pre>   <h3 id=\"res.json\">res.json([body])</h3> <p>Sends a JSON response. This method sends a response (with the correct content-type) that is the parameter converted to a JSON string using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\">JSON.stringify()</a>.</p> <p>The parameter can be any JSON type, including object, array, string, Boolean, or number, and you can also use it to convert other values to JSON, such as <code>null</code>, and <code>undefined</code> (although these are technically not valid JSON).</p> <pre data-language=\"js\">res.json(null);\nres.json({ user: 'tobi' });\nres.status(500).json({ error: 'message' });\n</pre>   <h3 id=\"res.jsonp\">res.jsonp([body])</h3> <p>Sends a JSON response with JSONP support. This method is identical to <code>res.json()</code>, except that it opts-in to JSONP callback support.</p> <pre data-language=\"js\">res.jsonp(null);\n// =&gt; null\n\nres.jsonp({ user: 'tobi' });\n// =&gt; { \"user\": \"tobi\" }\n\nres.status(500).jsonp({ error: 'message' });\n// =&gt; { \"error\": \"message\" }\n</pre> <p>By default, the JSONP callback name is simply <code>callback</code>. Override this with the <a href=\"#app.settings.table\">jsonp callback name</a> setting.</p> <p>The following are some examples of JSONP responses using the same code:</p> <pre data-language=\"js\">// ?callback=foo\nres.jsonp({ user: 'tobi' });\n// =&gt; foo({ \"user\": \"tobi\" })\n\napp.set('jsonp callback name', 'cb');\n\n// ?cb=foo\nres.status(500).jsonp({ error: 'message' });\n// =&gt; foo({ \"error\": \"message\" })\n</pre>   <h3 id=\"res.links\">res.links(links)</h3> <p>Joins the <code>links</code> provided as properties of the parameter to populate the response’s <code>Link</code> HTTP header field.</p> <p>For example, the following call:</p> <pre data-language=\"js\">res.links({\n  next: 'http://api.example.com/users?page=2',\n  last: 'http://api.example.com/users?page=5'\n});\n</pre> <p>Yields the following results:</p> <pre data-language=\"js\">Link: &lt;http://api.example.com/users?page=2&gt;; rel=\"next\",\n      &lt;http://api.example.com/users?page=5&gt;; rel=\"last\"\n</pre>   <h3 id=\"res.location\">res.location(path)</h3> <p>Sets the response <code>Location</code> HTTP header to the specified <code>path</code> parameter.</p> <pre data-language=\"js\">res.location('/foo/bar');\nres.location('http://example.com');\nres.location('back');\n</pre> <p>A <code>path</code> value of “back” has a special meaning, it refers to the URL specified in the <code>Referer</code> header of the request. If the <code>Referer</code> header was not specified, it refers to “/”.</p> <div class=\"doc-box doc-warn\"> <p>After encoding the URL, if not encoded already, Express passes the specified URL to the browser in the <code>Location</code> header, without any validation.</p> <p>Browsers take the responsibility of deriving the intended URL from the current URL or the referring URL, and the URL specified in the <code>Location</code> header; and redirect the user accordingly.</p> </div>   <h3 id=\"res.redirect\">res.redirect([status,] path)</h3> <p>Redirects to the URL derived from the specified <code>path</code>, with specified <code>status</code>, a positive integer that corresponds to an <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\">HTTP status code</a> . If not specified, <code>status</code> defaults to “302 “Found”.</p> <pre data-language=\"js\">res.redirect('/foo/bar');\nres.redirect('http://example.com');\nres.redirect(301, 'http://example.com');\nres.redirect('../login');\n</pre> <p>Redirects can be a fully-qualified URL for redirecting to a different site:</p> <pre data-language=\"js\">res.redirect('http://google.com');\n</pre> <p>Redirects can be relative to the root of the host name. For example, if the application is on <code>http://example.com/admin/post/new</code>, the following would redirect to the URL <code>http://example.com/admin</code>:</p> <pre data-language=\"js\">res.redirect('/admin');\n</pre> <p>Redirects can be relative to the current URL. For example, from <code>http://example.com/blog/admin/</code> (notice the trailing slash), the following would redirect to the URL <code>http://example.com/blog/admin/post/new</code>.</p> <pre data-language=\"js\">res.redirect('post/new');\n</pre> <p>Redirecting to <code>post/new</code> from <code>http://example.com/blog/admin</code> (no trailing slash), will redirect to <code>http://example.com/blog/post/new</code>.</p> <p>If you found the above behavior confusing, think of path segments as directories (with trailing slashes) and files, it will start to make sense.</p> <p>Path-relative redirects are also possible. If you were on <code>http://example.com/admin/post/new</code>, the following would redirect to <code>http//example.com/admin/post</code>:</p> <pre data-language=\"js\">res.redirect('..');\n</pre> <p>A <code>back</code> redirection redirects the request back to the <a href=\"http://en.wikipedia.org/wiki/HTTP_referer\">referer</a>, defaulting to <code>/</code> when the referer is missing.</p> <pre data-language=\"js\">res.redirect('back');\n</pre>   <h3 id=\"res.render\">res.render(view [, locals] [, callback])</h3> <p>Renders a <code>view</code> and sends the rendered HTML string to the client. Optional parameters:</p> <ul> <li>\n<code>locals</code>, an object whose properties define local variables for the view.</li> <li>\n<code>callback</code>, a callback function. If provided, the method returns both the possible error and rendered string, but does not perform an automated response. When an error occurs, the method invokes <code>next(err)</code> internally.</li> </ul> <p>The <code>view</code> argument is a string that is the file path of the view file to render. This can be an absolute path, or a path relative to the <code>views</code> setting. If the path does not contain a file extension, then the <code>view engine</code> setting determines the file extension. If the path does contain a file extension, then Express will load the module for the specified template engine (via <code>require()</code>) and render it using the loaded module’s <code>__express</code> function.</p> <p>For more information, see <a href=\"http://expressjs.com/guide/using-template-engines.html\">Using template engines with Express</a>.</p> <p><strong>NOTE:</strong> The <code>view</code> argument performs file system operations like reading a file from disk and evaluating Node.js modules, and as so for security reasons should not contain input from the end-user.</p> <div class=\"doc-box doc-notice\"> <p>The local variable <code>cache</code> enables view caching. Set it to <code>true</code>, to cache the view during development; view caching is enabled in production by default.</p> </div> <pre data-language=\"js\">// send the rendered view to the client\nres.render('index');\n\n// if a callback is specified, the rendered HTML string has to be sent explicitly\nres.render('index', function(err, html) {\n  res.send(html);\n});\n\n// pass a local variable to the view\nres.render('user', { name: 'Tobi' }, function(err, html) {\n  // ...\n});\n</pre>   <h3 id=\"res.send\">res.send([body])</h3> <p>Sends the HTTP response.</p> <p>The <code>body</code> parameter can be a <code>Buffer</code> object, a <code>String</code>, an object, or an <code>Array</code>. For example:</p> <pre data-language=\"js\">res.send(new Buffer('whoop'));\nres.send({ some: 'json' });\nres.send('&lt;p&gt;some html&lt;/p&gt;');\nres.status(404).send('Sorry, we cannot find that!');\nres.status(500).send({ error: 'something blew up' });\n</pre> <p>This method performs many useful tasks for simple non-streaming responses: For example, it automatically assigns the <code>Content-Length</code> HTTP response header field (unless previously defined) and provides automatic HEAD and HTTP cache freshness support.</p> <p>When the parameter is a <code>Buffer</code> object, the method sets the <code>Content-Type</code> response header field to “application/octet-stream”, unless previously defined as shown below:</p> <pre data-language=\"js\">res.set('Content-Type', 'text/html');\nres.send(new Buffer('&lt;p&gt;some html&lt;/p&gt;'));\n</pre> <p>When the parameter is a <code>String</code>, the method sets the <code>Content-Type</code> to “text/html”:</p> <pre data-language=\"js\">res.send('&lt;p&gt;some html&lt;/p&gt;');\n</pre> <p>When the parameter is an <code>Array</code> or <code>Object</code>, Express responds with the JSON representation:</p> <pre data-language=\"js\">res.send({ user: 'tobi' });\nres.send([1,2,3]);\n</pre>   <h3 id=\"res.sendFile\">res.sendFile(path [, options] [, fn])</h3> <div class=\"doc-box doc-info\"> <p><code>res.sendFile()</code> is supported by Express v4.8.0 onwards.</p> </div> <p>Transfers the file at the given <code>path</code>. Sets the <code>Content-Type</code> response HTTP header field based on the filename’s extension. Unless the <code>root</code> option is set in the options object, <code>path</code> must be an absolute path to the file.</p> <p>The following table provides details on the <code>options</code> parameter.</p> <div class=\"table-scroller\"> <table> <thead> <tr> <th>Property</th> <th>Description</th> <th>Default</th> <th>Availability</th> </tr> </thead> <tbody> <tr> <td><code>maxAge</code></td> <td>Sets the max-age property of the <code>Cache-Control</code> header in milliseconds or a string in <a href=\"https://www.npmjs.org/package/ms\">ms format</a>\n</td> <td>0</td> <td> </td> </tr> <tr> <td><code>root</code></td> <td>Root directory for relative filenames.</td> <td> </td> <td> </td> </tr> <tr> <td><code>lastModified</code></td> <td>Sets the <code>Last-Modified</code> header to the last modified date of the file on the OS. Set <code>false</code> to disable it.</td> <td>Enabled</td> <td>4.9.0+</td> </tr> <tr> <td><code>headers</code></td> <td>Object containing HTTP headers to serve with the file.</td> <td> </td> <td> </td> </tr> <tr> <td><code>dotfiles</code></td> <td>Option for serving dotfiles. Possible values are “allow”, “deny”, “ignore”.</td> <td>“ignore”</td> <td> </td> </tr> <tr> <td><code>acceptRanges</code></td> <td>Enable or disable accepting ranged requests.</td> <td><code>true</code></td> <td>4.14+</td> </tr> <tr> <td><code>cacheControl</code></td> <td>Enable or disable setting <code>Cache-Control</code> response header.</td> <td><code>true</code></td> <td>4.14+</td> </tr> </tbody> </table> </div> <p>The method invokes the callback function <code>fn(err)</code> when the transfer is complete or when an error occurs. If the callback function is specified and an error occurs, the callback function must explicitly handle the response process either by ending the request-response cycle, or by passing control to the next route.</p> <p>Here is an example of using <code>res.sendFile</code> with all its arguments.</p> <pre data-language=\"js\">app.get('/file/:name', function (req, res, next) {\n\n  var options = {\n    root: __dirname + '/public/',\n    dotfiles: 'deny',\n    headers: {\n        'x-timestamp': Date.now(),\n        'x-sent': true\n    }\n  };\n\n  var fileName = req.params.name;\n  res.sendFile(fileName, options, function (err) {\n    if (err) {\n      console.log(err);\n      res.status(err.status).end();\n    }\n    else {\n      console.log('Sent:', fileName);\n    }\n  });\n\n});\n</pre> <p>The following example illustrates using <code>res.sendFile</code> to provide fine-grained support for serving files:</p> <pre data-language=\"js\">app.get('/user/:uid/photos/:file', function(req, res){\n  var uid = req.params.uid\n    , file = req.params.file;\n\n  req.user.mayViewFilesFrom(uid, function(yes){\n    if (yes) {\n      res.sendFile('/uploads/' + uid + '/' + file);\n    } else {\n      res.status(403).send('Sorry! you cant see that.');\n    }\n  });\n});\n</pre> <p>For more information, or if you have issues or concerns, see <a href=\"https://github.com/pillarjs/send\">send</a>.</p>   <h3 id=\"res.sendStatus\">res.sendStatus(statusCode)</h3> <p>Sets the response HTTP status code to <code>statusCode</code> and send its string representation as the response body.</p> <pre data-language=\"js\">res.sendStatus(200); // equivalent to res.status(200).send('OK')\nres.sendStatus(403); // equivalent to res.status(403).send('Forbidden')\nres.sendStatus(404); // equivalent to res.status(404).send('Not Found')\nres.sendStatus(500); // equivalent to res.status(500).send('Internal Server Error')\n</pre> <p>If an unsupported status code is specified, the HTTP status is still set to <code>statusCode</code> and the string version of the code is sent as the response body.</p> <pre data-language=\"js\">res.sendStatus(2000); // equivalent to res.status(2000).send('2000')\n</pre> <p><a href=\"http://en.wikipedia.org/wiki/List_of_HTTP_status_codes\">More about HTTP Status Codes</a></p>   <h3 id=\"res.set\">res.set(field [, value])</h3> <p>Sets the response’s HTTP header <code>field</code> to <code>value</code>. To set multiple fields at once, pass an object as the parameter.</p> <pre data-language=\"js\">res.set('Content-Type', 'text/plain');\n\nres.set({\n  'Content-Type': 'text/plain',\n  'Content-Length': '123',\n  'ETag': '12345'\n});\n</pre> <p>Aliased as <code>res.header(field [, value])</code>.</p>   <h3 id=\"res.status\">res.status(code)</h3> <p>Sets the HTTP status for the response. It is a chainable alias of Node’s <a href=\"http://nodejs.org/api/http.html#http_response_statuscode\">response.statusCode</a>.</p> <pre data-language=\"js\">res.status(403).end();\nres.status(400).send('Bad Request');\nres.status(404).sendFile('/absolute/path/to/404.png');\n</pre>   <h3 id=\"res.type\">res.type(type)</h3> <p>Sets the <code>Content-Type</code> HTTP header to the MIME type as determined by <a href=\"https://github.com/broofa/node-mime#mimelookuppath\">mime.lookup()</a> for the specified <code>type</code>. If <code>type</code> contains the “/” character, then it sets the <code>Content-Type</code> to <code>type</code>.</p> <pre data-language=\"js\">res.type('.html');              // =&gt; 'text/html'\nres.type('html');               // =&gt; 'text/html'\nres.type('json');               // =&gt; 'application/json'\nres.type('application/json');   // =&gt; 'application/json'\nres.type('png');                // =&gt; image/png:\n</pre>   <h3 id=\"res.vary\">res.vary(field)</h3> <p>Adds the field to the <code>Vary</code> response header, if it is not there already.</p> <pre data-language=\"js\">res.vary('User-Agent').render('docs');\n</pre>   <h2>Router</h2>  <p>A <code>router</code> object is an isolated instance of middleware and routes. You can think of it as a “mini-application,” capable only of performing middleware and routing functions. Every Express application has a built-in app router.</p> <p>A router behaves like middleware itself, so you can use it as an argument to <a href=\"#app.use\">app.use()</a> or as the argument to another router’s <a href=\"#router.use\">use()</a> method.</p> <p>The top-level <code>express</code> object has a <a href=\"#express.router\">Router()</a> method that creates a new <code>router</code> object.</p> <p>Once you’ve created a router object, you can add middleware and HTTP method routes (such as <code>get</code>, <code>put</code>, <code>post</code>, and so on) to it just like an application. For example:</p> <pre data-language=\"js\">// invoked for any requests passed to this router\nrouter.use(function(req, res, next) {\n  // .. some logic here .. like any other middleware\n  next();\n});\n\n// will handle any request that ends in /events\n// depends on where the router is \"use()'d\"\nrouter.get('/events', function(req, res, next) {\n  // ..\n});\n</pre> <p>You can then use a router for a particular root URL in this way separating your routes into files or even mini-apps.</p> <pre data-language=\"js\">// only requests to /calendar/* will be sent to our \"router\"\napp.use('/calendar', router);\n</pre>  <h3 id=\"router.methods\">Methods</h3>  <h3 id=\"router.all\">router.all(path, [callback, ...] callback)</h3> <p>This method is just like the <code>router.METHOD()</code> methods, except that it matches all HTTP methods (verbs).</p> <p>This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches. For example, if you placed the following route at the top of all other route definitions, it would require that all routes from that point on would require authentication, and automatically load a user. Keep in mind that these callbacks do not have to act as end points; <code>loadUser</code> can perform a task, then call <code>next()</code> to continue matching subsequent routes.</p> <pre data-language=\"js\">router.all('*', requireAuthentication, loadUser);\n</pre> <p>Or the equivalent:</p> <pre data-language=\"js\">router.all('*', requireAuthentication)\nrouter.all('*', loadUser);\n</pre> <p>Another example of this is white-listed “global” functionality. Here the example is much like before, but it only restricts paths prefixed with “/api”:</p> <pre data-language=\"js\">router.all('/api/*', requireAuthentication);\n</pre>   <h3 id=\"router.METHOD\">router.METHOD(path, [callback, ...] callback)</h3> <p>The <code>router.METHOD()</code> methods provide the routing functionality in Express, where METHOD is one of the HTTP methods, such as GET, PUT, POST, and so on, in lowercase. Thus, the actual methods are <code>router.get()</code>, <code>router.post()</code>, <code>router.put()</code>, and so on.</p> <p>You can provide multiple callbacks, and all are treated equally, and behave just like middleware, except that these callbacks may invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to perform pre-conditions on a route then pass control to subsequent routes when there is no reason to proceed with the route matched.</p> <p>The following snippet illustrates the most simple route definition possible. Express translates the path strings to regular expressions, used internally to match incoming requests. Query strings are <em>not</em> considered when performing these matches, for example “GET /” would match the following route, as would “GET /?name=tobi”.</p> <pre data-language=\"js\">router.get('/', function(req, res){\n  res.send('hello world');\n});\n</pre> <p>You can also use regular expressions—useful if you have very specific constraints, for example the following would match “GET /commits/71dbb9c” as well as “GET /commits/71dbb9c..4c084f9”.</p> <pre data-language=\"js\">router.get(/^\\/commits\\/(\\w+)(?:\\.\\.(\\w+))?$/, function(req, res){\n  var from = req.params[0];\n  var to = req.params[1] || 'HEAD';\n  res.send('commit range ' + from + '..' + to);\n});\n</pre>   <h3 id=\"router.param\">router.param(name, callback)</h3> <p>Adds callback triggers to route parameters, where <code>name</code> is the name of the parameter and <code>callback</code> is the callback function. Although <code>name</code> is technically optional, using this method without it is deprecated starting with Express v4.11.0 (see below).</p> <p>The parameters of the callback function are:</p> <ul> <li>\n<code>req</code>, the request object.</li> <li>\n<code>res</code>, the response object.</li> <li>\n<code>next</code>, indicating the next middleware function.</li> <li>The value of the <code>name</code> parameter.</li> <li>The name of the parameter.</li> </ul> <div class=\"doc-box doc-info\"> <p>Unlike <code>app.param()</code>, <code>router.param()</code> does not accept an array of route parameters.</p> </div> <p>For example, when <code>:user</code> is present in a route path, you may map user loading logic to automatically provide <code>req.user</code> to the route, or perform validations on the parameter input.</p> <pre data-language=\"js\">router.param('user', function(req, res, next, id) {\n\n  // try to get the user details from the User model and attach it to the request object\n  User.find(id, function(err, user) {\n    if (err) {\n      next(err);\n    } else if (user) {\n      req.user = user;\n      next();\n    } else {\n      next(new Error('failed to load user'));\n    }\n  });\n});\n</pre> <p>Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers. Hence, param callbacks defined on <code>router</code> will be triggered only by route parameters defined on <code>router</code> routes.</p> <p>A param callback will be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.</p> <pre data-language=\"js\">router.param('id', function (req, res, next, id) {\n  console.log('CALLED ONLY ONCE');\n  next();\n});\n\nrouter.get('/user/:id', function (req, res, next) {\n  console.log('although this matches');\n  next();\n});\n\nrouter.get('/user/:id', function (req, res) {\n  console.log('and this matches too');\n  res.end();\n});\n</pre> <p>On <code>GET /user/42</code>, the following is printed:</p> <pre data-language=\"sh\">CALLED ONLY ONCE\nalthough this matches\nand this matches too\n</pre> <div class=\"doc-box doc-warn\"> <p>The following section describes <code>router.param(callback)</code>, which is deprecated as of v4.11.0.</p> </div> <p>The behavior of the <code>router.param(name, callback)</code> method can be altered entirely by passing only a function to <code>router.param()</code>. This function is a custom implementation of how <code>router.param(name, callback)</code> should behave - it accepts two parameters and must return a middleware.</p> <p>The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation.</p> <p>The middleware returned by the function decides the behavior of what happens when a URL parameter is captured.</p> <p>In this example, the <code>router.param(name, callback)</code> signature is modified to <code>router.param(name, accessId)</code>. Instead of accepting a name and a callback, <code>router.param()</code> will now accept a name and a number.</p> <pre data-language=\"js\">var express = require('express');\nvar app = express();\nvar router = express.Router();\n\n// customizing the behavior of router.param()\nrouter.param(function(param, option) {\n  return function (req, res, next, val) {\n    if (val == option) {\n      next();\n    }\n    else {\n      res.sendStatus(403);\n    }\n  }\n});\n\n// using the customized router.param()\nrouter.param('id', 1337);\n\n// route to trigger the capture\nrouter.get('/user/:id', function (req, res) {\n  res.send('OK');\n});\n\napp.use(router);\n\napp.listen(3000, function () {\n  console.log('Ready');\n});\n</pre> <p>In this example, the <code>router.param(name, callback)</code> signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id.</p> <pre data-language=\"js\">router.param(function(param, validator) {\n  return function (req, res, next, val) {\n    if (validator(val)) {\n      next();\n    }\n    else {\n      res.sendStatus(403);\n    }\n  }\n});\n\nrouter.param('id', function (candidate) {\n  return !isNaN(parseFloat(candidate)) &amp;&amp; isFinite(candidate);\n});\n</pre>   <h3 id=\"router.route\">router.route(path)</h3> <p>Returns an instance of a single route which you can then use to handle HTTP verbs with optional middleware. Use <code>router.route()</code> to avoid duplicate route naming and thus typo errors.</p> <p>Building on the <code>router.param()</code> example above, the following code shows how to use <code>router.route()</code> to specify various HTTP method handlers.</p> <pre data-language=\"js\">var router = express.Router();\n\nrouter.param('user_id', function(req, res, next, id) {\n  // sample user, would actually fetch from DB, etc...\n  req.user = {\n    id: id,\n    name: 'TJ'\n  };\n  next();\n});\n\nrouter.route('/users/:user_id')\n.all(function(req, res, next) {\n  // runs for all HTTP verbs first\n  // think of it as route specific middleware!\n  next();\n})\n.get(function(req, res, next) {\n  res.json(req.user);\n})\n.put(function(req, res, next) {\n  // just an example of maybe updating the user\n  req.user.name = req.params.name;\n  // save user ... etc\n  res.json(req.user);\n})\n.post(function(req, res, next) {\n  next(new Error('not implemented'));\n})\n.delete(function(req, res, next) {\n  next(new Error('not implemented'));\n});\n</pre> <p>This approach re-uses the single <code>/users/:user_id</code> path and add handlers for various HTTP methods.</p> <div class=\"doc-box doc-info\"> <p>NOTE: When you use <code>router.route()</code>, middleware ordering is based on when the <em>route</em> is created, not when method handlers are added to the route. For this purpose, you can consider method handlers to belong to the route to which they were added.</p> </div>   <h3 id=\"router.use\">router.use([path], [function, ...] function)</h3> <p>Uses the specified middleware function or functions, with optional mount path <code>path</code>, that defaults to “/”.</p> <p>This method is similar to <a href=\"#app.use\">app.use()</a>. A simple example and use case is described below. See <a href=\"#app.use\">app.use()</a> for more information.</p> <p>Middleware is like a plumbing pipe: requests start at the first middleware function defined and work their way “down” the middleware stack processing for each path they match.</p> <pre data-language=\"js\">var express = require('express');\nvar app = express();\nvar router = express.Router();\n\n// simple logger for this router's requests\n// all requests to this router will first hit this middleware\nrouter.use(function(req, res, next) {\n  console.log('%s %s %s', req.method, req.url, req.path);\n  next();\n});\n\n// this will only be invoked if the path starts with /bar from the mount point\nrouter.use('/bar', function(req, res, next) {\n  // ... maybe some additional /bar logging ...\n  next();\n});\n\n// always invoked\nrouter.use(function(req, res, next) {\n  res.send('Hello World');\n});\n\napp.use('/foo', router);\n\napp.listen(3000);\n</pre> <p>The “mount” path is stripped and is <em>not</em> visible to the middleware function. The main effect of this feature is that a mounted middleware function may operate without code changes regardless of its “prefix” pathname.</p> <p>The order in which you define middleware with <code>router.use()</code> is very important. They are invoked sequentially, thus the order defines middleware precedence. For example, usually a logger is the very first middleware you would use, so that every request gets logged.</p> <pre data-language=\"js\">var logger = require('morgan');\n\nrouter.use(logger());\nrouter.use(express.static(__dirname + '/public'));\nrouter.use(function(req, res){\n  res.send('Hello');\n});\n</pre> <p>Now suppose you wanted to ignore logging requests for static files, but to continue logging routes and middleware defined after <code>logger()</code>. You would simply move the call to <code>express.static()</code> to the top, before adding the logger middleware:</p> <pre data-language=\"js\">router.use(express.static(__dirname + '/public'));\nrouter.use(logger());\nrouter.use(function(req, res){\n  res.send('Hello');\n});\n</pre> <p>Another example is serving files from multiple directories, giving precedence to “./public” over the others:</p> <pre data-language=\"js\">app.use(express.static(__dirname + '/public'));\napp.use(express.static(__dirname + '/files'));\napp.use(express.static(__dirname + '/uploads'));\n</pre> <p>The <code>router.use()</code> method also supports named parameters so that your mount points for other routers can benefit from preloading using named parameters.</p> <p><strong>NOTE</strong>: Although these middleware functions are added via a particular router, <em>when</em> they run is defined by the path they are attached to (not the router). Therefore, middleware added via one router may run for other routers if its routes match. For example, this code shows two different routers mounted on the same path:</p> <pre data-language=\"js\">var authRouter = express.Router();\nvar openRouter = express.Router();\n\nauthRouter.use(require('./authenticate').basic(usersdb));\n\nauthRouter.get('/:user_id/edit', function(req, res, next) { \n  // ... Edit user UI ...  \n});\nopenRouter.get('/', function(req, res, next) { \n  // ... List users ... \n})\nopenRouter.get('/:user_id', function(req, res, next) { \n  // ... View user ... \n})\n\napp.use('/users', authRouter);\napp.use('/users', openRouter);\n</pre> <p>Even though the authentication middleware was added via the <code>authRouter</code> it will run on the routes defined by the <code>openRouter</code> as well since both routers were mounted on <code>/users</code>. To avoid this behavior, use different paths for each router.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/4x/api.html\" class=\"_attribution-link\">http://expressjs.com/en/4x/api.html</a>\n  </p>\n</div>\n","starter/basic-routing":"<h1 id=\"basic-routing\">Basic routing</h1> <p><em>Routing</em> refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, POST, and so on).</p> <p>Each route can have one or more handler functions, which are executed when the route is matched.</p> <p>Route definition takes the following structure:</p> <pre data-language=\"js\">app.METHOD(PATH, HANDLER)\n</pre> <p>Where:</p> <ul> <li>\n<code>app</code> is an instance of <code>express</code>.</li> <li>\n<code>METHOD</code> is an <a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods\">HTTP request method</a>, in lowercase.</li> <li>\n<code>PATH</code> is a path on the server.</li> <li>\n<code>HANDLER</code> is the function executed when the route is matched.</li> </ul> <div class=\"doc-box doc-notice\"> <p>This tutorial assumes that an instance of <code>express</code> named <code>app</code> is created and the server is running. If you are not familiar with creating an app and starting it, see the <a href=\"hello-world\">Hello world example</a>.</p> </div> <p>The following examples illustrate defining simple routes.</p> <p>Respond with <code>Hello World!</code> on the homepage:</p> <pre data-language=\"js\">app.get('/', function (req, res) {\n  res.send('Hello World!');\n});\n</pre> <p>Respond to POST request on the root route (<code>/</code>), the application’s home page:</p> <pre data-language=\"js\">app.post('/', function (req, res) {\n  res.send('Got a POST request');\n});\n</pre> <p>Respond to a PUT request to the <code>/user</code> route:</p> <pre data-language=\"js\">app.put('/user', function (req, res) {\n  res.send('Got a PUT request at /user');\n});\n</pre> <p>Respond to a DELETE request to the <code>/user</code> route:</p> <pre data-language=\"js\">app.delete('/user', function (req, res) {\n  res.send('Got a DELETE request at /user');\n});\n</pre> <p>For more details about routing, see the <a href=\"../guide/routing\">routing guide</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/starter/basic-routing.html\" class=\"_attribution-link\">http://expressjs.com/en/starter/basic-routing.html</a>\n  </p>\n</div>\n","starter/static-files":"<h1 id=\"serving-static-files-in-express\">Serving static files in Express</h1> <p>To serve static files such as images, CSS files, and JavaScript files, use the <code>express.static</code> built-in middleware function in Express.</p> <p>Pass the name of the directory that contains the static assets to the <code>express.static</code> middleware function to start serving the files directly. For example, use the following code to serve images, CSS files, and JavaScript files in a directory named <code>public</code>:</p> <pre data-language=\"js\">app.use(express.static('public'));\n</pre> <p>Now, you can load the files that are in the <code>public</code> directory:</p> <pre data-language=\"plain\">http://localhost:3000/images/kitten.jpg\nhttp://localhost:3000/css/style.css\nhttp://localhost:3000/js/app.js\nhttp://localhost:3000/images/bg.png\nhttp://localhost:3000/hello.html\n</pre> <div class=\"doc-box doc-info\"> Express looks up the files relative to the static directory, so the name of the static directory is not part of the URL. </div> <p>To use multiple static assets directories, call the <code>express.static</code> middleware function multiple times:</p> <pre data-language=\"js\">app.use(express.static('public'));\napp.use(express.static('files'));\n</pre> <p>Express looks up the files in the order in which you set the static directories with the <code>express.static</code> middleware function.</p> <p>To create a virtual path prefix (where the path does not actually exist in the file system) for files that are served by the <code>express.static</code> function, <a href=\"../4x/api#app.use\">specify a mount path</a> for the static directory, as shown below:</p> <pre data-language=\"js\">app.use('/static', express.static('public'));\n</pre> <p>Now, you can load the files that are in the <code>public</code> directory from the <code>/static</code> path prefix.</p> <pre data-language=\"plain\">http://localhost:3000/static/images/kitten.jpg\nhttp://localhost:3000/static/css/style.css\nhttp://localhost:3000/static/js/app.js\nhttp://localhost:3000/static/images/bg.png\nhttp://localhost:3000/static/hello.html\n</pre> <p>However, the path that you provide to the <code>express.static</code> function is relative to the directory from where you launch your <code>node</code> process. If you run the express app from another directory, it’s safer to use the absolute path of the directory that you want to serve:</p> <pre data-language=\"js\">app.use('/static', express.static(__dirname + '/public'));\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/starter/static-files.html\" class=\"_attribution-link\">http://expressjs.com/en/starter/static-files.html</a>\n  </p>\n</div>\n","starter/faq":"<h1 id=\"faq\">FAQ</h1> <h2 id=\"how-should-i-structure-my-application\">How should I structure my application?</h2> <p>There is no definitive answer to this question. The answer depends on the scale of your application and the team that is involved. To be as flexible as possible, Express makes no assumptions in terms of structure.</p> <p>Routes and other application-specific logic can live in as many files as you wish, in any directory structure you prefer. View the following examples for inspiration:</p> <ul> <li><a href=\"https://github.com/strongloop/express/blob/4.13.1/examples/route-separation/index.js#L32-47\">Route listings</a></li> <li><a href=\"https://github.com/strongloop/express/blob/4.13.1/examples/route-map/index.js#L52-L66\">Route map</a></li> <li><a href=\"https://github.com/strongloop/express/tree/master/examples/mvc\">MVC style controllers</a></li> </ul> <p>Also, there are third-party extensions for Express, which simplify some of these patterns:</p> <ul> <li><a href=\"https://github.com/expressjs/express-resource\">Resourceful routing</a></li> </ul> <h2 id=\"how-do-i-define-models\">How do I define models?</h2> <p>Express has no notion of a database. This concept is left up to third-party Node modules, allowing you to interface with nearly any database.</p> <p>See <a href=\"http://loopback.io\">LoopBack</a> for an Express-based framework that is centered around models.</p> <h2 id=\"how-can-i-authenticate-users\">How can I authenticate users?</h2> <p>Authentication is another opinionated area that Express does not venture into. You may use any authentication scheme you wish. For a simple username / password scheme, see <a href=\"https://github.com/strongloop/express/tree/master/examples/auth\">this example</a>.</p> <h2 id=\"which-template-engines-does-express-support\">Which template engines does Express support?</h2> <p>Express supports any template engine that conforms with the <code>(path, locals, callback)</code> signature. To normalize template engine interfaces and caching, see the <a href=\"https://github.com/visionmedia/consolidate.js\">consolidate.js</a> project for support. Unlisted template engines might still support the Express signature.</p> <h2 id=\"how-do-i-handle-404-responses\">How do I handle 404 responses?</h2> <p>In Express, 404 responses are not the result of an error, so the error-handler middleware will not capture them. This behavior is because a 404 response simply indicates the absence of additional work to do; in other words, Express has executed all middleware functions and routes, and found that none of them responded. All you need to do is add a middleware function at the very bottom of the stack (below all other functions) to handle a 404 response:</p> <pre data-language=\"js\">app.use(function(req, res, next) {\n  res.status(404).send('Sorry cant find that!');\n});\n</pre> <h2 id=\"how-do-i-setup-an-error-handler\">How do I setup an error handler?</h2> <p>You define error-handling middleware in the same way as other middleware, except with four arguments instead of three; specifically with the signature <code>(err, req, res, next)</code>:</p> <pre data-language=\"js\">app.use(function(err, req, res, next) {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n</pre> <p>For more information, see <a href=\"../guide/error-handling\">Error handling</a>.</p> <h2 id=\"how-do-i-render-plain-html\">How do I render plain HTML?</h2> <p>You don’t! There’s no need to “render” HTML with the <code>res.render()</code> function. If you have a specific file, use the <code>res.sendFile()</code> function. If you are serving many assets from a directory, use the <code>express.static()</code> middleware function.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/starter/faq.html\" class=\"_attribution-link\">http://expressjs.com/en/starter/faq.html</a>\n  </p>\n</div>\n","guide/writing-middleware":"<h1 id=\"writing-middleware-for-use-in-express-apps\">Writing middleware for use in Express apps</h1> <h2>Overview</h2> <p><em>Middleware</em> functions are functions that have access to the <a href=\"http://expressjs.com/4x/api.html#req\">request object</a> (<code>req</code>), the <a href=\"http://expressjs.com/4x/api.html#res\">response object</a> (<code>res</code>), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named <code>next</code>.</p> <p>Middleware functions can perform the following tasks:</p> <ul> <li>Execute any code.</li> <li>Make changes to the request and the response objects.</li> <li>End the request-response cycle.</li> <li>Call the next middleware in the stack.</li> </ul> <p>If the current middleware function does not end the request-response cycle, it must call <code>next()</code> to pass control to the next middleware function. Otherwise, the request will be left hanging.</p> <p>The following figure shows the elements of a middleware function call:</p> <table id=\"mw-fig\"> <tr>\n<td id=\"mw-fig-imgcell\"> <img src=\"http://expressjs.com/images/express-mw.png\" id=\"mw-fig-img\"> </td> <td class=\"mw-fig-callouts\"> <div class=\"callout\" id=\"callout1\">HTTP method for which the middleware function applies.</div> <div class=\"callout\" id=\"callout2\">Path (route) for which the middleware function applies.</div> <div class=\"callout\" id=\"callout3\">The middleware function.</div> <div class=\"callout\" id=\"callout4\">Callback argument to the middleware function, called \"next\" by convention.</div> <div class=\"callout\" id=\"callout5\">HTTP <a href=\"../4x/api#res\">response</a> argument to the middleware function, called \"res\" by convention.</div> <div class=\"callout\" id=\"callout6\">HTTP <a href=\"../4x/api#req\">request</a> argument to the middleware function, called \"req\" by convention.</div> </td>\n</tr> </table> <h2>Example</h2> <p>Here is an example of a simple “Hello World” Express application. The remainder of this article will define and add two middleware functions to the application: one called <code>myLogger</code> that prints a simple log message and another called <code>requestTime</code> that displays the timestamp of the HTTP request.</p> <pre data-language=\"js\">var express = require('express');\nvar app = express();\n\napp.get('/', function (req, res) {\n  res.send('Hello World!');\n});\n\napp.listen(3000);\n</pre> <h3>Middleware function myLogger</h3> <p>Here is a simple example of a middleware function called “myLogger”. This function just prints “LOGGED” when a request to the app passes through it. The middleware function is assigned to a variable named <code>myLogger</code>.</p> <pre data-language=\"js\">var myLogger = function (req, res, next) {\n  console.log('LOGGED');\n  next();\n};\n</pre> <div class=\"doc-box doc-notice\"> <p>Notice the call above to <code>next()</code>. Calling this function invokes the next middleware function in the app. The <code>next()</code> function is not a part of the Node.js or Express API, but is the third argument that is passed to the middleware function. The <code>next()</code> function could be named anything, but by convention it is always named “next”. To avoid confusion, always use this convention.</p> </div> <p>To load the middleware function, call <code>app.use()</code>, specifying the middleware function. For example, the following code loads the <code>myLogger</code> middleware function before the route to the root path (/).</p> <pre data-language=\"js\">var express = require('express');\nvar app = express();\n\nvar myLogger = function (req, res, next) {\n  console.log('LOGGED');\n  next();\n};\n\napp.use(myLogger);\n\napp.get('/', function (req, res) {\n  res.send('Hello World!');\n});\n\napp.listen(3000);\n</pre> <p>Every time the app receives a request, it prints the message “LOGGED” to the terminal.</p> <p>The order of middleware loading is important: middleware functions that are loaded first are also executed first.</p> <p>If <code>myLogger</code> is loaded after the route to the root path, the request never reaches it and the app doesn’t print “LOGGED”, because the route handler of the root path terminates the request-response cycle.</p> <p>The middleware function <code>myLogger</code> simply prints a message, then passes on the request to the next middleware function in the stack by calling the <code>next()</code> function.</p> <h3>Middleware function requestTime</h3> <p>Next, we’ll create a middleware function called “requestTime” and add it as a property called <code>requestTime</code> to the request object.</p> <pre data-language=\"js\">var requestTime = function (req, res, next) {\n  req.requestTime = Date.now();\n  next();\n};\n</pre> <p>The app now uses the <code>requestTime</code> middleware function. Also, the callback function of the root path route uses the property that the middleware function adds to <code>req</code> (the request object).</p> <pre data-language=\"js\">var express = require('express');\nvar app = express();\n\nvar requestTime = function (req, res, next) {\n  req.requestTime = Date.now();\n  next();\n};\n\napp.use(requestTime);\n\napp.get('/', function (req, res) {\n  var responseText = 'Hello World!&lt;br&gt;';\n  responseText += '&lt;small&gt;Requested at: ' + req.requestTime + '&lt;/small&gt;';\n  res.send(responseText);\n});\n\napp.listen(3000);\n</pre> <p>When you make a request to the root of the app, the app now displays the timestamp of your request in the browser.</p> <p>Because you have access to the request object, the response object, the next middleware function in the stack, and the whole Node.js API, the possibilities with middleware functions are endless.</p> <p>For more information about Express middleware, see: <a href=\"http://expressjs.com/guide/using-middleware.html\">Using Express middleware</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/guide/writing-middleware.html\" class=\"_attribution-link\">http://expressjs.com/en/guide/writing-middleware.html</a>\n  </p>\n</div>\n","guide/using-template-engines":"<h1 id=\"using-template-engines-with-express\">Using template engines with Express</h1> <p>A <em>template engine</em> enables you to use static template files in your application. At runtime, the template engine replaces variables in a template file with actual values, and transforms the template into an HTML file sent to the client. This approach makes it easier to design an HTML page.</p> <p>Some popular template engines that work with Express are <a href=\"http://jade-lang.com/\">Pug</a>, <a href=\"https://www.npmjs.com/package/mustache\">Mustache</a>, and <a href=\"https://www.npmjs.com/package/ejs\">EJS</a>. The <a href=\"../starter/generator\">Express application generator</a> uses Pug as its default, but it also supports several others.</p> <p>See <a href=\"https://github.com/strongloop/express/wiki#template-engines\">Template Engines (Express wiki)</a> for a list of template engines you can use with Express. See also <a href=\"https://strongloop.com/strongblog/compare-javascript-templates-jade-mustache-dust/\">Comparing JavaScript Templating Engines: Jade, Mustache, Dust and More</a>.</p> <p>To render template files, set the following <a href=\"../4x/api#app.set\">application setting properties</a>:</p> <ul> <li>\n<code>views</code>, the directory where the template files are located. Eg: <code>app.set('views', './views')</code>. This defaults to the <code>views</code> directory in the application root directory.</li> <li>\n<code>view engine</code>, the template engine to use. For example, to use the Pug template engine: <code>app.set('view engine', 'pug')</code>.</li> </ul> <p>Then install the corresponding template engine npm package; for example to install Pug:</p> <pre data-language=\"sh\">$ npm install pug --save\n</pre> <div class=\"doc-box doc-notice\"> <p>Express-compliant template engines such as Pug export a function named <code>__express(filePath, options, callback)</code>, which is called by the <code>res.render()</code> function to render the template code.</p> <p>Some template engines do not follow this convention. The <a href=\"https://www.npmjs.org/package/consolidate\">Consolidate.js</a> library follows this convention by mapping all of the popular Node.js template engines, and therefore works seamlessly within Express.</p> </div> <p>After the view engine is set, you don’t have to specify the engine or load the template engine module in your app; Express loads the module internally, as shown below (for the above example).</p> <pre data-language=\"js\">app.set('view engine', 'pug');\n</pre> <p>Create a Pug template file named <code>index.pug</code> in the <code>views</code> directory, with the following content:</p> <pre data-language=\"js\">html\n  head\n    title= title\n  body\n    h1= message\n</pre> <p>Then create a route to render the <code>index.pug</code> file. If the <code>view engine</code> property is not set, you must specify the extension of the <code>view</code> file. Otherwise, you can omit it.</p> <pre data-language=\"js\">app.get('/', function (req, res) {\n  res.render('index', { title: 'Hey', message: 'Hello there!'});\n});\n</pre> <p>When you make a request to the home page, the <code>index.pug</code> file will be rendered as HTML.</p> <p>To learn more about how template engines work in Express, see: <a href=\"../advanced/developing-template-engines\">“Developing template engines for Express”</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/guide/using-template-engines.html\" class=\"_attribution-link\">http://expressjs.com/en/guide/using-template-engines.html</a>\n  </p>\n</div>\n","guide/error-handling":"<h1 id=\"error-handling\">Error handling</h1> <p>Define error-handling middleware functions in the same way as other middleware functions, except error-handling functions have four arguments instead of three: <code>(err, req, res, next)</code>. For example:</p> <pre data-language=\"js\">app.use(function(err, req, res, next) {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n</pre> <p>You define error-handling middleware last, after other <code>app.use()</code> and routes calls; for example:</p> <pre data-language=\"js\">var bodyParser = require('body-parser');\nvar methodOverride = require('method-override');\n\napp.use(bodyParser());\napp.use(methodOverride());\napp.use(function(err, req, res, next) {\n  // logic\n});\n</pre> <p>Responses from within a middleware function can be in any format that you prefer, such as an HTML error page, a simple message, or a JSON string.</p> <p>For organizational (and higher-level framework) purposes, you can define several error-handling middleware functions, much like you would with regular middleware functions. For example, if you wanted to define an error-handler for requests made by using <code>XHR</code>, and those without, you might use the following commands:</p> <pre data-language=\"js\">var bodyParser = require('body-parser');\nvar methodOverride = require('method-override');\n\napp.use(bodyParser());\napp.use(methodOverride());\napp.use(logErrors);\napp.use(clientErrorHandler);\napp.use(errorHandler);\n</pre> <p>In this example, the generic <code>logErrors</code> might write request and error information to <code>stderr</code>, for example:</p> <pre data-language=\"js\">function logErrors(err, req, res, next) {\n  console.error(err.stack);\n  next(err);\n}\n</pre> <p>Also in this example, <code>clientErrorHandler</code> is defined as follows; in this case, the error is explicitly passed along to the next one.</p> <p>Notice that when <em>not</em> calling “next” in an error-handling function, you are responsible for writing (and ending) the response. Otherwise those requests will “hang” and will not be eligible for garbage collection.</p> <pre data-language=\"js\">function clientErrorHandler(err, req, res, next) {\n  if (req.xhr) {\n    res.status(500).send({ error: 'Something failed!' });\n  } else {\n    next(err);\n  }\n}\n</pre> <p>The “catch-all” <code>errorHandler</code> function might be implemented as follows:</p> <pre data-language=\"js\">function errorHandler(err, req, res, next) {\n  res.status(500);\n  res.render('error', { error: err });\n}\n</pre> <p>If you pass anything to the <code>next()</code> function (except the string <code>'route'</code>), Express regards the current request as being in error and will skip any remaining non-error handling routing and middleware functions. If you want to handle that error in some way, you’ll have to create an error-handling route as described in the next section.</p> <p>If you have a route handler with multiple callback functions you can use the <code>route</code> parameter to skip to the next route handler. For example:</p> <pre data-language=\"js\">app.get('/a_route_behind_paywall',\n  function checkIfPaidSubscriber(req, res, next) {\n    if(!req.user.hasPaid) {\n\n      // continue handling this request\n      next('route');\n    }\n  }, function getPaidContent(req, res, next) {\n    PaidContent.find(function(err, doc) {\n      if(err) return next(err);\n      res.json(doc);\n    });\n  });\n</pre> <p>In this example, the <code>getPaidContent</code> handler will be skipped but any remaining handlers in <code>app</code> for <code>/a_route_behind_paywall</code> would continue to be executed.</p> <div class=\"doc-box doc-info\"> <p>Calls to <code>next()</code> and <code>next(err)</code> indicate that the current handler is complete and in what state. <code>next(err)</code> will skip all remaining handlers in the chain except for those that are set up to handle errors as described above.</p> </div> <h2 id=\"the-default-error-handler\">The Default Error Handler</h2> <p>Express comes with a built-in error handler, which takes care of any errors that might be encountered in the app. This default error-handling middleware function is added at the end of the middleware function stack.</p> <p>If you pass an error to <code>next()</code> and you do not handle it in an error handler, it will be handled by the built-in error handler; the error will be written to the client with the stack trace. The stack trace is not included in the production environment.</p> <div class=\"doc-box doc-info\"> <p>Set the environment variable <code>NODE_ENV</code> to <code>production</code>, to run the app in production mode.</p> </div> <p>If you call <code>next()</code> with an error after you have started writing the response (for example, if you encounter an error while streaming the response to the client) the Express default error handler closes the connection and fails the request.</p> <p>So when you add a custom error handler, you will want to delegate to the default error handling mechanisms in Express, when the headers have already been sent to the client:</p> <pre data-language=\"js\">function errorHandler(err, req, res, next) {\n  if (res.headersSent) {\n    return next(err);\n  }\n  res.status(500);\n  res.render('error', { error: err });\n}\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/guide/error-handling.html\" class=\"_attribution-link\">http://expressjs.com/en/guide/error-handling.html</a>\n  </p>\n</div>\n","guide/debugging":"<h1 id=\"debugging-express\">Debugging Express</h1> <p>Express uses the <a href=\"https://www.npmjs.com/package/debug\">debug</a> module internally to log information about route matches, middleware functions that are in use, application mode, and the flow of the request-response cycle.</p> <div class=\"doc-box doc-info\"> <p><code>debug</code> is like an augmented version of <code>console.log</code>, but unlike <code>console.log</code>, you don’t have to comment out <code>debug</code> logs in production code. Logging is turned off by default and can be conditionally turned on by using the <code>DEBUG</code> environment variable.</p> </div> <p>To see all the internal logs used in Express, set the <code>DEBUG</code> environment variable to <code>express:*</code> when launching your app.</p> <pre data-language=\"sh\">$ DEBUG=express:* node index.js\n</pre> <p>On Windows, use the corresponding command.</p> <pre data-language=\"sh\">&gt; set DEBUG=express:* &amp; node index.js\n</pre> <p>Running this command on the default app generated by the <a href=\"../starter/generator\">express generator</a> prints the following output:</p> <pre data-language=\"sh\">$ DEBUG=express:* node ./bin/www\n  express:router:route new / +0ms\n  express:router:layer new / +1ms\n  express:router:route get / +1ms\n  express:router:layer new / +0ms\n  express:router:route new / +1ms\n  express:router:layer new / +0ms\n  express:router:route get / +0ms\n  express:router:layer new / +0ms\n  express:application compile etag weak +1ms\n  express:application compile query parser extended +0ms\n  express:application compile trust proxy false +0ms\n  express:application booting in development mode +1ms\n  express:router use / query +0ms\n  express:router:layer new / +0ms\n  express:router use / expressInit +0ms\n  express:router:layer new / +0ms\n  express:router use / favicon +1ms\n  express:router:layer new / +0ms\n  express:router use / logger +0ms\n  express:router:layer new / +0ms\n  express:router use / jsonParser +0ms\n  express:router:layer new / +1ms\n  express:router use / urlencodedParser +0ms\n  express:router:layer new / +0ms\n  express:router use / cookieParser +0ms\n  express:router:layer new / +0ms\n  express:router use / stylus +90ms\n  express:router:layer new / +0ms\n  express:router use / serveStatic +0ms\n  express:router:layer new / +0ms\n  express:router use / router +0ms\n  express:router:layer new / +1ms\n  express:router use /users router +0ms\n  express:router:layer new /users +0ms\n  express:router use / &amp;lt;anonymous&amp;gt; +0ms\n  express:router:layer new / +0ms\n  express:router use / &amp;lt;anonymous&amp;gt; +0ms\n  express:router:layer new / +0ms\n  express:router use / &amp;lt;anonymous&amp;gt; +0ms\n  express:router:layer new / +0ms\n</pre> <p>When a request is then made to the app, you will see the logs specified in the Express code:</p> <pre data-language=\"sh\">  express:router dispatching GET / +4h\n  express:router query  : / +2ms\n  express:router expressInit  : / +0ms\n  express:router favicon  : / +0ms\n  express:router logger  : / +1ms\n  express:router jsonParser  : / +0ms\n  express:router urlencodedParser  : / +1ms\n  express:router cookieParser  : / +0ms\n  express:router stylus  : / +0ms\n  express:router serveStatic  : / +2ms\n  express:router router  : / +2ms\n  express:router dispatching GET / +1ms\n  express:view lookup \"index.pug\" +338ms\n  express:view stat \"/projects/example/views/index.pug\" +0ms\n  express:view render \"/projects/example/views/index.pug\" +1ms\n</pre> <p>To see the logs only from the router implementation set the value of <code>DEBUG</code> to <code>express:router</code>. Likewise, to see logs only from the application implementation set the value of <code>DEBUG</code> to <code>express:application</code>, and so on.</p> <h2 id=\"applications-generated-by-express\">Applications generated by <code>express</code>\n</h2> <p>An application generated by the <code>express</code> command also uses the <code>debug</code> module and its debug namespace is scoped to the name of the application.</p> <p>For example, if you generated the app with <code>$ express sample-app</code>, you can enable the debug statements with the following command:</p> <pre data-language=\"sh\">$ DEBUG=sample-app node ./bin/www\n</pre> <p>You can specify more than one debug namespace by assigning a comma-separated list of names:</p> <pre data-language=\"sh\">$ DEBUG=http,mail,express:* node index.js\n</pre> <p>For more information about <code>debug</code>, see the <a href=\"https://www.npmjs.com/package/debug\">debug</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/guide/debugging.html\" class=\"_attribution-link\">http://expressjs.com/en/guide/debugging.html</a>\n  </p>\n</div>\n","guide/behind-proxies":"<h1 id=\"express-behind-proxies\">Express behind proxies</h1> <p>When running an Express app behind a proxy, set (by using <a href=\"../4x/api#app.set\">app.set()</a>) the application variable <code>trust proxy</code> to one of the values listed in the following table.</p> <div class=\"doc-box doc-info\"> <p>Although the app will not fail to run if the application variable <code>trust proxy</code> is not set, it will incorrectly register the proxy’s IP address as the client IP address unless <code>trust proxy</code> is configured.</p> </div> <table class=\"doctable\"> <thead><tr>\n<th>Type</th>\n<th>Value</th>\n</tr></thead> <tbody> <tr> <td>Boolean</td> <td> <p>If <code>true</code>, the client’s IP address is understood as the left-most entry in the <code>X-Forwarded-*</code> header.</p> <p>If <code>false</code>, the app is understood as directly facing the Internet and the client’s IP address is derived from <code>req.connection.remoteAddress</code>. This is the default setting.</p> </td> </tr> <tr> <td>IP addresses</td> <td> <p>An IP address, subnet, or an array of IP addresses and subnets to trust. The following list shows the pre-configured subnet names:</p> <ul> <li>loopback - <code>127.0.0.1/8</code>, <code>::1/128</code>\n</li> <li>linklocal - <code>169.254.0.0/16</code>, <code>fe80::/10</code>\n</li> <li>uniquelocal - <code>10.0.0.0/8</code>, <code>172.16.0.0/12</code>, <code>192.168.0.0/16</code>, <code>fc00::/7</code>\n</li> </ul> <p>You can set IP addresses in any of the following ways:</p> <pre data-language=\"js\">app.set('trust proxy', 'loopback') // specify a single subnet\napp.set('trust proxy', 'loopback, 123.123.123.123') // specify a subnet and an address\napp.set('trust proxy', 'loopback, linklocal, uniquelocal') // specify multiple subnets as CSV\napp.set('trust proxy', ['loopback', 'linklocal', 'uniquelocal']) // specify multiple subnets as an array\n</pre> <p>When specified, the IP addresses or the subnets are excluded from the address determination process, and the untrusted IP address nearest to the application server is determined as the client’s IP address.</p> </td> </tr> <tr> <td>Number</td> <td> <p>Trust the <code>n</code>th hop from the front-facing proxy server as the client.</p> </td> </tr> <tr> <td>Function</td> <td> <p>Custom trust implementation. Use this only if you know what you are doing.</p> <pre data-language=\"js\">app.set('trust proxy', function (ip) {\n  if (ip === '127.0.0.1' || ip === '123.123.123.123') return true; // trusted IPs\n  else return false;\n});\n</pre> </td> </tr> </tbody> </table> <p>Setting a non-<code>false</code> <code>trust proxy</code> value results in three important changes:</p> <ul> <li> <p>The value of <a href=\"http://expressjs.com/en/api.html#req.hostname\">req.hostname</a> is derived from the value set in the <code>X-Forwarded-Host</code> header, which can be set by the client or by the proxy.</p> </li> <li> <p><code>X-Forwarded-Proto</code> can be set by the reverse proxy to tell the app whether it is <code>https</code> or <code>http</code> or even an invalid name. This value is reflected by <a href=\"http://expressjs.com/en/api.html#req.protocol\">req.protocol</a>.</p> </li> <li> <p>The <a href=\"http://expressjs.com/en/api.html#req.ip\">req.ip</a> and <a href=\"http://expressjs.com/en/api.html#req.ips\">req.ips</a> values are populated with the list of addresses from <code>X-Forwarded-For</code>.</p> </li> </ul> <p>The <code>trust proxy</code> setting is implemented using the <a href=\"https://www.npmjs.com/package/proxy-addr\">proxy-addr</a> package. For more information, see its documentation.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/guide/behind-proxies.html\" class=\"_attribution-link\">http://expressjs.com/en/guide/behind-proxies.html</a>\n  </p>\n</div>\n","advanced/security-updates":"<h1 id=\"security-updates\">Security updates</h1> <div class=\"doc-box doc-notice\"> <p>Node.js vulnerabilities directly affect Express. Therefore <a href=\"http://blog.nodejs.org/vulnerability/\">keep a watch on Node.js vulnerabilities</a> and make sure you are using the latest stable version of Node.js.</p> </div> <p>The list below enumerates the Express vulnerabilities that were fixed in the specified version update.</p> <p><strong>NOTE</strong>: If you believe you have discovered a security vulnerability in Express, please see <a href=\"https://github.com/strongloop/express/blob/master/Security.md\">Security Policies and Procedures</a>.</p> <h2 id=\"x\">4.x</h2> <ul> <li>4.11.1 <ul> <li>Fixed root path disclosure vulnerability in <code>express.static</code>, <code>res.sendfile</code>, and <code>res.sendFile</code>\n</li> </ul> </li> <li>4.10.7 <ul> <li>Fixed open redirect vulnerability in <code>express.static</code> (<a href=\"https://nodesecurity.io/advisories/serve-static-open-redirect\">advisory</a>, <a href=\"http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1164\">CVE-2015-1164</a>).</li> </ul> </li> <li>4.8.8 <ul> <li>Fixed directory traversal vulnerabilities in <code>express.static</code> (<a href=\"http://nodesecurity.io/advisories/send-directory-traversal\">advisory</a> , <a href=\"http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6394\">CVE-2014-6394</a>).</li> </ul> </li> <li>4.8.4 <ul> <li>Node.js 0.10 can leak <code>fd</code>s in certain situations that affect <code>express.static</code> and <code>res.sendfile</code>. Malicious requests could cause <code>fd</code>s to leak and eventually lead to <code>EMFILE</code> errors and server unresponsiveness.</li> </ul> </li> <li>4.8.0 <ul> <li>Sparse arrays that have extremely high indexes in the query string could cause the process to run out of memory and crash the server.</li> <li>Extremely nested query string objects could cause the process to block and make the server unresponsive temporarily.</li> </ul> </li> </ul> <h2 id=\"x-1\">3.x</h2> <div class=\"doc-box doc-warn\"> <p><strong>Express 3.x IS NO LONGER MAINTAINED</strong></p> <p>Known and unknown security issues in 3.x have not been addressed since the last update (1 August, 2015). Using the 3.x line should not be considered secure.</p> </div> <ul> <li>3.19.1 <ul> <li>Fixed root path disclosure vulnerability in <code>express.static</code>, <code>res.sendfile</code>, and <code>res.sendFile</code>\n</li> </ul> </li> <li>3.19.0 <ul> <li>Fixed open redirect vulnerability in <code>express.static</code> (<a href=\"https://nodesecurity.io/advisories/serve-static-open-redirect\">advisory</a>, <a href=\"http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1164\">CVE-2015-1164</a>).</li> </ul> </li> <li>3.16.10 <ul> <li>Fixed directory traversal vulnerabilities in <code>express.static</code>.</li> </ul> </li> <li>3.16.6 <ul> <li>Node.js 0.10 can leak <code>fd</code>s in certain situations that affect <code>express.static</code> and <code>res.sendfile</code>. Malicious requests could cause <code>fd</code>s to leak and eventually lead to <code>EMFILE</code> errors and server unresponsiveness.</li> </ul> </li> <li>3.16.0 <ul> <li>Sparse arrays that have extremely high indexes in query string could cause the process to run out of memory and crash the server.</li> <li>Extremely nested query string objects could cause the process to block and make the server unresponsive temporarily.</li> </ul> </li> <li>3.3.0 <ul> <li>The 404 response of an unsupported method override attempt was susceptible to cross-site scripting attacks.</li> </ul> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/advanced/security-updates.html\" class=\"_attribution-link\">http://expressjs.com/en/advanced/security-updates.html</a>\n  </p>\n</div>\n","guide/using-middleware":"<h1 id=\"using-middleware\">Using middleware</h1> <p>Express is a routing and middleware web framework that has minimal functionality of its own: An Express application is essentially a series of middleware function calls.</p> <p><em>Middleware</em> functions are functions that have access to the <a href=\"../4x/api#req\">request object</a> (<code>req</code>), the <a href=\"../4x/api#res\">response object</a> (<code>res</code>), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named <code>next</code>.</p> <p>Middleware functions can perform the following tasks:</p> <ul> <li>Execute any code.</li> <li>Make changes to the request and the response objects.</li> <li>End the request-response cycle.</li> <li>Call the next middleware function in the stack.</li> </ul> <p>If the current middleware function does not end the request-response cycle, it must call <code>next()</code> to pass control to the next middleware function. Otherwise, the request will be left hanging.</p> <p>An Express application can use the following types of middleware:</p> <ul> <li><a href=\"#middleware.application\">Application-level middleware</a></li> <li><a href=\"#middleware.router\">Router-level middleware</a></li> <li><a href=\"#middleware.error-handling\">Error-handling middleware</a></li> <li><a href=\"#middleware.built-in\">Built-in middleware</a></li> <li><a href=\"#middleware.third-party\">Third-party middleware</a></li> </ul> <p>You can load application-level and router-level middleware with an optional mount path. You can also load a series of middleware functions together, which creates a sub-stack of the middleware system at a mount point.</p> <h2 id=\"middleware.application\">Application-level middleware</h2> <p>Bind application-level middleware to an instance of the <a href=\"../4x/api#app\">app object</a> by using the <code>app.use()</code> and <code>app.METHOD()</code> functions, where <code>METHOD</code> is the HTTP method of the request that the middleware function handles (such as GET, PUT, or POST) in lowercase.</p> <p>This example shows a middleware function with no mount path. The function is executed every time the app receives a request.</p> <pre data-language=\"js\">var app = express();\n\napp.use(function (req, res, next) {\n  console.log('Time:', Date.now());\n  next();\n});\n</pre> <p>This example shows a middleware function mounted on the <code>/user/:id</code> path. The function is executed for any type of HTTP request on the <code>/user/:id</code> path.</p> <pre data-language=\"js\">app.use('/user/:id', function (req, res, next) {\n  console.log('Request Type:', req.method);\n  next();\n});\n</pre> <p>This example shows a route and its handler function (middleware system). The function handles GET requests to the <code>/user/:id</code> path.</p> <pre data-language=\"js\">app.get('/user/:id', function (req, res, next) {\n  res.send('USER');\n});\n</pre> <p>Here is an example of loading a series of middleware functions at a mount point, with a mount path. It illustrates a middleware sub-stack that prints request info for any type of HTTP request to the <code>/user/:id</code> path.</p> <pre data-language=\"js\">app.use('/user/:id', function(req, res, next) {\n  console.log('Request URL:', req.originalUrl);\n  next();\n}, function (req, res, next) {\n  console.log('Request Type:', req.method);\n  next();\n});\n</pre> <p>Route handlers enable you to define multiple routes for a path. The example below defines two routes for GET requests to the <code>/user/:id</code> path. The second route will not cause any problems, but it will never get called because the first route ends the request-response cycle.</p> <p>This example shows a middleware sub-stack that handles GET requests to the <code>/user/:id</code> path.</p> <pre data-language=\"js\">app.get('/user/:id', function (req, res, next) {\n  console.log('ID:', req.params.id);\n  next();\n}, function (req, res, next) {\n  res.send('User Info');\n});\n\n// handler for the /user/:id path, which prints the user ID\napp.get('/user/:id', function (req, res, next) {\n  res.end(req.params.id);\n});\n</pre> <p>To skip the rest of the middleware functions from a router middleware stack, call <code>next('route')</code> to pass control to the next route. <strong>NOTE</strong>: <code>next('route')</code> will work only in middleware functions that were loaded by using the <code>app.METHOD()</code> or <code>router.METHOD()</code> functions.</p> <p>This example shows a middleware sub-stack that handles GET requests to the <code>/user/:id</code> path.</p> <pre data-language=\"js\">app.get('/user/:id', function (req, res, next) {\n  // if the user ID is 0, skip to the next route\n  if (req.params.id == 0) next('route');\n  // otherwise pass the control to the next middleware function in this stack\n  else next(); //\n}, function (req, res, next) {\n  // render a regular page\n  res.render('regular');\n});\n\n// handler for the /user/:id path, which renders a special page\napp.get('/user/:id', function (req, res, next) {\n  res.render('special');\n});\n</pre> <h2 id=\"middleware.router\">Router-level middleware</h2> <p>Router-level middleware works in the same way as application-level middleware, except it is bound to an instance of <code>express.Router()</code>.</p> <pre data-language=\"js\">var router = express.Router();\n</pre> <p>Load router-level middleware by using the <code>router.use()</code> and <code>router.METHOD()</code> functions.</p> <p>The following example code replicates the middleware system that is shown above for application-level middleware, by using router-level middleware:</p> <pre data-language=\"js\">var app = express();\nvar router = express.Router();\n\n// a middleware function with no mount path. This code is executed for every request to the router\nrouter.use(function (req, res, next) {\n  console.log('Time:', Date.now());\n  next();\n});\n\n// a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path\nrouter.use('/user/:id', function(req, res, next) {\n  console.log('Request URL:', req.originalUrl);\n  next();\n}, function (req, res, next) {\n  console.log('Request Type:', req.method);\n  next();\n});\n\n// a middleware sub-stack that handles GET requests to the /user/:id path\nrouter.get('/user/:id', function (req, res, next) {\n  // if the user ID is 0, skip to the next router\n  if (req.params.id == 0) next('route');\n  // otherwise pass control to the next middleware function in this stack\n  else next(); //\n}, function (req, res, next) {\n  // render a regular page\n  res.render('regular');\n});\n\n// handler for the /user/:id path, which renders a special page\nrouter.get('/user/:id', function (req, res, next) {\n  console.log(req.params.id);\n  res.render('special');\n});\n\n// mount the router on the app\napp.use('/', router);\n</pre> <h2 id=\"middleware.error-handling\">Error-handling middleware</h2> <div class=\"doc-box doc-notice\"> <p>Error-handling middleware always takes <em>four</em> arguments. You must provide four arguments to identify it as an error-handling middleware function. Even if you don’t need to use the <code>next</code> object, you must specify it to maintain the signature. Otherwise, the <code>next</code> object will be interpreted as regular middleware and will fail to handle errors.</p> </div> <p>Define error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature <code>(err, req, res, next)</code>):</p> <pre data-language=\"js\">app.use(function(err, req, res, next) {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n</pre> <p>For details about error-handling middleware, see: <a href=\"error-handling\">Error handling</a>.</p> <h2 id=\"middleware.built-in\">Built-in middleware</h2> <p>Starting with version 4.x, Express no longer depends on <a href=\"https://github.com/senchalabs/connect\">Connect</a>. With the exception of <code>express.static</code>, all of the middleware functions that were previously included with Express’ are now in separate modules. Please view <a href=\"https://github.com/senchalabs/connect#middleware\">the list of middleware functions</a>.</p> <p>The only built-in middleware function in Express is <code>express.static</code>. This function is based on <a href=\"https://github.com/expressjs/serve-static\">serve-static</a>, and is responsible for serving static assets such as HTML files, images, and so on.</p> <p>The function signature is:</p> <pre data-language=\"js\">express.static(root, [options])\n</pre> <p>The <code>root</code> argument specifies the root directory from which to serve static assets.</p> <p>For information on the <code>options</code> argument and more details on this middleware function, see <a href=\"../4x/api#express.static\">express.static</a>.</p> <p>Here is an example of using the <code>express.static</code> middleware function with an elaborate options object:</p> <pre data-language=\"js\">var options = {\n  dotfiles: 'ignore',\n  etag: false,\n  extensions: ['htm', 'html'],\n  index: false,\n  maxAge: '1d',\n  redirect: false,\n  setHeaders: function (res, path, stat) {\n    res.set('x-timestamp', Date.now());\n  }\n}\n\napp.use(express.static('public', options));\n</pre> <p>You can have more than one static directory per app:</p> <pre data-language=\"js\">app.use(express.static('public'));\napp.use(express.static('uploads'));\napp.use(express.static('files'));\n</pre> <p>For more details about the <code>serve-static</code> function and its options, see: <a href=\"https://github.com/expressjs/serve-static\">serve-static</a> documentation.</p> <h2 id=\"middleware.third-party\">Third-party middleware</h2> <p>Use third-party middleware to add functionality to Express apps.</p> <p>Install the Node.js module for the required functionality, then load it in your app at the application level or at the router level.</p> <p>The following example illustrates installing and loading the cookie-parsing middleware function <code>cookie-parser</code>.</p> <pre data-language=\"sh\">$ npm install cookie-parser\n</pre> <pre data-language=\"js\">var express = require('express');\nvar app = express();\nvar cookieParser = require('cookie-parser');\n\n// load the cookie-parsing middleware\napp.use(cookieParser());\n</pre> <p>For a partial list of third-party middleware functions that are commonly used with Express, see: <a href=\"http://expressjs.com/en/resources/middleware.html\">Third-party middleware</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/guide/using-middleware.html\" class=\"_attribution-link\">http://expressjs.com/en/guide/using-middleware.html</a>\n  </p>\n</div>\n","guide/migrating-4":"<h1 id=\"moving-to-express-4\">Moving to Express 4</h1> <h2 id=\"overview\">Overview</h2> <p>Express 4 is a breaking change from Express 3, so. That means an existing Express 3 app will not work if you update the Express version in its dependencies.</p> <p>This article covers:</p> <ul class=\"doclist\"> <li><a href=\"#changes\">Changes in Express 4.</a></li> <li>\n<a href=\"#example-migration\">An example</a> of migrating an Express 3 app to Express 4.</li> <li><a href=\"#app-gen\">Upgrading to the Express 4 app generator.</a></li> </ul> <h2 id=\"changes\">Changes in Express 4</h2> <p>There are several significant changes in Express 4:</p> <ul class=\"doclist\"> <li>\n<a href=\"#core-changes\">Changes to Express core and middleware system.</a> The dependencies on Connect and built-in middleware were removed, so you must add middleware yourself. </li> <li><a href=\"#routing\">Changes to the routing system.</a></li> <li><a href=\"#other-changes\">Various other changes.</a></li> </ul> <p>See also:</p> <ul> <li><a href=\"https://github.com/strongloop/express/wiki/New-features-in-4.x\">New features in 4.x.</a></li> <li><a href=\"https://github.com/strongloop/express/wiki/Migrating-from-3.x-to-4.x\">Migrating from 3.x to 4.x.</a></li> </ul> <h3 id=\"core-changes\"> Changes to Express core and middleware system </h3> <p>Express 4 no longer depends on Connect, and removes all built-in middleware from its core, except for the <code>express.static</code> function. This means that Express is now an independent routing and middleware web framework, and Express versioning and releases are not affected by middleware updates.</p> <p>Without built-in middleware, you must explicitly add all the middleware that is required to run your app. Simply follow these steps:</p> <ol> <li>Install the module: <code>npm install --save &lt;module-name&gt;</code>\n</li> <li>In your app, require the module: <code>require('module-name')</code>\n</li> <li>Use the module according to its documentation: <code>app.use( ... )</code>\n</li> </ol> <p>The following table lists Express 3 middleware and their counterparts in Express 4.</p> <table class=\"doctable\"> <tr>\n<th>Express 3</th>\n<th>Express 4</th>\n</tr> <tr>\n<td><code>express.bodyParser</code></td> <td>\n<a href=\"https://github.com/expressjs/body-parser\">body-parser</a> + <a href=\"https://github.com/expressjs/multer\">multer</a>\n</td>\n</tr> <tr>\n<td><code>express.compress</code></td> <td><a href=\"https://github.com/expressjs/compression\">compression</a></td>\n</tr> <tr>\n<td><code>express.cookieSession</code></td> <td><a href=\"https://github.com/expressjs/cookie-session\">cookie-session</a></td>\n</tr> <tr>\n<td><code>express.cookieParser</code></td> <td><a href=\"https://github.com/expressjs/cookie-parser\">cookie-parser</a></td>\n</tr> <tr>\n<td><code>express.logger</code></td> <td><a href=\"https://github.com/expressjs/morgan\">morgan</a></td>\n</tr> <tr>\n<td><code>express.session</code></td> <td><a href=\"https://github.com/expressjs/session\">express-session</a></td>\n</tr> <tr>\n<td><code>express.favicon</code></td> <td><a href=\"https://github.com/expressjs/serve-favicon\">serve-favicon</a></td>\n</tr> <tr>\n<td><code>express.responseTime</code></td> <td><a href=\"https://github.com/expressjs/response-time\">response-time</a></td>\n</tr> <tr>\n<td><code>express.errorHandler</code></td> <td><a href=\"https://github.com/expressjs/errorhandler\">errorhandler</a></td>\n</tr> <tr>\n<td><code>express.methodOverride</code></td> <td><a href=\"https://github.com/expressjs/method-override\">method-override</a></td>\n</tr> <tr>\n<td><code>express.timeout</code></td> <td><a href=\"https://github.com/expressjs/timeout\">connect-timeout</a></td>\n</tr> <tr>\n<td><code>express.vhost</code></td> <td><a href=\"https://github.com/expressjs/vhost\">vhost</a></td>\n</tr> <tr>\n<td><code>express.csrf</code></td> <td><a href=\"https://github.com/expressjs/csurf\">csurf</a></td>\n</tr> <tr>\n<td><code>express.directory</code></td> <td><a href=\"https://github.com/expressjs/serve-index\">serve-index</a></td>\n</tr> <tr>\n<td><code>express.static</code></td> <td><a href=\"https://github.com/expressjs/serve-static\">serve-static</a></td>\n</tr> </table> <p>Here is the <a href=\"https://github.com/senchalabs/connect#middleware\">complete list</a> of Express 4 middleware.</p> <p>In most cases, you can simply replace the old version 3 middleware with its Express 4 counterpart. For details, see the module documentation in GitHub.</p> <h4 id=\"app-use\">\n<code>app.use</code> accepts parameters</h4> <p>In version 4 you can use a variable parameter to define the path where middleware functions are loaded, then read the value of the parameter from the route handler. For example:</p> <pre data-language=\"js\">app.use('/book/:id', function(req, res, next) {\n  console.log('ID:', req.params.id);\n  next();\n});\n</pre> <h3 id=\"routing\"> The routing system </h3> <p>Apps now implicitly load routing middleware, so you no longer have to worry about the order in which middleware is loaded with respect to the <code>router</code> middleware.</p> <p>The way you define routes is unchanged, but the routing system has two new features to help organize your routes:</p> <ul class=\"doclist\"> <li>A new method, <code>app.route()</code>, to create chainable route handlers for a route path.</li> <li>A new class, <code>express.Router</code>, to create modular mountable route handlers.</li> </ul> <h4 id=\"app-route\">\n<code>app.route()</code> method</h4> <p>The new <code>app.route()</code> method enables you to create chainable route handlers for a route path. Because the path is specified in a single location, creating modular routes is helpful, as is reducing redundancy and typos. For more information about routes, see <a href=\"../4x/api#router\"><code>Router()</code> documentation</a>.</p> <p>Here is an example of chained route handlers that are defined by using the <code>app.route()</code> function.</p> <pre data-language=\"js\">app.route('/book')\n  .get(function(req, res) {\n    res.send('Get a random book');\n  })\n  .post(function(req, res) {\n    res.send('Add a book');\n  })\n  .put(function(req, res) {\n    res.send('Update the book');\n  });\n</pre> <h4 id=\"express-router\">\n<code>express.Router</code> class</h4> <p>The other feature that helps to organize routes is a new class, <code>express.Router</code>, that you can use to create modular mountable route handlers. A <code>Router</code> instance is a complete middleware and routing system; for this reason it is often referred to as a “mini-app”.</p> <p>The following example creates a router as a module, loads middleware in it, defines some routes, and mounts it on a path on the main app.</p> <p>For example, create a router file named <code>birds.js</code> in the app directory, with the following content:</p> <pre data-language=\"js\">var express = require('express');\nvar router = express.Router();\n\n// middleware specific to this router\nrouter.use(function timeLog(req, res, next) {\n  console.log('Time: ', Date.now());\n  next();\n});\n// define the home page route\nrouter.get('/', function(req, res) {\n  res.send('Birds home page');\n});\n// define the about route\nrouter.get('/about', function(req, res) {\n  res.send('About birds');\n});\n\nmodule.exports = router;\n</pre> <p>Then, load the router module in the app:</p> <pre data-language=\"js\">var birds = require('./birds');\n...\napp.use('/birds', birds);\n</pre> <p>The app will now be able to handle requests to the <code>/birds</code> and <code>/birds/about</code> paths, and will call the <code>timeLog</code> middleware that is specific to the route.</p> <h3 id=\"other-changes\"> Other changes </h3> <p>The following table lists other small but important changes in Express 4:</p> <table class=\"doctable\"> <tr> <th>Object</th> <th>Description</th> </tr> <tr> <td>Node.js</td> <td>Express 4 requires Node.js 0.10.x or later and has dropped support for Node.js 0.8.x.</td> </tr> <tr> <td> <p><code>http.createServer()</code></p> </td> <td> <p>The <code>http</code> module is no longer needed, unless you need to directly work with it (socket.io/SPDY/HTTPS). The app can be started by using the <code>app.listen()</code> function.</p> </td> </tr> <tr> <td> <p><code>app.configure()</code></p> </td> <td> <p>The <code>app.configure()</code> function has been removed. Use the <code>process.env.NODE_ENV</code> or <code>app.get('env')</code> function to detect the environment and configure the app accordingly.</p> </td> </tr> <tr> <td> <p><code>json spaces</code></p> </td> <td> <p>The <code>json spaces</code> application property is disabled by default in Express 4.</p> </td> </tr> <tr> <td> <p><code>req.accepted()</code></p> </td> <td> <p>Use <code>req.accepts()</code>, <code>req.acceptsEncodings()</code>, <code>req.acceptsCharsets()</code>, and <code>req.acceptsLanguages()</code>.</p> </td> </tr> <tr> <td> <p><code>res.location()</code></p> </td> <td> <p>No longer resolves relative URLs.</p> </td> </tr> <tr> <td> <p><code>req.params</code></p> </td> <td> <p>Was an array; now an object.</p> </td> </tr> <tr> <td> <p><code>res.locals</code></p> </td> <td> <p>Was a function; now an object.</p> </td> </tr> <tr> <td> <p><code>res.headerSent</code></p> </td> <td> <p>Changed to <code>res.headersSent</code>.</p> </td> </tr> <tr> <td> <p><code>app.route</code></p> </td> <td> <p>Now available as <code>app.mountpath</code>.</p> </td> </tr> <tr> <td> <p><code>res.on('header')</code></p> </td> <td> <p>Removed.</p> </td> </tr> <tr> <td> <p><code>res.charset</code></p> </td> <td> <p>Removed.</p> </td> </tr> <tr> <td> <p><code>res.setHeader('Set-Cookie', val)</code></p> </td> <td> <p>Functionality is now limited to setting the basic cookie value. Use <code>res.cookie()</code> for added functionality.</p> </td> </tr> </table> <h2 id=\"example-migration\">Example app migration</h2> <p>Here is an example of migrating an Express 3 application to Express 4. The files of interest are <code>app.js</code> and <code>package.json</code>.</p> <h3> Version 3 app </h3> <h4><code>app.js</code></h4> <p>Consider an Express v.3 application with the following <code>app.js</code> file:</p> <pre data-language=\"js\">var express = require('express');\nvar routes = require('./routes');\nvar user = require('./routes/user');\nvar http = require('http');\nvar path = require('path');\n\nvar app = express();\n\n// all environments\napp.set('port', process.env.PORT || 3000);\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'pug');\napp.use(express.favicon());\napp.use(express.logger('dev'));\napp.use(express.methodOverride());\napp.use(express.session({ secret: 'your secret here' }));\napp.use(express.bodyParser());\napp.use(app.router);\napp.use(express.static(path.join(__dirname, 'public')));\n\n// development only\nif ('development' == app.get('env')) {\n  app.use(express.errorHandler());\n}\n\napp.get('/', routes.index);\napp.get('/users', user.list);\n\nhttp.createServer(app).listen(app.get('port'), function(){\n  console.log('Express server listening on port ' + app.get('port'));\n});\n</pre> <h4><code>package.json</code></h4> <p>The accompanying version 3 <code>package.json</code> file might look something like this:</p> <pre data-language=\"js\">{\n  \"name\": \"application-name\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node app.js\"\n  },\n  \"dependencies\": {\n    \"express\": \"3.12.0\",\n    \"pug\": \"*\"\n  }\n}\n</pre> <h3> Process </h3> <p>Begin the migration process by installing the required middleware for the Express 4 app and updating Express and Pug to their respective latest version with the following command:</p> <pre data-language=\"sh\">$ npm install serve-favicon morgan method-override express-session body-parser multer errorhandler express@latest pug@latest --save\n</pre> <p>Make the following changes to <code>app.js</code>:</p> <ol> <li> <p>The built-in Express middleware functions <code>express.favicon</code>, <code>express.logger</code>, <code>express.methodOverride</code>, <code>express.session</code>, <code>express.bodyParser</code> and <code>express.errorHandler</code> are no longer available on the <code>express</code> object. You must install their alternatives manually and load them in the app.</p> </li> <li> <p>You no longer need to load the <code>app.router</code> function. It is not a valid Express 4 app object, so remove the <code>app.use(app.router);</code> code.</p> </li> <li> <p>Make sure that the middleware functions are loaded in the correct order - load <code>errorHandler</code> after loading the app routes.</p> </li> </ol> <h3>Version 4 app</h3> <h4><code>package.json</code></h4> <p>Running the above <code>npm</code> command will update <code>package.json</code> as follows:</p> <pre data-language=\"js\">{\n  \"name\": \"application-name\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node app.js\"\n  },\n  \"dependencies\": {\n    \"body-parser\": \"^1.5.2\",\n    \"errorhandler\": \"^1.1.1\",\n    \"express\": \"^4.8.0\",\n    \"express-session\": \"^1.7.2\",\n    \"jade\": \"^0.1.0\",\n    \"method-override\": \"^2.1.2\",\n    \"morgan\": \"^1.2.2\",\n    \"multer\": \"^0.1.3\",\n    \"serve-favicon\": \"^2.0.1\"\n  }\n}\n</pre> <h4><code>app.js</code></h4> <p>Then, remove invalid code, load the required middleware, and make other changes as necessary. The <code>app.js</code> file will look like this:</p> <pre data-language=\"js\">var http = require('http');\nvar express = require('express');\nvar routes = require('./routes');\nvar user = require('./routes/user');\nvar path = require('path');\n\nvar favicon = require('serve-favicon');\nvar logger = require('morgan');\nvar methodOverride = require('method-override');\nvar session = require('express-session');\nvar bodyParser = require('body-parser');\nvar multer = require('multer');\nvar errorHandler = require('errorhandler');\n\nvar app = express();\n\n// all environments\napp.set('port', process.env.PORT || 3000);\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'pug');\napp.use(favicon(__dirname + '/public/favicon.ico'));\napp.use(logger('dev'));\napp.use(methodOverride());\napp.use(session({ resave: true,\n                  saveUninitialized: true,\n                  secret: 'uwotm8' }));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(multer());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', routes.index);\napp.get('/users', user.list);\n\n// error handling middleware should be loaded after the loading the routes\nif ('development' == app.get('env')) {\n  app.use(errorHandler());\n}\n\nvar server = http.createServer(app);\nserver.listen(app.get('port'), function(){\n  console.log('Express server listening on port ' + app.get('port'));\n});\n</pre> <div class=\"doc-box doc-info\"> <p>Unless you need to work directly with the <code>http</code> module (socket.io/SPDY/HTTPS), loading it is not required, and the app can be simply started this way:</p> <pre data-language=\"js\">app.listen(app.get('port'), function(){\n  console.log('Express server listening on port ' + app.get('port'));\n});\n</pre> </div> <h3>Run the app</h3> <p>The migration process is complete, and the app is now an Express 4 app. To confirm, start the app by using the following command:</p> <pre data-language=\"sh\">$ node .\n</pre> <p>Load <a href=\"http://localhost:3000\">http://localhost:3000</a> and see the home page being rendered by Express 4.</p> <h2 id=\"app-gen\">Upgrading to the Express 4 app generator</h2> <p>The command-line tool to generate an Express app is still <code>express</code>, but to upgrade to the new version, you must uninstall the Express 3 app generator and then install the new <code>express-generator</code>.</p> <h3>Installing </h3> <p>If you already have the Express 3 app generator installed on your system, you must uninstall it:</p> <pre data-language=\"sh\">$ npm uninstall -g express\n</pre> <p>Depending on how your file and directory privileges are configured, you might need to run this command with <code>sudo</code>.</p> <p>Now install the new generator:</p> <pre data-language=\"sh\">$ npm install -g express-generator\n</pre> <p>Depending on how your file and directory privileges are configured, you might need to run this command with <code>sudo</code>.</p> <p>Now the <code>express</code> command on your system is updated to the Express 4 generator.</p> <h3>Changes to the app generator </h3> <p>Command options and use largely remain the same, with the following exceptions:</p> <ul class=\"doclist\"> <li>Removed the <code>--sessions</code> option.</li> <li>Removed the <code>--jshtml</code> option.</li> <li>Added the <code>--hogan</code> option to support <a href=\"http://twitter.github.io/hogan.js/\">Hogan.js</a>.</li> </ul> <h3>Example</h3> <p>Execute the following command to create an Express 4 app:</p> <pre data-language=\"sh\">$ express app4\n</pre> <p>If you look at the contents of the <code>app4/app.js</code> file, you will notice that all the middleware functions (except <code>express.static</code>) that are required for the app are loaded as independent modules, and the <code>router</code> middleware is no longer explicitly loaded in the app.</p> <p>You will also notice that the <code>app.js</code> file is now a Node.js module, in contrast to the standalone app that was generated by the old generator.</p> <p>After installing the dependencies, start the app by using the following command:</p> <pre data-language=\"sh\">$ npm start\n</pre> <p>If you look at the npm start script in the <code>package.json</code> file, you will notice that the actual command that starts the app is <code>node ./bin/www</code>, which used to be <code>node app.js</code> in Express 3.</p> <p>Because the <code>app.js</code> file that was generated by the Express 4 generator is now a Node.js module, it can no longer be started independently as an app (unless you modify the code). The module must be loaded in a Node.js file and started via the Node.js file. The Node.js file is <code>./bin/www</code> in this case.</p> <p>Neither the <code>bin</code> directory nor the extensionless <code>www</code> file is mandatory for creating an Express app or starting the app. They are just suggestions made by the generator, so feel free to modify them to suit your needs.</p> <p>To get rid of the <code>www</code> directory and keep things the “Express 3 way”, delete the line that says <code>module.exports = app;</code> at the end of the <code>app.js</code> file, then paste the following code in its place:</p> <pre data-language=\"js\">app.set('port', process.env.PORT || 3000);\n\nvar server = app.listen(app.get('port'), function() {\n  debug('Express server listening on port ' + server.address().port);\n});\n</pre> <p>Ensure that you load the <code>debug</code> module at the top of the <code>app.js</code> file by using the following code:</p> <pre data-language=\"js\">var debug = require('debug')('app4');\n</pre> <p>Next, change <code>\"start\": \"node ./bin/www\"</code> in the <code>package.json</code> file to <code>\"start\": \"node app.js\"</code>.</p> <p>You have now moved the functionality of <code>./bin/www</code> back to <code>app.js</code>. This change is not recommended, but the exercise helps you to understand how the <code>./bin/www</code> file works, and why the <code>app.js</code> file no longer starts on its own.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/guide/migrating-4.html\" class=\"_attribution-link\">http://expressjs.com/en/guide/migrating-4.html</a>\n  </p>\n</div>\n","guide/migrating-5":"<h1 id=\"moving-to-express-5\">Moving to Express 5</h1> <h2 id=\"overview\">Overview</h2> <p>Express 5.0 is still in the alpha release stage, but here is a preview of the changes that will be in the release and how to migrate your Express 4 app to Express 5.</p> <p>Express 5 is not very different from Express 4: The changes to the API are not as significant as from 3.0 to 4.0. Although the basic API remains the same, there are still breaking changes; in other words an existing Express 4 program might not work if you update it to use Express 5.</p> <p>To install the latest alpha and to preview Express 5, enter the following command in your application root directory:</p> <pre data-language=\"sh\">$ npm install express@5.0.0-alpha.2 --save\n</pre> <p>You can then run your automated tests to see what fails, and fix problems according to the updates listed below. After addressing test failures, run your app to see what errors occur. You’ll find out right away if the app uses any methods or properties that are not supported.</p> <h2 id=\"changes\">Changes in Express 5</h2> <p>Here is the list of changes (as of the alpha 2 release ) that will affect you as a user of Express. See the <a href=\"https://github.com/strongloop/express/pull/2237\">pull request</a> for a list of all the planned features.</p> <p><strong>Removed methods and properties</strong></p> <ul class=\"doclist\"> <li><a href=\"#app.del\">app.del()</a></li> <li><a href=\"#app.param\">app.param(fn)</a></li> <li><a href=\"#plural\">Pluralized method names</a></li> <li><a href=\"#leading\">Leading colon in name argument to app.param(name, fn)</a></li> <li><a href=\"#req.param\">req.param(name)</a></li> <li><a href=\"#res.json\">res.json(obj, status)</a></li> <li><a href=\"#res.jsonp\">res.jsonp(obj, status)</a></li> <li><a href=\"#res.send.body\">res.send(body, status)</a></li> <li><a href=\"#res.send.status\">res.send(status)</a></li> <li><a href=\"#res.sendfile\">res.sendfile()</a></li> </ul> <p><strong>Changed</strong></p> <ul class=\"doclist\"> <li><a href=\"#app.router\">app.router</a></li> <li><a href=\"#req.host\">req.host</a></li> <li><a href=\"#req.query\">req.query</a></li> </ul> <p><strong>Improvements</strong></p> <ul class=\"doclist\"> <li><a href=\"#res.render\">res.render()</a></li> </ul> <h3>Removed methods and properties</h3> <p>If you use any of these methods or properties in your app, it will crash. So, you’ll need to change your app after you update to version 5.</p> <h4 id=\"app.del\">app.del()</h4> <p>Express 5 no longer supports the <code>app.del()</code> function. If you use this function an error is thrown. For registering HTTP DELETE routes, use the <code>app.delete()</code> function instead.</p> <p>Initially <code>del</code> was used instead of <code>delete</code>, because <code>delete</code> is a reserved keyword in JavaScript. However, as of ECMAScript 6, <code>delete</code> and other reserved keywords can legally be used as property names.</p> <h4 id=\"app.param\">app.param(fn)</h4> <p>The <code>app.param(fn)</code> signature was used for modifying the behavior of the <code>app.param(name, fn)</code> function. It has been deprecated since v4.11.0, and Express 5 no longer supports it at all.</p> <h4 id=\"plural\">Pluralized method names</h4> <p>The following method names have been pluralized. In Express 4, using the old methods resulted in a deprecation warning. Express 5 no longer supports them at all:</p> <p><code>req.acceptsCharset()</code> is replaced by <code>req.acceptsCharsets()</code>.</p> <p><code>req.acceptsEncoding()</code> is replaced by <code>req.acceptsEncodings()</code>.</p> <p><code>req.acceptsLanguage()</code> is replaced by <code>req.acceptsLanguages()</code>.</p> <h4 id=\"leading\">Leading colon (:) in the name for app.param(name, fn)</h4> <p>A leading colon character (:) in the name for the <code>app.param(name, fn)</code> function is a remnant of Express 3, and for the sake of backwards compatibility, Express 4 supported it with a deprecation notice. Express 5 will silently ignore it and use the name parameter without prefixing it with a colon.</p> <p>This should not affect your code if you follow the Express 4 documentation of <a href=\"../4x/api#app.param\">app.param</a>, as it makes no mention of the leading colon.</p> <h4 id=\"req.param\">req.param(name)</h4> <p>This potentially confusing and dangerous method of retrieving form data has been removed. You will now need to specifically look for the submitted parameter name in the <code>req.params</code>, <code>req.body</code>, or <code>req.query</code> object.</p> <h4 id=\"res.json\">res.json(obj, status)</h4> <p>Express 5 no longer supports the signature <code>res.json(obj, status)</code>. Instead, set the status and then chain it to the <code>res.json()</code> method like this: <code>res.status(status).json(obj)</code>.</p> <h4 id=\"res.jsonp\">res.jsonp(obj, status)</h4> <p>Express 5 no longer supports the signature <code>res.jsonp(obj, status)</code>. Instead, set the status and then chain it to the <code>res.jsonp()</code> method like this: <code>res.status(status).jsonp(obj)</code>.</p> <h4 id=\"res.send.body\">res.send(body, status)</h4> <p>Express 5 no longer supports the signature <code>res.send(obj, status)</code>. Instead, set the status and then chain it to the <code>res.send()</code> method like this: <code>res.status(status).send(obj)</code>.</p> <h4 id=\"res.send.status\">res.send(status)</h4> <p>Express 5 no longer supports the signature <code>res.send(<em>status</em>)</code>, where <em><code>status</code></em> is a number. Instead, use the <code>res.sendStatus(statusCode)</code> function, which sets the HTTP response header status code and sends the text version of the code: “Not Found”, “Internal Server Error”, and so on. If you need to send a number by using the <code>res.send()</code> function, quote the number to convert it to a string, so that Express does not interpret it as an attempt to use the unsupported old signature.</p> <h4 id=\"res.sendfile\">res.sendfile()</h4> <p>The <code>res.sendfile()</code> function has been replaced by a camel-cased version <code>res.sendFile()</code> in Express 5.</p> <h3>Changed</h3> <h4 id=\"app.router\">app.router</h4> <p>The <code>app.router</code> object, which was removed in Express 4, has made a comeback in Express 5. In the new version, this object is a just a reference to the base Express router, unlike in Express 3, where an app had to explicitly load it.</p> <h4 id=\"req.host\">req.host</h4> <p>In Express 4, the <code>req.host</code> function incorrectly stripped off the port number if it was present. In Express 5 the port number is maintained.</p> <h4 id=\"req.query\">req.query</h4> <p>In Express 4.7 and Express 5 onwards, the query parser option can accept <code>false</code> to disable query string parsing when you want to use your own function for query string parsing logic.</p> <h3>Improvements</h3> <h4 id=\"res.render\">res.render()</h4> <p>This method now enforces asynchronous behavior for all view engines, avoiding bugs caused by view engines that had a synchronous implementation and that violated the recommended interface.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/guide/migrating-5.html\" class=\"_attribution-link\">http://expressjs.com/en/guide/migrating-5.html</a>\n  </p>\n</div>\n","guide/database-integration":"<h1 id=\"database-integration\">Database integration</h1> <p>Adding the capability to connect databases to Express apps is just a matter of loading an appropriate Node.js driver for the database in your app. This document briefly explains how to add and use some of the most popular Node.js modules for database systems in your Express app:</p> <ul> <li><a href=\"#cassandra\">Cassandra</a></li> <li><a href=\"#couchdb\">CouchDB</a></li> <li><a href=\"#leveldb\">LevelDB</a></li> <li><a href=\"#mysql\">MySQL</a></li> <li><a href=\"#mongo\">MongoDB</a></li> <li><a href=\"#neo4j\">Neo4j</a></li> <li><a href=\"#postgres\">PostgreSQL</a></li> <li><a href=\"#redis\">Redis</a></li> <li><a href=\"#sqlite\">SQLite</a></li> <li><a href=\"#elasticsearch\">ElasticSearch</a></li> </ul> <div class=\"doc-box doc-notice\"> <p>These database drivers are among many that are available. For other options, search on the <a href=\"https://www.npmjs.com/\">npm</a> site.</p> </div>  <h2 id=\"cassandra\">Cassandra</h2> <p><strong>Module</strong>: <a href=\"https://github.com/datastax/nodejs-driver\">cassandra-driver</a> <strong>Installation</strong></p> <pre data-language=\"sh\">$ npm install cassandra-driver\n</pre> <p><strong>Example</strong></p> <pre data-language=\"js\">var cassandra = require('cassandra-driver');\nvar client = new cassandra.Client({ contactPoints: ['localhost']});\n\nclient.execute('select key from system.local', function(err, result) {\n  if (err) throw err;\n  console.log(result.rows[0]);\n});\n</pre>  <h2 id=\"couchdb\">CouchDB</h2> <p><strong>Module</strong>: <a href=\"https://github.com/dscape/nano\">nano</a> <strong>Installation</strong></p> <pre data-language=\"sh\">$ npm install nano\n</pre> <p><strong>Example</strong></p> <pre data-language=\"js\">var nano = require('nano')('http://localhost:5984');\nnano.db.create('books');\nvar books = nano.db.use('books');\n\n//Insert a book document in the books database\nbooks.insert({name: 'The Art of war'}, null, function(err, body) {\n  if (!err){\n    console.log(body);\n  }\n});\n\n//Get a list of all books\nbooks.list(function(err, body){\n  console.log(body.rows);\n});\n</pre>  <h2 id=\"leveldb\">LevelDB</h2> <p><strong>Module</strong>: <a href=\"https://github.com/rvagg/node-levelup\">levelup</a> <strong>Installation</strong></p> <pre data-language=\"sh\">$ npm install level levelup leveldown\n</pre> <p><strong>Example</strong></p> <pre data-language=\"js\">var levelup = require('levelup');\nvar db = levelup('./mydb');\n\ndb.put('name', 'LevelUP', function (err) {\n\n  if (err) return console.log('Ooops!', err);\n  db.get('name', function (err, value) {\n    if (err) return console.log('Ooops!', err);\n    console.log('name=' + value);\n  });\n\n});\n</pre>  <h2 id=\"mysql\">MySQL</h2> <p><strong>Module</strong>: <a href=\"https://github.com/felixge/node-mysql/\">mysql</a> <strong>Installation</strong></p> <pre data-language=\"sh\">$ npm install mysql\n</pre> <p><strong>Example</strong></p> <pre data-language=\"js\">var mysql      = require('mysql');\nvar connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'dbuser',\n  password : 's3kreee7'\n});\n\nconnection.connect();\n\nconnection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {\n  if (err) throw err;\n  console.log('The solution is: ', rows[0].solution);\n});\n\nconnection.end();\n</pre>  <h2 id=\"mongodb\">MongoDB</h2> <p><strong>Module</strong>: <a href=\"https://github.com/mongodb/node-mongodb-native\">mongodb</a> <strong>Installation</strong></p> <pre data-language=\"sh\">$ npm install mongodb\n</pre> <p><strong>Example</strong></p> <pre data-language=\"js\">var MongoClient = require('mongodb').MongoClient;\n\nMongoClient.connect('mongodb://localhost:27017/animals', function(err, db) {\n  if (err) {\n    throw err;\n  }\n  db.collection('mammals').find().toArray(function(err, result) {\n    if (err) {\n      throw err;\n    }\n    console.log(result);\n  });\n});\n</pre> <p>If you want an object model driver for MongoDB, look at <a href=\"https://github.com/LearnBoost/mongoose\">Mongoose</a>.</p>  <h2 id=\"neo4j\">Neo4j</h2> <p><strong>Module</strong>: <a href=\"https://github.com/hacksparrow/apoc\">apoc</a> <strong>Installation</strong></p> <pre data-language=\"sh\">$ npm install apoc\n</pre> <p><strong>Example</strong></p> <pre data-language=\"js\">var apoc = require('apoc');\n\napoc.query('match (n) return n').exec().then(\n  function (response) {\n    console.log(response);\n  },\n  function (fail) {\n    console.log(fail);\n  }\n);\n</pre>  <h2 id=\"postgresql\">PostgreSQL</h2> <p><strong>Module</strong>: <a href=\"https://github.com/vitaly-t/pg-promise\">pg-promise</a> <strong>Installation</strong></p> <pre data-language=\"sh\">$ npm install pg-promise\n</pre> <p><strong>Example</strong></p> <pre data-language=\"js\">var pgp = require(\"pg-promise\")(/*options*/);\nvar db = pgp(\"postgres://username:password@host:port/database\");\n\ndb.one(\"SELECT $1 AS value\", 123)\n    .then(function (data) {\n        console.log(\"DATA:\", data.value);\n    })\n    .catch(function (error) {\n        console.log(\"ERROR:\", error);\n    });\n</pre>  <h2 id=\"redis\">Redis</h2> <p><strong>Module</strong>: <a href=\"https://github.com/mranney/node_redis\">redis</a> <strong>Installation</strong></p> <pre data-language=\"sh\">$ npm install redis\n</pre> <p><strong>Example</strong></p> <pre data-language=\"js\">var client = require('redis').createClient();\n\nclient.on('error', function (err) {\n  console.log('Error ' + err);\n});\n\nclient.set('string key', 'string val', redis.print);\nclient.hset('hash key', 'hashtest 1', 'some value', redis.print);\nclient.hset(['hash key', 'hashtest 2', 'some other value'], redis.print);\n\nclient.hkeys('hash key', function (err, replies) {\n\n  console.log(replies.length + ' replies:');\n  replies.forEach(function (reply, i) {\n    console.log('    ' + i + ': ' + reply);\n  });\n\n  client.quit();\n\n});\n</pre>  <h2 id=\"sqlite\">SQLite</h2> <p><strong>Module</strong>: <a href=\"https://github.com/mapbox/node-sqlite3\">sqlite3</a> <strong>Installation</strong></p> <pre data-language=\"sh\">$ npm install sqlite3\n</pre> <p><strong>Example</strong></p> <pre data-language=\"js\">var sqlite3 = require('sqlite3').verbose();\nvar db = new sqlite3.Database(':memory:');\n\ndb.serialize(function() {\n\n  db.run('CREATE TABLE lorem (info TEXT)');\n  var stmt = db.prepare('INSERT INTO lorem VALUES (?)');\n\n  for (var i = 0; i &lt; 10; i++) {\n    stmt.run('Ipsum ' + i);\n  }\n\n  stmt.finalize();\n\n  db.each('SELECT rowid AS id, info FROM lorem', function(err, row) {\n    console.log(row.id + ': ' + row.info);\n  });\n});\n\ndb.close();\n</pre>  <h2 id=\"elasticsearch\">ElasticSearch</h2> <p><strong>Module</strong>: <a href=\"https://github.com/elastic/elasticsearch-js\">elasticsearch</a> <strong>Installation</strong></p> <pre data-language=\"sh\">$ npm install elasticsearch\n</pre> <p><strong>Example</strong></p> <pre data-language=\"js\">var elasticsearch = require('elasticsearch');\nvar client = elasticsearch.Client({\n  host: 'localhost:9200'\n});\n\nclient.search({\n  index: 'books',\n  type: 'book',\n  body: {\n    query: {\n      multi_match: {\n        query: 'express js',\n        fields: ['title', 'description']\n      }\n    }\n  }\n}).then(function(response) {\n  var hits = response.hits.hits;\n}, function(error) {\n  console.trace(error.message);\n});\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/guide/database-integration.html\" class=\"_attribution-link\">http://expressjs.com/en/guide/database-integration.html</a>\n  </p>\n</div>\n","advanced/pm":"<h1 id=\"process-managers-for-express-apps\">Process managers for Express apps</h1> <p>When you run Express apps for production, it is helpful to use a <em>process manager</em> to achieve the following tasks:</p> <ul> <li>Restart the app automatically if it crashes.</li> <li>Gain insights into runtime performance and resource consumption.</li> <li>Modify settings dynamically to improve performance.</li> <li>Control clustering.</li> </ul> <p>A process manager is somewhat like an application server: it’s a “container” for applications that facilitates deployment, provides high availability, and enables you to manage the application at runtime.</p> <p>The most popular process managers for Express and other Node.js applications are as follows:</p> <ul> <li><a href=\"#sl\">StrongLoop Process Manager</a></li> <li><a href=\"#pm2\">PM2</a></li> <li><a href=\"#forever\">Forever</a></li> </ul> <p>Using any of these three tools can be very helpful, however StrongLoop Process Manager is the only tool that provides a comprehensive runtime and deployment solution that addresses the entire Node.js application life cycle, with tooling for every step before and after production, in a unified interface.</p> <p>Here’s a brief look at each of these tools. For a detailed comparison, see <a href=\"http://strong-pm.io/compare/\">http://strong-pm.io/compare/</a>.</p> <h2 id=\"a-idslstrongloop-process-managera\"><a id=\"sl\">StrongLoop Process Manager</a></h2> <p>StrongLoop Process Manager (StrongLoop PM) is a production process manager for Node.js applications. StrongLoop PM has built-in load balancing, monitoring, and multi-host deployment, and a graphical console. You can use StrongLoop PM for the following tasks:</p> <ul> <li>Build, package, and deploy your Node.js application to a local or remote system.</li> <li>View CPU profiles and heap snapshots to optimize performance and diagnose memory leaks.</li> <li>Keep processes and clusters alive forever.</li> <li>View performance metrics on your application.</li> <li>Easily manage multi-host deployments with Nginx integration.</li> <li>Unify multiple StrongLoop PMs to a distributed microservices runtime that is managed from Arc.</li> </ul> <p>You can work with StrongLoop PM by using a powerful command-line interface tool called <code>slc</code>, or a graphical tool called Arc. Arc is open source, with professional support provided by StrongLoop.</p> <p>For more information, see <a href=\"http://strong-pm.io/\">http://strong-pm.io/</a>.</p> <p>Full documentation:</p> <ul> <li><a href=\"http://docs.strongloop.com/display/SLC\">Operating Node apps (StrongLoop documentation)</a></li> <li>\n<a href=\"http://docs.strongloop.com/display/SLC/Using+Process+Manager\">Using StrongLoop Process Manager</a>.</li> </ul> <h3 id=\"installation\">Installation</h3> <pre data-language=\"sh\">$ [sudo] npm install -g strongloop\n</pre> <h3 id=\"basic-use\">Basic use</h3> <pre data-language=\"sh\">$ cd my-app\n$ slc start\n</pre> <p>View the status of Process Manager and all deployed apps:</p> <pre data-language=\"sh\">$ slc ctl\nService ID: 1\nService Name: my-app\nEnvironment variables:\n  No environment variables defined\nInstances:\n    Version  Agent version  Cluster size\n     4.1.13      1.5.14           4\nProcesses:\n        ID      PID   WID  Listening Ports  Tracking objects?  CPU profiling?\n    1.1.57692  57692   0\n    1.1.57693  57693   1     0.0.0.0:3001\n    1.1.57694  57694   2     0.0.0.0:3001\n    1.1.57695  57695   3     0.0.0.0:3001\n    1.1.57696  57696   4     0.0.0.0:3001\n</pre> <p>List all the apps (services) under management:</p> <pre data-language=\"sh\">$ slc ctl ls\nId          Name         Scale\n 1          my-app       1\n</pre> <p>Stop an app:</p> <pre data-language=\"sh\">$ slc ctl stop my-app\n</pre> <p>Restart an app:</p> <pre data-language=\"sh\">$ slc ctl restart my-app\n</pre> <p>You can also “soft restart,” which gives worker processes a grace period to close existing connections, then restarts the current application:</p> <pre data-language=\"sh\">$ slc ctl soft-restart my-app\n</pre> <p>To remove an app from management:</p> <pre data-language=\"sh\">$ slc ctl remove my-app\n</pre> <h2 id=\"a-idpm2pm2a\"><a id=\"pm2\">PM2</a></h2> <p>PM2 is a production process manager for Node.js applications, that has a built-in load balancer. PM2 allows you to keep applications alive forever and reload them without downtime, and will facilitate common system admin tasks. PM2 also enables you to manage application logging, monitoring, and clustering.</p> <p>For more information, see <a href=\"https://github.com/Unitech/pm2\">https://github.com/Unitech/pm2</a>.</p> <h3 id=\"installation-1\">Installation</h3> <pre data-language=\"sh\">$ [sudo] npm install pm2 -g\n</pre> <h3 id=\"basic-use-1\">Basic use</h3> <p>When you start an app by using the <code>pm2</code> command, you must specify the path of the app. However, when you stop, restart, or delete an app, you can specify just the name or the id of the app.</p> <pre data-language=\"sh\">$ pm2 start app.js\n[PM2] restartProcessId process id 0\n┌──────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────────────┬──────────┐\n│ App name │ id │ mode │ pid   │ status │ restart │ uptime │ memory      │ watching │\n├──────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────────────┼──────────┤\n│ my-app   │ 0  │ fork │ 64029 │ online │ 1       │ 0s     │ 17.816 MB   │ disabled │\n└──────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────────────┴──────────┘\n Use the `pm2 show &lt;id|name&gt;` command to get more details about an app.\n</pre> <p>When you start an app by using the <code>pm2</code> command, the app is immediately sent to the background. You can control the background app from the command line by using various <code>pm2</code> commands.</p> <p>After an app is started by using the <code>pm2</code> command, it is registered in PM2’s list of processes with an ID. You can therefore manage apps with the same name from different directories on the system, by using their IDs.</p> <p>Note that if more than one app with the same name is running, <code>pm2</code> commands affect all of them. So use IDs instead of names to manage individual apps.</p> <p>List all running processes:</p> <pre data-language=\"sh\">$ pm2 list\n</pre> <p>Stop an app:</p> <pre data-language=\"sh\">$ pm2 stop 0\n</pre> <p>Restart an app:</p> <pre data-language=\"sh\">$ pm2 restart 0\n</pre> <p>To view detailed information about an app:</p> <pre data-language=\"sh\">$ pm2 show 0\n</pre> <p>To remove an app from PM2’s registry:</p> <pre data-language=\"sh\">$ pm2 delete 0\n</pre> <h2 id=\"a-idforeverforevera\"><a id=\"forever\">Forever</a></h2> <p>Forever is a simple command-line interface tool for ensuring that a given script runs continuously (forever). Forever’s simple interface makes it ideal for running smaller deployments of Node.js apps and scripts.</p> <p>For more information, see <a href=\"https://github.com/foreverjs/forever\">https://github.com/foreverjs/forever</a>.</p> <h3 id=\"installation-2\">Installation</h3> <pre data-language=\"sh\">$ [sudo] npm install forever -g\n</pre> <h3 id=\"basic-use-2\">Basic use</h3> <p>To start a script, use the <code>forever start</code> command and specify the path of the script:</p> <pre data-language=\"sh\">$ forever start script.js\n</pre> <p>This command will run the script in daemon mode (in the background).</p> <p>To run the script so that it is attached to the terminal, omit <code>start</code>:</p> <pre data-language=\"sh\">$ forever script.js\n</pre> <p>It is a good idea to log output from the Forever tool and the script by using the logging options <code>-l</code>, <code>-o</code>, and <code>-e</code>, as shown this example:</p> <pre data-language=\"sh\">$ forever start -l forever.log -o out.log -e err.log script.js\n</pre> <p>To view the list of scripts that were started by Forever:</p> <pre data-language=\"sh\">$ forever list\n</pre> <p>To stop a script that was started by Forever use the <code>forever stop</code> command and specify the process index (as listed by the <code>forever list</code> command).</p> <pre data-language=\"sh\">$ forever stop 1\n</pre> <p>Alternatively, specify the path of the file:</p> <pre data-language=\"sh\">$ forever stop script.js\n</pre> <p>To stop all the scripts that were started by Forever:</p> <pre data-language=\"sh\">$ forever stopall\n</pre> <p>Forever has many more options, and it also provides a programmatic API.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/advanced/pm.html\" class=\"_attribution-link\">http://expressjs.com/en/advanced/pm.html</a>\n  </p>\n</div>\n","advanced/best-practice-security":"<h1 id=\"production-best-practices-security\">Production Best Practices: Security</h1> <h2 id=\"overview\">Overview</h2> <p>The term <em>“production”</em> refers to the stage in the software lifecycle when an application or API is generally available to its end-users or consumers. In contrast, in the <em>“development”</em> stage, you’re still actively writing and testing code, and the application is not open to external access. The corresponding system environments are known as <em>production</em> and <em>development</em> environments, respectively.</p> <p>Development and production environments are usually set up differently and have vastly different requirements. What’s fine in development may not be acceptable in production. For example, in a development environment you may want verbose logging of errors for debugging, while the same behavior can become a security concern in a production environment. And in development, you don’t need to worry about scalability, reliability, and performance, while those concerns become critical in production.</p> <p>This article discusses some security best practices for Express applications deployed to production.</p> <p><strong>NOTE</strong>: If you believe you have discovered a security vulnerability in Express, please see <a href=\"https://github.com/strongloop/express/blob/master/Security.md\">Security Policies and Procedures</a>.</p> <h2 id=\"dont-use-deprecated-or-vulnerable-versions-of-express\">Don’t use deprecated or vulnerable versions of Express</h2> <p>Express 2.x and 3.x are no longer maintained. Security and performance issues in these versions won’t be fixed. Do not use them! If you haven’t moved to version 4, follow the <a href=\"../guide/migrating-4\">migration guide</a>.</p> <p>Also ensure you are not using any of the vulnerable Express versions listed on the <a href=\"security-updates\">Security updates page</a>. If you are, update to one of the stable releases, preferably the latest.</p> <h2 id=\"use-tls\">Use TLS</h2> <p>If your app deals with or transmits sensitive data, use <a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security\">Transport Layer Security</a> (TLS) to secure the connection and the data. This technology encrypts data before it is sent from the client to the server, thus preventing some common (and easy) hacks. Although Ajax and POST requests might not be visibly obvious and seem “hidden” in browsers, their network traffic is vulnerable to <a href=\"https://en.wikipedia.org/wiki/Packet_analyzer\">packet sniffing</a> and <a href=\"https://en.wikipedia.org/wiki/Man-in-the-middle_attack\">man-in-the-middle attacks</a>.</p> <p>You may be familiar with Secure Socket Layer (SSL) encryption. <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/aa380515(v=vs.85).aspx\">TLS is simply the next progression of SSL</a>. In other words, if you were using SSL before, consider upgrading to TLS. In general, we recommend Nginx to handle TLS. For a good reference to configure TLS on Nginx (and other servers), see <a href=\"https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_Server_Configurations\">Recommended Server Configurations (Mozilla Wiki)</a>.</p> <p>Also, a handy tool to get a free TLS certificate is <a href=\"https://letsencrypt.org/about/\">Let’s Encrypt</a>, a free, automated, and open certificate authority (CA) provided by the <a href=\"https://letsencrypt.org/isrg/\">Internet Security Research Group (ISRG)</a>.</p> <h2 id=\"use-helmet\">Use Helmet</h2> <p><a href=\"https://www.npmjs.com/package/helmet\">Helmet</a> can help protect your app from some well-known web vulnerabilities by setting HTTP headers appropriately.</p> <p>Helmet is actually just a collection of nine smaller middleware functions that set security-related HTTP headers:</p> <ul> <li>\n<a href=\"https://github.com/helmetjs/csp\">csp</a> sets the <code>Content-Security-Policy</code> header to help prevent cross-site scripting attacks and other cross-site injections.</li> <li>\n<a href=\"https://github.com/helmetjs/hide-powered-by\">hidePoweredBy</a> removes the <code>X-Powered-By</code> header.</li> <li>\n<a href=\"https://github.com/helmetjs/hpkp\">hpkp</a> Adds <a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Public_Key_Pinning\">Public Key Pinning</a> headers to prevent man-in-the-middle attacks with forged certificates.</li> <li>\n<a href=\"https://github.com/helmetjs/hsts\">hsts</a> sets <code>Strict-Transport-Security</code> header that enforces secure (HTTP over SSL/TLS) connections to the server.</li> <li>\n<a href=\"https://github.com/helmetjs/ienoopen\">ieNoOpen</a> sets <code>X-Download-Options</code> for IE8+.</li> <li>\n<a href=\"https://github.com/helmetjs/nocache\">noCache</a> sets <code>Cache-Control</code> and Pragma headers to disable client-side caching.</li> <li>\n<a href=\"https://github.com/helmetjs/dont-sniff-mimetype\">noSniff</a> sets <code>X-Content-Type-Options</code> to prevent browsers from MIME-sniffing a response away from the declared content-type.</li> <li>\n<a href=\"https://github.com/helmetjs/frameguard\">frameguard</a> sets the <code>X-Frame-Options</code> header to provide <a href=\"https://www.owasp.org/index.php/Clickjacking\">clickjacking</a> protection.</li> <li>\n<a href=\"https://github.com/helmetjs/x-xss-protection\">xssFilter</a> sets <code>X-XSS-Protection</code> to enable the Cross-site scripting (XSS) filter in most recent web browsers.</li> </ul> <p>Install Helmet like any other module:</p> <pre data-language=\"sh\">$ npm install --save helmet\n</pre> <p>Then to use it in your code:</p> <pre data-language=\"js\">...\nvar helmet = require('helmet');\napp.use(helmet());\n...\n</pre> <h3 id=\"at-a-minimum-disable-x-powered-by-header\">At a minimum, disable X-Powered-By header</h3> <p>If you don’t want to use Helmet, then at least disable the <code>X-Powered-By</code> header. Attackers can use this header (which is enabled by default) to detect apps running Express and then launch specifically-targeted attacks.</p> <p>So, best practice is to to turn off the header with the <code>app.disable()</code> method:</p> <pre data-language=\"js\">app.disable('x-powered-by');\n</pre> <p>If you use <code>helmet.js</code>, it takes care of this for you.</p> <h2 id=\"use-cookies-securely\">Use cookies securely</h2> <p>To ensure cookies don’t open your app to exploits, don’t use the default session cookie name and set cookie security options appropriately.</p> <p>There are two main middleware cookie session modules:</p> <ul> <li>\n<a href=\"https://www.npmjs.com/package/express-session\">express-session</a> that replaces <code>express.session</code> middleware built-in to Express 3.x.</li> <li>\n<a href=\"https://www.npmjs.com/package/cookie-session\">cookie-session</a> that replaces <code>express.cookieSession</code> middleware built-in to Express 3.x.</li> </ul> <p>The main difference between these two modules is how they save cookie session data. The <a href=\"https://www.npmjs.com/package/express-session\">express-session</a> middleware stores session data on the server; it only saves the session ID in the cookie itself, not session data. By default, it uses in-memory storage and is not designed for a production environment. In production, you’ll need to set up a scalable session-store; see the list of <a href=\"https://github.com/expressjs/session#compatible-session-stores\">compatible session stores</a>.</p> <p>In contrast, <a href=\"https://www.npmjs.com/package/cookie-session\">cookie-session</a> middleware implements cookie-backed storage: it serializes the entire session to the cookie, rather than just a session key. Only use it when session data is relatively small and easily encoded as primitive values (rather than objects). Although browsers are supposed to support at least 4096 bytes per cookie, to ensure you don’t exceed the limit, don’t exceed a size of 4093 bytes per domain. Also, be aware that the cookie data will be visible to the client, so if there is any reason to keep it secure or obscure, then express-session may be a better choice.</p> <h3 id=\"dont-use-the-default-session-cookie-name\">Don’t use the default session cookie name</h3> <p>Using the default session cookie name can open your app to attacks. The security issue posed is similar to <code>X-Powered-By</code>: a potential attacker can use it to fingerprint the server and target attacks accordingly.</p> <p>To avoid this problem, use generic cookie names; for example using <a href=\"https://www.npmjs.com/package/express-session\">express-session</a> middleware:</p> <pre data-language=\"js\">var session = require('express-session');\napp.set('trust proxy', 1) // trust first proxy\napp.use( session({\n   secret : 's3Cur3',\n   name : 'sessionId',\n  })\n);\n</pre> <h3 id=\"set-cookie-security-options\">Set cookie security options</h3> <p>Set the following cookie options to enhance security:</p> <ul> <li>\n<code>secure</code> - Ensures the browser only sends the cookie over HTTPS.</li> <li>\n<code>httpOnly</code> - Ensures the cookie is sent only over HTTP(S), not client JavaScript, helping to protect against cross-site scripting attacks.</li> <li>\n<code>domain</code> - indicates the domain of the cookie; use it to compare against the domain of the server in which the URL is being requested. If they match, then check the path attribute next.</li> <li>\n<code>path</code> - indicates the path of the cookie; use it to compare against the request path. If this and domain match, then send the cookie in the request.</li> <li>\n<code>expires</code> - use to set expiration date for persistent cookies.</li> </ul> <p>Here is an example using <a href=\"https://www.npmjs.com/package/cookie-session\">cookie-session</a> middleware:</p> <pre data-language=\"js\">var session = require('cookie-session');\nvar express = require('express');\nvar app = express();\n\nvar expiryDate = new Date( Date.now() + 60 * 60 * 1000 ); // 1 hour\napp.use(session({\n  name: 'session',\n  keys: ['key1', 'key2'],\n  cookie: { secure: true,\n            httpOnly: true,\n            domain: 'example.com',\n            path: 'foo/bar',\n            expires: expiryDate\n          }\n  })\n);\n</pre> <h2 id=\"ensure-your-dependencies-are-secure\">Ensure your dependencies are secure</h2> <p>Using npm to manage your application’s dependencies is powerful and convenient. But the packages that you use may contain critical security vulnerabilities that could also affect your application. The security of your app is only as strong as the “weakest link” in your dependencies.</p> <p>Use either or both of the following two tools to help ensure the security of third-party packages that you use: <a href=\"https://www.npmjs.com/package/nsp\">nsp</a> and <a href=\"https://requiresafe.com/\">requireSafe</a>. These two tools do largely the same thing.</p> <p><a href=\"https://www.npmjs.com/package/nsp\">nsp</a> is a command-line tool that checks the <a href=\"https://nodesecurity.io/\">Node Security Project</a> vulnerability database to determine if your application uses packages with known vulnerabilities. Install it as follows:</p> <pre data-language=\"sh\">$ npm i nsp -g\n</pre> <p>Use this command to submit the <code>npm-shrinkwrap.json</code> / <code>package.json</code> files for validation to <a href=\"https://nodesecurity.io/\">nodesecurity.io</a>:</p> <pre data-language=\"sh\">$ nsp check\n</pre> <p>Here’s how to use <a href=\"https://requiresafe.com/\">requireSafe</a> to audit your Node modules:</p> <pre data-language=\"sh\">$ npm install -g requiresafe\n$ cd your-app\n$ requiresafe check\n</pre> <h2 id=\"additional-considerations\">Additional considerations</h2> <p>Here are some further recommendations from the excellent <a href=\"https://blog.risingstack.com/node-js-security-checklist/\">Node.js Security Checklist</a>. Refer to that blog post for all the details on these recommendations:</p> <ul> <li>Implement rate-limiting to prevent brute-force attacks against authentication. One way to do this is to use <a href=\"https://strongloop.com/node-js/api-gateway/\">StrongLoop API Gateway</a> to enforce a rate-limiting policy. Alternatively, you can use middleware such as <a href=\"https://www.npmjs.com/package/express-limiter\">express-limiter</a>, but doing so will require you to modify your code somewhat.</li> <li>Use <a href=\"https://www.npmjs.com/package/csurf\">csurf</a> middleware to protect against cross-site request forgery (CSRF).</li> <li>Always filter and sanitize user input to protect against cross-site scripting (XSS) and command injection attacks.</li> <li>Defend against SQL injection attacks by using parameterized queries or prepared statements.</li> <li>Use the open-source <a href=\"http://sqlmap.org/\">sqlmap</a> tool to detect SQL injection vulnerabilities in your app.</li> <li>Use the <a href=\"https://nmap.org/\">nmap</a> and <a href=\"https://github.com/nabla-c0d3/sslyze\">sslyze</a> tools to test the configuration of your SSL ciphers, keys, and renegotiation as well as the validity of your certificate.</li> <li>Use <a href=\"https://www.npmjs.com/package/safe-regex\">safe-regex</a> to ensure your regular expressions are not susceptible to <a href=\"https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS\">regular expression denial of service</a> attacks.</li> </ul> <h2 id=\"avoid-other-known-vulnerabilities\">Avoid other known vulnerabilities</h2> <p>Keep an eye out for <a href=\"https://nodesecurity.io/advisories\">Node Security Project</a> advisories that may affect Express or other modules that your app uses. In general, the Node Security Project is an excellent resource for knowledge and tools about Node security.</p> <p>Finally, Express apps - like any other web apps - can be vulnerable to a variety of web-based attacks. Familiarize yourself with known <a href=\"https://www.owasp.org/index.php/Top_10_2013-Top_10\">web vulnerabilities</a> and take precautions to avoid them.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>\n    <a href=\"http://expressjs.com/en/advanced/best-practice-security.html\" class=\"_attribution-link\">http://expressjs.com/en/advanced/best-practice-security.html</a>\n  </p>\n</div>\n"}