<h1>Express</h1>  <h2>express()</h2> <p>Creates an Express application. The <code>express()</code> function is a top-level function exported by the <code>express</code> module.</p> <pre data-language="js">var express = require('express');
var app = express();
</pre> <h3 id="express.methods">Methods</h3>  <h3 id="express.static" class="h2">express.static(root, [options])</h3> <p>This is the only built-in middleware function in Express. It serves static files and is based on <a href="https://github.com/expressjs/serve-static">serve-static</a>.</p> <p>The <code>root</code> argument refers to the root directory from which the static assets are to be served. The file to serve will be determined by combining <code>req.url</code> with the provided <code>root</code> directory. When a file is not found, instead of sending a 404 response, this module will instead call <code>next()</code> to move on to the next middleware, allowing for stacking and fall-backs.</p> <p>The following table describes the properties of the <code>options</code> object.</p> <table> <thead> <tr> <th>Property</th> <th>Description</th> <th>Type</th> <th>Default</th> </tr> </thead> <tbody> <tr> <td><code>dotfiles</code></td> <td>Determines how dotfiles (files or directories that begin with a dot “.”) are treated. <br><br>See <a href="#dotfiles">dotfiles</a> below.</td> <td>String</td> <td>“ignore”</td> </tr> <tr> <td><code>etag</code></td> <td>Enable or disable etag generation <br><br>NOTE: <code>express.static</code> always sends weak ETags.</td> <td>Boolean</td> <td><code>true</code></td> </tr> <tr> <td><code>extensions</code></td> <td>Sets file extension fallbacks: If a file is not found, search for files with the specified extensions and serve the first one found. Example: <code>['html', 'htm']</code>.</td> <td>Boolean</td> <td><code>false</code></td> </tr> <tr> <td><code>fallthrough</code></td> <td>Let client errors fall-through as unhandled requests, otherwise forward a client error. <br><br>See <a href="#fallthrough">fallthrough</a> below.</td> <td>Boolean</td> <td><code>true</code></td> </tr> <tr> <td><code>index</code></td> <td>Sends the specified directory index file. Set to <code>false</code> to disable directory indexing.</td> <td>Mixed</td> <td>“index.html”</td> </tr> <tr> <td><code>lastModified</code></td> <td>Set the <code>Last-Modified</code> header to the last modified date of the file on the OS.</td> <td>Boolean</td> <td><code>true</code></td> </tr> <tr> <td><code>maxAge</code></td> <td>Set the max-age property of the Cache-Control header in milliseconds or a string in <a href="https://www.npmjs.org/package/ms">ms format</a>.</td> <td>Number</td> <td>0</td> </tr> <tr> <td><code>redirect</code></td> <td>Redirect to trailing “/” when the pathname is a directory.</td> <td>Boolean</td> <td><code>true</code></td> </tr> <tr> <td><code>setHeaders</code></td> <td>Function for setting HTTP headers to serve with the file. <br><br>See <a href="#setHeaders">setHeaders</a> below.</td> <td>Function</td> <td> </td> </tr> </tbody> </table> <p>For more information, see <a href="http://expressjs.com/starter/static-files.html">Serving static files in Express</a>.</p> <h5 id="dotfiles"> dotfiles</h5> <p>Possible values for this option are:</p> <ul> <li>“allow” - No special treatment for dotfiles.</li> <li>“deny” - Deny a request for a dotfile, respond with <code>403</code>, then call <code>next()</code>.</li> <li>“ignore” - Act as if the dotfile does not exist, respond with <code>404</code>, then call <code>next()</code>.</li> </ul> <p><strong>NOTE</strong>: With the default value, it will not ignore files in a directory that begins with a dot.</p> <h5 id="fallthrough">fallthrough</h5> <p>When this option is <code>true</code>, client errors such as a bad request or a request to a non-existent file will cause this middleware to simply call <code>next()</code> to invoke the next middleware in the stack. When false, these errors (even 404s), will invoke <code>next(err)</code>.</p> <p>Set this option to <code>true</code> so you can map multiple physical directories to the same web address or for routes to fill in non-existent files.</p> <p>Use <code>false</code> if you have mounted this middleware at a path designed to be strictly a single file system directory, which allows for short-circuiting 404s for less overhead. This middleware will also reply to all methods.</p> <h5 id="setHeaders">setHeaders</h5> <p>For this option, specify a function to set custom response headers. Alterations to the headers must occur synchronously.</p> <p>The signature of the function is:</p> <pre data-language="js">fn(res, path, stat)
</pre> <p>Arguments:</p> <ul> <li>
<code>res</code>, the <a href="#res">response object</a>.</li> <li>
<code>path</code>, the file path that is being sent.</li> <li>
<code>stat</code>, the <code>stat</code> object of the file that is being sent.</li> </ul>   <h3 id="express.router" class="h2">express.Router([options])</h3> <p>Creates a new <a href="#router">router</a> object.</p> <pre data-language="js">var router = express.Router([options]);
</pre> <p>The optional <code>options</code> parameter specifies the behavior of the router.</p> <div class="table-scroller"> <table> <thead> <tr> <th>Property</th> <th>Description</th> <th>Default</th> <th>Availability</th> </tr> </thead> <tbody> <tr> <td><code>caseSensitive</code></td> <td>Enable case sensitivity.</td> <td>Disabled by default, treating “/Foo” and “/foo” as the same.</td> <td> </td> </tr> <tr> <td><code>mergeParams</code></td> <td>Preserve the <code>req.params</code> values from the parent router. If the parent and the child have conflicting param names, the child’s value take precedence.</td> <td><code>false</code></td> <td>4.5.0+</td> </tr> <tr> <td><code>strict</code></td> <td>Enable strict routing.</td> <td>Disabled by default, “/foo” and “/foo/” are treated the same by the router.</td> <td> </td> </tr> </tbody> </table> </div> <p>You can add middleware and HTTP method routes (such as <code>get</code>, <code>put</code>, <code>post</code>, and so on) to <code>router</code> just like an application.</p> <p>For more information, see <a href="#router">Router</a>.</p>   <h2>Application</h2> <p>The <code>app</code> object conventionally denotes the Express application. Create it by calling the top-level <code>express()</code> function exported by the Express module:</p> <pre data-language="js">var express = require('express');
var app = express();

app.get('/', function(req, res){
  res.send('hello world');
});

app.listen(3000);
</pre> <p>The <code>app</code> object has methods for</p> <ul> <li>Routing HTTP requests; see for example, <a href="#app.METHOD">app.METHOD</a> and <a href="#app.param">app.param</a>.</li> <li>Configuring middleware; see <a href="#app.route">app.route</a>.</li> <li>Rendering HTML views; see <a href="#app.render">app.render</a>.</li> <li>Registering a template engine; see <a href="#app.engine">app.engine</a>.</li> </ul> <p>It also has settings (properties) that affect how the application behaves; for more information, see <a href="#app.settings.table">Application settings</a>.</p> <div class="doc-box doc-info"> <p>The Express application object can be referred from the <a href="#req">request object</a> and the <a href="#res">request object</a> as <code>req.app</code>, and <code>res.app</code>, respectvely.</p> </div> <h3 id="app.properties">Properties</h3>  <h3 id="app.locals">app.locals</h3> <p>The <code>app.locals</code> object has properties that are local variables within the application.</p> <pre data-language="js">app.locals.title
// =&gt; 'My App'

app.locals.email
// =&gt; 'me@myapp.com'
</pre> <p>Once set, the value of <code>app.locals</code> properties persist throughout the life of the application, in contrast with <a href="#res.locals">res.locals</a> properties that are valid only for the lifetime of the request.</p> <p>You can access local variables in templates rendered within the application. This is useful for providing helper functions to templates, as well as application-level data. Local variables are available in middleware via <code>req.app.locals</code> (see <a href="#req.app">req.app</a>)</p> <pre data-language="js">app.locals.title = 'My App';
app.locals.strftime = require('strftime');
app.locals.email = 'me@myapp.com';
</pre>   <h3 id="app.mountpath">app.mountpath</h3> <p>The <code>app.mountpath</code> property contains one or more path patterns on which a sub-app was mounted.</p> <div class="doc-box doc-info"> <p>A sub-app is an instance of <code>express</code> that may be used for handling the request to a route.</p> </div> <pre data-language="js">var express = require('express');

var app = express(); // the main app
var admin = express(); // the sub app

admin.get('/', function (req, res) {
  console.log(admin.mountpath); // /admin
  res.send('Admin Homepage');
});

app.use('/admin', admin); // mount the sub app
</pre> <p>It is similar to the <a href="#req.baseUrl">baseUrl</a> property of the <code>req</code> object, except <code>req.baseUrl</code> returns the matched URL path, instead of the matched patterns.</p> <p>If a sub-app is mounted on multiple path patterns, <code>app.mountpath</code> returns the list of patterns it is mounted on, as shown in the following example.</p> <pre data-language="js">var admin = express();

admin.get('/', function (req, res) {
  console.log(admin.mountpath); // [ '/adm*n', '/manager' ]
  res.send('Admin Homepage');
});

var secret = express();
secret.get('/', function (req, res) {
  console.log(secret.mountpath); // /secr*t
  res.send('Admin Secret');
});

admin.use('/secr*t', secret); // load the 'secret' router on '/secr*t', on the 'admin' sub app
app.use(['/adm*n', '/manager'], admin); // load the 'admin' router on '/adm*n' and '/manager', on the parent app
</pre>  <h3 id="app.events">Events</h3>  <h3 id="app.onmount">app.on('mount', callback(parent))</h3> <p>The <code>mount</code> event is fired on a sub-app, when it is mounted on a parent app. The parent app is passed to the callback function.</p> <div class="doc-box doc-info"> <p><strong>NOTE</strong></p> <p>Sub-apps will:</p> <ul> <li>Not inherit the value of settings that have a default value. You must set the value in the sub-app.</li> <li>Inherit the value of settings with no default value.</li> </ul> <p>For details, see <a href="4x/api#app.settings.table">Application settings</a>.</p> </div> <pre data-language="js">var admin = express();

admin.on('mount', function (parent) {
  console.log('Admin Mounted');
  console.log(parent); // refers to the parent app
});

admin.get('/', function (req, res) {
  res.send('Admin Homepage');
});

app.use('/admin', admin);
</pre>  <h3 id="app.methods">Methods</h3>  <h3 id="app.all">app.all(path, callback [, callback ...])</h3> <p>This method is like the standard <a href="#app.METHOD">app.METHOD()</a> methods, except it matches all HTTP verbs.</p> <p>It’s useful for mapping “global” logic for specific path prefixes or arbitrary matches. For example, if you put the following at the top of all other route definitions, it requires that all routes from that point on require authentication, and automatically load a user. Keep in mind that these callbacks do not have to act as end-points: <code>loadUser</code> can perform a task, then call <code>next()</code> to continue matching subsequent routes.</p> <pre data-language="js">app.all('*', requireAuthentication, loadUser);
</pre> <p>Or the equivalent:</p> <pre data-language="js">app.all('*', requireAuthentication)
app.all('*', loadUser);
</pre> <p>Another example is white-listed “global” functionality. The example is similar to the ones above, but it only restricts paths that start with “/api”:</p> <pre data-language="js">app.all('/api/*', requireAuthentication);
</pre>   <h3 id="app.delete.method">app.delete(path, callback [, callback ...])</h3> <p>Routes HTTP DELETE requests to the specified path with the specified callback functions. For more information, see the <a href="http://expressjs.com/guide/routing.html">routing guide</a>.</p> <p>You can provide multiple callback functions that behave just like middleware, except these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p> <pre data-language="js">app.delete('/', function (req, res) {
  res.send('DELETE request to homepage');
});
</pre>   <h3 id="app.disable">app.disable(name)</h3> <p>Sets the Boolean setting <code>name</code> to <code>false</code>, where <code>name</code> is one of the properties from the <a href="#app.settings.table">app settings table</a>. Calling <code>app.set('foo', false)</code> for a Boolean property is the same as calling <code>app.disable('foo')</code>.</p> <p>For example:</p> <pre data-language="js">app.disable('trust proxy');
app.get('trust proxy');
// =&gt; false
</pre>   <h3 id="app.disabled">app.disabled(name)</h3> <p>Returns <code>true</code> if the Boolean setting <code>name</code> is disabled (<code>false</code>), where <code>name</code> is one of the properties from the <a href="#app.settings.table">app settings table</a>.</p> <pre data-language="js">app.disabled('trust proxy');
// =&gt; true

app.enable('trust proxy');
app.disabled('trust proxy');
// =&gt; false
</pre>   <h3 id="app.enable">app.enable(name)</h3> <p>Sets the Boolean setting <code>name</code> to <code>true</code>, where <code>name</code> is one of the properties from the <a href="#app.settings.table">app settings table</a>. Calling <code>app.set('foo', true)</code> for a Boolean property is the same as calling <code>app.enable('foo')</code>.</p> <pre data-language="js">app.enable('trust proxy');
app.get('trust proxy');
// =&gt; true
</pre>   <h3 id="app.enabled">app.enabled(name)</h3> <p>Returns <code>true</code> if the setting <code>name</code> is enabled (<code>true</code>), where <code>name</code> is one of the properties from the <a href="#app.settings.table">app settings table</a>.</p> <pre data-language="js">app.enabled('trust proxy');
// =&gt; false

app.enable('trust proxy');
app.enabled('trust proxy');
// =&gt; true
</pre>   <h3 id="app.engine">app.engine(ext, callback)</h3> <p>Registers the given template engine <code>callback</code> as <code>ext</code>.</p> <p>By default, Express will <code>require()</code> the engine based on the file extension. For example, if you try to render a “foo.pug” file, Express invokes the following internally, and caches the <code>require()</code> on subsequent calls to increase performance.</p> <pre data-language="js">app.engine('pug', require('pug').__express);
</pre> <p>Use this method for engines that do not provide <code>.__express</code> out of the box, or if you wish to “map” a different extension to the template engine.</p> <p>For example, to map the EJS template engine to “.html” files:</p> <pre data-language="js">app.engine('html', require('ejs').renderFile);
</pre> <p>In this case, EJS provides a <code>.renderFile()</code> method with the same signature that Express expects: <code>(path, options, callback)</code>, though note that it aliases this method as <code>ejs.__express</code> internally so if you’re using “.ejs” extensions you don’t need to do anything.</p> <p>Some template engines do not follow this convention. The <a href="https://github.com/tj/consolidate.js">consolidate.js</a> library maps Node template engines to follow this convention, so they work seamlessly with Express.</p> <pre data-language="js">var engines = require('consolidate');
app.engine('haml', engines.haml);
app.engine('html', engines.hogan);
</pre>   <h3 id="app.get">app.get(name)</h3> <p>Returns the value of <code>name</code> app setting, where <code>name</code> is one of strings in the <a href="#app.settings.table">app settings table</a>. For example:</p> <pre data-language="js">app.get('title');
// =&gt; undefined

app.set('title', 'My Site');
app.get('title');
// =&gt; "My Site"
</pre>   <h3 id="app.get.method">app.get(path, callback [, callback ...])</h3> <p>Routes HTTP GET requests to the specified path with the specified callback functions. For more information, see the <a href="http://expressjs.com/guide/routing.html">routing guide</a>.</p> <p>You can provide multiple callback functions that behave just like middleware, except these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p> <pre data-language="js">app.get('/', function (req, res) {
  res.send('GET request to homepage');
});
</pre>   <h3 id="app.listen">app.listen(port, [hostname], [backlog], [callback])</h3> <p>Binds and listens for connections on the specified host and port. This method is identical to Node’s <a href="http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback">http.Server.listen()</a>.</p> <pre data-language="js">var express = require('express');
var app = express();
app.listen(3000);
</pre> <p>The <code>app</code> returned by <code>express()</code> is in fact a JavaScript <code>Function</code>, designed to be passed to Node’s HTTP servers as a callback to handle requests. This makes it easy to provide both HTTP and HTTPS versions of your app with the same code base, as the app does not inherit from these (it is simply a callback):</p> <pre data-language="js">var express = require('express');
var https = require('https');
var http = require('http');
var app = express();

http.createServer(app).listen(80);
https.createServer(options, app).listen(443);
</pre> <p>The <code>app.listen()</code> method returns an <a href="https://nodejs.org/api/http.html#http_class_http_server">http.Server</a> object and (for HTTP) is a convenience method for the following:</p> <pre data-language="js">app.listen = function() {
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};
</pre>   <h3 id="app.METHOD">app.METHOD(path, callback [, callback ...])</h3> <p>Routes an HTTP request, where METHOD is the HTTP method of the request, such as GET, PUT, POST, and so on, in lowercase. Thus, the actual methods are <code>app.get()</code>, <code>app.post()</code>, <code>app.put()</code>, and so on. See below for the complete list.</p> <p>For more information, see the <a href="http://expressjs.com/guide/routing.html">routing guide</a>.</p> <p>Express supports the following routing methods corresponding to the HTTP methods of the same names:</p> <table style="border: 0px; background: none"> <tr> <td style="background: none; border: 0px;"> <ul> <li><code>checkout</code></li> <li><code>copy</code></li> <li><code>delete</code></li> <li><code>get</code></li> <li><code>head</code></li> <li><code>lock</code></li> <li><code>merge</code></li> <li><code>mkactivity</code></li> </ul> </td> <td style="background: none; border: 0px;"> <ul> <li><code>mkcol</code></li> <li><code>move</code></li> <li><code>m-search</code></li> <li><code>notify</code></li> <li><code>options</code></li> <li><code>patch</code></li> <li><code>post</code></li> </ul> </td> <td style="background: none; border: 0px;"> <ul> <li><code>purge</code></li> <li><code>put</code></li> <li><code>report</code></li> <li><code>search</code></li> <li><code>subscribe</code></li> <li><code>trace</code></li> <li><code>unlock</code></li> <li><code>unsubscribe</code></li> </ul> </td> </tr> </table> <div class="doc-box doc-info"> <p>To route methods which translate to invalid JavaScript variable names, use the bracket notation. For example, <code>app['m-search']('/', function ...</code>.</p> </div> <p>You can provide multiple callback functions that behave just like middleware, except that these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.</p> <div class="doc-box doc-info"> <p>The API documentation has explicit entries only for the most popular HTTP methods <code>app.get()</code>, <code>app.post()</code>, <code>app.put()</code>, and <code>app.delete()</code>. However, the other methods listed above work in exactly the same way.</p> </div> <p>There is a special routing method, <code>app.all()</code>, that is not derived from any HTTP method. It loads middleware at a path for all request methods.</p> <p>In the following example, the handler is executed for requests to “/secret” whether using GET, POST, PUT, DELETE, or any other HTTP request method.</p> <pre data-language="js">app.all('/secret', function (req, res, next) {
  console.log('Accessing the secret section ...')
  next() // pass control to the next handler
});
</pre>   <h3 id="app.param">app.param([name], callback)</h3> <p>Add callback triggers to route parameters, where <code>name</code> is the name of the parameter or an array of them, and <code>callback</code> is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order.</p> <p>If <code>name</code> is an array, the <code>callback</code> trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to <code>next</code> inside the callback will call the callback for the next declared parameter. For the last parameter, a call to <code>next</code> will call the next middleware in place for the route currently being processed, just like it would if <code>name</code> were just a string.</p> <p>For example, when <code>:user</code> is present in a route path, you may map user loading logic to automatically provide <code>req.user</code> to the route, or perform validations on the parameter input.</p> <pre data-language="js">app.param('user', function(req, res, next, id) {

  // try to get the user details from the User model and attach it to the request object
  User.find(id, function(err, user) {
    if (err) {
      next(err);
    } else if (user) {
      req.user = user;
      next();
    } else {
      next(new Error('failed to load user'));
    }
  });
});
</pre> <p>Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers. Hence, param callbacks defined on <code>app</code> will be triggered only by route parameters defined on <code>app</code> routes.</p> <p>All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.</p> <pre data-language="js">app.param('id', function (req, res, next, id) {
  console.log('CALLED ONLY ONCE');
  next();
});

app.get('/user/:id', function (req, res, next) {
  console.log('although this matches');
  next();
});

app.get('/user/:id', function (req, res) {
  console.log('and this matches too');
  res.end();
});
</pre> <p>On <code>GET /user/42</code>, the following is printed:</p> <pre data-language="sh">CALLED ONLY ONCE
although this matches
and this matches too
</pre> <pre data-language="js">app.param(['id', 'page'], function (req, res, next, value) {
  console.log('CALLED ONLY ONCE with', value);
  next();
});

app.get('/user/:id/:page', function (req, res, next) {
  console.log('although this matches');
  next();
});

app.get('/user/:id/:page', function (req, res) {
  console.log('and this matches too');
  res.end();
});
</pre> <p>On <code>GET /user/42/3</code>, the following is printed:</p> <pre data-language="sh">CALLED ONLY ONCE with 42
CALLED ONLY ONCE with 3
although this matches
and this matches too
</pre> <div class="doc-box doc-warn"> <p>The following section describes <code>app.param(callback)</code>, which is deprecated as of v4.11.0.</p> </div> <p>The behavior of the <code>app.param(name, callback)</code> method can be altered entirely by passing only a function to <code>app.param()</code>. This function is a custom implementation of how <code>app.param(name, callback)</code> should behave - it accepts two parameters and must return a middleware.</p> <p>The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation.</p> <p>The middleware returned by the function decides the behavior of what happens when a URL parameter is captured.</p> <p>In this example, the <code>app.param(name, callback)</code> signature is modified to <code>app.param(name, accessId)</code>. Instead of accepting a name and a callback, <code>app.param()</code> will now accept a name and a number.</p> <pre data-language="js">var express = require('express');
var app = express();

// customizing the behavior of app.param()
app.param(function(param, option) {
  return function (req, res, next, val) {
    if (val == option) {
      next();
    }
    else {
      res.sendStatus(403);
    }
  }
});

// using the customized app.param()
app.param('id', 1337);

// route to trigger the capture
app.get('/user/:id', function (req, res) {
  res.send('OK');
});

app.listen(3000, function () {
  console.log('Ready');
});
</pre> <p>In this example, the <code>app.param(name, callback)</code> signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id.</p> <pre data-language="js">app.param(function(param, validator) {
  return function (req, res, next, val) {
    if (validator(val)) {
      next();
    }
    else {
      res.sendStatus(403);
    }
  }
});

app.param('id', function (candidate) {
  return !isNaN(parseFloat(candidate)) &amp;&amp; isFinite(candidate);
});
</pre> <div class="doc-box doc-info"> <p>The ‘<code>.</code>’ character can’t be used to capture a character in your capturing regexp. For example you can’t use <code>'/user-.+/'</code> to capture <code>'users-gami'</code>, use <code>[\\s\\S]</code> or <code>[\\w\\W]</code> instead (as in <code>'/user-[\\s\\S]+/'</code>.</p> <p>Examples:</p> <pre data-language="js">
//captures '1-a_6' but not '543-azser-sder'
router.get('/[0-9]+-[[\\w]]*', function);

//captures '1-a_6' and '543-az(ser"-sder' but not '5-a s'
router.get('/[0-9]+-[[\\S]]*', function);

//captures all (equivalent to '.*')
router.get('[[\\s\\S]]*', function);
</pre> </div>   <h3 id="app.path">app.path()</h3> <p>Returns the canonical path of the app, a string.</p> <pre data-language="js">var app = express()
  , blog = express()
  , blogAdmin = express();

app.use('/blog', blog);
blog.use('/admin', blogAdmin);

console.log(app.path()); // ''
console.log(blog.path()); // '/blog'
console.log(blogAdmin.path()); // '/blog/admin'
</pre> <p>The behavior of this method can become very complicated in complex cases of mounted apps: it is usually better to use <a href="#req.baseUrl">req.baseUrl</a> to get the canonical path of the app.</p>   <h3 id="app.post.method">app.post(path, callback [, callback ...])</h3> <p>Routes HTTP POST requests to the specified path with the specified callback functions. For more information, see the <a href="http://expressjs.com/guide/routing.html">routing guide</a>.</p> <p>You can provide multiple callback functions that behave just like middleware, except that these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p> <pre data-language="js">app.post('/', function (req, res) {
  res.send('POST request to homepage');
});
</pre>   <h3 id="app.put.method">app.put(path, callback [, callback ...])</h3> <p>Routes HTTP PUT requests to the specified path with the specified callback functions. For more information, see the <a href="http://expressjs.com/guide/routing.html">routing guide</a>.</p> <p>You can provide multiple callback functions that behave just like middleware, except that these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p> <pre data-language="js">app.put('/', function (req, res) {
  res.send('PUT request to homepage');
});
</pre>   <h3 id="app.render">app.render(view, [locals], callback)</h3> <p>Returns the rendered HTML of a view via the <code>callback</code> function. It accepts an optional parameter that is an object containing local variables for the view. It is like <a href="#res.render">res.render()</a>, except it cannot send the rendered view to the client on its own.</p> <div class="doc-box doc-info"> <p>Think of <code>app.render()</code> as a utility function for generating rendered view strings. Internally <code>res.render()</code> uses <code>app.render()</code> to render views.</p> </div> <div class="doc-box doc-notice"> <p>The local variable <code>cache</code> is reserved for enabling view cache. Set it to <code>true</code>, if you want to cache view during development; view caching is enabled in production by default.</p> </div> <pre data-language="js">app.render('email', function(err, html){
  // ...
});

app.render('email', { name: 'Tobi' }, function(err, html){
  // ...
});
</pre>   <h3 id="app.route">app.route(path)</h3> <p>Returns an instance of a single route, which you can then use to handle HTTP verbs with optional middleware. Use <code>app.route()</code> to avoid duplicate route names (and thus typo errors).</p> <pre data-language="js">var app = express();

app.route('/events')
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
})
.get(function(req, res, next) {
  res.json(...);
})
.post(function(req, res, next) {
  // maybe add a new event...
});
</pre>   <h3 id="app.set">app.set(name, value)</h3> <p>Assigns setting <code>name</code> to <code>value</code>, where <code>name</code> is one of the properties from the <a href="#app.settings.table">app settings table</a>.</p> <p>Calling <code>app.set('foo', true)</code> for a Boolean property is the same as calling <code>app.enable('foo')</code>. Similarly, calling <code>app.set('foo', false)</code> for a Boolean property is the same as calling <code>app.disable('foo')</code>.</p> <p>Retrieve the value of a setting with <a href="#app.get"><code>app.get()</code></a>.</p> <pre data-language="js">app.set('title', 'My Site');
app.get('title'); // "My Site"
</pre> <h4 id="app.settings.table">Application Settings</h4> <p>The following table lists application settings.</p> <p>Note that sub-apps will:</p> <ul> <li>Not inherit the value of settings that have a default value. You must set the value in the sub-app.</li> <li>Inherit the value of settings with no default value; these are explicitly noted in the table below.</li> </ul> <p>Exceptions: Sub-apps will inherit the value of <code>trust proxy</code> even though it has a default value (for backward-compatibility); Sub-apps will not inherit the value of <code>view cache</code> in production (when <code>NODE_ENV</code> is “production”).</p> <div class="table-scroller"> <table class="doctable"> <thead><tr>
<th id="app-settings-property">Property</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr></thead> <tbody> <tr> <td> <p><code>case sensitive routing</code></p> </td> <td>Boolean</td> <td>
<p>Enable case sensitivity. When enabled, "/Foo" and "/foo" are different routes. When disabled, "/Foo" and "/foo" are treated the same.</p> <p><b>NOTE</b>: Sub-apps will inherit the value of this setting.</p> </td> <td>N/A (undefined) </td> </tr> <tr> <td> <p><code>env</code></p> </td> <td>String</td> <td>Environment mode. Be sure to set to "production" in a production environment; see <a href="http://expressjs.com/advanced/best-practice-performance.html#env">Production best practices: performance and reliability</a>. </td> <td> <p><code>process.env.NODE_ENV</code> (<code>NODE_ENV</code> environment variable) or “development” if <code>NODE_ENV</code> is not set.</p> </td> </tr> <tr> <td> <p><code>etag</code></p> </td> <td>Varied</td> <td> <p>Set the ETag response header. For possible values, see the <a href="#etag.options.table"><code>etag</code> options table</a>.</p> <p><a href="http://en.wikipedia.org/wiki/HTTP_ETag">More about the HTTP ETag header</a>.</p> </td> <td> <p><code>weak</code></p> </td> </tr> <tr> <td> <p><code>jsonp callback name</code></p> </td> <td>String</td> <td>Specifies the default JSONP callback name.</td> <td> <p>“callback”</p> </td> </tr> <tr> <td> <p><code>json replacer</code></p> </td> <td>Varied</td> <td>The <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_replacer_parameter">'replacer' argument used by `JSON.stringify`</a>. <p><b>NOTE</b>: Sub-apps will inherit the value of this setting.</p> </td> <td>N/A (undefined) </td> </tr> <tr> <td> <p><code>json spaces</code></p> </td> <td>Varied</td> <td>The <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_space_argument">'space' argument used by `JSON.stringify`</a>. This is typically set to the number of spaces to use to indent prettified JSON. <p><b>NOTE</b>: Sub-apps will inherit the value of this setting.</p> </td> <td>N/A (undefined)</td> </tr> <tr> <td> <p><code>query parser</code></p> </td> <td>Varied</td> <td> <p>Disable query parsing by setting the value to <code>false</code>, or set the query parser to use either “simple” or “extended” or a custom query string parsing function.</p> <p>The simple query parser is based on Node’s native query parser, <a href="http://nodejs.org/api/querystring.html">querystring</a>.</p> <p>The extended query parser is based on <a href="https://www.npmjs.org/package/qs">qs</a>.</p> <p>A custom query string parsing function will receive the complete query string, and must return an object of query keys and their values.</p> </td> <td>"extended"</td> </tr> <tr> <td> <p><code>strict routing</code></p> </td> <td>Boolean</td> <td>
<p>Enable strict routing. When enabled, the router treats "/foo" and "/foo/" as different. Otherwise, the router treats "/foo" and "/foo/" as the same.</p> <p><b>NOTE</b>: Sub-apps will inherit the value of this setting.</p> </td> <td>N/A (undefined) </td> </tr> <tr> <td> <p><code>subdomain offset</code></p> </td> <td>Number</td> <td>The number of dot-separated parts of the host to remove to access subdomain.</td> <td>2</td> </tr> <tr> <td> <p><code>trust proxy</code></p> </td> <td>Varied</td> <td> <p>Indicates the app is behind a front-facing proxy, and to use the <code>X-Forwarded-*</code> headers to determine the connection and the IP address of the client. NOTE: <code>X-Forwarded-*</code> headers are easily spoofed and the detected IP addresses are unreliable.</p> <p> When enabled, Express attempts to determine the IP address of the client connected through the front-facing proxy, or series of proxies. The `req.ips` property, then contains an array of IP addresses the client is connected through. To enable it, use the values described in the <a href="#trust.proxy.options.table">trust proxy options table</a>. </p> <p> The `trust proxy` setting is implemented using the <a href="https://www.npmjs.org/package/proxy-addr">proxy-addr</a> package. For more information, see its documentation. </p> <p> <b>NOTE</b>: Sub-apps <i>will</i> inherit the value of this setting, even though it has a default value. </p> </td> <td> <p><code>false</code> (disabled)</p> </td> </tr> <tr> <td> <p><code>views</code></p> </td> <td>String or Array</td> <td>A directory or an array of directories for the application's views. If an array, the views are looked up in the order they occur in the array.</td> <td> <p><code>process.cwd() + '/views'</code></p> </td> </tr> <tr> <td> <p><code>view cache</code></p> </td> <td>Boolean</td> <td>
<p>Enables view template compilation caching.</p> <p><b>NOTE</b>: Sub-apps will not inherit the value of this setting in production (when `NODE_ENV` is "production").</p> </td> <td> <p><code>true</code> in production, otherwise undefined.</p> </td> </tr> <tr> <td> <p><code>view engine</code></p> </td> <td>String</td> <td>The default engine extension to use when omitted. <p><b>NOTE</b>: Sub-apps will inherit the value of this setting.</p> </td> <td>N/A (undefined)</td> </tr> <tr> <td> <p><code>x-powered-by</code></p> </td> <td>Boolean</td> <td>Enables the "X-Powered-By: Express" HTTP header.</td> <td> <p><code>true</code></p> </td> </tr> </tbody> </table> <h5 id="trust.proxy.options.table">Options for `trust proxy` setting</h5> <p> Read <a href="http://expressjs.com/guide/behind-proxies.html">Express behind proxies</a> for more information. </p> <table class="doctable"> <thead><tr>
<th>Type</th>
<th>Value</th>
</tr></thead> <tbody> <tr> <td>Boolean</td> <td> <p>If <code>true</code>, the client’s IP address is understood as the left-most entry in the <code>X-Forwarded-*</code> header.</p> <p>If <code>false</code>, the app is understood as directly facing the Internet and the client’s IP address is derived from <code>req.connection.remoteAddress</code>. This is the default setting.</p> </td> </tr> <tr> <td>String<br>String containing comma-separated values<br>Array of strings </td> <td> <p>An IP address, subnet, or an array of IP addresses, and subnets to trust. Pre-configured subnet names are:</p> <ul> <li>loopback - <code>127.0.0.1/8</code>, <code>::1/128</code>
</li> <li>linklocal - <code>169.254.0.0/16</code>, <code>fe80::/10</code>
</li> <li>uniquelocal - <code>10.0.0.0/8</code>, <code>172.16.0.0/12</code>, <code>192.168.0.0/16</code>, <code>fc00::/7</code>
</li> </ul> <p>Set IP addresses in any of the following ways:</p> <p>Specify a single subnet:</p> <pre data-language="js">app.set('trust proxy', 'loopback') 
</pre> <p>Specify a subnet and an address:</p> <pre data-language="js">app.set('trust proxy', 'loopback, 123.123.123.123') 
</pre> <p>Specify multiple subnets as CSV:</p> <pre data-language="js">app.set('trust proxy', 'loopback, linklocal, uniquelocal') 
</pre> <p>Specify multiple subnets as an array:</p> <pre data-language="js">app.set('trust proxy', ['loopback', 'linklocal', 'uniquelocal'])
</pre> <p>When specified, the IP addresses or the subnets are excluded from the address determination process, and the untrusted IP address nearest to the application server is determined as the client’s IP address.</p> </td> </tr> <tr> <td>Number</td> <td> <p>Trust the <i>n</i><sup>th</sup> hop from the front-facing proxy server as the client.</p> </td> </tr> <tr> <td>Function</td> <td> <p>Custom trust implementation. Use this only if you know what you are doing.</p> <pre data-language="js">app.set('trust proxy', function (ip) {
    if (ip === '127.0.0.1' || ip === '123.123.123.123') return true; // trusted IPs
    else return false;
  });
</pre> </td> </tr> </tbody> </table> <h5 id="etag.options.table">Options for `etag` setting</h5> <p> <strong>NOTE</strong>: These settings apply only to dynamic files, not static files. The <a href="#express.static">express.static</a> middleware ignores these settings. </p> <p> The ETag functionality is implemented using the <a href="https://www.npmjs.org/package/etag">etag</a> package. For more information, see its documentation. </p> <table class="doctable"> <thead><tr>
<th>Type</th>
<th>Value</th>
</tr></thead> <tbody> <tr> <td>Boolean</td> <td> <p><code>true</code> enables weak ETag. This is the default setting.<br> <code>false</code> disables ETag altogether.</p> </td> </tr> <tr> <td>String</td> <td> If "strong", enables strong ETag.<br> If "weak", enables weak ETag. </td> </tr> <tr> <td>Function</td> <td> <p>Custom ETag function implementation. Use this only if you know what you are doing.</p> <pre data-language="js"> app.set('etag', function (body, encoding) {
  return generateHash(body, encoding); // consider the function is defined
  });
</pre> </td> </tr> </tbody> </table> </div>   <h3 id="app.use">app.use([path,] function [, function...])</h3> <p>Mounts the specified <a href="http://expressjs.com/guide/using-middleware.html">middleware</a> function or functions at the specified path. If <code>path</code> is not specified, it defaults to “/”.</p> <div class="doc-box doc-info"> <p>A route will match any path that follows its path immediately with a “<code>/</code>”. For example: <code>app.use('/apple', ...)</code> will match “/apple”, “/apple/images”, “/apple/images/news”, and so on.</p> </div> <p>Note that <code>req.originalUrl</code> in a middleware function is a combination of <code>req.baseUrl</code> and <code>req.path</code>, as shown in the following example.</p> <pre data-language="js">app.use('/admin', function(req, res, next) {
  // GET 'http://www.example.com/admin/new'
  console.log(req.originalUrl); // '/admin/new'
  console.log(req.baseUrl); // '/admin'
  console.log(req.path); // '/new'
  next();
});
</pre> <p>Mounting a middleware function at a <code>path</code> will cause the middleware function to be executed whenever the base of the requested path matches the <code>path</code>.</p> <p>Since <code>path</code> defaults to “/”, middleware mounted without a path will be executed for every request to the app.</p> <pre data-language="js">// this middleware will be executed for every request to the app
app.use(function (req, res, next) {
  console.log('Time: %d', Date.now());
  next();
});
</pre> <div class="doc-box doc-info"> <p><strong>NOTE</strong></p> <p>Sub-apps will:</p> <ul> <li>Not inherit the value of settings that have a default value. You must set the value in the sub-app.</li> <li>Inherit the value of settings with no default value.</li> </ul> <p>For details, see <a href="4x/api#app.settings.table">Application settings</a>.</p> </div> <p>Middleware functions are executed sequentially, therefore the order of middleware inclusion is important.</p> <pre data-language="js">// this middleware will not allow the request to go beyond it
app.use(function(req, res, next) {
  res.send('Hello World');
});

// requests will never reach this route
app.get('/', function (req, res) {
  res.send('Welcome');
});
</pre> <p><code>path</code> can be a string representing a path, a path pattern, a regular expression to match paths, or an array of combinations thereof.</p> <p>The following table provides some simple examples of mounting middleware.</p> <div class="table-scroller"> <table class="doctable"> <thead> <tr> <th> Type </th> <th> Example </th> </tr> </thead> <tbody> <tr> <td>Path</td> <td> This will match paths starting with `/abcd`: <pre data-language="js">app.use('/abcd', function (req, res, next) {
  next();
});
</pre> </td> </tr> <tr> <td>Path Pattern</td> <td> This will match paths starting with `/abcd` and `/abd`: <pre data-language="js">app.use('/abc?d', function (req, res, next) {
  next();
});
</pre> This will match paths starting with `/abcd`, `/abbcd`, `/abbbbbcd`, and so on: <pre data-language="js">
app.use('/ab+cd', function (req, res, next) {
  next();
});</pre> This will match paths starting with `/abcd`, `/abxcd`, `/abFOOcd`, `/abbArcd`, and so on: <pre data-language="js">
app.use('/ab\*cd', function (req, res, next) {
  next();
});</pre> This will match paths starting with `/ad` and `/abcd`: <pre data-language="js">
app.use('/a(bc)?d', function (req, res, next) {
  next();
});</pre> </td> </tr> <tr> <td>Regular Expression</td> <td> This will match paths starting with `/abc` and `/xyz`: <pre data-language="js">app.use(/\/abc|\/xyz/, function (req, res, next) {
  next();
});</pre> </td> </tr> <tr> <td>Array</td> <td> This will match paths starting with `/abcd`, `/xyza`, `/lmn`, and `/pqr`: <pre data-language="js">app.use(['/abcd', '/xyza', /\/lmn|\/pqr/], function (req, res, next) {
  next();
});</pre> </td> </tr> </tbody> </table> </div> <p><code>function</code> can be a middleware function, a series of middleware functions, an array of middleware functions, or a combination of all of them. Since <a href="#router">router</a> and <a href="#application">app</a> implement the middleware interface, you can use them as you would any other middleware function.</p> <table class="doctable"> <thead> <tr> <th>Usage</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td>Single Middleware</td> <td>You can define and mount a middleware function locally. <pre data-language="js">app.use(function (req, res, next) {
  next();
});
</pre> A router is valid middleware. <pre data-language="js">var router = express.Router();
router.get('/', function (req, res, next) {
  next();
});
app.use(router);
</pre> An Express app is valid middleware. <pre data-language="js">var subApp = express();
subApp.get('/', function (req, res, next) {
  next();
});
app.use(subApp);
</pre> </td> </tr> <tr> <td>Series of Middleware</td> <td> You can specify more than one middleware function at the same mount path. <pre data-language="js">var r1 = express.Router();
r1.get('/', function (req, res, next) {
  next();
});

var r2 = express.Router();
r2.get('/', function (req, res, next) {
  next();
});

app.use(r1, r2);
</pre> </td> </tr> <tr> <td>Array</td> <td> Use an array to group middleware logically. If you pass an array of middleware as the first or only middleware parameters, then you <em>must</em> specify the mount path. <pre data-language="js">var r1 = express.Router();
r1.get('/', function (req, res, next) {
  next();
});

var r2 = express.Router();
r2.get('/', function (req, res, next) {
  next();
});

app.use('/', [r1, r2]);
</pre> </td> </tr> <tr> <td>Combination</td> <td> You can combine all the above ways of mounting middleware. <pre data-language="js">function mw1(req, res, next) { next(); }
function mw2(req, res, next) { next(); }

var r1 = express.Router();
r1.get('/', function (req, res, next) { next(); });

var r2 = express.Router();
r2.get('/', function (req, res, next) { next(); });

var subApp = express();
subApp.get('/', function (req, res, next) { next(); });

app.use(mw1, [mw2, r1, r2], subApp);
</pre> </td> </tr> </tbody> </table> <p>Following are some examples of using the <a href="http://expressjs.com/guide/using-middleware.html#middleware.built-in">express.static</a> middleware in an Express app.</p> <p>Serve static content for the app from the “public” directory in the application directory:</p> <pre data-language="js">// GET /style.css etc
app.use(express.static(__dirname + '/public'));
</pre> <p>Mount the middleware at “/static” to serve static content only when their request path is prefixed with “/static”:</p> <pre data-language="js">// GET /static/style.css etc.
app.use('/static', express.static(__dirname + '/public'));
</pre> <p>Disable logging for static content requests by loading the logger middleware after the static middleware:</p> <pre data-language="js">app.use(express.static(__dirname + '/public'));
app.use(logger());
</pre> <p>Serve static files from multiple directories, but give precedence to “./public” over the others:</p> <pre data-language="js">app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads'));
</pre>   <h2>Request</h2> <p>The <code>req</code> object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention, the object is always referred to as <code>req</code> (and the HTTP response is <code>res</code>) but its actual name is determined by the parameters to the callback function in which you’re working.</p> <p>For example:</p> <pre data-language="js">app.get('/user/:id', function(req, res) {
  res.send('user ' + req.params.id);
});
</pre> <p>But you could just as well have:</p> <pre data-language="js">app.get('/user/:id', function(request, response) {
  response.send('user ' + request.params.id);
});
</pre> <p>The <code>req</code> object is an enhanced version of Node’s own request object and supports all <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage">built-in fields and methods</a>.</p> <h3 id="req.properties">Properties</h3> <div class="doc-box doc-notice"> <p>In Express 4, <code>req.files</code> is no longer available on the <code>req</code> object by default. To access uploaded files on the <code>req.files</code> object, use multipart-handling middleware like <a href="#">busboy</a>, <a href="https://www.npmjs.com/package/multer">multer</a>, <a href="https://www.npmjs.com/package/formidable">formidable</a>, <a href="https://www.npmjs.com/package/multiparty">multiparty</a>, <a href="https://www.npmjs.com/package/connect-multiparty">connect-multiparty</a>, or <a href="https://www.npmjs.com/package/pez">pez</a>.</p> </div>  <h3 id="req.app">req.app</h3> <p>This property holds a reference to the instance of the Express application that is using the middleware.</p> <p>If you follow the pattern in which you create a module that just exports a middleware function and <code>require()</code> it in your main file, then the middleware can access the Express instance via <code>req.app</code></p> <p>For example:</p> <pre data-language="js">//index.js
app.get('/viewdirectory', require('./mymiddleware.js'))
</pre> <pre data-language="js">//mymiddleware.js
module.exports = function (req, res) {
  res.send('The views directory is ' + req.app.get('views'));
});
</pre>   <h3 id="req.baseUrl">req.baseUrl</h3> <p>The URL path on which a router instance was mounted.</p> <p>The <code>req.baseUrl</code> property is similar to the <a href="#app.mountpath">mountpath</a> property of the <code>app</code> object, except <code>app.mountpath</code> returns the matched path pattern(s).</p> <p>For example:</p> <pre data-language="js">var greet = express.Router();

greet.get('/jp', function (req, res) {
  console.log(req.baseUrl); // /greet
  res.send('Konichiwa!');
});

app.use('/greet', greet); // load the router on '/greet'
</pre> <p>Even if you use a path pattern or a set of path patterns to load the router, the <code>baseUrl</code> property returns the matched string, not the pattern(s). In the following example, the <code>greet</code> router is loaded on two path patterns.</p> <pre data-language="js">app.use(['/gre+t', '/hel{2}o'], greet); // load the router on '/gre+t' and '/hel{2}o'
</pre> <p>When a request is made to <code>/greet/jp</code>, <code>req.baseUrl</code> is “/greet”. When a request is made to <code>/hello/jp</code>, <code>req.baseUrl</code> is “/hello”.</p>   <h3 id="req.body">req.body</h3> <p>Contains key-value pairs of data submitted in the request body. By default, it is <code>undefined</code>, and is populated when you use body-parsing middleware such as <a href="https://www.npmjs.org/package/body-parser">body-parser</a> and <a href="https://www.npmjs.org/package/multer">multer</a>.</p> <p>The following example shows how to use body-parsing middleware to populate <code>req.body</code>.</p> <pre data-language="js">var app = require('express')();
var bodyParser = require('body-parser');
var multer = require('multer'); // v1.0.5
var upload = multer(); // for parsing multipart/form-data

app.use(bodyParser.json()); // for parsing application/json
app.use(bodyParser.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded

app.post('/profile', upload.array(), function (req, res, next) {
  console.log(req.body);
  res.json(req.body);
});
</pre>   <h3 id="req.cookies">req.cookies</h3> <p>When using <a href="https://www.npmjs.com/package/cookie-parser">cookie-parser</a> middleware, this property is an object that contains cookies sent by the request. If the request contains no cookies, it defaults to <code>{}</code>.</p> <pre data-language="js">// Cookie: name=tj
req.cookies.name
// =&gt; "tj"
</pre> <p>For more information, issues, or concerns, see <a href="https://github.com/expressjs/cookie-parser">cookie-parser</a>.</p>   <h3 id="req.fresh">req.fresh</h3> <p>Indicates whether the request is “fresh.” It is the opposite of <code>req.stale</code>.</p> <p>It is true if the <code>cache-control</code> request header doesn’t have a <code>no-cache</code> directive and any of the following are true:</p> <ul> <li>The <code>if-modified-since</code> request header is specified and <code>last-modified</code> request header is equal to or earlier than the <code>modified</code> response header.</li> <li>The <code>if-none-match</code> request header is <code>*</code>.</li> <li>The <code>if-none-match</code> request header, after being parsed into its directives, does not match the <code>etag</code> response header.</li> </ul> <pre data-language="js">req.fresh
// =&gt; true
</pre> <p>For more information, issues, or concerns, see <a href="https://github.com/jshttp/fresh">fresh</a>.</p>   <h3 id="req.hostname">req.hostname</h3> <p>Contains the hostname derived from the <code>Host</code> HTTP header.</p> <p>When the <a href="http://expressjs.com/4x/api.html#trust.proxy.options.table"><code>trust proxy</code> setting</a> does not evaluate to <code>false</code>, this property will instead have the value of the <code>X-Forwarded-Host</code> header field. This header can be set by the client or by the proxy.</p> <pre data-language="js">// Host: "example.com:3000"
req.hostname
// =&gt; "example.com"
</pre>   <h3 id="req.ip">req.ip</h3> <p>Contains the remote IP address of the request.</p> <p>When the <a href="http://expressjs.com/4x/api.html#trust.proxy.options.table"><code>trust proxy</code> setting</a> does not evaluate to <code>false</code>, the value of this property is derived from the left-most entry in the <code>X-Forwarded-For</code> header. This header can be set by the client or by the proxy.</p> <pre data-language="js">req.ip
// =&gt; "127.0.0.1"
</pre>   <h3 id="req.ips">req.ips</h3> <p>When the <a href="http://expressjs.com/4x/api.html#trust.proxy.options.table"><code>trust proxy</code> setting</a> does not evaluate to <code>false</code>, this property contains an array of IP addresses specified in the <code>X-Forwarded-For</code> request header. Otherwise, it contains an empty array. This header can be set by the client or by the proxy.</p> <p>For example, if <code>X-Forwarded-For</code> is <code>client, proxy1, proxy2</code>, <code>req.ips</code> would be <code>["client", "proxy1", "proxy2"]</code>, where <code>proxy2</code> is the furthest downstream.</p>   <h3 id="req.method">req.method</h3> <p>Contains a string corresponding to the HTTP method of the request: <code>GET</code>, <code>POST</code>, <code>PUT</code>, and so on.</p>   <h3 id="req.originalUrl">req.originalUrl</h3> <div class="doc-box doc-notice"> <p><code>req.url</code> is not a native Express property, it is inherited from Node’s <a href="https://nodejs.org/api/http.html#http_message_url">http module</a>.</p> </div> <p>This property is much like <code>req.url</code>; however, it retains the original request URL, allowing you to rewrite <code>req.url</code> freely for internal routing purposes. For example, the “mounting” feature of <a href="#app.use">app.use()</a> will rewrite <code>req.url</code> to strip the mount point.</p> <pre data-language="js">// GET /search?q=something
req.originalUrl
// =&gt; "/search?q=something"
</pre>   <h3 id="req.params">req.params</h3> <p>This property is an object containing properties mapped to the named route “parameters”. For example, if you have the route <code>/user/:name</code>, then the “name” property is available as <code>req.params.name</code>. This object defaults to <code>{}</code>.</p> <pre data-language="js">// GET /user/tj
req.params.name
// =&gt; "tj"
</pre> <p>When you use a regular expression for the route definition, capture groups are provided in the array using <code>req.params[n]</code>, where <code>n</code> is the n<sup>th</sup> capture group. This rule is applied to unnamed wild card matches with string routes such as <code>/file/*</code>:</p> <pre data-language="js">// GET /file/javascripts/jquery.js
req.params[0]
// =&gt; "javascripts/jquery.js"
</pre>   <h3 id="req.path">req.path</h3> <p>Contains the path part of the request URL.</p> <pre data-language="js">// example.com/users?sort=desc
req.path
// =&gt; "/users"
</pre> <div class="doc-box doc-info"> <p>When called from a middleware, the mount point is not included in <code>req.path</code>. See <a href="http://expressjs.com/4x/api.html#app.use">app.use()</a> for more details.</p> </div>   <h3 id="req.protocol">req.protocol</h3> <p>Contains the request protocol string: either <code>http</code> or (for TLS requests) <code>https</code>.</p> <p>When the <a href="http://expressjs.com/4x/api.html#trust.proxy.options.table"><code>trust proxy</code> setting</a> does not evaluate to <code>false</code>, this property will use the value of the <code>X-Forwarded-Proto</code> header field if present. This header can be set by the client or by the proxy.</p> <pre data-language="js">req.protocol
// =&gt; "http"
</pre>   <h3 id="req.query">req.query</h3> <p>This property is an object containing a property for each query string parameter in the route. If there is no query string, it is the empty object, <code>{}</code>.</p> <pre data-language="js">// GET /search?q=tobi+ferret
req.query.q
// =&gt; "tobi ferret"

// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse
req.query.order
// =&gt; "desc"

req.query.shoe.color
// =&gt; "blue"

req.query.shoe.type
// =&gt; "converse"
</pre>   <h3 id="req.route">req.route</h3> <p>Contains the currently-matched route, a string. For example:</p> <pre data-language="js">app.get('/user/:id?', function userIdHandler(req, res) {
  console.log(req.route);
  res.send('GET');
});
</pre> <p>Example output from the previous snippet:</p> <pre data-language="js">{ path: '/user/:id?',
  stack:
   [ { handle: [Function: userIdHandler],
       name: 'userIdHandler',
       params: undefined,
       path: undefined,
       keys: [],
       regexp: /^\/?$/i,
       method: 'get' } ],
  methods: { get: true } }
</pre>   <h3 id="req.secure">req.secure</h3> <p>A Boolean property that is true if a TLS connection is established. Equivalent to:</p> <pre data-language="js">'https' == req.protocol;
</pre>   <h3 id="req.signedCookies">req.signedCookies</h3> <p>When using <a href="https://www.npmjs.com/package/cookie-parser">cookie-parser</a> middleware, this property contains signed cookies sent by the request, unsigned and ready for use. Signed cookies reside in a different object to show developer intent; otherwise, a malicious attack could be placed on <code>req.cookie</code> values (which are easy to spoof). Note that signing a cookie does not make it “hidden” or encrypted; but simply prevents tampering (because the secret used to sign is private).</p> <p>If no signed cookies are sent, the property defaults to <code>{}</code>.</p> <pre data-language="js">// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
req.signedCookies.user
// =&gt; "tobi"
</pre> <p>For more information, issues, or concerns, see <a href="https://github.com/expressjs/cookie-parser">cookie-parser</a>.</p>   <h3 id="req.stale">req.stale</h3> <p>Indicates whether the request is “stale,” and is the opposite of <code>req.fresh</code>. For more information, see <a href="#req.fresh">req.fresh</a>.</p> <pre data-language="js">req.stale
// =&gt; true
</pre>   <h3 id="req.subdomains">req.subdomains</h3> <p>An array of subdomains in the domain name of the request.</p> <pre data-language="js">// Host: "tobi.ferrets.example.com"
req.subdomains
// =&gt; ["ferrets", "tobi"]
</pre>   <h3 id="req.xhr">req.xhr</h3> <p>A Boolean property that is <code>true</code> if the request’s <code>X-Requested-With</code> header field is “XMLHttpRequest”, indicating that the request was issued by a client library such as jQuery.</p> <pre data-language="js">req.xhr
// =&gt; true
</pre>  <h3 id="req.methods">Methods</h3>  <h3 id="req.accepts">req.accepts(types)</h3> <p>Checks if the specified content types are acceptable, based on the request’s <code>Accept</code> HTTP header field. The method returns the best match, or if none of the specified content types is acceptable, returns <code>false</code> (in which case, the application should respond with <code>406 "Not Acceptable"</code>).</p> <p>The <code>type</code> value may be a single MIME type string (such as “application/json”), an extension name such as “json”, a comma-delimited list, or an array. For a list or array, the method returns the <em>best</em> match (if any).</p> <pre data-language="js">// Accept: text/html
req.accepts('html');
// =&gt; "html"

// Accept: text/*, application/json
req.accepts('html');
// =&gt; "html"
req.accepts('text/html');
// =&gt; "text/html"
req.accepts(['json', 'text']);
// =&gt; "json"
req.accepts('application/json');
// =&gt; "application/json"

// Accept: text/*, application/json
req.accepts('image/png');
req.accepts('png');
// =&gt; undefined

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json']);
// =&gt; "json"
</pre> <p>For more information, or if you have issues or concerns, see <a href="https://github.com/expressjs/accepts">accepts</a>.</p>   <h3 id="req.acceptsCharsets">req.acceptsCharsets(charset [, ...])</h3> <p>Returns the first accepted charset of the specified character sets, based on the request’s <code>Accept-Charset</code> HTTP header field. If none of the specified charsets is accepted, returns <code>false</code>.</p> <p>For more information, or if you have issues or concerns, see <a href="https://github.com/expressjs/accepts">accepts</a>.</p>   <h3 id="req.acceptsEncodings">req.acceptsEncodings(encoding [, ...])</h3> <p>Returns the first accepted encoding of the specified encodings, based on the request’s <code>Accept-Encoding</code> HTTP header field. If none of the specified encodings is accepted, returns <code>false</code>.</p> <p>For more information, or if you have issues or concerns, see <a href="https://github.com/expressjs/accepts">accepts</a>.</p>   <h3 id="req.acceptsLanguages">req.acceptsLanguages(lang [, ...])</h3> <p>Returns the first accepted language of the specified languages, based on the request’s <code>Accept-Language</code> HTTP header field. If none of the specified languages is accepted, returns <code>false</code>.</p> <p>For more information, or if you have issues or concerns, see <a href="https://github.com/expressjs/accepts">accepts</a>.</p>   <h3 id="req.get">req.get(field)</h3> <p>Returns the specified HTTP request header field (case-insensitive match). The <code>Referrer</code> and <code>Referer</code> fields are interchangeable.</p> <pre data-language="js">req.get('Content-Type');
// =&gt; "text/plain"

req.get('content-type');
// =&gt; "text/plain"

req.get('Something');
// =&gt; undefined
</pre> <p>Aliased as <code>req.header(field)</code>.</p>   <h3 id="req.is">req.is(type)</h3> <p>Returns <code>true</code> if the incoming request’s “Content-Type” HTTP header field matches the MIME type specified by the <code>type</code> parameter. Returns <code>false</code> otherwise.</p> <pre data-language="js">// With Content-Type: text/html; charset=utf-8
req.is('html');
req.is('text/html');
req.is('text/*');
// =&gt; true

// When Content-Type is application/json
req.is('json');
req.is('application/json');
req.is('application/*');
// =&gt; true

req.is('html');
// =&gt; false
</pre> <p>For more information, or if you have issues or concerns, see <a href="https://github.com/expressjs/type-is">type-is</a>.</p>   <h3 id="req.param">req.param(name [, defaultValue])</h3> <div class="doc-box doc-warn"> <p>Deprecated. Use either <code>req.params</code>, <code>req.body</code> or <code>req.query</code>, as applicable.</p> </div> <p>Returns the value of param <code>name</code> when present.</p> <pre data-language="js">// ?name=tobi
req.param('name')
// =&gt; "tobi"

// POST name=tobi
req.param('name')
// =&gt; "tobi"

// /user/tobi for /user/:name
req.param('name')
// =&gt; "tobi"
</pre> <p>Lookup is performed in the following order:</p> <ul> <li><code>req.params</code></li> <li><code>req.body</code></li> <li><code>req.query</code></li> </ul> <p>Optionally, you can specify <code>defaultValue</code> to set a default value if the parameter is not found in any of the request objects.</p> <div class="doc-box doc-warn"> <p>Direct access to <code>req.body</code>, <code>req.params</code>, and <code>req.query</code> should be favoured for clarity - unless you truly accept input from each object.</p> <p>Body-parsing middleware must be loaded for <code>req.param()</code> to work predictably. Refer <a href="#req.body">req.body</a> for details.</p> </div>   <h3 id="req.range">req.range(size[, options])</h3> <p><code>Range</code> header parser.</p> <p>The <code>size</code> parameter is the maximum size of the resource.</p> <p>The <code>options</code> parameter is an object that can have the following properties.</p> <table> <thead> <tr> <th>Property</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code>combine</code></td> <td>Boolean</td> <td>Specify if overlapping &amp; adjacent ranges should be combined, defaults to <code>false</code>. When <code>true</code>, ranges will be combined and returned as if they were specified that way in the header.</td> </tr> </tbody> </table> <p>An array of ranges will be returned or negative numbers indicating an error parsing.</p> <ul> <li>
<code>-2</code> signals a malformed header string</li> <li>
<code>-1</code> signals an unsatisfiable range</li> </ul> <pre data-language="js">// parse header from request
var range = req.range(1000)

// the type of the range
if (range.type === 'bytes') {
  // the ranges
  range.forEach(function (r) {
    // do something with r.start and r.end
  })
}
</pre>   <h2>Response</h2> <p>The <code>res</code> object represents the HTTP response that an Express app sends when it gets an HTTP request.</p> <p>In this documentation and by convention, the object is always referred to as <code>res</code> (and the HTTP request is <code>req</code>) but its actual name is determined by the parameters to the callback function in which you’re working.</p> <p>For example:</p> <pre data-language="js">app.get('/user/:id', function(req, res){
  res.send('user ' + req.params.id);
});
</pre> <p>But you could just as well have:</p> <pre data-language="js">app.get('/user/:id', function(request, response){
  response.send('user ' + request.params.id);
});
</pre> <p>The <code>res</code> object is an enhanced version of Node’s own response object and supports all <a href="https://nodejs.org/api/http.html#http_class_http_serverresponse">built-in fields and methods</a>.</p> <h3 id="res.properties">Properties</h3>  <h3 id="res.app">res.app</h3> <p>This property holds a reference to the instance of the Express application that is using the middleware.</p> <p><code>res.app</code> is identical to the <a href="#req.app">req.app</a> property in the request object.</p>   <h3 id="res.headersSent">res.headersSent</h3> <p>Boolean property that indicates if the app sent HTTP headers for the response.</p> <pre data-language="js">app.get('/', function (req, res) {
  console.log(res.headersSent); // false
  res.send('OK');
  console.log(res.headersSent); // true
});
</pre>   <h3 id="res.locals">res.locals</h3> <p>An object that contains response local variables scoped to the request, and therefore available only to the view(s) rendered during that request / response cycle (if any). Otherwise, this property is identical to <a href="#app.locals">app.locals</a>.</p> <p>This property is useful for exposing request-level information such as the request path name, authenticated user, user settings, and so on.</p> <pre data-language="js">app.use(function(req, res, next){
  res.locals.user = req.user;
  res.locals.authenticated = ! req.user.anonymous;
  next();
});
</pre>  <h3 id="res.methods">Methods</h3>  <h3 id="res.append">res.append(field [, value])</h3> <div class="doc-box doc-info"> <p><code>res.append()</code> is supported by Express v4.11.0+</p> </div> <p>Appends the specified <code>value</code> to the HTTP response header <code>field</code>. If the header is not already set, it creates the header with the specified value. The <code>value</code> parameter can be a string or an array.</p> <p>Note: calling <code>res.set()</code> after <code>res.append()</code> will reset the previously-set header value.</p> <pre data-language="js">res.append('Link', ['&lt;http://localhost/&gt;', '&lt;http://localhost:3000/&gt;']);
res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
res.append('Warning', '199 Miscellaneous warning');
</pre>   <h3 id="res.attachment">res.attachment([filename])</h3> <p>Sets the HTTP response <code>Content-Disposition</code> header field to “attachment”. If a <code>filename</code> is given, then it sets the Content-Type based on the extension name via <code>res.type()</code>, and sets the <code>Content-Disposition</code> “filename=” parameter.</p> <pre data-language="js">res.attachment();
// Content-Disposition: attachment

res.attachment('path/to/logo.png');
// Content-Disposition: attachment; filename="logo.png"
// Content-Type: image/png
</pre>   <h3 id="res.cookie">res.cookie(name, value [, options])</h3> <p>Sets cookie <code>name</code> to <code>value</code>. The <code>value</code> parameter may be a string or object converted to JSON.</p> <p>The <code>options</code> parameter is an object that can have the following properties.</p> <table> <thead> <tr> <th>Property</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code>domain</code></td> <td>String</td> <td>Domain name for the cookie. Defaults to the domain name of the app.</td> </tr> <tr> <td><code>encode</code></td> <td>Function</td> <td>A synchronous function used for cookie value encoding. Defaults to <code>encodeURIComponent</code>.</td> </tr> <tr> <td><code>expires</code></td> <td>Date</td> <td>Expiry date of the cookie in GMT. If not specified or set to 0, creates a session cookie.</td> </tr> <tr> <td><code>httpOnly</code></td> <td>Boolean</td> <td>Flags the cookie to be accessible only by the web server.</td> </tr> <tr> <td><code>maxAge</code></td> <td>String</td> <td>Convenient option for setting the expiry time relative to the current time in milliseconds.</td> </tr> <tr> <td><code>path</code></td> <td>String</td> <td>Path for the cookie. Defaults to “/”.</td> </tr> <tr> <td><code>secure</code></td> <td>Boolean</td> <td>Marks the cookie to be used with HTTPS only.</td> </tr> <tr> <td><code>signed</code></td> <td>Boolean</td> <td>Indicates if the cookie should be signed.</td> </tr> </tbody> </table> <div class="doc-box doc-notice"> <p>All <code>res.cookie()</code> does is set the HTTP <code>Set-Cookie</code> header with the options provided. Any option not specified defaults to the value stated in <a href="http://tools.ietf.org/html/rfc6265">RFC 6265</a>.</p> </div> <p>For example:</p> <pre data-language="js">res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true });
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
</pre> <p>The <code>encode</code> option allows you to choose the function used for cookie value encoding. Does not support asynchronous functions.</p> <p>Example use case: You need to set a domain-wide cookie for another site in your organization. This other site (not under your administrative control) does not use URI-encoded cookie values.</p> <pre data-language="js">//Default encoding
res.cookie('some_cross_domain_cookie', 'http://mysubdomain.example.com',{domain:'example.com'});
// Result: 'some_cross_domain_cookie=http%3A%2F%2Fmysubdomain.example.com; Domain=example.com; Path=/'

//Custom encoding
res.cookie('some_cross_domain_cookie', 'http://mysubdomain.example.com',{domain:'example.com', encode: String});
// Result: 'some_cross_domain_cookie=http://mysubdomain.example.com; Domain=example.com; Path=/;'
</pre> <p>The <code>maxAge</code> option is a convenience option for setting “expires” relative to the current time in milliseconds. The following is equivalent to the second example above.</p> <pre data-language="js">res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true });
</pre> <p>You can pass an object as the <code>value</code> parameter; it is then serialized as JSON and parsed by <code>bodyParser()</code> middleware.</p> <pre data-language="js">res.cookie('cart', { items: [1,2,3] });
res.cookie('cart', { items: [1,2,3] }, { maxAge: 900000 });
</pre> <p>When using <a href="https://www.npmjs.com/package/cookie-parser">cookie-parser</a> middleware, this method also supports signed cookies. Simply include the <code>signed</code> option set to <code>true</code>. Then <code>res.cookie()</code> will use the secret passed to <code>cookieParser(secret)</code> to sign the value.</p> <pre data-language="js">res.cookie('name', 'tobi', { signed: true });
</pre> <p>Later you may access this value through the <a href="#req.signedCookies">req.signedCookie</a> object.</p>   <h3 id="res.clearCookie">res.clearCookie(name [, options])</h3> <p>Clears the cookie specified by <code>name</code>. For details about the <code>options</code> object, see <a href="#res.cookie">res.cookie()</a>.</p> <pre data-language="js">res.cookie('name', 'tobi', { path: '/admin' });
res.clearCookie('name', { path: '/admin' });
</pre>   <h3 id="res.download">res.download(path [, filename] [, fn])</h3> <p>Transfers the file at <code>path</code> as an “attachment”. Typically, browsers will prompt the user for download. By default, the <code>Content-Disposition</code> header “filename=” parameter is <code>path</code> (this typically appears in the browser dialog). Override this default with the <code>filename</code> parameter.</p> <p>When an error ocurrs or transfer is complete, the method calls the optional callback function <code>fn</code>. This method uses <a href="#res.sendFile">res.sendFile()</a> to transfer the file.</p> <pre data-language="js">res.download('/report-12345.pdf');

res.download('/report-12345.pdf', 'report.pdf');

res.download('/report-12345.pdf', 'report.pdf', function(err){
  if (err) {
    // Handle error, but keep in mind the response may be partially-sent
    // so check res.headersSent
  } else {
    // decrement a download credit, etc.
  }
});
</pre>   <h3 id="res.end">res.end([data] [, encoding])</h3> <p>Ends the response process. This method actually comes from Node core, specifically the <a href="https://nodejs.org/api/http.html#http_response_end_data_encoding_callback">response.end() method of http.ServerResponse</a>.</p> <p>Use to quickly end the response without any data. If you need to respond with data, instead use methods such as <a href="#res.send">res.send()</a> and <a href="#res.json">res.json()</a>.</p> <pre data-language="js">res.end();
res.status(404).end();
</pre>   <h3 id="res.format">res.format(object)</h3> <p>Performs content-negotiation on the <code>Accept</code> HTTP header on the request object, when present. It uses <a href="#req.accepts">req.accepts()</a> to select a handler for the request, based on the acceptable types ordered by their quality values. If the header is not specified, the first callback is invoked. When no match is found, the server responds with 406 “Not Acceptable”, or invokes the <code>default</code> callback.</p> <p>The <code>Content-Type</code> response header is set when a callback is selected. However, you may alter this within the callback using methods such as <code>res.set()</code> or <code>res.type()</code>.</p> <p>The following example would respond with <code>{ "message": "hey" }</code> when the <code>Accept</code> header field is set to “application/json” or “*/json” (however if it is “*/*”, then the response will be “hey”).</p> <pre data-language="js">res.format({
  'text/plain': function(){
    res.send('hey');
  },

  'text/html': function(){
    res.send('&lt;p&gt;hey&lt;/p&gt;');
  },

  'application/json': function(){
    res.send({ message: 'hey' });
  },

  'default': function() {
    // log the request and respond with 406
    res.status(406).send('Not Acceptable');
  }
});
</pre> <p>In addition to canonicalized MIME types, you may also use extension names mapped to these types for a slightly less verbose implementation:</p> <pre data-language="js">res.format({
  text: function(){
    res.send('hey');
  },

  html: function(){
    res.send('&lt;p&gt;hey&lt;/p&gt;');
  },

  json: function(){
    res.send({ message: 'hey' });
  }
});
</pre>   <h3 id="res.get">res.get(field)</h3> <p>Returns the HTTP response header specified by <code>field</code>. The match is case-insensitive.</p> <pre data-language="js">res.get('Content-Type');
// =&gt; "text/plain"
</pre>   <h3 id="res.json">res.json([body])</h3> <p>Sends a JSON response. This method sends a response (with the correct content-type) that is the parameter converted to a JSON string using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify()</a>.</p> <p>The parameter can be any JSON type, including object, array, string, Boolean, or number, and you can also use it to convert other values to JSON, such as <code>null</code>, and <code>undefined</code> (although these are technically not valid JSON).</p> <pre data-language="js">res.json(null);
res.json({ user: 'tobi' });
res.status(500).json({ error: 'message' });
</pre>   <h3 id="res.jsonp">res.jsonp([body])</h3> <p>Sends a JSON response with JSONP support. This method is identical to <code>res.json()</code>, except that it opts-in to JSONP callback support.</p> <pre data-language="js">res.jsonp(null);
// =&gt; null

res.jsonp({ user: 'tobi' });
// =&gt; { "user": "tobi" }

res.status(500).jsonp({ error: 'message' });
// =&gt; { "error": "message" }
</pre> <p>By default, the JSONP callback name is simply <code>callback</code>. Override this with the <a href="#app.settings.table">jsonp callback name</a> setting.</p> <p>The following are some examples of JSONP responses using the same code:</p> <pre data-language="js">// ?callback=foo
res.jsonp({ user: 'tobi' });
// =&gt; foo({ "user": "tobi" })

app.set('jsonp callback name', 'cb');

// ?cb=foo
res.status(500).jsonp({ error: 'message' });
// =&gt; foo({ "error": "message" })
</pre>   <h3 id="res.links">res.links(links)</h3> <p>Joins the <code>links</code> provided as properties of the parameter to populate the response’s <code>Link</code> HTTP header field.</p> <p>For example, the following call:</p> <pre data-language="js">res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
});
</pre> <p>Yields the following results:</p> <pre data-language="js">Link: &lt;http://api.example.com/users?page=2&gt;; rel="next",
      &lt;http://api.example.com/users?page=5&gt;; rel="last"
</pre>   <h3 id="res.location">res.location(path)</h3> <p>Sets the response <code>Location</code> HTTP header to the specified <code>path</code> parameter.</p> <pre data-language="js">res.location('/foo/bar');
res.location('http://example.com');
res.location('back');
</pre> <p>A <code>path</code> value of “back” has a special meaning, it refers to the URL specified in the <code>Referer</code> header of the request. If the <code>Referer</code> header was not specified, it refers to “/”.</p> <div class="doc-box doc-warn"> <p>After encoding the URL, if not encoded already, Express passes the specified URL to the browser in the <code>Location</code> header, without any validation.</p> <p>Browsers take the responsibility of deriving the intended URL from the current URL or the referring URL, and the URL specified in the <code>Location</code> header; and redirect the user accordingly.</p> </div>   <h3 id="res.redirect">res.redirect([status,] path)</h3> <p>Redirects to the URL derived from the specified <code>path</code>, with specified <code>status</code>, a positive integer that corresponds to an <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">HTTP status code</a> . If not specified, <code>status</code> defaults to “302 “Found”.</p> <pre data-language="js">res.redirect('/foo/bar');
res.redirect('http://example.com');
res.redirect(301, 'http://example.com');
res.redirect('../login');
</pre> <p>Redirects can be a fully-qualified URL for redirecting to a different site:</p> <pre data-language="js">res.redirect('http://google.com');
</pre> <p>Redirects can be relative to the root of the host name. For example, if the application is on <code>http://example.com/admin/post/new</code>, the following would redirect to the URL <code>http://example.com/admin</code>:</p> <pre data-language="js">res.redirect('/admin');
</pre> <p>Redirects can be relative to the current URL. For example, from <code>http://example.com/blog/admin/</code> (notice the trailing slash), the following would redirect to the URL <code>http://example.com/blog/admin/post/new</code>.</p> <pre data-language="js">res.redirect('post/new');
</pre> <p>Redirecting to <code>post/new</code> from <code>http://example.com/blog/admin</code> (no trailing slash), will redirect to <code>http://example.com/blog/post/new</code>.</p> <p>If you found the above behavior confusing, think of path segments as directories (with trailing slashes) and files, it will start to make sense.</p> <p>Path-relative redirects are also possible. If you were on <code>http://example.com/admin/post/new</code>, the following would redirect to <code>http//example.com/admin/post</code>:</p> <pre data-language="js">res.redirect('..');
</pre> <p>A <code>back</code> redirection redirects the request back to the <a href="http://en.wikipedia.org/wiki/HTTP_referer">referer</a>, defaulting to <code>/</code> when the referer is missing.</p> <pre data-language="js">res.redirect('back');
</pre>   <h3 id="res.render">res.render(view [, locals] [, callback])</h3> <p>Renders a <code>view</code> and sends the rendered HTML string to the client. Optional parameters:</p> <ul> <li>
<code>locals</code>, an object whose properties define local variables for the view.</li> <li>
<code>callback</code>, a callback function. If provided, the method returns both the possible error and rendered string, but does not perform an automated response. When an error occurs, the method invokes <code>next(err)</code> internally.</li> </ul> <p>The <code>view</code> argument is a string that is the file path of the view file to render. This can be an absolute path, or a path relative to the <code>views</code> setting. If the path does not contain a file extension, then the <code>view engine</code> setting determines the file extension. If the path does contain a file extension, then Express will load the module for the specified template engine (via <code>require()</code>) and render it using the loaded module’s <code>__express</code> function.</p> <p>For more information, see <a href="http://expressjs.com/guide/using-template-engines.html">Using template engines with Express</a>.</p> <p><strong>NOTE:</strong> The <code>view</code> argument performs file system operations like reading a file from disk and evaluating Node.js modules, and as so for security reasons should not contain input from the end-user.</p> <div class="doc-box doc-notice"> <p>The local variable <code>cache</code> enables view caching. Set it to <code>true</code>, to cache the view during development; view caching is enabled in production by default.</p> </div> <pre data-language="js">// send the rendered view to the client
res.render('index');

// if a callback is specified, the rendered HTML string has to be sent explicitly
res.render('index', function(err, html) {
  res.send(html);
});

// pass a local variable to the view
res.render('user', { name: 'Tobi' }, function(err, html) {
  // ...
});
</pre>   <h3 id="res.send">res.send([body])</h3> <p>Sends the HTTP response.</p> <p>The <code>body</code> parameter can be a <code>Buffer</code> object, a <code>String</code>, an object, or an <code>Array</code>. For example:</p> <pre data-language="js">res.send(new Buffer('whoop'));
res.send({ some: 'json' });
res.send('&lt;p&gt;some html&lt;/p&gt;');
res.status(404).send('Sorry, we cannot find that!');
res.status(500).send({ error: 'something blew up' });
</pre> <p>This method performs many useful tasks for simple non-streaming responses: For example, it automatically assigns the <code>Content-Length</code> HTTP response header field (unless previously defined) and provides automatic HEAD and HTTP cache freshness support.</p> <p>When the parameter is a <code>Buffer</code> object, the method sets the <code>Content-Type</code> response header field to “application/octet-stream”, unless previously defined as shown below:</p> <pre data-language="js">res.set('Content-Type', 'text/html');
res.send(new Buffer('&lt;p&gt;some html&lt;/p&gt;'));
</pre> <p>When the parameter is a <code>String</code>, the method sets the <code>Content-Type</code> to “text/html”:</p> <pre data-language="js">res.send('&lt;p&gt;some html&lt;/p&gt;');
</pre> <p>When the parameter is an <code>Array</code> or <code>Object</code>, Express responds with the JSON representation:</p> <pre data-language="js">res.send({ user: 'tobi' });
res.send([1,2,3]);
</pre>   <h3 id="res.sendFile">res.sendFile(path [, options] [, fn])</h3> <div class="doc-box doc-info"> <p><code>res.sendFile()</code> is supported by Express v4.8.0 onwards.</p> </div> <p>Transfers the file at the given <code>path</code>. Sets the <code>Content-Type</code> response HTTP header field based on the filename’s extension. Unless the <code>root</code> option is set in the options object, <code>path</code> must be an absolute path to the file.</p> <p>The following table provides details on the <code>options</code> parameter.</p> <div class="table-scroller"> <table> <thead> <tr> <th>Property</th> <th>Description</th> <th>Default</th> <th>Availability</th> </tr> </thead> <tbody> <tr> <td><code>maxAge</code></td> <td>Sets the max-age property of the <code>Cache-Control</code> header in milliseconds or a string in <a href="https://www.npmjs.org/package/ms">ms format</a>
</td> <td>0</td> <td> </td> </tr> <tr> <td><code>root</code></td> <td>Root directory for relative filenames.</td> <td> </td> <td> </td> </tr> <tr> <td><code>lastModified</code></td> <td>Sets the <code>Last-Modified</code> header to the last modified date of the file on the OS. Set <code>false</code> to disable it.</td> <td>Enabled</td> <td>4.9.0+</td> </tr> <tr> <td><code>headers</code></td> <td>Object containing HTTP headers to serve with the file.</td> <td> </td> <td> </td> </tr> <tr> <td><code>dotfiles</code></td> <td>Option for serving dotfiles. Possible values are “allow”, “deny”, “ignore”.</td> <td>“ignore”</td> <td> </td> </tr> <tr> <td><code>acceptRanges</code></td> <td>Enable or disable accepting ranged requests.</td> <td><code>true</code></td> <td>4.14+</td> </tr> <tr> <td><code>cacheControl</code></td> <td>Enable or disable setting <code>Cache-Control</code> response header.</td> <td><code>true</code></td> <td>4.14+</td> </tr> </tbody> </table> </div> <p>The method invokes the callback function <code>fn(err)</code> when the transfer is complete or when an error occurs. If the callback function is specified and an error occurs, the callback function must explicitly handle the response process either by ending the request-response cycle, or by passing control to the next route.</p> <p>Here is an example of using <code>res.sendFile</code> with all its arguments.</p> <pre data-language="js">app.get('/file/:name', function (req, res, next) {

  var options = {
    root: __dirname + '/public/',
    dotfiles: 'deny',
    headers: {
        'x-timestamp': Date.now(),
        'x-sent': true
    }
  };

  var fileName = req.params.name;
  res.sendFile(fileName, options, function (err) {
    if (err) {
      console.log(err);
      res.status(err.status).end();
    }
    else {
      console.log('Sent:', fileName);
    }
  });

});
</pre> <p>The following example illustrates using <code>res.sendFile</code> to provide fine-grained support for serving files:</p> <pre data-language="js">app.get('/user/:uid/photos/:file', function(req, res){
  var uid = req.params.uid
    , file = req.params.file;

  req.user.mayViewFilesFrom(uid, function(yes){
    if (yes) {
      res.sendFile('/uploads/' + uid + '/' + file);
    } else {
      res.status(403).send('Sorry! you cant see that.');
    }
  });
});
</pre> <p>For more information, or if you have issues or concerns, see <a href="https://github.com/pillarjs/send">send</a>.</p>   <h3 id="res.sendStatus">res.sendStatus(statusCode)</h3> <p>Sets the response HTTP status code to <code>statusCode</code> and send its string representation as the response body.</p> <pre data-language="js">res.sendStatus(200); // equivalent to res.status(200).send('OK')
res.sendStatus(403); // equivalent to res.status(403).send('Forbidden')
res.sendStatus(404); // equivalent to res.status(404).send('Not Found')
res.sendStatus(500); // equivalent to res.status(500).send('Internal Server Error')
</pre> <p>If an unsupported status code is specified, the HTTP status is still set to <code>statusCode</code> and the string version of the code is sent as the response body.</p> <pre data-language="js">res.sendStatus(2000); // equivalent to res.status(2000).send('2000')
</pre> <p><a href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">More about HTTP Status Codes</a></p>   <h3 id="res.set">res.set(field [, value])</h3> <p>Sets the response’s HTTP header <code>field</code> to <code>value</code>. To set multiple fields at once, pass an object as the parameter.</p> <pre data-language="js">res.set('Content-Type', 'text/plain');

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  'ETag': '12345'
});
</pre> <p>Aliased as <code>res.header(field [, value])</code>.</p>   <h3 id="res.status">res.status(code)</h3> <p>Sets the HTTP status for the response. It is a chainable alias of Node’s <a href="http://nodejs.org/api/http.html#http_response_statuscode">response.statusCode</a>.</p> <pre data-language="js">res.status(403).end();
res.status(400).send('Bad Request');
res.status(404).sendFile('/absolute/path/to/404.png');
</pre>   <h3 id="res.type">res.type(type)</h3> <p>Sets the <code>Content-Type</code> HTTP header to the MIME type as determined by <a href="https://github.com/broofa/node-mime#mimelookuppath">mime.lookup()</a> for the specified <code>type</code>. If <code>type</code> contains the “/” character, then it sets the <code>Content-Type</code> to <code>type</code>.</p> <pre data-language="js">res.type('.html');              // =&gt; 'text/html'
res.type('html');               // =&gt; 'text/html'
res.type('json');               // =&gt; 'application/json'
res.type('application/json');   // =&gt; 'application/json'
res.type('png');                // =&gt; image/png:
</pre>   <h3 id="res.vary">res.vary(field)</h3> <p>Adds the field to the <code>Vary</code> response header, if it is not there already.</p> <pre data-language="js">res.vary('User-Agent').render('docs');
</pre>   <h2>Router</h2>  <p>A <code>router</code> object is an isolated instance of middleware and routes. You can think of it as a “mini-application,” capable only of performing middleware and routing functions. Every Express application has a built-in app router.</p> <p>A router behaves like middleware itself, so you can use it as an argument to <a href="#app.use">app.use()</a> or as the argument to another router’s <a href="#router.use">use()</a> method.</p> <p>The top-level <code>express</code> object has a <a href="#express.router">Router()</a> method that creates a new <code>router</code> object.</p> <p>Once you’ve created a router object, you can add middleware and HTTP method routes (such as <code>get</code>, <code>put</code>, <code>post</code>, and so on) to it just like an application. For example:</p> <pre data-language="js">// invoked for any requests passed to this router
router.use(function(req, res, next) {
  // .. some logic here .. like any other middleware
  next();
});

// will handle any request that ends in /events
// depends on where the router is "use()'d"
router.get('/events', function(req, res, next) {
  // ..
});
</pre> <p>You can then use a router for a particular root URL in this way separating your routes into files or even mini-apps.</p> <pre data-language="js">// only requests to /calendar/* will be sent to our "router"
app.use('/calendar', router);
</pre>  <h3 id="router.methods">Methods</h3>  <h3 id="router.all">router.all(path, [callback, ...] callback)</h3> <p>This method is just like the <code>router.METHOD()</code> methods, except that it matches all HTTP methods (verbs).</p> <p>This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches. For example, if you placed the following route at the top of all other route definitions, it would require that all routes from that point on would require authentication, and automatically load a user. Keep in mind that these callbacks do not have to act as end points; <code>loadUser</code> can perform a task, then call <code>next()</code> to continue matching subsequent routes.</p> <pre data-language="js">router.all('*', requireAuthentication, loadUser);
</pre> <p>Or the equivalent:</p> <pre data-language="js">router.all('*', requireAuthentication)
router.all('*', loadUser);
</pre> <p>Another example of this is white-listed “global” functionality. Here the example is much like before, but it only restricts paths prefixed with “/api”:</p> <pre data-language="js">router.all('/api/*', requireAuthentication);
</pre>   <h3 id="router.METHOD">router.METHOD(path, [callback, ...] callback)</h3> <p>The <code>router.METHOD()</code> methods provide the routing functionality in Express, where METHOD is one of the HTTP methods, such as GET, PUT, POST, and so on, in lowercase. Thus, the actual methods are <code>router.get()</code>, <code>router.post()</code>, <code>router.put()</code>, and so on.</p> <p>You can provide multiple callbacks, and all are treated equally, and behave just like middleware, except that these callbacks may invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to perform pre-conditions on a route then pass control to subsequent routes when there is no reason to proceed with the route matched.</p> <p>The following snippet illustrates the most simple route definition possible. Express translates the path strings to regular expressions, used internally to match incoming requests. Query strings are <em>not</em> considered when performing these matches, for example “GET /” would match the following route, as would “GET /?name=tobi”.</p> <pre data-language="js">router.get('/', function(req, res){
  res.send('hello world');
});
</pre> <p>You can also use regular expressions—useful if you have very specific constraints, for example the following would match “GET /commits/71dbb9c” as well as “GET /commits/71dbb9c..4c084f9”.</p> <pre data-language="js">router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
  var from = req.params[0];
  var to = req.params[1] || 'HEAD';
  res.send('commit range ' + from + '..' + to);
});
</pre>   <h3 id="router.param">router.param(name, callback)</h3> <p>Adds callback triggers to route parameters, where <code>name</code> is the name of the parameter and <code>callback</code> is the callback function. Although <code>name</code> is technically optional, using this method without it is deprecated starting with Express v4.11.0 (see below).</p> <p>The parameters of the callback function are:</p> <ul> <li>
<code>req</code>, the request object.</li> <li>
<code>res</code>, the response object.</li> <li>
<code>next</code>, indicating the next middleware function.</li> <li>The value of the <code>name</code> parameter.</li> <li>The name of the parameter.</li> </ul> <div class="doc-box doc-info"> <p>Unlike <code>app.param()</code>, <code>router.param()</code> does not accept an array of route parameters.</p> </div> <p>For example, when <code>:user</code> is present in a route path, you may map user loading logic to automatically provide <code>req.user</code> to the route, or perform validations on the parameter input.</p> <pre data-language="js">router.param('user', function(req, res, next, id) {

  // try to get the user details from the User model and attach it to the request object
  User.find(id, function(err, user) {
    if (err) {
      next(err);
    } else if (user) {
      req.user = user;
      next();
    } else {
      next(new Error('failed to load user'));
    }
  });
});
</pre> <p>Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers. Hence, param callbacks defined on <code>router</code> will be triggered only by route parameters defined on <code>router</code> routes.</p> <p>A param callback will be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.</p> <pre data-language="js">router.param('id', function (req, res, next, id) {
  console.log('CALLED ONLY ONCE');
  next();
});

router.get('/user/:id', function (req, res, next) {
  console.log('although this matches');
  next();
});

router.get('/user/:id', function (req, res) {
  console.log('and this matches too');
  res.end();
});
</pre> <p>On <code>GET /user/42</code>, the following is printed:</p> <pre data-language="sh">CALLED ONLY ONCE
although this matches
and this matches too
</pre> <div class="doc-box doc-warn"> <p>The following section describes <code>router.param(callback)</code>, which is deprecated as of v4.11.0.</p> </div> <p>The behavior of the <code>router.param(name, callback)</code> method can be altered entirely by passing only a function to <code>router.param()</code>. This function is a custom implementation of how <code>router.param(name, callback)</code> should behave - it accepts two parameters and must return a middleware.</p> <p>The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation.</p> <p>The middleware returned by the function decides the behavior of what happens when a URL parameter is captured.</p> <p>In this example, the <code>router.param(name, callback)</code> signature is modified to <code>router.param(name, accessId)</code>. Instead of accepting a name and a callback, <code>router.param()</code> will now accept a name and a number.</p> <pre data-language="js">var express = require('express');
var app = express();
var router = express.Router();

// customizing the behavior of router.param()
router.param(function(param, option) {
  return function (req, res, next, val) {
    if (val == option) {
      next();
    }
    else {
      res.sendStatus(403);
    }
  }
});

// using the customized router.param()
router.param('id', 1337);

// route to trigger the capture
router.get('/user/:id', function (req, res) {
  res.send('OK');
});

app.use(router);

app.listen(3000, function () {
  console.log('Ready');
});
</pre> <p>In this example, the <code>router.param(name, callback)</code> signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id.</p> <pre data-language="js">router.param(function(param, validator) {
  return function (req, res, next, val) {
    if (validator(val)) {
      next();
    }
    else {
      res.sendStatus(403);
    }
  }
});

router.param('id', function (candidate) {
  return !isNaN(parseFloat(candidate)) &amp;&amp; isFinite(candidate);
});
</pre>   <h3 id="router.route">router.route(path)</h3> <p>Returns an instance of a single route which you can then use to handle HTTP verbs with optional middleware. Use <code>router.route()</code> to avoid duplicate route naming and thus typo errors.</p> <p>Building on the <code>router.param()</code> example above, the following code shows how to use <code>router.route()</code> to specify various HTTP method handlers.</p> <pre data-language="js">var router = express.Router();

router.param('user_id', function(req, res, next, id) {
  // sample user, would actually fetch from DB, etc...
  req.user = {
    id: id,
    name: 'TJ'
  };
  next();
});

router.route('/users/:user_id')
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
  next();
})
.get(function(req, res, next) {
  res.json(req.user);
})
.put(function(req, res, next) {
  // just an example of maybe updating the user
  req.user.name = req.params.name;
  // save user ... etc
  res.json(req.user);
})
.post(function(req, res, next) {
  next(new Error('not implemented'));
})
.delete(function(req, res, next) {
  next(new Error('not implemented'));
});
</pre> <p>This approach re-uses the single <code>/users/:user_id</code> path and add handlers for various HTTP methods.</p> <div class="doc-box doc-info"> <p>NOTE: When you use <code>router.route()</code>, middleware ordering is based on when the <em>route</em> is created, not when method handlers are added to the route. For this purpose, you can consider method handlers to belong to the route to which they were added.</p> </div>   <h3 id="router.use">router.use([path], [function, ...] function)</h3> <p>Uses the specified middleware function or functions, with optional mount path <code>path</code>, that defaults to “/”.</p> <p>This method is similar to <a href="#app.use">app.use()</a>. A simple example and use case is described below. See <a href="#app.use">app.use()</a> for more information.</p> <p>Middleware is like a plumbing pipe: requests start at the first middleware function defined and work their way “down” the middleware stack processing for each path they match.</p> <pre data-language="js">var express = require('express');
var app = express();
var router = express.Router();

// simple logger for this router's requests
// all requests to this router will first hit this middleware
router.use(function(req, res, next) {
  console.log('%s %s %s', req.method, req.url, req.path);
  next();
});

// this will only be invoked if the path starts with /bar from the mount point
router.use('/bar', function(req, res, next) {
  // ... maybe some additional /bar logging ...
  next();
});

// always invoked
router.use(function(req, res, next) {
  res.send('Hello World');
});

app.use('/foo', router);

app.listen(3000);
</pre> <p>The “mount” path is stripped and is <em>not</em> visible to the middleware function. The main effect of this feature is that a mounted middleware function may operate without code changes regardless of its “prefix” pathname.</p> <p>The order in which you define middleware with <code>router.use()</code> is very important. They are invoked sequentially, thus the order defines middleware precedence. For example, usually a logger is the very first middleware you would use, so that every request gets logged.</p> <pre data-language="js">var logger = require('morgan');

router.use(logger());
router.use(express.static(__dirname + '/public'));
router.use(function(req, res){
  res.send('Hello');
});
</pre> <p>Now suppose you wanted to ignore logging requests for static files, but to continue logging routes and middleware defined after <code>logger()</code>. You would simply move the call to <code>express.static()</code> to the top, before adding the logger middleware:</p> <pre data-language="js">router.use(express.static(__dirname + '/public'));
router.use(logger());
router.use(function(req, res){
  res.send('Hello');
});
</pre> <p>Another example is serving files from multiple directories, giving precedence to “./public” over the others:</p> <pre data-language="js">app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads'));
</pre> <p>The <code>router.use()</code> method also supports named parameters so that your mount points for other routers can benefit from preloading using named parameters.</p> <p><strong>NOTE</strong>: Although these middleware functions are added via a particular router, <em>when</em> they run is defined by the path they are attached to (not the router). Therefore, middleware added via one router may run for other routers if its routes match. For example, this code shows two different routers mounted on the same path:</p> <pre data-language="js">var authRouter = express.Router();
var openRouter = express.Router();

authRouter.use(require('./authenticate').basic(usersdb));

authRouter.get('/:user_id/edit', function(req, res, next) { 
  // ... Edit user UI ...  
});
openRouter.get('/', function(req, res, next) { 
  // ... List users ... 
})
openRouter.get('/:user_id', function(req, res, next) { 
  // ... View user ... 
})

app.use('/users', authRouter);
app.use('/users', openRouter);
</pre> <p>Even though the authentication middleware was added via the <code>authRouter</code> it will run on the routes defined by the <code>openRouter</code> as well since both routers were mounted on <code>/users</code>. To avoid this behavior, use different paths for each router.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016 StrongLoop, IBM, and other expressjs.com contributors.<br>
    <a href="http://expressjs.com/en/4x/api.html" class="_attribution-link">http://expressjs.com/en/4x/api.html</a>
  </p>
</div>
