{"index":"<h1>Elixir</h1> <h1>  API Reference </h1> <ul class=\"summary-links\"> <li><a href=\"#modules\">Modules</a></li> <li><a href=\"#exceptions\">Exceptions</a></li> <li><a href=\"#protocols\">Protocols</a></li> </ul>  <h1 class=\"section-heading\">Modules</h1> <dl class=\"summary\">  <dt class=\"summary-signature\"><a href=\"elixir/access\">Access</a></dt> <dd class=\"summary-synopsis\">\n<p>Key-based access to data structures using the <code class=\"inline\">data[key]</code> syntax</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/agent\">Agent</a></dt> <dd class=\"summary-synopsis\">\n<p>Agents are a simple abstraction around state</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/application\">Application</a></dt> <dd class=\"summary-synopsis\">\n<p>A module for working with applications and defining application callbacks</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/atom\">Atom</a></dt> <dd class=\"summary-synopsis\">\n<p>Convenience functions for working with atoms</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/base\">Base</a></dt> <dd class=\"summary-synopsis\">\n<p>This module provides data encoding and decoding functions according to <a href=\"http://tools.ietf.org/html/rfc4648\">RFC 4648</a></p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/behaviour\">Behaviour</a></dt> <dd class=\"summary-synopsis\">\n<p>This module has been deprecated</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/bitwise\">Bitwise</a></dt> <dd class=\"summary-synopsis\">\n<p>A set of macros that perform calculations on bits</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/calendar\">Calendar</a></dt> <dd class=\"summary-synopsis\">\n<p>This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/calendar.iso\">Calendar.ISO</a></dt> <dd class=\"summary-synopsis\">\n<p>A calendar implementation that follows to ISO8601</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/code\">Code</a></dt> <dd class=\"summary-synopsis\">\n<p>Utilities for managing code compilation, code evaluation and code loading</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/date\">Date</a></dt> <dd class=\"summary-synopsis\">\n<p>A Date struct and functions</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/datetime\">DateTime</a></dt> <dd class=\"summary-synopsis\">\n<p>A datetime implementation with a time zone</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/dict\">Dict</a></dt> <dd class=\"summary-synopsis\">\n<p>WARNING: this module is deprecated</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/enum\">Enum</a></dt> <dd class=\"summary-synopsis\">\n<p>Provides a set of algorithms that enumerate over enumerables according to the <a href=\"elixir/enumerable\"><code class=\"inline\">Enumerable</code></a> protocol</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/exception\">Exception</a></dt> <dd class=\"summary-synopsis\">\n<p>Functions to format throw/catch/exit and exceptions</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/file\">File</a></dt> <dd class=\"summary-synopsis\">\n<p>This module contains functions to manipulate files</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/file.stat\">File.Stat</a></dt> <dd class=\"summary-synopsis\">\n<p>A struct that holds file information</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/file.stream\">File.Stream</a></dt> <dd class=\"summary-synopsis\">\n<p>Defines a <a href=\"elixir/file.stream#content\"><code class=\"inline\">File.Stream</code></a> struct returned by <a href=\"elixir/file#stream!/3\"><code class=\"inline\">File.stream!/3</code></a></p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/float\">Float</a></dt> <dd class=\"summary-synopsis\">\n<p>Functions for working with floating point numbers</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/genevent\">GenEvent</a></dt> <dd class=\"summary-synopsis\">\n<p>A behaviour module for implementing event handling functionality</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/genevent.stream\">GenEvent.Stream</a></dt> <dd class=\"summary-synopsis\">\n<p>Defines a <a href=\"elixir/genevent\"><code class=\"inline\">GenEvent</code></a> stream</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/genserver\">GenServer</a></dt> <dd class=\"summary-synopsis\">\n<p>A behaviour module for implementing the server of a client-server relation</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/hashdict\">HashDict</a></dt> <dd class=\"summary-synopsis\">\n<p>WARNING: this module is deprecated</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/hashset\">HashSet</a></dt> <dd class=\"summary-synopsis\">\n<p>WARNING: this module is deprecated</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/io\">IO</a></dt> <dd class=\"summary-synopsis\">\n<p>Functions handling input/output (IO)</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/io.ansi\">IO.ANSI</a></dt> <dd class=\"summary-synopsis\">\n<p>Functionality to render ANSI escape sequences</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/io.stream\">IO.Stream</a></dt> <dd class=\"summary-synopsis\">\n<p>Defines an <a href=\"elixir/io.stream#content\"><code class=\"inline\">IO.Stream</code></a> struct returned by <a href=\"elixir/io#stream/2\"><code class=\"inline\">IO.stream/2</code></a> and <a href=\"elixir/io#binstream/2\"><code class=\"inline\">IO.binstream/2</code></a></p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/inspect.algebra\">Inspect.Algebra</a></dt> <dd class=\"summary-synopsis\">\n<p>A set of functions for creating and manipulating algebra documents</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/inspect.opts\">Inspect.Opts</a></dt> <dd class=\"summary-synopsis\">\n<p>Defines the Inspect.Opts used by the Inspect protocol</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/integer\">Integer</a></dt> <dd class=\"summary-synopsis\">\n<p>Functions for working with integers</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/kernel\">Kernel</a></dt> <dd class=\"summary-synopsis\">\n<p>Provides the default macros and functions Elixir imports into your environment</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/kernel.parallelcompiler\">Kernel.ParallelCompiler</a></dt> <dd class=\"summary-synopsis\">\n<p>A module responsible for compiling files in parallel</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/kernel.parallelrequire\">Kernel.ParallelRequire</a></dt> <dd class=\"summary-synopsis\">\n<p>A module responsible for requiring files in parallel</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/kernel.specialforms\">Kernel.SpecialForms</a></dt> <dd class=\"summary-synopsis\">\n<p>Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/keyword\">Keyword</a></dt> <dd class=\"summary-synopsis\">\n<p>A set of functions for working with keywords</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/list\">List</a></dt> <dd class=\"summary-synopsis\">\n<p>Specialized functions that only work on lists</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/macro\">Macro</a></dt> <dd class=\"summary-synopsis\">\n<p>Conveniences for working with macros</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/macro.env\">Macro.Env</a></dt> <dd class=\"summary-synopsis\">\n<p>A struct that holds compile time environment information</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/map\">Map</a></dt> <dd class=\"summary-synopsis\">\n<p>A set of functions for working with maps</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/mapset\">MapSet</a></dt> <dd class=\"summary-synopsis\">\n<p>A set of functions for working with sets</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/module\">Module</a></dt> <dd class=\"summary-synopsis\">\n<p>Provides functions to deal with modules during compilation time</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/naivedatetime\">NaiveDateTime</a></dt> <dd class=\"summary-synopsis\">\n<p>A NaiveDateTime struct (without a time zone) and functions</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/node\">Node</a></dt> <dd class=\"summary-synopsis\">\n<p>Functions related to VM nodes</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/optionparser\">OptionParser</a></dt> <dd class=\"summary-synopsis\">\n<p>This module contains functions to parse command line options</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/path\">Path</a></dt> <dd class=\"summary-synopsis\">\n<p>This module provides conveniences for manipulating or retrieving file system paths</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/port\">Port</a></dt> <dd class=\"summary-synopsis\">\n<p>Functions related to Erlang ports</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/process\">Process</a></dt> <dd class=\"summary-synopsis\">\n<p>Conveniences for working with processes and the process dictionary</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/protocol\">Protocol</a></dt> <dd class=\"summary-synopsis\">\n<p>Functions for working with protocols</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/range\">Range</a></dt> <dd class=\"summary-synopsis\">\n<p>Defines a range</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/record\">Record</a></dt> <dd class=\"summary-synopsis\">\n<p>Module to work with, define and import records</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/regex\">Regex</a></dt> <dd class=\"summary-synopsis\">\n<p>Provides regular expressions for Elixir. Built on top of Erlang’s <code class=\"inline\">:re</code> module</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/set\">Set</a></dt> <dd class=\"summary-synopsis\">\n<p>WARNING: this module is deprecated</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/stream\">Stream</a></dt> <dd class=\"summary-synopsis\">\n<p>Module for creating and composing streams</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/string\">String</a></dt> <dd class=\"summary-synopsis\">\n<p>A String in Elixir is a UTF-8 encoded binary</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/stringio\">StringIO</a></dt> <dd class=\"summary-synopsis\">\n<p>Controls an IO device process that wraps a string</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/supervisor\">Supervisor</a></dt> <dd class=\"summary-synopsis\">\n<p>A behaviour module for implementing supervision functionality</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/supervisor.spec\">Supervisor.Spec</a></dt> <dd class=\"summary-synopsis\">\n<p>Convenience functions for defining supervisor specifications</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/system\">System</a></dt> <dd class=\"summary-synopsis\">\n<p>The <a href=\"elixir/system#content\"><code class=\"inline\">System</code></a> module provides functions that interact directly with the VM or the host system</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/task\">Task</a></dt> <dd class=\"summary-synopsis\">\n<p>Conveniences for spawning and awaiting tasks</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/task.supervisor\">Task.Supervisor</a></dt> <dd class=\"summary-synopsis\">\n<p>A task supervisor</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/time\">Time</a></dt> <dd class=\"summary-synopsis\">\n<p>A Time struct and functions</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/tuple\">Tuple</a></dt> <dd class=\"summary-synopsis\">\n<p>Functions for working with tuples</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/uri\">URI</a></dt> <dd class=\"summary-synopsis\">\n<p>Utilities for working with URIs</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/version\">Version</a></dt> <dd class=\"summary-synopsis\">\n<p>Functions for parsing and matching versions against requirements</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/version.requirement\">Version.Requirement</a></dt>  </dl>   <h1 class=\"section-heading\">Exceptions</h1> <dl class=\"summary\">  <dt class=\"summary-signature\"><a href=\"elixir/argumenterror\">ArgumentError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/arithmeticerror\">ArithmeticError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/badarityerror\">BadArityError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/badfunctionerror\">BadFunctionError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/badmaperror\">BadMapError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/badstructerror\">BadStructError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/caseclauseerror\">CaseClauseError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/code.loaderror\">Code.LoadError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/compileerror\">CompileError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/condclauseerror\">CondClauseError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/enum.emptyerror\">Enum.EmptyError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/enum.outofboundserror\">Enum.OutOfBoundsError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/erlangerror\">ErlangError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/file.copyerror\">File.CopyError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/file.error\">File.Error</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/functionclauseerror\">FunctionClauseError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/io.streamerror\">IO.StreamError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/inspect.error\">Inspect.Error</a></dt> <dd class=\"summary-synopsis\">\n<p>Raised when a struct cannot be inspected</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/keyerror\">KeyError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/matcherror\">MatchError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/optionparser.parseerror\">OptionParser.ParseError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/protocol.undefinederror\">Protocol.UndefinedError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/regex.compileerror\">Regex.CompileError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/runtimeerror\">RuntimeError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/syntaxerror\">SyntaxError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/systemlimiterror\">SystemLimitError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/tokenmissingerror\">TokenMissingError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/tryclauseerror\">TryClauseError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/undefinedfunctionerror\">UndefinedFunctionError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/unicodeconversionerror\">UnicodeConversionError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/version.invalidrequirementerror\">Version.InvalidRequirementError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/version.invalidversionerror\">Version.InvalidVersionError</a></dt>   <dt class=\"summary-signature\"><a href=\"elixir/withclauseerror\">WithClauseError</a></dt>  </dl>   <h1 class=\"section-heading\">Protocols</h1> <dl class=\"summary\">  <dt class=\"summary-signature\"><a href=\"elixir/collectable\">Collectable</a></dt> <dd class=\"summary-synopsis\">\n<p>A protocol to traverse data structures</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/enumerable\">Enumerable</a></dt> <dd class=\"summary-synopsis\">\n<p>Enumerable protocol used by <a href=\"elixir/enum\"><code class=\"inline\">Enum</code></a> and <a href=\"elixir/stream\"><code class=\"inline\">Stream</code></a> modules</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/inspect\">Inspect</a></dt> <dd class=\"summary-synopsis\">\n<p>The <a href=\"elixir/inspect#content\"><code class=\"inline\">Inspect</code></a> protocol is responsible for converting any Elixir data structure into an algebra document. This document is then formatted, either in pretty printing format or a regular one</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/list.chars\">List.Chars</a></dt> <dd class=\"summary-synopsis\">\n<p>The List.Chars protocol is responsible for converting a structure to a list (only if applicable). The only function required to be implemented is <code class=\"inline\">to_charlist</code> which does the conversion</p> </dd>   <dt class=\"summary-signature\"><a href=\"elixir/string.chars\">String.Chars</a></dt> <dd class=\"summary-synopsis\">\n<p>The <a href=\"elixir/string.chars#content\"><code class=\"inline\">String.Chars</code></a> protocol is responsible for converting a structure to a Binary (only if applicable). The only function required to be implemented is <code class=\"inline\">to_string</code> which does the conversion</p> </dd>  </dl><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/api-reference.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/api-reference.html</a>\n  </p>\n</div>\n","eex/eex":"<h1>  EEx  </h1>  <p>EEx stands for Embedded Elixir. It allows you to embed Elixir code inside a string in a robust way.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; EEx.eval_string \"foo &lt;%= bar %&gt;\", [bar: \"baz\"]\n\"foo baz\"</code></pre> <h2 id=\"module-api\" class=\"section-heading\">  API </h2> <p>This module provides 3 main APIs for you to use:</p> <ol> <li>\n<p>Evaluate a string (<code class=\"inline\">eval_string</code>) or a file (<code class=\"inline\">eval_file</code>) directly. This is the simplest API to use but also the slowest, since the code is evaluated and not compiled before.</p> </li> <li>\n<p>Define a function from a string (<code class=\"inline\">function_from_string</code>) or a file (<code class=\"inline\">function_from_file</code>). This allows you to embed the template as a function inside a module which will then be compiled. This is the preferred API if you have access to the template at compilation time.</p> </li> <li>Compile a string (<code class=\"inline\">compile_string</code>) or a file (<code class=\"inline\">compile_file</code>) into Elixir syntax tree. This is the API used by both functions above and is available to you if you want to provide your own ways of handling the compiled template. </li> </ol> <h2 id=\"module-options\" class=\"section-heading\">  Options </h2> <p>All functions in this module accept EEx-related options. They are:</p> <ul> <li>\n<code class=\"inline\">:line</code> - the line to be used as the template start. Defaults to 1. </li> <li>\n<code class=\"inline\">:file</code> - the file to be used in the template. Defaults to the given file the template is read from or to “nofile” when compiling from a string. </li> <li>\n<code class=\"inline\">:engine</code> - the EEx engine to be used for compilation. </li> <li>\n<code class=\"inline\">:trim</code> - trims whitespace left/right of quotation tags </li> </ul> <h2 id=\"module-engine\" class=\"section-heading\">  Engine </h2> <p>EEx has the concept of engines which allows you to modify or transform the code extracted from the given string or file.</p> <p>By default, <a href=\"eex#content\"><code class=\"inline\">EEx</code></a> uses the <a href=\"eex.smartengine\"><code class=\"inline\">EEx.SmartEngine</code></a> that provides some conveniences on top of the simple <a href=\"eex.engine\"><code class=\"inline\">EEx.Engine</code></a>.</p> <h3>Tags</h3> <p><a href=\"eex.smartengine\"><code class=\"inline\">EEx.SmartEngine</code></a> supports the following tags:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;% Elixir expression - inline with output %&gt;\n&lt;%= Elixir expression - replace with result %&gt;\n&lt;%% EEx quotation - returns the contents inside %&gt;\n&lt;%# Comments - they are discarded from source %&gt;</code></pre> <p>All expressions that output something to the template <strong>must</strong> use the equals sign (<code class=\"inline\">=</code>). Since everything in Elixir is an expression, there are no exceptions for this rule. For example, while some template languages would special-case <code class=\"inline\">if/2</code> clauses, they are treated the same in EEx and also require <code class=\"inline\">=</code> in order to have their result printed:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= if true do %&gt;\n  It is obviously true\n&lt;% else %&gt;\n  This will never appear\n&lt;% end %&gt;</code></pre> <p>Notice that different engines may have different rules for each tag. Other tags may be added in future versions.</p> <h3>Macros</h3> <p><a href=\"eex.smartengine\"><code class=\"inline\">EEx.SmartEngine</code></a> also adds some macros to your template. An example is the <code class=\"inline\">@</code> macro which allows easy data access in a template:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; EEx.eval_string \"&lt;%= @foo %&gt;\", assigns: [foo: 1]\n\"1\"</code></pre> <p>In other words, <code class=\"inline\">&lt;%= @foo %&gt;</code> translates to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;%= {:ok, v} = Access.fetch(assigns, :foo); v %&gt;</code></pre> <p>The <code class=\"inline\">assigns</code> extension is useful when the number of variables required by the template is not specified at compilation time.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#compile_file/2\">compile_file(filename, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets a <code class=\"inline\">filename</code> and generate a quoted expression that can be evaluated by Elixir or compiled to a function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compile_string/2\">compile_string(source, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets a string <code class=\"inline\">source</code> and generate a quoted expression that can be evaluated by Elixir or compiled to a function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#eval_file/3\">eval_file(filename, bindings \\\\ [], options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets a <code class=\"inline\">filename</code> and evaluate the values using the <code class=\"inline\">bindings</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#eval_string/3\">eval_string(source, bindings \\\\ [], options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets a string <code class=\"inline\">source</code> and evaluate the values using the <code class=\"inline\">bindings</code></p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#function_from_file/5\">function_from_file(kind, name, file, args \\\\ [], options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a function definition from the file contents</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#function_from_string/5\">function_from_string(kind, name, source, args \\\\ [], options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates a function definition from the string</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"compile_file/2\">  <span class=\"signature\">compile_file(filename, options \\\\ [])</span>  </h3>  <p>Gets a <code class=\"inline\">filename</code> and generate a quoted expression that can be evaluated by Elixir or compiled to a function.</p>    <h3 class=\"detail-header function\" id=\"compile_string/2\">  <span class=\"signature\">compile_string(source, options \\\\ [])</span>  </h3>  <p>Gets a string <code class=\"inline\">source</code> and generate a quoted expression that can be evaluated by Elixir or compiled to a function.</p>    <h3 class=\"detail-header function\" id=\"eval_file/3\">  <span class=\"signature\">eval_file(filename, bindings \\\\ [], options \\\\ [])</span>  </h3>  <p>Gets a <code class=\"inline\">filename</code> and evaluate the values using the <code class=\"inline\">bindings</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># sample.eex\nfoo &lt;%= bar %&gt;\n\n# iex\nEEx.eval_file \"sample.eex\", [bar: \"baz\"] #=&gt; \"foo baz\"</code></pre>    <h3 class=\"detail-header function\" id=\"eval_string/3\">  <span class=\"signature\">eval_string(source, bindings \\\\ [], options \\\\ [])</span>  </h3>  <p>Gets a string <code class=\"inline\">source</code> and evaluate the values using the <code class=\"inline\">bindings</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; EEx.eval_string \"foo &lt;%= bar %&gt;\", [bar: \"baz\"]\n\"foo baz\"</code></pre>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"function_from_file/5\">  <span class=\"signature\">function_from_file(kind, name, file, args \\\\ [], options \\\\ [])</span>  </h3>  <p>Generates a function definition from the file contents.</p> <p>The kind (<code class=\"inline\">:def</code> or <code class=\"inline\">:defp</code>) must be given, the function name, its arguments and the compilation options.</p> <p>This function is useful in case you have templates but you want to precompile inside a module for speed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># sample.eex\n&lt;%= a + b %&gt;\n\n# sample.ex\ndefmodule Sample do\n  require EEx\n  EEx.function_from_file :def, :sample, \"sample.eex\", [:a, :b]\nend\n\n# iex\nSample.sample(1, 2) #=&gt; \"3\"</code></pre>    <h3 class=\"detail-header macro\" id=\"function_from_string/5\">  <span class=\"signature\">function_from_string(kind, name, source, args \\\\ [], options \\\\ [])</span>  </h3>  <p>Generates a function definition from the string.</p> <p>The kind (<code class=\"inline\">:def</code> or <code class=\"inline\">:defp</code>) must be given, the function name, its arguments and the compilation options.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; defmodule Sample do\n...&gt;   require EEx\n...&gt;   EEx.function_from_string :def, :sample, \"&lt;%= a + b %&gt;\", [:a, :b]\n...&gt; end\niex&gt; Sample.sample(1, 2)\n\"3\"</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/eex/EEx.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/eex/EEx.html</a>\n  </p>\n</div>\n","ex_unit/exunit":"<h1>  ExUnit  </h1>  <p>Unit testing framework for Elixir.</p> <h2 id=\"module-example\" class=\"section-heading\">  Example </h2> <p>A basic setup for ExUnit is shown below:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># File: assertion_test.exs\n\n# 1) Start ExUnit.\nExUnit.start\n\n# 2) Create a new test module (test case) and use \"ExUnit.Case\".\ndefmodule AssertionTest do\n  # 3) Notice we pass \"async: true\", this runs the test case\n  #    concurrently with other test cases. The individual tests\n  #    within each test case are still run serially.\n  use ExUnit.Case, async: true\n\n  # 4) Use the \"test\" macro instead of \"def\" for clarity.\n  test \"the truth\" do\n    assert true\n  end\nend</code></pre> <p>To run the tests above, run the file using <code class=\"inline\">elixir</code> from the command line. Assuming you named the file <code class=\"inline\">assertion_test.exs</code>, you can run it as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">elixir assertion_test.exs</code></pre> <h2 id=\"module-case-callbacks-and-assertions\" class=\"section-heading\">  Case, Callbacks and Assertions </h2> <p>See <a href=\"exunit.case\"><code class=\"inline\">ExUnit.Case</code></a> and <a href=\"exunit.callbacks\"><code class=\"inline\">ExUnit.Callbacks</code></a> for more information about defining test cases and setting up callbacks.</p> <p>The <a href=\"exunit.assertions\"><code class=\"inline\">ExUnit.Assertions</code></a> module contains a set of macros to generate assertions with appropriate error messages.</p> <h2 id=\"module-integration-with-mix\" class=\"section-heading\">  Integration with Mix </h2> <p>Mix is the project management and build tool for Elixir. Invoking <code class=\"inline\">mix test</code> from the command line will run the tests in each file matching the pattern <code class=\"inline\">*_test.exs</code> found in the <code class=\"inline\">test</code> directory of your project.</p> <p>You must create a <code class=\"inline\">test_helper.exs</code> file inside the <code class=\"inline\">test</code> directory and put the code common to all tests there.</p> <p>The minimum example of a <code class=\"inline\">test_helper.exs</code> file would be:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># test/test_helper.exs\nExUnit.start</code></pre> <p>Mix will load the <code class=\"inline\">test_helper.exs</code> file before executing the tests. It is not necessary to <code class=\"inline\">require</code> the <code class=\"inline\">test_helper.exs</code> file in your test files. See <code class=\"inline\">Mix.Tasks.Test</code> for more information.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:failed/0\">failed()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:state/0\">state()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The error state returned by ExUnit.Test and ExUnit.TestCase</p> </dd>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#configuration/0\">configuration()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns ExUnit configuration</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#configure/1\">configure(options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Configures ExUnit</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#plural_rule/1\">plural_rule(word)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the pluralization for <code class=\"inline\">word</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#plural_rule/2\">plural_rule(word, pluralization)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Registers a <code class=\"inline\">pluralization</code> for <code class=\"inline\">word</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#run/0\">run()</a> </dt> <dd class=\"summary-synopsis\">\n<p>API used to run the tests. It is invoked automatically if ExUnit is started via <a href=\"exunit#start/1\"><code class=\"inline\">ExUnit.start/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start/1\">start(options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts ExUnit and automatically runs tests right before the VM terminates. It accepts a set of options to configure <a href=\"exunit#content\"><code class=\"inline\">ExUnit</code></a> (the same ones accepted by <a href=\"#configure/1)\"><code class=\"inline\">configure/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:failed/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:failed/0\">failed</a> :: [{<a href=\"../elixir/exception#t:kind/0\">Exception.kind</a>, reason :: term, stacktrace :: [tuple]}]</code></pre> </div> <div id=\"t:state/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:state/0\">state</a> ::\n  nil |\n  {:failed, <a href=\"#t:failed/0\">failed</a>} |\n  {:skip, binary} |\n  {:invalid, module}</code></pre> <p>The error state returned by ExUnit.Test and ExUnit.TestCase</p>  </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"configuration/0\">  <span class=\"signature\">configuration()</span>  </h3>  <p>Returns ExUnit configuration.</p>    <h3 class=\"detail-header function\" id=\"configure/1\">  <span class=\"signature\">configure(options)</span>  </h3>  <p>Configures ExUnit.</p> <h4>Options</h4> <p>ExUnit supports the following options:</p> <ul> <li>\n<p><code class=\"inline\">:assert_receive_timeout</code> - the timeout to be used on <code class=\"inline\">assert_receive</code> calls. Defaults to 100ms.</p> </li> <li>\n<p><code class=\"inline\">:capture_log</code> - if ExUnit should default to keeping track of log messages and print them on test failure. Can be overridden for individual tests via <code class=\"inline\">@tag capture_log: false</code>. Defaults to <code class=\"inline\">false</code>.</p> </li> <li>\n<p><code class=\"inline\">:colors</code> - a keyword list of colors to be used by some formatters. The only option so far is <code class=\"inline\">[enabled: boolean]</code> which defaults to <code class=\"inline\">IO.ANSI.enabled?/0</code></p> </li> <li>\n<p><code class=\"inline\">:formatters</code> - the formatters that will print results; defaults to <code class=\"inline\">[ExUnit.CLIFormatter]</code></p> </li> <li>\n<p><code class=\"inline\">:max_cases</code> - maximum number of cases to run in parallel; defaults to <code class=\"inline\">:erlang.system_info(:schedulers_online) * 2</code> to optimize both CPU-bound and IO-bound tests</p> </li> <li>\n<p><code class=\"inline\">:trace</code> - set ExUnit into trace mode, this sets <code class=\"inline\">:max_cases</code> to <code class=\"inline\">1</code> and prints each test case and test while running</p> </li> <li>\n<p><code class=\"inline\">:autorun</code> - if ExUnit should run by default on exit; defaults to <code class=\"inline\">true</code></p> </li> <li>\n<p><code class=\"inline\">:include</code> - specify which tests are run by skipping tests that do not match the filter. Keep in mind that all tests are included by default, so unless they are excluded first, the <code class=\"inline\">:include</code> option has no effect.</p> </li> <li>\n<p><code class=\"inline\">:exclude</code> - specify which tests are run by skipping tests that match the filter</p> </li> <li>\n<p><code class=\"inline\">:refute_receive_timeout</code> - the timeout to be used on <code class=\"inline\">refute_receive</code> calls (defaults to 100ms)</p> </li> <li>\n<p><code class=\"inline\">:seed</code> - an integer seed value to randomize the test suite</p> </li> <li>\n<p><code class=\"inline\">:stacktrace_depth</code> - configures the stacktrace depth to be used on formatting and reporters (defaults to 20)</p> </li> <li>\n<code class=\"inline\">:timeout</code> - set the timeout for the tests (default 60_000ms) </li> </ul>    <h3 class=\"detail-header function\" id=\"plural_rule/1\">  <span class=\"signature\">plural_rule(word)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">plural_rule(binary) :: binary</code></pre>    <p>Returns the pluralization for <code class=\"inline\">word</code>.</p> <p>If one is not registered, returns the word appended with an “s”.</p>    <h3 class=\"detail-header function\" id=\"plural_rule/2\">  <span class=\"signature\">plural_rule(word, pluralization)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">plural_rule(binary, binary) :: :ok</code></pre>    <p>Registers a <code class=\"inline\">pluralization</code> for <code class=\"inline\">word</code>.</p> <p>If one is already registered, it is replaced.</p>    <h3 class=\"detail-header function\" id=\"run/0\">  <span class=\"signature\">run()</span>  </h3>  <p>API used to run the tests. It is invoked automatically if ExUnit is started via <a href=\"exunit#start/1\"><code class=\"inline\">ExUnit.start/1</code></a>.</p> <p>Returns a map containing the total number of tests, the number of failures and the number of skipped tests.</p>    <h3 class=\"detail-header function\" id=\"start/1\">  <span class=\"signature\">start(options \\\\ [])</span>  </h3>  <p>Starts ExUnit and automatically runs tests right before the VM terminates. It accepts a set of options to configure <a href=\"exunit#content\"><code class=\"inline\">ExUnit</code></a> (the same ones accepted by <a href=\"#configure/1)\"><code class=\"inline\">configure/1</code></a>.</p> <p>If you want to run tests manually, you can set <code class=\"inline\">:autorun</code> to <code class=\"inline\">false</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/ex_unit/ExUnit.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/ex_unit/ExUnit.html</a>\n  </p>\n</div>\n","iex/iex":"<h1>  IEx  </h1>  <p>Elixir’s interactive shell.</p> <p>This module is the main entry point for Interactive Elixir and in this documentation we will talk a bit about how IEx works.</p> <p>Notice that some of the functionalities described here will not be available depending on your terminal. In particular, if you get a message saying that the smart terminal could not be run, some of the features described here won’t work.</p> <h2 id=\"module-helpers\" class=\"section-heading\">  Helpers </h2> <p>IEx provides a bunch of helpers. They can be accessed by typing <code class=\"inline\">h()</code> into the shell or as a documentation for the <a href=\"iex.helpers\"><code class=\"inline\">IEx.Helpers</code></a> module.</p> <h2 id=\"module-autocomplete\" class=\"section-heading\">  Autocomplete </h2> <p>To discover all available functions for a module, type the module name followed by a dot, then press tab to trigger autocomplete. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Enum.</code></pre> <p>Such function may not be available on some Windows shells. You may need to pass the <code class=\"inline\">--werl</code> flag when starting iex, as in <code class=\"inline\">iex --werl</code> for it to work. <code class=\"inline\">--werl</code> may be permanently enabled by setting the <code class=\"inline\">IEX_WITH_WERL</code> environment variable.</p> <h2 id=\"module-the-break-command\" class=\"section-heading\">  The Break command </h2> <p>Inside IEx, hitting <code class=\"inline\">Ctrl+C</code> will open up the <code class=\"inline\">BREAK</code> menu. In this menu you can quit the shell, see process and ets tables information and much more.</p> <h2 id=\"module-the-user-switch-command\" class=\"section-heading\">  The User Switch command </h2> <p>Besides the break command, one can type <code class=\"inline\">Ctrl+G</code> to get to the user switch command menu. When reached, you can type <code class=\"inline\">h</code> to get more information.</p> <p>In this menu, developers are able to start new shells and alternate between them. Let’s give it a try:</p> <pre data-language=\"elixir\"><code class=\"elixir\">User switch command\n --&gt; s 'Elixir.IEx'\n --&gt; c</code></pre> <p>The command above will start a new shell and connect to it. Create a new variable called <code class=\"inline\">hello</code> and assign some value to it:</p> <pre data-language=\"elixir\"><code class=\"elixir\">hello = :world</code></pre> <p>Now, let’s roll back to the first shell:</p> <pre data-language=\"elixir\"><code class=\"elixir\">User switch command\n --&gt; c 1</code></pre> <p>Now, try to access the <code class=\"inline\">hello</code> variable again:</p> <pre data-language=\"elixir\"><code class=\"elixir\">hello\n** (UndefinedFunctionError) undefined function hello/0</code></pre> <p>The command above fails because we have switched shells. Since shells are isolated from each other, you can’t access the variables defined in one shell from the other one.</p> <p>The user switch command menu also allows developers to connect to remote shells using the <code class=\"inline\">r</code> command. A topic which we will discuss next.</p> <h2 id=\"module-remote-shells\" class=\"section-heading\">  Remote shells </h2> <p>IEx allows you to connect to another node in two fashions. First of all, we can only connect to a shell if we give names both to the current shell and the shell we want to connect to.</p> <p>Let’s give it a try. First start a new shell:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$ iex --sname foo\niex(foo@HOST)1&gt;</code></pre> <p>The string between the parentheses in the prompt is the name of your node. We can retrieve it by calling the <code class=\"inline\">node()</code> function:</p> <pre data-language=\"elixir\"><code class=\"elixir\">iex(foo@HOST)1&gt; node()\n:\"foo@HOST\"\niex(foo@HOST)2&gt; Node.alive?()\ntrue</code></pre> <p>For fun, let’s define a simple module in this shell too:</p> <pre data-language=\"elixir\"><code class=\"elixir\">iex(foo@HOST)3&gt; defmodule Hello do\n...(foo@HOST)3&gt;   def world, do: \"it works!\"\n...(foo@HOST)3&gt; end</code></pre> <p>Now, let’s start another shell, giving it a name as well:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$ iex --sname bar\niex(bar@HOST)1&gt;</code></pre> <p>If we try to dispatch to <code class=\"inline\">Hello.world</code>, it won’t be available as it was defined only in the other shell:</p> <pre data-language=\"elixir\"><code class=\"elixir\">iex(bar@HOST)1&gt; Hello.world\n** (UndefinedFunctionError) undefined function Hello.world/0</code></pre> <p>However, we can connect to the other shell remotely. Open up the User Switch prompt (Ctrl+G) and type:</p> <pre data-language=\"elixir\"><code class=\"elixir\">User switch command\n --&gt; r 'foo@HOST' 'Elixir.IEx'\n --&gt; c</code></pre> <p>Now we are connected into the remote node, as the prompt shows us, and we can access the information and modules defined over there:</p> <pre data-language=\"elixir\"><code class=\"elixir\">rem(foo@macbook)1&gt; Hello.world\n\"it works\"</code></pre> <p>In fact, connecting to remote shells is so common that we provide a shortcut via the command line as well:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$ iex --sname baz --remsh foo@HOST</code></pre> <p>Where “remsh” means “remote shell”. In general, Elixir supports:</p> <ul> <li>remsh from an Elixir node to an Elixir node </li> <li>remsh from a plain Erlang node to an Elixir node (through the ^G menu) </li> <li>remsh from an Elixir node to a plain Erlang node (and get an <code class=\"inline\">erl</code> shell there) </li> </ul> <p>Connecting an Elixir shell to a remote node without Elixir is <strong>not</strong> supported.</p> <h2 id=\"module-the-iex-exs-file\" class=\"section-heading\">  The .iex.exs file </h2> <p>When starting IEx, it will look for a local <code class=\"inline\">.iex.exs</code> file (located in the current working directory), then a global one (located at <code class=\"inline\">~/.iex.exs</code>) and will load the first one it finds (if any). The code in the chosen .iex.exs file will be evaluated in the shell’s context. So, for instance, any modules that are loaded or variables that are bound in the .iex.exs file will be available in the shell after it has booted.</p> <p>Sample contents of a local .iex.exs file:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># source another \".iex.exs\" file\nimport_file \"~/.iex.exs\"\n\n# print something before the shell starts\nIO.puts \"hello world\"\n\n# bind a variable that'll be accessible in the shell\nvalue = 13</code></pre> <p>Running the shell in the directory where the above .iex.exs file is located results in:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$ iex\nErlang 17 [...]\n\nhello world\nInteractive Elixir - press Ctrl+C to exit (type h() ENTER for help)\niex(1)&gt; value\n13</code></pre> <p>It is possible to load another file by supplying the <code class=\"inline\">--dot-iex</code> option to iex. See <code class=\"inline\">iex --help</code>.</p> <h2 id=\"module-configuring-the-shell\" class=\"section-heading\">  Configuring the shell </h2> <p>There are a number of customization options provided by the shell. Take a look at the docs for the <a href=\"iex#configure/1\"><code class=\"inline\">IEx.configure/1</code></a> function by typing <code class=\"inline\">h IEx.configure/1</code>.</p> <p>Those options can be configured in your project configuration file or globally by calling <a href=\"iex#configure/1\"><code class=\"inline\">IEx.configure/1</code></a> from your <code class=\"inline\">~/.iex.exs</code> file like this:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># .iex.exs\nIEx.configure(inspect: [limit: 3])\n\n### now run the shell ###\n\n$ iex\nErlang 17 (erts-5.10.1) [...]\n\nInteractive Elixir - press Ctrl+C to exit (type h() ENTER for help)\niex(1)&gt; [1, 2, 3, 4, 5]\n[1, 2, 3, ...]</code></pre> <h2 id=\"module-expressions-in-iex\" class=\"section-heading\">  Expressions in IEx </h2> <p>As an interactive shell, IEx evaluates expressions. This has some interesting consequences that are worth discussing.</p> <p>The first one is that the code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell.</p> <p>Second, IEx allows you to break an expression into many lines, since this is common in Elixir. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">iex(1)&gt; \"ab\n...(1)&gt; c\"\n\"ab\\nc\"</code></pre> <p>In the example above, the shell will be expecting more input until it finds the closing quote. Sometimes it is not obvious which character the shell is expecting, and the user may find themselves trapped in the state of incomplete expression with no ability to terminate it other than by exiting the shell.</p> <p>For such cases, there is a special break-trigger (<code class=\"inline\">#iex:break</code>) that when encountered on a line by itself will force the shell to break out of any pending expression and return to its normal state:</p> <pre data-language=\"elixir\"><code class=\"elixir\">iex(1)&gt; [\"ab\n...(1)&gt; c\"\n...(1)&gt; \"\n...(1)&gt; ]\n...(1)&gt; #iex:break\n** (TokenMissingError) iex:1: incomplete expression</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#after_spawn/0\">after_spawn()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns registered <code class=\"inline\">after_spawn</code> callbacks</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#after_spawn/1\">after_spawn(fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Registers a function to be invoked after the IEx process is spawned</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#color/2\">color(color, string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">string</code> escaped using the specified <code class=\"inline\">color</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#configuration/0\">configuration()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns IEx configuration</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#configure/1\">configure(options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Configures IEx</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#inspect_opts/0\">inspect_opts()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the options used for inspecting</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pry/3\">pry(binding, env, timeout)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback for <a href=\"iex#pry/1\"><code class=\"inline\">IEx.pry/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#started?/0\">started?()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if IEx was started</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#width/0\">width()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the IEx width for printing</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#pry/1\">pry(timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Pries into the process environment</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"after_spawn/0\">  <span class=\"signature\">after_spawn()</span>  </h3>  <p>Returns registered <code class=\"inline\">after_spawn</code> callbacks.</p>    <h3 class=\"detail-header function\" id=\"after_spawn/1\">  <span class=\"signature\">after_spawn(fun)</span>  </h3>  <p>Registers a function to be invoked after the IEx process is spawned.</p>    <h3 class=\"detail-header function\" id=\"color/2\">  <span class=\"signature\">color(color, string)</span>  </h3>  <p>Returns <code class=\"inline\">string</code> escaped using the specified <code class=\"inline\">color</code>.</p> <p>ANSI escapes in <code class=\"inline\">string</code> are not processed in any way.</p>    <h3 class=\"detail-header function\" id=\"configuration/0\">  <span class=\"signature\">configuration()</span>  </h3>  <p>Returns IEx configuration.</p>    <h3 class=\"detail-header function\" id=\"configure/1\">  <span class=\"signature\">configure(options)</span>  </h3>  <p>Configures IEx.</p> <p>The supported options are: <code class=\"inline\">:colors</code>, <code class=\"inline\">:inspect</code>, <code class=\"inline\">:width</code>, <code class=\"inline\">:history_size</code>, <code class=\"inline\">:default_prompt</code> and <code class=\"inline\">:alive_prompt</code>.</p> <h4>Colors</h4> <p>A keyword list that encapsulates all color settings used by the shell. See documentation for the <code class=\"inline\">IO.ANSI</code> module for the list of supported colors and attributes.</p> <p>The value is a keyword list. List of supported keys:</p> <ul> <li>\n<code class=\"inline\">:enabled</code> - boolean value that allows for switching the coloring on and off </li> <li>\n<code class=\"inline\">:eval_result</code> - color for an expression’s resulting value </li> <li>\n<code class=\"inline\">:eval_info</code> - … various informational messages </li> <li>\n<code class=\"inline\">:eval_error</code> - … error messages </li> <li>\n<code class=\"inline\">:stack_app</code> - … the app in stack traces </li> <li>\n<code class=\"inline\">:stack_info</code> - … the remaining info in stacktraces </li> <li>\n<code class=\"inline\">:ls_directory</code> - … for directory entries (ls helper) </li> <li>\n<code class=\"inline\">:ls_device</code> - … device entries (ls helper) </li> </ul> <p>When printing documentation, IEx will convert the Markdown documentation to ANSI as well. Those can be configured via:</p> <ul> <li>\n<code class=\"inline\">:doc_code</code> - the attributes for code blocks (cyan, bright) </li> <li>\n<code class=\"inline\">:doc_inline_code</code> - inline code (cyan) </li> <li>\n<code class=\"inline\">:doc_headings</code> - h1 and h2 (yellow, bright) </li> <li>\n<code class=\"inline\">:doc_title</code> - the overall heading for the output (reverse, yellow, bright) </li> <li>\n<code class=\"inline\">:doc_bold</code> - (bright) </li> <li>\n<code class=\"inline\">:doc_underline</code> - (underline) </li> </ul> <h4>Inspect</h4> <p>A keyword list containing inspect options used by the shell when printing results of expression evaluation. Default to pretty formatting with a limit of 50 entries.</p> <p>See <code class=\"inline\">Inspect.Opts</code> for the full list of options.</p> <h4>Width</h4> <p>An integer indicating the number of columns to use in documentation output. Default is 80 columns or result of <code class=\"inline\">:io.columns</code>, whichever is smaller. The configured value will be used unless it is too large, which in that case <code class=\"inline\">:io.columns</code> is used. This way you can configure IEx to be your largest screen size and it should always take up the full width of your terminal screen.</p> <h4>History size</h4> <p>Number of expressions and their results to keep in the history. The value is an integer. When it is negative, the history is unlimited.</p> <h4>Prompt</h4> <p>This is an option determining the prompt displayed to the user when awaiting input.</p> <p>The value is a keyword list. Two prompt types:</p> <ul> <li>\n<code class=\"inline\">:default_prompt</code> - used when <code class=\"inline\">Node.alive?</code> returns <code class=\"inline\">false</code> </li> <li>\n<code class=\"inline\">:alive_prompt</code> - used when <code class=\"inline\">Node.alive?</code> returns <code class=\"inline\">true</code> </li> </ul> <p>The following values in the prompt string will be replaced appropriately:</p> <ul> <li>\n<code class=\"inline\">%counter</code> - the index of the history </li> <li>\n<code class=\"inline\">%prefix</code> - a prefix given by <code class=\"inline\">IEx.Server</code> </li> <li>\n<code class=\"inline\">%node</code> - the name of the local node </li> </ul>    <h3 class=\"detail-header function\" id=\"inspect_opts/0\">  <span class=\"signature\">inspect_opts()</span>  </h3>  <p>Gets the options used for inspecting.</p>    <h3 class=\"detail-header function\" id=\"pry/3\">  <span class=\"signature\">pry(binding, env, timeout)</span>  </h3>  <p>Callback for <a href=\"iex#pry/1\"><code class=\"inline\">IEx.pry/1</code></a>.</p> <p>You can invoke this function directly when you are not able to invoke <a href=\"iex#pry/1\"><code class=\"inline\">IEx.pry/1</code></a> as a macro. This function expects the binding (from <code class=\"inline\">Kernel.binding/0</code>), the environment (from <code class=\"inline\">__ENV__</code>) and the timeout (a sensible default is 5000).</p>    <h3 class=\"detail-header function\" id=\"started?/0\">  <span class=\"signature\">started?()</span>  </h3>  <p>Returns <code class=\"inline\">true</code> if IEx was started.</p>    <h3 class=\"detail-header function\" id=\"width/0\">  <span class=\"signature\">width()</span>  </h3>  <p>Gets the IEx width for printing.</p> <p>Used by helpers and it has a maximum cap of 80 chars.</p>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"pry/1\">  <span class=\"signature\">pry(timeout \\\\ 5000)</span>  </h3>  <p>Pries into the process environment.</p> <p>This is useful for debugging a particular chunk of code and inspect the state of a particular process. The process is temporarily changed to trap exits (i.e. the process flag <code class=\"inline\">:trap_exit</code> is set to <code class=\"inline\">true</code>) and has the <code class=\"inline\">group_leader</code> changed to support ANSI escape codes. Those values are reverted by calling <code class=\"inline\">respawn</code>, which starts a new IEx shell, freeing up the pried one.</p> <p>When a process is pried, all code runs inside IEx and, as such, it is evaluated and cannot access private functions of the module being pried. Module functions still need to be accessed via <code class=\"inline\">Mod.fun(args)</code>.</p> <h4>Examples</h4> <p>Let’s suppose you want to investigate what is happening with some particular function. By invoking <a href=\"iex#pry/1\"><code class=\"inline\">IEx.pry/1</code></a> from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let’s see an example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import Enum, only: [map: 2]\nrequire IEx\n\ndefmodule Adder do\n  def add(a, b) do\n    c = a + b\n    IEx.pry\n  end\nend</code></pre> <p>When invoking <code class=\"inline\">Adder.add(1, 2)</code>, you will receive a message in your shell to pry the given environment. By allowing it, the shell will be reset and you gain access to all variables and the lexical scope from above:</p> <pre data-language=\"elixir\"><code class=\"elixir\">pry(1)&gt; map([a, b, c], &amp;IO.inspect(&amp;1))\n1\n2\n3</code></pre> <p>Keep in mind that <a href=\"iex#pry/1\"><code class=\"inline\">IEx.pry/1</code></a> runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling <code class=\"inline\">respawn</code>, which starts a new IEx evaluation cycle, letting this one go:</p> <pre data-language=\"elixir\"><code class=\"elixir\">pry(2)&gt; respawn\ntrue\n\nInteractive Elixir - press Ctrl+C to exit (type h() ENTER for help)</code></pre> <p>Setting variables or importing modules in IEx does not affect the caller the environment (hence it is called <code class=\"inline\">pry</code>).</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/iex/IEx.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/iex/IEx.html</a>\n  </p>\n</div>\n","mix/mix":"<h1>  Mix  </h1>  <p>Mix is a build tool that provides tasks for creating, compiling, and testing Elixir projects, managing its dependencies, and more.</p> <h2 id=\"module-mix-project\" class=\"section-heading\">  Mix.Project </h2> <p>The foundation of Mix is a project. A project can be defined by using <a href=\"mix.project\"><code class=\"inline\">Mix.Project</code></a> in a module, usually placed in a file named <code class=\"inline\">mix.exs</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.Mixfile do\n  use Mix.Project\n\n  def project do\n    [app: :my_app,\n     version: \"1.0.0\"]\n  end\nend</code></pre> <p>The <code class=\"inline\">project/0</code> function is where the project information is defined and it allows developers to configure many tasks.</p> <p>After the project above is defined, there are many tasks one can run directly from the command line:</p> <ul> <li>\n<code class=\"inline\">mix compile</code> - compiles the current project </li> <li>\n<code class=\"inline\">mix test</code> - runs tests for the given project </li> <li>\n<code class=\"inline\">mix run</code> - runs a particular command inside the project </li> </ul> <p>Each task has its own options and sometimes specific configuration to be defined in the <code class=\"inline\">project/0</code> function. You can use <code class=\"inline\">mix help</code> to list all available tasks and <code class=\"inline\">mix help NAME</code> to show help for a particular task.</p> <p>The best way to get started with your first project is by calling <code class=\"inline\">mix new my_project</code> from the command line.</p> <h2 id=\"module-mix-task\" class=\"section-heading\">  Mix.Task </h2> <p>Tasks are what make Mix extensible.</p> <p>Any project can extend Mix behaviour by adding their own tasks. For example, you can add the task below inside your project and it will be available to everyone that uses your project:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Mix.Tasks.Hello do\n  use Mix.Task\n\n  def run(_) do\n    Mix.shell.info \"hello\"\n  end\nend</code></pre> <p>Now they can invoke it with <code class=\"inline\">mix hello</code>.</p> <h2 id=\"module-dependencies\" class=\"section-heading\">  Dependencies </h2> <p>Another important feature in Mix is that it is able to manage your dependencies and integrates nicely with <a href=\"https://hex.pm\">the Hex package manager</a>.</p> <p>In order to use dependencies, you just need to add a <code class=\"inline\">:deps</code> key to your project configuration. We often extract the dependencies listing to its own functions:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.Mixfile do\n  use Mix.Project\n\n  def project do\n    [app: :my_app,\n     version: \"1.0.0\",\n     deps: deps]\n  end\n\n  defp deps do\n    [{:ecto, \"~&gt; 0.2.5\"},\n     {:plug, github: \"elixir-lang/plug\"}]\n  end\nend</code></pre> <p>You can run <code class=\"inline\">mix help deps</code> to learn more about dependencies in Mix.</p> <h2 id=\"module-environments\" class=\"section-heading\">  Environments </h2> <p>Mix provides environments.</p> <p>Environments allow developers to prepare and organize their project specifically for different scenarios. By default, Mix provides three environments:</p> <ul> <li>\n<code class=\"inline\">:dev</code> - the default environment </li> <li>\n<code class=\"inline\">:test</code> - the environment <code class=\"inline\">mix test</code> runs on </li> <li>\n<code class=\"inline\">:prod</code> - the environment your dependencies runs on </li> </ul> <p>The environment can be changed via the command line by setting the <code class=\"inline\">MIX_ENV</code> environment variable, for example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$ MIX_ENV=prod mix run server.exs</code></pre> <h2 id=\"module-aliases\" class=\"section-heading\">  Aliases </h2> <p>Aliases are shortcuts or tasks specific to the current project.</p> <p>In the <a href=\"mix.task\"><code class=\"inline\">Mix.Task</code></a> section, we have defined a task that would be available to everyone using our project as a dependency. What if we wanted the task to only be available for our project? Just define an alias:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.Mixfile do\n  use Mix.Project\n\n  def project do\n    [app: :my_app,\n     version: \"1.0.0\",\n     aliases: aliases]\n  end\n\n  defp aliases do\n    [c: \"compile\",\n     hello: &amp;hello/1]\n  end\n\n  defp hello(_) do\n    Mix.shell.info \"Hello world\"\n  end\nend</code></pre> <p>In the example above, we have defined two aliases. One is <code class=\"inline\">mix c</code> which is a shortcut for <code class=\"inline\">mix compile</code>. The other is named <code class=\"inline\">mix hello</code>, which is the equivalent to the <code class=\"inline\">Mix.Tasks.Hello</code> we have defined in the <a href=\"mix.task\"><code class=\"inline\">Mix.Task</code></a> section.</p> <p>Aliases may also be lists, specifying multiple tasks to run at once:</p> <pre data-language=\"elixir\"><code class=\"elixir\">[all: [&amp;hello/1, \"deps.get --only #{Mix.env}\", \"compile\"]]</code></pre> <p>In the example above, we have defined an alias named <code class=\"inline\">mix all</code>, that prints hello, then fetches dependencies specific to the current environment and compiles it.</p> <p>Arguments given to the alias will be appended to the arguments of the last task in the list, if the last task is a function they will be given as a list of strings to the function.</p> <p>Finally, aliases can also be use to augment existing tasks. Let’s suppose you want to augment <code class=\"inline\">mix clean</code> to clean another directory Mix does not know about:</p> <pre data-language=\"elixir\"><code class=\"elixir\">[clean: [\"clean\", &amp;clean_extra/1]]</code></pre> <p>Where <code class=\"inline\">&amp;clean_extra/1</code> would be a function in your <code class=\"inline\">mix.exs</code> with extra clean up logic.</p> <p>Note aliases do not show up on <code class=\"inline\">mix help</code>.</p> <h2 id=\"module-environment-variables\" class=\"section-heading\">  Environment variables </h2> <p>Environment variables can be used to modify Mix behaviour.</p> <p>Mix responds to the following variables:</p> <ul> <li>\n<code class=\"inline\">MIX_ARCHIVES</code> - allows specifying the directory into which the archives should be installed </li> <li>\n<code class=\"inline\">MIX_DEBUG</code> - outputs debug information about each task before running it </li> <li>\n<code class=\"inline\">MIX_ENV</code> - allows specifying which environment should be used. see Environments </li> <li>\n<code class=\"inline\">MIX_EXS</code> - allows changing the full path to the <code class=\"inline\">mix.exs</code> file </li> <li>\n<code class=\"inline\">MIX_HOME</code> - stores configuration files and scripts shared by multiple implementations </li> <li>\n<code class=\"inline\">MIX_PATH</code> - allows expanding the code path </li> <li>\n<code class=\"inline\">MIX_QUIET</code> - does not print information messages to the terminal </li> </ul> <p>Variables which do not take a value should be set to either <code class=\"inline\">1</code> or <code class=\"inline\">true</code>, for example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$ MIX_DEBUG=1 mix compile</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#compilers/0\">compilers()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the default compilers used by Mix</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#debug/1\">debug(debug)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets Mix debug mode</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#debug?/0\">debug?()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns true if Mix is in debug mode</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#env/0\">env()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the Mix environment</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#env/1\">env(env)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Changes the current Mix environment to <code class=\"inline\">env</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#raise/1\">raise(message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Raises a Mix error that is nicely formatted</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#shell/0\">shell()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current shell</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#shell/1\">shell(shell)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets the current shell</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"compilers/0\">  <span class=\"signature\">compilers()</span>  </h3>  <p>Returns the default compilers used by Mix.</p> <p>It can be used in your <code class=\"inline\">mix.exs</code> to prepend or append new compilers to Mix:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def project do\n  [compilers: Mix.compilers ++ [:foo, :bar]]\nend</code></pre>    <h3 class=\"detail-header function\" id=\"debug/1\">  <span class=\"signature\">debug(debug)</span>  </h3>  <p>Sets Mix debug mode.</p>    <h3 class=\"detail-header function\" id=\"debug?/0\">  <span class=\"signature\">debug?()</span>  </h3>  <p>Returns true if Mix is in debug mode.</p>    <h3 class=\"detail-header function\" id=\"env/0\">  <span class=\"signature\">env()</span>  </h3>  <p>Returns the Mix environment.</p>    <h3 class=\"detail-header function\" id=\"env/1\">  <span class=\"signature\">env(env)</span>  </h3>  <p>Changes the current Mix environment to <code class=\"inline\">env</code>.</p> <p>Be careful when invoking this function as any project configuration won’t be reloaded.</p>    <h3 class=\"detail-header function\" id=\"raise/1\">  <span class=\"signature\">raise(message)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">raise(binary) :: no_return</code></pre>    <p>Raises a Mix error that is nicely formatted.</p>    <h3 class=\"detail-header function\" id=\"shell/0\">  <span class=\"signature\">shell()</span>  </h3>  <p>Returns the current shell.</p> <p><a href=\"#shell/0\"><code class=\"inline\">shell/0</code></a> can be used as a wrapper for the current shell. It contains conveniences for asking information to the user, printing things and so forth. The Mix shell is swappable (see <a href=\"#shell/1)\"><code class=\"inline\">shell/1</code></a>, allowing developers to use a test shell that simply sends messages to the current process instead of doing IO (see <a href=\"mix.shell.process.html)\"><code class=\"inline\">Mix.Shell.Process</code></a>.</p> <p>By default, this returns <a href=\"mix.shell.io\"><code class=\"inline\">Mix.Shell.IO</code></a>.</p>    <h3 class=\"detail-header function\" id=\"shell/1\">  <span class=\"signature\">shell(shell)</span>  </h3>  <p>Sets the current shell.</p> <p>After calling this function, <code class=\"inline\">shell</code> becomes the shell that is returned by <a href=\"#shell/0\"><code class=\"inline\">shell/0</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/mix/Mix.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/mix/Mix.html</a>\n  </p>\n</div>\n","logger/logger":"<h1>  Logger  </h1>  <p>A logger for Elixir applications.</p> <p>It includes many features:</p> <ul> <li>\n<p>Provides debug, info, warn and error levels.</p> </li> <li>\n<p>Supports multiple backends which are automatically supervised when plugged into <a href=\"logger#content\"><code class=\"inline\">Logger</code></a>.</p> </li> <li>\n<p>Formats and truncates messages on the client to avoid clogging <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> backends.</p> </li> <li>\n<p>Alternates between sync and async modes to remain performant when required but also apply backpressure when under stress.</p> </li> <li>Wraps OTP’s <code class=\"inline\">error_logger</code> to prevent it from overflowing. </li> </ul> <h2 id=\"module-levels\" class=\"section-heading\">  Levels </h2> <p>The supported levels are:</p> <ul> <li>\n<code class=\"inline\">:debug</code> - for debug-related messages </li> <li>\n<code class=\"inline\">:info</code> - for information of any kind </li> <li>\n<code class=\"inline\">:warn</code> - for warnings </li> <li>\n<code class=\"inline\">:error</code> - for errors </li> </ul> <h2 id=\"module-configuration\" class=\"section-heading\">  Configuration </h2> <p><a href=\"logger#content\"><code class=\"inline\">Logger</code></a> supports a wide range of configurations.</p> <p>This configuration is split in three categories:</p> <ul> <li>\n<p>Application configuration - must be set before the <code class=\"inline\">:logger</code> application is started</p> </li> <li>\n<p>Runtime configuration - can be set before the <code class=\"inline\">:logger</code> application is started, but may be changed during runtime</p> </li> <li>Error logger configuration - configuration for the wrapper around OTP’s <code class=\"inline\">error_logger</code> </li> </ul> <h3>Application configuration</h3> <p>The following configuration must be set via config files (e.g., <code class=\"inline\">config/config.exs</code>) before the <code class=\"inline\">:logger</code> application is started.</p> <ul> <li>\n<p><code class=\"inline\">:backends</code> - the backends to be used. Defaults to <code class=\"inline\">[:console]</code>. See the “Backends” section for more information.</p> </li> <li>\n<p><code class=\"inline\">:compile_time_purge_level</code> - purge <em>at compilation time</em> all calls that have log level lower than the value of this option. This means that <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> calls with level lower than this option will be completely removed at compile time, accruing no overhead at runtime. Defaults to <code class=\"inline\">:debug</code> and only applies to the <a href=\"logger#debug/2\"><code class=\"inline\">Logger.debug/2</code></a>, <a href=\"logger#info/2\"><code class=\"inline\">Logger.info/2</code></a>, <a href=\"logger#warn/2\"><code class=\"inline\">Logger.warn/2</code></a>, and <a href=\"logger#error/2\"><code class=\"inline\">Logger.error/2</code></a> macros (e.g., it doesn’t apply to <a href=\"logger#log/3)\"><code class=\"inline\">Logger.log/3</code></a>. Note that arguments passed to <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> calls that are removed from the AST at compilation time are never evaluated, thus any function call that occurs in these arguments is never executed. As a consequence, avoid code that looks like <code class=\"inline\">Logger.debug(\"Cleanup:\n    #{perform_cleanup()}\")</code> as in the example <code class=\"inline\">perform_cleanup/0</code> won’t be executed if the <code class=\"inline\">:compile_time_purge_level</code> is <code class=\"inline\">:info</code> or higher.</p> </li> <li>\n<code class=\"inline\">:compile_time_application</code> - sets the <code class=\"inline\">:application</code> metadata value to the configured value at compilation time. This configuration is usually only useful for build tools to automatically add the application to the metadata for <a href=\"logger#debug/2\"><code class=\"inline\">Logger.debug/2</code></a>, <a href=\"logger#info/2\"><code class=\"inline\">Logger.info/2</code></a>, etc. style of calls. </li> </ul> <p>For example, to configure the <code class=\"inline\">:backends</code> and <code class=\"inline\">compile_time_purge_level</code> options in a <code class=\"inline\">config/config.exs</code> file:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :logger,\n  backends: [:console],\n  compile_time_purge_level: :info</code></pre> <h3>Runtime Configuration</h3> <p>All configuration below can be set via config files (e.g., <code class=\"inline\">config/config.exs</code>) but also changed dynamically during runtime via <a href=\"logger#configure/1\"><code class=\"inline\">Logger.configure/1</code></a>.</p> <ul> <li>\n<p><code class=\"inline\">:level</code> - the logging level. Attempting to log any message with severity less than the configured level will simply cause the message to be ignored. Keep in mind that each backend may have its specific level, too. Note that, unlike what happens with the <code class=\"inline\">:compile_time_purge_level</code> option, the argument passed to <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> calls is evaluated even if the level of the call is lower than <code class=\"inline\">:level</code>.</p> </li> <li>\n<p><code class=\"inline\">:utc_log</code> - when <code class=\"inline\">true</code>, uses UTC in logs. By default it uses local time (i.e., it defaults to <code class=\"inline\">false</code>).</p> </li> <li>\n<p><code class=\"inline\">:truncate</code> - the maximum message size to be logged (in bytes). Defaults to 8192 bytes. Note this configuration is approximate. Truncated messages will have <code class=\"inline\">\" (truncated)\"</code> at the end. The atom <code class=\"inline\">:infinity</code> can be passed to disable this behavior.</p> </li> <li>\n<p><code class=\"inline\">:sync_threshold</code> - if the <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> manager has more than <code class=\"inline\">:sync_threshold</code> messages in its queue, <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> will change to <em>sync mode</em>, to apply backpressure to the clients. <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> will return to <em>async mode</em> once the number of messages in the queue is reduced to <code class=\"inline\">sync_threshold * 0.75</code> messages. Defaults to 20 messages.</p> </li> <li>\n<code class=\"inline\">:translator_inspect_opts</code> - when translating OTP reports and errors, the last message and state must be inspected in the error reports. This configuration allow developers to change how much and how the data should be inspected. </li> </ul> <p>For example, to configure the <code class=\"inline\">:level</code> and <code class=\"inline\">:truncate</code> options in a <code class=\"inline\">config/config.exs</code> file:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :logger,\n  level: :warn,\n  truncate: 4096</code></pre> <h3>Error Logger configuration</h3> <p>The following configuration applies to <a href=\"logger#content\"><code class=\"inline\">Logger</code></a>’s wrapper around Erlang’s <code class=\"inline\">error_logger</code>. All the configurations below must be set before the <code class=\"inline\">:logger</code> application starts.</p> <ul> <li>\n<p><code class=\"inline\">:handle_otp_reports</code> - redirects OTP reports to <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> so they are formatted in Elixir terms. This uninstalls Erlang’s logger that prints terms to terminal. Defaults to <code class=\"inline\">true</code>.</p> </li> <li>\n<p><code class=\"inline\">:handle_sasl_reports</code> - redirects supervisor, crash and progress reports to <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> so they are formatted in Elixir terms. This uninstalls <code class=\"inline\">sasl</code>’s logger that prints these reports to the terminal. Defaults to <code class=\"inline\">false</code>.</p> </li> <li>\n<code class=\"inline\">:discard_threshold_for_error_logger</code> - a value that, when reached, triggers the error logger to discard messages. This value must be a positive number that represents the maximum number of messages accepted per second. Once above this threshold, the <code class=\"inline\">error_logger</code> enters discard mode for the remainder of that second. Defaults to 500 messages. </li> </ul> <p>For example, to configure <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> to redirect all <code class=\"inline\">error_logger</code> messages using a <code class=\"inline\">config/config.exs</code> file:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :logger,\n  handle_otp_reports: true,\n  handle_sasl_reports: true</code></pre> <p>Furthermore, <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> allows messages sent by Erlang’s <code class=\"inline\">error_logger</code> to be translated into an Elixir format via translators. Translators can be dynamically added at any time with the <a href=\"#add_translator/1\"><code class=\"inline\">add_translator/1</code></a> and <a href=\"#remove_translator/1\"><code class=\"inline\">remove_translator/1</code></a> APIs. Check <a href=\"logger.translator\"><code class=\"inline\">Logger.Translator</code></a> for more information.</p> <h2 id=\"module-backends\" class=\"section-heading\">  Backends </h2> <p><a href=\"logger#content\"><code class=\"inline\">Logger</code></a> supports different backends where log messages are written to.</p> <p>The available backends by default are:</p> <ul> <li>\n<code class=\"inline\">:console</code> - logs messages to the console (enabled by default) </li> </ul> <p>Developers may also implement their own backends, an option that is explored in more detail below.</p> <p>The initial backends are loaded via the <code class=\"inline\">:backends</code> configuration, which must be set before the <code class=\"inline\">:logger</code> application is started.</p> <h3>Console backend</h3> <p>The console backend logs messages by printing them to the console. It supports the following options:</p> <ul> <li>\n<p><code class=\"inline\">:level</code> - the level to be logged by this backend. Note that messages are filtered by the general <code class=\"inline\">:level</code> configuration for the <code class=\"inline\">:logger</code> application first.</p> </li> <li>\n<p><code class=\"inline\">:format</code> - the format message used to print logs. Defaults to: <code class=\"inline\">\"$time $metadata[$level] $levelpad$message\\n\"</code>.</p> </li> <li>\n<p><code class=\"inline\">:metadata</code> - the metadata to be printed by <code class=\"inline\">$metadata</code>. Defaults to an empty list (no metadata).</p> </li> <li>\n<p><code class=\"inline\">:colors</code> - a keyword list of coloring options.</p> </li> <li>\n<code class=\"inline\">:max_buffer</code> - maximum events to buffer while waiting for a confirmation from the IO device (default: 32). Once the buffer is full, the backend will block until a confirmation is received. </li> </ul> <p>In addition to the keys provided by the user via <a href=\"logger#metadata/1\"><code class=\"inline\">Logger.metadata/1</code></a>, the following default keys are available in the <code class=\"inline\">:metadata</code> list:</p> <ul> <li>\n<p><code class=\"inline\">:application</code> - the current application</p> </li> <li>\n<p><code class=\"inline\">:module</code> - the current module</p> </li> <li>\n<p><code class=\"inline\">:function</code> - the current function</p> </li> <li>\n<p><code class=\"inline\">:file</code> - the current file</p> </li> <li>\n<code class=\"inline\">:line</code> - the current line </li> </ul> <p>The supported keys in the <code class=\"inline\">:colors</code> keyword list are:</p> <ul> <li>\n<p><code class=\"inline\">:enabled</code> - boolean value that allows for switching the coloring on and off. Defaults to: <code class=\"inline\">IO.ANSI.enabled?</code></p> </li> <li>\n<p><code class=\"inline\">:debug</code> - color for debug messages. Defaults to: <code class=\"inline\">:cyan</code></p> </li> <li>\n<p><code class=\"inline\">:info</code> - color for info messages. Defaults to: <code class=\"inline\">:normal</code></p> </li> <li>\n<p><code class=\"inline\">:warn</code> - color for warn messages. Defaults to: <code class=\"inline\">:yellow</code></p> </li> <li>\n<code class=\"inline\">:error</code> - color for error messages. Defaults to: <code class=\"inline\">:red</code> </li> </ul> <p>See the <code class=\"inline\">IO.ANSI</code> module for a list of colors and attributes.</p> <p>Here is an example of how to configure the <code class=\"inline\">:console</code> backend in a <code class=\"inline\">config/config.exs</code> file:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :logger, :console,\n  format: \"\\n$time $metadata[$level] $levelpad$message\\n\"\n  metadata: [:user_id]</code></pre> <p>You can read more about formatting in <a href=\"logger.formatter\"><code class=\"inline\">Logger.Formatter</code></a>.</p> <h3>Custom backends</h3> <p>Any developer can create their own <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> backend. Since <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> is an event manager powered by <code class=\"inline\">GenEvent</code>, writing a new backend is a matter of creating an event handler, as described in the <code class=\"inline\">GenEvent</code> module.</p> <p>From now on, we will be using the term “event handler” to refer to your custom backend, as we head into implementation details.</p> <p>Once the <code class=\"inline\">:logger</code> application starts, it installs all event handlers listed under the <code class=\"inline\">:backends</code> configuration into the <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> event manager. The event manager and all added event handlers are automatically supervised by <a href=\"logger#content\"><code class=\"inline\">Logger</code></a>.</p> <p>Once initialized, the handler should be designed to handle events in the following format:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{level, group_leader, {Logger, message, timestamp, metadata}} | :flush</code></pre> <p>where:</p> <ul> <li>\n<code class=\"inline\">level</code> is one of <code class=\"inline\">:debug</code>, <code class=\"inline\">:info</code>, <code class=\"inline\">:warn</code>, or <code class=\"inline\">:error</code>, as previously described </li> <li>\n<code class=\"inline\">group_leader</code> is the group leader of the process which logged the message </li> <li>\n<p><code class=\"inline\">{Logger, message, timestamp, metadata}</code> is a tuple containing information about the logged message:</p> <ul> <li>the first element is always the atom <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> </li> <li>\n<code class=\"inline\">message</code> is the actual message (as chardata) </li> <li>\n<code class=\"inline\">timestamp</code> is the timestamp for when the message was logged, as a <code class=\"inline\">{{year, month, day}, {hour, minute, second, milliseconds}}</code> tuple </li> <li>\n<code class=\"inline\">metadata</code> is a keyword list of metadata used when logging the message </li> </ul> </li> </ul> <p>It is recommended that handlers ignore messages where the group leader is in a different node than the one where the handler is installed. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def handle_event({_level, gl, {Logger, _, _, _}}, state)\n    when node(gl) != node() do\n  {:ok, state}\nend</code></pre> <p>In the case of the event <code class=\"inline\">:flush</code> handlers should flush any pending data. This event is triggered by <a href=\"#flush/0\"><code class=\"inline\">flush/0</code></a>.</p> <p>Furthermore, backends can be configured via the <a href=\"#configure_backend/2\"><code class=\"inline\">configure_backend/2</code></a> function which requires event handlers to handle calls of the following format:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:configure, options}</code></pre> <p>where <code class=\"inline\">options</code> is a keyword list. The result of the call is the result returned by <a href=\"#configure_backend/2\"><code class=\"inline\">configure_backend/2</code></a>. The recommended return value for successful configuration is <code class=\"inline\">:ok</code>.</p> <p>It is recommended that backends support at least the following configuration options:</p> <ul> <li>\n<code class=\"inline\">:level</code> - the logging level for that backend </li> <li>\n<code class=\"inline\">:format</code> - the logging format for that backend </li> <li>\n<code class=\"inline\">:metadata</code> - the metadata to include in that backend </li> </ul> <p>Check the implementation for <code class=\"inline\">Logger.Backends.Console</code>, for examples on how to handle the recommendations in this section and how to process the existing options.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:backend/0\">backend()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:level/0\">level()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:message/0\">message()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#add_backend/2\">add_backend(backend, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds a new backend</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#add_translator/1\">add_translator(translator)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds a new translator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#bare_log/3\">bare_log(level, chardata_or_fn, metadata \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Logs a message dynamically</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compare_levels/2\">compare_levels(level, level)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compares log levels</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#configure/1\">configure(options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Configures the logger</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#configure_backend/2\">configure_backend(backend, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Configures the given backend</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#disable/1\">disable(pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Disables logging for the current process</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#enable/1\">enable(pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Enables logging for the current process</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#flush/0\">flush()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Flushes the Logger</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#level/0\">level()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Retrieves the Logger level</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#metadata/0\">metadata()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reads the current process metadata</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#metadata/1\">metadata(keywords)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds the given keyword list to the current process metadata</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#remove_backend/2\">remove_backend(backend, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes a backend</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#remove_translator/1\">remove_translator(translator)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes a translator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reset_metadata/1\">reset_metadata(keywords \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Resets the current process metadata to the given keyword list</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#debug/2\">debug(chardata_or_fn, metadata \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Logs a debug message</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#error/2\">error(chardata_or_fn, metadata \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Logs an error</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#info/2\">info(chardata_or_fn, metadata \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Logs some info</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#log/3\">log(level, chardata_or_fn, metadata \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Logs a message</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#warn/2\">warn(chardata_or_fn, metadata \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Logs a warning</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:backend/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:backend/0\">backend</a> :: <a href=\"../elixir/genevent#t:handler/0\">GenEvent.handler</a></code></pre> </div> <div id=\"t:level/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:level/0\">level</a> :: :error | :info | :warn | :debug</code></pre> </div> <div id=\"t:message/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:message/0\">message</a> :: <a href=\"../elixir/io#t:chardata/0\">IO.chardata</a> | <a href=\"../elixir/string.chars#t:t/0\">String.Chars.t</a></code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"add_backend/2\">  <span class=\"signature\">add_backend(backend, opts \\\\ [])</span>  </h3>  <p>Adds a new backend.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:flush</code> - when <code class=\"inline\">true</code>, guarantees all messages currently sent to both Logger and Erlang’s <code class=\"inline\">error_logger</code> are processed before the backend is added </li> </ul>    <h3 class=\"detail-header function\" id=\"add_translator/1\">  <span class=\"signature\">add_translator(translator)</span>  </h3>  <p>Adds a new translator.</p>    <h3 class=\"detail-header function\" id=\"bare_log/3\">  <span class=\"signature\">bare_log(level, chardata_or_fn, metadata \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">bare_log(<a href=\"#t:level/0\">level</a>, <a href=\"#t:message/0\">message</a> | (() -&gt; <a href=\"#t:message/0\">message</a>), <a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) ::\n  :ok |\n  {:error, :noproc} |\n  {:error, term}</code></pre>    <p>Logs a message dynamically.</p> <p>Use this function only when there is a need to explicitly avoid embedding metadata.</p>    <h3 class=\"detail-header function\" id=\"compare_levels/2\">  <span class=\"signature\">compare_levels(level, level)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">compare_levels(<a href=\"#t:level/0\">level</a>, <a href=\"#t:level/0\">level</a>) :: :lt | :eq | :gt</code></pre>    <p>Compares log levels.</p> <p>Receives two log levels and compares the <code class=\"inline\">left</code> against <code class=\"inline\">right</code> and returns <code class=\"inline\">:lt</code>, <code class=\"inline\">:eq</code> or <code class=\"inline\">:gt</code>.</p>    <h3 class=\"detail-header function\" id=\"configure/1\">  <span class=\"signature\">configure(options)</span>  </h3>  <p>Configures the logger.</p> <p>See the “Runtime Configuration” section in <a href=\"logger#content\"><code class=\"inline\">Logger</code></a> module documentation for the available options.</p>    <h3 class=\"detail-header function\" id=\"configure_backend/2\">  <span class=\"signature\">configure_backend(backend, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">configure_backend(<a href=\"#t:backend/0\">backend</a>, <a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: term</code></pre>    <p>Configures the given backend.</p> <p>The backend needs to be started and running in order to be configured at runtime.</p>    <h3 class=\"detail-header function\" id=\"disable/1\">  <span class=\"signature\">disable(pid)</span>  </h3>  <p>Disables logging for the current process.</p> <p>Currently the only accepted process is self().</p>    <h3 class=\"detail-header function\" id=\"enable/1\">  <span class=\"signature\">enable(pid)</span>  </h3>  <p>Enables logging for the current process.</p> <p>Currently the only accepted process is self().</p>    <h3 class=\"detail-header function\" id=\"flush/0\">  <span class=\"signature\">flush()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">flush :: :ok</code></pre>    <p>Flushes the Logger.</p> <p>This basically guarantees all messages sent to the Logger prior to this call will be processed. This is useful for testing and it should not be called in production code.</p>    <h3 class=\"detail-header function\" id=\"level/0\">  <span class=\"signature\">level()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:level/0\">level</a> :: <a href=\"#t:level/0\">level</a></code></pre>    <p>Retrieves the Logger level.</p> <p>The Logger level can be changed via <a href=\"#configure/1\"><code class=\"inline\">configure/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"metadata/0\">  <span class=\"signature\">metadata()</span>  </h3>  <p>Reads the current process metadata.</p>    <h3 class=\"detail-header function\" id=\"metadata/1\">  <span class=\"signature\">metadata(keywords)</span>  </h3>  <p>Adds the given keyword list to the current process metadata.</p>    <h3 class=\"detail-header function\" id=\"remove_backend/2\">  <span class=\"signature\">remove_backend(backend, opts \\\\ [])</span>  </h3>  <p>Removes a backend.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:flush</code> - when <code class=\"inline\">true</code>, guarantees all messages currently sent to both Logger and Erlang’s <code class=\"inline\">error_logger</code> are processed before the backend is removed </li> </ul>    <h3 class=\"detail-header function\" id=\"remove_translator/1\">  <span class=\"signature\">remove_translator(translator)</span>  </h3>  <p>Removes a translator.</p>    <h3 class=\"detail-header function\" id=\"reset_metadata/1\">  <span class=\"signature\">reset_metadata(keywords \\\\ [])</span>  </h3>  <p>Resets the current process metadata to the given keyword list.</p>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"debug/2\">  <span class=\"signature\">debug(chardata_or_fn, metadata \\\\ [])</span>  </h3>  <p>Logs a debug message.</p> <p>Returns the atom <code class=\"inline\">:ok</code> or an <code class=\"inline\">{:error, reason}</code> tuple.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Logger.debug \"hello?\"\nLogger.debug fn -&gt; \"expensive to calculate debug\" end</code></pre>    <h3 class=\"detail-header macro\" id=\"error/2\">  <span class=\"signature\">error(chardata_or_fn, metadata \\\\ [])</span>  </h3>  <p>Logs an error.</p> <p>Returns the atom <code class=\"inline\">:ok</code> or an <code class=\"inline\">{:error, reason}</code> tuple.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Logger.error \"oops\"\nLogger.error fn -&gt; \"expensive to calculate error\" end</code></pre>    <h3 class=\"detail-header macro\" id=\"info/2\">  <span class=\"signature\">info(chardata_or_fn, metadata \\\\ [])</span>  </h3>  <p>Logs some info.</p> <p>Returns the atom <code class=\"inline\">:ok</code> or an <code class=\"inline\">{:error, reason}</code> tuple.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Logger.info \"mission accomplished\"\nLogger.info fn -&gt; \"expensive to calculate info\" end</code></pre>    <h3 class=\"detail-header macro\" id=\"log/3\">  <span class=\"signature\">log(level, chardata_or_fn, metadata \\\\ [])</span>  </h3>  <p>Logs a message.</p> <p>Returns the atom <code class=\"inline\">:ok</code> or an <code class=\"inline\">{:error, reason}</code> tuple.</p> <p>Developers should use the macros <a href=\"logger#debug/2\"><code class=\"inline\">Logger.debug/2</code></a>, <a href=\"logger#warn/2\"><code class=\"inline\">Logger.warn/2</code></a>, <a href=\"logger#info/2\"><code class=\"inline\">Logger.info/2</code></a> or <a href=\"logger#error/2\"><code class=\"inline\">Logger.error/2</code></a> instead of this macro as they can automatically eliminate the Logger call altogether at compile time if desired.</p>    <h3 class=\"detail-header macro\" id=\"warn/2\">  <span class=\"signature\">warn(chardata_or_fn, metadata \\\\ [])</span>  </h3>  <p>Logs a warning.</p> <p>Returns the atom <code class=\"inline\">:ok</code> or an <code class=\"inline\">{:error, reason}</code> tuple.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Logger.warn \"knob turned too far to the right\"\nLogger.warn fn -&gt; \"expensive to calculate warning\" end</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/logger/Logger.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/logger/Logger.html</a>\n  </p>\n</div>\n","elixir/atom":"<h1>  Atom  </h1>  <p>Convenience functions for working with atoms.</p> <p>See also <a href=\"kernel#is_atom/1\"><code class=\"inline\">Kernel.is_atom/1</code></a>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#to_charlist/1\">to_charlist(atom)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an atom to a charlist</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(atom)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an atom to a string</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"to_charlist/1\">  <span class=\"signature\">to_charlist(atom)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_charlist(atom) :: charlist</code></pre>    <p>Converts an atom to a charlist.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Atom.to_charlist(:\"An atom\")\n'An atom'</code></pre>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(atom)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_string(atom) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts an atom to a string.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Atom.to_string(:foo)\n\"foo\"</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Atom.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Atom.html</a>\n  </p>\n</div>\n","elixir/access":"<h1>  Access <small>behaviour</small>  </h1>  <p>Key-based access to data structures using the <code class=\"inline\">data[key]</code> syntax.</p> <p>Elixir provides two syntaxes for accessing values. <code class=\"inline\">user[:name]</code> is used by dynamic structures, like maps and keywords, while <code class=\"inline\">user.name</code> is used by structs. The main difference is that <code class=\"inline\">user[:name]</code> won’t raise if the key <code class=\"inline\">:name</code> is missing but <code class=\"inline\">user.name</code> will raise if there is no <code class=\"inline\">:name</code> key.</p> <p>Besides the cases above, this module provides convenience functions for accessing other structures, like <a href=\"#at/1\"><code class=\"inline\">at/1</code></a> for lists and <a href=\"#elem/1\"><code class=\"inline\">elem/1</code></a> for tuples. Those functions can be used by the nested update functions in <a href=\"kernel\"><code class=\"inline\">Kernel</code></a>, such as <a href=\"kernel#get_in/2\"><code class=\"inline\">Kernel.get_in/2</code></a>, <a href=\"kernel#put_in/3\"><code class=\"inline\">Kernel.put_in/3</code></a>, <a href=\"kernel#update_in/3\"><code class=\"inline\">Kernel.update_in/3</code></a>, <a href=\"kernel#get_and_update_in/3\"><code class=\"inline\">Kernel.get_and_update_in/3</code></a> and friends.</p> <h2 id=\"module-dynamic-lookups\" class=\"section-heading\">  Dynamic lookups </h2> <p>Out of the box, Access works with <a href=\"keyword\"><code class=\"inline\">Keyword</code></a> and <a href=\"map\"><code class=\"inline\">Map</code></a>:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; keywords = [a: 1, b: 2]\niex&gt; keywords[:a]\n1\n\niex&gt; map = %{a: 1, b: 2}\niex&gt; map[:a]\n1\n\niex&gt; star_ratings = %{1.0 =&gt; \"★\", 1.5 =&gt; \"★☆\", 2.0 =&gt; \"★★\"}\niex&gt; star_ratings[1.5]\n\"★☆\"</code></pre> <p>Access can be combined with <a href=\"kernel#put_in/3\"><code class=\"inline\">Kernel.put_in/3</code></a> to put a value in a given key:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; map = %{a: 1, b: 2}\niex&gt; put_in map[:a], 3\n%{a: 3, b: 2}</code></pre> <p>This syntax is very convenient as it can be nested arbitrarily:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; put_in users[\"john\"][:age], 28\n%{\"john\" =&gt; %{age: 28}, \"meg\" =&gt; %{age: 23}}</code></pre> <p>Furthermore, Access transparently ignores <code class=\"inline\">nil</code> values:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; keywords = [a: 1, b: 2]\niex&gt; keywords[:c][:unknown]\nnil</code></pre> <p>Since Access is a behaviour, it can be implemented to key-value data structures. The implementation should be added to the module that defines the struct being access. Access requires the key comparison to be implemented using the <code class=\"inline\">===</code> operator.</p> <h2 id=\"module-static-lookups\" class=\"section-heading\">  Static lookups </h2> <p>The Access syntax (<code class=\"inline\">foo[bar]</code>) cannot be used to access fields in structs, since structs do not implement the Access behaviour by default. It is also design decision: the dynamic access lookup is meant to be used for dynamic key-value structures, like maps and keywords, and not by static ones like structs.</p> <p>Therefore Elixir provides a static lookup for map and structs fields. Imagine a struct named <code class=\"inline\">User</code> with name and age fields. The following would raise:</p> <pre data-language=\"elixir\"><code class=\"elixir\">user = %User{name: \"john\"}\nuser[:name]\n** (UndefinedFunctionError) undefined function User.fetch/2\n   (User does not implement the Access behaviour)</code></pre> <p>Structs instead use the <code class=\"inline\">user.name</code> syntax:</p> <pre data-language=\"elixir\"><code class=\"elixir\">user.name\n#=&gt; \"john\"</code></pre> <p>The same <code class=\"inline\">user.name</code> syntax can also be used by <a href=\"kernel#put_in/2\"><code class=\"inline\">Kernel.put_in/2</code></a> to for updating structs fields:</p> <pre data-language=\"elixir\"><code class=\"elixir\">put_in user.name, \"mary\"\n%User{name: \"mary\"}</code></pre> <p>Differently from <code class=\"inline\">user[:name]</code>, <code class=\"inline\">user.name</code> is not extensible via a behaviour and is restricted to only maps and structs.</p> <p>Summing up:</p> <ul> <li>\n<code class=\"inline\">user[:name]</code> is used by dynamic structures, is extensible and does not raise on missing keys </li> <li>\n<code class=\"inline\">user.name</code> is used by static structures, it is not extensible and it will raise on missing keys </li> </ul> <h2 id=\"module-accessors\" class=\"section-heading\">  Accessors </h2> <p>While Elixir provides built-in syntax only for traversing dynamic and static key-value structures, this module provides convenience functions for traversing other structures, like tuples and lists, to be used alongside <a href=\"kernel#put_in/2\"><code class=\"inline\">Kernel.put_in/2</code></a> in others.</p> <p>For instance, given a user with a list of languages, here is how to deeply traverse the map and convert all language names to uppercase:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; user = %{name: \"john\",\n...&gt;          languages: [%{name: \"elixir\", type: :functional},\n...&gt;                      %{name: \"c\", type: :procedural}]}\niex&gt; update_in user, [:languages, Access.all(), :name], &amp;String.upcase/1\n%{name: \"john\",\n  languages: [%{name: \"ELIXIR\", type: :functional},\n              %{name: \"C\", type: :procedural}]}</code></pre> <p>See the functions <code class=\"inline\">key/1</code>, <a href=\"#key!/1\"><code class=\"inline\">key!/1</code></a>, <a href=\"#elem/1\"><code class=\"inline\">elem/1</code></a> and <a href=\"#all/0\"><code class=\"inline\">all/0</code></a> for the current accessors.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:key/0\">key()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:value/0\">value()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#all/0\">all()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Accesses all the elements in a list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#at/1\">at(index)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Accesses the element at <code class=\"inline\">index</code> (zero based) of a list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#elem/1\">elem(index)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Accesses the element at the given index in a tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch/2\">fetch(container, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches the container’s value for the given key</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get/3\">get(container, key, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the container’s value for the given key</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_and_update/3\">get_and_update(container, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets and updates the container’s value for the given key, in a single pass</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#key/2\">key(key, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Accesses the given key in a map/struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#key!/1\">key!(key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Accesses the given key in a map/struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pop/2\">pop(container, key)</a> </dt>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:fetch/2\">fetch(t, key)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:get/3\">get(t, key, value)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:get_and_update/3\">get_and_update(t, key, list)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:pop/2\">pop(t, key)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:key/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:key/0\">key</a> :: any</code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: list | map | nil</code></pre> </div> <div id=\"t:value/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:value/0\">value</a> :: any</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"all/0\">  <span class=\"signature\">all()</span>  </h3>  <p>Accesses all the elements in a list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; list = [%{name: \"john\"}, %{name: \"mary\"}]\niex&gt; get_in(list, [Access.all(), :name])\n[\"john\", \"mary\"]\niex&gt; get_and_update_in(list, [Access.all(), :name], fn\n...&gt;   prev -&gt; {prev, String.upcase(prev)}\n...&gt; end)\n{[\"john\", \"mary\"], [%{name: \"JOHN\"}, %{name: \"MARY\"}]}\niex&gt; pop_in(list, [Access.all(), :name])\n{[\"john\", \"mary\"], [%{}, %{}]}</code></pre> <p>Here is an example that traverses the list dropping even numbers and multipling odd numbers by 2:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; require Integer\niex&gt; get_and_update_in([1, 2, 3, 4, 5], [Access.all], fn\n...&gt;   num -&gt; if Integer.is_even(num), do: :pop, else: {num, num * 2}\n...&gt; end)\n{[1, 2, 3, 4, 5], [2, 6, 10]}</code></pre> <p>An error is raised if the accessed structure is not a list:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; get_in(%{}, [Access.all()])\n** (RuntimeError) Access.all/0 expected a list, got: %{}</code></pre>    <h3 class=\"detail-header function\" id=\"at/1\">  <span class=\"signature\">at(index)</span>  </h3>  <p>Accesses the element at <code class=\"inline\">index</code> (zero based) of a list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; list = [%{name: \"john\"}, %{name: \"mary\"}]\niex&gt; get_in(list, [Access.at(1), :name])\n\"mary\"\niex&gt; get_and_update_in(list, [Access.at(0), :name], fn\n...&gt;   prev -&gt; {prev, String.upcase(prev)}\n...&gt; end)\n{\"john\", [%{name: \"JOHN\"}, %{name: \"mary\"}]}</code></pre> <p><a href=\"#at/1\"><code class=\"inline\">at/1</code></a> can also be used to pop elements out of a list or a key inside of a list:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; list = [%{name: \"john\"}, %{name: \"mary\"}]\niex&gt; pop_in(list, [Access.at(0)])\n{%{name: \"john\"}, [%{name: \"mary\"}]}\niex&gt; pop_in(list, [Access.at(0), :name])\n{\"john\", [%{}, %{name: \"mary\"}]}</code></pre> <p>When the index is out of bounds, <code class=\"inline\">nil</code> is returned and the update function is never called:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; list = [%{name: \"john\"}, %{name: \"mary\"}]\niex&gt; get_in(list, [Access.at(10), :name])\nnil\niex&gt; get_and_update_in(list, [Access.at(10), :name], fn\n...&gt;   prev -&gt; {prev, String.upcase(prev)}\n...&gt; end)\n{nil, [%{name: \"john\"}, %{name: \"mary\"}]}</code></pre> <p>An error is raised for negative indexes:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; get_in([], [Access.at(-1)])\n** (FunctionClauseError) no function clause matching in Access.at/1</code></pre> <p>An error is raised if the accessed structure is not a list:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; get_in(%{}, [Access.at(1)])\n** (RuntimeError) Access.at/1 expected a list, got: %{}</code></pre>    <h3 class=\"detail-header function\" id=\"elem/1\">  <span class=\"signature\">elem(index)</span>  </h3>  <p>Accesses the element at the given index in a tuple.</p> <p>Raises if the index is out of bounds.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; map = %{user: {\"john\", 27}}\niex&gt; get_in(map, [:user, Access.elem(0)])\n\"john\"\niex&gt; get_and_update_in(map, [:user, Access.elem(0)], fn\n...&gt;   prev -&gt; {prev, String.upcase(prev)}\n...&gt; end)\n{\"john\", %{user: {\"JOHN\", 27}}}\niex&gt; pop_in(map, [:user, Access.elem(0)])\n** (RuntimeError) cannot pop data from a tuple</code></pre> <p>An error is raised if the accessed structure is not a tuple:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; get_in(%{}, [Access.elem(0)])\n** (RuntimeError) Access.elem/1 expected a tuple, got: %{}</code></pre>    <h3 class=\"detail-header function\" id=\"fetch/2\">  <span class=\"signature\">fetch(container, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch(<a href=\"#t:t/0\">t</a>, term) :: {:ok, term} | :error</code></pre>    <p>Fetches the container’s value for the given key.</p>    <h3 class=\"detail-header function\" id=\"get/3\">  <span class=\"signature\">get(container, key, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get(<a href=\"#t:t/0\">t</a>, term, term) :: term</code></pre>    <p>Gets the container’s value for the given key.</p>    <h3 class=\"detail-header function\" id=\"get_and_update/3\">  <span class=\"signature\">get_and_update(container, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_and_update(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (<a href=\"#t:value/0\">value</a> -&gt; {get, <a href=\"#t:value/0\">value</a>})) :: {get, <a href=\"#t:t/0\">t</a>} when get: var</code></pre>    <p>Gets and updates the container’s value for the given key, in a single pass.</p> <p>This <code class=\"inline\">fun</code> argument receives the value of <code class=\"inline\">key</code> (or <code class=\"inline\">nil</code> if <code class=\"inline\">key</code> is not present) and must return a two-element tuple: the “get” value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class=\"inline\">key</code>. The <code class=\"inline\">fun</code> may also return <code class=\"inline\">:pop</code>, implying the current value shall be removed from the map and returned.</p> <p>The returned value is a tuple with the “get” value returned by <code class=\"inline\">fun</code> and a new map with the updated value under <code class=\"inline\">key</code>.</p>    <h3 class=\"detail-header function\" id=\"key/2\">  <span class=\"signature\">key(key, default \\\\ nil)</span>  </h3>  <p>Accesses the given key in a map/struct.</p> <p>Uses the default value if the key does not exist or if the value being accessed is <code class=\"inline\">nil</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; get_in(%{}, [Access.key(:unknown), Access.key(:name)])\nnil\niex&gt; get_in(%{}, [Access.key(:unknown, %{name: \"john\"}), Access.key(:name)])\n\"john\"\niex&gt; get_in(%{}, [Access.key(:unknown), Access.key(:name, \"john\")])\n\"john\"\n\niex&gt; map = %{user: %{name: \"john\"}}\niex&gt; get_in(map, [Access.key(:unknown), Access.key(:name, \"john\")])\n\"john\"\niex&gt; get_and_update_in(map, [Access.key(:user), Access.key(:name)], fn\n...&gt;   prev -&gt; {prev, String.upcase(prev)}\n...&gt; end)\n{\"john\", %{user: %{name: \"JOHN\"}}}\niex&gt; pop_in(map, [Access.key(:user), Access.key(:name)])\n{\"john\", %{user: %{}}}</code></pre> <p>An error is raised if the accessed structure is not a map/struct/nil:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; get_in([], [Access.key(:foo)])\n** (RuntimeError) Access.key/1 expected a map/struct or nil, got: []</code></pre>    <h3 class=\"detail-header function\" id=\"key!/1\">  <span class=\"signature\">key!(key)</span>  </h3>  <p>Accesses the given key in a map/struct.</p> <p>Raises if the key does not exist.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; map = %{user: %{name: \"john\"}}\niex&gt; get_in(map, [Access.key!(:user), Access.key!(:name)])\n\"john\"\niex&gt; get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], fn\n...&gt;   prev -&gt; {prev, String.upcase(prev)}\n...&gt; end)\n{\"john\", %{user: %{name: \"JOHN\"}}}\niex&gt; pop_in(map, [Access.key!(:user), Access.key!(:name)])\n{\"john\", %{user: %{}}}\niex&gt; get_in(map, [Access.key!(:user), Access.key!(:unknown)])\n** (KeyError) key :unknown not found in: %{name: \"john\"}</code></pre> <p>An error is raised if the accessed structure is not a map/struct:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; get_in([], [Access.key!(:foo)])\n** (RuntimeError) Access.key!/1 expected a map/struct, got: []</code></pre>    <h3 class=\"detail-header function\" id=\"pop/2\">  <span class=\"signature\">pop(container, key)</span>  </h3>      <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:fetch/2\">  <span class=\"signature\">fetch(t, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>) :: {:ok, <a href=\"#t:value/0\">value</a>} | :error</code></pre>       <h3 class=\"detail-header callback\" id=\"c:get/3\">  <span class=\"signature\">get(t, key, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: <a href=\"#t:value/0\">value</a></code></pre>       <h3 class=\"detail-header callback\" id=\"c:get_and_update/3\">  <span class=\"signature\">get_and_update(t, key, list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_and_update(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (<a href=\"#t:value/0\">value</a> -&gt; {<a href=\"#t:value/0\">value</a>, <a href=\"#t:value/0\">value</a>} | :pop)) :: {<a href=\"#t:value/0\">value</a>, <a href=\"#t:t/0\">t</a>}</code></pre>       <h3 class=\"detail-header callback\" id=\"c:pop/2\">  <span class=\"signature\">pop(t, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">pop(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>) :: {<a href=\"#t:value/0\">value</a>, <a href=\"#t:t/0\">t</a>}</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Access.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Access.html</a>\n  </p>\n</div>\n","elixir/agent":"<h1>  Agent  </h1>  <p>Agents are a simple abstraction around state.</p> <p>Often in Elixir there is a need to share or store state that must be accessed from different processes or by the same process at different points in time.</p> <p>The Agent module provides a basic server implementation that allows state to be retrieved and updated via a simple API.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <p>For example, in the Mix tool that ships with Elixir, we need to keep a set of all tasks executed by a given project. Since this set is shared, we can implement it with an Agent:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Mix.TasksServer do\n  def start_link do\n    Agent.start_link(fn -&gt; MapSet.new end, name: __MODULE__)\n  end\n\n  @doc \"Checks if the task has already executed\"\n  def executed?(task, project) do\n    item = {task, project}\n    Agent.get(__MODULE__, fn set -&gt;\n      item in set\n    end)\n  end\n\n  @doc \"Marks a task as executed\"\n  def put_task(task, project) do\n    item = {task, project}\n    Agent.update(__MODULE__, &amp;MapSet.put(&amp;1, item))\n  end\n\n  @doc \"Resets the executed tasks and returns the previous list of tasks\"\n  def take_all() do\n    Agent.get_and_update(__MODULE__, fn set -&gt;\n      {Enum.into(set, []), MapSet.new}\n    end)\n  end\nend</code></pre> <p>Note that agents still provide a segregation between the client and server APIs, as seen in GenServers. In particular, all code inside the function passed to the agent is executed by the agent. This distinction is important because you may want to avoid expensive operations inside the agent, as it will effectively block the agent until the request is fulfilled.</p> <p>Consider these two examples:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Compute in the agent/server\ndef get_something(agent) do\n  Agent.get(agent, fn state -&gt; do_something_expensive(state) end)\nend\n\n# Compute in the agent/client\ndef get_something(agent) do\n  Agent.get(agent, &amp;(&amp;1)) |&gt; do_something_expensive()\nend</code></pre> <p>The first function blocks the agent. The second function copies all the state to the client and then executes the operation in the client. The difference is whether the data is large enough to require processing in the server, at least initially, or small enough to be sent to the client cheaply.</p> <h2 id=\"module-name-registration\" class=\"section-heading\">  Name Registration </h2> <p>An Agent is bound to the same name registration rules as GenServers. Read more about it in the <a href=\"genserver\"><code class=\"inline\">GenServer</code></a> docs.</p> <h2 id=\"module-a-word-on-distributed-agents\" class=\"section-heading\">  A word on distributed agents </h2> <p>It is important to consider the limitations of distributed agents. Agents provide two APIs, one that works with anonymous functions and another that expects an explicit module, function, and arguments.</p> <p>In a distributed setup with multiple nodes, the API that accepts anonymous functions only works if the caller (client) and the agent have the same version of the caller module.</p> <p>Keep in mind this issue also shows up when performing “rolling upgrades” with agents. By rolling upgrades we mean the following situation: you wish to deploy a new version of your software by <em>shutting down</em> some of your nodes and replacing them with nodes running a new version of the software. In this setup, part of your environment will have one version of a given module and the other part another version (the newer one) of the same module.</p> <p>The best solution is to simply use the explicit module, function, and arguments APIs when working with distributed agents.</p> <h2 id=\"module-hot-code-swapping\" class=\"section-heading\">  Hot code swapping </h2> <p>An agent can have its code hot swapped live by simply passing a module, function, and args tuple to the update instruction. For example, imagine you have an agent named <code class=\"inline\">:sample</code> and you want to convert its inner state from some dict structure to a map. It can be done with the following instruction:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:update, :sample, {:advanced, {Enum, :into, [%{}]}}}</code></pre> <p>The agent’s state will be added to the given list as the first argument.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:agent/0\">agent()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The agent reference</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:name/0\">name()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The agent name</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:on_start/0\">on_start()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Return values of <code class=\"inline\">start*</code> functions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:state/0\">state()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The agent state</p> </dd>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#cast/2\">cast(agent, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Performs a cast (fire and forget) operation on the agent state</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cast/4\">cast(agent, module, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Performs a cast (fire and forget) operation on the agent state</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get/3\">get(agent, fun, timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets an agent value via the given function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get/5\">get(agent, module, fun, args, timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets an agent value via the given function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_and_update/3\">get_and_update(agent, fun, timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets and updates the agent state in one operation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_and_update/5\">get_and_update(agent, module, fun, args, timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets and updates the agent state in one operation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start/2\">start(fun, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts an agent process without links (outside of a supervision tree)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start/4\">start(module, fun, args, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts an agent with the given module function and arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/2\">start_link(fun, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts an agent linked to the current process with the given function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/4\">start_link(module, fun, args, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts an agent linked to the current process with the given module function and arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stop/3\">stop(agent, reason \\\\ :normal, timeout \\\\ :infinity)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stops the agent with the given <code class=\"inline\">reason</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update/3\">update(agent, fun, timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates the agent state</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update/5\">update(agent, module, fun, args, timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates the agent state</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:agent/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:agent/0\">agent</a> :: pid | {atom, node} | <a href=\"#t:name/0\">name</a></code></pre> <p>The agent reference</p>  </div> <div id=\"t:name/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:name/0\">name</a> ::\n  atom |\n  {:global, term} |\n  {:via, module, term}</code></pre> <p>The agent name</p>  </div> <div id=\"t:on_start/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:on_start/0\">on_start</a> ::\n  {:ok, pid} |\n  {:error, {:already_started, pid} | term}</code></pre> <p>Return values of <code class=\"inline\">start*</code> functions</p>  </div> <div id=\"t:state/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:state/0\">state</a> :: term</code></pre> <p>The agent state</p>  </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"cast/2\">  <span class=\"signature\">cast(agent, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cast(<a href=\"#t:agent/0\">agent</a>, (<a href=\"#t:state/0\">state</a> -&gt; <a href=\"#t:state/0\">state</a>)) :: :ok</code></pre>    <p>Performs a cast (fire and forget) operation on the agent state.</p> <p>The function <code class=\"inline\">fun</code> is sent to the <code class=\"inline\">agent</code> which invokes the function passing the agent state. The function must return the new state.</p> <p>Note that <code class=\"inline\">cast</code> returns <code class=\"inline\">:ok</code> immediately, regardless of whether the destination node or agent exists.</p>    <h3 class=\"detail-header function\" id=\"cast/4\">  <span class=\"signature\">cast(agent, module, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cast(<a href=\"#t:agent/0\">agent</a>, module, atom, [term]) :: :ok</code></pre>    <p>Performs a cast (fire and forget) operation on the agent state.</p> <p>Same as <a href=\"#cast/2\"><code class=\"inline\">cast/2</code></a> but a module, function and args are expected instead of an anonymous function. The state is added as first argument to the given list of args.</p>    <h3 class=\"detail-header function\" id=\"get/3\">  <span class=\"signature\">get(agent, fun, timeout \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get(<a href=\"#t:agent/0\">agent</a>, (<a href=\"#t:state/0\">state</a> -&gt; a), timeout) :: a when a: var</code></pre>    <p>Gets an agent value via the given function.</p> <p>The function <code class=\"inline\">fun</code> is sent to the <code class=\"inline\">agent</code> which invokes the function passing the agent state. The result of the function invocation is returned.</p> <p>A timeout can also be specified (it has a default value of 5000).</p>    <h3 class=\"detail-header function\" id=\"get/5\">  <span class=\"signature\">get(agent, module, fun, args, timeout \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get(<a href=\"#t:agent/0\">agent</a>, module, atom, [term], timeout) :: any</code></pre>    <p>Gets an agent value via the given function.</p> <p>Same as <a href=\"#get/3\"><code class=\"inline\">get/3</code></a> but a module, function and args are expected instead of an anonymous function. The state is added as first argument to the given list of args.</p>    <h3 class=\"detail-header function\" id=\"get_and_update/3\">  <span class=\"signature\">get_and_update(agent, fun, timeout \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_and_update(<a href=\"#t:agent/0\">agent</a>, (<a href=\"#t:state/0\">state</a> -&gt; {a, <a href=\"#t:state/0\">state</a>}), timeout) :: a when a: var</code></pre>    <p>Gets and updates the agent state in one operation.</p> <p>The function <code class=\"inline\">fun</code> is sent to the <code class=\"inline\">agent</code> which invokes the function passing the agent state. The function must return a tuple with two elements, the first being the value to return (i.e. the <code class=\"inline\">get</code> value) and the second one is the new state.</p> <p>A timeout can also be specified (it has a default value of 5000).</p>    <h3 class=\"detail-header function\" id=\"get_and_update/5\">  <span class=\"signature\">get_and_update(agent, module, fun, args, timeout \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_and_update(<a href=\"#t:agent/0\">agent</a>, module, atom, [term], timeout) :: any</code></pre>    <p>Gets and updates the agent state in one operation.</p> <p>Same as <a href=\"#get_and_update/3\"><code class=\"inline\">get_and_update/3</code></a> but a module, function and args are expected instead of an anonymous function. The state is added as first argument to the given list of args.</p>    <h3 class=\"detail-header function\" id=\"start/2\">  <span class=\"signature\">start(fun, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start((() -&gt; term), <a href=\"genserver#t:options/0\">GenServer.options</a>) :: <a href=\"#t:on_start/0\">on_start</a></code></pre>    <p>Starts an agent process without links (outside of a supervision tree).</p> <p>See <a href=\"#start_link/2\"><code class=\"inline\">start_link/2</code></a> for more information.</p>    <h3 class=\"detail-header function\" id=\"start/4\">  <span class=\"signature\">start(module, fun, args, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start(module, atom, [any], <a href=\"genserver#t:options/0\">GenServer.options</a>) :: <a href=\"#t:on_start/0\">on_start</a></code></pre>    <p>Starts an agent with the given module function and arguments.</p> <p>Similar to <a href=\"#start/2\"><code class=\"inline\">start/2</code></a> but a module, function and args are expected instead of an anonymous function.</p>    <h3 class=\"detail-header function\" id=\"start_link/2\">  <span class=\"signature\">start_link(fun, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_link((() -&gt; term), <a href=\"genserver#t:options/0\">GenServer.options</a>) :: <a href=\"#t:on_start/0\">on_start</a></code></pre>    <p>Starts an agent linked to the current process with the given function.</p> <p>This is often used to start the agent as part of a supervision tree.</p> <p>Once the agent is spawned, the given function is invoked and its return value is used as the agent state. Note that <code class=\"inline\">start_link</code> does not return until the given function has returned.</p> <h4>Options</h4> <p>The <code class=\"inline\">:name</code> option is used for registration as described in the module documentation.</p> <p>If the <code class=\"inline\">:timeout</code> option is present, the agent is allowed to spend at most the given number of milliseconds on initialization or it will be terminated and the start function will return <code class=\"inline\">{:error, :timeout}</code>.</p> <p>If the <code class=\"inline\">:debug</code> option is present, the corresponding function in the <a href=\"http://www.erlang.org/doc/man/sys.html\"><code class=\"inline\">:sys</code> module</a> will be invoked.</p> <p>If the <code class=\"inline\">:spawn_opt</code> option is present, its value will be passed as options to the underlying process as in <a href=\"process#spawn/4\"><code class=\"inline\">Process.spawn/4</code></a>.</p> <h4>Return values</h4> <p>If the server is successfully created and initialized, the function returns <code class=\"inline\">{:ok, pid}</code>, where <code class=\"inline\">pid</code> is the pid of the server. If an agent with the specified name already exists, the function returns <code class=\"inline\">{:error, {:already_started, pid}}</code> with the pid of that process.</p> <p>If the given function callback fails with <code class=\"inline\">reason</code>, the function returns <code class=\"inline\">{:error, reason}</code>.</p>    <h3 class=\"detail-header function\" id=\"start_link/4\">  <span class=\"signature\">start_link(module, fun, args, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_link(module, atom, [any], <a href=\"genserver#t:options/0\">GenServer.options</a>) :: <a href=\"#t:on_start/0\">on_start</a></code></pre>    <p>Starts an agent linked to the current process with the given module function and arguments.</p> <p>Same as <a href=\"#start_link/2\"><code class=\"inline\">start_link/2</code></a> but a module, function and args are expected instead of an anonymous function.</p>    <h3 class=\"detail-header function\" id=\"stop/3\">  <span class=\"signature\">stop(agent, reason \\\\ :normal, timeout \\\\ :infinity)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stop(<a href=\"#t:agent/0\">agent</a>, reason :: term, timeout) :: :ok</code></pre>    <p>Stops the agent with the given <code class=\"inline\">reason</code>.</p> <p>It returns <code class=\"inline\">:ok</code> if the server terminates with the given reason, if it terminates with another reason, the call will exit.</p> <p>This function keeps OTP semantics regarding error reporting. If the reason is any other than <code class=\"inline\">:normal</code>, <code class=\"inline\">:shutdown</code> or <code class=\"inline\">{:shutdown, _}</code>, an error report will be logged.</p>    <h3 class=\"detail-header function\" id=\"update/3\">  <span class=\"signature\">update(agent, fun, timeout \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update(<a href=\"#t:agent/0\">agent</a>, (<a href=\"#t:state/0\">state</a> -&gt; <a href=\"#t:state/0\">state</a>), timeout) :: :ok</code></pre>    <p>Updates the agent state.</p> <p>The function <code class=\"inline\">fun</code> is sent to the <code class=\"inline\">agent</code> which invokes the function passing the agent state. The function must return the new state.</p> <p>A timeout can also be specified (it has a default value of 5000). This function always returns <code class=\"inline\">:ok</code>.</p>    <h3 class=\"detail-header function\" id=\"update/5\">  <span class=\"signature\">update(agent, module, fun, args, timeout \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update(<a href=\"#t:agent/0\">agent</a>, module, atom, [term], timeout) :: :ok</code></pre>    <p>Updates the agent state.</p> <p>Same as <a href=\"#update/3\"><code class=\"inline\">update/3</code></a> but a module, function and args are expected instead of an anonymous function. The state is added as first argument to the given list of args.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Agent.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Agent.html</a>\n  </p>\n</div>\n","elixir/behaviour":"<h1>  Behaviour  </h1>  <p>This module has been deprecated.</p> <p>Instead of <code class=\"inline\">defcallback</code>, one can simply use <code class=\"inline\">@callback</code>. Instead of <code class=\"inline\">defmacrocallback</code>, one can simply use <code class=\"inline\">@macrocallback</code>. Instead of <code class=\"inline\">__behaviour__(:callbacks)</code>, one can simply use <code class=\"inline\">behaviour_info(:callbacks)</code>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#defcallback/1\">defcallback(spec)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a function callback according to the given type specification</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defmacrocallback/1\">defmacrocallback(spec)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a macro callback according to the given type specification</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"defcallback/1\">  <span class=\"signature\">defcallback(spec)</span>  </h3>  <p>Defines a function callback according to the given type specification.</p>    <h3 class=\"detail-header macro\" id=\"defmacrocallback/1\">  <span class=\"signature\">defmacrocallback(spec)</span>  </h3>  <p>Defines a macro callback according to the given type specification.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Behaviour.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Behaviour.html</a>\n  </p>\n</div>\n","elixir/bitwise":"<h1>  Bitwise  </h1>  <p>A set of macros that perform calculations on bits.</p> <p>The macros in this module come in two flavors: named or operators. For example:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; use Bitwise\niex&gt; bnot 1   # named\n-2\niex&gt; 1 &amp;&amp;&amp; 1  # operator\n1</code></pre> <p>If you prefer to use only operators or skip them, you can pass the following options:</p> <ul> <li>\n<code class=\"inline\">:only_operators</code> - include only operators </li> <li>\n<code class=\"inline\">:skip_operators</code> - skip operators </li> </ul> <p>For example:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; use Bitwise, only_operators: true\niex&gt; 1 &amp;&amp;&amp; 1\n1</code></pre> <p>When invoked with no options, <code class=\"inline\">use Bitwise</code> is equivalent to <code class=\"inline\">import Bitwise</code>.</p> <p>All bitwise macros can be used in guards:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; use Bitwise\niex&gt; odd? = fn int when band(int, 1) == 1 -&gt; true; _ -&gt; false end\niex&gt; odd?.(1)\ntrue</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#&amp;&amp;&amp;/2\">left &amp;&amp;&amp; right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Infix operator; calculates the bitwise AND of its arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%3C%3C%3C/2\">left &lt;&lt;&lt; right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Infix operator; calculates the result of an arithmetic left bitshift</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%3E%3E%3E/2\">left &gt;&gt;&gt; right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Infix operator; calculates the result of an arithmetic right bitshift</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%5E%5E%5E/2\">left ^^^ right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Infix operator; calculates the bitwise XOR of its arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#band/2\">band(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calculates the bitwise AND of its arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#bnot/1\">bnot(expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calculates the bitwise NOT of its argument</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#bor/2\">bor(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calculates the bitwise OR of its arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#bsl/2\">bsl(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calculates the result of an arithmetic left bitshift</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#bsr/2\">bsr(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calculates the result of an arithmetic right bitshift</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#bxor/2\">bxor(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calculates the bitwise XOR of its arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%7C%7C%7C/2\">left ||| right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Infix operator; calculates the bitwise OR of its arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#~~~/1\">~~~expr</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prefix (unary) operator; calculates the bitwise NOT of its argument</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"&amp;&amp;&amp;/2\">  <span class=\"signature\">left &amp;&amp;&amp; right</span>  </h3>  <p>Infix operator; calculates the bitwise AND of its arguments.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 9 &amp;&amp;&amp; 3\n1</code></pre>    <h3 class=\"detail-header macro\" id=\"%3C%3C%3C/2\">  <span class=\"signature\">left &lt;&lt;&lt; right</span>  </h3>  <p>Infix operator; calculates the result of an arithmetic left bitshift.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 &lt;&lt;&lt; 2\n4\niex&gt; 1 &lt;&lt;&lt; -2\n0\niex&gt; -1 &lt;&lt;&lt; 2\n-4\niex&gt; -1 &lt;&lt;&lt; -2\n-1</code></pre>    <h3 class=\"detail-header macro\" id=\"%3E%3E%3E/2\">  <span class=\"signature\">left &gt;&gt;&gt; right</span>  </h3>  <p>Infix operator; calculates the result of an arithmetic right bitshift.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 &gt;&gt;&gt; 2\n0\niex&gt; 1 &gt;&gt;&gt; -2\n4\niex&gt; -1 &gt;&gt;&gt; 2\n-1\niex&gt; -1 &gt;&gt;&gt; -2\n-4</code></pre>    <h3 class=\"detail-header macro\" id=\"%5E%5E%5E/2\">  <span class=\"signature\">left ^^^ right</span>  </h3>  <p>Infix operator; calculates the bitwise XOR of its arguments.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 9 ^^^ 3\n10</code></pre>    <h3 class=\"detail-header macro\" id=\"band/2\">  <span class=\"signature\">band(left, right)</span>  </h3>  <p>Calculates the bitwise AND of its arguments.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; band(9, 3)\n1</code></pre>    <h3 class=\"detail-header macro\" id=\"bnot/1\">  <span class=\"signature\">bnot(expr)</span>  </h3>  <p>Calculates the bitwise NOT of its argument.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; bnot(2)\n-3\niex&gt; bnot(2) &amp;&amp;&amp; 3\n1</code></pre>    <h3 class=\"detail-header macro\" id=\"bor/2\">  <span class=\"signature\">bor(left, right)</span>  </h3>  <p>Calculates the bitwise OR of its arguments.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; bor(9, 3)\n11</code></pre>    <h3 class=\"detail-header macro\" id=\"bsl/2\">  <span class=\"signature\">bsl(left, right)</span>  </h3>  <p>Calculates the result of an arithmetic left bitshift.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; bsl(1, 2)\n4\niex&gt; bsl(1, -2)\n0\niex&gt; bsl(-1, 2)\n-4\niex&gt; bsl(-1, -2)\n-1</code></pre>    <h3 class=\"detail-header macro\" id=\"bsr/2\">  <span class=\"signature\">bsr(left, right)</span>  </h3>  <p>Calculates the result of an arithmetic right bitshift.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; bsr(1, 2)\n0\niex&gt; bsr(1, -2)\n4\niex&gt; bsr(-1, 2)\n-1\niex&gt; bsr(-1, -2)\n-4</code></pre>    <h3 class=\"detail-header macro\" id=\"bxor/2\">  <span class=\"signature\">bxor(left, right)</span>  </h3>  <p>Calculates the bitwise XOR of its arguments.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; bxor(9, 3)\n10</code></pre>    <h3 class=\"detail-header macro\" id=\"%7C%7C%7C/2\">  <span class=\"signature\">left ||| right</span>  </h3>  <p>Infix operator; calculates the bitwise OR of its arguments.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 9 ||| 3\n11</code></pre>    <h3 class=\"detail-header macro\" id=\"~~~/1\">  <span class=\"signature\">~~~expr</span>  </h3>  <p>Prefix (unary) operator; calculates the bitwise NOT of its argument.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~~~2\n-3\niex&gt; ~~~2 &amp;&amp;&amp; 3\n1</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Bitwise.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Bitwise.html</a>\n  </p>\n</div>\n","elixir/calendar":"<h1>  Calendar <small>behaviour</small>  </h1>  <p>This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir.</p> <p>Currently it defines types and the minimal implementation for a calendar behaviour in Elixir. The goal of the Calendar features in Elixir is to provide a base for interoperatibility instead of full-featured datetime API.</p> <p>For the actual date, time and datetime structures, see <a href=\"date\"><code class=\"inline\">Date</code></a>, <a href=\"time\"><code class=\"inline\">Time</code></a>, <a href=\"naivedatetime\"><code class=\"inline\">NaiveDateTime</code></a> and <a href=\"datetime\"><code class=\"inline\">DateTime</code></a>.</p> <p>Note the year, month, day, etc designations are overspecified (i.e. an integer instead of 1..12 for months) because different calendars may have a different number of days per month, months per year and so on.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:calendar/0\">calendar()</a> </dt> <dd class=\"summary-synopsis\">\n<p>A calendar implementation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:day/0\">day()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:hour/0\">hour()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:microsecond/0\">microsecond()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Microseconds with stored precision</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:minute/0\">minute()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:month/0\">month()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:second/0\">second()</a> </dt> <dd class=\"summary-synopsis\">\n<p>From 0 to 60 to account for leap seconds</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:std_offset/0\">std_offset()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The time zone standard offset in seconds (not zero in summer times)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:time_zone/0\">time_zone()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The time zone ID according to the IANA tz database (e.g. Europe/Zurich)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:utc_offset/0\">utc_offset()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The time zone UTC offset in seconds</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:year/0\">year()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:zone_abbr/0\">zone_abbr()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The time zone abbreviation (e.g. CET or CEST or BST etc.)</p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:date/3\">date(year, month, day)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Builds a new date from proleptic year, month and day of month</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:leap_year?/1\">leap_year?(year)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns true if the given year is a leap year</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:to_string/1\">to_string(arg0)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given structure into a string according to the calendar</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:calendar/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:calendar/0\">calendar</a> :: module</code></pre> <p>A calendar implementation</p>  </div> <div id=\"t:day/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:day/0\">day</a> :: integer</code></pre> </div> <div id=\"t:hour/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:hour/0\">hour</a> :: 0..23</code></pre> </div> <div id=\"t:microsecond/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:microsecond/0\">microsecond</a> :: {0..999999, 0..6}</code></pre> <p>Microseconds with stored precision.</p> <p>The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0, it means microseconds must be skipped.</p>  </div> <div id=\"t:minute/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:minute/0\">minute</a> :: 0..59</code></pre> </div> <div id=\"t:month/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:month/0\">month</a> :: integer</code></pre> </div> <div id=\"t:second/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:second/0\">second</a> :: 0..60</code></pre> <p>From 0 to 60 to account for leap seconds</p>  </div> <div id=\"t:std_offset/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:std_offset/0\">std_offset</a> :: integer</code></pre> <p>The time zone standard offset in seconds (not zero in summer times)</p>  </div> <div id=\"t:time_zone/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:time_zone/0\">time_zone</a> :: <a href=\"string#t:t/0\">String.t</a></code></pre> <p>The time zone ID according to the IANA tz database (e.g. Europe/Zurich)</p>  </div> <div id=\"t:utc_offset/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:utc_offset/0\">utc_offset</a> :: integer</code></pre> <p>The time zone UTC offset in seconds</p>  </div> <div id=\"t:year/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:year/0\">year</a> :: integer</code></pre> </div> <div id=\"t:zone_abbr/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:zone_abbr/0\">zone_abbr</a> :: <a href=\"string#t:t/0\">String.t</a></code></pre> <p>The time zone abbreviation (e.g. CET or CEST or BST etc.)</p>  </div>    <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:date/3\">  <span class=\"signature\">date(year, month, day)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">date(<a href=\"#t:year/0\">year</a>, <a href=\"#t:month/0\">month</a>, <a href=\"#t:day/0\">day</a>) ::\n  {:ok, <a href=\"date#t:t/0\">Date.t</a>} |\n  {:error, atom}</code></pre>    <p>Builds a new date from proleptic year, month and day of month.</p>    <h3 class=\"detail-header callback\" id=\"c:leap_year?/1\">  <span class=\"signature\">leap_year?(year)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">leap_year?(<a href=\"#t:year/0\">year</a>) :: boolean</code></pre>    <p>Returns true if the given year is a leap year.</p> <p>A leap year is a year of a longer length than normal. The exact meaning is up to the calendar. A calendar must return <code class=\"inline\">false</code> if it does not support the concept of leap years.</p>    <h3 class=\"detail-header callback\" id=\"c:to_string/1\">  <span class=\"signature\">to_string(arg0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_string(<a href=\"date#t:t/0\">Date.t</a> | <a href=\"naivedatetime#t:t/0\">NaiveDateTime.t</a> | <a href=\"datetime#t:t/0\">DateTime.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts the given structure into a string according to the calendar.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Calendar.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Calendar.html</a>\n  </p>\n</div>\n","elixir/calendar.iso":"<h1>  Calendar.ISO  </h1>  <p>A calendar implementation that follows to ISO8601.</p> <p>This calendar implements the proleptic Gregorian calendar and is therefore compatible with the calendar used in most countries today. The proleptic means the Gregorian rules for leap years are applied for all time, consequently the dates give different results before the year 1583 from when the Gregorian calendar was adopted.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#date/3\">date(year, month, day)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Builds and validates an ISO date</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#leap_year?/1\">leap_year?(year)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns if the given year is a leap year</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(arg1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given structure into a string</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"date/3\">  <span class=\"signature\">date(year, month, day)</span>  </h3>  <p>Builds and validates an ISO date.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Calendar.ISO.date(2000, 1, 1)\n{:ok, ~D[2000-01-01]}\niex&gt; Calendar.ISO.date(2000, 13, 1)\n{:error, :invalid_date}\niex&gt; Calendar.ISO.date(2000, 2, 29)\n{:ok, ~D[2000-02-29]}\n\niex&gt; Calendar.ISO.date(2000, 2, 30)\n{:error, :invalid_date}\niex&gt; Calendar.ISO.date(2001, 2, 29)\n{:error, :invalid_date}</code></pre>    <h3 class=\"detail-header function\" id=\"leap_year?/1\">  <span class=\"signature\">leap_year?(year)</span>  </h3>  <p>Returns if the given year is a leap year.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Calendar.ISO.leap_year?(2000)\ntrue\niex&gt; Calendar.ISO.leap_year?(2001)\nfalse\niex&gt; Calendar.ISO.leap_year?(2004)\ntrue\niex&gt; Calendar.ISO.leap_year?(1900)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(arg1)</span>  </h3>  <p>Converts the given structure into a string.</p> <p>It uses the ISO8601 standard except for DateTime where the timezone information is added between brackets.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Calendar.ISO.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Calendar.ISO.html</a>\n  </p>\n</div>\n","elixir/enumerable":"<h1>  Enumerable <small>protocol</small>  </h1>  <p>Enumerable protocol used by <a href=\"enum\"><code class=\"inline\">Enum</code></a> and <a href=\"stream\"><code class=\"inline\">Stream</code></a> modules.</p> <p>When you invoke a function in the <a href=\"enum\"><code class=\"inline\">Enum</code></a> module, the first argument is usually a collection that must implement this protocol. For example, the expression:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Enum.map([1, 2, 3], &amp;(&amp;1 * 2))</code></pre> <p>invokes <a href=\"enumerable#reduce/3\"><code class=\"inline\">Enumerable.reduce/3</code></a> to perform the reducing operation that builds a mapped list by calling the mapping function <code class=\"inline\">&amp;(&amp;1 * 2)</code> on every element in the collection and consuming the element with an accumulated list.</p> <p>Internally, <a href=\"enum#map/2\"><code class=\"inline\">Enum.map/2</code></a> is implemented as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def map(enum, fun) do\n  reducer = fn x, acc -&gt; {:cont, [fun.(x) | acc]} end\n  Enumerable.reduce(enum, {:cont, []}, reducer) |&gt; elem(1) |&gt; :lists.reverse()\nend</code></pre> <p>Notice the user-supplied function is wrapped into a <code class=\"inline\">t:reducer/0</code> function. The <code class=\"inline\">t:reducer/0</code> function must return a tagged tuple after each step, as described in the <code class=\"inline\">t:acc/0</code> type.</p> <p>The reason the accumulator requires a tagged tuple is to allow the <code class=\"inline\">t:reducer/0</code> function to communicate the end of enumeration to the underlying enumerable, allowing any open resources to be properly closed. It also allows suspension of the enumeration, which is useful when interleaving between many enumerables is required (as in zip).</p> <p>Finally, <a href=\"enumerable#reduce/3\"><code class=\"inline\">Enumerable.reduce/3</code></a> will return another tagged tuple, as represented by the <code class=\"inline\">t:result/0</code> type.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:acc/0\">acc()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The accumulator value for each step</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:continuation/0\">continuation()</a> </dt> <dd class=\"summary-synopsis\">\n<p>A partially applied reduce function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:reducer/0\">reducer()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The reducer function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:result/0\">result()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The result of the reduce operation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#count/1\">count(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Retrieves the enumerable’s size</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#member?/2\">member?(enumerable, element)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if an element exists within the enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reduce/3\">reduce(enumerable, acc, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reduces the enumerable into an element</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:acc/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:acc/0\">acc</a> ::\n  {:cont, term} |\n  {:halt, term} |\n  {:suspend, term}</code></pre> <p>The accumulator value for each step.</p> <p>It must be a tagged tuple with one of the following “tags”:</p> <ul> <li>\n<code class=\"inline\">:cont</code> - the enumeration should continue </li> <li>\n<code class=\"inline\">:halt</code> - the enumeration should halt immediately </li> <li>\n<code class=\"inline\">:suspend</code> - the enumeration should be suspended immediately </li> </ul> <p>Depending on the accumulator value, the result returned by <a href=\"enumerable#reduce/3\"><code class=\"inline\">Enumerable.reduce/3</code></a> will change. Please check the <code class=\"inline\">t:result/0</code> type documentation for more information.</p> <p>In case a <code class=\"inline\">t:reducer/0</code> function returns a <code class=\"inline\">:suspend</code> accumulator, it must be explicitly handled by the caller and never leak.</p>  </div> <div id=\"t:continuation/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:continuation/0\">continuation</a> :: (<a href=\"#t:acc/0\">acc</a> -&gt; <a href=\"#t:result/0\">result</a>)</code></pre> <p>A partially applied reduce function.</p> <p>The continuation is the closure returned as a result when the enumeration is suspended. When invoked, it expects a new accumulator and it returns the result.</p> <p>A continuation is easily implemented as long as the reduce function is defined in a tail recursive fashion. If the function is tail recursive, all the state is passed as arguments, so the continuation would simply be the reducing function partially applied.</p>  </div> <div id=\"t:reducer/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:reducer/0\">reducer</a> :: (term, term -&gt; <a href=\"#t:acc/0\">acc</a>)</code></pre> <p>The reducer function.</p> <p>Should be called with the enumerable element and the accumulator contents.</p> <p>Returns the accumulator for the next enumeration step.</p>  </div> <div id=\"t:result/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:result/0\">result</a> ::\n  {:done, term} |\n  {:halted, term} |\n  {:suspended, term, <a href=\"#t:continuation/0\">continuation</a>}</code></pre> <p>The result of the reduce operation.</p> <p>It may be <em>done</em> when the enumeration is finished by reaching its end, or <em>halted</em>/<em>suspended</em> when the enumeration was halted or suspended by the <code class=\"inline\">t:reducer/0</code> function.</p> <p>In case a <code class=\"inline\">t:reducer/0</code> function returns the <code class=\"inline\">:suspend</code> accumulator, the <code class=\"inline\">:suspended</code> tuple must be explicitly handled by the caller and never leak. In practice, this means regular enumeration functions just need to be concerned about <code class=\"inline\">:done</code> and <code class=\"inline\">:halted</code> results.</p> <p>Furthermore, a <code class=\"inline\">:suspend</code> call must always be followed by another call, eventually halting or continuing until the end.</p>  </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: term</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"count/1\">  <span class=\"signature\">count(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">count(<a href=\"#t:t/0\">t</a>) :: {:ok, non_neg_integer} | {:error, module}</code></pre>    <p>Retrieves the enumerable’s size.</p> <p>It should return <code class=\"inline\">{:ok, size}</code>.</p> <p>If <code class=\"inline\">{:error, __MODULE__}</code> is returned a default algorithm using <code class=\"inline\">reduce</code> and the match (<code class=\"inline\">===</code>) operator is used. This algorithm runs in linear time.</p> <p><em>Please force use of the default algorithm unless you can implement an algorithm that is significantly faster.</em></p>    <h3 class=\"detail-header function\" id=\"member?/2\">  <span class=\"signature\">member?(enumerable, element)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">member?(<a href=\"#t:t/0\">t</a>, term) ::\n  {:ok, boolean} |\n  {:error, module}</code></pre>    <p>Checks if an element exists within the enumerable.</p> <p>It should return <code class=\"inline\">{:ok, boolean}</code>.</p> <p>If <code class=\"inline\">{:error, __MODULE__}</code> is returned a default algorithm using <code class=\"inline\">reduce</code> and the match (<code class=\"inline\">===</code>) operator is used. This algorithm runs in linear time.</p> <p><em>Please force use of the default algorithm unless you can implement an algorithm that is significantly faster.</em></p>    <h3 class=\"detail-header function\" id=\"reduce/3\">  <span class=\"signature\">reduce(enumerable, acc, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reduce(<a href=\"#t:t/0\">t</a>, <a href=\"#t:acc/0\">acc</a>, <a href=\"#t:reducer/0\">reducer</a>) :: <a href=\"#t:result/0\">result</a></code></pre>    <p>Reduces the enumerable into an element.</p> <p>Most of the operations in <a href=\"enum\"><code class=\"inline\">Enum</code></a> are implemented in terms of reduce. This function should apply the given <code class=\"inline\">t:reducer/0</code> function to each item in the enumerable and proceed as expected by the returned accumulator.</p> <p>As an example, here is the implementation of <code class=\"inline\">reduce</code> for lists:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def reduce(_,       {:halt, acc}, _fun),   do: {:halted, acc}\ndef reduce(list,    {:suspend, acc}, fun), do: {:suspended, acc, &amp;reduce(list, &amp;1, fun)}\ndef reduce([],      {:cont, acc}, _fun),   do: {:done, acc}\ndef reduce([h | t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), fun)</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Enumerable.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Enumerable.html</a>\n  </p>\n</div>\n","elixir/application":"<h1>  Application <small>behaviour</small>  </h1>  <p>A module for working with applications and defining application callbacks.</p> <p>In Elixir (actually, in Erlang/OTP), an application is a component implementing some specific functionality, that can be started and stopped as a unit, and which can be re-used in other systems.</p> <p>Applications are defined with an application file named <code class=\"inline\">APP.app</code> where <code class=\"inline\">APP</code> is the application name, usually in <code class=\"inline\">underscore_case</code>. The application file must reside in the same <code class=\"inline\">ebin</code> directory as the compiled modules of the application.</p> <p>In Elixir, Mix is responsible for compiling your source code and generating your application <code class=\"inline\">.app</code> file. Furthermore, Mix is also responsible for configuring, starting and stopping your application and its dependencies. For this reason, this documentation will focus on the remaining aspects of your application: the application environment and the application callback module.</p> <p>You can learn more about Mix generation of <code class=\"inline\">.app</code> files by typing <code class=\"inline\">mix help compile.app</code>.</p> <h2 id=\"module-application-environment\" class=\"section-heading\">  Application environment </h2> <p>Once an application is started, OTP provides an application environment that can be used to configure the application.</p> <p>Assuming you are inside a Mix project, you can edit the <code class=\"inline\">application</code> function in the <code class=\"inline\">mix.exs</code> file to the following:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def application do\n  [env: [hello: :world]]\nend</code></pre> <p>In the application function, we can define the default environment values for our application. By starting your application with <code class=\"inline\">iex -S mix</code>, you can access the default value:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Application.get_env(:APP_NAME, :hello)\n#=&gt; :world</code></pre> <p>It is also possible to put and delete values from the application value, including new values that are not defined in the environment file (although this should be avoided).</p> <p>Keep in mind that each application is responsible for its environment. Do not use the functions in this module for directly accessing or modifying the environment of other applications (as it may lead to inconsistent data in the application environment).</p> <h2 id=\"module-application-module-callback\" class=\"section-heading\">  Application module callback </h2> <p>Often times, an application defines a supervision tree that must be started and stopped when the application starts and stops. For such, we need to define an application module callback. The first step is to define the module callback in the application definition in the <code class=\"inline\">mix.exs</code> file:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def application do\n  [mod: {MyApp, []}]\nend</code></pre> <p>Our application now requires the <code class=\"inline\">MyApp</code> module to provide an application callback. This can be done by invoking <code class=\"inline\">use Application</code> in that module and defining a <a href=\"#start/2\"><code class=\"inline\">start/2</code></a> callback, for example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp do\n  use Application\n\n  def start(_type, _args) do\n    MyApp.Supervisor.start_link()\n  end\nend</code></pre> <p><a href=\"#start/2\"><code class=\"inline\">start/2</code></a> typically returns <code class=\"inline\">{:ok, pid}</code> or <code class=\"inline\">{:ok, pid, state}</code> where <code class=\"inline\">pid</code> identifies the supervision tree and <code class=\"inline\">state</code> is the application state. <code class=\"inline\">args</code> is the second element of the tuple given to the <code class=\"inline\">:mod</code> option.</p> <p>The <code class=\"inline\">type</code> argument passed to <a href=\"#start/2\"><code class=\"inline\">start/2</code></a> is usually <code class=\"inline\">:normal</code> unless in a distributed setup where application takeovers and failovers are configured. This particular aspect of applications is explained in more detail in the OTP documentation:</p> <ul> <li>\n<a href=\"http://www.erlang.org/doc/man/application.html\"><code class=\"inline\">:application</code> module</a> </li> <li>\n<a href=\"http://www.erlang.org/doc/design_principles/applications.html\">Applications – OTP Design Principles</a> </li> </ul> <p>A developer may also implement the <a href=\"#stop/1\"><code class=\"inline\">stop/1</code></a> callback (automatically defined by <code class=\"inline\">use Application</code>) which does any application cleanup. It receives the application state and can return any value. Note that shutting down the supervisor is automatically handled by the VM.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:app/0\">app()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:key/0\">key()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:start_type/0\">start_type()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:state/0\">state()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:value/0\">value()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#app_dir/1\">app_dir(app)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the directory for app</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#app_dir/2\">app_dir(app, path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the given path inside <a href=\"#app_dir/1\"><code class=\"inline\">app_dir/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete_env/3\">delete_env(app, key, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes the <code class=\"inline\">key</code> from the given <code class=\"inline\">app</code> environment</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ensure_all_started/2\">ensure_all_started(app, type \\\\ :temporary)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Ensures the given <code class=\"inline\">app</code> and its applications are started</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ensure_started/2\">ensure_started(app, type \\\\ :temporary)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Ensures the given <code class=\"inline\">app</code> is started</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch_env/2\">fetch_env(app, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the value for <code class=\"inline\">key</code> in <code class=\"inline\">app</code>’s environment in a tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch_env!/2\">fetch_env!(app, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the value for <code class=\"inline\">key</code> in <code class=\"inline\">app</code>’s environment</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format_error/1\">format_error(reason)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Formats the error reason returned by <a href=\"#start/2\"><code class=\"inline\">start/2</code></a>, <a href=\"#ensure_started/2\"><code class=\"inline\">ensure_started/2</code></a>, <a href=\"#stop/1\"><code class=\"inline\">stop/1</code></a>, <a href=\"#load/1\"><code class=\"inline\">load/1</code></a> and <a href=\"#unload/1\"><code class=\"inline\">unload/1</code></a>, returns a string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_all_env/1\">get_all_env(app)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all key-value pairs for <code class=\"inline\">app</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_application/1\">get_application(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the application for the given module</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_env/3\">get_env(app, key, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the value for <code class=\"inline\">key</code> in <code class=\"inline\">app</code>’s environment</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#load/1\">load(app)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Loads the given <code class=\"inline\">app</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#loaded_applications/0\">loaded_applications()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list with information about the applications which have been loaded</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_env/4\">put_env(app, key, value, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts the <code class=\"inline\">value</code> in <code class=\"inline\">key</code> for the given <code class=\"inline\">app</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spec/1\">spec(app)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the spec for <code class=\"inline\">app</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spec/2\">spec(app, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the value for <code class=\"inline\">key</code> in <code class=\"inline\">app</code>’s specification</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start/2\">start(app, type \\\\ :temporary)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts the given <code class=\"inline\">app</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#started_applications/1\">started_applications(timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list with information about the applications which are currently running</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stop/1\">stop(app)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stops the given <code class=\"inline\">app</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unload/1\">unload(app)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Unloads the given <code class=\"inline\">app</code></p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:start/2\">start(start_type, start_args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Called when an application is started</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:stop/1\">stop(state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Called when an application is stopped</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:app/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:app/0\">app</a> :: atom</code></pre> </div> <div id=\"t:key/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:key/0\">key</a> :: atom</code></pre> </div> <div id=\"t:start_type/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:start_type/0\">start_type</a> :: :permanent | :transient | :temporary</code></pre> </div> <div id=\"t:state/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:state/0\">state</a> :: term</code></pre> </div> <div id=\"t:value/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:value/0\">value</a> :: term</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"app_dir/1\">  <span class=\"signature\">app_dir(app)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">app_dir(<a href=\"#t:app/0\">app</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Gets the directory for app.</p> <p>This information is returned based on the code path. Here is an example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">File.mkdir_p!(\"foo/ebin\")\nCode.prepend_path(\"foo/ebin\")\nApplication.app_dir(:foo)\n#=&gt; \"foo\"</code></pre> <p>Even though the directory is empty and there is no <code class=\"inline\">.app</code> file it is considered the application directory based on the name “foo/ebin”. The name may contain a dash <code class=\"inline\">-</code> which is considered to be the app version and it is removed for the lookup purposes:</p> <pre data-language=\"elixir\"><code class=\"elixir\">File.mkdir_p!(\"bar-123/ebin\")\nCode.prepend_path(\"bar-123/ebin\")\nApplication.app_dir(:bar)\n#=&gt; \"bar-123\"</code></pre> <p>For more information on code paths, check the <a href=\"code\"><code class=\"inline\">Code</code></a> module in Elixir and also Erlang’s <code class=\"inline\">:code</code> module.</p>    <h3 class=\"detail-header function\" id=\"app_dir/2\">  <span class=\"signature\">app_dir(app, path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">app_dir(<a href=\"#t:app/0\">app</a>, <a href=\"string#t:t/0\">String.t</a> | [<a href=\"string#t:t/0\">String.t</a>]) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Returns the given path inside <a href=\"#app_dir/1\"><code class=\"inline\">app_dir/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"delete_env/3\">  <span class=\"signature\">delete_env(app, key, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete_env(<a href=\"#t:app/0\">app</a>, <a href=\"#t:key/0\">key</a>, timeout: timeout, persistent: boolean) :: :ok</code></pre>    <p>Deletes the <code class=\"inline\">key</code> from the given <code class=\"inline\">app</code> environment.</p> <p>See <a href=\"#put_env/4\"><code class=\"inline\">put_env/4</code></a> for a description of the options.</p>    <h3 class=\"detail-header function\" id=\"ensure_all_started/2\">  <span class=\"signature\">ensure_all_started(app, type \\\\ :temporary)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">ensure_all_started(<a href=\"#t:app/0\">app</a>, <a href=\"#t:start_type/0\">start_type</a>) ::\n  {:ok, [<a href=\"#t:app/0\">app</a>]} |\n  {:error, {<a href=\"#t:app/0\">app</a>, term}}</code></pre>    <p>Ensures the given <code class=\"inline\">app</code> and its applications are started.</p> <p>Same as <a href=\"#start/2\"><code class=\"inline\">start/2</code></a> but also starts the applications listed under <code class=\"inline\">:applications</code> in the <code class=\"inline\">.app</code> file in case they were not previously started.</p>    <h3 class=\"detail-header function\" id=\"ensure_started/2\">  <span class=\"signature\">ensure_started(app, type \\\\ :temporary)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">ensure_started(<a href=\"#t:app/0\">app</a>, <a href=\"#t:start_type/0\">start_type</a>) ::\n  :ok |\n  {:error, term}</code></pre>    <p>Ensures the given <code class=\"inline\">app</code> is started.</p> <p>Same as <a href=\"#start/2\"><code class=\"inline\">start/2</code></a> but returns <code class=\"inline\">:ok</code> if the application was already started. This is useful in scripts and in test setup, where test applications need to be explicitly started:</p> <pre data-language=\"elixir\"><code class=\"elixir\">:ok = Application.ensure_started(:my_test_dep)</code></pre>    <h3 class=\"detail-header function\" id=\"fetch_env/2\">  <span class=\"signature\">fetch_env(app, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch_env(<a href=\"#t:app/0\">app</a>, <a href=\"#t:key/0\">key</a>) :: {:ok, <a href=\"#t:value/0\">value</a>} | :error</code></pre>    <p>Returns the value for <code class=\"inline\">key</code> in <code class=\"inline\">app</code>’s environment in a tuple.</p> <p>If the configuration parameter does not exist, the function returns <code class=\"inline\">:error</code>.</p>    <h3 class=\"detail-header function\" id=\"fetch_env!/2\">  <span class=\"signature\">fetch_env!(app, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch_env!(<a href=\"#t:app/0\">app</a>, <a href=\"#t:key/0\">key</a>) :: <a href=\"#t:value/0\">value</a> | no_return</code></pre>    <p>Returns the value for <code class=\"inline\">key</code> in <code class=\"inline\">app</code>’s environment.</p> <p>If the configuration parameter does not exist, raises <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a>.</p>    <h3 class=\"detail-header function\" id=\"format_error/1\">  <span class=\"signature\">format_error(reason)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">format_error(any) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Formats the error reason returned by <a href=\"#start/2\"><code class=\"inline\">start/2</code></a>, <a href=\"#ensure_started/2\"><code class=\"inline\">ensure_started/2</code></a>, <a href=\"#stop/1\"><code class=\"inline\">stop/1</code></a>, <a href=\"#load/1\"><code class=\"inline\">load/1</code></a> and <a href=\"#unload/1\"><code class=\"inline\">unload/1</code></a>, returns a string.</p>    <h3 class=\"detail-header function\" id=\"get_all_env/1\">  <span class=\"signature\">get_all_env(app)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_all_env(<a href=\"#t:app/0\">app</a>) :: [{<a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>}]</code></pre>    <p>Returns all key-value pairs for <code class=\"inline\">app</code>.</p>    <h3 class=\"detail-header function\" id=\"get_application/1\">  <span class=\"signature\">get_application(module)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_application(atom) :: atom | nil</code></pre>    <p>Gets the application for the given module.</p> <p>The application is located by analyzing the spec of all loaded applications. Returns <code class=\"inline\">nil</code> if the module is not listed in any application spec.</p>    <h3 class=\"detail-header function\" id=\"get_env/3\">  <span class=\"signature\">get_env(app, key, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_env(<a href=\"#t:app/0\">app</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: <a href=\"#t:value/0\">value</a></code></pre>    <p>Returns the value for <code class=\"inline\">key</code> in <code class=\"inline\">app</code>’s environment.</p> <p>If the configuration parameter does not exist, the function returns the <code class=\"inline\">default</code> value.</p>    <h3 class=\"detail-header function\" id=\"load/1\">  <span class=\"signature\">load(app)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">load(<a href=\"#t:app/0\">app</a>) :: :ok | {:error, term}</code></pre>    <p>Loads the given <code class=\"inline\">app</code>.</p> <p>In order to be loaded, an <code class=\"inline\">.app</code> file must be in the load paths. All <code class=\"inline\">:included_applications</code> will also be loaded.</p> <p>Loading the application does not start it nor load its modules, but it does load its environment.</p>    <h3 class=\"detail-header function\" id=\"loaded_applications/0\">  <span class=\"signature\">loaded_applications()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">loaded_applications :: [tuple]</code></pre>    <p>Returns a list with information about the applications which have been loaded.</p>    <h3 class=\"detail-header function\" id=\"put_env/4\">  <span class=\"signature\">put_env(app, key, value, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_env(<a href=\"#t:app/0\">app</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>, timeout: timeout, persistent: boolean) :: :ok</code></pre>    <p>Puts the <code class=\"inline\">value</code> in <code class=\"inline\">key</code> for the given <code class=\"inline\">app</code>.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:timeout</code> - the timeout for the change (defaults to 5000ms) </li> <li>\n<code class=\"inline\">:persistent</code> - persists the given value on application load and reloads </li> </ul> <p>If <a href=\"#put_env/4\"><code class=\"inline\">put_env/4</code></a> is called before the application is loaded, the application environment values specified in the <code class=\"inline\">.app</code> file will override the ones previously set.</p> <p>The persistent option can be set to <code class=\"inline\">true</code> when there is a need to guarantee parameters set with this function will not be overridden by the ones defined in the application resource file on load. This means persistent values will stick after the application is loaded and also on application reload.</p>    <h3 class=\"detail-header function\" id=\"spec/1\">  <span class=\"signature\">spec(app)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spec(<a href=\"#t:app/0\">app</a>) :: [{<a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>}] | nil</code></pre>    <p>Returns the spec for <code class=\"inline\">app</code>.</p> <p>The following keys are returned:</p> <ul> <li>:description </li> <li>:id </li> <li>:vsn </li> <li>:modules </li> <li>:maxP </li> <li>:maxT </li> <li>:registered </li> <li>:included_applications </li> <li>:applications </li> <li>:mod </li> <li>:start_phases </li> </ul> <p>Note the environment is not returned as it can be accessed via <a href=\"#fetch_env/2\"><code class=\"inline\">fetch_env/2</code></a>. Returns <code class=\"inline\">nil</code> if the application is not loaded.</p>    <h3 class=\"detail-header function\" id=\"spec/2\">  <span class=\"signature\">spec(app, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spec(<a href=\"#t:app/0\">app</a>, <a href=\"#t:key/0\">key</a>) :: <a href=\"#t:value/0\">value</a> | nil</code></pre>    <p>Returns the value for <code class=\"inline\">key</code> in <code class=\"inline\">app</code>’s specification.</p> <p>See <a href=\"#spec/1\"><code class=\"inline\">spec/1</code></a> for the supported keys. If the given specification parameter does not exist, this function will raise. Returns <code class=\"inline\">nil</code> if the application is not loaded.</p>    <h3 class=\"detail-header function\" id=\"start/2\">  <span class=\"signature\">start(app, type \\\\ :temporary)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start(<a href=\"#t:app/0\">app</a>, <a href=\"#t:start_type/0\">start_type</a>) :: :ok | {:error, term}</code></pre>    <p>Starts the given <code class=\"inline\">app</code>.</p> <p>If the <code class=\"inline\">app</code> is not loaded, the application will first be loaded using <a href=\"#load/1\"><code class=\"inline\">load/1</code></a>. Any included application, defined in the <code class=\"inline\">:included_applications</code> key of the <code class=\"inline\">.app</code> file will also be loaded, but they won’t be started.</p> <p>Furthermore, all applications listed in the <code class=\"inline\">:applications</code> key must be explicitly started before this application is. If not, <code class=\"inline\">{:error, {:not_started, app}}</code> is returned, where <code class=\"inline\">app</code> is the name of the missing application.</p> <p>In case you want to automatically load <strong>and start</strong> all of <code class=\"inline\">app</code>’s dependencies, see <a href=\"#ensure_all_started/2\"><code class=\"inline\">ensure_all_started/2</code></a>.</p> <p>The <code class=\"inline\">type</code> argument specifies the type of the application:</p> <ul> <li>\n<p><code class=\"inline\">:permanent</code> - if <code class=\"inline\">app</code> terminates, all other applications and the entire node are also terminated.</p> </li> <li>\n<p><code class=\"inline\">:transient</code> - if <code class=\"inline\">app</code> terminates with <code class=\"inline\">:normal</code> reason, it is reported but no other applications are terminated. If a transient application terminates abnormally, all other applications and the entire node are also terminated.</p> </li> <li>\n<code class=\"inline\">:temporary</code> - if <code class=\"inline\">app</code> terminates, it is reported but no other applications are terminated (the default). </li> </ul> <p>Note that it is always possible to stop an application explicitly by calling <a href=\"#stop/1\"><code class=\"inline\">stop/1</code></a>. Regardless of the type of the application, no other applications will be affected.</p> <p>Note also that the <code class=\"inline\">:transient</code> type is of little practical use, since when a supervision tree terminates, the reason is set to <code class=\"inline\">:shutdown</code>, not <code class=\"inline\">:normal</code>.</p>    <h3 class=\"detail-header function\" id=\"started_applications/1\">  <span class=\"signature\">started_applications(timeout \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">started_applications(timeout) :: [tuple]</code></pre>    <p>Returns a list with information about the applications which are currently running.</p>    <h3 class=\"detail-header function\" id=\"stop/1\">  <span class=\"signature\">stop(app)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stop(<a href=\"#t:app/0\">app</a>) :: :ok | {:error, term}</code></pre>    <p>Stops the given <code class=\"inline\">app</code>.</p> <p>When stopped, the application is still loaded.</p>    <h3 class=\"detail-header function\" id=\"unload/1\">  <span class=\"signature\">unload(app)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unload(<a href=\"#t:app/0\">app</a>) :: :ok | {:error, term}</code></pre>    <p>Unloads the given <code class=\"inline\">app</code>.</p> <p>It will also unload all <code class=\"inline\">:included_applications</code>. Note that the function does not purge the application modules.</p>     <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:start/2\">  <span class=\"signature\">start(start_type, start_args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start(<a href=\"#t:start_type/0\">start_type</a>, start_args :: term) ::\n  {:ok, pid} |\n  {:ok, pid, <a href=\"#t:state/0\">state</a>} |\n  {:error, reason :: term}</code></pre>    <p>Called when an application is started.</p> <p>This function is called when an the application is started using <a href=\"application#start/2\"><code class=\"inline\">Application.start/2</code></a> (and functions on top of that, such as <a href=\"application#ensure_started/2)\"><code class=\"inline\">Application.ensure_started/2</code></a>. This function should start the top-level process of the application (which should be the top supervisor of the application’s supervision tree if the application follows the OTP design principles around supervision).</p> <p><code class=\"inline\">start_type</code> defines how the application is started:</p> <ul> <li>\n<code class=\"inline\">:normal</code> - used if the startup is a normal startup or if the application is distributed and is started on the current node because of a failover from another mode and the application specification key <code class=\"inline\">:start_phases</code> is <code class=\"inline\">:undefined</code>. </li> <li>\n<code class=\"inline\">{:takeover, node}</code> - used if the application is distributed and is started on the current node because of a failover on the node <code class=\"inline\">node</code>. </li> <li>\n<code class=\"inline\">{:failover, node}</code> - used if the application is distributed and is started on the current node because of a failover on node <code class=\"inline\">node</code>, and the application specification key <code class=\"inline\">:start_phases</code> is not <code class=\"inline\">:undefined</code>. </li> </ul> <p><code class=\"inline\">start_args</code> are the arguments passed to the application in the <code class=\"inline\">:mod</code> specification key (e.g., <code class=\"inline\">mod: {MyApp, [:my_args]}</code>).</p> <p>This function should either return <code class=\"inline\">{:ok, pid}</code> or <code class=\"inline\">{:ok, pid, state}</code> if startup is successful. <code class=\"inline\">pid</code> should be the pid of the top supervisor. <code class=\"inline\">state</code> can be an arbitrary term, and if omitted will default to <code class=\"inline\">[]</code>; if the application is later stopped, <code class=\"inline\">state</code> is passed to the <a href=\"#stop/1\"><code class=\"inline\">stop/1</code></a> callback (see the documentation for the <code class=\"inline\">stop/2</code> callback for more information).</p> <p><code class=\"inline\">use Application</code> provides no default implementation for the <a href=\"#start/2\"><code class=\"inline\">start/2</code></a> callback.</p>    <h3 class=\"detail-header callback\" id=\"c:stop/1\">  <span class=\"signature\">stop(state)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stop(<a href=\"#t:state/0\">state</a>) :: term</code></pre>    <p>Called when an application is stopped.</p> <p>This function is called when an application has stopped, i.e., when its supervision tree has been stopped. It should do the opposite of what the <a href=\"#start/2\"><code class=\"inline\">start/2</code></a> callback did, and should perform any necessary cleanup. The return value of this callback is ignored.</p> <p><code class=\"inline\">state</code> is the return value of the <a href=\"#start/2\"><code class=\"inline\">start/2</code></a> callback or the return value of the <code class=\"inline\">prep_stop/1</code> function if the application module defines such a function.</p> <p><code class=\"inline\">use Application</code> defines a default implementation of this function which does nothing and just returns <code class=\"inline\">:ok</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Application.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Application.html</a>\n  </p>\n</div>\n","elixir/base":"<h1>  Base  </h1>  <p>This module provides data encoding and decoding functions according to <a href=\"http://tools.ietf.org/html/rfc4648\">RFC 4648</a>.</p> <p>This document defines the commonly used base 16, base 32, and base 64 encoding schemes.</p> <h2 id=\"module-base-16-alphabet\" class=\"section-heading\">  Base 16 alphabet </h2> <pre data-language=\"elixir\"><code class=\"elixir\">| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n|      0|         0|      4|         4|      8|         8|     12|         C|\n|      1|         1|      5|         5|      9|         9|     13|         D|\n|      2|         2|      6|         6|     10|         A|     14|         E|\n|      3|         3|      7|         7|     11|         B|     15|         F|</code></pre> <h2 id=\"module-base-32-alphabet\" class=\"section-heading\">  Base 32 alphabet </h2> <pre data-language=\"elixir\"><code class=\"elixir\">| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n|      0|         A|      9|         J|     18|         S|     27|         3|\n|      1|         B|     10|         K|     19|         T|     28|         4|\n|      2|         C|     11|         L|     20|         U|     29|         5|\n|      3|         D|     12|         M|     21|         V|     30|         6|\n|      4|         E|     13|         N|     22|         W|     31|         7|\n|      5|         F|     14|         O|     23|         X|       |          |\n|      6|         G|     15|         P|     24|         Y|  (pad)|         =|\n|      7|         H|     16|         Q|     25|         Z|       |          |\n|      8|         I|     17|         R|     26|         2|       |          |</code></pre> <h2 id=\"module-base-32-extended-hex-alphabet\" class=\"section-heading\">  Base 32 (extended hex) alphabet </h2> <pre data-language=\"elixir\"><code class=\"elixir\">| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n|      0|         0|      9|         9|     18|         I|     27|         R|\n|      1|         1|     10|         A|     19|         J|     28|         S|\n|      2|         2|     11|         B|     20|         K|     29|         T|\n|      3|         3|     12|         C|     21|         L|     30|         U|\n|      4|         4|     13|         D|     22|         M|     31|         V|\n|      5|         5|     14|         E|     23|         N|       |          |\n|      6|         6|     15|         F|     24|         O|  (pad)|         =|\n|      7|         7|     16|         G|     25|         P|       |          |\n|      8|         8|     17|         H|     26|         Q|       |          |</code></pre> <h2 id=\"module-base-64-alphabet\" class=\"section-heading\">  Base 64 alphabet </h2> <pre data-language=\"elixir\"><code class=\"elixir\">| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n|      0|         A|     17|         R|     34|         i|     51|         z|\n|      1|         B|     18|         S|     35|         j|     52|         0|\n|      2|         C|     19|         T|     36|         k|     53|         1|\n|      3|         D|     20|         U|     37|         l|     54|         2|\n|      4|         E|     21|         V|     38|         m|     55|         3|\n|      5|         F|     22|         W|     39|         n|     56|         4|\n|      6|         G|     23|         X|     40|         o|     57|         5|\n|      7|         H|     24|         Y|     41|         p|     58|         6|\n|      8|         I|     25|         Z|     42|         q|     59|         7|\n|      9|         J|     26|         a|     43|         r|     60|         8|\n|     10|         K|     27|         b|     44|         s|     61|         9|\n|     11|         L|     28|         c|     45|         t|     62|         +|\n|     12|         M|     29|         d|     46|         u|     63|         /|\n|     13|         N|     30|         e|     47|         v|       |          |\n|     14|         O|     31|         f|     48|         w|  (pad)|         =|\n|     15|         P|     32|         g|     49|         x|       |          |\n|     16|         Q|     33|         h|     50|         y|       |          |</code></pre> <h2 id=\"module-base-64-url-and-filename-safe-alphabet\" class=\"section-heading\">  Base 64 (URL and filename safe) alphabet </h2> <pre data-language=\"elixir\"><code class=\"elixir\">| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n|      0|         A|     17|         R|     34|         i|     51|         z|\n|      1|         B|     18|         S|     35|         j|     52|         0|\n|      2|         C|     19|         T|     36|         k|     53|         1|\n|      3|         D|     20|         U|     37|         l|     54|         2|\n|      4|         E|     21|         V|     38|         m|     55|         3|\n|      5|         F|     22|         W|     39|         n|     56|         4|\n|      6|         G|     23|         X|     40|         o|     57|         5|\n|      7|         H|     24|         Y|     41|         p|     58|         6|\n|      8|         I|     25|         Z|     42|         q|     59|         7|\n|      9|         J|     26|         a|     43|         r|     60|         8|\n|     10|         K|     27|         b|     44|         s|     61|         9|\n|     11|         L|     28|         c|     45|         t|     62|         -|\n|     12|         M|     29|         d|     46|         u|     63|         _|\n|     13|         N|     30|         e|     47|         v|       |          |\n|     14|         O|     31|         f|     48|         w|  (pad)|         =|\n|     15|         P|     32|         g|     49|         x|       |          |\n|     16|         Q|     33|         h|     50|         y|       |          |</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#decode16/2\">decode16(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes a base 16 encoded string into a binary string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#decode16!/2\">decode16!(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes a base 16 encoded string into a binary string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#decode32/2\">decode32(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes a base 32 encoded string into a binary string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#decode32!/2\">decode32!(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes a base 32 encoded string into a binary string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#decode64/2\">decode64(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes a base 64 encoded string into a binary string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#decode64!/2\">decode64!(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes a base 64 encoded string into a binary string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#encode16/2\">encode16(data, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Encodes a binary string into a base 16 encoded string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#encode32/2\">encode32(data, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Encodes a binary string into a base 32 encoded string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#encode64/2\">encode64(data, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Encodes a binary string into a base 64 encoded string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#hex_decode32/2\">hex_decode32(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes a base 32 encoded string with extended hexadecimal alphabet into a binary string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#hex_decode32!/2\">hex_decode32!(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes a base 32 encoded string with extended hexadecimal alphabet into a binary string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#hex_encode32/2\">hex_encode32(data, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Encodes a binary string into a base 32 encoded string with an extended hexadecimal alphabet</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#url_decode64/2\">url_decode64(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes a base 64 encoded string with URL and filename safe alphabet into a binary string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#url_decode64!/2\">url_decode64!(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes a base 64 encoded string with URL and filename safe alphabet into a binary string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#url_encode64/2\">url_encode64(data, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Encodes a binary string into a base 64 encoded string with URL and filename safe alphabet</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"decode16/2\">  <span class=\"signature\">decode16(string, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">decode16(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: {:ok, binary} | :error</code></pre>    <p>Decodes a base 16 encoded string into a binary string.</p> <h4>Options</h4> <p>The accepted options are:</p> <ul> <li>\n<code class=\"inline\">:case</code> - specifies the character case to accept when decoding </li> </ul> <p>The values for <code class=\"inline\">:case</code> can be:</p> <ul> <li>\n<code class=\"inline\">:upper</code> - only allow upper case characters (default) </li> <li>\n<code class=\"inline\">:lower</code> - only allow lower case characters </li> <li>\n<code class=\"inline\">:mixed</code> - allow mixed case characters </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.decode16(\"666F6F626172\")\n{:ok, \"foobar\"}\n\niex&gt; Base.decode16(\"666f6f626172\", case: :lower)\n{:ok, \"foobar\"}\n\niex&gt; Base.decode16(\"666f6F626172\", case: :mixed)\n{:ok, \"foobar\"}</code></pre>    <h3 class=\"detail-header function\" id=\"decode16!/2\">  <span class=\"signature\">decode16!(string, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">decode16!(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: binary</code></pre>    <p>Decodes a base 16 encoded string into a binary string.</p> <h4>Options</h4> <p>The accepted options are:</p> <ul> <li>\n<code class=\"inline\">:case</code> - specifies the character case to accept when decoding </li> </ul> <p>The values for <code class=\"inline\">:case</code> can be:</p> <ul> <li>\n<code class=\"inline\">:upper</code> - only allow upper case characters (default) </li> <li>\n<code class=\"inline\">:lower</code> - only allow lower case characters </li> <li>\n<code class=\"inline\">:mixed</code> - allow mixed case characters </li> </ul> <p>An <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> exception is raised if the padding is incorrect or a non-alphabet character is present in the string.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.decode16!(\"666F6F626172\")\n\"foobar\"\n\niex&gt; Base.decode16!(\"666f6f626172\", case: :lower)\n\"foobar\"\n\niex&gt; Base.decode16!(\"666f6F626172\", case: :mixed)\n\"foobar\"</code></pre>    <h3 class=\"detail-header function\" id=\"decode32/2\">  <span class=\"signature\">decode32(string, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">decode32(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: {:ok, binary} | :error</code></pre>    <p>Decodes a base 32 encoded string into a binary string.</p> <h4>Options</h4> <p>The accepted options are:</p> <ul> <li>\n<code class=\"inline\">:case</code> - specifies the character case to accept when decoding </li> <li>\n<code class=\"inline\">:padding</code> - specifies whether to require padding </li> </ul> <p>The values for <code class=\"inline\">:case</code> can be:</p> <ul> <li>\n<code class=\"inline\">:upper</code> - only allow upper case characters (default) </li> <li>\n<code class=\"inline\">:lower</code> - only allow lower case characters </li> <li>\n<code class=\"inline\">:mixed</code> - allow mixed case characters </li> </ul> <p>The values for <code class=\"inline\">:padding</code> can be:</p> <ul> <li>\n<code class=\"inline\">true</code> - require the input string to be padded to the nearest multiple of 8 (default) </li> <li>\n<code class=\"inline\">false</code> - ignore padding from the input string </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.decode32(\"MZXW6YTBOI======\")\n{:ok, \"foobar\"}\n\niex&gt; Base.decode32(\"mzxw6ytboi======\", case: :lower)\n{:ok, \"foobar\"}\n\niex&gt; Base.decode32(\"mzXW6ytBOi======\", case: :mixed)\n{:ok, \"foobar\"}\n\niex&gt; Base.decode32(\"MZXW6YTBOI\", padding: false)\n{:ok, \"foobar\"}</code></pre>    <h3 class=\"detail-header function\" id=\"decode32!/2\">  <span class=\"signature\">decode32!(string, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">decode32!(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: binary</code></pre>    <p>Decodes a base 32 encoded string into a binary string.</p> <p>An <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> exception is raised if the padding is incorrect or a non-alphabet character is present in the string.</p> <h4>Options</h4> <p>The accepted options are:</p> <ul> <li>\n<code class=\"inline\">:case</code> - specifies the character case to accept when decoding </li> <li>\n<code class=\"inline\">:padding</code> - specifies whether to require padding </li> </ul> <p>The values for <code class=\"inline\">:case</code> can be:</p> <ul> <li>\n<code class=\"inline\">:upper</code> - only allow upper case characters (default) </li> <li>\n<code class=\"inline\">:lower</code> - only allow lower case characters </li> <li>\n<code class=\"inline\">:mixed</code> - allow mixed case characters </li> </ul> <p>The values for <code class=\"inline\">:padding</code> can be:</p> <ul> <li>\n<code class=\"inline\">true</code> - require the input string to be padded to the nearest multiple of 8 (default) </li> <li>\n<code class=\"inline\">false</code> - ignore padding from the input string </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.decode32!(\"MZXW6YTBOI======\")\n\"foobar\"\n\niex&gt; Base.decode32!(\"mzxw6ytboi======\", case: :lower)\n\"foobar\"\n\niex&gt; Base.decode32!(\"mzXW6ytBOi======\", case: :mixed)\n\"foobar\"\n\niex&gt; Base.decode32!(\"MZXW6YTBOI\", padding: false)\n\"foobar\"</code></pre>    <h3 class=\"detail-header function\" id=\"decode64/2\">  <span class=\"signature\">decode64(string, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">decode64(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: {:ok, binary} | :error</code></pre>    <p>Decodes a base 64 encoded string into a binary string.</p> <p>Accepts <code class=\"inline\">ignore: :whitespace</code> option which will ignore all the whitespace characters in the input string.</p> <p>Accepts <code class=\"inline\">padding: false</code> option which will ignore padding from the input string.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.decode64(\"Zm9vYmFy\")\n{:ok, \"foobar\"}\n\niex&gt; Base.decode64(\"Zm9vYmFy\\n\", ignore: :whitespace)\n{:ok, \"foobar\"}\n\niex&gt; Base.decode64(\"Zm9vYg==\")\n{:ok, \"foob\"}\n\niex&gt; Base.decode64(\"Zm9vYg\", padding: false)\n{:ok, \"foob\"}</code></pre>    <h3 class=\"detail-header function\" id=\"decode64!/2\">  <span class=\"signature\">decode64!(string, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">decode64!(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: binary</code></pre>    <p>Decodes a base 64 encoded string into a binary string.</p> <p>Accepts <code class=\"inline\">ignore: :whitespace</code> option which will ignore all the whitespace characters in the input string.</p> <p>Accepts <code class=\"inline\">padding: false</code> option which will ignore padding from the input string.</p> <p>An <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> exception is raised if the padding is incorrect or a non-alphabet character is present in the string.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.decode64!(\"Zm9vYmFy\")\n\"foobar\"\n\niex&gt; Base.decode64!(\"Zm9vYmFy\\n\", ignore: :whitespace)\n\"foobar\"\n\niex&gt; Base.decode64!(\"Zm9vYg==\")\n\"foob\"\n\niex&gt; Base.decode64!(\"Zm9vYg\", padding: false)\n\"foob\"</code></pre>    <h3 class=\"detail-header function\" id=\"encode16/2\">  <span class=\"signature\">encode16(data, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">encode16(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: binary</code></pre>    <p>Encodes a binary string into a base 16 encoded string.</p> <h4>Options</h4> <p>The accepted options are:</p> <ul> <li>\n<code class=\"inline\">:case</code> - specifies the character case to use when encoding </li> </ul> <p>The values for <code class=\"inline\">:case</code> can be:</p> <ul> <li>\n<code class=\"inline\">:upper</code> - use upper case characters (default) </li> <li>\n<code class=\"inline\">:lower</code> - use lower case characters </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.encode16(\"foobar\")\n\"666F6F626172\"\n\niex&gt; Base.encode16(\"foobar\", case: :lower)\n\"666f6f626172\"</code></pre>    <h3 class=\"detail-header function\" id=\"encode32/2\">  <span class=\"signature\">encode32(data, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">encode32(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: binary</code></pre>    <p>Encodes a binary string into a base 32 encoded string.</p> <h4>Options</h4> <p>The accepted options are:</p> <ul> <li>\n<code class=\"inline\">:case</code> - specifies the character case to use when encoding </li> <li>\n<code class=\"inline\">:padding</code> - specifies whether to apply padding </li> </ul> <p>The values for <code class=\"inline\">:case</code> can be:</p> <ul> <li>\n<code class=\"inline\">:upper</code> - use upper case characters (default) </li> <li>\n<code class=\"inline\">:lower</code> - use lower case characters </li> </ul> <p>The values for <code class=\"inline\">:padding</code> can be:</p> <ul> <li>\n<code class=\"inline\">true</code> - pad the output string to the nearest multiple of 8 (default) </li> <li>\n<code class=\"inline\">false</code> - omit padding from the output string </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.encode32(\"foobar\")\n\"MZXW6YTBOI======\"\n\niex&gt; Base.encode32(\"foobar\", case: :lower)\n\"mzxw6ytboi======\"\n\niex&gt; Base.encode32(\"foobar\", padding: false)\n\"MZXW6YTBOI\"</code></pre>    <h3 class=\"detail-header function\" id=\"encode64/2\">  <span class=\"signature\">encode64(data, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">encode64(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: binary</code></pre>    <p>Encodes a binary string into a base 64 encoded string.</p> <p>Accepts <code class=\"inline\">padding: false</code> option which will omit padding from the output string.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.encode64(\"foobar\")\n\"Zm9vYmFy\"\n\niex&gt; Base.encode64(\"foob\")\n\"Zm9vYg==\"\n\niex&gt; Base.encode64(\"foob\", padding: false)\n\"Zm9vYg\"</code></pre>    <h3 class=\"detail-header function\" id=\"hex_decode32/2\">  <span class=\"signature\">hex_decode32(string, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">hex_decode32(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) ::\n  {:ok, binary} |\n  :error</code></pre>    <p>Decodes a base 32 encoded string with extended hexadecimal alphabet into a binary string.</p> <h4>Options</h4> <p>The accepted options are:</p> <ul> <li>\n<code class=\"inline\">:case</code> - specifies the character case to accept when decoding </li> <li>\n<code class=\"inline\">:padding</code> - specifies whether to require padding </li> </ul> <p>The values for <code class=\"inline\">:case</code> can be:</p> <ul> <li>\n<code class=\"inline\">:upper</code> - only allow upper case characters (default) </li> <li>\n<code class=\"inline\">:lower</code> - only allow lower case characters </li> <li>\n<code class=\"inline\">:mixed</code> - allow mixed case characters </li> </ul> <p>The values for <code class=\"inline\">:padding</code> can be:</p> <ul> <li>\n<code class=\"inline\">true</code> - require the input string to be padded to the nearest multiple of 8 (default) </li> <li>\n<code class=\"inline\">false</code> - ignore padding from the input string </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.hex_decode32(\"CPNMUOJ1E8======\")\n{:ok, \"foobar\"}\n\niex&gt; Base.hex_decode32(\"cpnmuoj1e8======\", case: :lower)\n{:ok, \"foobar\"}\n\niex&gt; Base.hex_decode32(\"cpnMuOJ1E8======\", case: :mixed)\n{:ok, \"foobar\"}\n\niex&gt; Base.hex_decode32(\"CPNMUOJ1E8\", padding: false)\n{:ok, \"foobar\"}</code></pre>    <h3 class=\"detail-header function\" id=\"hex_decode32!/2\">  <span class=\"signature\">hex_decode32!(string, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">hex_decode32!(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: binary</code></pre>    <p>Decodes a base 32 encoded string with extended hexadecimal alphabet into a binary string.</p> <p>An <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> exception is raised if the padding is incorrect or a non-alphabet character is present in the string.</p> <h4>Options</h4> <p>The accepted options are:</p> <ul> <li>\n<code class=\"inline\">:case</code> - specifies the character case to accept when decoding </li> <li>\n<code class=\"inline\">:padding</code> - specifies whether to require padding </li> </ul> <p>The values for <code class=\"inline\">:case</code> can be:</p> <ul> <li>\n<code class=\"inline\">:upper</code> - only allow upper case characters (default) </li> <li>\n<code class=\"inline\">:lower</code> - only allow lower case characters </li> <li>\n<code class=\"inline\">:mixed</code> - allow mixed case characters </li> </ul> <p>The values for <code class=\"inline\">:padding</code> can be:</p> <ul> <li>\n<code class=\"inline\">true</code> - require the input string to be padded to the nearest multiple of 8 (default) </li> <li>\n<code class=\"inline\">false</code> - ignore padding from the input string </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.hex_decode32!(\"CPNMUOJ1E8======\")\n\"foobar\"\n\niex&gt; Base.hex_decode32!(\"cpnmuoj1e8======\", case: :lower)\n\"foobar\"\n\niex&gt; Base.hex_decode32!(\"cpnMuOJ1E8======\", case: :mixed)\n\"foobar\"\n\niex&gt; Base.hex_decode32!(\"CPNMUOJ1E8\", padding: false)\n\"foobar\"</code></pre>    <h3 class=\"detail-header function\" id=\"hex_encode32/2\">  <span class=\"signature\">hex_encode32(data, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">hex_encode32(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: binary</code></pre>    <p>Encodes a binary string into a base 32 encoded string with an extended hexadecimal alphabet.</p> <h4>Options</h4> <p>The accepted options are:</p> <ul> <li>\n<code class=\"inline\">:case</code> - specifies the character case to use when encoding </li> <li>\n<code class=\"inline\">:padding</code> - specifies whether to apply padding </li> </ul> <p>The values for <code class=\"inline\">:case</code> can be:</p> <ul> <li>\n<code class=\"inline\">:upper</code> - use upper case characters (default) </li> <li>\n<code class=\"inline\">:lower</code> - use lower case characters </li> </ul> <p>The values for <code class=\"inline\">:padding</code> can be:</p> <ul> <li>\n<code class=\"inline\">true</code> - pad the output string to the nearest multiple of 8 (default) </li> <li>\n<code class=\"inline\">false</code> - omit padding from the output string </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.hex_encode32(\"foobar\")\n\"CPNMUOJ1E8======\"\n\niex&gt; Base.hex_encode32(\"foobar\", case: :lower)\n\"cpnmuoj1e8======\"\n\niex&gt; Base.hex_encode32(\"foobar\", padding: false)\n\"CPNMUOJ1E8\"</code></pre>    <h3 class=\"detail-header function\" id=\"url_decode64/2\">  <span class=\"signature\">url_decode64(string, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">url_decode64(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) ::\n  {:ok, binary} |\n  :error</code></pre>    <p>Decodes a base 64 encoded string with URL and filename safe alphabet into a binary string.</p> <p>Accepts <code class=\"inline\">ignore: :whitespace</code> option which will ignore all the whitespace characters in the input string.</p> <p>Accepts <code class=\"inline\">padding: false</code> option which will ignore padding from the input string.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.url_decode64(\"_3_-_A==\")\n{:ok, &lt;&lt;255, 127, 254, 252&gt;&gt;}\n\niex&gt; Base.url_decode64(\"_3_-_A==\\n\", ignore: :whitespace)\n{:ok, &lt;&lt;255, 127, 254, 252&gt;&gt;}\n\niex&gt; Base.url_decode64(\"_3_-_A\", padding: false)\n{:ok, &lt;&lt;255, 127, 254, 252&gt;&gt;}</code></pre>    <h3 class=\"detail-header function\" id=\"url_decode64!/2\">  <span class=\"signature\">url_decode64!(string, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">url_decode64!(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: binary</code></pre>    <p>Decodes a base 64 encoded string with URL and filename safe alphabet into a binary string.</p> <p>Accepts <code class=\"inline\">ignore: :whitespace</code> option which will ignore all the whitespace characters in the input string.</p> <p>Accepts <code class=\"inline\">padding: false</code> option which will ignore padding from the input string.</p> <p>An <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> exception is raised if the padding is incorrect or a non-alphabet character is present in the string.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.url_decode64!(\"_3_-_A==\")\n&lt;&lt;255, 127, 254, 252&gt;&gt;\n\niex&gt; Base.url_decode64!(\"_3_-_A==\\n\", ignore: :whitespace)\n&lt;&lt;255, 127, 254, 252&gt;&gt;\n\niex&gt; Base.url_decode64!(\"_3_-_A\", padding: false)\n&lt;&lt;255, 127, 254, 252&gt;&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"url_encode64/2\">  <span class=\"signature\">url_encode64(data, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">url_encode64(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: binary</code></pre>    <p>Encodes a binary string into a base 64 encoded string with URL and filename safe alphabet.</p> <p>Accepts <code class=\"inline\">padding: false</code> option which will omit padding from the output string.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Base.url_encode64(&lt;&lt;255, 127, 254, 252&gt;&gt;)\n\"_3_-_A==\"\n\niex&gt; Base.url_encode64(&lt;&lt;255, 127, 254, 252&gt;&gt;, padding: false)\n\"_3_-_A\"</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Base.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Base.html</a>\n  </p>\n</div>\n","elixir/date":"<h1>  Date  </h1>  <p>A Date struct and functions.</p> <p>The Date struct contains the fields year, month, day and calendar. New dates can be built with the <a href=\"#new/3\"><code class=\"inline\">new/3</code></a> function or using the <code class=\"inline\">~D</code> sigil:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~D[2000-01-01]\n~D[2000-01-01]</code></pre> <p>Both <a href=\"#new/3\"><code class=\"inline\">new/3</code></a> and sigil return a struct where the date fields can be accessed directly:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; date = ~D[2000-01-01]\niex&gt; date.year\n2000\niex&gt; date.month\n1</code></pre> <p>Developers should avoid creating the Date struct directly and instead rely on the functions provided by this module as well as the ones in 3rd party calendar libraries.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#from_erl/1\">from_erl(arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an Erlang date tuple to a <a href=\"date#content\"><code class=\"inline\">Date</code></a> struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_erl!/1\">from_erl!(tuple)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an Erlang date tuple but raises for invalid dates</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_iso8601/1\">from_iso8601(arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses the extended “Date and time of day” format described by ISO8601:2004</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_iso8601!/1\">from_iso8601!(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses the extended “Date and time of day” format described by ISO8601:2004</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/3\">new(year, month, day)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Builds a new ISO date</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_erl/1\">to_erl(date)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a <a href=\"date#content\"><code class=\"inline\">Date</code></a> struct to an Erlang date tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_iso8601/1\">to_iso8601(date)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given date time to ISO8601</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(date)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given date to a string according to its calendar</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Date{calendar: <a href=\"calendar#t:calendar/0\">Calendar.calendar</a>, day: <a href=\"calendar#t:day/0\">Calendar.day</a>, month: <a href=\"calendar#t:month/0\">Calendar.month</a>, year: <a href=\"calendar#t:year/0\">Calendar.year</a>}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"from_erl/1\">  <span class=\"signature\">from_erl(arg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_erl(:calendar.date) ::\n  {:ok, <a href=\"date#t:t/0\">Date.t</a>} |\n  {:error, atom}</code></pre>    <p>Converts an Erlang date tuple to a <a href=\"date#content\"><code class=\"inline\">Date</code></a> struct.</p> <p>Attempting to convert an invalid ISO calendar date will produce an error tuple.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Date.from_erl({2000, 1, 1})\n{:ok, ~D[2000-01-01]}\niex&gt; Date.from_erl({2000, 13, 1})\n{:error, :invalid_date}</code></pre>    <h3 class=\"detail-header function\" id=\"from_erl!/1\">  <span class=\"signature\">from_erl!(tuple)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_erl!(:calendar.date) :: <a href=\"date#t:t/0\">Date.t</a> | no_return</code></pre>    <p>Converts an Erlang date tuple but raises for invalid dates.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Date.from_erl!({2000, 1, 1})\n~D[2000-01-01]\niex&gt; Date.from_erl!({2000, 13, 1})\n** (ArgumentError) cannot convert {2000, 13, 1} to date, reason: :invalid_date</code></pre>    <h3 class=\"detail-header function\" id=\"from_iso8601/1\">  <span class=\"signature\">from_iso8601(arg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_iso8601(<a href=\"string#t:t/0\">String.t</a>) ::\n  {:ok, <a href=\"date#t:t/0\">Date.t</a>} |\n  {:error, atom}</code></pre>    <p>Parses the extended “Date and time of day” format described by ISO8601:2004.</p> <p>Timezone offset may be included in the string but they will be simply discarded as such information is not included in naive date times.</p> <p>Time representations with reduced accuracy are not supported.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Date.from_iso8601(\"2015-01-23\")\n{:ok, ~D[2015-01-23]}\n\niex&gt; Date.from_iso8601(\"2015:01:23\")\n{:error, :invalid_format}\niex&gt; Date.from_iso8601(\"2015-01-32\")\n{:error, :invalid_date}</code></pre>    <h3 class=\"detail-header function\" id=\"from_iso8601!/1\">  <span class=\"signature\">from_iso8601!(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_iso8601!(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"date#t:t/0\">Date.t</a> | no_return</code></pre>    <p>Parses the extended “Date and time of day” format described by ISO8601:2004.</p> <p>Raises if the format is invalid.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Date.from_iso8601!(\"2015-01-23\")\n~D[2015-01-23]\niex&gt; Date.from_iso8601!(\"2015:01:23\")\n** (ArgumentError) cannot parse \"2015:01:23\" as date, reason: :invalid_format</code></pre>    <h3 class=\"detail-header function\" id=\"new/3\">  <span class=\"signature\">new(year, month, day)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new(<a href=\"calendar#t:year/0\">Calendar.year</a>, <a href=\"calendar#t:month/0\">Calendar.month</a>, <a href=\"calendar#t:day/0\">Calendar.day</a>) ::\n  {:ok, <a href=\"date#t:t/0\">Date.t</a>} |\n  {:error, atom}</code></pre>    <p>Builds a new ISO date.</p> <p>Expects all values to be integers. Returns <code class=\"inline\">{:ok, time}</code> if each entry fits its appropriate range, returns <code class=\"inline\">:error</code> otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Date.new(2000, 1, 1)\n{:ok, ~D[2000-01-01]}\niex&gt; Date.new(2000, 13, 1)\n{:error, :invalid_date}\niex&gt; Date.new(2000, 2, 29)\n{:ok, ~D[2000-02-29]}\n\niex&gt; Date.new(2000, 2, 30)\n{:error, :invalid_date}\niex&gt; Date.new(2001, 2, 29)\n{:error, :invalid_date}</code></pre>    <h3 class=\"detail-header function\" id=\"to_erl/1\">  <span class=\"signature\">to_erl(date)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_erl(<a href=\"date#t:t/0\">Date.t</a>) :: :calendar.date</code></pre>    <p>Converts a <a href=\"date#content\"><code class=\"inline\">Date</code></a> struct to an Erlang date tuple.</p> <p>Only supports converting dates which are in the ISO calendar, attempting to convert dates from other calendars will raise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Date.to_erl(~D[2000-01-01])\n{2000, 1, 1}</code></pre>    <h3 class=\"detail-header function\" id=\"to_iso8601/1\">  <span class=\"signature\">to_iso8601(date)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_iso8601(<a href=\"date#t:t/0\">Date.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts the given date time to ISO8601.</p> <p>Only supports converting date times which are in the ISO calendar, attempting to convert date times from other calendars will raise.</p> <h3>Examples</h3> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Date.to_iso8601(~D[2000-02-28])\n\"2000-02-28\"</code></pre>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(date)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_string(<a href=\"date#t:t/0\">Date.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts the given date to a string according to its calendar.</p> <h3>Examples</h3> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Date.to_string(~D[2000-02-28])\n\"2000-02-28\"</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Date.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Date.html</a>\n  </p>\n</div>\n","elixir/datetime":"<h1>  DateTime  </h1>  <p>A datetime implementation with a time zone.</p> <p>This datetime can be seen as an ephemeral snapshot of a datetime at a given timezone. For such purposes, it also includes both UTC and Standard offsets, as well as the zone abbreviation field used exclusively for formatting purposes.</p> <p>Developers should avoid creating the DateTime struct directly and instead rely on the functions provided by this module as well as the ones in 3rd party calendar libraries.</p> <h2 id=\"module-where-are-my-functions\" class=\"section-heading\">  Where are my functions? </h2> <p>You will notice this module only contains conversion functions as well as functions that work on UTC. This is because a proper DateTime implementation requires a TimeZone database which currently is not provided as part of Elixir.</p> <p>Such may be addressed in upcoming versions, meanwhile, use 3rd party packages to provide DateTime building and similar functionality with time zone backing.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#from_unix/2\">from_unix(integer, unit \\\\ :seconds)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given Unix time to DateTime</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_unix!/2\">from_unix!(integer, unit \\\\ :seconds)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given Unix time to DateTime</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#precision_for_unit/1\">precision_for_unit(unit)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#to_date/1\">to_date(date_time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a <a href=\"datetime#content\"><code class=\"inline\">DateTime</code></a> into a <a href=\"date\"><code class=\"inline\">Date</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_iso8601/1\">to_iso8601(dt)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given date time to ISO8601</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_naive/1\">to_naive(date_time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a <a href=\"datetime#content\"><code class=\"inline\">DateTime</code></a> into a <a href=\"naivedatetime\"><code class=\"inline\">NaiveDateTime</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(dt)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given date time to a string according to its calendar</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_time/1\">to_time(date_time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a <a href=\"datetime#content\"><code class=\"inline\">DateTime</code></a> into <a href=\"time\"><code class=\"inline\">Time</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_unix/2\">to_unix(date_time, unit \\\\ :seconds)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given DateTime to Unix time</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#utc_now/0\">utc_now()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current datetime in UTC</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %DateTime{calendar: <a href=\"calendar#t:calendar/0\">Calendar.calendar</a>, day: <a href=\"calendar#t:day/0\">Calendar.day</a>, hour: <a href=\"calendar#t:hour/0\">Calendar.hour</a>, microsecond: <a href=\"calendar#t:microsecond/0\">Calendar.microsecond</a>, minute: <a href=\"calendar#t:minute/0\">Calendar.minute</a>, month: <a href=\"calendar#t:month/0\">Calendar.month</a>, second: <a href=\"calendar#t:second/0\">Calendar.second</a>, std_offset: <a href=\"calendar#t:std_offset/0\">Calendar.std_offset</a>, time_zone: <a href=\"calendar#t:time_zone/0\">Calendar.time_zone</a>, utc_offset: <a href=\"calendar#t:utc_offset/0\">Calendar.utc_offset</a>, year: <a href=\"calendar#t:year/0\">Calendar.year</a>, zone_abbr: <a href=\"calendar#t:zone_abbr/0\">Calendar.zone_abbr</a>}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"from_unix/2\">  <span class=\"signature\">from_unix(integer, unit \\\\ :seconds)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_unix(non_neg_integer, :native | <a href=\"system#t:time_unit/0\">System.time_unit</a>) :: {:ok, <a href=\"datetime#t:t/0\">DateTime.t</a>}</code></pre>    <p>Converts the given Unix time to DateTime.</p> <p>The integer can be given in different unit according to <a href=\"system#convert_time_unit/3\"><code class=\"inline\">System.convert_time_unit/3</code></a> and it will be converted to microseconds internally.</p> <p>Unix times are always in UTC and therefore the DateTime will be returned in UTC.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; DateTime.from_unix(1464096368)\n{:ok, %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: {0, 0}, minute: 26,\n                month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n                year: 2016, zone_abbr: \"UTC\"}}\n\niex&gt; DateTime.from_unix(1432560368868569, :microseconds)\n{:ok, %DateTime{calendar: Calendar.ISO, day: 25, hour: 13, microsecond: {868569, 6}, minute: 26,\n                month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n                year: 2015, zone_abbr: \"UTC\"}}</code></pre> <p>The unit can also be an integer as in <code class=\"inline\">System.time_unit</code>:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; DateTime.from_unix(1432560368868569, 1024)\n{:ok, %DateTime{calendar: Calendar.ISO, day: 23, hour: 22, microsecond: {211914, 3}, minute: 53,\n                month: 1, second: 43, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n                year: 46302, zone_abbr: \"UTC\"}}</code></pre>    <h3 class=\"detail-header function\" id=\"from_unix!/2\">  <span class=\"signature\">from_unix!(integer, unit \\\\ :seconds)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_unix!(non_neg_integer, :native | <a href=\"system#t:time_unit/0\">System.time_unit</a>) :: <a href=\"datetime#t:t/0\">DateTime.t</a></code></pre>    <p>Converts the given Unix time to DateTime.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; DateTime.from_unix!(1464096368)\n%DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: {0, 0}, minute: 26,\n          month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n          year: 2016, zone_abbr: \"UTC\"}\n\niex&gt; DateTime.from_unix!(1432560368868569, :microseconds)\n%DateTime{calendar: Calendar.ISO, day: 25, hour: 13, microsecond: {868569, 6}, minute: 26,\n          month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n          year: 2015, zone_abbr: \"UTC\"}</code></pre>    <h3 class=\"detail-header function\" id=\"precision_for_unit/1\">  <span class=\"signature\">precision_for_unit(unit)</span>  </h3>     <h3 class=\"detail-header function\" id=\"to_date/1\">  <span class=\"signature\">to_date(date_time)</span>  </h3>  <p>Converts a <a href=\"datetime#content\"><code class=\"inline\">DateTime</code></a> into a <a href=\"date\"><code class=\"inline\">Date</code></a>.</p> <p>Because <a href=\"date\"><code class=\"inline\">Date</code></a> does not hold time nor timezone information, data will be lost during the conversion.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n...&gt;                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\niex&gt; DateTime.to_date(dt)\n~D[2000-02-29]</code></pre>    <h3 class=\"detail-header function\" id=\"to_iso8601/1\">  <span class=\"signature\">to_iso8601(dt)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_iso8601(<a href=\"datetime#t:t/0\">DateTime.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts the given date time to ISO8601.</p> <p>Only supports converting date times which are in the ISO calendar, attempting to convert date times from other calendars will raise.</p> <p>WARNING: the ISO8601 does not contain the time zone nor its abbreviation, which means information is lost when converting to such format. This is also why this module does not provide a <code class=\"inline\">from_iso8601/1</code> function, as it is impossible to build a proper <a href=\"datetime#content\"><code class=\"inline\">DateTime</code></a> from only the information in the ISO8601 string.</p> <h3>Examples</h3> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n...&gt;                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\niex&gt; DateTime.to_iso8601(dt)\n\"2000-02-29T23:00:07+01:00\"\n\niex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n...&gt;                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\niex&gt; DateTime.to_iso8601(dt)\n\"2000-02-29T23:00:07Z\"\n\niex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n...&gt;                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\niex&gt; DateTime.to_iso8601(dt)\n\"2000-02-29T23:00:07-04:00\"</code></pre>    <h3 class=\"detail-header function\" id=\"to_naive/1\">  <span class=\"signature\">to_naive(date_time)</span>  </h3>  <p>Converts a <a href=\"datetime#content\"><code class=\"inline\">DateTime</code></a> into a <a href=\"naivedatetime\"><code class=\"inline\">NaiveDateTime</code></a>.</p> <p>Because <a href=\"naivedatetime\"><code class=\"inline\">NaiveDateTime</code></a> does not hold timezone information, any timezone related data will be lost during the conversion.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 1},\n...&gt;                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\niex&gt; DateTime.to_naive(dt)\n~N[2000-02-29 23:00:07.0]</code></pre>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(dt)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_string(<a href=\"datetime#t:t/0\">DateTime.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts the given date time to a string according to its calendar.</p> <h3>Examples</h3> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n...&gt;                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\niex&gt; DateTime.to_string(dt)\n\"2000-02-29 23:00:07+01:00 CET Europe/Warsaw\"\n\niex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n...&gt;                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\niex&gt; DateTime.to_string(dt)\n\"2000-02-29 23:00:07Z\"\n\niex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n...&gt;                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\niex&gt; DateTime.to_string(dt)\n\"2000-02-29 23:00:07-04:00 AMT America/Manaus\"</code></pre>    <h3 class=\"detail-header function\" id=\"to_time/1\">  <span class=\"signature\">to_time(date_time)</span>  </h3>  <p>Converts a <a href=\"datetime#content\"><code class=\"inline\">DateTime</code></a> into <a href=\"time\"><code class=\"inline\">Time</code></a>.</p> <p>Because <a href=\"time\"><code class=\"inline\">Time</code></a> does not hold date nor timezone information, data will be lost during the conversion.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 1},\n...&gt;                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\niex&gt; DateTime.to_time(dt)\n~T[23:00:07.0]</code></pre>    <h3 class=\"detail-header function\" id=\"to_unix/2\">  <span class=\"signature\">to_unix(date_time, unit \\\\ :seconds)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_unix(<a href=\"datetime#t:t/0\">DateTime.t</a>, <a href=\"system#t:time_unit/0\">System.time_unit</a>) :: non_neg_integer</code></pre>    <p>Converts the given DateTime to Unix time.</p> <p>The DateTime is expected to be using the ISO calendar with a year greater than or equal to 1970.</p> <p>It will return the integer with the given unit, according to <a href=\"system#convert_time_unit/3\"><code class=\"inline\">System.convert_time_unit/3</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1464096368 |&gt; DateTime.from_unix!() |&gt; DateTime.to_unix()\n1464096368\n\niex&gt; dt = %DateTime{calendar: Calendar.ISO, day: 20, hour: 18, microsecond: {273806, 6},\n...&gt;                minute: 58, month: 11, second: 19, time_zone: \"America/Montevideo\",\n...&gt;                utc_offset: -10800, std_offset: 3600, year: 2014, zone_abbr: \"UYST\"}\niex&gt; DateTime.to_unix(dt)\n1416517099</code></pre>    <h3 class=\"detail-header function\" id=\"utc_now/0\">  <span class=\"signature\">utc_now()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">utc_now :: <a href=\"datetime#t:t/0\">DateTime.t</a></code></pre>    <p>Returns the current datetime in UTC.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; datetime = DateTime.utc_now()\niex&gt; datetime.time_zone\n\"Etc/UTC\"</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/DateTime.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/DateTime.html</a>\n  </p>\n</div>\n","elixir/dict":"<h1>  Dict  </h1>  <p>WARNING: this module is deprecated.</p> <p>If you need a general dictionary, use the <a href=\"map\"><code class=\"inline\">Map</code></a> module. If you need to manipulate keyword lists, use <a href=\"keyword\"><code class=\"inline\">Keyword</code></a>.</p> <p>To convert maps into keywords and vice-versa, use the <code class=\"inline\">new</code> function in the respective modules.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:key/0\">key()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:value/0\">value()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#delete/2\">delete(dict, key)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#drop/2\">drop(dict, keys)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#empty/1\">empty(dict)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#equal?/2\">equal?(dict1, dict2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#fetch/2\">fetch(dict, key)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#fetch!/2\">fetch!(dict, key)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#get/3\">get(dict, key, default \\\\ nil)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#get_and_update/3\">get_and_update(dict, key, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#get_lazy/3\">get_lazy(dict, key, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#has_key?/2\">has_key?(dict, key)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#keys/1\">keys(dict)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#merge/2\">merge(dict1, dict2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#merge/3\">merge(dict1, dict2, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#pop/3\">pop(dict, key, default \\\\ nil)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#pop_lazy/3\">pop_lazy(dict, key, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#put/3\">put(dict, key, val)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#put_new/3\">put_new(dict, key, val)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#put_new_lazy/3\">put_new_lazy(dict, key, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#size/1\">size(dict)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#split/2\">split(dict, keys)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#take/2\">take(dict, keys)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#to_list/1\">to_list(dict)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#update/4\">update(dict, key, initial, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#update!/3\">update!(dict, key, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#values/1\">values(dict)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:key/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:key/0\">key</a> :: any</code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: list | map</code></pre> </div> <div id=\"t:value/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:value/0\">value</a> :: any</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"delete/2\">  <span class=\"signature\">delete(dict, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>) :: <a href=\"#t:t/0\">t</a></code></pre>       <h3 class=\"detail-header function\" id=\"drop/2\">  <span class=\"signature\">drop(dict, keys)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">drop(<a href=\"#t:t/0\">t</a>, [<a href=\"#t:key/0\">key</a>]) :: <a href=\"#t:t/0\">t</a></code></pre>       <h3 class=\"detail-header function\" id=\"empty/1\">  <span class=\"signature\">empty(dict)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">empty(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>       <h3 class=\"detail-header function\" id=\"equal?/2\">  <span class=\"signature\">equal?(dict1, dict2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">equal?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: boolean</code></pre>       <h3 class=\"detail-header function\" id=\"fetch/2\">  <span class=\"signature\">fetch(dict, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>) :: <a href=\"#t:value/0\">value</a></code></pre>       <h3 class=\"detail-header function\" id=\"fetch!/2\">  <span class=\"signature\">fetch!(dict, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch!(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>) :: <a href=\"#t:value/0\">value</a> | no_return</code></pre>       <h3 class=\"detail-header function\" id=\"get/3\">  <span class=\"signature\">get(dict, key, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: <a href=\"#t:value/0\">value</a></code></pre>       <h3 class=\"detail-header function\" id=\"get_and_update/3\">  <span class=\"signature\">get_and_update(dict, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_and_update(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (<a href=\"#t:value/0\">value</a> -&gt; {<a href=\"#t:value/0\">value</a>, <a href=\"#t:value/0\">value</a>})) :: {<a href=\"#t:value/0\">value</a>, <a href=\"#t:t/0\">t</a>}</code></pre>       <h3 class=\"detail-header function\" id=\"get_lazy/3\">  <span class=\"signature\">get_lazy(dict, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_lazy(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (() -&gt; <a href=\"#t:value/0\">value</a>)) :: <a href=\"#t:value/0\">value</a></code></pre>       <h3 class=\"detail-header function\" id=\"has_key?/2\">  <span class=\"signature\">has_key?(dict, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">has_key?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>) :: boolean</code></pre>       <h3 class=\"detail-header function\" id=\"keys/1\">  <span class=\"signature\">keys(dict)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">keys(<a href=\"#t:t/0\">t</a>) :: [<a href=\"#t:key/0\">key</a>]</code></pre>       <h3 class=\"detail-header function\" id=\"merge/2\">  <span class=\"signature\">merge(dict1, dict2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">merge(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>       <h3 class=\"detail-header function\" id=\"merge/3\">  <span class=\"signature\">merge(dict1, dict2, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">merge(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>, (<a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>, <a href=\"#t:value/0\">value</a> -&gt; <a href=\"#t:value/0\">value</a>)) :: <a href=\"#t:t/0\">t</a></code></pre>       <h3 class=\"detail-header function\" id=\"pop/3\">  <span class=\"signature\">pop(dict, key, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">pop(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: {<a href=\"#t:value/0\">value</a>, <a href=\"#t:t/0\">t</a>}</code></pre>       <h3 class=\"detail-header function\" id=\"pop_lazy/3\">  <span class=\"signature\">pop_lazy(dict, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">pop_lazy(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (() -&gt; <a href=\"#t:value/0\">value</a>)) :: {<a href=\"#t:value/0\">value</a>, <a href=\"#t:t/0\">t</a>}</code></pre>       <h3 class=\"detail-header function\" id=\"put/3\">  <span class=\"signature\">put(dict, key, val)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: <a href=\"#t:t/0\">t</a></code></pre>       <h3 class=\"detail-header function\" id=\"put_new/3\">  <span class=\"signature\">put_new(dict, key, val)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_new(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: <a href=\"#t:t/0\">t</a></code></pre>       <h3 class=\"detail-header function\" id=\"put_new_lazy/3\">  <span class=\"signature\">put_new_lazy(dict, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_new_lazy(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (() -&gt; <a href=\"#t:value/0\">value</a>)) :: <a href=\"#t:t/0\">t</a></code></pre>       <h3 class=\"detail-header function\" id=\"size/1\">  <span class=\"signature\">size(dict)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">size(<a href=\"#t:t/0\">t</a>) :: non_neg_integer</code></pre>       <h3 class=\"detail-header function\" id=\"split/2\">  <span class=\"signature\">split(dict, keys)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">split(<a href=\"#t:t/0\">t</a>, [<a href=\"#t:key/0\">key</a>]) :: {<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>}</code></pre>       <h3 class=\"detail-header function\" id=\"take/2\">  <span class=\"signature\">take(dict, keys)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">take(<a href=\"#t:t/0\">t</a>, [<a href=\"#t:key/0\">key</a>]) :: <a href=\"#t:t/0\">t</a></code></pre>       <h3 class=\"detail-header function\" id=\"to_list/1\">  <span class=\"signature\">to_list(dict)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_list(<a href=\"#t:t/0\">t</a>) :: list</code></pre>       <h3 class=\"detail-header function\" id=\"update/4\">  <span class=\"signature\">update(dict, key, initial, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>, (<a href=\"#t:value/0\">value</a> -&gt; <a href=\"#t:value/0\">value</a>)) :: <a href=\"#t:t/0\">t</a></code></pre>       <h3 class=\"detail-header function\" id=\"update!/3\">  <span class=\"signature\">update!(dict, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update!(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (<a href=\"#t:value/0\">value</a> -&gt; <a href=\"#t:value/0\">value</a>)) :: <a href=\"#t:t/0\">t</a></code></pre>       <h3 class=\"detail-header function\" id=\"values/1\">  <span class=\"signature\">values(dict)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">values(<a href=\"#t:t/0\">t</a>) :: [<a href=\"#t:value/0\">value</a>]</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Dict.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Dict.html</a>\n  </p>\n</div>\n","elixir/exception":"<h1>  Exception <small>behaviour</small>  </h1>  <p>Functions to format throw/catch/exit and exceptions.</p> <p>Note that stacktraces in Elixir are updated on throw, errors and exits. For example, at any given moment, <a href=\"system#stacktrace/0\"><code class=\"inline\">System.stacktrace/0</code></a> will return the stacktrace for the last throw/error/exit that occurred in the current process.</p> <p>Do not rely on the particular format returned by the <code class=\"inline\">format</code> functions in this module. They may be changed in future releases in order to better suit Elixir’s tool chain. In other words, by using the functions in this module it is guaranteed you will format exceptions as in the current Elixir version being used.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:kind/0\">kind()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The kind handled by formatting functions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:stacktrace/0\">stacktrace()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:stacktrace_entry/0\">stacktrace_entry()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The exception type</p> </dd>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception?/1\">exception?(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the given <code class=\"inline\">term</code> is an exception</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format/3\">format(kind, payload, stacktrace \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Normalizes and formats throw/errors/exits and stacktraces</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format_banner/3\">format_banner(kind, exception, stacktrace \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Normalizes and formats any throw/error/exit</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format_exit/1\">format_exit(reason)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Formats an exit. It returns a string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format_fa/2\">format_fa(fun, arity)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives an anonymous function and arity and formats it as shown in stacktraces. The arity may also be a list of arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format_file_line/3\">format_file_line(file, line, suffix \\\\ \"\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Formats the given <code class=\"inline\">file</code> and <code class=\"inline\">line</code> as shown in stacktraces. If any of the values are <code class=\"inline\">nil</code>, they are omitted</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format_mfa/3\">format_mfa(module, fun, arity)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a module, fun and arity and formats it as shown in stacktraces. The arity may also be a list of arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format_stacktrace/1\">format_stacktrace(trace \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Formats the stacktrace</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format_stacktrace_entry/1\">format_stacktrace_entry(entry)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a stacktrace entry and formats it into a string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the message for an <code class=\"inline\">exception</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#normalize/3\">normalize(kind, payload, stacktrace \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Normalizes an exception, converting Erlang exceptions to Elixir exceptions</p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:exception/1\">exception(term)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:message/1\">message(t)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:kind/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:kind/0\">kind</a> :: :error | :exit | :throw | {:EXIT, pid}</code></pre> <p>The kind handled by formatting functions</p>  </div> <div id=\"t:stacktrace/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:stacktrace/0\">stacktrace</a> :: [<a href=\"#t:stacktrace_entry/0\">stacktrace_entry</a>]</code></pre> </div> <div id=\"t:stacktrace_entry/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:stacktrace_entry/0\">stacktrace_entry</a> ::\n  {module, atom, arity_or_args, location} |\n  {(... -&gt; any), arity_or_args, location}</code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %module{:__exception__ =&gt; true, optional(atom) =&gt; any}</code></pre> <p>The exception type</p>  </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception?/1\">  <span class=\"signature\">exception?(term)</span>  </h3>  <p>Returns <code class=\"inline\">true</code> if the given <code class=\"inline\">term</code> is an exception.</p>    <h3 class=\"detail-header function\" id=\"format/3\">  <span class=\"signature\">format(kind, payload, stacktrace \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">format(<a href=\"#t:kind/0\">kind</a>, any, <a href=\"#t:stacktrace/0\">stacktrace</a> | nil) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Normalizes and formats throw/errors/exits and stacktraces.</p> <p>It relies on <a href=\"#format_banner/3\"><code class=\"inline\">format_banner/3</code></a> and <a href=\"#format_stacktrace/1\"><code class=\"inline\">format_stacktrace/1</code></a> to generate the final format.</p> <p>Note that <code class=\"inline\">{:EXIT, pid}</code> do not generate a stacktrace though (as they are retrieved as messages without stacktraces).</p>    <h3 class=\"detail-header function\" id=\"format_banner/3\">  <span class=\"signature\">format_banner(kind, exception, stacktrace \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">format_banner(<a href=\"#t:kind/0\">kind</a>, any, <a href=\"#t:stacktrace/0\">stacktrace</a> | nil) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Normalizes and formats any throw/error/exit.</p> <p>The message is formatted and displayed in the same format as used by Elixir’s CLI.</p> <p>The third argument, a stacktrace, is optional. If it is not supplied <a href=\"system#stacktrace/0\"><code class=\"inline\">System.stacktrace/0</code></a> will sometimes be used to get additional information for the <code class=\"inline\">kind</code> <code class=\"inline\">:error</code>. If the stacktrace is unknown and <a href=\"system#stacktrace/0\"><code class=\"inline\">System.stacktrace/0</code></a> would not return the stacktrace corresponding to the exception an empty stacktrace, <code class=\"inline\">[]</code>, must be used.</p>    <h3 class=\"detail-header function\" id=\"format_exit/1\">  <span class=\"signature\">format_exit(reason)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">format_exit(any) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Formats an exit. It returns a string.</p> <p>Often there are errors/exceptions inside exits. Exits are often wrapped by the caller and provide stacktraces too. This function formats exits in a way to nicely show the exit reason, caller and stacktrace.</p>    <h3 class=\"detail-header function\" id=\"format_fa/2\">  <span class=\"signature\">format_fa(fun, arity)</span>  </h3>  <p>Receives an anonymous function and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Exception.format_fa(fn -&gt; nil end, 1)\n#=&gt; \"#Function&lt;...&gt;/1\"</code></pre>    <h3 class=\"detail-header function\" id=\"format_file_line/3\">  <span class=\"signature\">format_file_line(file, line, suffix \\\\ \"\")</span>  </h3>  <p>Formats the given <code class=\"inline\">file</code> and <code class=\"inline\">line</code> as shown in stacktraces. If any of the values are <code class=\"inline\">nil</code>, they are omitted.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Exception.format_file_line(\"foo\", 1)\n\"foo:1:\"\n\niex&gt; Exception.format_file_line(\"foo\", nil)\n\"foo:\"\n\niex&gt; Exception.format_file_line(nil, nil)\n\"\"</code></pre>    <h3 class=\"detail-header function\" id=\"format_mfa/3\">  <span class=\"signature\">format_mfa(module, fun, arity)</span>  </h3>  <p>Receives a module, fun and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Exception.format_mfa Foo, :bar, 1\n\"Foo.bar/1\"\n\niex&gt; Exception.format_mfa Foo, :bar, []\n\"Foo.bar()\"\n\niex&gt; Exception.format_mfa nil, :bar, []\n\"nil.bar()\"</code></pre> <p>Anonymous functions are reported as -func/arity-anonfn-count-, where func is the name of the enclosing function. Convert to “anonymous fn in func/arity”</p>    <h3 class=\"detail-header function\" id=\"format_stacktrace/1\">  <span class=\"signature\">format_stacktrace(trace \\\\ nil)</span>  </h3>  <p>Formats the stacktrace.</p> <p>A stacktrace must be given as an argument. If not, the stacktrace is retrieved from <a href=\"process#info/2\"><code class=\"inline\">Process.info/2</code></a>.</p>    <h3 class=\"detail-header function\" id=\"format_stacktrace_entry/1\">  <span class=\"signature\">format_stacktrace_entry(entry)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">format_stacktrace_entry(<a href=\"#t:stacktrace_entry/0\">stacktrace_entry</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Receives a stacktrace entry and formats it into a string.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Gets the message for an <code class=\"inline\">exception</code>.</p>    <h3 class=\"detail-header function\" id=\"normalize/3\">  <span class=\"signature\">normalize(kind, payload, stacktrace \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">normalize(:error, any, <a href=\"#t:stacktrace/0\">stacktrace</a>) :: <a href=\"#t:t/0\">t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">normalize(<a href=\"#t:kind/0\">kind</a>, payload, <a href=\"#t:stacktrace/0\">stacktrace</a>) :: payload when payload: var</code></pre>    <p>Normalizes an exception, converting Erlang exceptions to Elixir exceptions.</p> <p>It takes the <code class=\"inline\">kind</code> spilled by <code class=\"inline\">catch</code> as an argument and normalizes only <code class=\"inline\">:error</code>, returning the untouched payload for others.</p> <p>The third argument, a stacktrace, is optional. If it is not supplied <a href=\"system#stacktrace/0\"><code class=\"inline\">System.stacktrace/0</code></a> will sometimes be used to get additional information for the <code class=\"inline\">kind</code> <code class=\"inline\">:error</code>. If the stacktrace is unknown and <a href=\"system#stacktrace/0\"><code class=\"inline\">System.stacktrace/0</code></a> would not return the stacktrace corresponding to the exception an empty stacktrace, <code class=\"inline\">[]</code>, must be used.</p>     <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:exception/1\">  <span class=\"signature\">exception(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(term) :: <a href=\"#t:t/0\">t</a></code></pre>       <h3 class=\"detail-header callback\" id=\"c:message/1\">  <span class=\"signature\">message(t)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"#t:t/0\">t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Exception.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Exception.html</a>\n  </p>\n</div>\n","elixir/file.stat":"<h1>  File.Stat  </h1>  <p>A struct that holds file information.</p> <p>In Erlang, this struct is represented by a <code class=\"inline\">:file_info</code> record. Therefore this module also provides functions for converting between the Erlang record and the Elixir struct.</p> <p>Its fields are:</p> <ul> <li>\n<p><code class=\"inline\">size</code> - size of file in bytes.</p> </li> <li>\n<p><code class=\"inline\">type</code> - <code class=\"inline\">:device | :directory | :regular | :other</code>; the type of the file.</p> </li> <li>\n<p><code class=\"inline\">access</code> - <code class=\"inline\">:read | :write | :read_write | :none</code>; the current system access to the file.</p> </li> <li>\n<p><code class=\"inline\">atime</code> - the last time the file was read.</p> </li> <li>\n<p><code class=\"inline\">mtime</code> - the last time the file was written.</p> </li> <li>\n<p><code class=\"inline\">ctime</code> - the interpretation of this time field depends on the operating system. On Unix, it is the last time the file or the inode was changed. In Windows, it is the time of creation.</p> </li> <li>\n<p><code class=\"inline\">mode</code> - the file permissions.</p> </li> <li>\n<p><code class=\"inline\">links</code> - the number of links to this file. This is always 1 for file systems which have no concept of links.</p> </li> <li>\n<p><code class=\"inline\">major_device</code> - identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</p> </li> <li>\n<p><code class=\"inline\">minor_device</code> - only valid for character devices on Unix. In all other cases, this field is zero.</p> </li> <li>\n<p><code class=\"inline\">inode</code> - gives the inode number. On non-Unix file systems, this field will be zero.</p> </li> <li>\n<p><code class=\"inline\">uid</code> - indicates the owner of the file. Will be zero for non-Unix file systems.</p> </li> <li>\n<code class=\"inline\">gid</code> - indicates the group that owns the file. Will be zero for non-Unix file systems. </li> </ul> <p>The time type returned in <code class=\"inline\">atime</code>, <code class=\"inline\">mtime</code>, and <code class=\"inline\">ctime</code> is dependent on the time type set in options. <code class=\"inline\">{:time, type}</code> where type can be <code class=\"inline\">:local</code>, <code class=\"inline\">:universal</code>, or <code class=\"inline\">:posix</code>. Default is <code class=\"inline\">:universal</code>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#from_record/1\">from_record(file_info)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a <code class=\"inline\">:file_info</code> record into a <a href=\"file.stat#content\"><code class=\"inline\">File.Stat</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_record/1\">to_record(stat)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a <a href=\"file.stat#content\"><code class=\"inline\">File.Stat</code></a> struct to a <code class=\"inline\">:file_info</code> record</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %File.Stat{access: term, atime: term, ctime: term, gid: term, inode: term, links: term, major_device: term, minor_device: term, mode: term, mtime: term, size: term, type: term, uid: term}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"from_record/1\">  <span class=\"signature\">from_record(file_info)</span>  </h3>  <p>Converts a <code class=\"inline\">:file_info</code> record into a <a href=\"file.stat#content\"><code class=\"inline\">File.Stat</code></a>.</p>    <h3 class=\"detail-header function\" id=\"to_record/1\">  <span class=\"signature\">to_record(stat)</span>  </h3>  <p>Converts a <a href=\"file.stat#content\"><code class=\"inline\">File.Stat</code></a> struct to a <code class=\"inline\">:file_info</code> record.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/File.Stat.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/File.Stat.html</a>\n  </p>\n</div>\n","elixir/file.stream":"<h1>  File.Stream  </h1>  <p>Defines a <a href=\"file.stream#content\"><code class=\"inline\">File.Stream</code></a> struct returned by <a href=\"file#stream!/3\"><code class=\"inline\">File.stream!/3</code></a>.</p> <p>The following fields are public:</p> <ul> <li>\n<code class=\"inline\">path</code> - the file path </li> <li>\n<code class=\"inline\">modes</code> - the file modes </li> <li>\n<code class=\"inline\">raw</code> - a boolean indicating if bin functions should be used </li> <li>\n<code class=\"inline\">line_or_bytes</code> - if reading should read lines or a given amount of bytes </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %File.Stream{line_or_bytes: term, modes: term, path: term, raw: term}</code></pre> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/File.Stream.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/File.Stream.html</a>\n  </p>\n</div>\n","elixir/float":"<h1>  Float  </h1>  <p>Functions for working with floating point numbers.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#ceil/2\">ceil(number, precision \\\\ 0)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Rounds a float to the smallest integer greater than or equal to <code class=\"inline\">num</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#floor/2\">floor(number, precision \\\\ 0)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Rounds a float to the largest integer less than or equal to <code class=\"inline\">num</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#parse/1\">parse(binary)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses a binary into a float</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#round/2\">round(number, precision \\\\ 0)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Rounds a floating point value to an arbitrary number of fractional digits (between 0 and 15)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_charlist/1\">to_charlist(float)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a charlist which corresponds to the text representation of the given float</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(float)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a binary which corresponds to the text representation of the given float</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"ceil/2\">  <span class=\"signature\">ceil(number, precision \\\\ 0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">ceil(float, 0..15) :: float</code></pre>    <p>Rounds a float to the smallest integer greater than or equal to <code class=\"inline\">num</code>.</p> <p><a href=\"#ceil/2\"><code class=\"inline\">ceil/2</code></a> also accepts a precision to round a floating point value down to an arbitrary number of fractional digits (between 0 and 15).</p> <p>This function always returns floats. <a href=\"kernel#trunc/1\"><code class=\"inline\">Kernel.trunc/1</code></a> may be used instead to truncate the result to an integer afterwards.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Float.ceil(34.25)\n35.0\n\niex&gt; Float.ceil(-56.5)\n-56.0\n\niex&gt; Float.ceil(34.251, 2)\n34.26</code></pre>    <h3 class=\"detail-header function\" id=\"floor/2\">  <span class=\"signature\">floor(number, precision \\\\ 0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">floor(float, 0..15) :: float</code></pre>    <p>Rounds a float to the largest integer less than or equal to <code class=\"inline\">num</code>.</p> <p><a href=\"#floor/2\"><code class=\"inline\">floor/2</code></a> also accepts a precision to round a floating point value down to an arbitrary number of fractional digits (between 0 and 15).</p> <p>This function always returns a float. <a href=\"kernel#trunc/1\"><code class=\"inline\">Kernel.trunc/1</code></a> may be used instead to truncate the result to an integer afterwards.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Float.floor(34.25)\n34.0\n\niex&gt; Float.floor(-56.5)\n-57.0\n\niex&gt; Float.floor(34.259, 2)\n34.25</code></pre>    <h3 class=\"detail-header function\" id=\"parse/1\">  <span class=\"signature\">parse(binary)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">parse(binary) :: {float, binary} | :error</code></pre>    <p>Parses a binary into a float.</p> <p>If successful, returns a tuple in the form of <code class=\"inline\">{float, remainder_of_binary}</code>; when the binary cannot be coerced into a valid float, the atom <code class=\"inline\">:error</code> is returned.</p> <p>If the size of float exceeds the maximum size of <code class=\"inline\">1.7976931348623157e+308</code>, the <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> exception is raised.</p> <p>If you want to convert a string-formatted float directly to a float, <a href=\"string#to_float/1\"><code class=\"inline\">String.to_float/1</code></a> can be used instead.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Float.parse(\"34\")\n{34.0, \"\"}\n\niex&gt; Float.parse(\"34.25\")\n{34.25, \"\"}\n\niex&gt; Float.parse(\"56.5xyz\")\n{56.5, \"xyz\"}\n\niex&gt; Float.parse(\"pi\")\n:error</code></pre>    <h3 class=\"detail-header function\" id=\"round/2\">  <span class=\"signature\">round(number, precision \\\\ 0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">round(float, 0..15) :: float</code></pre>    <p>Rounds a floating point value to an arbitrary number of fractional digits (between 0 and 15).</p> <p>This function only accepts floats and always returns a float. Use <a href=\"kernel#round/1\"><code class=\"inline\">Kernel.round/1</code></a> if you want a function that accepts both floats and integers and always returns an integer.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Float.round(5.5674, 3)\n5.567\n\niex&gt; Float.round(5.5675, 3)\n5.568\n\niex&gt; Float.round(-5.5674, 3)\n-5.567\n\niex&gt; Float.round(-5.5675, 3)\n-5.568\n\niex&gt; Float.round(-5.5675)\n-6.0</code></pre>    <h3 class=\"detail-header function\" id=\"to_charlist/1\">  <span class=\"signature\">to_charlist(float)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_charlist(float) :: charlist</code></pre>    <p>Returns a charlist which corresponds to the text representation of the given float.</p> <p>It uses the shortest representation according to algorithm described in “Printing Floating-Point Numbers Quickly and Accurately” in Proceedings of the SIGPLAN ‘96 Conference on Programming Language Design and Implementation.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Float.to_charlist(7.0)\n'7.0'</code></pre>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(float)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_string(float) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Returns a binary which corresponds to the text representation of the given float.</p> <p>It uses the shortest representation according to algorithm described in “Printing Floating-Point Numbers Quickly and Accurately” in Proceedings of the SIGPLAN ‘96 Conference on Programming Language Design and Implementation.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Float.to_string(7.0)\n\"7.0\"</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Float.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Float.html</a>\n  </p>\n</div>\n","elixir/code":"<h1>  Code  </h1>  <p>Utilities for managing code compilation, code evaluation and code loading.</p> <p>This module complements Erlang’s <a href=\"http://www.erlang.org/doc/man/code.html\"><code class=\"inline\">:code</code> module</a> to add behaviour which is specific to Elixir. Almost all of the functions in this module have global side effects on the behaviour of Elixir.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#append_path/1\">append_path(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Appends a path to the end of the Erlang VM code path list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#available_compiler_options/0\">available_compiler_options()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list with the available compiler options</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compile_quoted/2\">compile_quoted(quoted, file \\\\ \"nofile\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compiles the quoted expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compile_string/2\">compile_string(string, file \\\\ \"nofile\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compiles the given string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compiler_options/0\">compiler_options()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the compilation options from the code server</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compiler_options/1\">compiler_options(opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets compilation options</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete_path/1\">delete_path(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ensure_compiled/1\">ensure_compiled(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Ensures the given module is compiled and loaded</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ensure_compiled?/1\">ensure_compiled?(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Ensures the given module is compiled and loaded</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ensure_loaded/1\">ensure_loaded(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Ensures the given module is loaded</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ensure_loaded?/1\">ensure_loaded?(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Ensures the given module is loaded</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#eval_file/2\">eval_file(file, relative_to \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Evals the given file</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#eval_quoted/3\">eval_quoted(quoted, binding \\\\ [], opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Evaluates the quoted contents</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#eval_string/3\">eval_string(string, binding \\\\ [], opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Evaluates the contents given by <code class=\"inline\">string</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_docs/2\">get_docs(module, kind)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the docs for the given module</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#load_file/2\">load_file(file, relative_to \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Loads the given file</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#loaded_files/0\">loaded_files()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Lists all loaded files</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#prepend_path/1\">prepend_path(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prepends a path to the beginning of the Erlang VM code path list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#require_file/2\">require_file(file, relative_to \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Requires the given <code class=\"inline\">file</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#string_to_quoted/2\">string_to_quoted(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given string to its quoted form</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#string_to_quoted!/2\">string_to_quoted!(string, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given string to its quoted form</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unload_files/1\">unload_files(files)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes files from the loaded files list</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"append_path/1\">  <span class=\"signature\">append_path(path)</span>  </h3>  <p>Appends a path to the end of the Erlang VM code path list.</p> <p>This is the list of directories the Erlang VM uses for finding module code.</p> <p>The path is expanded with <a href=\"path#expand/1\"><code class=\"inline\">Path.expand/1</code></a> before being appended. If this path does not exist, an error is returned.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Code.append_path(\".\") #=&gt; true\n\nCode.append_path(\"/does_not_exist\") #=&gt; {:error, :bad_directory}</code></pre>    <h3 class=\"detail-header function\" id=\"available_compiler_options/0\">  <span class=\"signature\">available_compiler_options()</span>  </h3>  <p>Returns a list with the available compiler options.</p> <p>See <a href=\"code#compiler_options/1\"><code class=\"inline\">Code.compiler_options/1</code></a> for more info.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Code.available_compiler_options\n[:docs, :debug_info, :ignore_module_conflict, :warnings_as_errors]</code></pre>    <h3 class=\"detail-header function\" id=\"compile_quoted/2\">  <span class=\"signature\">compile_quoted(quoted, file \\\\ \"nofile\")</span>  </h3>  <p>Compiles the quoted expression.</p> <p>Returns a list of tuples where the first element is the module name and the second one is its byte code (as a binary).</p>    <h3 class=\"detail-header function\" id=\"compile_string/2\">  <span class=\"signature\">compile_string(string, file \\\\ \"nofile\")</span>  </h3>  <p>Compiles the given string.</p> <p>Returns a list of tuples where the first element is the module name and the second one is its byte code (as a binary).</p> <p>For compiling many files at once, check <a href=\"kernel.parallelcompiler#files/2\"><code class=\"inline\">Kernel.ParallelCompiler.files/2</code></a>.</p>    <h3 class=\"detail-header function\" id=\"compiler_options/0\">  <span class=\"signature\">compiler_options()</span>  </h3>  <p>Gets the compilation options from the code server.</p> <p>Check <a href=\"#compiler_options/1\"><code class=\"inline\">compiler_options/1</code></a> for more information.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Code.compiler_options\n#=&gt; %{debug_info: true, docs: true,\n      warnings_as_errors: false, ignore_module_conflict: false}</code></pre>    <h3 class=\"detail-header function\" id=\"compiler_options/1\">  <span class=\"signature\">compiler_options(opts)</span>  </h3>  <p>Sets compilation options.</p> <p>These options are global since they are stored by Elixir’s Code Server.</p> <p>Available options are:</p> <ul> <li>\n<p><code class=\"inline\">:docs</code> - when <code class=\"inline\">true</code>, retain documentation in the compiled module, <code class=\"inline\">true</code> by default</p> </li> <li>\n<p><code class=\"inline\">:debug_info</code> - when <code class=\"inline\">true</code>, retain debug information in the compiled module; this allows a developer to reconstruct the original source code, <code class=\"inline\">false</code> by default</p> </li> <li>\n<p><code class=\"inline\">:ignore_module_conflict</code> - when <code class=\"inline\">true</code>, override modules that were already defined without raising errors, <code class=\"inline\">false</code> by default</p> </li> <li>\n<code class=\"inline\">:warnings_as_errors</code> - cause compilation to fail when warnings are generated </li> </ul> <p>It returns the new list of compiler options.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Code.compiler_options(debug_info: true)\n#=&gt; %{debug_info: true, docs: true,\n      warnings_as_errors: false, ignore_module_conflict: false}</code></pre>    <h3 class=\"detail-header function\" id=\"delete_path/1\">  <span class=\"signature\">delete_path(path)</span>  </h3>  <p>Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code.</p> <p>The path is expanded with <a href=\"path#expand/1\"><code class=\"inline\">Path.expand/1</code></a> before being deleted. If the path does not exist it returns <code class=\"inline\">false</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Code.prepend_path(\".\")\nCode.delete_path(\".\") #=&gt; true\n\nCode.delete_path(\"/does_not_exist\") #=&gt; false</code></pre>    <h3 class=\"detail-header function\" id=\"ensure_compiled/1\">  <span class=\"signature\">ensure_compiled(module)</span>  </h3>  <p>Ensures the given module is compiled and loaded.</p> <p>If the module is already loaded, it works as no-op. If the module was not loaded yet, it checks if it needs to be compiled first and then tries to load it.</p> <p>If it succeeds loading the module, it returns <code class=\"inline\">{:module, module}</code>. If not, returns <code class=\"inline\">{:error, reason}</code> with the error reason.</p> <p>Check <a href=\"#ensure_loaded/1\"><code class=\"inline\">ensure_loaded/1</code></a> for more information on module loading and when to use <a href=\"#ensure_loaded/1\"><code class=\"inline\">ensure_loaded/1</code></a> or <a href=\"#ensure_compiled/1\"><code class=\"inline\">ensure_compiled/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"ensure_compiled?/1\">  <span class=\"signature\">ensure_compiled?(module)</span>  </h3>  <p>Ensures the given module is compiled and loaded.</p> <p>Similar to <a href=\"#ensure_compiled/1\"><code class=\"inline\">ensure_compiled/1</code></a>, but returns <code class=\"inline\">true</code> if the module is already loaded or was successfully loaded and compiled. Returns <code class=\"inline\">false</code> otherwise.</p>    <h3 class=\"detail-header function\" id=\"ensure_loaded/1\">  <span class=\"signature\">ensure_loaded(module)</span>  </h3>  <p>Ensures the given module is loaded.</p> <p>If the module is already loaded, this works as no-op. If the module was not yet loaded, it tries to load it.</p> <p>If it succeeds loading the module, it returns <code class=\"inline\">{:module, module}</code>. If not, returns <code class=\"inline\">{:error, reason}</code> with the error reason.</p> <h4>Code loading on the Erlang VM</h4> <p>Erlang has two modes to load code: interactive and embedded.</p> <p>By default, the Erlang VM runs in interactive mode, where modules are loaded as needed. In embedded mode the opposite happens, as all modules need to be loaded upfront or explicitly.</p> <p>Therefore, this function is used to check if a module is loaded before using it and allows one to react accordingly. For example, the <a href=\"uri\"><code class=\"inline\">URI</code></a> module uses this function to check if a specific parser exists for a given URI scheme.</p> <h4>Code.ensure_compiled/1</h4> <p>Elixir also contains an <a href=\"#ensure_compiled/1\"><code class=\"inline\">ensure_compiled/1</code></a> function that is a superset of <a href=\"#ensure_loaded/1\"><code class=\"inline\">ensure_loaded/1</code></a>.</p> <p>Since Elixir’s compilation happens in parallel, in some situations you may need to use a module that was not yet compiled, therefore it can’t even be loaded.</p> <p><a href=\"#ensure_compiled/1\"><code class=\"inline\">ensure_compiled/1</code></a> halts the current process until the module we are depending on is available.</p> <p>In most cases, <a href=\"#ensure_loaded/1\"><code class=\"inline\">ensure_loaded/1</code></a> is enough. <a href=\"#ensure_compiled/1\"><code class=\"inline\">ensure_compiled/1</code></a> must be used in rare cases, usually involving macros that need to invoke a module for callback information.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Code.ensure_loaded(Atom)\n{:module, Atom}\n\niex&gt; Code.ensure_loaded(DoesNotExist)\n{:error, :nofile}</code></pre>    <h3 class=\"detail-header function\" id=\"ensure_loaded?/1\">  <span class=\"signature\">ensure_loaded?(module)</span>  </h3>  <p>Ensures the given module is loaded.</p> <p>Similar to <a href=\"#ensure_loaded/1\"><code class=\"inline\">ensure_loaded/1</code></a>, but returns <code class=\"inline\">true</code> if the module is already loaded or was successfully loaded. Returns <code class=\"inline\">false</code> otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Code.ensure_loaded?(Atom)\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"eval_file/2\">  <span class=\"signature\">eval_file(file, relative_to \\\\ nil)</span>  </h3>  <p>Evals the given file.</p> <p>Accepts <code class=\"inline\">relative_to</code> as an argument to tell where the file is located.</p> <p>While <code class=\"inline\">load_file</code> loads a file and returns the loaded modules and their byte code, <code class=\"inline\">eval_file</code> simply evaluates the file contents and returns the evaluation result and its bindings.</p>    <h3 class=\"detail-header function\" id=\"eval_quoted/3\">  <span class=\"signature\">eval_quoted(quoted, binding \\\\ [], opts \\\\ [])</span>  </h3>  <p>Evaluates the quoted contents.</p> <p>See <a href=\"#eval_string/3\"><code class=\"inline\">eval_string/3</code></a> for a description of arguments and return values.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; contents = quote(do: var!(a) + var!(b))\niex&gt; Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n{3, [a: 1, b: 2]}</code></pre> <p>For convenience, you can pass <code class=\"inline\">__ENV__</code> as the <code class=\"inline\">opts</code> argument and all options will be automatically extracted from the current environment:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; contents = quote(do: var!(a) + var!(b))\niex&gt; Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n{3, [a: 1, b: 2]}</code></pre>    <h3 class=\"detail-header function\" id=\"eval_string/3\">  <span class=\"signature\">eval_string(string, binding \\\\ [], opts \\\\ [])</span>  </h3>  <p>Evaluates the contents given by <code class=\"inline\">string</code>.</p> <p>The <code class=\"inline\">binding</code> argument is a keyword list of variable bindings. The <code class=\"inline\">opts</code> argument is a keyword list of environment options.</p> <p>Those options can be:</p> <ul> <li>\n<code class=\"inline\">:file</code> - the file to be considered in the evaluation </li> <li>\n<code class=\"inline\">:line</code> - the line on which the script starts </li> </ul> <p>Additionally, the following scope values can be configured:</p> <ul> <li>\n<p><code class=\"inline\">:aliases</code> - a list of tuples with the alias and its target</p> </li> <li>\n<p><code class=\"inline\">:requires</code> - a list of modules required</p> </li> <li>\n<p><code class=\"inline\">:functions</code> - a list of tuples where the first element is a module and the second a list of imported function names and arity; the list of function names and arity must be sorted</p> </li> <li>\n<code class=\"inline\">:macros</code> - a list of tuples where the first element is a module and the second a list of imported macro names and arity; the list of function names and arity must be sorted </li> </ul> <p>Notice that setting any of the values above overrides Elixir’s default values. For example, setting <code class=\"inline\">:requires</code> to <code class=\"inline\">[]</code>, will no longer automatically require the <a href=\"kernel\"><code class=\"inline\">Kernel</code></a> module; in the same way setting <code class=\"inline\">:macros</code> will no longer auto-import <a href=\"kernel\"><code class=\"inline\">Kernel</code></a> macros like <code class=\"inline\">if/2</code>, <code class=\"inline\">case/2</code>, etc.</p> <p>Returns a tuple of the form <code class=\"inline\">{value, binding}</code>, where <code class=\"inline\">value</code> is the value returned from evaluating <code class=\"inline\">string</code>. If an error occurs while evaluating <code class=\"inline\">string</code> an exception will be raised.</p> <p><code class=\"inline\">binding</code> is a keyword list with the value of all variable bindings after evaluating <code class=\"inline\">string</code>. The binding key is usually an atom, but it may be a tuple for variables defined in a different context.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n{3, [a: 1, b: 2]}\n\niex&gt; Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n{3, [a: 1, b: 2, c: 3]}\n\niex&gt; Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n{3, [a: 3, b: 2]}</code></pre> <p>For convenience, you can pass <code class=\"inline\">__ENV__</code> as the <code class=\"inline\">opts</code> argument and all imports, requires and aliases defined in the current environment will be automatically carried over:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n{3, [a: 1, b: 2]}</code></pre>    <h3 class=\"detail-header function\" id=\"get_docs/2\">  <span class=\"signature\">get_docs(module, kind)</span>  </h3>  <p>Returns the docs for the given module.</p> <p>When given a module name, it finds its BEAM code and reads the docs from it.</p> <p>When given a path to a .beam file, it will load the docs directly from that file.</p> <p>The return value depends on the <code class=\"inline\">kind</code> value:</p> <ul> <li>\n<p><code class=\"inline\">:docs</code> - list of all docstrings attached to functions and macros using the <code class=\"inline\">@doc</code> attribute</p> </li> <li>\n<p><code class=\"inline\">:moduledoc</code> - tuple <code class=\"inline\">{&lt;line&gt;, &lt;doc&gt;}</code> where <code class=\"inline\">line</code> is the line on which module definition starts and <code class=\"inline\">doc</code> is the string attached to the module using the <code class=\"inline\">@moduledoc</code> attribute</p> </li> <li>\n<p><code class=\"inline\">:callback_docs</code> - list of all docstrings attached to <code class=\"inline\">@callbacks</code> using the <code class=\"inline\">@doc</code> attribute</p> </li> <li>\n<p><code class=\"inline\">:type_docs</code> - list of all docstrings attached to <code class=\"inline\">@type</code> callbacks using the <code class=\"inline\">@typedoc</code> attribute</p> </li> <li>\n<code class=\"inline\">:all</code> - a keyword list with <code class=\"inline\">:docs</code> and <code class=\"inline\">:moduledoc</code>, <code class=\"inline\">:callback_docs</code>, and <code class=\"inline\">:type_docs</code>. </li> </ul> <p>If the module cannot be found, it returns <code class=\"inline\">nil</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Get the module documentation\niex&gt; {_line, text} = Code.get_docs(Atom, :moduledoc)\niex&gt; String.split(text, \"\\n\") |&gt; Enum.at(0)\n\"Convenience functions for working with atoms.\"\n\n# Module doesn't exist\niex&gt; Code.get_docs(ModuleNotGood, :all)\nnil</code></pre>    <h3 class=\"detail-header function\" id=\"load_file/2\">  <span class=\"signature\">load_file(file, relative_to \\\\ nil)</span>  </h3>  <p>Loads the given file.</p> <p>Accepts <code class=\"inline\">relative_to</code> as an argument to tell where the file is located. If the file was already required/loaded, loads it again.</p> <p>It returns a list of tuples <code class=\"inline\">{ModuleName, &lt;&lt;byte_code&gt;&gt;}</code>, one tuple for each module defined in the file.</p> <p>Notice that if <code class=\"inline\">load_file</code> is invoked by different processes concurrently, the target file will be loaded concurrently many times. Check <a href=\"#require_file/2\"><code class=\"inline\">require_file/2</code></a> if you don’t want a file to be loaded concurrently.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Code.load_file(\"eex_test.exs\", \"../eex/test\") |&gt; List.first\n#=&gt; {EExTest.Compiled, &lt;&lt;70, 79, 82, 49, ...&gt;&gt;}</code></pre>    <h3 class=\"detail-header function\" id=\"loaded_files/0\">  <span class=\"signature\">loaded_files()</span>  </h3>  <p>Lists all loaded files.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Code.require_file(\"../eex/test/eex_test.exs\")\nList.first(Code.loaded_files) =~ \"eex_test.exs\" #=&gt; true</code></pre>    <h3 class=\"detail-header function\" id=\"prepend_path/1\">  <span class=\"signature\">prepend_path(path)</span>  </h3>  <p>Prepends a path to the beginning of the Erlang VM code path list.</p> <p>This is the list of directories the Erlang VM uses for finding module code.</p> <p>The path is expanded with <a href=\"path#expand/1\"><code class=\"inline\">Path.expand/1</code></a> before being prepended. If this path does not exist, an error is returned.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Code.prepend_path(\".\") #=&gt; true\n\nCode.prepend_path(\"/does_not_exist\") #=&gt; {:error, :bad_directory}</code></pre>    <h3 class=\"detail-header function\" id=\"require_file/2\">  <span class=\"signature\">require_file(file, relative_to \\\\ nil)</span>  </h3>  <p>Requires the given <code class=\"inline\">file</code>.</p> <p>Accepts <code class=\"inline\">relative_to</code> as an argument to tell where the file is located. The return value is the same as that of <a href=\"#load_file/2\"><code class=\"inline\">load_file/2</code></a>. If the file was already required/loaded, doesn’t do anything and returns <code class=\"inline\">nil</code>.</p> <p>Notice that if <code class=\"inline\">require_file</code> is invoked by different processes concurrently, the first process to invoke <code class=\"inline\">require_file</code> acquires a lock and the remaining ones will block until the file is available. I.e. if <code class=\"inline\">require_file</code> is called N times with a given file, it will be loaded only once. The first process to call <code class=\"inline\">require_file</code> will get the list of loaded modules, others will get <code class=\"inline\">nil</code>.</p> <p>Check <a href=\"#load_file/2\"><code class=\"inline\">load_file/2</code></a> if you want a file to be loaded multiple times. See also <a href=\"#unload_files/1\"><code class=\"inline\">unload_files/1</code></a></p> <h4>Examples</h4> <p>If the code is already loaded, it returns <code class=\"inline\">nil</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Code.require_file(\"eex_test.exs\", \"../eex/test\") #=&gt; nil</code></pre> <p>If the code is not loaded yet, it returns the same as <a href=\"#load_file/2\"><code class=\"inline\">load_file/2</code></a>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Code.require_file(\"eex_test.exs\", \"../eex/test\") |&gt; List.first\n#=&gt; {EExTest.Compiled, &lt;&lt;70, 79, 82, 49, ...&gt;&gt;}</code></pre>    <h3 class=\"detail-header function\" id=\"string_to_quoted/2\">  <span class=\"signature\">string_to_quoted(string, opts \\\\ [])</span>  </h3>  <p>Converts the given string to its quoted form.</p> <p>Returns <code class=\"inline\">{:ok, quoted_form}</code> if it succeeds, <code class=\"inline\">{:error, {line, error, token}}</code> otherwise.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:file</code> - the filename to be used in stacktraces and the file reported in the <code class=\"inline\">__ENV__</code> variable</p> </li> <li>\n<p><code class=\"inline\">:line</code> - the line reported in the <code class=\"inline\">__ENV__</code> variable</p> </li> <li>\n<code class=\"inline\">:existing_atoms_only</code> - when <code class=\"inline\">true</code>, raises an error when non-existing atoms are found by the tokenizer </li> </ul> <h4>Macro.to_string/2</h4> <p>The opposite of converting a string to its quoted form is <a href=\"macro#to_string/2\"><code class=\"inline\">Macro.to_string/2</code></a>, which converts a quoted form to a string/binary representation.</p>    <h3 class=\"detail-header function\" id=\"string_to_quoted!/2\">  <span class=\"signature\">string_to_quoted!(string, opts \\\\ [])</span>  </h3>  <p>Converts the given string to its quoted form.</p> <p>It returns the ast if it succeeds, raises an exception otherwise. The exception is a <a href=\"tokenmissingerror\"><code class=\"inline\">TokenMissingError</code></a> in case a token is missing (usually because the expression is incomplete), <a href=\"syntaxerror\"><code class=\"inline\">SyntaxError</code></a> otherwise.</p> <p>Check <a href=\"#string_to_quoted/2\"><code class=\"inline\">string_to_quoted/2</code></a> for options information.</p>    <h3 class=\"detail-header function\" id=\"unload_files/1\">  <span class=\"signature\">unload_files(files)</span>  </h3>  <p>Removes files from the loaded files list.</p> <p>The modules defined in the file are not removed; calling this function only removes them from the list, allowing them to be required again.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Load EEx test code, unload file, check for functions still available\nCode.load_file(\"../eex/test/eex_test.exs\")\nCode.unload_files(Code.loaded_files)\nfunction_exported?(EExTest.Compiled, :before_compile, 0) #=&gt; true</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Code.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Code.html</a>\n  </p>\n</div>\n","elixir/genevent.stream":"<h1>  GenEvent.Stream  </h1>  <p>Defines a <a href=\"genevent\"><code class=\"inline\">GenEvent</code></a> stream.</p> <p>This is a struct returned by <a href=\"genevent#stream/2\"><code class=\"inline\">GenEvent.stream/2</code></a>. The struct is public and contains the following fields:</p> <ul> <li>\n<code class=\"inline\">:manager</code> - the manager reference given to <a href=\"genevent#stream/2\"><code class=\"inline\">GenEvent.stream/2</code></a> </li> <li>\n<code class=\"inline\">:timeout</code> - the timeout between events, defaults to <code class=\"inline\">:infinity</code> </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %GenEvent.Stream{manager: <a href=\"genevent#t:manager/0\">GenEvent.manager</a>, timeout: timeout}</code></pre> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/GenEvent.Stream.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/GenEvent.Stream.html</a>\n  </p>\n</div>\n","elixir/hashset":"<h1>  HashSet  </h1>  <p>WARNING: this module is deprecated.</p> <p>Use the <a href=\"mapset\"><code class=\"inline\">MapSet</code></a> module instead.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#delete/2\">delete(set, term)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#difference/2\">difference(set1, set2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#disjoint?/2\">disjoint?(set1, set2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#equal?/2\">equal?(set1, set2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#intersection/2\">intersection(set1, set2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#member?/2\">member?(hash_set, term)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#new/0\">new()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#put/2\">put(hash_set, term)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#size/1\">size(hash_set)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#subset?/2\">subset?(set1, set2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#to_list/1\">to_list(set)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#union/2\">union(set1, set2)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a></code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"delete/2\">  <span class=\"signature\">delete(set, term)</span>  </h3>     <h3 class=\"detail-header function\" id=\"difference/2\">  <span class=\"signature\">difference(set1, set2)</span>  </h3>     <h3 class=\"detail-header function\" id=\"disjoint?/2\">  <span class=\"signature\">disjoint?(set1, set2)</span>  </h3>     <h3 class=\"detail-header function\" id=\"equal?/2\">  <span class=\"signature\">equal?(set1, set2)</span>  </h3>     <h3 class=\"detail-header function\" id=\"intersection/2\">  <span class=\"signature\">intersection(set1, set2)</span>  </h3>     <h3 class=\"detail-header function\" id=\"member?/2\">  <span class=\"signature\">member?(hash_set, term)</span>  </h3>     <h3 class=\"detail-header function\" id=\"new/0\">  <span class=\"signature\">new()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new :: <a href=\"set#t:t/0\">Set.t</a></code></pre>       <h3 class=\"detail-header function\" id=\"put/2\">  <span class=\"signature\">put(hash_set, term)</span>  </h3>     <h3 class=\"detail-header function\" id=\"size/1\">  <span class=\"signature\">size(hash_set)</span>  </h3>     <h3 class=\"detail-header function\" id=\"subset?/2\">  <span class=\"signature\">subset?(set1, set2)</span>  </h3>     <h3 class=\"detail-header function\" id=\"to_list/1\">  <span class=\"signature\">to_list(set)</span>  </h3>     <h3 class=\"detail-header function\" id=\"union/2\">  <span class=\"signature\">union(set1, set2)</span>  </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/HashSet.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/HashSet.html</a>\n  </p>\n</div>\n","elixir/io.stream":"<h1>  IO.Stream  </h1>  <p>Defines an <a href=\"io.stream#content\"><code class=\"inline\">IO.Stream</code></a> struct returned by <a href=\"io#stream/2\"><code class=\"inline\">IO.stream/2</code></a> and <a href=\"io#binstream/2\"><code class=\"inline\">IO.binstream/2</code></a>.</p> <p>The following fields are public:</p> <ul> <li>\n<code class=\"inline\">device</code> - the IO device </li> <li>\n<code class=\"inline\">raw</code> - a boolean indicating if bin functions should be used </li> <li>\n<code class=\"inline\">line_or_bytes</code> - if reading should read lines or a given amount of bytes </li> </ul> <p>It is worth noting that an IO stream has side effects and every time you go over the stream you may get different results.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %IO.Stream{device: term, line_or_bytes: term, raw: term}</code></pre> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/IO.Stream.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/IO.Stream.html</a>\n  </p>\n</div>\n","elixir/hashdict":"<h1>  HashDict  </h1>  <p>WARNING: this module is deprecated.</p> <p>Use the <a href=\"map\"><code class=\"inline\">Map</code></a> module instead.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#delete/2\">delete(dict, key)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#drop/2\">drop(dict, keys)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#equal?/2\">equal?(dict1, dict2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#fetch/2\">fetch(hash_dict, key)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#fetch!/2\">fetch!(dict, key)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#get/3\">get(dict, key, default \\\\ nil)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#get_and_update/3\">get_and_update(dict, key, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#get_lazy/3\">get_lazy(dict, key, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#has_key?/2\">has_key?(dict, key)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#keys/1\">keys(dict)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#merge/3\">merge(dict1, dict2, fun \\\\ fn _k, _v1, v2 -&gt; v2 end)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#new/0\">new()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a new empty dict</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pop/3\">pop(dict, key, default \\\\ nil)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#pop_lazy/3\">pop_lazy(dict, key, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#put/3\">put(hash_dict, key, value)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#put_new/3\">put_new(dict, key, value)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#put_new_lazy/3\">put_new_lazy(dict, key, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#size/1\">size(hash_dict)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#split/2\">split(dict, keys)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#take/2\">take(dict, keys)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#to_list/1\">to_list(dict)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#update/4\">update(dict, key, initial, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#update!/3\">update!(dict, key, fun)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#values/1\">values(dict)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a></code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"delete/2\">  <span class=\"signature\">delete(dict, key)</span>  </h3>     <h3 class=\"detail-header function\" id=\"drop/2\">  <span class=\"signature\">drop(dict, keys)</span>  </h3>     <h3 class=\"detail-header function\" id=\"equal?/2\">  <span class=\"signature\">equal?(dict1, dict2)</span>  </h3>     <h3 class=\"detail-header function\" id=\"fetch/2\">  <span class=\"signature\">fetch(hash_dict, key)</span>  </h3>     <h3 class=\"detail-header function\" id=\"fetch!/2\">  <span class=\"signature\">fetch!(dict, key)</span>  </h3>     <h3 class=\"detail-header function\" id=\"get/3\">  <span class=\"signature\">get(dict, key, default \\\\ nil)</span>  </h3>     <h3 class=\"detail-header function\" id=\"get_and_update/3\">  <span class=\"signature\">get_and_update(dict, key, fun)</span>  </h3>     <h3 class=\"detail-header function\" id=\"get_lazy/3\">  <span class=\"signature\">get_lazy(dict, key, fun)</span>  </h3>     <h3 class=\"detail-header function\" id=\"has_key?/2\">  <span class=\"signature\">has_key?(dict, key)</span>  </h3>     <h3 class=\"detail-header function\" id=\"keys/1\">  <span class=\"signature\">keys(dict)</span>  </h3>     <h3 class=\"detail-header function\" id=\"merge/3\">  <span class=\"signature\">merge(dict1, dict2, fun \\\\ fn _k, _v1, v2 -&gt; v2 end)</span>  </h3>     <h3 class=\"detail-header function\" id=\"new/0\">  <span class=\"signature\">new()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new :: <a href=\"dict#t:t/0\">Dict.t</a></code></pre>    <p>Creates a new empty dict.</p>    <h3 class=\"detail-header function\" id=\"pop/3\">  <span class=\"signature\">pop(dict, key, default \\\\ nil)</span>  </h3>     <h3 class=\"detail-header function\" id=\"pop_lazy/3\">  <span class=\"signature\">pop_lazy(dict, key, fun)</span>  </h3>     <h3 class=\"detail-header function\" id=\"put/3\">  <span class=\"signature\">put(hash_dict, key, value)</span>  </h3>     <h3 class=\"detail-header function\" id=\"put_new/3\">  <span class=\"signature\">put_new(dict, key, value)</span>  </h3>     <h3 class=\"detail-header function\" id=\"put_new_lazy/3\">  <span class=\"signature\">put_new_lazy(dict, key, fun)</span>  </h3>     <h3 class=\"detail-header function\" id=\"size/1\">  <span class=\"signature\">size(hash_dict)</span>  </h3>     <h3 class=\"detail-header function\" id=\"split/2\">  <span class=\"signature\">split(dict, keys)</span>  </h3>     <h3 class=\"detail-header function\" id=\"take/2\">  <span class=\"signature\">take(dict, keys)</span>  </h3>     <h3 class=\"detail-header function\" id=\"to_list/1\">  <span class=\"signature\">to_list(dict)</span>  </h3>     <h3 class=\"detail-header function\" id=\"update/4\">  <span class=\"signature\">update(dict, key, initial, fun)</span>  </h3>     <h3 class=\"detail-header function\" id=\"update!/3\">  <span class=\"signature\">update!(dict, key, fun)</span>  </h3>     <h3 class=\"detail-header function\" id=\"values/1\">  <span class=\"signature\">values(dict)</span>  </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/HashDict.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/HashDict.html</a>\n  </p>\n</div>\n","elixir/inspect.opts":"<h1>  Inspect.Opts  </h1>  <p>Defines the Inspect.Opts used by the Inspect protocol.</p> <p>The following fields are available:</p> <ul> <li>\n<p><code class=\"inline\">:structs</code> - when <code class=\"inline\">false</code>, structs are not formatted by the inspect protocol, they are instead printed as maps, defaults to <code class=\"inline\">true</code>.</p> </li> <li>\n<p><code class=\"inline\">:binaries</code> - when <code class=\"inline\">:as_strings</code> all binaries will be printed as strings, non-printable bytes will be escaped.</p> <p>When <code class=\"inline\">:as_binaries</code> all binaries will be printed in bit syntax.</p> <p>When the default <code class=\"inline\">:infer</code>, the binary will be printed as a string if it is printable, otherwise in bit syntax.</p> </li> <li>\n<p><code class=\"inline\">:charlists</code> - when <code class=\"inline\">:as_charlists</code> all lists will be printed as char lists, non-printable elements will be escaped.</p> <p>When <code class=\"inline\">:as_lists</code> all lists will be printed as lists.</p> <p>When the default <code class=\"inline\">:infer</code>, the list will be printed as a charlist if it is printable, otherwise as list.</p> </li> <li>\n<p><code class=\"inline\">:limit</code> - limits the number of items that are printed for tuples, bitstrings, and lists, does not apply to strings nor charlists, defaults to 50.</p> </li> <li>\n<p><code class=\"inline\">:pretty</code> - if set to <code class=\"inline\">true</code> enables pretty printing, defaults to <code class=\"inline\">false</code>.</p> </li> <li>\n<p><code class=\"inline\">:width</code> - defaults to 80 characters, used when pretty is <code class=\"inline\">true</code> or when printing to IO devices. Set to 0 to force each item to be printed on its own line.</p> </li> <li>\n<p><code class=\"inline\">:base</code> - print integers as :binary, :octal, :decimal, or :hex, defaults to :decimal. When inspecting binaries any <code class=\"inline\">:base</code> other than <code class=\"inline\">:decimal</code> implies <code class=\"inline\">binaries: :as_binaries</code>.</p> </li> <li>\n<code class=\"inline\">:safe</code> - when <code class=\"inline\">false</code>, failures while inspecting structs will be raised as errors instead of being wrapped in the <a href=\"inspect.error\"><code class=\"inline\">Inspect.Error</code></a> exception. This is useful when debugging failures and crashes for custom inspect implementations </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Inspect.Opts{base: :decimal | :binary | :hex | :octal, binaries: :infer | :as_binaries | :as_strings, char_lists: :infer | :as_lists | :as_char_lists, charlists: :infer | :as_lists | :as_charlists, limit: pos_integer | :infinity, pretty: boolean, safe: boolean, structs: boolean, width: pos_integer | :infinity}</code></pre> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Inspect.Opts.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Inspect.Opts.html</a>\n  </p>\n</div>\n","elixir/kernel.parallelcompiler":"<h1>  Kernel.ParallelCompiler  </h1>  <p>A module responsible for compiling files in parallel.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#files/2\">files(files, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compiles the given files</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#files_to_path/3\">files_to_path(files, path, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compiles the given files to the given path. Read <a href=\"#files/2\"><code class=\"inline\">files/2</code></a> for more information</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"files/2\">  <span class=\"signature\">files(files, options \\\\ [])</span>  </h3>  <p>Compiles the given files.</p> <p>Those files are compiled in parallel and can automatically detect dependencies between them. Once a dependency is found, the current file stops being compiled until the dependency is resolved.</p> <p>If there is an error during compilation or if <code class=\"inline\">warnings_as_errors</code> is set to <code class=\"inline\">true</code> and there is a warning, this function will fail with an exception.</p> <p>This function accepts the following options:</p> <ul> <li>\n<p><code class=\"inline\">:each_file</code> - for each file compiled, invokes the callback passing the file</p> </li> <li>\n<p><code class=\"inline\">:each_long_compilation</code> - for each file that takes more than a given timeout (see the <code class=\"inline\">:long_compilation_threshold</code> option) to compile, invoke this callback passing the file as its argument</p> </li> <li>\n<p><code class=\"inline\">:long_compilation_threshold</code> - the timeout (in seconds) after the <code class=\"inline\">:each_long_compilation</code> callback is invoked; defaults to <code class=\"inline\">10</code></p> </li> <li>\n<p><code class=\"inline\">:each_module</code> - for each module compiled, invokes the callback passing the file, module and the module bytecode</p> </li> <li>\n<code class=\"inline\">:dest</code> - the destination directory for the beam files. When using <a href=\"#files/2\"><code class=\"inline\">files/2</code></a>, this information is only used to properly annotate the beam files before they are loaded into memory. If you want a file to actually be written to <code class=\"inline\">dest</code>, use <a href=\"#files_to_path/3\"><code class=\"inline\">files_to_path/3</code></a> instead. </li> </ul> <p>Returns the modules generated by each compiled file.</p>    <h3 class=\"detail-header function\" id=\"files_to_path/3\">  <span class=\"signature\">files_to_path(files, path, options \\\\ [])</span>  </h3>  <p>Compiles the given files to the given path. Read <a href=\"#files/2\"><code class=\"inline\">files/2</code></a> for more information.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Kernel.ParallelCompiler.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Kernel.ParallelCompiler.html</a>\n  </p>\n</div>\n","elixir/kernel.parallelrequire":"<h1>  Kernel.ParallelRequire  </h1>  <p>A module responsible for requiring files in parallel.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#files/2\">files(files, callbacks \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Requires the given files</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"files/2\">  <span class=\"signature\">files(files, callbacks \\\\ [])</span>  </h3>  <p>Requires the given files.</p> <p>A callback that will be invoked with each file, or a keyword list of <code class=\"inline\">callbacks</code> can be provided:</p> <ul> <li>\n<p><code class=\"inline\">:each_file</code> - invoked with each file</p> </li> <li>\n<code class=\"inline\">:each_module</code> - invoked with file, module name, and binary code </li> </ul> <p>Returns the modules generated by each required file.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Kernel.ParallelRequire.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Kernel.ParallelRequire.html</a>\n  </p>\n</div>\n","elixir/genevent":"<h1>  GenEvent <small>behaviour</small>  </h1>  <p>A behaviour module for implementing event handling functionality.</p> <p>The event handling model consists of a generic event manager process with an arbitrary number of event handlers which are added and deleted dynamically.</p> <p>An event manager implemented using this module will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.</p> <h2 id=\"module-example\" class=\"section-heading\">  Example </h2> <p>There are many use cases for event handlers. For example, a logging system can be built using event handlers where each log message is an event and different event handlers can be attached to handle the log messages. One handler may print error messages on the terminal, another can write it to a file, while a third one can keep the messages in memory (like a buffer) until they are read.</p> <p>As an example, let’s have a GenEvent that accumulates messages until they are collected by an explicit call.</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Define an Event Handler\ndefmodule LoggerHandler do\n  use GenEvent\n\n  # Callbacks\n\n  def handle_event({:log, x}, messages) do\n    {:ok, [x | messages]}\n  end\n\n  def handle_call(:messages, messages) do\n    {:ok, Enum.reverse(messages), []}\n  end\nend\n\n# Start a new event manager.\n{:ok, pid} = GenEvent.start_link([])\n\n# Attach an event handler to the event manager.\nGenEvent.add_handler(pid, LoggerHandler, [])\n#=&gt; :ok\n\n# Send some events to the event manager.\nGenEvent.notify(pid, {:log, 1})\n#=&gt; :ok\n\nGenEvent.notify(pid, {:log, 2})\n#=&gt; :ok\n\n# Call functions on specific handlers in the manager.\nGenEvent.call(pid, LoggerHandler, :messages)\n#=&gt; [1, 2]\n\nGenEvent.call(pid, LoggerHandler, :messages)\n#=&gt; []</code></pre> <p>We start a new event manager by calling <a href=\"genevent#start_link/1\"><code class=\"inline\">GenEvent.start_link/1</code></a>. Notifications can be sent to the event manager which will then invoke <code class=\"inline\">handle_event/2</code> for each registered handler.</p> <p>We can add new handlers with <a href=\"#add_handler/3\"><code class=\"inline\">add_handler/3</code></a> and <a href=\"#add_mon_handler/3\"><code class=\"inline\">add_mon_handler/3</code></a>. Calls can also be made to specific handlers by using <code class=\"inline\">call/3</code>.</p> <h2 id=\"module-callbacks\" class=\"section-heading\">  Callbacks </h2> <p>There are 6 callbacks required to be implemented in a <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a>. By adding <code class=\"inline\">use GenEvent</code> to your module, Elixir will automatically define all 6 callbacks for you, leaving it up to you to implement the ones you want to customize.</p> <h2 id=\"module-name-registration\" class=\"section-heading\">  Name Registration </h2> <p>A GenEvent is bound to the same name registration rules as a <a href=\"genserver\"><code class=\"inline\">GenServer</code></a>. Read more about it in the <a href=\"genserver\"><code class=\"inline\">GenServer</code></a> docs.</p> <h2 id=\"module-modes\" class=\"section-heading\">  Modes </h2> <p>GenEvent supports three different notifications.</p> <p>On <a href=\"genevent#ack_notify/2\"><code class=\"inline\">GenEvent.ack_notify/2</code></a>, the manager acknowledges each event, providing backpressure, but processing of the message happens asynchronously.</p> <p>On <a href=\"genevent#sync_notify/2\"><code class=\"inline\">GenEvent.sync_notify/2</code></a>, the manager acknowledges an event just after it is processed by all event handlers.</p> <p>On <a href=\"genevent#notify/2\"><code class=\"inline\">GenEvent.notify/2</code></a>, all events are processed asynchronously and there is no ack (which means there is no backpressure).</p> <h2 id=\"module-streaming\" class=\"section-heading\">  Streaming </h2> <p><a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> messages can be streamed with the help of <a href=\"#stream/2\"><code class=\"inline\">stream/2</code></a>. You will need to start another process to consume the stream:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Task.start_link fn -&gt;\n  stream = GenEvent.stream(pid)\n\n  # Discard the next 3 events\n  _ = Enum.take(stream, 3)\n\n  # Print all remaining events\n  for event &lt;- stream do\n    IO.inspect event\n  end\nend</code></pre> <p>Now call <a href=\"genevent#notify/2\"><code class=\"inline\">GenEvent.notify/2</code></a> multiple times. You will see the first three events will be skipped while the rest will be continuously printed.</p> <h2 id=\"module-learn-more-and-compatibility\" class=\"section-heading\">  Learn more and compatibility </h2> <p>If you wish to find out more about GenEvent, the documentation and links in Erlang can provide extra insight.</p> <ul> <li>\n<a href=\"http://www.erlang.org/doc/man/gen_event.html\"><code class=\"inline\">:gen_event</code> module documentation</a> </li> <li>\n<a href=\"http://learnyousomeerlang.com/event-handlers\">Event Handlers – Learn You Some Erlang for Great Good!</a> </li> </ul> <p>Keep in mind though Elixir and Erlang gen events are not 100% compatible. The <a href=\"http://www.erlang.org/doc/man/gen_event.html#add_sup_handler-3\"><code class=\"inline\">:gen_event.add_sup_handler/3</code></a> is not supported by Elixir’s GenEvent, which in turn supports <a href=\"genevent#add_mon_handler/3\"><code class=\"inline\">GenEvent.add_mon_handler/3</code></a>.</p> <p>The benefits of the monitoring approach are described in the “Don’t drink too much kool aid” section of the “Learn you some Erlang” link above. Due to those changes, Elixir’s GenEvent does not trap exits by default.</p> <p>Furthermore, Elixir also normalizes the <code class=\"inline\">{:error, _}</code> tuples returned by many functions, in order to be more consistent with themselves and the <a href=\"genserver\"><code class=\"inline\">GenServer</code></a> module.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:handler/0\">handler()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Supported values for new handlers</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:manager/0\">manager()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The event manager reference</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:name/0\">name()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The GenEvent manager name</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:on_start/0\">on_start()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Return values of <code class=\"inline\">start*</code> functions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:options/0\">options()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Options used by the <code class=\"inline\">start*</code> functions</p> </dd>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#ack_notify/2\">ack_notify(manager, event)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends an ack event notification to the event <code class=\"inline\">manager</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#add_handler/3\">add_handler(manager, handler, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds a new event handler to the event <code class=\"inline\">manager</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#add_mon_handler/3\">add_mon_handler(manager, handler, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Adds a monitored event handler to the event <code class=\"inline\">manager</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#call/4\">call(manager, handler, request, timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Makes a synchronous call to the event <code class=\"inline\">handler</code> installed in <code class=\"inline\">manager</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#notify/2\">notify(manager, event)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends an event notification to the event <code class=\"inline\">manager</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#remove_handler/3\">remove_handler(manager, handler, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes an event handler from the event <code class=\"inline\">manager</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start/1\">start(options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts an event manager process without links (outside of a supervision tree)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/1\">start_link(options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts an event manager linked to the current process</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stop/3\">stop(manager, reason \\\\ :normal, timeout \\\\ :infinity)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stops the manager with the given <code class=\"inline\">reason</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stream/2\">stream(manager, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a stream that consumes events from the <code class=\"inline\">manager</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#swap_handler/5\">swap_handler(manager, handler1, args1, handler2, args2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Replaces an old event handler with a new one in the event <code class=\"inline\">manager</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#swap_mon_handler/5\">swap_mon_handler(manager, handler1, args1, handler2, args2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Replaces an old event handler with a new monitored one in the event <code class=\"inline\">manager</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sync_notify/2\">sync_notify(manager, event)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends a sync event notification to the event <code class=\"inline\">manager</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#which_handlers/1\">which_handlers(manager)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of all event handlers installed in the <code class=\"inline\">manager</code></p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:code_change/3\">code_change(old_vsn, state, extra)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked to change the state of the handler when a different version of the handler’s module is loaded (hot code swapping) and the state’s term structure should be changed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:handle_call/2\">handle_call(request, state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked to handle synchronous <a href=\"#call/4\"><code class=\"inline\">call/4</code></a> messages to a specific handler</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:handle_event/2\">handle_event(event, state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked to handle <a href=\"#notify/2\"><code class=\"inline\">notify/2</code></a>, <a href=\"#ack_notify/2\"><code class=\"inline\">ack_notify/2</code></a> or <a href=\"#sync_notify/2\"><code class=\"inline\">sync_notify/2</code></a> messages</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:handle_info/2\">handle_info(msg, state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked to handle all other messages. All handlers are run in the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> process so messages intended for other handlers should be ignored with a catch all clause</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:init/1\">init(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked when the handler is added to the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> process. <a href=\"#add_handler/3\"><code class=\"inline\">add_handler/3</code></a> (and <a href=\"#add_mon_handler/3)\"><code class=\"inline\">add_mon_handler/3</code></a> will block until it returns</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:terminate/2\">terminate(reason, state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked when the server is about to exit. It should do any cleanup required</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:handler/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:handler/0\">handler</a> :: atom | {atom, term}</code></pre> <p>Supported values for new handlers</p>  </div> <div id=\"t:manager/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:manager/0\">manager</a> :: pid | <a href=\"#t:name/0\">name</a> | {atom, node}</code></pre> <p>The event manager reference</p>  </div> <div id=\"t:name/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:name/0\">name</a> ::\n  atom |\n  {:global, term} |\n  {:via, module, term}</code></pre> <p>The GenEvent manager name</p>  </div> <div id=\"t:on_start/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:on_start/0\">on_start</a> ::\n  {:ok, pid} |\n  {:error, {:already_started, pid}}</code></pre> <p>Return values of <code class=\"inline\">start*</code> functions</p>  </div> <div id=\"t:options/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:options/0\">options</a> :: [{:name, <a href=\"#t:name/0\">name</a>}]</code></pre> <p>Options used by the <code class=\"inline\">start*</code> functions</p>  </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"ack_notify/2\">  <span class=\"signature\">ack_notify(manager, event)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">ack_notify(<a href=\"#t:manager/0\">manager</a>, term) :: :ok</code></pre>    <p>Sends an ack event notification to the event <code class=\"inline\">manager</code>.</p> <p>In other words, this function only returns <code class=\"inline\">:ok</code> as soon as the event manager starts processing this event, but it does not wait for event handlers to process the sent event.</p> <p>See <a href=\"#notify/2\"><code class=\"inline\">notify/2</code></a> for more info. Note this function is specific to Elixir’s GenEvent and does not work with Erlang ones.</p>    <h3 class=\"detail-header function\" id=\"add_handler/3\">  <span class=\"signature\">add_handler(manager, handler, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">add_handler(<a href=\"#t:manager/0\">manager</a>, <a href=\"#t:handler/0\">handler</a>, term) ::\n  :ok |\n  {:error, term}</code></pre>    <p>Adds a new event handler to the event <code class=\"inline\">manager</code>.</p> <p>The event manager will call the <code class=\"inline\">init/1</code> callback with <code class=\"inline\">args</code> to initiate the event handler and its internal state.</p> <p>If <code class=\"inline\">init/1</code> returns a correct value indicating successful completion, the event manager adds the event handler and this function returns <code class=\"inline\">:ok</code>. If the callback fails with <code class=\"inline\">reason</code> or returns <code class=\"inline\">{:error, reason}</code>, the event handler is ignored and this function returns <code class=\"inline\">{:error, reason}</code>.</p> <p>If the given handler was previously installed at the manager, this function returns <code class=\"inline\">{:error, :already_present}</code>.</p> <p>For installing multiple instances of the same handler, <code class=\"inline\">{Module, id}</code> instead of <a href=\"module\"><code class=\"inline\">Module</code></a> must be used. The handler could be then referenced with <code class=\"inline\">{Module, id}</code> instead of just <a href=\"module\"><code class=\"inline\">Module</code></a>.</p>    <h3 class=\"detail-header function\" id=\"add_mon_handler/3\">  <span class=\"signature\">add_mon_handler(manager, handler, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">add_mon_handler(<a href=\"#t:manager/0\">manager</a>, <a href=\"#t:handler/0\">handler</a>, term) ::\n  :ok |\n  {:error, term}</code></pre>    <p>Adds a monitored event handler to the event <code class=\"inline\">manager</code>.</p> <p>Expects the same input and returns the same values as <a href=\"#add_handler/3\"><code class=\"inline\">add_handler/3</code></a>.</p> <h4>Monitored handlers</h4> <p>A monitored handler implies the calling process will now be monitored by the GenEvent manager.</p> <p>If the calling process later terminates with <code class=\"inline\">reason</code>, the event manager will delete the event handler by calling the <code class=\"inline\">terminate/2</code> callback with <code class=\"inline\">{:stop, reason}</code> as argument. If the event handler later is deleted, the event manager sends a message <code class=\"inline\">{:gen_event_EXIT, handler, reason}</code> to the calling process. Reason is one of the following:</p> <ul> <li>\n<p><code class=\"inline\">:normal</code> - if the event handler has been removed due to a call to <a href=\"#remove_handler/3\"><code class=\"inline\">remove_handler/3</code></a>, or <code class=\"inline\">:remove_handler</code> has been returned by a callback function</p> </li> <li>\n<p><code class=\"inline\">:shutdown</code> - if the event handler has been removed because the event manager is terminating</p> </li> <li>\n<p><code class=\"inline\">{:swapped, new_handler, pid}</code> - if the process pid has replaced the event handler by another</p> </li> <li>\n<code class=\"inline\">term</code> - if the event handler is removed due to an error. Which term depends on the error </li> </ul> <p>Keep in mind that the <code class=\"inline\">{:gen_event_EXIT, handler, reason}</code> message is not guaranteed to be delivered in case the manager crashes. If you want to guarantee the message is delivered, you have two options:</p> <ul> <li>monitor the event manager </li> <li>link to the event manager and then set <code class=\"inline\">Process.flag(:trap_exit, true)</code> in your handler callback </li> </ul> <p>Finally, this functionality only works with GenEvent started via this module (it is not backwards compatible with Erlang’s <code class=\"inline\">:gen_event</code>).</p>    <h3 class=\"detail-header function\" id=\"call/4\">  <span class=\"signature\">call(manager, handler, request, timeout \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">call(<a href=\"#t:manager/0\">manager</a>, <a href=\"#t:handler/0\">handler</a>, term, timeout) ::\n  term |\n  {:error, term}</code></pre>    <p>Makes a synchronous call to the event <code class=\"inline\">handler</code> installed in <code class=\"inline\">manager</code>.</p> <p>The given <code class=\"inline\">request</code> is sent and the caller waits until a reply arrives or a timeout occurs. The event manager will call <code class=\"inline\">handle_call/2</code> to handle the request.</p> <p>The return value <code class=\"inline\">reply</code> is defined in the return value of <code class=\"inline\">handle_call/2</code>. If the specified event handler is not installed, the function returns <code class=\"inline\">{:error, :not_found}</code>.</p>    <h3 class=\"detail-header function\" id=\"notify/2\">  <span class=\"signature\">notify(manager, event)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">notify(<a href=\"#t:manager/0\">manager</a>, term) :: :ok</code></pre>    <p>Sends an event notification to the event <code class=\"inline\">manager</code>.</p> <p>The event manager will call <code class=\"inline\">handle_event/2</code> for each installed event handler.</p> <p><code class=\"inline\">notify</code> is asynchronous and will return immediately after the notification is sent. <code class=\"inline\">notify</code> will not fail even if the specified event manager does not exist, unless it is specified as an atom.</p>    <h3 class=\"detail-header function\" id=\"remove_handler/3\">  <span class=\"signature\">remove_handler(manager, handler, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">remove_handler(<a href=\"#t:manager/0\">manager</a>, <a href=\"#t:handler/0\">handler</a>, term) ::\n  term |\n  {:error, term}</code></pre>    <p>Removes an event handler from the event <code class=\"inline\">manager</code>.</p> <p>The event manager will call <code class=\"inline\">terminate/2</code> to terminate the event handler and return the callback value. If the specified event handler is not installed, the function returns <code class=\"inline\">{:error, :not_found}</code>.</p>    <h3 class=\"detail-header function\" id=\"start/1\">  <span class=\"signature\">start(options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start(<a href=\"#t:options/0\">options</a>) :: <a href=\"#t:on_start/0\">on_start</a></code></pre>    <p>Starts an event manager process without links (outside of a supervision tree).</p> <p>See <a href=\"#start_link/1\"><code class=\"inline\">start_link/1</code></a> for more information.</p>    <h3 class=\"detail-header function\" id=\"start_link/1\">  <span class=\"signature\">start_link(options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_link(<a href=\"#t:options/0\">options</a>) :: <a href=\"#t:on_start/0\">on_start</a></code></pre>    <p>Starts an event manager linked to the current process.</p> <p>This is often used to start the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> as part of a supervision tree.</p> <p>It accepts the <code class=\"inline\">:name</code> option which is described under the <code class=\"inline\">Name Registration</code> section in the <a href=\"genserver\"><code class=\"inline\">GenServer</code></a> module docs.</p> <p>If the event manager is successfully created and initialized, the function returns <code class=\"inline\">{:ok, pid}</code>, where pid is the pid of the server. If a process with the specified server name already exists, the function returns <code class=\"inline\">{:error, {:already_started, pid}}</code> with the pid of that process.</p> <p>Note that a <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> started with <a href=\"#start_link/1\"><code class=\"inline\">start_link/1</code></a> is linked to the parent process and will exit not only on crashes but also if the parent process exits with <code class=\"inline\">:normal</code> reason.</p>    <h3 class=\"detail-header function\" id=\"stop/3\">  <span class=\"signature\">stop(manager, reason \\\\ :normal, timeout \\\\ :infinity)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stop(<a href=\"#t:manager/0\">manager</a>, reason :: term, timeout) :: :ok</code></pre>    <p>Stops the manager with the given <code class=\"inline\">reason</code>.</p> <p>Before terminating, the event manager will call <code class=\"inline\">terminate(:stop, ...)</code> for each installed event handler. It returns <code class=\"inline\">:ok</code> if the manager terminates with the given reason, if it terminates with another reason, the call will exit.</p> <p>This function keeps OTP semantics regarding error reporting. If the reason is any other than <code class=\"inline\">:normal</code>, <code class=\"inline\">:shutdown</code> or <code class=\"inline\">{:shutdown, _}</code>, an error report will be logged.</p>    <h3 class=\"detail-header function\" id=\"stream/2\">  <span class=\"signature\">stream(manager, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stream(<a href=\"#t:manager/0\">manager</a>, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"genevent.stream#t:t/0\">GenEvent.Stream.t</a></code></pre>    <p>Returns a stream that consumes events from the <code class=\"inline\">manager</code>.</p> <p>The stream is a <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> struct that implements the <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> protocol. Consumption of events only begins when enumeration starts.</p> <p>Note streaming is specific to Elixir’s GenEvent and does not work with Erlang ones.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:timeout</code> - raises if no event arrives in X milliseconds (defaults to <code class=\"inline\">:infinity</code>) </li> </ul>    <h3 class=\"detail-header function\" id=\"swap_handler/5\">  <span class=\"signature\">swap_handler(manager, handler1, args1, handler2, args2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">swap_handler(<a href=\"#t:manager/0\">manager</a>, <a href=\"#t:handler/0\">handler</a>, term, <a href=\"#t:handler/0\">handler</a>, term) ::\n  :ok |\n  {:error, term}</code></pre>    <p>Replaces an old event handler with a new one in the event <code class=\"inline\">manager</code>.</p> <p>First, the old event handler is deleted by calling <code class=\"inline\">terminate/2</code> with the given <code class=\"inline\">args1</code> and collects the return value. Then the new event handler is added and initiated by calling <code class=\"inline\">init({args2, term})</code>, where <code class=\"inline\">term</code> is the return value of calling <code class=\"inline\">terminate/2</code> in the old handler. This makes it possible to transfer information from one handler to another.</p> <p>The new handler will be added even if the specified old event handler is not installed or if the handler fails to terminate with a given reason in which case <code class=\"inline\">state = {:error, term}</code>.</p> <p>If <code class=\"inline\">init/1</code> in the second handler returns a correct value, this function returns <code class=\"inline\">:ok</code>.</p>    <h3 class=\"detail-header function\" id=\"swap_mon_handler/5\">  <span class=\"signature\">swap_mon_handler(manager, handler1, args1, handler2, args2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">swap_mon_handler(<a href=\"#t:manager/0\">manager</a>, <a href=\"#t:handler/0\">handler</a>, term, <a href=\"#t:handler/0\">handler</a>, term) ::\n  :ok |\n  {:error, term}</code></pre>    <p>Replaces an old event handler with a new monitored one in the event <code class=\"inline\">manager</code>.</p> <p>Read the docs for <a href=\"#add_mon_handler/3\"><code class=\"inline\">add_mon_handler/3</code></a> and <a href=\"#swap_handler/5\"><code class=\"inline\">swap_handler/5</code></a> for more information.</p>    <h3 class=\"detail-header function\" id=\"sync_notify/2\">  <span class=\"signature\">sync_notify(manager, event)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">sync_notify(<a href=\"#t:manager/0\">manager</a>, term) :: :ok</code></pre>    <p>Sends a sync event notification to the event <code class=\"inline\">manager</code>.</p> <p>In other words, this function only returns <code class=\"inline\">:ok</code> after the event manager invokes the <code class=\"inline\">handle_event/2</code> callback on each installed event handler.</p> <p>See <a href=\"#notify/2\"><code class=\"inline\">notify/2</code></a> for more info.</p>    <h3 class=\"detail-header function\" id=\"which_handlers/1\">  <span class=\"signature\">which_handlers(manager)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">which_handlers(<a href=\"#t:manager/0\">manager</a>) :: [<a href=\"#t:handler/0\">handler</a>]</code></pre>    <p>Returns a list of all event handlers installed in the <code class=\"inline\">manager</code>.</p>     <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:code_change/3\">  <span class=\"signature\">code_change(old_vsn, state, extra)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">code_change(old_vsn, state :: term, extra :: term) :: {:ok, new_state :: term} when old_vsn: term | {:down, term}</code></pre>    <p>Invoked to change the state of the handler when a different version of the handler’s module is loaded (hot code swapping) and the state’s term structure should be changed.</p> <p><code class=\"inline\">old_vsn</code> is the previous version of the module (defined by the <code class=\"inline\">@vsn</code> attribute) when upgrading. When downgrading the previous version is wrapped in a 2-tuple with first element <code class=\"inline\">:down</code>. <code class=\"inline\">state</code> is the current state of the handler and <code class=\"inline\">extra</code> is any extra data required to change the state.</p> <p>Returning <code class=\"inline\">{:ok, new_state}</code> changes the state to <code class=\"inline\">new_state</code> and the code change is successful.</p> <p>If <code class=\"inline\">code_change/3</code> raises, the code change fails and the handler will continue with its previous state. Therefore this callback does not usually contain side effects.</p>    <h3 class=\"detail-header callback\" id=\"c:handle_call/2\">  <span class=\"signature\">handle_call(request, state)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_call(request :: term, state :: term) ::\n  {:ok, reply, new_state} |\n  {:ok, reply, new_state, :hibernate} |\n  {:remove_handler, reply} when reply: term, new_state: term</code></pre>    <p>Invoked to handle synchronous <a href=\"#call/4\"><code class=\"inline\">call/4</code></a> messages to a specific handler.</p> <p><code class=\"inline\">request</code> is the request message sent by a <a href=\"#call/4\"><code class=\"inline\">call/4</code></a> and <code class=\"inline\">state</code> is the current state of the handler.</p> <p>Returning <code class=\"inline\">{:ok, reply, new_state}</code> sends <code class=\"inline\">reply</code> as a response to the call and sets the handler’s state to <code class=\"inline\">new_state</code>.</p> <p>Returning <code class=\"inline\">{:ok, reply, new_state, :hibernate}</code> is similar to <code class=\"inline\">{:ok, reply, new_state}</code> except the process is hibernated. See <code class=\"inline\">handle_event/2</code> for more information on hibernation.</p> <p>Returning <code class=\"inline\">{:remove_handler, reply}</code> sends <code class=\"inline\">reply</code> as a response to the call, removes the handler from the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> loop and calls <code class=\"inline\">terminate/2</code> with reason <code class=\"inline\">:remove_handler</code> and state <code class=\"inline\">state</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:handle_event/2\">  <span class=\"signature\">handle_event(event, state)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_event(event :: term, state :: term) ::\n  {:ok, new_state} |\n  {:ok, new_state, :hibernate} |\n  :remove_handler when new_state: term</code></pre>    <p>Invoked to handle <a href=\"#notify/2\"><code class=\"inline\">notify/2</code></a>, <a href=\"#ack_notify/2\"><code class=\"inline\">ack_notify/2</code></a> or <a href=\"#sync_notify/2\"><code class=\"inline\">sync_notify/2</code></a> messages.</p> <p><code class=\"inline\">event</code> is the event message and <code class=\"inline\">state</code> is the current state of the handler.</p> <p>Returning <code class=\"inline\">{:ok, new_state}</code> sets the handler’s state to <code class=\"inline\">new_state</code> and the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> loop continues.</p> <p>Returning <code class=\"inline\">{:ok, new_state, :hibernate}</code> is similar to <code class=\"inline\">{:ok, new_state}</code> except the process is hibernated once all handlers have handled the events. The <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> process will continue the loop once a message is its message queue. If a message is already in the message queue this will be immediately. Hibernating a <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> causes garbage collection and leaves a continuous heap that minimises the memory used by the process.</p> <p>Hibernating should not be used aggressively as too much time could be spent garbage collecting. Normally it should only be used when a message is not expected soon and minimising the memory of the process is shown to be beneficial.</p> <p>Returning <code class=\"inline\">:remove_handler</code> removes the handler from the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> loop and calls <code class=\"inline\">terminate/2</code> with reason <code class=\"inline\">:remove_handler</code> and state <code class=\"inline\">state</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:handle_info/2\">  <span class=\"signature\">handle_info(msg, state)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_info(msg :: term, state :: term) ::\n  {:ok, new_state} |\n  {:ok, new_state, :hibernate} |\n  :remove_handler when new_state: term</code></pre>    <p>Invoked to handle all other messages. All handlers are run in the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> process so messages intended for other handlers should be ignored with a catch all clause.</p> <p><code class=\"inline\">msg</code> is the message and <code class=\"inline\">state</code> is the current state of the handler.</p> <p>Return values are the same as <code class=\"inline\">handle_event/2</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:init/1\">  <span class=\"signature\">init(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">init(args :: term) ::\n  {:ok, state} |\n  {:ok, state, :hibernate} |\n  {:error, reason :: any} when state: any</code></pre>    <p>Invoked when the handler is added to the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> process. <a href=\"#add_handler/3\"><code class=\"inline\">add_handler/3</code></a> (and <a href=\"#add_mon_handler/3)\"><code class=\"inline\">add_mon_handler/3</code></a> will block until it returns.</p> <p><code class=\"inline\">args</code> is the argument term (third argument) passed to <a href=\"#add_handler/3\"><code class=\"inline\">add_handler/3</code></a>.</p> <p>Returning <code class=\"inline\">{:ok, state}</code> will cause <a href=\"#add_handler/3\"><code class=\"inline\">add_handler/3</code></a> to return <code class=\"inline\">:ok</code> and the handler to become part of the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> loop with state <code class=\"inline\">state</code>.</p> <p>Returning <code class=\"inline\">{:ok, state, :hibernate}</code> is similar to <code class=\"inline\">{:ok, state}</code> except the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> process is hibernated before continuing its loop. See <code class=\"inline\">handle_event/2</code> for more information on hibernation.</p> <p>Returning <code class=\"inline\">{:error, reason}</code> will cause <a href=\"#add_handler/3\"><code class=\"inline\">add_handler/3</code></a> to return <code class=\"inline\">{:error, reason}</code> and the handler is not added to <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> loop.</p>    <h3 class=\"detail-header callback\" id=\"c:terminate/2\">  <span class=\"signature\">terminate(reason, state)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">terminate(reason, state :: term) :: term when reason: :stop | {:stop, term} | :remove_handler | {:error, term} | term</code></pre>    <p>Invoked when the server is about to exit. It should do any cleanup required.</p> <p><code class=\"inline\">reason</code> is removal reason and <code class=\"inline\">state</code> is the current state of the handler. The return value is returned to <a href=\"genevent#remove_handler/3\"><code class=\"inline\">GenEvent.remove_handler/3</code></a> or ignored if removing for another reason.</p> <p><code class=\"inline\">reason</code> is one of:</p> <ul> <li>\n<code class=\"inline\">:stop</code> - manager is terminating </li> <li>\n<code class=\"inline\">{:stop, term}</code> - monitored process terminated (for monitored handlers) </li> <li>\n<code class=\"inline\">:remove_handler</code> - handler is being removed </li> <li>\n<code class=\"inline\">{:error, term}</code> - handler crashed or returned a bad value and an error is logged </li> <li>\n<code class=\"inline\">term</code> - any term passed to functions like <a href=\"genevent#remove_handler/3\"><code class=\"inline\">GenEvent.remove_handler/3</code></a> </li> </ul> <p>If part of a supervision tree, a <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a>’s <a href=\"supervisor\"><code class=\"inline\">Supervisor</code></a> will send an exit signal when shutting it down. The exit signal is based on the shutdown strategy in the child’s specification. If it is <code class=\"inline\">:brutal_kill</code> the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> is killed and so <code class=\"inline\">terminate/2</code> is not called for its handlers. However if it is a timeout the <a href=\"supervisor\"><code class=\"inline\">Supervisor</code></a> will send the exit signal <code class=\"inline\">:shutdown</code> and the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> will have the duration of the timeout to call <code class=\"inline\">terminate/2</code> on all of its handlers - if the process is still alive after the timeout it is killed.</p> <p>If the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> receives an exit signal (that is not <code class=\"inline\">:normal</code>) from any process when it is not trapping exits it will exit abruptly with the same reason and so not call the handlers’ <code class=\"inline\">terminate/2</code>. Note that a process does <em>NOT</em> trap exits by default and an exit signal is sent when a linked process exits or its node is disconnected. Therefore it is not guaranteed that <code class=\"inline\">terminate/2</code> is called when a <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> exits.</p> <p>Care should be taken to cleanup because the <a href=\"genevent#content\"><code class=\"inline\">GenEvent</code></a> can continue to loop after removing the handler. This is different to most other OTP behaviours. For example if the handler controls a <code class=\"inline\">port</code> (e.g. <code class=\"inline\">:gen_tcp.socket</code>) or <code class=\"inline\">File.io_device</code>, it will be need to be closed in <code class=\"inline\">terminate/2</code> as the process is not exiting so will not be automatically cleaned up.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/GenEvent.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/GenEvent.html</a>\n  </p>\n</div>\n","elixir/io":"<h1>  IO  </h1>  <p>Functions handling input/output (IO).</p> <p>Many functions in this module expect an IO device as an argument. An IO device must be a pid or an atom representing a process. For convenience, Elixir provides <code class=\"inline\">:stdio</code> and <code class=\"inline\">:stderr</code> as shortcuts to Erlang’s <code class=\"inline\">:standard_io</code> and <code class=\"inline\">:standard_error</code>.</p> <p>The majority of the functions expect chardata, i.e. strings or lists of characters and strings. In case another type is given, functions will convert to string via the <a href=\"string.chars\"><code class=\"inline\">String.Chars</code></a> protocol (as shown in typespecs).</p> <p>The functions starting with <code class=\"inline\">bin</code> expect iodata as an argument, i.e. binaries or lists of bytes and binaries.</p> <h2 id=\"module-io-devices\" class=\"section-heading\">  IO devices </h2> <p>An IO device may be an atom or a pid. In case it is an atom, the atom must be the name of a registered process. In addition, Elixir provides two shortcuts:</p> <ul> <li>\n<p><code class=\"inline\">:stdio</code> - a shortcut for <code class=\"inline\">:standard_io</code>, which maps to the current <a href=\"process#group_leader/0\"><code class=\"inline\">Process.group_leader/0</code></a> in Erlang</p> </li> <li>\n<code class=\"inline\">:stderr</code> - a shortcut for the named process <code class=\"inline\">:standard_error</code> provided in Erlang </li> </ul> <p>IO devices maintain their position, that means subsequent calls to any reading or writing functions will start from the place when the device was last accessed. Position of files can be changed using the <a href=\"http://www.erlang.org/doc/man/file.html#position-2\"><code class=\"inline\">:file.position/2</code></a> function.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:chardata/0\">chardata()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:device/0\">device()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:nodata/0\">nodata()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#binread/2\">binread(device \\\\ group_leader(), line_or_chars)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reads from the IO <code class=\"inline\">device</code>. The operation is Unicode unsafe</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#binstream/2\">binstream(device, line_or_bytes)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the IO <code class=\"inline\">device</code> into an <a href=\"io.stream\"><code class=\"inline\">IO.Stream</code></a>. The operation is Unicode unsafe</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#binwrite/2\">binwrite(device \\\\ group_leader(), item)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Writes <code class=\"inline\">item</code> as a binary to the given <code class=\"inline\">device</code>. No Unicode conversion happens. The operation is Unicode unsafe</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chardata_to_string/1\">chardata_to_string(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts chardata (a list of integers representing codepoints, lists and strings) into a string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#getn/2\">getn(prompt, count \\\\ 1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets a number of bytes from IO device <code class=\"inline\">:stdio</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#getn/3\">getn(device, prompt, count)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets a number of bytes from the IO <code class=\"inline\">device</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#gets/2\">gets(device \\\\ group_leader(), prompt)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reads a line from the IO <code class=\"inline\">device</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#inspect/2\">inspect(item, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inspects and writes the given <code class=\"inline\">item</code> to the device</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#inspect/3\">inspect(device, item, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inspects <code class=\"inline\">item</code> according to the given options using the IO <code class=\"inline\">device</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#iodata_length/1\">iodata_length(item)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the size of an iodata</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#iodata_to_binary/1\">iodata_to_binary(item)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts iodata (a list of integers representing bytes, lists and binaries) into a binary. The operation is Unicode unsafe</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#puts/2\">puts(device \\\\ group_leader(), item)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Writes <code class=\"inline\">item</code> to the given <code class=\"inline\">device</code>, similar to <a href=\"#write/2\"><code class=\"inline\">write/2</code></a>, but adds a newline at the end</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#read/2\">read(device \\\\ group_leader(), line_or_chars)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reads from the IO <code class=\"inline\">device</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stream/2\">stream(device, line_or_codepoints)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the IO <code class=\"inline\">device</code> into an <a href=\"io.stream\"><code class=\"inline\">IO.Stream</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#warn/1\">warn(message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Writes a <code class=\"inline\">message</code> to stderr, along with the current stacktrace</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#warn/2\">warn(message, stacktrace)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Writes a <code class=\"inline\">message</code> to stderr, along with the given <code class=\"inline\">stacktrace</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#write/2\">write(device \\\\ group_leader(), item)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Writes <code class=\"inline\">item</code> to the given <code class=\"inline\">device</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:chardata/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:chardata/0\">chardata</a> :: :unicode.chardata</code></pre> </div> <div id=\"t:device/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:device/0\">device</a> :: atom | pid</code></pre> </div> <div id=\"t:nodata/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:nodata/0\">nodata</a> :: {:error, term} | :eof</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"binread/2\">  <span class=\"signature\">binread(device \\\\ group_leader(), line_or_chars)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">binread(<a href=\"#t:device/0\">device</a>, :all | :line | non_neg_integer) ::\n  iodata |\n  <a href=\"#t:nodata/0\">nodata</a></code></pre>    <p>Reads from the IO <code class=\"inline\">device</code>. The operation is Unicode unsafe.</p> <p>The <code class=\"inline\">device</code> is iterated by the given number of characters or line by line if <code class=\"inline\">:line</code> is given. Alternatively, if <code class=\"inline\">:all</code> is given, then whole <code class=\"inline\">device</code> is returned.</p> <p>It returns:</p> <ul> <li>\n<p><code class=\"inline\">data</code> - the input characters</p> </li> <li>\n<p><code class=\"inline\">:eof</code> - end of file was encountered</p> </li> <li>\n<code class=\"inline\">{:error, reason}</code> - other (rare) error condition; for instance, <code class=\"inline\">{:error, :estale}</code> if reading from an NFS volume </li> </ul> <p>If <code class=\"inline\">:all</code> is given, <code class=\"inline\">:eof</code> is never returned, but an empty string in case the device has reached EOF.</p> <p>Note: do not use this function on IO devices in Unicode mode as it will return the wrong result.</p>    <h3 class=\"detail-header function\" id=\"binstream/2\">  <span class=\"signature\">binstream(device, line_or_bytes)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">binstream(<a href=\"#t:device/0\">device</a>, :line | pos_integer) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Converts the IO <code class=\"inline\">device</code> into an <a href=\"io.stream\"><code class=\"inline\">IO.Stream</code></a>. The operation is Unicode unsafe.</p> <p>An <a href=\"io.stream\"><code class=\"inline\">IO.Stream</code></a> implements both <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> and <a href=\"collectable\"><code class=\"inline\">Collectable</code></a>, allowing it to be used for both read and write.</p> <p>The <code class=\"inline\">device</code> is iterated by the given number of bytes or line by line if <code class=\"inline\">:line</code> is given. This reads from the IO device as a raw binary.</p> <p>Note that an IO stream has side effects and every time you go over the stream you may get different results.</p> <p>Finally, do not use this function on IO devices in Unicode mode as it will return the wrong result.</p>    <h3 class=\"detail-header function\" id=\"binwrite/2\">  <span class=\"signature\">binwrite(device \\\\ group_leader(), item)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">binwrite(<a href=\"#t:device/0\">device</a>, iodata) :: :ok | {:error, term}</code></pre>    <p>Writes <code class=\"inline\">item</code> as a binary to the given <code class=\"inline\">device</code>. No Unicode conversion happens. The operation is Unicode unsafe.</p> <p>Check <a href=\"#write/2\"><code class=\"inline\">write/2</code></a> for more information.</p> <p>Note: do not use this function on IO devices in Unicode mode as it will return the wrong result.</p>    <h3 class=\"detail-header function\" id=\"chardata_to_string/1\">  <span class=\"signature\">chardata_to_string(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chardata_to_string(<a href=\"#t:chardata/0\">chardata</a>) :: <a href=\"string#t:t/0\">String.t</a> | no_return</code></pre>    <p>Converts chardata (a list of integers representing codepoints, lists and strings) into a string.</p> <p>In case the conversion fails, it raises an <a href=\"unicodeconversionerror\"><code class=\"inline\">UnicodeConversionError</code></a>. If a string is given, it returns the string itself.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; IO.chardata_to_string([0x00E6, 0x00DF])\n\"æß\"\n\niex&gt; IO.chardata_to_string([0x0061, \"bc\"])\n\"abc\"\n\niex&gt; IO.chardata_to_string(\"string\")\n\"string\"</code></pre>    <h3 class=\"detail-header function\" id=\"getn/2\">  <span class=\"signature\">getn(prompt, count \\\\ 1)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">getn(<a href=\"#t:chardata/0\">chardata</a> | <a href=\"string.chars#t:t/0\">String.Chars.t</a>, pos_integer) ::\n  <a href=\"#t:chardata/0\">chardata</a> |\n  <a href=\"#t:nodata/0\">nodata</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">getn(<a href=\"#t:device/0\">device</a>, <a href=\"#t:chardata/0\">chardata</a> | <a href=\"string.chars#t:t/0\">String.Chars.t</a>) ::\n  <a href=\"#t:chardata/0\">chardata</a> |\n  <a href=\"#t:nodata/0\">nodata</a></code></pre>    <p>Gets a number of bytes from IO device <code class=\"inline\">:stdio</code>.</p> <p>If <code class=\"inline\">:stdio</code> is a Unicode device, <code class=\"inline\">count</code> implies the number of Unicode codepoints to be retrieved. Otherwise, <code class=\"inline\">count</code> is the number of raw bytes to be retrieved.</p> <p>See <a href=\"io#getn/3\"><code class=\"inline\">IO.getn/3</code></a> for a description of return values.</p>    <h3 class=\"detail-header function\" id=\"getn/3\">  <span class=\"signature\">getn(device, prompt, count)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">getn(<a href=\"#t:device/0\">device</a>, <a href=\"#t:chardata/0\">chardata</a> | <a href=\"string.chars#t:t/0\">String.Chars.t</a>, pos_integer) ::\n  <a href=\"#t:chardata/0\">chardata</a> |\n  <a href=\"#t:nodata/0\">nodata</a></code></pre>    <p>Gets a number of bytes from the IO <code class=\"inline\">device</code>.</p> <p>If the IO <code class=\"inline\">device</code> is a Unicode device, <code class=\"inline\">count</code> implies the number of Unicode codepoints to be retrieved. Otherwise, <code class=\"inline\">count</code> is the number of raw bytes to be retrieved.</p> <p>It returns:</p> <ul> <li>\n<p><code class=\"inline\">data</code> - the input characters</p> </li> <li>\n<p><code class=\"inline\">:eof</code> - end of file was encountered</p> </li> <li>\n<code class=\"inline\">{:error, reason}</code> - other (rare) error condition; for instance, <code class=\"inline\">{:error, :estale}</code> if reading from an NFS volume </li> </ul>    <h3 class=\"detail-header function\" id=\"gets/2\">  <span class=\"signature\">gets(device \\\\ group_leader(), prompt)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">gets(<a href=\"#t:device/0\">device</a>, <a href=\"#t:chardata/0\">chardata</a> | <a href=\"string.chars#t:t/0\">String.Chars.t</a>) ::\n  <a href=\"#t:chardata/0\">chardata</a> |\n  <a href=\"#t:nodata/0\">nodata</a></code></pre>    <p>Reads a line from the IO <code class=\"inline\">device</code>.</p> <p>It returns:</p> <ul> <li>\n<p><code class=\"inline\">data</code> - the characters in the line terminated by a line-feed (LF) or end of file (EOF)</p> </li> <li>\n<p><code class=\"inline\">:eof</code> - end of file was encountered</p> </li> <li>\n<code class=\"inline\">{:error, reason}</code> - other (rare) error condition; for instance, <code class=\"inline\">{:error, :estale}</code> if reading from an NFS volume </li> </ul> <h4>Examples</h4> <p>To display “What is your name?” as a prompt and await user input:</p> <pre data-language=\"elixir\"><code class=\"elixir\">IO.gets \"What is your name?</code></pre> <p>“</p>    <h3 class=\"detail-header function\" id=\"inspect/2\">  <span class=\"signature\">inspect(item, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">inspect(item, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: item when item: var</code></pre>    <p>Inspects and writes the given <code class=\"inline\">item</code> to the device.</p> <p>It enables pretty printing by default with width of 80 characters. The width can be changed by explicitly passing the <code class=\"inline\">:width</code> option.</p> <p>See <a href=\"inspect.opts\"><code class=\"inline\">Inspect.Opts</code></a> for a full list of options.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">IO.inspect Process.list, width: 40</code></pre>    <h3 class=\"detail-header function\" id=\"inspect/3\">  <span class=\"signature\">inspect(device, item, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">inspect(<a href=\"#t:device/0\">device</a>, item, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: item when item: var</code></pre>    <p>Inspects <code class=\"inline\">item</code> according to the given options using the IO <code class=\"inline\">device</code>.</p> <p>See <a href=\"inspect.opts\"><code class=\"inline\">Inspect.Opts</code></a> for a full list of options.</p>    <h3 class=\"detail-header function\" id=\"iodata_length/1\">  <span class=\"signature\">iodata_length(item)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">iodata_length(iodata) :: non_neg_integer</code></pre>    <p>Returns the size of an iodata.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; IO.iodata_length([1, 2 | &lt;&lt;3, 4&gt;&gt;])\n4</code></pre>    <h3 class=\"detail-header function\" id=\"iodata_to_binary/1\">  <span class=\"signature\">iodata_to_binary(item)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">iodata_to_binary(iodata) :: binary</code></pre>    <p>Converts iodata (a list of integers representing bytes, lists and binaries) into a binary. The operation is Unicode unsafe.</p> <p>Notice that this function treats lists of integers as raw bytes and does not perform any kind of encoding conversion. If you want to convert from a charlist to a string (UTF-8 encoded), please use <a href=\"#chardata_to_string/1\"><code class=\"inline\">chardata_to_string/1</code></a> instead.</p> <p>If this function receives a binary, the same binary is returned.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; bin1 = &lt;&lt;1, 2, 3&gt;&gt;\niex&gt; bin2 = &lt;&lt;4, 5&gt;&gt;\niex&gt; bin3 = &lt;&lt;6&gt;&gt;\niex&gt; IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4 | bin3])\n&lt;&lt;1, 2, 3, 1, 2, 3, 4, 5, 4, 6&gt;&gt;\n\niex&gt; bin = &lt;&lt;1, 2, 3&gt;&gt;\niex&gt; IO.iodata_to_binary(bin)\n&lt;&lt;1, 2, 3&gt;&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"puts/2\">  <span class=\"signature\">puts(device \\\\ group_leader(), item)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">puts(<a href=\"#t:device/0\">device</a>, <a href=\"#t:chardata/0\">chardata</a> | <a href=\"string.chars#t:t/0\">String.Chars.t</a>) :: :ok</code></pre>    <p>Writes <code class=\"inline\">item</code> to the given <code class=\"inline\">device</code>, similar to <a href=\"#write/2\"><code class=\"inline\">write/2</code></a>, but adds a newline at the end.</p>    <h3 class=\"detail-header function\" id=\"read/2\">  <span class=\"signature\">read(device \\\\ group_leader(), line_or_chars)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">read(<a href=\"#t:device/0\">device</a>, :all | :line | non_neg_integer) ::\n  <a href=\"#t:chardata/0\">chardata</a> |\n  <a href=\"#t:nodata/0\">nodata</a></code></pre>    <p>Reads from the IO <code class=\"inline\">device</code>.</p> <p>The <code class=\"inline\">device</code> is iterated by the given number of characters or line by line if <code class=\"inline\">:line</code> is given. Alternatively, if <code class=\"inline\">:all</code> is given, then whole <code class=\"inline\">device</code> is returned.</p> <p>It returns:</p> <ul> <li>\n<p><code class=\"inline\">data</code> - the input characters</p> </li> <li>\n<p><code class=\"inline\">:eof</code> - end of file was encountered</p> </li> <li>\n<code class=\"inline\">{:error, reason}</code> - other (rare) error condition; for instance, <code class=\"inline\">{:error, :estale}</code> if reading from an NFS volume </li> </ul> <p>If <code class=\"inline\">:all</code> is given, <code class=\"inline\">:eof</code> is never returned, but an empty string in case the device has reached EOF.</p>    <h3 class=\"detail-header function\" id=\"stream/2\">  <span class=\"signature\">stream(device, line_or_codepoints)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stream(<a href=\"#t:device/0\">device</a>, :line | pos_integer) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Converts the IO <code class=\"inline\">device</code> into an <a href=\"io.stream\"><code class=\"inline\">IO.Stream</code></a>.</p> <p>An <a href=\"io.stream\"><code class=\"inline\">IO.Stream</code></a> implements both <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> and <a href=\"collectable\"><code class=\"inline\">Collectable</code></a>, allowing it to be used for both read and write.</p> <p>The <code class=\"inline\">device</code> is iterated by the given number of characters or line by line if <code class=\"inline\">:line</code> is given.</p> <p>This reads from the IO as utf-8. Check out <a href=\"io#binstream/2\"><code class=\"inline\">IO.binstream/2</code></a> to handle the IO as a raw binary.</p> <p>Note that an IO stream has side effects and every time you go over the stream you may get different results.</p> <h4>Examples</h4> <p>Here is an example on how we mimic an echo server from the command line:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Enum.each IO.stream(:stdio, :line), &amp;IO.write(&amp;1)</code></pre>    <h3 class=\"detail-header function\" id=\"warn/1\">  <span class=\"signature\">warn(message)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">warn(<a href=\"#t:chardata/0\">chardata</a> | <a href=\"string.chars#t:t/0\">String.Chars.t</a>) :: :ok</code></pre>    <p>Writes a <code class=\"inline\">message</code> to stderr, along with the current stacktrace.</p> <p>It returns <code class=\"inline\">:ok</code> if it succeeds.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">IO.warn \"variable bar is unused\"\n#=&gt; warning: variable bar is unused\n#=&gt;   (iex) evaluator.ex:108: IEx.Evaluator.eval/4</code></pre>    <h3 class=\"detail-header function\" id=\"warn/2\">  <span class=\"signature\">warn(message, stacktrace)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">warn(<a href=\"#t:chardata/0\">chardata</a> | <a href=\"string.chars#t:t/0\">String.Chars.t</a>, <a href=\"exception#t:stacktrace/0\">Exception.stacktrace</a>) :: :ok</code></pre>    <p>Writes a <code class=\"inline\">message</code> to stderr, along with the given <code class=\"inline\">stacktrace</code>.</p> <p>This function also notifies the compiler a warning was printed (in case —warnings-as-errors was enabled). It returns <code class=\"inline\">:ok</code> if it succeeds.</p> <p>An empty list can be passed to avoid stacktrace printing.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">stacktrace = [{MyApp, :main, 1, [file: 'my_app.ex', line: 4]}]\nIO.warn \"variable bar is unused\", stacktrace\n#=&gt; warning: variable bar is unused\n#=&gt;   my_app.ex:4: MyApp.main/1</code></pre>    <h3 class=\"detail-header function\" id=\"write/2\">  <span class=\"signature\">write(device \\\\ group_leader(), item)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">write(<a href=\"#t:device/0\">device</a>, <a href=\"#t:chardata/0\">chardata</a> | <a href=\"string.chars#t:t/0\">String.Chars.t</a>) :: :ok</code></pre>    <p>Writes <code class=\"inline\">item</code> to the given <code class=\"inline\">device</code>.</p> <p>By default the <code class=\"inline\">device</code> is the standard output. It returns <code class=\"inline\">:ok</code> if it succeeds.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">IO.write \"sample\"\n#=&gt; sample\n\nIO.write :stderr, \"error\"\n#=&gt; error</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/IO.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/IO.html</a>\n  </p>\n</div>\n","elixir/inspect.algebra":"<h1>  Inspect.Algebra  </h1>  <p>A set of functions for creating and manipulating algebra documents.</p> <p>This module implements the functionality described in <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200\" title=\"\">“Strictly Pretty” (2000) by Christian Lindig</a> with small additions, like support for String nodes, and a custom rendering function that maximises horizontal space use.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Inspect.Algebra.empty\n:doc_nil\n\niex&gt; \"foo\"\n\"foo\"</code></pre> <p>With the functions in this module, we can concatenate different elements together and render them:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = Inspect.Algebra.concat(Inspect.Algebra.empty, \"foo\")\niex&gt; Inspect.Algebra.format(doc, 80)\n[\"foo\"]</code></pre> <p>The functions <a href=\"#nest/2\"><code class=\"inline\">nest/2</code></a>, <a href=\"#space/2\"><code class=\"inline\">space/2</code></a> and <a href=\"#line/2\"><code class=\"inline\">line/2</code></a> help you put the document together into a rigid structure. However, the document algebra gets interesting when using functions like <code class=\"inline\">break/2</code>, which converts the given string into a line break depending on how much space there is to print. Let’s glue two docs together with a break and then render it:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\niex&gt; Inspect.Algebra.format(doc, 80)\n[\"a\", \" \", \"b\"]</code></pre> <p>Notice the break was represented as is, because we haven’t reached a line limit. Once we do, it is replaced by a newline:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b\")\niex&gt; Inspect.Algebra.format(doc, 10)\n[\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]</code></pre> <p>Finally, this module also contains Elixir related functions, a bit tied to Elixir formatting, namely <a href=\"#surround/3\"><code class=\"inline\">surround/3</code></a> and <code class=\"inline\">surround_many/5</code>.</p> <h2 id=\"module-implementation-details\" class=\"section-heading\">  Implementation details </h2> <p>The original Haskell implementation of the algorithm by <a href=\"http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf\" title=\"\">Wadler</a> relies on lazy evaluation to unfold document groups on two alternatives: <code class=\"inline\">:flat</code> (breaks as spaces) and <code class=\"inline\">:break</code> (breaks as newlines). Implementing the same logic in a strict language such as Elixir leads to an exponential growth of possible documents, unless document groups are encoded explicitly as <code class=\"inline\">:flat</code> or <code class=\"inline\">:break</code>. Those groups are then reduced to a simple document, where the layout is already decided, per <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200\" title=\"\">Lindig</a>.</p> <p>This implementation slightly changes the semantic of Lindig’s algorithm to allow elements that belong to the same group to be printed together in the same line, even if they do not fit the line fully. This was achieved by changing <code class=\"inline\">:break</code> to mean a possible break and <code class=\"inline\">:flat</code> to force a flat structure. Then deciding if a break works as a newline is just a matter of checking if we have enough space until the next break that is not inside a group (which is still flat).</p> <p>Custom pretty printers can be implemented using the documents returned by this module and by providing their own rendering functions.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#break/0\">break()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#break/1\">break(s)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Document entity representing a break</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#concat/1\">concat(docs)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Concatenates a list of documents</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#concat/2\">concat(x, y)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Concatenates two document entities</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#empty/0\">empty()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a document entity used to represent nothingness</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fold_doc/2\">fold_doc(list, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Folds a list of document entities into a document entity using a function that is passed as the first argument</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format/2\">format(d, w)</a> </dt> <dd class=\"summary-synopsis\">\n<p>The formatting function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#glue/2\">glue(x, y)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts a break between two docs. See <a href=\"#break/1\"><code class=\"inline\">break/1</code></a> for more info</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#glue/3\">glue(x, g, y)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts a break, passed as the second argument, between two docs, the first and the third arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#group/1\">group(d)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a group containing the specified document</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#line/2\">line(x, y)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts a mandatory linebreak between two document entities</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#nest/2\">nest(x, i)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Nests document entity <code class=\"inline\">x</code> positions deep</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#space/2\">space(x, y)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts a mandatory single space between two document entities</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#surround/3\">surround(left, doc, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Surrounds a document with characters</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#surround_many/6\">surround_many(left, docs, right, opts, fun, separator \\\\ \",\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Maps and glues a collection of items</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_doc/2\">to_doc(map, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an Elixir structure to an algebra document according to the inspect protocol</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> ::\n  :doc_nil |\n  :doc_line |\n  doc_cons |\n  doc_nest |\n  doc_break |\n  doc_group |\n  binary</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"break/0\">  <span class=\"signature\">break()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">break :: doc_break</code></pre>       <h3 class=\"detail-header function\" id=\"break/1\">  <span class=\"signature\">break(s)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">break(binary) :: doc_break</code></pre>    <p>Document entity representing a break.</p> <p>This break can be rendered as a linebreak or as spaces, depending on the <code class=\"inline\">mode</code> of the chosen layout or the provided separator.</p> <h4>Examples</h4> <p>Let’s glue two docs together with a break and then render it:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\niex&gt; Inspect.Algebra.format(doc, 80)\n[\"a\", \" \", \"b\"]</code></pre> <p>Notice the break was represented as is, because we haven’t reached a line limit. Once we do, it is replaced by a newline:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b\")\niex&gt; Inspect.Algebra.format(doc, 10)\n[\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]</code></pre>    <h3 class=\"detail-header function\" id=\"concat/1\">  <span class=\"signature\">concat(docs)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">concat([<a href=\"#t:t/0\">t</a>]) :: doc_cons</code></pre>    <p>Concatenates a list of documents.</p>    <h3 class=\"detail-header function\" id=\"concat/2\">  <span class=\"signature\">concat(x, y)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">concat(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: doc_cons</code></pre>    <p>Concatenates two document entities.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = Inspect.Algebra.concat \"hello\", \"world\"\niex&gt; Inspect.Algebra.format(doc, 80)\n[\"hello\", \"world\"]</code></pre>    <h3 class=\"detail-header function\" id=\"empty/0\">  <span class=\"signature\">empty()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">empty :: :doc_nil</code></pre>    <p>Returns a document entity used to represent nothingness.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Inspect.Algebra.empty\n:doc_nil</code></pre>    <h3 class=\"detail-header function\" id=\"fold_doc/2\">  <span class=\"signature\">fold_doc(list, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fold_doc([<a href=\"#t:t/0\">t</a>], (<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a> -&gt; <a href=\"#t:t/0\">t</a>)) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Folds a list of document entities into a document entity using a function that is passed as the first argument.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = [\"A\", \"B\"]\niex&gt; doc = Inspect.Algebra.fold_doc(doc, fn(x, y) -&gt;\n...&gt;   Inspect.Algebra.concat [x, \"!\", y]\n...&gt; end)\niex&gt; Inspect.Algebra.format(doc, 80)\n[\"A\", \"!\", \"B\"]</code></pre>    <h3 class=\"detail-header function\" id=\"format/2\">  <span class=\"signature\">format(d, w)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">format(<a href=\"#t:t/0\">t</a>, non_neg_integer | :infinity) :: iodata</code></pre>    <p>The formatting function.</p> <p>Takes the maximum width and a document to print as its arguments and returns an IO data representation of the best layout for the document to fit in the given width.</p>    <h3 class=\"detail-header function\" id=\"glue/2\">  <span class=\"signature\">glue(x, y)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">glue(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: doc_cons</code></pre>    <p>Inserts a break between two docs. See <a href=\"#break/1\"><code class=\"inline\">break/1</code></a> for more info.</p>    <h3 class=\"detail-header function\" id=\"glue/3\">  <span class=\"signature\">glue(x, g, y)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">glue(<a href=\"#t:t/0\">t</a>, binary, <a href=\"#t:t/0\">t</a>) :: doc_cons</code></pre>    <p>Inserts a break, passed as the second argument, between two docs, the first and the third arguments.</p>    <h3 class=\"detail-header function\" id=\"group/1\">  <span class=\"signature\">group(d)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">group(<a href=\"#t:t/0\">t</a>) :: doc_group</code></pre>    <p>Returns a group containing the specified document.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = Inspect.Algebra.group(\n...&gt;   Inspect.Algebra.concat(\n...&gt;     Inspect.Algebra.group(\n...&gt;       Inspect.Algebra.concat(\n...&gt;         \"Hello,\",\n...&gt;         Inspect.Algebra.concat(\n...&gt;           Inspect.Algebra.break,\n...&gt;           \"A\"\n...&gt;         )\n...&gt;       )\n...&gt;     ),\n...&gt;     Inspect.Algebra.concat(\n...&gt;       Inspect.Algebra.break,\n...&gt;       \"B\"\n...&gt;     )\n...&gt; ))\niex&gt; Inspect.Algebra.format(doc, 80)\n[\"Hello,\", \" \", \"A\", \" \", \"B\"]\niex&gt; Inspect.Algebra.format(doc, 6)\n[\"Hello,\", \"\\n\", \"A\", \" \", \"B\"]</code></pre>    <h3 class=\"detail-header function\" id=\"line/2\">  <span class=\"signature\">line(x, y)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">line(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: doc_cons</code></pre>    <p>Inserts a mandatory linebreak between two document entities.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = Inspect.Algebra.line \"Hughes\", \"Wadler\"\niex&gt; Inspect.Algebra.format(doc, 80)\n[\"Hughes\", \"\\n\", \"Wadler\"]</code></pre>    <h3 class=\"detail-header function\" id=\"nest/2\">  <span class=\"signature\">nest(x, i)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">nest(<a href=\"#t:t/0\">t</a>, non_neg_integer) :: doc_nest</code></pre>    <p>Nests document entity <code class=\"inline\">x</code> positions deep.</p> <p>Nesting will be appended to the line breaks.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world\"), 5)\niex&gt; Inspect.Algebra.format(doc, 5)\n[\"hello\", \"\\n     \", \"world\"]</code></pre>    <h3 class=\"detail-header function\" id=\"space/2\">  <span class=\"signature\">space(x, y)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">space(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: doc_cons</code></pre>    <p>Inserts a mandatory single space between two document entities.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = Inspect.Algebra.space \"Hughes\", \"Wadler\"\niex&gt; Inspect.Algebra.format(doc, 80)\n[\"Hughes\", \" \", \"Wadler\"]</code></pre>    <h3 class=\"detail-header function\" id=\"surround/3\">  <span class=\"signature\">surround(left, doc, right)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">surround(binary, <a href=\"#t:t/0\">t</a>, binary) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Surrounds a document with characters.</p> <p>Puts the document between left and right enclosing and nesting it. The document is marked as a group, to show the maximum as possible concisely together.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = Inspect.Algebra.surround \"[\", Inspect.Algebra.glue(\"a\", \"b\"), \"]\"\niex&gt; Inspect.Algebra.format(doc, 3)\n[\"[\", \"a\", \"\\n \", \"b\", \"]\"]</code></pre>    <h3 class=\"detail-header function\" id=\"surround_many/6\">  <span class=\"signature\">surround_many(left, docs, right, opts, fun, separator \\\\ \",\")</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">surround_many(binary, [any], binary, <a href=\"inspect.opts#t:t/0\">Inspect.Opts.t</a>, (term, <a href=\"inspect.opts#t:t/0\">Inspect.Opts.t</a> -&gt; <a href=\"#t:t/0\">t</a>), binary) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Maps and glues a collection of items.</p> <p>It uses the given left and right as surrounding and a separator for each item. A limit can be passed which, once reached, stops gluing and outputs “…” instead.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), \"]\",\n...&gt;         %Inspect.Opts{limit: :infinity}, fn i, _opts -&gt; to_string(i) end)\niex&gt; Inspect.Algebra.format(doc, 5) |&gt; IO.iodata_to_binary\n\"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n\niex&gt; doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), \"]\",\n...&gt;         %Inspect.Opts{limit: 3}, fn i, _opts -&gt; to_string(i) end)\niex&gt; Inspect.Algebra.format(doc, 20) |&gt; IO.iodata_to_binary\n\"[1, 2, 3, ...]\"\n\niex&gt; doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), \"]\",\n...&gt;         %Inspect.Opts{limit: 3}, fn i, _opts -&gt; to_string(i) end, \"!\")\niex&gt; Inspect.Algebra.format(doc, 20) |&gt; IO.iodata_to_binary\n\"[1! 2! 3! ...]\"</code></pre>    <h3 class=\"detail-header function\" id=\"to_doc/2\">  <span class=\"signature\">to_doc(map, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_doc(any, <a href=\"inspect.opts#t:t/0\">Inspect.Opts.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Converts an Elixir structure to an algebra document according to the inspect protocol.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Inspect.Algebra.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Inspect.Algebra.html</a>\n  </p>\n</div>\n","elixir/integer":"<h1>  Integer  </h1>  <p>Functions for working with integers.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#digits/2\">digits(integer, base \\\\ 10)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the ordered digits for the given non-negative <code class=\"inline\">integer</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#parse/2\">parse(binary, base \\\\ 10)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses a text representation of an integer</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_charlist/1\">to_charlist(integer)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a charlist which corresponds to the text representation of the given <code class=\"inline\">integer</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_charlist/2\">to_charlist(integer, base)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a charlist which corresponds to the text representation of <code class=\"inline\">integer</code> in the given <code class=\"inline\">base</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(integer)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a binary which corresponds to the text representation of <code class=\"inline\">integer</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/2\">to_string(integer, base)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a binary which corresponds to the text representation of <code class=\"inline\">integer</code> in the given <code class=\"inline\">base</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#undigits/2\">undigits(digits, base \\\\ 10)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the integer represented by the ordered <code class=\"inline\">digits</code></p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#is_even/1\">is_even(integer)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Determines if an <code class=\"inline\">integer</code> is even</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_odd/1\">is_odd(integer)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Determines if <code class=\"inline\">integer</code> is odd</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"digits/2\">  <span class=\"signature\">digits(integer, base \\\\ 10)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">digits(non_neg_integer, pos_integer) :: [non_neg_integer, ...]</code></pre>    <p>Returns the ordered digits for the given non-negative <code class=\"inline\">integer</code>.</p> <p>An optional <code class=\"inline\">base</code> value may be provided representing the radix for the returned digits. This one can be an integer &gt;= 2.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Integer.digits(101)\n[1, 0, 1]\n\niex&gt; Integer.digits(170, 2)\n[1, 0, 1, 0, 1, 0, 1, 0]</code></pre>    <h3 class=\"detail-header function\" id=\"parse/2\">  <span class=\"signature\">parse(binary, base \\\\ 10)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">parse(binary, 2..36) ::\n  {integer, binary} |\n  :error |\n  no_return</code></pre>    <p>Parses a text representation of an integer.</p> <p>An optional <code class=\"inline\">base</code> to the corresponding integer can be provided. If <code class=\"inline\">base</code> is not given, 10 will be used.</p> <p>If successful, returns a tuple in the form of <code class=\"inline\">{integer, remainder_of_binary}</code>. Otherwise <code class=\"inline\">:error</code>.</p> <p>Raises an error if <code class=\"inline\">base</code> is less than 2 or more than 36.</p> <p>If you want to convert a string-formatted integer directly to a integer, <a href=\"string#to_integer/1\"><code class=\"inline\">String.to_integer/1</code></a> or <a href=\"string#to_integer/2\"><code class=\"inline\">String.to_integer/2</code></a> can be used instead.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Integer.parse(\"34\")\n{34, \"\"}\n\niex&gt; Integer.parse(\"34.5\")\n{34, \".5\"}\n\niex&gt; Integer.parse(\"three\")\n:error\n\niex&gt; Integer.parse(\"34\", 10)\n{34, \"\"}\n\niex&gt; Integer.parse(\"f4\", 16)\n{244, \"\"}\n\niex&gt; Integer.parse(\"Awww++\", 36)\n{509216, \"++\"}\n\niex&gt; Integer.parse(\"fab\", 10)\n:error\n\niex&gt; Integer.parse(\"a2\", 38)\n** (ArgumentError) invalid base 38</code></pre>    <h3 class=\"detail-header function\" id=\"to_charlist/1\">  <span class=\"signature\">to_charlist(integer)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_charlist(integer) :: charlist</code></pre>    <p>Returns a charlist which corresponds to the text representation of the given <code class=\"inline\">integer</code>.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Integer.to_charlist(123)\n'123'\n\niex&gt; Integer.to_charlist(+456)\n'456'\n\niex&gt; Integer.to_charlist(-789)\n'-789'\n\niex&gt; Integer.to_charlist(0123)\n'123'</code></pre>    <h3 class=\"detail-header function\" id=\"to_charlist/2\">  <span class=\"signature\">to_charlist(integer, base)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_charlist(integer, 2..36) :: charlist</code></pre>    <p>Returns a charlist which corresponds to the text representation of <code class=\"inline\">integer</code> in the given <code class=\"inline\">base</code>.</p> <p><code class=\"inline\">base</code> can be an integer between 2 and 36.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Integer.to_charlist(100, 16)\n'64'\n\niex&gt; Integer.to_charlist(-100, 16)\n'-64'\n\niex&gt; Integer.to_charlist(882681651, 36)\n'ELIXIR'</code></pre>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(integer)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_string(integer) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Returns a binary which corresponds to the text representation of <code class=\"inline\">integer</code>.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Integer.to_string(123)\n\"123\"\n\niex&gt; Integer.to_string(+456)\n\"456\"\n\niex&gt; Integer.to_string(-789)\n\"-789\"\n\niex&gt; Integer.to_string(0123)\n\"123\"</code></pre>    <h3 class=\"detail-header function\" id=\"to_string/2\">  <span class=\"signature\">to_string(integer, base)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_string(integer, 2..36) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Returns a binary which corresponds to the text representation of <code class=\"inline\">integer</code> in the given <code class=\"inline\">base</code>.</p> <p><code class=\"inline\">base</code> can be an integer between 2 and 36.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Integer.to_string(100, 16)\n\"64\"\n\niex&gt; Integer.to_string(-100, 16)\n\"-64\"\n\niex&gt; Integer.to_string(882681651, 36)\n\"ELIXIR\"</code></pre>    <h3 class=\"detail-header function\" id=\"undigits/2\">  <span class=\"signature\">undigits(digits, base \\\\ 10)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">undigits([integer], integer) :: integer</code></pre>    <p>Returns the integer represented by the ordered <code class=\"inline\">digits</code>.</p> <p>An optional <code class=\"inline\">base</code> value may be provided representing the radix for the <code class=\"inline\">digits</code>. This one can be an integer &gt;= 2.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Integer.undigits([1, 2, 3])\n123\n\niex&gt; Integer.undigits([1, 4], 16)\n20\n\niex&gt; Integer.undigits([])\n0</code></pre>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"is_even/1\">  <span class=\"signature\">is_even(integer)</span>  </h3>  <p>Determines if an <code class=\"inline\">integer</code> is even.</p> <p>Returns <code class=\"inline\">true</code> if the given <code class=\"inline\">integer</code> is an even number, otherwise it returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard clauses.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Integer.is_even(10)\ntrue\n\niex&gt; Integer.is_even(5)\nfalse\n\niex&gt; Integer.is_even(-10)\ntrue\n\niex&gt; Integer.is_even(0)\ntrue</code></pre>    <h3 class=\"detail-header macro\" id=\"is_odd/1\">  <span class=\"signature\">is_odd(integer)</span>  </h3>  <p>Determines if <code class=\"inline\">integer</code> is odd.</p> <p>Returns <code class=\"inline\">true</code> if the given <code class=\"inline\">integer</code> is an odd number, otherwise it returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard clauses.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Integer.is_odd(5)\ntrue\n\niex&gt; Integer.is_odd(6)\nfalse\n\niex&gt; Integer.is_odd(-5)\ntrue\n\niex&gt; Integer.is_odd(0)\nfalse</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Integer.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Integer.html</a>\n  </p>\n</div>\n","elixir/macro.env":"<h1>  Macro.Env  </h1>  <p>A struct that holds compile time environment information.</p> <p>The current environment can be accessed at any time as <code class=\"inline\">__ENV__</code>. Inside macros, the caller environment can be accessed as <code class=\"inline\">__CALLER__</code>.</p> <p>An instance of <a href=\"macro.env#content\"><code class=\"inline\">Macro.Env</code></a> must not be modified by hand. If you need to create a custom environment to pass to <a href=\"code#eval_quoted/3\"><code class=\"inline\">Code.eval_quoted/3</code></a>, use the following trick:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def make_custom_env do\n  import SomeModule, only: [some_function: 2]\n  alias A.B.C\n  __ENV__\nend</code></pre> <p>You may then call <code class=\"inline\">make_custom_env()</code> to get a struct with the desired imports and aliases included.</p> <p>It contains the following fields:</p> <ul> <li>\n<code class=\"inline\">module</code> - the current module name </li> <li>\n<code class=\"inline\">file</code> - the current file name as a binary </li> <li>\n<code class=\"inline\">line</code> - the current line as an integer </li> <li>\n<code class=\"inline\">function</code> - a tuple as <code class=\"inline\">{atom, integer}</code>, where the first element is the function name and the second its arity; returns <code class=\"inline\">nil</code> if not inside a function </li> <li>\n<code class=\"inline\">context</code> - the context of the environment; it can be <code class=\"inline\">nil</code> (default context), inside a guard or inside a match </li> <li>\n<code class=\"inline\">aliases</code> - a list of two-element tuples, where the first element is the aliased name and the second one the actual name </li> <li>\n<code class=\"inline\">requires</code> - the list of required modules </li> <li>\n<code class=\"inline\">functions</code> - a list of functions imported from each module </li> <li>\n<code class=\"inline\">macros</code> - a list of macros imported from each module </li> <li>\n<code class=\"inline\">macro_aliases</code> - a list of aliases defined inside the current macro </li> <li>\n<code class=\"inline\">context_modules</code> - a list of modules defined in the current context </li> <li>\n<code class=\"inline\">vars</code> - a list keeping all defined variables as <code class=\"inline\">{var, context}</code> </li> <li>\n<code class=\"inline\">export_vars</code> - a list keeping all variables to be exported in a construct (may be <code class=\"inline\">nil</code>) </li> <li>\n<code class=\"inline\">lexical_tracker</code> - PID of the lexical tracker which is responsible for keeping user info </li> <li>\n<code class=\"inline\">local</code> - the module to expand local functions to </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:aliases/0\">aliases()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:context/0\">context()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:context_modules/0\">context_modules()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:export_vars/0\">export_vars()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:file/0\">file()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:functions/0\">functions()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:lexical_tracker/0\">lexical_tracker()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:line/0\">line()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:local/0\">local()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:macro_aliases/0\">macro_aliases()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:macros/0\">macros()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:name_arity/0\">name_arity()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:requires/0\">requires()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:vars/0\">vars()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#in_guard?/1\">in_guard?(env)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns whether the compilation environment is currently inside a guard</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#in_match?/1\">in_match?(env)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns whether the compilation environment is currently inside a match clause</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#location/1\">location(env)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a keyword list containing the file and line information as keys</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stacktrace/1\">stacktrace(env)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the environment stacktrace</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:aliases/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:aliases/0\">aliases</a> :: [{module, module}]</code></pre> </div> <div id=\"t:context/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:context/0\">context</a> :: :match | :guard | nil</code></pre> </div> <div id=\"t:context_modules/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:context_modules/0\">context_modules</a> :: [module]</code></pre> </div> <div id=\"t:export_vars/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:export_vars/0\">export_vars</a> :: <a href=\"#t:vars/0\">vars</a> | nil</code></pre> </div> <div id=\"t:file/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:file/0\">file</a> :: binary</code></pre> </div> <div id=\"t:functions/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:functions/0\">functions</a> :: [{module, [<a href=\"#t:name_arity/0\">name_arity</a>]}]</code></pre> </div> <div id=\"t:lexical_tracker/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:lexical_tracker/0\">lexical_tracker</a> :: pid</code></pre> </div> <div id=\"t:line/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:line/0\">line</a> :: non_neg_integer</code></pre> </div> <div id=\"t:local/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:local/0\">local</a> :: atom | nil</code></pre> </div> <div id=\"t:macro_aliases/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:macro_aliases/0\">macro_aliases</a> :: [{module, {integer, module}}]</code></pre> </div> <div id=\"t:macros/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:macros/0\">macros</a> :: [{module, [<a href=\"#t:name_arity/0\">name_arity</a>]}]</code></pre> </div> <div id=\"t:name_arity/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:name_arity/0\">name_arity</a> :: {atom, arity}</code></pre> </div> <div id=\"t:requires/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:requires/0\">requires</a> :: [module]</code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Macro.Env{module: atom, file: <a href=\"#t:file/0\">file</a>, line: <a href=\"#t:line/0\">line</a>, function: <a href=\"#t:name_arity/0\">name_arity</a> | nil, context: <a href=\"#t:context/0\">context</a>, requires: <a href=\"#t:requires/0\">requires</a>, aliases: <a href=\"#t:aliases/0\">aliases</a>, functions: <a href=\"#t:functions/0\">functions</a>, macros: <a href=\"#t:macros/0\">macros</a>, macro_aliases: <a href=\"#t:aliases/0\">aliases</a>, context_modules: <a href=\"#t:context_modules/0\">context_modules</a>, vars: <a href=\"#t:vars/0\">vars</a>, export_vars: <a href=\"#t:export_vars/0\">export_vars</a>, lexical_tracker: <a href=\"#t:lexical_tracker/0\">lexical_tracker</a>, local: <a href=\"#t:local/0\">local</a>}</code></pre> </div> <div id=\"t:vars/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:vars/0\">vars</a> :: [{atom, atom | non_neg_integer}]</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"in_guard?/1\">  <span class=\"signature\">in_guard?(env)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">in_guard?(<a href=\"#t:t/0\">t</a>) :: boolean</code></pre>    <p>Returns whether the compilation environment is currently inside a guard.</p>    <h3 class=\"detail-header function\" id=\"in_match?/1\">  <span class=\"signature\">in_match?(env)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">in_match?(<a href=\"#t:t/0\">t</a>) :: boolean</code></pre>    <p>Returns whether the compilation environment is currently inside a match clause.</p>    <h3 class=\"detail-header function\" id=\"location/1\">  <span class=\"signature\">location(env)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">location(<a href=\"#t:t/0\">t</a>) :: <a href=\"keyword#t:t/0\">Keyword.t</a></code></pre>    <p>Returns a keyword list containing the file and line information as keys.</p>    <h3 class=\"detail-header function\" id=\"stacktrace/1\">  <span class=\"signature\">stacktrace(env)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stacktrace(<a href=\"#t:t/0\">t</a>) :: list</code></pre>    <p>Returns the environment stacktrace.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Macro.Env.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Macro.Env.html</a>\n  </p>\n</div>\n","elixir/genserver":"<h1>  GenServer <small>behaviour</small>  </h1>  <p>A behaviour module for implementing the server of a client-server relation.</p> <p>A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.</p> <h2 id=\"module-example\" class=\"section-heading\">  Example </h2> <p>The GenServer behaviour abstracts the common client-server interaction. Developers are only required to implement the callbacks and functionality they are interested in.</p> <p>Let’s start with a code example and then explore the available callbacks. Imagine we want a GenServer that works like a stack, allowing us to push and pop items:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Stack do\n  use GenServer\n\n  # Callbacks\n\n  def handle_call(:pop, _from, [h | t]) do\n    {:reply, h, t}\n  end\n\n  def handle_cast({:push, item}, state) do\n    {:noreply, [item | state]}\n  end\nend\n\n# Start the server\n{:ok, pid} = GenServer.start_link(Stack, [:hello])\n\n# This is the client\nGenServer.call(pid, :pop)\n#=&gt; :hello\n\nGenServer.cast(pid, {:push, :world})\n#=&gt; :ok\n\nGenServer.call(pid, :pop)\n#=&gt; :world</code></pre> <p>We start our <code class=\"inline\">Stack</code> by calling <a href=\"#start_link/3\"><code class=\"inline\">start_link/3</code></a>, passing the module with the server implementation and its initial argument (a list representing the stack containing the item <code class=\"inline\">:hello</code>). We can primarily interact with the server by sending two types of messages. <strong>call</strong> messages expect a reply from the server (and are therefore synchronous) while <strong>cast</strong> messages do not.</p> <p>Every time you do a <a href=\"genserver#call/3\"><code class=\"inline\">GenServer.call/3</code></a>, the client will send a message that must be handled by the <code class=\"inline\">handle_call/3</code> callback in the GenServer. A <a href=\"#cast/2\"><code class=\"inline\">cast/2</code></a> message must be handled by <code class=\"inline\">handle_cast/2</code>.</p> <h2 id=\"module-callbacks\" class=\"section-heading\">  Callbacks </h2> <p>There are 6 callbacks required to be implemented in a <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a>. By adding <code class=\"inline\">use GenServer</code> to your module, Elixir will automatically define all 6 callbacks for you, leaving it up to you to implement the ones you want to customize.</p> <h2 id=\"module-name-registration\" class=\"section-heading\">  Name Registration </h2> <p>Both <a href=\"#start_link/3\"><code class=\"inline\">start_link/3</code></a> and <a href=\"#start/3\"><code class=\"inline\">start/3</code></a> support the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> to register a name on start via the <code class=\"inline\">:name</code> option. Registered names are also automatically cleaned up on termination. The supported values are:</p> <ul> <li>\n<p>an atom - the GenServer is registered locally with the given name using <a href=\"process#register/2\"><code class=\"inline\">Process.register/2</code></a>.</p> </li> <li>\n<p><code class=\"inline\">{:global, term}</code>- the GenServer is registered globally with the given term using the functions in the <code class=\"inline\">:global</code> module.</p> </li> <li>\n<code class=\"inline\">{:via, module, term}</code> - the GenServer is registered with the given mechanism and name. The <code class=\"inline\">:via</code> option expects a module that exports <code class=\"inline\">register_name/2</code>, <code class=\"inline\">unregister_name/1</code>, <code class=\"inline\">whereis_name/1</code> and <code class=\"inline\">send/2</code>. One such example is the <code class=\"inline\">:global</code> module which uses these functions for keeping the list of names of processes and their associated pid’s that are available globally for a network of Erlang nodes. </li> </ul> <p>For example, we could start and register our Stack server locally as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Start the server and register it locally with name MyStack\n{:ok, _} = GenServer.start_link(Stack, [:hello], name: MyStack)\n\n# Now messages can be sent directly to MyStack\nGenServer.call(MyStack, :pop) #=&gt; :hello</code></pre> <p>Once the server is started, the remaining functions in this module (<a href=\"#call/3\"><code class=\"inline\">call/3</code></a>, <a href=\"#cast/2\"><code class=\"inline\">cast/2</code></a>, and friends) will also accept an atom, or any <code class=\"inline\">:global</code> or <code class=\"inline\">:via</code> tuples. In general, the following formats are supported:</p> <ul> <li>a <code class=\"inline\">pid</code> </li> <li>an <code class=\"inline\">atom</code> if the server is locally registered </li> <li>\n<code class=\"inline\">{atom, node}</code> if the server is locally registered at another node </li> <li>\n<code class=\"inline\">{:global, term}</code> if the server is globally registered </li> <li>\n<code class=\"inline\">{:via, module, name}</code> if the server is registered through an alternative registry </li> </ul> <h2 id=\"module-client-server-apis\" class=\"section-heading\">  Client / Server APIs </h2> <p>Although in the example above we have used <a href=\"genserver#start_link/3\"><code class=\"inline\">GenServer.start_link/3</code></a> and friends to directly start and communicate with the server, most of the time we don’t call the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> functions directly. Instead, we wrap the calls in new functions representing the public API of the server.</p> <p>Here is a better implementation of our Stack module:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Stack do\n  use GenServer\n\n  # Client\n\n  def start_link(default) do\n    GenServer.start_link(__MODULE__, default)\n  end\n\n  def push(pid, item) do\n    GenServer.cast(pid, {:push, item})\n  end\n\n  def pop(pid) do\n    GenServer.call(pid, :pop)\n  end\n\n  # Server (callbacks)\n\n  def handle_call(:pop, _from, [h | t]) do\n    {:reply, h, t}\n  end\n\n  def handle_call(request, from, state) do\n    # Call the default implementation from GenServer\n    super(request, from, state)\n  end\n\n  def handle_cast({:push, item}, state) do\n    {:noreply, [item | state]}\n  end\n\n  def handle_cast(request, state) do\n    super(request, state)\n  end\nend</code></pre> <p>In practice, it is common to have both server and client functions in the same module. If the server and/or client implementations are growing complex, you may want to have them in different modules.</p> <h2 id=\"module-receiving-custom-messages\" class=\"section-heading\">  Receiving custom messages </h2> <p>The goal of a <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> is to abstract the “receive” loop for developers, automatically handling system messages, support code change, synchronous calls and more. Therefore, you should never call your own “receive” inside the GenServer callbacks as doing so will cause the GenServer to misbehave. If you want to receive custom messages, always receive them in <code class=\"inline\">handle_info/2</code>.</p> <h2 id=\"module-learn-more\" class=\"section-heading\">  Learn more </h2> <p>If you wish to find out more about gen servers, the Elixir Getting Started guide provides a tutorial-like introduction. The documentation and links in Erlang can also provide extra insight.</p> <ul> <li>\n<a href=\"http://elixir-lang.org/getting-started/mix-otp/genserver.html\">GenServer – Elixir’s Getting Started Guide</a> </li> <li>\n<a href=\"http://www.erlang.org/doc/man/gen_server.html\"><code class=\"inline\">:gen_server</code> module documentation</a> </li> <li>\n<a href=\"http://www.erlang.org/doc/design_principles/gen_server_concepts.html\">gen_server Behaviour – OTP Design Principles</a> </li> <li>\n<a href=\"http://learnyousomeerlang.com/clients-and-servers\">Clients and Servers – Learn You Some Erlang for Great Good!</a> </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:debug/0\">debug()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Debug options supported by the <code class=\"inline\">start*</code> functions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:from/0\">from()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Tuple describing the client of a call request</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:name/0\">name()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The GenServer name</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:on_start/0\">on_start()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Return values of <code class=\"inline\">start*</code> functions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:option/0\">option()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Option values used by the <code class=\"inline\">start*</code> functions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:options/0\">options()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Options used by the <code class=\"inline\">start*</code> functions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:server/0\">server()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The server reference</p> </dd>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#abcast/3\">abcast(nodes \\\\ nodes(), name, request)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Casts all servers locally registered as <code class=\"inline\">name</code> at the specified nodes</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#call/3\">call(server, request, timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Makes a synchronous call to the <code class=\"inline\">server</code> and waits for its reply</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cast/2\">cast(server, request)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends an asynchronous request to the <code class=\"inline\">server</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#multi_call/4\">multi_call(nodes \\\\ nodes(), name, request, timeout \\\\ :infinity)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calls all servers locally registered as <code class=\"inline\">name</code> at the specified <code class=\"inline\">nodes</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reply/2\">reply(client, reply)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Replies to a client</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start/3\">start(module, args, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> process without links (outside of a supervision tree)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/3\">start_link(module, args, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> process linked to the current process</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stop/3\">stop(server, reason \\\\ :normal, timeout \\\\ :infinity)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stops the server with the given <code class=\"inline\">reason</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#whereis/1\">whereis(pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the <code class=\"inline\">pid</code> or <code class=\"inline\">{name, node}</code> of a GenServer process, or <code class=\"inline\">nil</code> if no process is associated with the given name</p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:code_change/3\">code_change(old_vsn, state, extra)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked to change the state of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> when a different version of a module is loaded (hot code swapping) and the state’s term structure should be changed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:format_status/2\">format_status(reason, pdict_and_state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked in some cases to retrieve a formatted version of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> status</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:handle_call/3\">handle_call(request, from, state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked to handle synchronous <a href=\"#call/3\"><code class=\"inline\">call/3</code></a> messages. <a href=\"#call/3\"><code class=\"inline\">call/3</code></a> will block until a reply is received (unless the call times out or nodes are disconnected)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:handle_cast/2\">handle_cast(request, state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked to handle asynchronous <a href=\"#cast/2\"><code class=\"inline\">cast/2</code></a> messages</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:handle_info/2\">handle_info(msg, state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked to handle all other messages</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:init/1\">init(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked when the server is started. <a href=\"#start_link/3\"><code class=\"inline\">start_link/3</code></a> (or <a href=\"#start/3)\"><code class=\"inline\">start/3</code></a> will block until it returns</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#c:terminate/2\">terminate(reason, state)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invoked when the server is about to exit. It should do any cleanup required</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:debug/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:debug/0\">debug</a> :: [:trace | :log | :statistics | {:log_to_file, <a href=\"path#t:t/0\">Path.t</a>}]</code></pre> <p>Debug options supported by the <code class=\"inline\">start*</code> functions</p>  </div> <div id=\"t:from/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:from/0\">from</a> :: {pid, tag :: term}</code></pre> <p>Tuple describing the client of a call request.</p> <p><code class=\"inline\">pid</code> is the pid of the caller and <code class=\"inline\">tag</code> is a unique term used to identify the call.</p>  </div> <div id=\"t:name/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:name/0\">name</a> ::\n  atom |\n  {:global, term} |\n  {:via, module, term}</code></pre> <p>The GenServer name</p>  </div> <div id=\"t:on_start/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:on_start/0\">on_start</a> ::\n  {:ok, pid} |\n  :ignore |\n  {:error, {:already_started, pid} | term}</code></pre> <p>Return values of <code class=\"inline\">start*</code> functions</p>  </div> <div id=\"t:option/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:option/0\">option</a> ::\n  {:debug, <a href=\"#t:debug/0\">debug</a>} |\n  {:name, <a href=\"#t:name/0\">name</a>} |\n  {:timeout, timeout} |\n  {:spawn_opt, <a href=\"process#t:spawn_opt/0\">Process.spawn_opt</a>}</code></pre> <p>Option values used by the <code class=\"inline\">start*</code> functions</p>  </div> <div id=\"t:options/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:options/0\">options</a> :: [<a href=\"#t:option/0\">option</a>]</code></pre> <p>Options used by the <code class=\"inline\">start*</code> functions</p>  </div> <div id=\"t:server/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:server/0\">server</a> :: pid | <a href=\"#t:name/0\">name</a> | {atom, node}</code></pre> <p>The server reference</p>  </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"abcast/3\">  <span class=\"signature\">abcast(nodes \\\\ nodes(), name, request)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">abcast([node], name :: atom, term) :: :abcast</code></pre>    <p>Casts all servers locally registered as <code class=\"inline\">name</code> at the specified nodes.</p> <p>This function returns immediately and ignores nodes that do not exist, or where the server name does not exist.</p> <p>See <a href=\"#multi_call/4\"><code class=\"inline\">multi_call/4</code></a> for more information.</p>    <h3 class=\"detail-header function\" id=\"call/3\">  <span class=\"signature\">call(server, request, timeout \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">call(<a href=\"#t:server/0\">server</a>, term, timeout) :: term</code></pre>    <p>Makes a synchronous call to the <code class=\"inline\">server</code> and waits for its reply.</p> <p>The client sends the given <code class=\"inline\">request</code> to the server and waits until a reply arrives or a timeout occurs. <code class=\"inline\">handle_call/3</code> will be called on the server to handle the request.</p> <p><code class=\"inline\">server</code> can be any of the values described in the “Name registration” section of the documentation for this module.</p> <h4>Timeouts</h4> <p><code class=\"inline\">timeout</code> is an integer greater than zero which specifies how many milliseconds to wait for a reply, or the atom <code class=\"inline\">:infinity</code> to wait indefinitely. The default value is <code class=\"inline\">5000</code>. If no reply is received within the specified time, the function call fails and the caller exits. If the caller catches the failure and continues running, and the server is just late with the reply, it may arrive at any time later into the caller’s message queue. The caller must in this case be prepared for this and discard any such garbage messages that are two-element tuples with a reference as the first element.</p>    <h3 class=\"detail-header function\" id=\"cast/2\">  <span class=\"signature\">cast(server, request)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cast(<a href=\"#t:server/0\">server</a>, term) :: :ok</code></pre>    <p>Sends an asynchronous request to the <code class=\"inline\">server</code>.</p> <p>This function always returns <code class=\"inline\">:ok</code> regardless of whether the destination <code class=\"inline\">server</code> (or node) exists. Therefore it is unknown whether the destination <code class=\"inline\">server</code> successfully handled the message.</p> <p><code class=\"inline\">handle_cast/2</code> will be called on the server to handle the request. In case the <code class=\"inline\">server</code> is on a node which is not yet connected to the caller one, the call is going to block until a connection happens. This is different than the behaviour in OTP’s <code class=\"inline\">:gen_server</code> where the message is sent by another process in this case, which could cause messages to other nodes to arrive out of order.</p>    <h3 class=\"detail-header function\" id=\"multi_call/4\">  <span class=\"signature\">multi_call(nodes \\\\ nodes(), name, request, timeout \\\\ :infinity)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">multi_call([node], name :: atom, term, timeout) :: {replies :: [{node, term}], bad_nodes :: [node]}</code></pre>    <p>Calls all servers locally registered as <code class=\"inline\">name</code> at the specified <code class=\"inline\">nodes</code>.</p> <p>First, the <code class=\"inline\">request</code> is sent to every node in <code class=\"inline\">nodes</code>; then, the caller waits for the replies. This function returns a two-element tuple <code class=\"inline\">{replies,\nbad_nodes}</code> where:</p> <ul> <li>\n<code class=\"inline\">replies</code> - is a list of <code class=\"inline\">{node, reply}</code> tuples where <code class=\"inline\">node</code> is the node that replied and <code class=\"inline\">reply</code> is its reply </li> <li>\n<code class=\"inline\">bad_nodes</code> - is a list of nodes that either did not exist or where a server with the given <code class=\"inline\">name</code> did not exist or did not reply </li> </ul> <p><code class=\"inline\">nodes</code> is a list of node names to which the request is sent. The default value is the list of all known nodes (including this node).</p> <p>To avoid that late answers (after the timeout) pollute the caller’s message queue, a middleman process is used to do the actual calls. Late answers will then be discarded when they arrive to a terminated process.</p> <h4>Examples</h4> <p>Assuming the <code class=\"inline\">Stack</code> GenServer mentioned in the docs for the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> module is registered as <code class=\"inline\">Stack</code> in the <code class=\"inline\">:\"foo@my-machine\"</code> and <code class=\"inline\">:\"bar@my-machine\"</code> nodes:</p> <pre data-language=\"elixir\"><code class=\"elixir\">GenServer.multi_call(Stack, :pop)\n#=&gt; {[{:\"foo@my-machine\", :hello}, {:\"bar@my-machine\", :world}], []}</code></pre>    <h3 class=\"detail-header function\" id=\"reply/2\">  <span class=\"signature\">reply(client, reply)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reply(<a href=\"#t:from/0\">from</a>, term) :: :ok</code></pre>    <p>Replies to a client.</p> <p>This function can be used to explicitely send a reply to a client that called <a href=\"#call/3\"><code class=\"inline\">call/3</code></a> or <a href=\"#multi_call/4\"><code class=\"inline\">multi_call/4</code></a> when the reply cannot be specified in the return value of <code class=\"inline\">handle_call/3</code>.</p> <p><code class=\"inline\">client</code> must be the <code class=\"inline\">from</code> argument (the second argument) accepted by <code class=\"inline\">handle_call/3</code> callbacks. <code class=\"inline\">reply</code> is an arbitrary term which will be given back to the client as the return value of the call.</p> <p>Note that <a href=\"#reply/2\"><code class=\"inline\">reply/2</code></a> can be called from any process, not just the GenServer that originally received the call (as long as that GenServer communicated the <code class=\"inline\">from</code> argument somehow).</p> <p>This function always returns <code class=\"inline\">:ok</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">def handle_call(:reply_in_one_second, from, state) do\n  Process.send_after(self(), {:reply, from}, 1_000)\n  {:noreply, state}\nend\n\ndef handle_info({:reply, from}, state) do\n  GenServer.reply(from, :one_second_has_passed)\nend</code></pre>    <h3 class=\"detail-header function\" id=\"start/3\">  <span class=\"signature\">start(module, args, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start(module, any, <a href=\"#t:options/0\">options</a>) :: <a href=\"#t:on_start/0\">on_start</a></code></pre>    <p>Starts a <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> process without links (outside of a supervision tree).</p> <p>See <a href=\"#start_link/3\"><code class=\"inline\">start_link/3</code></a> for more information.</p>    <h3 class=\"detail-header function\" id=\"start_link/3\">  <span class=\"signature\">start_link(module, args, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_link(module, any, <a href=\"#t:options/0\">options</a>) :: <a href=\"#t:on_start/0\">on_start</a></code></pre>    <p>Starts a <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> process linked to the current process.</p> <p>This is often used to start the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> as part of a supervision tree.</p> <p>Once the server is started, the <code class=\"inline\">init/1</code> function of the given <code class=\"inline\">module</code> is called with <code class=\"inline\">args</code> as its arguments to initialize the server. To ensure a synchronized start-up procedure, this function does not return until <code class=\"inline\">init/1</code> has returned.</p> <p>Note that a <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> started with <a href=\"#start_link/3\"><code class=\"inline\">start_link/3</code></a> is linked to the parent process and will exit in case of crashes from the parent. The GenServer will also exit due to the <code class=\"inline\">:normal</code> reasons in case it is configured to trap exits in the <code class=\"inline\">init/1</code> callback.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:name</code> - used for name registration as described in the “Name registration” section of the module documentation</p> </li> <li>\n<p><code class=\"inline\">:timeout</code> - if present, the server is allowed to spend the given amount of milliseconds initializing or it will be terminated and the start function will return <code class=\"inline\">{:error, :timeout}</code></p> </li> <li>\n<p><code class=\"inline\">:debug</code> - if present, the corresponding function in the <a href=\"http://www.erlang.org/doc/man/sys.html\"><code class=\"inline\">:sys</code> module</a> is invoked</p> </li> <li>\n<code class=\"inline\">:spawn_opt</code> - if present, its value is passed as options to the underlying process as in <a href=\"process#spawn/4\"><code class=\"inline\">Process.spawn/4</code></a> </li> </ul> <h4>Return values</h4> <p>If the server is successfully created and initialized, this function returns <code class=\"inline\">{:ok, pid}</code>, where <code class=\"inline\">pid</code> is the pid of the server. If a process with the specified server name already exists, this function returns <code class=\"inline\">{:error, {:already_started, pid}}</code> with the pid of that process.</p> <p>If the <code class=\"inline\">init/1</code> callback fails with <code class=\"inline\">reason</code>, this function returns <code class=\"inline\">{:error, reason}</code>. Otherwise, if it returns <code class=\"inline\">{:stop, reason}</code> or <code class=\"inline\">:ignore</code>, the process is terminated and this function returns <code class=\"inline\">{:error, reason}</code> or <code class=\"inline\">:ignore</code>, respectively.</p>    <h3 class=\"detail-header function\" id=\"stop/3\">  <span class=\"signature\">stop(server, reason \\\\ :normal, timeout \\\\ :infinity)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stop(<a href=\"#t:server/0\">server</a>, reason :: term, timeout) :: :ok</code></pre>    <p>Stops the server with the given <code class=\"inline\">reason</code>.</p> <p>The <code class=\"inline\">terminate/2</code> callback of the given <code class=\"inline\">server</code> will be invoked before exiting. This function returns <code class=\"inline\">:ok</code> if the server terminates with the given reason; if it terminates with another reason, the call exits.</p> <p>This function keeps OTP semantics regarding error reporting. If the reason is any other than <code class=\"inline\">:normal</code>, <code class=\"inline\">:shutdown</code> or <code class=\"inline\">{:shutdown, _}</code>, an error report is logged.</p>    <h3 class=\"detail-header function\" id=\"whereis/1\">  <span class=\"signature\">whereis(pid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">whereis(<a href=\"#t:server/0\">server</a>) :: pid | {atom, node} | nil</code></pre>    <p>Returns the <code class=\"inline\">pid</code> or <code class=\"inline\">{name, node}</code> of a GenServer process, or <code class=\"inline\">nil</code> if no process is associated with the given name.</p> <h4>Examples</h4> <p>For example, to lookup a server process, monitor it and send a cast to it:</p> <pre data-language=\"elixir\"><code class=\"elixir\">process = GenServer.whereis(server)\nmonitor = Process.monitor(process)\nGenServer.cast(process, :hello)</code></pre>     <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:code_change/3\">  <span class=\"signature\">code_change(old_vsn, state, extra)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">code_change(old_vsn, state :: term, extra :: term) ::\n  {:ok, new_state :: term} |\n  {:error, reason :: term} when old_vsn: term | {:down, term}</code></pre>    <p>Invoked to change the state of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> when a different version of a module is loaded (hot code swapping) and the state’s term structure should be changed.</p> <p><code class=\"inline\">old_vsn</code> is the previous version of the module (defined by the <code class=\"inline\">@vsn</code> attribute) when upgrading. When downgrading the previous version is wrapped in a 2-tuple with first element <code class=\"inline\">:down</code>. <code class=\"inline\">state</code> is the current state of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> and <code class=\"inline\">extra</code> is any extra data required to change the state.</p> <p>Returning <code class=\"inline\">{:ok, new_state}</code> changes the state to <code class=\"inline\">new_state</code> and the code change is successful.</p> <p>Returning <code class=\"inline\">{:error, reason}</code> fails the code change with reason <code class=\"inline\">reason</code> and the state remains as the previous state.</p> <p>If <code class=\"inline\">code_change/3</code> raises the code change fails and the loop will continue with its previous state. Therefore this callback does not usually contain side effects.</p>    <h3 class=\"detail-header callback\" id=\"c:format_status/2\">  <span class=\"signature\">format_status(reason, pdict_and_state)</span>  <span class=\"note\">(optional)</span> </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">format_status(reason, pdict_and_state :: list) :: term when reason: :normal | :terminate</code></pre>    <p>Invoked in some cases to retrieve a formatted version of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> status.</p> <p>This callback can be useful to control the <em>appearance</em> of the status of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a>. For example, it can be used to return a compact representation of the <code class=\"inline\">GenServers</code>’s state to avoid having large state terms printed.</p> <ul> <li>\n<p>one of <a href=\"http://www.erlang.org/doc/man/sys.html#get_status-1\"><code class=\"inline\">:sys.get_status/1</code></a> or <a href=\"http://www.erlang.org/doc/man/sys.html#get_status-2\"><code class=\"inline\">:sys.get_status/2</code></a> is invoked to get the status of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a>; in such cases, <code class=\"inline\">reason</code> is <code class=\"inline\">:normal</code></p> </li> <li>the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> terminates abnormally and logs an error; in such cases, <code class=\"inline\">reason</code> is <code class=\"inline\">:terminate</code> </li> </ul> <p><code class=\"inline\">pdict_and_state</code> is a two-elements list <code class=\"inline\">[pdict, state]</code> where <code class=\"inline\">pdict</code> is a list of <code class=\"inline\">{key, value}</code> tuples representing the current process dictionary of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> and <code class=\"inline\">state</code> is the current state of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a>.</p>    <h3 class=\"detail-header callback\" id=\"c:handle_call/3\">  <span class=\"signature\">handle_call(request, from, state)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_call(request :: term, <a href=\"#t:from/0\">from</a>, state :: term) ::\n  {:reply, reply, new_state} |\n  {:reply, reply, new_state, timeout | :hibernate} |\n  {:noreply, new_state} |\n  {:noreply, new_state, timeout | :hibernate} |\n  {:stop, reason, reply, new_state} |\n  {:stop, reason, new_state} when reply: term, new_state: term, reason: term</code></pre>    <p>Invoked to handle synchronous <a href=\"#call/3\"><code class=\"inline\">call/3</code></a> messages. <a href=\"#call/3\"><code class=\"inline\">call/3</code></a> will block until a reply is received (unless the call times out or nodes are disconnected).</p> <p><code class=\"inline\">request</code> is the request message sent by a <a href=\"#call/3\"><code class=\"inline\">call/3</code></a>, <code class=\"inline\">from</code> is a 2-tuple containing the caller’s pid and a term that uniquely identifies the call, and <code class=\"inline\">state</code> is the current state of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a>.</p> <p>Returning <code class=\"inline\">{:reply, reply, new_state}</code> sends the response <code class=\"inline\">reply</code> to the caller and continues the loop with new state <code class=\"inline\">new_state</code>.</p> <p>Returning <code class=\"inline\">{:reply, reply, new_state, timeout}</code> is similar to <code class=\"inline\">{:reply, reply, new_state}</code> except <code class=\"inline\">handle_info(:timeout, new_state)</code> will be called after <code class=\"inline\">timeout</code> milliseconds if no messages are received.</p> <p>Returning <code class=\"inline\">{:reply, reply, new_state, :hibernate}</code> is similar to <code class=\"inline\">{:reply, reply, new_state}</code> except the process is hibernated and will continue the loop once a message is in its message queue. If a message is already in the message queue this will be immediately. Hibernating a <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> causes garbage collection and leaves a continuous heap that minimises the memory used by the process.</p> <p>Hibernating should not be used aggressively as too much time could be spent garbage collecting. Normally it should only be used when a message is not expected soon and minimising the memory of the process is shown to be beneficial.</p> <p>Returning <code class=\"inline\">{:noreply, new_state}</code> does not send a response to the caller and continues the loop with new state <code class=\"inline\">new_state</code>. The response must be sent with <a href=\"#reply/2\"><code class=\"inline\">reply/2</code></a>.</p> <p>There are three main use cases for not replying using the return value:</p> <ul> <li>To reply before returning from the callback because the response is known before calling a slow function. </li> <li>To reply after returning from the callback because the response is not yet available. </li> <li>To reply from another process, such as a task. </li> </ul> <p>When replying from another process the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> should exit if the other process exits without replying as the caller will be blocking awaiting a reply.</p> <p>Returning <code class=\"inline\">{:noreply, new_state, timeout | :hibernate}</code> is similar to <code class=\"inline\">{:noreply, new_state}</code> except a timeout or hibernation occurs as with a <code class=\"inline\">:reply</code> tuple.</p> <p>Returning <code class=\"inline\">{:stop, reason, reply, new_state}</code> stops the loop and <code class=\"inline\">terminate/2</code> is called with reason <code class=\"inline\">reason</code> and state <code class=\"inline\">new_state</code>. Then the <code class=\"inline\">reply</code> is sent as the response to call and the process exits with reason <code class=\"inline\">reason</code>.</p> <p>Returning <code class=\"inline\">{:stop, reason, new_state}</code> is similar to <code class=\"inline\">{:stop, reason, reply, new_state}</code> except a reply is not sent.</p> <p>If this callback is not implemented, the default implementation by <code class=\"inline\">use GenServer</code> will return <code class=\"inline\">{:stop, {:bad_call, request}, state}</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:handle_cast/2\">  <span class=\"signature\">handle_cast(request, state)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_cast(request :: term, state :: term) ::\n  {:noreply, new_state} |\n  {:noreply, new_state, timeout | :hibernate} |\n  {:stop, reason :: term, new_state} when new_state: term</code></pre>    <p>Invoked to handle asynchronous <a href=\"#cast/2\"><code class=\"inline\">cast/2</code></a> messages.</p> <p><code class=\"inline\">request</code> is the request message sent by a <a href=\"#cast/2\"><code class=\"inline\">cast/2</code></a> and <code class=\"inline\">state</code> is the current state of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a>.</p> <p>Returning <code class=\"inline\">{:noreply, new_state}</code> continues the loop with new state <code class=\"inline\">new_state</code>.</p> <p>Returning <code class=\"inline\">{:noreply, new_state, timeout}</code> is similar to <code class=\"inline\">{:noreply, new_state}</code> except <code class=\"inline\">handle_info(:timeout, new_state)</code> will be called after <code class=\"inline\">timeout</code> milliseconds if no messages are received.</p> <p>Returning <code class=\"inline\">{:noreply, new_state, :hibernate}</code> is similar to <code class=\"inline\">{:noreply, new_state}</code> except the process is hibernated before continuing the loop. See <code class=\"inline\">handle_call/3</code> for more information.</p> <p>Returning <code class=\"inline\">{:stop, reason, new_state}</code> stops the loop and <code class=\"inline\">terminate/2</code> is called with the reason <code class=\"inline\">reason</code> and state <code class=\"inline\">new_state</code>. The process exits with reason <code class=\"inline\">reason</code>.</p> <p>If this callback is not implemented, the default implementation by <code class=\"inline\">use GenServer</code> will return <code class=\"inline\">{:stop, {:bad_cast, request}, state}</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:handle_info/2\">  <span class=\"signature\">handle_info(msg, state)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_info(msg :: :timeout | term, state :: term) ::\n  {:noreply, new_state} |\n  {:noreply, new_state, timeout | :hibernate} |\n  {:stop, reason :: term, new_state} when new_state: term</code></pre>    <p>Invoked to handle all other messages.</p> <p><code class=\"inline\">msg</code> is the message and <code class=\"inline\">state</code> is the current state of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a>. When a timeout occurs the message is <code class=\"inline\">:timeout</code>.</p> <p>Return values are the same as <code class=\"inline\">handle_cast/2</code>.</p> <p>If this callback is not implemented, the default implementation by <code class=\"inline\">use GenServer</code> will return <code class=\"inline\">{:noreply, state}</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:init/1\">  <span class=\"signature\">init(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">init(args :: term) ::\n  {:ok, state} |\n  {:ok, state, timeout | :hibernate} |\n  :ignore |\n  {:stop, reason :: any} when state: any</code></pre>    <p>Invoked when the server is started. <a href=\"#start_link/3\"><code class=\"inline\">start_link/3</code></a> (or <a href=\"#start/3)\"><code class=\"inline\">start/3</code></a> will block until it returns.</p> <p><code class=\"inline\">args</code> is the argument term (second argument) passed to <a href=\"#start_link/3\"><code class=\"inline\">start_link/3</code></a>.</p> <p>Returning <code class=\"inline\">{:ok, state}</code> will cause <a href=\"#start_link/3\"><code class=\"inline\">start_link/3</code></a> to return <code class=\"inline\">{:ok, pid}</code> and the process to enter its loop.</p> <p>Returning <code class=\"inline\">{:ok, state, timeout}</code> is similar to <code class=\"inline\">{:ok, state}</code> except <code class=\"inline\">handle_info(:timeout, state)</code> will be called after <code class=\"inline\">timeout</code> milliseconds if no messages are received within the timeout.</p> <p>Returning <code class=\"inline\">{:ok, state, :hibernate}</code> is similar to <code class=\"inline\">{:ok, state}</code> except the process is hibernated before entering the loop. See <code class=\"inline\">handle_call/3</code> for more information on hibernation.</p> <p>Returning <code class=\"inline\">:ignore</code> will cause <a href=\"#start_link/3\"><code class=\"inline\">start_link/3</code></a> to return <code class=\"inline\">:ignore</code> and the process will exit normally without entering the loop or calling <code class=\"inline\">terminate/2</code>. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a>. The remainder of the supervision tree will be (re)started and so the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> should not be required by other processes. It can be started later with <a href=\"supervisor#restart_child/2\"><code class=\"inline\">Supervisor.restart_child/2</code></a> as the child specification is saved in the parent supervisor. The main use cases for this are:</p> <ul> <li>The <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> is disabled by configuration but might be enabled later. </li> <li>An error occurred and it will be handled by a different mechanism than the <a href=\"supervisor\"><code class=\"inline\">Supervisor</code></a>. Likely this approach involves calling <a href=\"supervisor#restart_child/2\"><code class=\"inline\">Supervisor.restart_child/2</code></a> after a delay to attempt a restart. </li> </ul> <p>Returning <code class=\"inline\">{:stop, reason}</code> will cause <a href=\"#start_link/3\"><code class=\"inline\">start_link/3</code></a> to return <code class=\"inline\">{:error, reason}</code> and the process to exit with reason <code class=\"inline\">reason</code> without entering the loop or calling <code class=\"inline\">terminate/2</code>.</p>    <h3 class=\"detail-header callback\" id=\"c:terminate/2\">  <span class=\"signature\">terminate(reason, state)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">terminate(reason, state :: term) :: term when reason: :normal | :shutdown | {:shutdown, term} | term</code></pre>    <p>Invoked when the server is about to exit. It should do any cleanup required.</p> <p><code class=\"inline\">reason</code> is exit reason and <code class=\"inline\">state</code> is the current state of the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a>. The return value is ignored.</p> <p><code class=\"inline\">terminate/2</code> is called if a callback (except <code class=\"inline\">init/1</code>) returns a <code class=\"inline\">:stop</code> tuple, raises, calls <a href=\"kernel#exit/1\"><code class=\"inline\">Kernel.exit/1</code></a> or returns an invalid value. It may also be called if the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> traps exits using <a href=\"process#flag/2\"><code class=\"inline\">Process.flag/2</code></a> <em>and</em> the parent process sends an exit signal.</p> <p>If part of a supervision tree a <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a>’s <a href=\"supervisor\"><code class=\"inline\">Supervisor</code></a> will send an exit signal when shutting it down. The exit signal is based on the shutdown strategy in the child’s specification. If it is <code class=\"inline\">:brutal_kill</code> the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> is killed and so <code class=\"inline\">terminate/2</code> is not called. However if it is a timeout the <a href=\"supervisor\"><code class=\"inline\">Supervisor</code></a> will send the exit signal <code class=\"inline\">:shutdown</code> and the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> will have the duration of the timeout to call <code class=\"inline\">terminate/2</code> - if the process is still alive after the timeout it is killed.</p> <p>If the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> receives an exit signal (that is not <code class=\"inline\">:normal</code>) from any process when it is not trapping exits it will exit abruptly with the same reason and so not call <code class=\"inline\">terminate/2</code>. Note that a process does <em>NOT</em> trap exits by default and an exit signal is sent when a linked process exits or its node is disconnected.</p> <p>Therefore it is not guaranteed that <code class=\"inline\">terminate/2</code> is called when a <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> exits. For such reasons, we usually recommend important clean-up rules to happen in separated processes either by use of monitoring or by links themselves. For example if the <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a> controls a <code class=\"inline\">port</code> (e.g. <code class=\"inline\">:gen_tcp.socket</code>) or <code class=\"inline\">File.io_device</code>, they will be closed on receiving a <a href=\"genserver#content\"><code class=\"inline\">GenServer</code></a>’s exit signal and do not need to be closed in <code class=\"inline\">terminate/2</code>.</p> <p>If <code class=\"inline\">reason</code> is not <code class=\"inline\">:normal</code>, <code class=\"inline\">:shutdown</code> nor <code class=\"inline\">{:shutdown, term}</code> an error is logged.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/GenServer.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/GenServer.html</a>\n  </p>\n</div>\n","elixir/io.ansi":"<h1>  IO.ANSI  </h1>  <p>Functionality to render ANSI escape sequences.</p> <p><a href=\"https://en.wikipedia.org/wiki/ANSI_escape_code\">ANSI escape sequences</a> are characters embedded in text used to control formatting, color, and other output options on video text terminals.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:ansidata/0\">ansidata()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#black/0\">black()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets foreground color to black</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#black_background/0\">black_background()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets background color to black</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#blink_off/0\">blink_off()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Blink: off</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#blink_rapid/0\">blink_rapid()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Blink: Rapid. MS-DOS ANSI.SYS; 150 per minute or more; not widely supported</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#blink_slow/0\">blink_slow()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Blink: Slow. Less than 150 per minute</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#blue/0\">blue()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets foreground color to blue</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#blue_background/0\">blue_background()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets background color to blue</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#bright/0\">bright()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Bright (increased intensity) or Bold</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#clear/0\">clear()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Clears screen</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#clear_line/0\">clear_line()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Clears line</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#color/1\">color(code)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets foreground color</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#color/3\">color(r, g, b)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets the foreground color from individual RGB values</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#color_background/1\">color_background(code)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets background color</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#color_background/3\">color_background(r, g, b)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets the background color from individual RGB values</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#conceal/0\">conceal()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Conceal. Not widely supported</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#crossed_out/0\">crossed_out()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Crossed-out. Characters legible, but marked for deletion. Not widely supported</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cyan/0\">cyan()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets foreground color to cyan</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cyan_background/0\">cyan_background()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets background color to cyan</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#default_background/0\">default_background()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Default background color</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#default_color/0\">default_color()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Default text color</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#enabled?/0\">enabled?()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if ANSI coloring is supported and enabled on this machine</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#encircled/0\">encircled()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Encircled</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#faint/0\">faint()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Faint (decreased intensity), not widely supported</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#font_1/0\">font_1()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets alternative font 1</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#font_2/0\">font_2()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets alternative font 2</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#font_3/0\">font_3()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets alternative font 3</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#font_4/0\">font_4()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets alternative font 4</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#font_5/0\">font_5()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets alternative font 5</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#font_6/0\">font_6()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets alternative font 6</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#font_7/0\">font_7()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets alternative font 7</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#font_8/0\">font_8()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets alternative font 8</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#font_9/0\">font_9()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets alternative font 9</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format/2\">format(chardata, emit? \\\\ enabled?)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Formats a chardata-like argument by converting named ANSI sequences into actual ANSI codes</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format_fragment/2\">format_fragment(chardata, emit? \\\\ enabled?)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Formats a chardata-like argument by converting named ANSI sequences into actual ANSI codes</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#framed/0\">framed()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Framed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#green/0\">green()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets foreground color to green</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#green_background/0\">green_background()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets background color to green</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#home/0\">home()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends cursor home</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#inverse/0\">inverse()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Image: Negative. Swap foreground and background</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#italic/0\">italic()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Italic: on. Not widely supported. Sometimes treated as inverse</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#magenta/0\">magenta()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets foreground color to magenta</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#magenta_background/0\">magenta_background()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets background color to magenta</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#no_underline/0\">no_underline()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Underline: None</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#normal/0\">normal()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Normal color or intensity</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#not_framed_encircled/0\">not_framed_encircled()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Not framed or encircled</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#not_italic/0\">not_italic()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Not italic</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#not_overlined/0\">not_overlined()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Not overlined</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#overlined/0\">overlined()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Overlined</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#primary_font/0\">primary_font()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets primary (default) font</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#red/0\">red()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets foreground color to red</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#red_background/0\">red_background()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets background color to red</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reset/0\">reset()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Resets all attributes</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reverse/0\">reverse()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Image: Negative. Swap foreground and background</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#underline/0\">underline()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Underline: Single</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#white/0\">white()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets foreground color to white</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#white_background/0\">white_background()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets background color to white</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#yellow/0\">yellow()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets foreground color to yellow</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#yellow_background/0\">yellow_background()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets background color to yellow</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:ansidata/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:ansidata/0\">ansidata</a> :: ansilist | ansicode | binary</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"black/0\">  <span class=\"signature\">black()</span>  </h3>  <p>Sets foreground color to black</p>    <h3 class=\"detail-header function\" id=\"black_background/0\">  <span class=\"signature\">black_background()</span>  </h3>  <p>Sets background color to black</p>    <h3 class=\"detail-header function\" id=\"blink_off/0\">  <span class=\"signature\">blink_off()</span>  </h3>  <p>Blink: off</p>    <h3 class=\"detail-header function\" id=\"blink_rapid/0\">  <span class=\"signature\">blink_rapid()</span>  </h3>  <p>Blink: Rapid. MS-DOS ANSI.SYS; 150 per minute or more; not widely supported</p>    <h3 class=\"detail-header function\" id=\"blink_slow/0\">  <span class=\"signature\">blink_slow()</span>  </h3>  <p>Blink: Slow. Less than 150 per minute</p>    <h3 class=\"detail-header function\" id=\"blue/0\">  <span class=\"signature\">blue()</span>  </h3>  <p>Sets foreground color to blue</p>    <h3 class=\"detail-header function\" id=\"blue_background/0\">  <span class=\"signature\">blue_background()</span>  </h3>  <p>Sets background color to blue</p>    <h3 class=\"detail-header function\" id=\"bright/0\">  <span class=\"signature\">bright()</span>  </h3>  <p>Bright (increased intensity) or Bold</p>    <h3 class=\"detail-header function\" id=\"clear/0\">  <span class=\"signature\">clear()</span>  </h3>  <p>Clears screen</p>    <h3 class=\"detail-header function\" id=\"clear_line/0\">  <span class=\"signature\">clear_line()</span>  </h3>  <p>Clears line</p>    <h3 class=\"detail-header function\" id=\"color/1\">  <span class=\"signature\">color(code)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">color(0..255) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Sets foreground color</p>    <h3 class=\"detail-header function\" id=\"color/3\">  <span class=\"signature\">color(r, g, b)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">color(0..5, 0..5, 0..5) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Sets the foreground color from individual RGB values.</p> <p>Valid values for each color are in the range 0 to 5.</p>    <h3 class=\"detail-header function\" id=\"color_background/1\">  <span class=\"signature\">color_background(code)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">color_background(0..255) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Sets background color</p>    <h3 class=\"detail-header function\" id=\"color_background/3\">  <span class=\"signature\">color_background(r, g, b)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">color_background(0..5, 0..5, 0..5) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Sets the background color from individual RGB values.</p> <p>Valid values for each color are in the range 0 to 5.</p>    <h3 class=\"detail-header function\" id=\"conceal/0\">  <span class=\"signature\">conceal()</span>  </h3>  <p>Conceal. Not widely supported</p>    <h3 class=\"detail-header function\" id=\"crossed_out/0\">  <span class=\"signature\">crossed_out()</span>  </h3>  <p>Crossed-out. Characters legible, but marked for deletion. Not widely supported</p>    <h3 class=\"detail-header function\" id=\"cyan/0\">  <span class=\"signature\">cyan()</span>  </h3>  <p>Sets foreground color to cyan</p>    <h3 class=\"detail-header function\" id=\"cyan_background/0\">  <span class=\"signature\">cyan_background()</span>  </h3>  <p>Sets background color to cyan</p>    <h3 class=\"detail-header function\" id=\"default_background/0\">  <span class=\"signature\">default_background()</span>  </h3>  <p>Default background color</p>    <h3 class=\"detail-header function\" id=\"default_color/0\">  <span class=\"signature\">default_color()</span>  </h3>  <p>Default text color</p>    <h3 class=\"detail-header function\" id=\"enabled?/0\">  <span class=\"signature\">enabled?()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">enabled? :: boolean</code></pre>    <p>Checks if ANSI coloring is supported and enabled on this machine.</p> <p>This function simply reads the configuration value for <code class=\"inline\">:ansi_enabled</code> in the <code class=\"inline\">:elixir</code> application. The value is by default <code class=\"inline\">false</code> unless Elixir can detect during startup that both <code class=\"inline\">stdout</code> and <code class=\"inline\">stderr</code> are terminals.</p>    <h3 class=\"detail-header function\" id=\"encircled/0\">  <span class=\"signature\">encircled()</span>  </h3>  <p>Encircled</p>    <h3 class=\"detail-header function\" id=\"faint/0\">  <span class=\"signature\">faint()</span>  </h3>  <p>Faint (decreased intensity), not widely supported</p>    <h3 class=\"detail-header function\" id=\"font_1/0\">  <span class=\"signature\">font_1()</span>  </h3>  <p>Sets alternative font 1</p>    <h3 class=\"detail-header function\" id=\"font_2/0\">  <span class=\"signature\">font_2()</span>  </h3>  <p>Sets alternative font 2</p>    <h3 class=\"detail-header function\" id=\"font_3/0\">  <span class=\"signature\">font_3()</span>  </h3>  <p>Sets alternative font 3</p>    <h3 class=\"detail-header function\" id=\"font_4/0\">  <span class=\"signature\">font_4()</span>  </h3>  <p>Sets alternative font 4</p>    <h3 class=\"detail-header function\" id=\"font_5/0\">  <span class=\"signature\">font_5()</span>  </h3>  <p>Sets alternative font 5</p>    <h3 class=\"detail-header function\" id=\"font_6/0\">  <span class=\"signature\">font_6()</span>  </h3>  <p>Sets alternative font 6</p>    <h3 class=\"detail-header function\" id=\"font_7/0\">  <span class=\"signature\">font_7()</span>  </h3>  <p>Sets alternative font 7</p>    <h3 class=\"detail-header function\" id=\"font_8/0\">  <span class=\"signature\">font_8()</span>  </h3>  <p>Sets alternative font 8</p>    <h3 class=\"detail-header function\" id=\"font_9/0\">  <span class=\"signature\">font_9()</span>  </h3>  <p>Sets alternative font 9</p>    <h3 class=\"detail-header function\" id=\"format/2\">  <span class=\"signature\">format(chardata, emit? \\\\ enabled?)</span>  </h3>  <p>Formats a chardata-like argument by converting named ANSI sequences into actual ANSI codes.</p> <p>The named sequences are represented by atoms.</p> <p>It will also append an <a href=\"io.ansi#reset/0\"><code class=\"inline\">IO.ANSI.reset/0</code></a> to the chardata when a conversion is performed. If you don’t want this behaviour, use <a href=\"#format_fragment/2\"><code class=\"inline\">format_fragment/2</code></a>.</p> <p>An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When <code class=\"inline\">false</code>, no ANSI codes will emitted. By default checks if ANSI is enabled using the <a href=\"#enabled?/0\"><code class=\"inline\">enabled?/0</code></a> function.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; IO.ANSI.format([\"Hello, \", :red, :bright, \"world!\"], true)\n[[[[[[], \"Hello, \"] | \"\\e[31m\"] | \"\\e[1m\"], \"world!\"] | \"\\e[0m\"]</code></pre>    <h3 class=\"detail-header function\" id=\"format_fragment/2\">  <span class=\"signature\">format_fragment(chardata, emit? \\\\ enabled?)</span>  </h3>  <p>Formats a chardata-like argument by converting named ANSI sequences into actual ANSI codes.</p> <p>The named sequences are represented by atoms.</p> <p>An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When <code class=\"inline\">false</code>, no ANSI codes will emitted. By default checks if ANSI is enabled using the <a href=\"#enabled?/0\"><code class=\"inline\">enabled?/0</code></a> function.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; IO.ANSI.format_fragment([:bright, 'Word'], true)\n[[[[[[] | \"\\e[1m\"], 87], 111], 114], 100]</code></pre>    <h3 class=\"detail-header function\" id=\"framed/0\">  <span class=\"signature\">framed()</span>  </h3>  <p>Framed</p>    <h3 class=\"detail-header function\" id=\"green/0\">  <span class=\"signature\">green()</span>  </h3>  <p>Sets foreground color to green</p>    <h3 class=\"detail-header function\" id=\"green_background/0\">  <span class=\"signature\">green_background()</span>  </h3>  <p>Sets background color to green</p>    <h3 class=\"detail-header function\" id=\"home/0\">  <span class=\"signature\">home()</span>  </h3>  <p>Sends cursor home</p>    <h3 class=\"detail-header function\" id=\"inverse/0\">  <span class=\"signature\">inverse()</span>  </h3>  <p>Image: Negative. Swap foreground and background</p>    <h3 class=\"detail-header function\" id=\"italic/0\">  <span class=\"signature\">italic()</span>  </h3>  <p>Italic: on. Not widely supported. Sometimes treated as inverse</p>    <h3 class=\"detail-header function\" id=\"magenta/0\">  <span class=\"signature\">magenta()</span>  </h3>  <p>Sets foreground color to magenta</p>    <h3 class=\"detail-header function\" id=\"magenta_background/0\">  <span class=\"signature\">magenta_background()</span>  </h3>  <p>Sets background color to magenta</p>    <h3 class=\"detail-header function\" id=\"no_underline/0\">  <span class=\"signature\">no_underline()</span>  </h3>  <p>Underline: None</p>    <h3 class=\"detail-header function\" id=\"normal/0\">  <span class=\"signature\">normal()</span>  </h3>  <p>Normal color or intensity</p>    <h3 class=\"detail-header function\" id=\"not_framed_encircled/0\">  <span class=\"signature\">not_framed_encircled()</span>  </h3>  <p>Not framed or encircled</p>    <h3 class=\"detail-header function\" id=\"not_italic/0\">  <span class=\"signature\">not_italic()</span>  </h3>  <p>Not italic</p>    <h3 class=\"detail-header function\" id=\"not_overlined/0\">  <span class=\"signature\">not_overlined()</span>  </h3>  <p>Not overlined</p>    <h3 class=\"detail-header function\" id=\"overlined/0\">  <span class=\"signature\">overlined()</span>  </h3>  <p>Overlined</p>    <h3 class=\"detail-header function\" id=\"primary_font/0\">  <span class=\"signature\">primary_font()</span>  </h3>  <p>Sets primary (default) font</p>    <h3 class=\"detail-header function\" id=\"red/0\">  <span class=\"signature\">red()</span>  </h3>  <p>Sets foreground color to red</p>    <h3 class=\"detail-header function\" id=\"red_background/0\">  <span class=\"signature\">red_background()</span>  </h3>  <p>Sets background color to red</p>    <h3 class=\"detail-header function\" id=\"reset/0\">  <span class=\"signature\">reset()</span>  </h3>  <p>Resets all attributes</p>    <h3 class=\"detail-header function\" id=\"reverse/0\">  <span class=\"signature\">reverse()</span>  </h3>  <p>Image: Negative. Swap foreground and background</p>    <h3 class=\"detail-header function\" id=\"underline/0\">  <span class=\"signature\">underline()</span>  </h3>  <p>Underline: Single</p>    <h3 class=\"detail-header function\" id=\"white/0\">  <span class=\"signature\">white()</span>  </h3>  <p>Sets foreground color to white</p>    <h3 class=\"detail-header function\" id=\"white_background/0\">  <span class=\"signature\">white_background()</span>  </h3>  <p>Sets background color to white</p>    <h3 class=\"detail-header function\" id=\"yellow/0\">  <span class=\"signature\">yellow()</span>  </h3>  <p>Sets foreground color to yellow</p>    <h3 class=\"detail-header function\" id=\"yellow_background/0\">  <span class=\"signature\">yellow_background()</span>  </h3>  <p>Sets background color to yellow</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/IO.ANSI.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/IO.ANSI.html</a>\n  </p>\n</div>\n","elixir/list":"<h1>  List  </h1>  <p>Specialized functions that only work on lists.</p> <p>In general, favor using the <a href=\"enum\"><code class=\"inline\">Enum</code></a> API instead of <a href=\"list#content\"><code class=\"inline\">List</code></a>.</p> <p>Index access for list is linear. Negative indexes are also supported but they imply the list will be iterated twice, one to calculate the proper index and another to perform the operation.</p> <p>A decision was taken to delegate most functions to Erlang’s standard library but follow Elixir’s convention of receiving the subject (in this case, a list) as the first argument.</p> <h2 id=\"module-charlists\" class=\"section-heading\">  Charlists </h2> <p>If a list is made of non-negative integers, it can also be called as a charlist. Elixir uses single quotes to define charlists:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 'héllo'\n[104, 233, 108, 108, 111]</code></pre> <p>In particular, charlists may be printed back in single quotes if they contain only ASCII-printable codepoints:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 'abc'\n'abc'</code></pre> <p>The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings. One example of such functions is <code class=\"inline\">Application.loaded_applications</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Application.loaded_applications\n#=&gt;  [{:stdlib, 'ERTS  CXC 138 10', '2.6'},\n      {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n      {:elixir, 'elixir', '1.0.0'},\n      {:kernel, 'ERTS  CXC 138 10', '4.1'},\n      {:logger, 'logger', '1.0.0'}]</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#delete/2\">delete(list, item)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes the given item from the list. Returns a list without the item. If the item occurs more than once in the list, just the first occurrence is removed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete_at/2\">delete_at(list, index)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Produces a new list by removing the value at the specified <code class=\"inline\">index</code>. Negative indices indicate an offset from the end of the list. If <code class=\"inline\">index</code> is out of bounds, the original <code class=\"inline\">list</code> is returned</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#duplicate/2\">duplicate(elem, n)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Duplicates the given element <code class=\"inline\">n</code> times in a list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#first/1\">first(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the first element in <code class=\"inline\">list</code> or <code class=\"inline\">nil</code> if <code class=\"inline\">list</code> is empty</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#flatten/1\">flatten(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Flattens the given <code class=\"inline\">list</code> of nested lists</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#flatten/2\">flatten(list, tail)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Flattens the given <code class=\"inline\">list</code> of nested lists. The list <code class=\"inline\">tail</code> will be added at the end of the flattened list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#foldl/3\">foldl(list, acc, function)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Folds (reduces) the given list from the left with a function. Requires an accumulator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#foldr/3\">foldr(list, acc, function)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Folds (reduces) the given list from the right with a function. Requires an accumulator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#insert_at/3\">insert_at(list, index, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list with <code class=\"inline\">value</code> inserted at the specified <code class=\"inline\">index</code>. Note that <code class=\"inline\">index</code> is capped at the list length. Negative indices indicate an offset from the end of the list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#keydelete/3\">keydelete(list, key, position)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a list of tuples and deletes the first tuple where the item at <code class=\"inline\">position</code> matches the given <code class=\"inline\">key</code>. Returns the new list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#keyfind/4\">keyfind(list, key, position, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a list of tuples and returns the first tuple where the item at <code class=\"inline\">position</code> in the tuple matches the given <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#keymember?/3\">keymember?(list, key, position)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a list of tuples and returns <code class=\"inline\">true</code> if there is a tuple where the item at <code class=\"inline\">position</code> in the tuple matches the given <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#keyreplace/4\">keyreplace(list, key, position, new_tuple)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a list of tuples and replaces the item identified by <code class=\"inline\">key</code> at <code class=\"inline\">position</code> if it exists</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#keysort/2\">keysort(list, position)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a list of tuples and sorts the items at <code class=\"inline\">position</code> of the tuples. The sort is stable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#keystore/4\">keystore(list, key, position, new_tuple)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a list of tuples and replaces the item identified by <code class=\"inline\">key</code> at <code class=\"inline\">position</code>. If the item does not exist, it is added to the end of the list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#keytake/3\">keytake(list, key, position)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a <code class=\"inline\">list</code> of tuples and returns the first tuple where the element at <code class=\"inline\">position</code> in the tuple matches the given <code class=\"inline\">key</code>, as well as the <code class=\"inline\">list</code> without found tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#last/1\">last(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the last element in <code class=\"inline\">list</code> or <code class=\"inline\">nil</code> if <code class=\"inline\">list</code> is empty</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#replace_at/3\">replace_at(list, index, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list with a replaced value at the specified <code class=\"inline\">index</code>. Negative indices indicate an offset from the end of the list. If <code class=\"inline\">index</code> is out of bounds, the original <code class=\"inline\">list</code> is returned</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_atom/1\">to_atom(charlist)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a charlist to an atom</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_existing_atom/1\">to_existing_atom(charlist)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a charlist to an existing atom. Raises an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> if the atom does not exist</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_float/1\">to_float(charlist)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the float whose text representation is <code class=\"inline\">charlist</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_integer/1\">to_integer(charlist)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an integer whose text representation is <code class=\"inline\">charlist</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_integer/2\">to_integer(charlist, base)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an integer whose text representation is <code class=\"inline\">charlist</code> in base <code class=\"inline\">base</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a list of integers representing codepoints, lists or strings into a string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_tuple/1\">to_tuple(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a list to a tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update_at/3\">update_at(list, index, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list with an updated value at the specified <code class=\"inline\">index</code>. Negative indices indicate an offset from the end of the list. If <code class=\"inline\">index</code> is out of bounds, the original <code class=\"inline\">list</code> is returned</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#wrap/1\">wrap(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Wraps the argument in a list. If the argument is already a list, returns the list. If the argument is <code class=\"inline\">nil</code>, returns an empty list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#zip/1\">zip(list_of_lists)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Zips corresponding elements from each list in <code class=\"inline\">list_of_lists</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"delete/2\">  <span class=\"signature\">delete(list, item)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete(list, any) :: list</code></pre>    <p>Deletes the given item from the list. Returns a list without the item. If the item occurs more than once in the list, just the first occurrence is removed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.delete([1, 2, 3], 1)\n[2, 3]\n\niex&gt; List.delete([1, 2, 2, 3], 2)\n[1, 2, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"delete_at/2\">  <span class=\"signature\">delete_at(list, index)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete_at(list, integer) :: list</code></pre>    <p>Produces a new list by removing the value at the specified <code class=\"inline\">index</code>. Negative indices indicate an offset from the end of the list. If <code class=\"inline\">index</code> is out of bounds, the original <code class=\"inline\">list</code> is returned.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.delete_at([1, 2, 3], 0)\n[2, 3]\n\niex&gt; List.delete_at([1, 2, 3], 10)\n[1, 2, 3]\n\niex&gt; List.delete_at([1, 2, 3], -1)\n[1, 2]</code></pre>    <h3 class=\"detail-header function\" id=\"duplicate/2\">  <span class=\"signature\">duplicate(elem, n)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">duplicate(elem, non_neg_integer) :: [elem] when elem: var</code></pre>    <p>Duplicates the given element <code class=\"inline\">n</code> times in a list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.duplicate(\"hello\", 3)\n[\"hello\", \"hello\", \"hello\"]\n\niex&gt; List.duplicate([1, 2], 2)\n[[1, 2], [1, 2]]</code></pre>    <h3 class=\"detail-header function\" id=\"first/1\">  <span class=\"signature\">first(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">first([elem]) :: nil | elem when elem: var</code></pre>    <p>Returns the first element in <code class=\"inline\">list</code> or <code class=\"inline\">nil</code> if <code class=\"inline\">list</code> is empty.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.first([])\nnil\n\niex&gt; List.first([1])\n1\n\niex&gt; List.first([1, 2, 3])\n1</code></pre>    <h3 class=\"detail-header function\" id=\"flatten/1\">  <span class=\"signature\">flatten(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">flatten(deep_list) :: list when deep_list: [any | deep_list]</code></pre>    <p>Flattens the given <code class=\"inline\">list</code> of nested lists.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.flatten([1, [[2], 3]])\n[1, 2, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"flatten/2\">  <span class=\"signature\">flatten(list, tail)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">flatten(deep_list, [elem]) :: [elem] when deep_list: [elem | deep_list], elem: var</code></pre>    <p>Flattens the given <code class=\"inline\">list</code> of nested lists. The list <code class=\"inline\">tail</code> will be added at the end of the flattened list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.flatten([1, [[2], 3]], [4, 5])\n[1, 2, 3, 4, 5]</code></pre>    <h3 class=\"detail-header function\" id=\"foldl/3\">  <span class=\"signature\">foldl(list, acc, function)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">foldl([elem], acc, (elem, acc -&gt; acc)) :: acc when elem: var, acc: var</code></pre>    <p>Folds (reduces) the given list from the left with a function. Requires an accumulator.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.foldl([5, 5], 10, fn(x, acc) -&gt; x + acc end)\n20\n\niex&gt; List.foldl([1, 2, 3, 4], 0, fn(x, acc) -&gt; x - acc end)\n2</code></pre>    <h3 class=\"detail-header function\" id=\"foldr/3\">  <span class=\"signature\">foldr(list, acc, function)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">foldr([elem], acc, (elem, acc -&gt; acc)) :: acc when elem: var, acc: var</code></pre>    <p>Folds (reduces) the given list from the right with a function. Requires an accumulator.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.foldr([1, 2, 3, 4], 0, fn(x, acc) -&gt; x - acc end)\n-2</code></pre>    <h3 class=\"detail-header function\" id=\"insert_at/3\">  <span class=\"signature\">insert_at(list, index, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">insert_at(list, integer, any) :: list</code></pre>    <p>Returns a list with <code class=\"inline\">value</code> inserted at the specified <code class=\"inline\">index</code>. Note that <code class=\"inline\">index</code> is capped at the list length. Negative indices indicate an offset from the end of the list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.insert_at([1, 2, 3, 4], 2, 0)\n[1, 2, 0, 3, 4]\n\niex&gt; List.insert_at([1, 2, 3], 10, 0)\n[1, 2, 3, 0]\n\niex&gt; List.insert_at([1, 2, 3], -1, 0)\n[1, 2, 3, 0]\n\niex&gt; List.insert_at([1, 2, 3], -10, 0)\n[0, 1, 2, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"keydelete/3\">  <span class=\"signature\">keydelete(list, key, position)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">keydelete([tuple], any, non_neg_integer) :: [tuple]</code></pre>    <p>Receives a list of tuples and deletes the first tuple where the item at <code class=\"inline\">position</code> matches the given <code class=\"inline\">key</code>. Returns the new list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.keydelete([a: 1, b: 2], :a, 0)\n[b: 2]\n\niex&gt; List.keydelete([a: 1, b: 2], 2, 1)\n[a: 1]\n\niex&gt; List.keydelete([a: 1, b: 2], :c, 0)\n[a: 1, b: 2]</code></pre>    <h3 class=\"detail-header function\" id=\"keyfind/4\">  <span class=\"signature\">keyfind(list, key, position, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">keyfind([tuple], any, non_neg_integer, any) :: any</code></pre>    <p>Receives a list of tuples and returns the first tuple where the item at <code class=\"inline\">position</code> in the tuple matches the given <code class=\"inline\">key</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.keyfind([a: 1, b: 2], :a, 0)\n{:a, 1}\n\niex&gt; List.keyfind([a: 1, b: 2], 2, 1)\n{:b, 2}\n\niex&gt; List.keyfind([a: 1, b: 2], :c, 0)\nnil</code></pre>    <h3 class=\"detail-header function\" id=\"keymember?/3\">  <span class=\"signature\">keymember?(list, key, position)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">keymember?([tuple], any, non_neg_integer) :: any</code></pre>    <p>Receives a list of tuples and returns <code class=\"inline\">true</code> if there is a tuple where the item at <code class=\"inline\">position</code> in the tuple matches the given <code class=\"inline\">key</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.keymember?([a: 1, b: 2], :a, 0)\ntrue\n\niex&gt; List.keymember?([a: 1, b: 2], 2, 1)\ntrue\n\niex&gt; List.keymember?([a: 1, b: 2], :c, 0)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"keyreplace/4\">  <span class=\"signature\">keyreplace(list, key, position, new_tuple)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">keyreplace([tuple], any, non_neg_integer, tuple) :: [tuple]</code></pre>    <p>Receives a list of tuples and replaces the item identified by <code class=\"inline\">key</code> at <code class=\"inline\">position</code> if it exists.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n[a: 3, b: 2]</code></pre>    <h3 class=\"detail-header function\" id=\"keysort/2\">  <span class=\"signature\">keysort(list, position)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">keysort([tuple], non_neg_integer) :: [tuple]</code></pre>    <p>Receives a list of tuples and sorts the items at <code class=\"inline\">position</code> of the tuples. The sort is stable.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.keysort([a: 5, b: 1, c: 3], 1)\n[b: 1, c: 3, a: 5]\n\niex&gt; List.keysort([a: 5, c: 1, b: 3], 0)\n[a: 5, b: 3, c: 1]</code></pre>    <h3 class=\"detail-header function\" id=\"keystore/4\">  <span class=\"signature\">keystore(list, key, position, new_tuple)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">keystore([tuple], any, non_neg_integer, tuple) :: [tuple, ...]</code></pre>    <p>Receives a list of tuples and replaces the item identified by <code class=\"inline\">key</code> at <code class=\"inline\">position</code>. If the item does not exist, it is added to the end of the list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n[a: 3, b: 2]\n\niex&gt; List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n[a: 1, b: 2, c: 3]</code></pre>    <h3 class=\"detail-header function\" id=\"keytake/3\">  <span class=\"signature\">keytake(list, key, position)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">keytake([tuple], any, non_neg_integer) ::\n  {tuple, [tuple]} |\n  nil</code></pre>    <p>Receives a <code class=\"inline\">list</code> of tuples and returns the first tuple where the element at <code class=\"inline\">position</code> in the tuple matches the given <code class=\"inline\">key</code>, as well as the <code class=\"inline\">list</code> without found tuple.</p> <p>If such a tuple is not found, <code class=\"inline\">nil</code> will be returned.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.keytake([a: 1, b: 2], :a, 0)\n{{:a, 1}, [b: 2]}\n\niex&gt; List.keytake([a: 1, b: 2], 2, 1)\n{{:b, 2}, [a: 1]}\n\niex&gt; List.keytake([a: 1, b: 2], :c, 0)\nnil</code></pre>    <h3 class=\"detail-header function\" id=\"last/1\">  <span class=\"signature\">last(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">last([elem]) :: nil | elem when elem: var</code></pre>    <p>Returns the last element in <code class=\"inline\">list</code> or <code class=\"inline\">nil</code> if <code class=\"inline\">list</code> is empty.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.last([])\nnil\n\niex&gt; List.last([1])\n1\n\niex&gt; List.last([1, 2, 3])\n3</code></pre>    <h3 class=\"detail-header function\" id=\"replace_at/3\">  <span class=\"signature\">replace_at(list, index, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">replace_at(list, integer, any) :: list</code></pre>    <p>Returns a list with a replaced value at the specified <code class=\"inline\">index</code>. Negative indices indicate an offset from the end of the list. If <code class=\"inline\">index</code> is out of bounds, the original <code class=\"inline\">list</code> is returned.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.replace_at([1, 2, 3], 0, 0)\n[0, 2, 3]\n\niex&gt; List.replace_at([1, 2, 3], 10, 0)\n[1, 2, 3]\n\niex&gt; List.replace_at([1, 2, 3], -1, 0)\n[1, 2, 0]\n\niex&gt; List.replace_at([1, 2, 3], -10, 0)\n[1, 2, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"to_atom/1\">  <span class=\"signature\">to_atom(charlist)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_atom(charlist) :: atom</code></pre>    <p>Converts a charlist to an atom.</p> <p>Currently Elixir does not support conversions from charlists which contains Unicode codepoints greater than 0xFF.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.to_atom('elixir')\n:elixir</code></pre>    <h3 class=\"detail-header function\" id=\"to_existing_atom/1\">  <span class=\"signature\">to_existing_atom(charlist)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_existing_atom(charlist) :: atom</code></pre>    <p>Converts a charlist to an existing atom. Raises an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> if the atom does not exist.</p> <p>Currently Elixir does not support conversions from charlists which contains Unicode codepoints greater than 0xFF.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; _ = :my_atom\niex&gt; List.to_existing_atom('my_atom')\n:my_atom\n\niex&gt; List.to_existing_atom('this_atom_will_never_exist')\n** (ArgumentError) argument error</code></pre>    <h3 class=\"detail-header function\" id=\"to_float/1\">  <span class=\"signature\">to_float(charlist)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_float(charlist) :: float</code></pre>    <p>Returns the float whose text representation is <code class=\"inline\">charlist</code>.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.to_float('2.2017764e+0')\n2.2017764</code></pre>    <h3 class=\"detail-header function\" id=\"to_integer/1\">  <span class=\"signature\">to_integer(charlist)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_integer(charlist) :: integer</code></pre>    <p>Returns an integer whose text representation is <code class=\"inline\">charlist</code>.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.to_integer('123')\n123</code></pre>    <h3 class=\"detail-header function\" id=\"to_integer/2\">  <span class=\"signature\">to_integer(charlist, base)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_integer(charlist, 2..36) :: integer</code></pre>    <p>Returns an integer whose text representation is <code class=\"inline\">charlist</code> in base <code class=\"inline\">base</code>.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.to_integer('3FF', 16)\n1023</code></pre>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_string(:unicode.charlist) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts a list of integers representing codepoints, lists or strings into a string.</p> <p>Notice that this function expects a list of integers representing UTF-8 codepoints. If you have a list of bytes, you must instead use the <a href=\"http://www.erlang.org/doc/man/binary.html\"><code class=\"inline\">:binary</code> module</a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.to_string([0x00E6, 0x00DF])\n\"æß\"\n\niex&gt; List.to_string([0x0061, \"bc\"])\n\"abc\"</code></pre>    <h3 class=\"detail-header function\" id=\"to_tuple/1\">  <span class=\"signature\">to_tuple(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_tuple(list) :: tuple</code></pre>    <p>Converts a list to a tuple.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.to_tuple([:share, [:elixir, 163]])\n{:share, [:elixir, 163]}</code></pre>    <h3 class=\"detail-header function\" id=\"update_at/3\">  <span class=\"signature\">update_at(list, index, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update_at([elem], integer, (elem -&gt; any)) :: list when elem: var</code></pre>    <p>Returns a list with an updated value at the specified <code class=\"inline\">index</code>. Negative indices indicate an offset from the end of the list. If <code class=\"inline\">index</code> is out of bounds, the original <code class=\"inline\">list</code> is returned.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.update_at([1, 2, 3], 0, &amp;(&amp;1 + 10))\n[11, 2, 3]\n\niex&gt; List.update_at([1, 2, 3], 10, &amp;(&amp;1 + 10))\n[1, 2, 3]\n\niex&gt; List.update_at([1, 2, 3], -1, &amp;(&amp;1 + 10))\n[1, 2, 13]\n\niex&gt; List.update_at([1, 2, 3], -10, &amp;(&amp;1 + 10))\n[1, 2, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"wrap/1\">  <span class=\"signature\">wrap(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">wrap(list | any) :: list</code></pre>    <p>Wraps the argument in a list. If the argument is already a list, returns the list. If the argument is <code class=\"inline\">nil</code>, returns an empty list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.wrap(\"hello\")\n[\"hello\"]\n\niex&gt; List.wrap([1, 2, 3])\n[1, 2, 3]\n\niex&gt; List.wrap(nil)\n[]</code></pre>    <h3 class=\"detail-header function\" id=\"zip/1\">  <span class=\"signature\">zip(list_of_lists)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">zip([list]) :: [tuple]</code></pre>    <p>Zips corresponding elements from each list in <code class=\"inline\">list_of_lists</code>.</p> <p>The zipping finishes as soon as any list terminates.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; List.zip([[1, 2], [3, 4], [5, 6]])\n[{1, 3, 5}, {2, 4, 6}]\n\niex&gt; List.zip([[1, 2], [3], [5, 6]])\n[{1, 3, 5}]</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/List.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/List.html</a>\n  </p>\n</div>\n","elixir/mapset":"<h1>  MapSet  </h1>  <p>A set of functions for working with sets.</p> <p>The <a href=\"mapset#content\"><code class=\"inline\">MapSet</code></a> is represented internally as a struct, therefore <code class=\"inline\">%MapSet{}</code> can be used whenever there is a need to match on any <a href=\"mapset#content\"><code class=\"inline\">MapSet</code></a>. Note though the struct fields are private and must not be accessed directly. Instead, use the functions in this module.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t/0\">t()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:value/0\">value()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#delete/2\">delete(set, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes <code class=\"inline\">value</code> from <code class=\"inline\">set</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#difference/2\">difference(map_set1, map_set2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a set that is <code class=\"inline\">set1</code> without the members of <code class=\"inline\">set2</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#disjoint?/2\">disjoint?(map_set1, map_set2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if <code class=\"inline\">set1</code> and <code class=\"inline\">set2</code> have no members in common</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#equal?/2\">equal?(map_set1, map_set2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if two sets are equal</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#intersection/2\">intersection(map_set1, map_set2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a set containing only members that <code class=\"inline\">set1</code> and <code class=\"inline\">set2</code> have in common</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#member?/2\">member?(map_set, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if <code class=\"inline\">set</code> contains <code class=\"inline\">value</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/0\">new()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a new set</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/1\">new(mapset)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a set from an enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/2\">new(enumerable, transform)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a mapset from an enumerable via the transformation function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put/2\">put(set, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts <code class=\"inline\">value</code> into <code class=\"inline\">set</code> if <code class=\"inline\">set</code> doesn’t already contain it</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#size/1\">size(map_set)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the number of elements in <code class=\"inline\">set</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#subset?/2\">subset?(map_set1, map_set2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if <code class=\"inline\">set1</code>’s members are all contained in <code class=\"inline\">set2</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_list/1\">to_list(map_set)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts <code class=\"inline\">set</code> to a list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#union/2\">union(map_set1, map_set2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a set containing all members of <code class=\"inline\">set1</code> and <code class=\"inline\">set2</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a></code></pre> </div> <div id=\"t:value/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:value/0\">value</a> :: term</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"delete/2\">  <span class=\"signature\">delete(set, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete(<a href=\"#t:t/0\">t</a>, <a href=\"#t:value/0\">value</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Deletes <code class=\"inline\">value</code> from <code class=\"inline\">set</code>.</p> <p>Returns a new set which is a copy of <code class=\"inline\">set</code> but without <code class=\"inline\">value</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; set = MapSet.new([1, 2, 3])\niex&gt; MapSet.delete(set, 4)\n#MapSet&lt;[1, 2, 3]&gt;\niex&gt; MapSet.delete(set, 2)\n#MapSet&lt;[1, 3]&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"difference/2\">  <span class=\"signature\">difference(map_set1, map_set2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">difference(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a set that is <code class=\"inline\">set1</code> without the members of <code class=\"inline\">set2</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.difference(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n#MapSet&lt;[1]&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"disjoint?/2\">  <span class=\"signature\">disjoint?(map_set1, map_set2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">disjoint?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: boolean</code></pre>    <p>Checks if <code class=\"inline\">set1</code> and <code class=\"inline\">set2</code> have no members in common.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([3, 4]))\ntrue\niex&gt; MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([2, 3]))\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"equal?/2\">  <span class=\"signature\">equal?(map_set1, map_set2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">equal?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: boolean</code></pre>    <p>Checks if two sets are equal.</p> <p>The comparison between elements must be done using <code class=\"inline\">===</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.equal?(MapSet.new([1, 2]), MapSet.new([2, 1, 1]))\ntrue\niex&gt; MapSet.equal?(MapSet.new([1, 2]), MapSet.new([3, 4]))\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"intersection/2\">  <span class=\"signature\">intersection(map_set1, map_set2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">intersection(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a set containing only members that <code class=\"inline\">set1</code> and <code class=\"inline\">set2</code> have in common.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.intersection(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n#MapSet&lt;[2]&gt;\n\niex&gt; MapSet.intersection(MapSet.new([1, 2]), MapSet.new([3, 4]))\n#MapSet&lt;[]&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"member?/2\">  <span class=\"signature\">member?(map_set, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">member?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:value/0\">value</a>) :: boolean</code></pre>    <p>Checks if <code class=\"inline\">set</code> contains <code class=\"inline\">value</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.member?(MapSet.new([1, 2, 3]), 2)\ntrue\niex&gt; MapSet.member?(MapSet.new([1, 2, 3]), 4)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"new/0\">  <span class=\"signature\">new()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a new set.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.new\n#MapSet&lt;[]&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"new/1\">  <span class=\"signature\">new(mapset)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new(<a href=\"enum#t:t/0\">Enum.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Creates a set from an enumerable.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.new([:b, :a, 3])\n#MapSet&lt;[3, :a, :b]&gt;\niex&gt; MapSet.new([3, 3, 3, 2, 2, 1])\n#MapSet&lt;[1, 2, 3]&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"new/2\">  <span class=\"signature\">new(enumerable, transform)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new(<a href=\"enum#t:t/0\">Enum.t</a>, (term -&gt; term)) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Creates a mapset from an enumerable via the transformation function.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.new([1, 2, 1], fn x -&gt; 2 * x end)\n#MapSet&lt;[2, 4]&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"put/2\">  <span class=\"signature\">put(set, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put(<a href=\"#t:t/0\">t</a>, <a href=\"#t:value/0\">value</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Inserts <code class=\"inline\">value</code> into <code class=\"inline\">set</code> if <code class=\"inline\">set</code> doesn’t already contain it.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.put(MapSet.new([1, 2, 3]), 3)\n#MapSet&lt;[1, 2, 3]&gt;\niex&gt; MapSet.put(MapSet.new([1, 2, 3]), 4)\n#MapSet&lt;[1, 2, 3, 4]&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"size/1\">  <span class=\"signature\">size(map_set)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">size(<a href=\"#t:t/0\">t</a>) :: non_neg_integer</code></pre>    <p>Returns the number of elements in <code class=\"inline\">set</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.size(MapSet.new([1, 2, 3]))\n3</code></pre>    <h3 class=\"detail-header function\" id=\"subset?/2\">  <span class=\"signature\">subset?(map_set1, map_set2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">subset?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: boolean</code></pre>    <p>Checks if <code class=\"inline\">set1</code>’s members are all contained in <code class=\"inline\">set2</code>.</p> <p>This function checks if <code class=\"inline\">set1</code> is a subset of <code class=\"inline\">set2</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.subset?(MapSet.new([1, 2]), MapSet.new([1, 2, 3]))\ntrue\niex&gt; MapSet.subset?(MapSet.new([1, 2, 3]), MapSet.new([1, 2]))\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"to_list/1\">  <span class=\"signature\">to_list(map_set)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_list(<a href=\"#t:t/0\">t</a>) :: list</code></pre>    <p>Converts <code class=\"inline\">set</code> to a list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.to_list(MapSet.new([1, 2, 3]))\n[1, 2, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"union/2\">  <span class=\"signature\">union(map_set1, map_set2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">union(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a set containing all members of <code class=\"inline\">set1</code> and <code class=\"inline\">set2</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; MapSet.union(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n#MapSet&lt;[1, 2, 3, 4]&gt;</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/MapSet.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/MapSet.html</a>\n  </p>\n</div>\n","elixir/file":"<h1>  File  </h1>  <p>This module contains functions to manipulate files.</p> <p>Some of those functions are low-level, allowing the user to interact with files or IO devices, like <a href=\"#open/2\"><code class=\"inline\">open/2</code></a>, <a href=\"#copy/3\"><code class=\"inline\">copy/3</code></a> and others. This module also provides higher level functions that work with filenames and have their naming based on UNIX variants. For example, one can copy a file via <a href=\"#cp/3\"><code class=\"inline\">cp/3</code></a> and remove files and directories recursively via <a href=\"#rm_rf/1\"><code class=\"inline\">rm_rf/1</code></a>.</p> <h2 id=\"module-encoding\" class=\"section-heading\">  Encoding </h2> <p>In order to write and read files, one must use the functions in the <a href=\"io\"><code class=\"inline\">IO</code></a> module. By default, a file is opened in binary mode, which requires the functions <a href=\"io#binread/2\"><code class=\"inline\">IO.binread/2</code></a> and <a href=\"io#binwrite/2\"><code class=\"inline\">IO.binwrite/2</code></a> to interact with the file. A developer may pass <code class=\"inline\">:utf8</code> as an option when opening the file, then the slower <a href=\"io#read/2\"><code class=\"inline\">IO.read/2</code></a> and <a href=\"io#write/2\"><code class=\"inline\">IO.write/2</code></a> functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.</p> <p>Note that filenames when given as charlists in Elixir are always treated as UTF-8. In particular, we expect that the shell and the operating system are configured to use UTF-8 encoding. Binary filenames are considered raw and passed to the OS as is.</p> <h2 id=\"module-api\" class=\"section-heading\">  API </h2> <p>Most of the functions in this module return <code class=\"inline\">:ok</code> or <code class=\"inline\">{:ok, result}</code> in case of success, <code class=\"inline\">{:error, reason}</code> otherwise. Those functions also have a variant that ends with <code class=\"inline\">!</code> which returns the result (instead of the <code class=\"inline\">{:ok, result}</code> tuple) in case of success or raises an exception in case it fails. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">File.read(\"hello.txt\")\n#=&gt; {:ok, \"World\"}\n\nFile.read(\"invalid.txt\")\n#=&gt; {:error, :enoent}\n\nFile.read!(\"hello.txt\")\n#=&gt; \"World\"\n\nFile.read!(\"invalid.txt\")\n#=&gt; raises File.Error</code></pre> <p>In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).</p> <h2 id=\"module-processes-and-raw-files\" class=\"section-heading\">  Processes and raw files </h2> <p>Every time a file is opened, Elixir spawns a new process. Writing to a file is equivalent to sending messages to the process that writes to the file descriptor.</p> <p>This means files can be passed between nodes and message passing guarantees they can write to the same file in a network.</p> <p>However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in <code class=\"inline\">:raw</code> mode. The options <code class=\"inline\">:read_ahead</code> and <code class=\"inline\">:delayed_write</code> are also useful when operating on large files or working with files in tight loops.</p> <p>Check <a href=\"http://www.erlang.org/doc/man/file.html#open-2\"><code class=\"inline\">:file.open/2</code></a> for more information about such options and other performance considerations.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:io_device/0\">io_device()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:mode/0\">mode()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:posix/0\">posix()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:stat_options/0\">stat_options()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#cd/1\">cd(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets the current working directory</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cd!/1\">cd!(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>The same as <a href=\"#cd/1\"><code class=\"inline\">cd/1</code></a>, but raises an exception if it fails</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cd!/2\">cd!(path, function)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Changes the current directory to the given <code class=\"inline\">path</code>, executes the given function and then reverts back to the previous path regardless of whether there is an exception</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chgrp/2\">chgrp(path, gid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Changes the group given by the group id <code class=\"inline\">gid</code> for a given <code class=\"inline\">file</code>. Returns <code class=\"inline\">:ok</code> on success, or <code class=\"inline\">{:error, reason}</code> on failure</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chgrp!/2\">chgrp!(path, gid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#chgrp/2\"><code class=\"inline\">chgrp/2</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chmod/2\">chmod(path, mode)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Changes the <code class=\"inline\">mode</code> for a given <code class=\"inline\">file</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chmod!/2\">chmod!(path, mode)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#chmod/2\"><code class=\"inline\">chmod/2</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chown/2\">chown(path, uid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Changes the owner given by the user id <code class=\"inline\">uid</code> for a given <code class=\"inline\">file</code>. Returns <code class=\"inline\">:ok</code> on success, or <code class=\"inline\">{:error, reason}</code> on failure</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chown!/2\">chown!(path, uid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#chown/2\"><code class=\"inline\">chown/2</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#close/1\">close(io_device)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Closes the file referenced by <code class=\"inline\">io_device</code>. It mostly returns <code class=\"inline\">:ok</code>, except for some severe errors such as out of memory</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#copy/3\">copy(source, destination, bytes_count \\\\ :infinity)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Copies the contents of <code class=\"inline\">source</code> to <code class=\"inline\">destination</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#copy!/3\">copy!(source, destination, bytes_count \\\\ :infinity)</a> </dt> <dd class=\"summary-synopsis\">\n<p>The same as <a href=\"#copy/3\"><code class=\"inline\">copy/3</code></a> but raises an <a href=\"file.copyerror\"><code class=\"inline\">File.CopyError</code></a> if it fails. Returns the <code class=\"inline\">bytes_copied</code> otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cp/3\">cp(source, destination, callback \\\\ fn _, _ -&gt; true end)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Copies the contents in <code class=\"inline\">source</code> to <code class=\"inline\">destination</code> preserving its mode</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cp!/3\">cp!(source, destination, callback \\\\ fn _, _ -&gt; true end)</a> </dt> <dd class=\"summary-synopsis\">\n<p>The same as <a href=\"#cp/3\"><code class=\"inline\">cp/3</code></a>, but raises <a href=\"file.copyerror\"><code class=\"inline\">File.CopyError</code></a> if it fails. Returns <code class=\"inline\">:ok</code> otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cp_r/3\">cp_r(source, destination, callback \\\\ fn _, _ -&gt; true end)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Copies the contents in source to destination</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cp_r!/3\">cp_r!(source, destination, callback \\\\ fn _, _ -&gt; true end)</a> </dt> <dd class=\"summary-synopsis\">\n<p>The same as <a href=\"#cp_r/3\"><code class=\"inline\">cp_r/3</code></a>, but raises <a href=\"file.copyerror\"><code class=\"inline\">File.CopyError</code></a> if it fails. Returns the list of copied files otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cwd/0\">cwd()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the current working directory</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cwd!/0\">cwd!()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The same as <a href=\"#cwd/0\"><code class=\"inline\">cwd/0</code></a>, but raises an exception if it fails</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dir?/1\">dir?(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the path is a directory</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#exists?/1\">exists?(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the given path exists. It can be regular file, directory, socket, symbolic link, named pipe or device file</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ln_s/2\">ln_s(existing, new)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a symbolic link <code class=\"inline\">new</code> to the file or directory <code class=\"inline\">existing</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ls/1\">ls(path \\\\ \".\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the list of files in the given directory</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ls!/1\">ls!(path \\\\ \".\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>The same as <a href=\"#ls/1\"><code class=\"inline\">ls/1</code></a> but raises <a href=\"file.error\"><code class=\"inline\">File.Error</code></a> in case of an error</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#lstat/2\">lstat(path, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns information about the <code class=\"inline\">path</code>. If the file is a symlink, sets the <code class=\"inline\">type</code> to <code class=\"inline\">:symlink</code> and returns a <a href=\"file.stat\"><code class=\"inline\">File.Stat</code></a> struct for the link. For any other file, returns exactly the same values as <a href=\"#stat/2\"><code class=\"inline\">stat/2</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#lstat!/2\">lstat!(path, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#lstat/2\"><code class=\"inline\">lstat/2</code></a> but returns the <a href=\"file.stat\"><code class=\"inline\">File.Stat</code></a> struct directly and throws <a href=\"file.error\"><code class=\"inline\">File.Error</code></a> if an error is returned</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#mkdir/1\">mkdir(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Tries to create the directory <code class=\"inline\">path</code>. Missing parent directories are not created. Returns <code class=\"inline\">:ok</code> if successful, or <code class=\"inline\">{:error, reason}</code> if an error occurs</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#mkdir!/1\">mkdir!(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#mkdir/1\"><code class=\"inline\">mkdir/1</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#mkdir_p/1\">mkdir_p(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Tries to create the directory <code class=\"inline\">path</code>. Missing parent directories are created. Returns <code class=\"inline\">:ok</code> if successful, or <code class=\"inline\">{:error, reason}</code> if an error occurs</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#mkdir_p!/1\">mkdir_p!(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#mkdir_p/1\"><code class=\"inline\">mkdir_p/1</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#open/2\">open(path, modes \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Opens the given <code class=\"inline\">path</code> according to the given list of <code class=\"inline\">modes</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#open/3\">open(path, modes, function)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Similar to <a href=\"#open/2\"><code class=\"inline\">open/2</code></a> but expects a function as its last argument</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#open!/2\">open!(path, modes \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#open/2\"><code class=\"inline\">open/2</code></a> but raises an error if file could not be opened</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#open!/3\">open!(path, modes, function)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#open/3\"><code class=\"inline\">open/3</code></a> but raises an error if file could not be opened</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#read/1\">read(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">{:ok, binary}</code>, where <code class=\"inline\">binary</code> is a binary data object that contains the contents of <code class=\"inline\">path</code>, or <code class=\"inline\">{:error, reason}</code> if an error occurs</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#read!/1\">read!(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a binary with the contents of the given filename or raises <a href=\"file.error\"><code class=\"inline\">File.Error</code></a> if an error occurs</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#regular?/1\">regular?(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the path is a regular file</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rename/2\">rename(source, destination)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Renames the <code class=\"inline\">source</code> file to <code class=\"inline\">destination</code> file. It can be used to move files (and directories) between directories. If moving a file, you must fully specify the <code class=\"inline\">destination</code> filename, it is not sufficient to simply specify its directory</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rm/1\">rm(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Tries to delete the file <code class=\"inline\">path</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rm!/1\">rm!(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#rm/1\"><code class=\"inline\">rm/1</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rm_rf/1\">rm_rf(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes files and directories recursively at the given <code class=\"inline\">path</code>. Symlinks are not followed but simply removed, non-existing files are simply ignored (i.e. doesn’t make this function fail)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rm_rf!/1\">rm_rf!(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#rm_rf/1\"><code class=\"inline\">rm_rf/1</code></a> but raises <a href=\"file.error\"><code class=\"inline\">File.Error</code></a> in case of failures, otherwise the list of files or directories removed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rmdir/1\">rmdir(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Tries to delete the dir at <code class=\"inline\">path</code>. Returns <code class=\"inline\">:ok</code> if successful, or <code class=\"inline\">{:error, reason}</code> if an error occurs</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rmdir!/1\">rmdir!(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#rmdir/1\"><code class=\"inline\">rmdir/1</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stat/2\">stat(path, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns information about the <code class=\"inline\">path</code>. If it exists, it returns a <code class=\"inline\">{:ok, info}</code> tuple, where info is a <a href=\"file.stat\"><code class=\"inline\">File.Stat</code></a> struct. Returns <code class=\"inline\">{:error, reason}</code> with the same reasons as <a href=\"#read/1\"><code class=\"inline\">read/1</code></a> if a failure occurs</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stat!/2\">stat!(path, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#stat/2\"><code class=\"inline\">stat/2</code></a> but returns the <a href=\"file.stat\"><code class=\"inline\">File.Stat</code></a> directly and throws <a href=\"file.error\"><code class=\"inline\">File.Error</code></a> if an error is returned</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stream!/3\">stream!(path, modes \\\\ [], line_or_bytes \\\\ :line)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a <a href=\"file.stream\"><code class=\"inline\">File.Stream</code></a> for the given <code class=\"inline\">path</code> with the given <code class=\"inline\">modes</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#touch/2\">touch(path, time \\\\ :calendar.universal_time())</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates modification time (mtime) and access time (atime) of the given file</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#touch!/2\">touch!(path, time \\\\ :calendar.universal_time())</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#touch/2\"><code class=\"inline\">touch/2</code></a> but raises an exception if it fails</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#write/3\">write(path, content, modes \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Writes <code class=\"inline\">content</code> to the file <code class=\"inline\">path</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#write!/3\">write!(path, content, modes \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#write/3\"><code class=\"inline\">write/3</code></a> but raises an exception if it fails, returns <code class=\"inline\">:ok</code> otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#write_stat/3\">write_stat(path, stat, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Writes the given <a href=\"file.stat\"><code class=\"inline\">File.Stat</code></a> back to the filesystem at the given path. Returns <code class=\"inline\">:ok</code> or <code class=\"inline\">{:error, reason}</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#write_stat!/3\">write_stat!(path, stat, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#write_stat/3\"><code class=\"inline\">write_stat/3</code></a> but raises an exception if it fails. Returns <code class=\"inline\">:ok</code> otherwise</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:io_device/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:io_device/0\">io_device</a> :: :file.io_device</code></pre> </div> <div id=\"t:mode/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:mode/0\">mode</a> ::\n  :append |\n  :binary |\n  :charlist |\n  :compressed |\n  :delayed_write |\n  :exclusive |\n  :raw |\n  :read |\n  :read_ahead |\n  :sync |\n  :utf8 |\n  :write |\n  {:encoding, :latin1 | :unicode | :utf8 | :utf16 | :utf32 | {:utf16, :big | :little} | {:utf32, :big | :little}} |\n  {:read_ahead, pos_integer} |\n  {:delayed_write, non_neg_integer, non_neg_integer}</code></pre> </div> <div id=\"t:posix/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:posix/0\">posix</a> :: :file.posix</code></pre> </div> <div id=\"t:stat_options/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:stat_options/0\">stat_options</a> :: [{:time, :local | :universal | :posix}]</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"cd/1\">  <span class=\"signature\">cd(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cd(<a href=\"path#t:t/0\">Path.t</a>) :: :ok | {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Sets the current working directory.</p> <p>Returns <code class=\"inline\">:ok</code> if successful, <code class=\"inline\">{:error, reason}</code> otherwise.</p>    <h3 class=\"detail-header function\" id=\"cd!/1\">  <span class=\"signature\">cd!(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cd!(<a href=\"path#t:t/0\">Path.t</a>) :: :ok | no_return</code></pre>    <p>The same as <a href=\"#cd/1\"><code class=\"inline\">cd/1</code></a>, but raises an exception if it fails.</p>    <h3 class=\"detail-header function\" id=\"cd!/2\">  <span class=\"signature\">cd!(path, function)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cd!(<a href=\"path#t:t/0\">Path.t</a>, (() -&gt; res)) ::\n  res |\n  no_return when res: var</code></pre>    <p>Changes the current directory to the given <code class=\"inline\">path</code>, executes the given function and then reverts back to the previous path regardless of whether there is an exception.</p> <p>Raises an error if retrieving or changing the current directory fails.</p>    <h3 class=\"detail-header function\" id=\"chgrp/2\">  <span class=\"signature\">chgrp(path, gid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chgrp(<a href=\"path#t:t/0\">Path.t</a>, non_neg_integer) ::\n  :ok |\n  {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Changes the group given by the group id <code class=\"inline\">gid</code> for a given <code class=\"inline\">file</code>. Returns <code class=\"inline\">:ok</code> on success, or <code class=\"inline\">{:error, reason}</code> on failure.</p>    <h3 class=\"detail-header function\" id=\"chgrp!/2\">  <span class=\"signature\">chgrp!(path, gid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chgrp!(<a href=\"path#t:t/0\">Path.t</a>, non_neg_integer) :: :ok | no_return</code></pre>    <p>Same as <a href=\"#chgrp/2\"><code class=\"inline\">chgrp/2</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code>.</p>    <h3 class=\"detail-header function\" id=\"chmod/2\">  <span class=\"signature\">chmod(path, mode)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chmod(<a href=\"path#t:t/0\">Path.t</a>, non_neg_integer) ::\n  :ok |\n  {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Changes the <code class=\"inline\">mode</code> for a given <code class=\"inline\">file</code>.</p> <p>Returns <code class=\"inline\">:ok</code> on success, or <code class=\"inline\">{:error, reason}</code> on failure.</p> <h4>Permissions</h4> <ul> <li>0o400 - read permission: owner </li> <li>0o200 - write permission: owner </li> <li>\n<p>0o100 - execute permission: owner</p> </li> <li>0o040 - read permission: group </li> <li>0o020 - write permission: group </li> <li>\n<p>0o010 - execute permission: group</p> </li> <li>0o004 - read permission: other </li> <li>0o002 - write permission: other </li> <li>0o001 - execute permission: other </li> </ul> <p>For example, setting the mode 0o755 gives it write, read and execute permission to the owner and both read and execute permission to group and others.</p>    <h3 class=\"detail-header function\" id=\"chmod!/2\">  <span class=\"signature\">chmod!(path, mode)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chmod!(<a href=\"path#t:t/0\">Path.t</a>, non_neg_integer) :: :ok | no_return</code></pre>    <p>Same as <a href=\"#chmod/2\"><code class=\"inline\">chmod/2</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code>.</p>    <h3 class=\"detail-header function\" id=\"chown/2\">  <span class=\"signature\">chown(path, uid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chown(<a href=\"path#t:t/0\">Path.t</a>, non_neg_integer) ::\n  :ok |\n  {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Changes the owner given by the user id <code class=\"inline\">uid</code> for a given <code class=\"inline\">file</code>. Returns <code class=\"inline\">:ok</code> on success, or <code class=\"inline\">{:error, reason}</code> on failure.</p>    <h3 class=\"detail-header function\" id=\"chown!/2\">  <span class=\"signature\">chown!(path, uid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chown!(<a href=\"path#t:t/0\">Path.t</a>, non_neg_integer) :: :ok | no_return</code></pre>    <p>Same as <a href=\"#chown/2\"><code class=\"inline\">chown/2</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code>.</p>    <h3 class=\"detail-header function\" id=\"close/1\">  <span class=\"signature\">close(io_device)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">close(<a href=\"#t:io_device/0\">io_device</a>) ::\n  :ok |\n  {:error, <a href=\"#t:posix/0\">posix</a> | :badarg | :terminated}</code></pre>    <p>Closes the file referenced by <code class=\"inline\">io_device</code>. It mostly returns <code class=\"inline\">:ok</code>, except for some severe errors such as out of memory.</p> <p>Note that if the option <code class=\"inline\">:delayed_write</code> was used when opening the file, <a href=\"#close/1\"><code class=\"inline\">close/1</code></a> might return an old write error and not even try to close the file. See <a href=\"#open/2\"><code class=\"inline\">open/2</code></a>.</p>    <h3 class=\"detail-header function\" id=\"copy/3\">  <span class=\"signature\">copy(source, destination, bytes_count \\\\ :infinity)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">copy(<a href=\"path#t:t/0\">Path.t</a> | <a href=\"#t:io_device/0\">io_device</a>, <a href=\"path#t:t/0\">Path.t</a> | <a href=\"#t:io_device/0\">io_device</a>, pos_integer | :infinity) ::\n  {:ok, non_neg_integer} |\n  {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Copies the contents of <code class=\"inline\">source</code> to <code class=\"inline\">destination</code>.</p> <p>Both parameters can be a filename or an IO device opened with <a href=\"#open/2\"><code class=\"inline\">open/2</code></a>. <code class=\"inline\">bytes_count</code> specifies the number of bytes to copy, the default being <code class=\"inline\">:infinity</code>.</p> <p>If file <code class=\"inline\">destination</code> already exists, it is overwritten by the contents in <code class=\"inline\">source</code>.</p> <p>Returns <code class=\"inline\">{:ok, bytes_copied}</code> if successful, <code class=\"inline\">{:error, reason}</code> otherwise.</p> <p>Compared to the <a href=\"#cp/3\"><code class=\"inline\">cp/3</code></a>, this function is more low-level, allowing a copy from device to device limited by a number of bytes. On the other hand, <a href=\"#cp/3\"><code class=\"inline\">cp/3</code></a> performs more extensive checks on both source and destination and it also preserves the file mode after copy.</p> <p>Typical error reasons are the same as in <a href=\"#open/2\"><code class=\"inline\">open/2</code></a>, <a href=\"#read/1\"><code class=\"inline\">read/1</code></a> and <a href=\"#write/3\"><code class=\"inline\">write/3</code></a>.</p>    <h3 class=\"detail-header function\" id=\"copy!/3\">  <span class=\"signature\">copy!(source, destination, bytes_count \\\\ :infinity)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">copy!(<a href=\"path#t:t/0\">Path.t</a> | <a href=\"#t:io_device/0\">io_device</a>, <a href=\"path#t:t/0\">Path.t</a> | <a href=\"#t:io_device/0\">io_device</a>, pos_integer | :infinity) ::\n  non_neg_integer |\n  no_return</code></pre>    <p>The same as <a href=\"#copy/3\"><code class=\"inline\">copy/3</code></a> but raises an <a href=\"file.copyerror\"><code class=\"inline\">File.CopyError</code></a> if it fails. Returns the <code class=\"inline\">bytes_copied</code> otherwise.</p>    <h3 class=\"detail-header function\" id=\"cp/3\">  <span class=\"signature\">cp(source, destination, callback \\\\ fn _, _ -&gt; true end)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cp(<a href=\"path#t:t/0\">Path.t</a>, <a href=\"path#t:t/0\">Path.t</a>, (<a href=\"path#t:t/0\">Path.t</a>, <a href=\"path#t:t/0\">Path.t</a> -&gt; boolean)) ::\n  :ok |\n  {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Copies the contents in <code class=\"inline\">source</code> to <code class=\"inline\">destination</code> preserving its mode.</p> <p>If a file already exists in the destination, it invokes a callback which should return <code class=\"inline\">true</code> if the existing file should be overwritten, <code class=\"inline\">false</code> otherwise. The callback defaults to return <code class=\"inline\">true</code>.</p> <p>The function returns <code class=\"inline\">:ok</code> in case of success, returns <code class=\"inline\">{:error, reason}</code> otherwise.</p> <p>If you want to copy contents from an IO device to another device or do a straight copy from a source to a destination without preserving modes, check <a href=\"#copy/3\"><code class=\"inline\">copy/3</code></a> instead.</p> <p>Note: The command <code class=\"inline\">cp</code> in Unix systems behaves differently depending if <code class=\"inline\">destination</code> is an existing directory or not. We have chosen to explicitly disallow this behaviour. If destination is a directory, an error will be returned.</p>    <h3 class=\"detail-header function\" id=\"cp!/3\">  <span class=\"signature\">cp!(source, destination, callback \\\\ fn _, _ -&gt; true end)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cp!(<a href=\"path#t:t/0\">Path.t</a>, <a href=\"path#t:t/0\">Path.t</a>, (<a href=\"path#t:t/0\">Path.t</a>, <a href=\"path#t:t/0\">Path.t</a> -&gt; boolean)) ::\n  :ok |\n  no_return</code></pre>    <p>The same as <a href=\"#cp/3\"><code class=\"inline\">cp/3</code></a>, but raises <a href=\"file.copyerror\"><code class=\"inline\">File.CopyError</code></a> if it fails. Returns <code class=\"inline\">:ok</code> otherwise.</p>    <h3 class=\"detail-header function\" id=\"cp_r/3\">  <span class=\"signature\">cp_r(source, destination, callback \\\\ fn _, _ -&gt; true end)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cp_r(<a href=\"path#t:t/0\">Path.t</a>, <a href=\"path#t:t/0\">Path.t</a>, (<a href=\"path#t:t/0\">Path.t</a>, <a href=\"path#t:t/0\">Path.t</a> -&gt; boolean)) ::\n  {:ok, [binary]} |\n  {:error, <a href=\"#t:posix/0\">posix</a>, binary}</code></pre>    <p>Copies the contents in source to destination.</p> <p>If the source is a file, it copies <code class=\"inline\">source</code> to <code class=\"inline\">destination</code>. If the source is a directory, it copies the contents inside source into the destination.</p> <p>If a file already exists in the destination, it invokes a callback which should return <code class=\"inline\">true</code> if the existing file should be overwritten, <code class=\"inline\">false</code> otherwise. The callback defaults to return <code class=\"inline\">true</code>.</p> <p>If a directory already exists in the destination where a file is meant to be (or vice versa), this function will fail.</p> <p>This function may fail while copying files, in such cases, it will leave the destination directory in a dirty state, where file which have already been copied won’t be removed.</p> <p>The function returns <code class=\"inline\">{:ok, files_and_directories}</code> in case of success, <code class=\"inline\">files_and_directories</code> lists all files and directories copied in no specific order. It returns <code class=\"inline\">{:error, reason, file}</code> otherwise.</p> <p>Note: The command <code class=\"inline\">cp</code> in Unix systems behaves differently depending if <code class=\"inline\">destination</code> is an existing directory or not. We have chosen to explicitly disallow this behaviour.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Copies file \"a.txt\" to \"b.txt\"\nFile.cp_r \"a.txt\", \"b.txt\"\n\n# Copies all files in \"samples\" to \"tmp\"\nFile.cp_r \"samples\", \"tmp\"\n\n# Same as before, but asks the user how to proceed in case of conflicts\nFile.cp_r \"samples\", \"tmp\", fn(source, destination) -&gt;\n  IO.gets(\"Overwriting #{destination} by #{source}. Type y to confirm. \") == \"y\\n\"\nend</code></pre>    <h3 class=\"detail-header function\" id=\"cp_r!/3\">  <span class=\"signature\">cp_r!(source, destination, callback \\\\ fn _, _ -&gt; true end)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cp_r!(<a href=\"path#t:t/0\">Path.t</a>, <a href=\"path#t:t/0\">Path.t</a>, (<a href=\"path#t:t/0\">Path.t</a>, <a href=\"path#t:t/0\">Path.t</a> -&gt; boolean)) ::\n  [binary] |\n  no_return</code></pre>    <p>The same as <a href=\"#cp_r/3\"><code class=\"inline\">cp_r/3</code></a>, but raises <a href=\"file.copyerror\"><code class=\"inline\">File.CopyError</code></a> if it fails. Returns the list of copied files otherwise.</p>    <h3 class=\"detail-header function\" id=\"cwd/0\">  <span class=\"signature\">cwd()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cwd :: {:ok, binary} | {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Gets the current working directory.</p> <p>In rare circumstances, this function can fail on Unix. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns <code class=\"inline\">{:ok, cwd}</code> in case of success, <code class=\"inline\">{:error, reason}</code> otherwise.</p>    <h3 class=\"detail-header function\" id=\"cwd!/0\">  <span class=\"signature\">cwd!()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cwd! :: binary | no_return</code></pre>    <p>The same as <a href=\"#cwd/0\"><code class=\"inline\">cwd/0</code></a>, but raises an exception if it fails.</p>    <h3 class=\"detail-header function\" id=\"dir?/1\">  <span class=\"signature\">dir?(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">dir?(<a href=\"path#t:t/0\">Path.t</a>) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if the path is a directory.</p>    <h3 class=\"detail-header function\" id=\"exists?/1\">  <span class=\"signature\">exists?(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exists?(<a href=\"path#t:t/0\">Path.t</a>) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if the given path exists. It can be regular file, directory, socket, symbolic link, named pipe or device file.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">File.exists?(\"test/\")\n#=&gt; true\n\nFile.exists?(\"missing.txt\")\n#=&gt; false\n\nFile.exists?(\"/dev/null\")\n#=&gt; true</code></pre>    <h3 class=\"detail-header function\" id=\"ln_s/2\">  <span class=\"signature\">ln_s(existing, new)</span>  </h3>  <p>Creates a symbolic link <code class=\"inline\">new</code> to the file or directory <code class=\"inline\">existing</code>.</p> <p>Returns <code class=\"inline\">:ok</code> if successful, <code class=\"inline\">{:error, reason}</code> otherwise. If the operating system does not support symlinks, returns <code class=\"inline\">{:error, :enotsup}</code>.</p>    <h3 class=\"detail-header function\" id=\"ls/1\">  <span class=\"signature\">ls(path \\\\ \".\")</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">ls(<a href=\"path#t:t/0\">Path.t</a>) :: {:ok, [binary]} | {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Returns the list of files in the given directory.</p> <p>It returns <code class=\"inline\">{:ok, [files]}</code> in case of success, <code class=\"inline\">{:error, reason}</code> otherwise.</p>    <h3 class=\"detail-header function\" id=\"ls!/1\">  <span class=\"signature\">ls!(path \\\\ \".\")</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">ls!(<a href=\"path#t:t/0\">Path.t</a>) :: [binary] | no_return</code></pre>    <p>The same as <a href=\"#ls/1\"><code class=\"inline\">ls/1</code></a> but raises <a href=\"file.error\"><code class=\"inline\">File.Error</code></a> in case of an error.</p>    <h3 class=\"detail-header function\" id=\"lstat/2\">  <span class=\"signature\">lstat(path, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">lstat(<a href=\"path#t:t/0\">Path.t</a>, <a href=\"#t:stat_options/0\">stat_options</a>) ::\n  {:ok, <a href=\"file.stat#t:t/0\">File.Stat.t</a>} |\n  {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Returns information about the <code class=\"inline\">path</code>. If the file is a symlink, sets the <code class=\"inline\">type</code> to <code class=\"inline\">:symlink</code> and returns a <a href=\"file.stat\"><code class=\"inline\">File.Stat</code></a> struct for the link. For any other file, returns exactly the same values as <a href=\"#stat/2\"><code class=\"inline\">stat/2</code></a>.</p> <p>For more details, see <a href=\"http://www.erlang.org/doc/man/file.html#read_link_info-2\"><code class=\"inline\">:file.read_link_info/2</code></a>.</p> <h4>Options</h4> <p>The accepted options are:</p> <ul> <li>\n<code class=\"inline\">:time</code> - configures how the file timestamps are returned </li> </ul> <p>The values for <code class=\"inline\">:time</code> can be:</p> <ul> <li>\n<code class=\"inline\">:universal</code> - returns a <code class=\"inline\">{date, time}</code> tuple in UTC (default) </li> <li>\n<code class=\"inline\">:local</code> - returns a <code class=\"inline\">{date, time}</code> tuple using the machine time </li> <li>\n<code class=\"inline\">:posix</code> - returns the time as integer seconds since epoch </li> </ul>    <h3 class=\"detail-header function\" id=\"lstat!/2\">  <span class=\"signature\">lstat!(path, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">lstat!(<a href=\"path#t:t/0\">Path.t</a>, <a href=\"#t:stat_options/0\">stat_options</a>) ::\n  <a href=\"file.stat#t:t/0\">File.Stat.t</a> |\n  no_return</code></pre>    <p>Same as <a href=\"#lstat/2\"><code class=\"inline\">lstat/2</code></a> but returns the <a href=\"file.stat\"><code class=\"inline\">File.Stat</code></a> struct directly and throws <a href=\"file.error\"><code class=\"inline\">File.Error</code></a> if an error is returned.</p>    <h3 class=\"detail-header function\" id=\"mkdir/1\">  <span class=\"signature\">mkdir(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">mkdir(<a href=\"path#t:t/0\">Path.t</a>) :: :ok | {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Tries to create the directory <code class=\"inline\">path</code>. Missing parent directories are not created. Returns <code class=\"inline\">:ok</code> if successful, or <code class=\"inline\">{:error, reason}</code> if an error occurs.</p> <p>Typical error reasons are:</p> <ul> <li>\n<code class=\"inline\">:eacces</code> - missing search or write permissions for the parent directories of <code class=\"inline\">path</code> </li> <li>\n<code class=\"inline\">:eexist</code> - there is already a file or directory named <code class=\"inline\">path</code> </li> <li>\n<code class=\"inline\">:enoent</code> - a component of <code class=\"inline\">path</code> does not exist </li> <li>\n<code class=\"inline\">:enospc</code> - there is a no space left on the device </li> <li>\n<code class=\"inline\">:enotdir</code> - a component of <code class=\"inline\">path</code> is not a directory; on some platforms, <code class=\"inline\">:enoent</code> is returned instead </li> </ul>    <h3 class=\"detail-header function\" id=\"mkdir!/1\">  <span class=\"signature\">mkdir!(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">mkdir!(<a href=\"path#t:t/0\">Path.t</a>) :: :ok | no_return</code></pre>    <p>Same as <a href=\"#mkdir/1\"><code class=\"inline\">mkdir/1</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code>.</p>    <h3 class=\"detail-header function\" id=\"mkdir_p/1\">  <span class=\"signature\">mkdir_p(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">mkdir_p(<a href=\"path#t:t/0\">Path.t</a>) :: :ok | {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Tries to create the directory <code class=\"inline\">path</code>. Missing parent directories are created. Returns <code class=\"inline\">:ok</code> if successful, or <code class=\"inline\">{:error, reason}</code> if an error occurs.</p> <p>Typical error reasons are:</p> <ul> <li>\n<code class=\"inline\">:eacces</code> - missing search or write permissions for the parent directories of <code class=\"inline\">path</code> </li> <li>\n<code class=\"inline\">:enospc</code> - there is a no space left on the device </li> <li>\n<code class=\"inline\">:enotdir</code> - a component of <code class=\"inline\">path</code> is not a directory </li> </ul>    <h3 class=\"detail-header function\" id=\"mkdir_p!/1\">  <span class=\"signature\">mkdir_p!(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">mkdir_p!(<a href=\"path#t:t/0\">Path.t</a>) :: :ok | no_return</code></pre>    <p>Same as <a href=\"#mkdir_p/1\"><code class=\"inline\">mkdir_p/1</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code>.</p>    <h3 class=\"detail-header function\" id=\"open/2\">  <span class=\"signature\">open(path, modes \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">open(<a href=\"path#t:t/0\">Path.t</a>, [<a href=\"#t:mode/0\">mode</a> | :ram]) ::\n  {:ok, <a href=\"#t:io_device/0\">io_device</a>} |\n  {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">open(<a href=\"path#t:t/0\">Path.t</a>, (<a href=\"#t:io_device/0\">io_device</a> -&gt; res)) ::\n  {:ok, res} |\n  {:error, <a href=\"#t:posix/0\">posix</a>} when res: var</code></pre>    <p>Opens the given <code class=\"inline\">path</code> according to the given list of <code class=\"inline\">modes</code>.</p> <p>In order to write and read files, one must use the functions in the <a href=\"io\"><code class=\"inline\">IO</code></a> module. By default, a file is opened in <code class=\"inline\">:binary</code> mode, which requires the functions <a href=\"io#binread/2\"><code class=\"inline\">IO.binread/2</code></a> and <a href=\"io#binwrite/2\"><code class=\"inline\">IO.binwrite/2</code></a> to interact with the file. A developer may pass <code class=\"inline\">:utf8</code> as an option when opening the file and then all other functions from <a href=\"io\"><code class=\"inline\">IO</code></a> are available, since they work directly with Unicode data.</p> <p>The allowed modes:</p> <ul> <li>\n<p><code class=\"inline\">:binary</code> - opens the file in binary mode, disabling special handling of unicode sequences (default mode).</p> </li> <li>\n<p><code class=\"inline\">:read</code> - the file, which must exist, is opened for reading.</p> </li> <li>\n<p><code class=\"inline\">:write</code> - the file is opened for writing. It is created if it does not exist.</p> <p>If the file does exists, and if write is not combined with read, the file will be truncated.</p> </li> <li>\n<p><code class=\"inline\">:append</code> - the file will be opened for writing, and it will be created if it does not exist. Every write operation to a file opened with append will take place at the end of the file.</p> </li> <li>\n<p><code class=\"inline\">:exclusive</code> - the file, when opened for writing, is created if it does not exist. If the file exists, open will return <code class=\"inline\">{:error, :eexist}</code>.</p> </li> <li>\n<p><code class=\"inline\">:charlist</code> - when this term is given, read operations on the file will return charlists rather than binaries.</p> </li> <li>\n<p><code class=\"inline\">:compressed</code> - makes it possible to read or write gzip compressed files.</p> <p>The compressed option must be combined with either read or write, but not both. Note that the file size obtained with <code class=\"inline\">stat/1</code> will most probably not match the number of bytes that can be read from a compressed file.</p> </li> <li>\n<p><code class=\"inline\">:utf8</code> - this option denotes how data is actually stored in the disk file and makes the file perform automatic translation of characters to and from UTF-8.</p> <p>If data is sent to a file in a format that cannot be converted to the UTF-8 or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file will be closed.</p> </li> <li>\n<code class=\"inline\">:delayed_write</code>, <code class=\"inline\">:raw</code>, <code class=\"inline\">:ram</code>, <code class=\"inline\">:read_ahead</code>, <code class=\"inline\">:sync</code>, <code class=\"inline\">{:encoding, ...}</code>, <code class=\"inline\">{:read_ahead, pos_integer}</code>, <code class=\"inline\">{:delayed_write, non_neg_integer, non_neg_integer}</code> - for more information about these options see <a href=\"http://www.erlang.org/doc/man/file.html#open-2\"><code class=\"inline\">:file.open/2</code></a>. </li> </ul> <p>This function returns:</p> <ul> <li>\n<p><code class=\"inline\">{:ok, io_device}</code> - the file has been opened in the requested mode.</p> <p><code class=\"inline\">io_device</code> is actually the pid of the process which handles the file. This process is linked to the process which originally opened the file. If any process to which the <code class=\"inline\">io_device</code> is linked terminates, the file will be closed and the process itself will be terminated.</p> <p>An <code class=\"inline\">io_device</code> returned from this call can be used as an argument to the <a href=\"io\"><code class=\"inline\">IO</code></a> module functions.</p> </li> <li>\n<code class=\"inline\">{:error, reason}</code> - the file could not be opened. </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">{:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\nIO.read(file, :line)\nFile.close(file)</code></pre>    <h3 class=\"detail-header function\" id=\"open/3\">  <span class=\"signature\">open(path, modes, function)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">open(<a href=\"path#t:t/0\">Path.t</a>, [<a href=\"#t:mode/0\">mode</a> | :ram], (<a href=\"#t:io_device/0\">io_device</a> -&gt; res)) ::\n  {:ok, res} |\n  {:error, <a href=\"#t:posix/0\">posix</a>} when res: var</code></pre>    <p>Similar to <a href=\"#open/2\"><code class=\"inline\">open/2</code></a> but expects a function as its last argument.</p> <p>The file is opened, given to the function as an argument and automatically closed after the function returns, regardless if there was an error when executing the function.</p> <p>It returns <code class=\"inline\">{:ok, function_result}</code> in case of success, <code class=\"inline\">{:error, reason}</code> otherwise.</p> <p>This function expects the file to be closed with success, which is usually the case unless the <code class=\"inline\">:delayed_write</code> option is given. For this reason, we do not recommend passing <code class=\"inline\">:delayed_write</code> to this function.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">File.open(\"file.txt\", [:read, :write], fn(file) -&gt;\n  IO.read(file, :line)\nend)</code></pre>    <h3 class=\"detail-header function\" id=\"open!/2\">  <span class=\"signature\">open!(path, modes \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">open!(<a href=\"path#t:t/0\">Path.t</a>, [<a href=\"#t:mode/0\">mode</a>]) :: <a href=\"#t:io_device/0\">io_device</a> | no_return</code></pre>    <p>Same as <a href=\"#open/2\"><code class=\"inline\">open/2</code></a> but raises an error if file could not be opened.</p> <p>Returns the <code class=\"inline\">io_device</code> otherwise.</p>    <h3 class=\"detail-header function\" id=\"open!/3\">  <span class=\"signature\">open!(path, modes, function)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">open!(<a href=\"path#t:t/0\">Path.t</a>, [<a href=\"#t:mode/0\">mode</a> | :ram], (<a href=\"#t:io_device/0\">io_device</a> -&gt; res)) ::\n  res |\n  no_return when res: var</code></pre>    <p>Same as <a href=\"#open/3\"><code class=\"inline\">open/3</code></a> but raises an error if file could not be opened.</p> <p>Returns the function result otherwise.</p>    <h3 class=\"detail-header function\" id=\"read/1\">  <span class=\"signature\">read(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">read(<a href=\"path#t:t/0\">Path.t</a>) :: {:ok, binary} | {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Returns <code class=\"inline\">{:ok, binary}</code>, where <code class=\"inline\">binary</code> is a binary data object that contains the contents of <code class=\"inline\">path</code>, or <code class=\"inline\">{:error, reason}</code> if an error occurs.</p> <p>Typical error reasons:</p> <ul> <li>\n<code class=\"inline\">:enoent</code> - the file does not exist </li> <li>\n<code class=\"inline\">:eacces</code> - missing permission for reading the file, or for searching one of the parent directories </li> <li>\n<code class=\"inline\">:eisdir</code> - the named file is a directory </li> <li>\n<code class=\"inline\">:enotdir</code> - a component of the file name is not a directory; on some platforms, <code class=\"inline\">:enoent</code> is returned instead </li> <li>\n<code class=\"inline\">:enomem</code> - there is not enough memory for the contents of the file </li> </ul> <p>You can use <a href=\"http://www.erlang.org/doc/man/file.html#format_error-1\"><code class=\"inline\">:file.format_error/1</code></a> to get a descriptive string of the error.</p>    <h3 class=\"detail-header function\" id=\"read!/1\">  <span class=\"signature\">read!(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">read!(<a href=\"path#t:t/0\">Path.t</a>) :: binary | no_return</code></pre>    <p>Returns a binary with the contents of the given filename or raises <a href=\"file.error\"><code class=\"inline\">File.Error</code></a> if an error occurs.</p>    <h3 class=\"detail-header function\" id=\"regular?/1\">  <span class=\"signature\">regular?(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">regular?(<a href=\"path#t:t/0\">Path.t</a>) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if the path is a regular file.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">File.regular? __ENV__.file #=&gt; true</code></pre>    <h3 class=\"detail-header function\" id=\"rename/2\">  <span class=\"signature\">rename(source, destination)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rename(<a href=\"path#t:t/0\">Path.t</a>, <a href=\"path#t:t/0\">Path.t</a>) :: :ok | {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Renames the <code class=\"inline\">source</code> file to <code class=\"inline\">destination</code> file. It can be used to move files (and directories) between directories. If moving a file, you must fully specify the <code class=\"inline\">destination</code> filename, it is not sufficient to simply specify its directory.</p> <p>It returns <code class=\"inline\">:ok</code> in case of success, returns <code class=\"inline\">{:error, reason}</code> otherwise.</p> <p>Note: The command <code class=\"inline\">mv</code> in Unix systems behaves differently depending if <code class=\"inline\">source</code> is a file and the <code class=\"inline\">destination</code> is an existing directory. We have chosen to explicitly disallow this behaviour.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Rename file \"a.txt\" to \"b.txt\"\nFile.rename \"a.txt\", \"b.txt\"\n\n# Rename directory \"samples\" to \"tmp\"\nFile.rename \"samples\", \"tmp\"</code></pre>    <h3 class=\"detail-header function\" id=\"rm/1\">  <span class=\"signature\">rm(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rm(<a href=\"path#t:t/0\">Path.t</a>) :: :ok | {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Tries to delete the file <code class=\"inline\">path</code>.</p> <p>Returns <code class=\"inline\">:ok</code> if successful, or <code class=\"inline\">{:error, reason}</code> if an error occurs.</p> <p>Note the file is deleted even if in read-only mode.</p> <p>Typical error reasons are:</p> <ul> <li>\n<code class=\"inline\">:enoent</code> - the file does not exist </li> <li>\n<code class=\"inline\">:eacces</code> - missing permission for the file or one of its parents </li> <li>\n<code class=\"inline\">:eperm</code> - the file is a directory and user is not super-user </li> <li>\n<code class=\"inline\">:enotdir</code> - a component of the file name is not a directory; on some platforms, <code class=\"inline\">:enoent</code> is returned instead </li> <li>\n<code class=\"inline\">:einval</code> - filename had an improper type, such as tuple </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">File.rm(\"file.txt\")\n#=&gt; :ok\n\nFile.rm(\"tmp_dir/\")\n#=&gt; {:error, :eperm}</code></pre>    <h3 class=\"detail-header function\" id=\"rm!/1\">  <span class=\"signature\">rm!(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rm!(<a href=\"path#t:t/0\">Path.t</a>) :: :ok | no_return</code></pre>    <p>Same as <a href=\"#rm/1\"><code class=\"inline\">rm/1</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code>.</p>    <h3 class=\"detail-header function\" id=\"rm_rf/1\">  <span class=\"signature\">rm_rf(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rm_rf(<a href=\"path#t:t/0\">Path.t</a>) ::\n  {:ok, [binary]} |\n  {:error, <a href=\"#t:posix/0\">posix</a>, binary}</code></pre>    <p>Removes files and directories recursively at the given <code class=\"inline\">path</code>. Symlinks are not followed but simply removed, non-existing files are simply ignored (i.e. doesn’t make this function fail).</p> <p>Returns <code class=\"inline\">{:ok, files_and_directories}</code> with all files and directories removed in no specific order, <code class=\"inline\">{:error, reason, file}</code> otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">File.rm_rf \"samples\"\n#=&gt; {:ok, [\"samples\", \"samples/1.txt\"]}\n\nFile.rm_rf \"unknown\"\n#=&gt; {:ok, []}</code></pre>    <h3 class=\"detail-header function\" id=\"rm_rf!/1\">  <span class=\"signature\">rm_rf!(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rm_rf!(<a href=\"path#t:t/0\">Path.t</a>) :: [binary] | no_return</code></pre>    <p>Same as <a href=\"#rm_rf/1\"><code class=\"inline\">rm_rf/1</code></a> but raises <a href=\"file.error\"><code class=\"inline\">File.Error</code></a> in case of failures, otherwise the list of files or directories removed.</p>    <h3 class=\"detail-header function\" id=\"rmdir/1\">  <span class=\"signature\">rmdir(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rmdir(<a href=\"path#t:t/0\">Path.t</a>) :: :ok | {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Tries to delete the dir at <code class=\"inline\">path</code>. Returns <code class=\"inline\">:ok</code> if successful, or <code class=\"inline\">{:error, reason}</code> if an error occurs.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">File.rmdir('tmp_dir')\n#=&gt; :ok\n\nFile.rmdir('file.txt')\n#=&gt; {:error, :enotdir}</code></pre>    <h3 class=\"detail-header function\" id=\"rmdir!/1\">  <span class=\"signature\">rmdir!(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rmdir!(<a href=\"path#t:t/0\">Path.t</a>) :: :ok | {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Same as <a href=\"#rmdir/1\"><code class=\"inline\">rmdir/1</code></a>, but raises an exception in case of failure. Otherwise <code class=\"inline\">:ok</code>.</p>    <h3 class=\"detail-header function\" id=\"stat/2\">  <span class=\"signature\">stat(path, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stat(<a href=\"path#t:t/0\">Path.t</a>, <a href=\"#t:stat_options/0\">stat_options</a>) ::\n  {:ok, <a href=\"file.stat#t:t/0\">File.Stat.t</a>} |\n  {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Returns information about the <code class=\"inline\">path</code>. If it exists, it returns a <code class=\"inline\">{:ok, info}</code> tuple, where info is a <a href=\"file.stat\"><code class=\"inline\">File.Stat</code></a> struct. Returns <code class=\"inline\">{:error, reason}</code> with the same reasons as <a href=\"#read/1\"><code class=\"inline\">read/1</code></a> if a failure occurs.</p> <h4>Options</h4> <p>The accepted options are:</p> <ul> <li>\n<code class=\"inline\">:time</code> - configures how the file timestamps are returned </li> </ul> <p>The values for <code class=\"inline\">:time</code> can be:</p> <ul> <li>\n<code class=\"inline\">:universal</code> - returns a <code class=\"inline\">{date, time}</code> tuple in UTC (default) </li> <li>\n<code class=\"inline\">:local</code> - returns a <code class=\"inline\">{date, time}</code> tuple using the same time zone as the machine </li> <li>\n<code class=\"inline\">:posix</code> - returns the time as integer seconds since epoch </li> </ul>    <h3 class=\"detail-header function\" id=\"stat!/2\">  <span class=\"signature\">stat!(path, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stat!(<a href=\"path#t:t/0\">Path.t</a>, <a href=\"#t:stat_options/0\">stat_options</a>) ::\n  <a href=\"file.stat#t:t/0\">File.Stat.t</a> |\n  no_return</code></pre>    <p>Same as <a href=\"#stat/2\"><code class=\"inline\">stat/2</code></a> but returns the <a href=\"file.stat\"><code class=\"inline\">File.Stat</code></a> directly and throws <a href=\"file.error\"><code class=\"inline\">File.Error</code></a> if an error is returned.</p>    <h3 class=\"detail-header function\" id=\"stream!/3\">  <span class=\"signature\">stream!(path, modes \\\\ [], line_or_bytes \\\\ :line)</span>  </h3>  <p>Returns a <a href=\"file.stream\"><code class=\"inline\">File.Stream</code></a> for the given <code class=\"inline\">path</code> with the given <code class=\"inline\">modes</code>.</p> <p>The stream implements both <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> and <a href=\"collectable\"><code class=\"inline\">Collectable</code></a> protocols, which means it can be used both for read and write.</p> <p>The <code class=\"inline\">line_or_byte</code> argument configures how the file is read when streaming, by <code class=\"inline\">:line</code> (default) or by a given number of bytes.</p> <p>Operating the stream can fail on open for the same reasons as <a href=\"file#open!/2\"><code class=\"inline\">File.open!/2</code></a>. Note that the file is automatically opened each time streaming begins. There is no need to pass <code class=\"inline\">:read</code> and <code class=\"inline\">:write</code> modes, as those are automatically set by Elixir.</p> <h4>Raw files</h4> <p>Since Elixir controls when the streamed file is opened, the underlying device cannot be shared and as such it is convenient to open the file in raw mode for performance reasons. Therefore, Elixir <strong>will</strong> open streams in <code class=\"inline\">:raw</code> mode with the <code class=\"inline\">:read_ahead</code> option unless an encoding is specified. This means any data streamed into the file must be converted to <code class=\"inline\">iodata</code> type. If you pass <code class=\"inline\">[:utf8]</code> in the modes parameter, the underlying stream will use <a href=\"io#write/2\"><code class=\"inline\">IO.write/2</code></a> and the <a href=\"string.chars\"><code class=\"inline\">String.Chars</code></a> protocol to convert the data. See <a href=\"io#binwrite/2\"><code class=\"inline\">IO.binwrite/2</code></a> and <a href=\"io#write/2\"><code class=\"inline\">IO.write/2</code></a> .</p> <p>One may also consider passing the <code class=\"inline\">:delayed_write</code> option if the stream is meant to be written to under a tight loop.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Read in 2048 byte chunks rather than lines\nFile.stream!(\"./test/test.data\", [], 2048)\n#=&gt;  %File.Stream{line_or_bytes: 2048, modes: [:raw, :read_ahead, :binary],\n#=&gt; path: \"./test/test.data\", raw: true}</code></pre> <p>See <a href=\"stream#run/1\"><code class=\"inline\">Stream.run/1</code></a> for an example of streaming into a file.</p>    <h3 class=\"detail-header function\" id=\"touch/2\">  <span class=\"signature\">touch(path, time \\\\ :calendar.universal_time())</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">touch(<a href=\"path#t:t/0\">Path.t</a>, :calendar.datetime) ::\n  :ok |\n  {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Updates modification time (mtime) and access time (atime) of the given file.</p> <p>The file is created if it doesn’t exist. Requires datetime in UTC.</p>    <h3 class=\"detail-header function\" id=\"touch!/2\">  <span class=\"signature\">touch!(path, time \\\\ :calendar.universal_time())</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">touch!(<a href=\"path#t:t/0\">Path.t</a>, :calendar.datetime) :: :ok | no_return</code></pre>    <p>Same as <a href=\"#touch/2\"><code class=\"inline\">touch/2</code></a> but raises an exception if it fails.</p> <p>Returns <code class=\"inline\">:ok</code> otherwise. Requires datetime in UTC.</p>    <h3 class=\"detail-header function\" id=\"write/3\">  <span class=\"signature\">write(path, content, modes \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">write(<a href=\"path#t:t/0\">Path.t</a>, iodata, [<a href=\"#t:mode/0\">mode</a>]) ::\n  :ok |\n  {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Writes <code class=\"inline\">content</code> to the file <code class=\"inline\">path</code>.</p> <p>The file is created if it does not exist. If it exists, the previous contents are overwritten. Returns <code class=\"inline\">:ok</code> if successful, or <code class=\"inline\">{:error, reason}</code> if an error occurs.</p> <p><strong>Warning:</strong> Every time this function is invoked, a file descriptor is opened and a new process is spawned to write to the file. For this reason, if you are doing multiple writes in a loop, opening the file via <a href=\"file#open/2\"><code class=\"inline\">File.open/2</code></a> and using the functions in <a href=\"io\"><code class=\"inline\">IO</code></a> to write to the file will yield much better performance than calling this function multiple times.</p> <p>Typical error reasons are:</p> <ul> <li>\n<code class=\"inline\">:enoent</code> - a component of the file name does not exist </li> <li>\n<code class=\"inline\">:enotdir</code> - a component of the file name is not a directory; on some platforms, <code class=\"inline\">:enoent</code> is returned instead </li> <li>\n<code class=\"inline\">:enospc</code> - there is a no space left on the device </li> <li>\n<code class=\"inline\">:eacces</code> - missing permission for writing the file or searching one of the parent directories </li> <li>\n<code class=\"inline\">:eisdir</code> - the named file is a directory </li> </ul> <p>Check <a href=\"file#open/2\"><code class=\"inline\">File.open/2</code></a> for other available options.</p>    <h3 class=\"detail-header function\" id=\"write!/3\">  <span class=\"signature\">write!(path, content, modes \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">write!(<a href=\"path#t:t/0\">Path.t</a>, iodata, [<a href=\"#t:mode/0\">mode</a>]) :: :ok | no_return</code></pre>    <p>Same as <a href=\"#write/3\"><code class=\"inline\">write/3</code></a> but raises an exception if it fails, returns <code class=\"inline\">:ok</code> otherwise.</p>    <h3 class=\"detail-header function\" id=\"write_stat/3\">  <span class=\"signature\">write_stat(path, stat, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">write_stat(<a href=\"path#t:t/0\">Path.t</a>, <a href=\"file.stat#t:t/0\">File.Stat.t</a>, <a href=\"#t:stat_options/0\">stat_options</a>) ::\n  :ok |\n  {:error, <a href=\"#t:posix/0\">posix</a>}</code></pre>    <p>Writes the given <a href=\"file.stat\"><code class=\"inline\">File.Stat</code></a> back to the filesystem at the given path. Returns <code class=\"inline\">:ok</code> or <code class=\"inline\">{:error, reason}</code>.</p>    <h3 class=\"detail-header function\" id=\"write_stat!/3\">  <span class=\"signature\">write_stat!(path, stat, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">write_stat!(<a href=\"path#t:t/0\">Path.t</a>, <a href=\"file.stat#t:t/0\">File.Stat.t</a>, <a href=\"#t:stat_options/0\">stat_options</a>) ::\n  :ok |\n  no_return</code></pre>    <p>Same as <a href=\"#write_stat/3\"><code class=\"inline\">write_stat/3</code></a> but raises an exception if it fails. Returns <code class=\"inline\">:ok</code> otherwise.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/File.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/File.html</a>\n  </p>\n</div>\n","elixir/keyword":"<h1>  Keyword  </h1>  <p>A set of functions for working with keywords.</p> <p>A keyword is a list of two-element tuples where the first element of the tuple is an atom and the second element can be any value.</p> <p>A keyword may have duplicated keys so it is not strictly a key-value store. However most of the functions in this module behave exactly as a dictionary so they work similarly to the functions you would find in the <a href=\"map\"><code class=\"inline\">Map</code></a> module.</p> <p>For example, <a href=\"keyword#get/3\"><code class=\"inline\">Keyword.get/3</code></a> will get the first entry matching the given key, regardless if duplicated entries exist. Similarly, <a href=\"keyword#put/3\"><code class=\"inline\">Keyword.put/3</code></a> and <a href=\"keyword#delete/3\"><code class=\"inline\">Keyword.delete/3</code></a> ensure all duplicated entries for a given key are removed when invoked.</p> <p>A handful of functions exist to handle duplicated keys, in particular, <a href=\"enum#into/2\"><code class=\"inline\">Enum.into/2</code></a> allows creating new keywords without removing duplicated keys, <a href=\"#get_values/2\"><code class=\"inline\">get_values/2</code></a> returns all values for a given key and <a href=\"#delete_first/2\"><code class=\"inline\">delete_first/2</code></a> deletes just one of the existing entries.</p> <p>The functions in Keyword do not guarantee any property when it comes to ordering. However, since a keyword list is simply a list, all the operations defined in <a href=\"enum\"><code class=\"inline\">Enum</code></a> and <a href=\"list\"><code class=\"inline\">List</code></a> can be applied too, specially when ordering is required.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:key/0\">key()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/1\">t(value)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:value/0\">value()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#delete/2\">delete(keywords, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes the entries in the keyword list for a specific <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete/3\">delete(keywords, key, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes the entries in the keyword list for a <code class=\"inline\">key</code> with <code class=\"inline\">value</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete_first/2\">delete_first(keywords, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes the first entry in the keyword list for a specific <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#drop/2\">drop(keywords, keys)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Drops the given keys from the keyword list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#equal?/2\">equal?(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if two keywords are equal</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch/2\">fetch(keywords, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches the value for a specific <code class=\"inline\">key</code> and returns it in a tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch!/2\">fetch!(keywords, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches the value for specific <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get/3\">get(keywords, key, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the value for a specific <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_and_update/3\">get_and_update(keywords, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the value from <code class=\"inline\">key</code> and updates it, all in one pass</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_and_update!/3\">get_and_update!(keywords, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the value from <code class=\"inline\">key</code> and updates it. Raises if there is no <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_lazy/3\">get_lazy(keywords, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the value for a specific <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_values/2\">get_values(keywords, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets all values for a specific <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#has_key?/2\">has_key?(keywords, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns whether a given <code class=\"inline\">key</code> exists in the given <code class=\"inline\">keywords</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#keys/1\">keys(keywords)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all keys from the keyword list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#keyword?/1\">keyword?(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a keyword list; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#merge/2\">merge(keywords1, keywords2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Merges two keyword lists into one</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#merge/3\">merge(keywords1, keywords2, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Merges two keyword lists into one</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/0\">new()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an empty keyword list, i.e. an empty list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/1\">new(pairs)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a keyword from an enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/2\">new(pairs, transform)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a keyword from an enumerable via the transformation function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pop/3\">pop(keywords, key, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns and removes all values associated with <code class=\"inline\">key</code> in the keyword list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pop_first/3\">pop_first(keywords, key, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns and removes the first value associated with <code class=\"inline\">key</code> in the keyword list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pop_lazy/3\">pop_lazy(keywords, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Lazily returns and removes all values associated with <code class=\"inline\">key</code> in the keyword list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put/3\">put(keywords, key, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts the given <code class=\"inline\">value</code> under <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_new/3\">put_new(keywords, key, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts the given <code class=\"inline\">value</code> under <code class=\"inline\">key</code> unless the entry <code class=\"inline\">key</code> already exists</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_new_lazy/3\">put_new_lazy(keywords, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Evaluates <code class=\"inline\">fun</code> and puts the result under <code class=\"inline\">key</code> in keyword list unless <code class=\"inline\">key</code> is already present</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#split/2\">split(keywords, keys)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Takes all entries corresponding to the given keys and extracts them into a separate keyword list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#take/2\">take(keywords, keys)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Takes all entries corresponding to the given keys and returns them in a new keyword list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_list/1\">to_list(keyword)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the keyword list itself</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update/4\">update(keywords, key, initial, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates the <code class=\"inline\">key</code> in <code class=\"inline\">keywords</code> with the given function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update!/3\">update!(keywords, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates the <code class=\"inline\">key</code> with the given function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#values/1\">values(keywords)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all values from the keyword list</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:key/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:key/0\">key</a> :: atom</code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: [{<a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>}]</code></pre> </div> <div id=\"t:t/1\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/1\">t(value)</a> :: [{<a href=\"#t:key/0\">key</a>, value}]</code></pre> </div> <div id=\"t:value/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:value/0\">value</a> :: any</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"delete/2\">  <span class=\"signature\">delete(keywords, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Deletes the entries in the keyword list for a specific <code class=\"inline\">key</code>.</p> <p>If the <code class=\"inline\">key</code> does not exist, returns the keyword list unchanged. Use <a href=\"#delete_first/2\"><code class=\"inline\">delete_first/2</code></a> to delete just the first entry in case of duplicated keys.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.delete([a: 1, b: 2], :a)\n[b: 2]\niex&gt; Keyword.delete([a: 1, b: 2, a: 3], :a)\n[b: 2]\niex&gt; Keyword.delete([b: 2], :a)\n[b: 2]</code></pre>    <h3 class=\"detail-header function\" id=\"delete/3\">  <span class=\"signature\">delete(keywords, key, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Deletes the entries in the keyword list for a <code class=\"inline\">key</code> with <code class=\"inline\">value</code>.</p> <p>If no <code class=\"inline\">key</code> with <code class=\"inline\">value</code> exists, returns the keyword list unchanged.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.delete([a: 1, b: 2], :a, 1)\n[b: 2]\niex&gt; Keyword.delete([a: 1, b: 2, a: 3], :a, 3)\n[a: 1, b: 2]\niex&gt; Keyword.delete([a: 1], :a, 5)\n[a: 1]\niex&gt; Keyword.delete([a: 1], :b, 5)\n[a: 1]</code></pre>    <h3 class=\"detail-header function\" id=\"delete_first/2\">  <span class=\"signature\">delete_first(keywords, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete_first(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Deletes the first entry in the keyword list for a specific <code class=\"inline\">key</code>.</p> <p>If the <code class=\"inline\">key</code> does not exist, returns the keyword list unchanged.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n[b: 2, a: 3]\niex&gt; Keyword.delete_first([b: 2], :a)\n[b: 2]</code></pre>    <h3 class=\"detail-header function\" id=\"drop/2\">  <span class=\"signature\">drop(keywords, keys)</span>  </h3>  <p>Drops the given keys from the keyword list.</p> <p>Duplicated keys are preserved in the new keyword list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])\n[a: 1, c: 3]\niex&gt; Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])\n[a: 1, c: 3, a: 5]</code></pre>    <h3 class=\"detail-header function\" id=\"equal?/2\">  <span class=\"signature\">equal?(left, right)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">equal?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: boolean</code></pre>    <p>Checks if two keywords are equal.</p> <p>Two keywords are considered to be equal if they contain the same keys and those keys contain the same values.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\ntrue\niex&gt; Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])\nfalse\niex&gt; Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"fetch/2\">  <span class=\"signature\">fetch(keywords, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>) :: {:ok, <a href=\"#t:value/0\">value</a>} | :error</code></pre>    <p>Fetches the value for a specific <code class=\"inline\">key</code> and returns it in a tuple.</p> <p>If the <code class=\"inline\">key</code> does not exist, returns <code class=\"inline\">:error</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.fetch([a: 1], :a)\n{:ok, 1}\niex&gt; Keyword.fetch([a: 1], :b)\n:error</code></pre>    <h3 class=\"detail-header function\" id=\"fetch!/2\">  <span class=\"signature\">fetch!(keywords, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch!(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>) :: <a href=\"#t:value/0\">value</a> | no_return</code></pre>    <p>Fetches the value for specific <code class=\"inline\">key</code>.</p> <p>If <code class=\"inline\">key</code> does not exist, a <a href=\"keyerror\"><code class=\"inline\">KeyError</code></a> is raised.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.fetch!([a: 1], :a)\n1\niex&gt; Keyword.fetch!([a: 1], :b)\n** (KeyError) key :b not found in: [a: 1]</code></pre>    <h3 class=\"detail-header function\" id=\"get/3\">  <span class=\"signature\">get(keywords, key, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: <a href=\"#t:value/0\">value</a></code></pre>    <p>Gets the value for a specific <code class=\"inline\">key</code>.</p> <p>If <code class=\"inline\">key</code> does not exist, return the default value (<code class=\"inline\">nil</code> if no default value).</p> <p>If duplicated entries exist, the first one is returned. Use <a href=\"#get_values/2\"><code class=\"inline\">get_values/2</code></a> to retrieve all entries.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.get([], :a)\nnil\niex&gt; Keyword.get([a: 1], :a)\n1\niex&gt; Keyword.get([a: 1], :b)\nnil\niex&gt; Keyword.get([a: 1], :b, 3)\n3</code></pre> <p>With duplicated keys:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.get([a: 1, a: 2], :a, 3)\n1\niex&gt; Keyword.get([a: 1, a: 2], :b, 3)\n3</code></pre>    <h3 class=\"detail-header function\" id=\"get_and_update/3\">  <span class=\"signature\">get_and_update(keywords, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_and_update(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (<a href=\"#t:value/0\">value</a> -&gt; {get, <a href=\"#t:value/0\">value</a>} | :pop)) :: {get, <a href=\"#t:t/0\">t</a>} when get: term</code></pre>    <p>Gets the value from <code class=\"inline\">key</code> and updates it, all in one pass.</p> <p>This <code class=\"inline\">fun</code> argument receives the value of <code class=\"inline\">key</code> (or <code class=\"inline\">nil</code> if <code class=\"inline\">key</code> is not present) and must return a two-element tuple: the “get” value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class=\"inline\">key</code>. The <code class=\"inline\">fun</code> may also return <code class=\"inline\">:pop</code>, implying the current value shall be removed from the keyword list and returned.</p> <p>The returned value is a tuple with the “get” value returned by <code class=\"inline\">fun</code> and a new keyword list with the updated value under <code class=\"inline\">key</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.get_and_update([a: 1], :a, fn current_value -&gt;\n...&gt;   {current_value, \"new value!\"}\n...&gt; end)\n{1, [a: \"new value!\"]}\n\niex&gt; Keyword.get_and_update([a: 1], :b, fn current_value -&gt;\n...&gt;   {current_value, \"new value!\"}\n...&gt; end)\n{nil, [b: \"new value!\", a: 1]}\n\niex&gt; Keyword.get_and_update([a: 1], :a, fn _ -&gt; :pop end)\n{1, []}\n\niex&gt; Keyword.get_and_update([a: 1], :b, fn _ -&gt; :pop end)\n{nil, [a: 1]}</code></pre>    <h3 class=\"detail-header function\" id=\"get_and_update!/3\">  <span class=\"signature\">get_and_update!(keywords, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_and_update!(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (<a href=\"#t:value/0\">value</a> -&gt; {get, <a href=\"#t:value/0\">value</a>})) ::\n  {get, <a href=\"#t:t/0\">t</a>} |\n  no_return when get: term</code></pre>    <p>Gets the value from <code class=\"inline\">key</code> and updates it. Raises if there is no <code class=\"inline\">key</code>.</p> <p>This <code class=\"inline\">fun</code> argument receives the value of <code class=\"inline\">key</code> and must return a two-element tuple: the “get” value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class=\"inline\">key</code>.</p> <p>The returned value is a tuple with the “get” value returned by <code class=\"inline\">fun</code> and a new keyword list with the updated value under <code class=\"inline\">key</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.get_and_update!([a: 1], :a, fn current_value -&gt;\n...&gt;   {current_value, \"new value!\"}\n...&gt; end)\n{1, [a: \"new value!\"]}\n\niex&gt; Keyword.get_and_update!([a: 1], :b, fn current_value -&gt;\n...&gt;   {current_value, \"new value!\"}\n...&gt; end)\n** (KeyError) key :b not found in: [a: 1]\n\niex&gt; Keyword.get_and_update!([a: 1], :a, fn _ -&gt;\n...&gt;   :pop\n...&gt; end)\n{1, []}</code></pre>    <h3 class=\"detail-header function\" id=\"get_lazy/3\">  <span class=\"signature\">get_lazy(keywords, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_lazy(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (() -&gt; <a href=\"#t:value/0\">value</a>)) :: <a href=\"#t:value/0\">value</a></code></pre>    <p>Gets the value for a specific <code class=\"inline\">key</code>.</p> <p>If <code class=\"inline\">key</code> does not exist, lazily evaluates <code class=\"inline\">fun</code> and returns its result.</p> <p>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</p> <p>If duplicated entries exist, the first one is returned. Use <a href=\"#get_values/2\"><code class=\"inline\">get_values/2</code></a> to retrieve all entries.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; keyword = [a: 1]\niex&gt; fun = fn -&gt;\n...&gt;   # some expensive operation here\n...&gt;   13\n...&gt; end\niex&gt; Keyword.get_lazy(keyword, :a, fun)\n1\niex&gt; Keyword.get_lazy(keyword, :b, fun)\n13</code></pre>    <h3 class=\"detail-header function\" id=\"get_values/2\">  <span class=\"signature\">get_values(keywords, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_values(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>) :: [<a href=\"#t:value/0\">value</a>]</code></pre>    <p>Gets all values for a specific <code class=\"inline\">key</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.get_values([], :a)\n[]\niex&gt; Keyword.get_values([a: 1], :a)\n[1]\niex&gt; Keyword.get_values([a: 1, a: 2], :a)\n[1, 2]</code></pre>    <h3 class=\"detail-header function\" id=\"has_key?/2\">  <span class=\"signature\">has_key?(keywords, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">has_key?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>) :: boolean</code></pre>    <p>Returns whether a given <code class=\"inline\">key</code> exists in the given <code class=\"inline\">keywords</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.has_key?([a: 1], :a)\ntrue\niex&gt; Keyword.has_key?([a: 1], :b)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"keys/1\">  <span class=\"signature\">keys(keywords)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">keys(<a href=\"#t:t/0\">t</a>) :: [<a href=\"#t:key/0\">key</a>]</code></pre>    <p>Returns all keys from the keyword list.</p> <p>Duplicated keys appear duplicated in the final list of keys.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.keys([a: 1, b: 2])\n[:a, :b]\niex&gt; Keyword.keys([a: 1, b: 2, a: 3])\n[:a, :b, :a]</code></pre>    <h3 class=\"detail-header function\" id=\"keyword?/1\">  <span class=\"signature\">keyword?(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">keyword?(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a keyword list; otherwise returns <code class=\"inline\">false</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.keyword?([])\ntrue\niex&gt; Keyword.keyword?([a: 1])\ntrue\niex&gt; Keyword.keyword?([{Foo, 1}])\ntrue\niex&gt; Keyword.keyword?([{}])\nfalse\niex&gt; Keyword.keyword?([:key])\nfalse\niex&gt; Keyword.keyword?(%{})\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"merge/2\">  <span class=\"signature\">merge(keywords1, keywords2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">merge(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Merges two keyword lists into one.</p> <p>All keys, including duplicated keys, given in <code class=\"inline\">keywords2</code> will be added to <code class=\"inline\">keywords1</code>, overriding any existing one.</p> <p>There are no guarantees about the order of keys in the returned keyword.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n[b: 2, a: 3, d: 4]\n\niex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])\n[b: 2, a: 3, d: 4, a: 5]</code></pre>    <h3 class=\"detail-header function\" id=\"merge/3\">  <span class=\"signature\">merge(keywords1, keywords2, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">merge(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>, (<a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>, <a href=\"#t:value/0\">value</a> -&gt; <a href=\"#t:value/0\">value</a>)) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Merges two keyword lists into one.</p> <p>All keys, including duplicated keys, given in <code class=\"inline\">keywords2</code> will be added to <code class=\"inline\">keywords1</code>. The given function will be invoked to solve conflicts.</p> <p>If <code class=\"inline\">keywords2</code> has duplicate keys, the given function will be invoked for each matching pair in <code class=\"inline\">keywords1</code>.</p> <p>There are no guarantees about the order of keys in the returned keyword.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 -&gt;\n...&gt;   v1 + v2\n...&gt; end)\n[b: 2, a: 4, d: 4]\n\niex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 -&gt;\n...&gt;  v1 + v2\n...&gt; end)\n[b: 2, a: 4, d: 4, a: 5]\n\niex&gt; Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 -&gt;\n...&gt;  v1 + v2\n...&gt; end)\n[b: 2, a: 4, d: 4, a: 8]</code></pre>    <h3 class=\"detail-header function\" id=\"new/0\">  <span class=\"signature\">new()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new :: []</code></pre>    <p>Returns an empty keyword list, i.e. an empty list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.new()\n[]</code></pre>    <h3 class=\"detail-header function\" id=\"new/1\">  <span class=\"signature\">new(pairs)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new(<a href=\"enum#t:t/0\">Enum.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Creates a keyword from an enumerable.</p> <p>Duplicated entries are removed, the latest one prevails. Unlike <code class=\"inline\">Enum.into(enumerable, [])</code>, <code class=\"inline\">Keyword.new(enumerable)</code> guarantees the keys are unique.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.new([{:b, 1}, {:a, 2}])\n[b: 1, a: 2]\n\niex&gt; Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])\n[a: 3]</code></pre>    <h3 class=\"detail-header function\" id=\"new/2\">  <span class=\"signature\">new(pairs, transform)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new(<a href=\"enum#t:t/0\">Enum.t</a>, (term -&gt; {<a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>})) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Creates a keyword from an enumerable via the transformation function.</p> <p>Duplicated entries are removed, the latest one prevails. Unlike <code class=\"inline\">Enum.into(enumerable, [], fun)</code>, <code class=\"inline\">Keyword.new(enumerable, fun)</code> guarantees the keys are unique.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.new([:a, :b], fn(x) -&gt; {x, x} end)\n[a: :a, b: :b]</code></pre>    <h3 class=\"detail-header function\" id=\"pop/3\">  <span class=\"signature\">pop(keywords, key, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">pop(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: {<a href=\"#t:value/0\">value</a>, <a href=\"#t:t/0\">t</a>}</code></pre>    <p>Returns and removes all values associated with <code class=\"inline\">key</code> in the keyword list.</p> <p>All duplicated keys are removed. See <a href=\"#pop_first/3\"><code class=\"inline\">pop_first/3</code></a> for removing only the first entry.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.pop([a: 1], :a)\n{1, []}\niex&gt; Keyword.pop([a: 1], :b)\n{nil, [a: 1]}\niex&gt; Keyword.pop([a: 1], :b, 3)\n{3, [a: 1]}\niex&gt; Keyword.pop([a: 1, a: 2], :a)\n{1, []}</code></pre>    <h3 class=\"detail-header function\" id=\"pop_first/3\">  <span class=\"signature\">pop_first(keywords, key, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">pop_first(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: {<a href=\"#t:value/0\">value</a>, <a href=\"#t:t/0\">t</a>}</code></pre>    <p>Returns and removes the first value associated with <code class=\"inline\">key</code> in the keyword list.</p> <p>Duplicated keys are not removed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.pop_first [a: 1], :a\n{1, []}\niex&gt; Keyword.pop_first [a: 1], :b\n{nil, [a: 1]}\niex&gt; Keyword.pop_first [a: 1], :b, 3\n{3, [a: 1]}\niex&gt; Keyword.pop_first [a: 1, a: 2], :a\n{1, [a: 2]}</code></pre>    <h3 class=\"detail-header function\" id=\"pop_lazy/3\">  <span class=\"signature\">pop_lazy(keywords, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">pop_lazy(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (() -&gt; <a href=\"#t:value/0\">value</a>)) :: {<a href=\"#t:value/0\">value</a>, <a href=\"#t:t/0\">t</a>}</code></pre>    <p>Lazily returns and removes all values associated with <code class=\"inline\">key</code> in the keyword list.</p> <p>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</p> <p>All duplicated keys are removed. See <a href=\"#pop_first/3\"><code class=\"inline\">pop_first/3</code></a> for removing only the first entry.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; keyword = [a: 1]\niex&gt; fun = fn -&gt;\n...&gt;   # some expensive operation here\n...&gt;   13\n...&gt; end\niex&gt; Keyword.pop_lazy(keyword, :a, fun)\n{1, []}\niex&gt; Keyword.pop_lazy(keyword, :b, fun)\n{13, [a: 1]}</code></pre>    <h3 class=\"detail-header function\" id=\"put/3\">  <span class=\"signature\">put(keywords, key, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Puts the given <code class=\"inline\">value</code> under <code class=\"inline\">key</code>.</p> <p>If a previous value is already stored, all entries are removed and the value is overridden.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.put([a: 1], :b, 2)\n[b: 2, a: 1]\niex&gt; Keyword.put([a: 1, b: 2], :a, 3)\n[a: 3, b: 2]\niex&gt; Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n[a: 3, b: 2]</code></pre>    <h3 class=\"detail-header function\" id=\"put_new/3\">  <span class=\"signature\">put_new(keywords, key, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_new(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Puts the given <code class=\"inline\">value</code> under <code class=\"inline\">key</code> unless the entry <code class=\"inline\">key</code> already exists.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.put_new([a: 1], :b, 2)\n[b: 2, a: 1]\niex&gt; Keyword.put_new([a: 1, b: 2], :a, 3)\n[a: 1, b: 2]</code></pre>    <h3 class=\"detail-header function\" id=\"put_new_lazy/3\">  <span class=\"signature\">put_new_lazy(keywords, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_new_lazy(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (() -&gt; <a href=\"#t:value/0\">value</a>)) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Evaluates <code class=\"inline\">fun</code> and puts the result under <code class=\"inline\">key</code> in keyword list unless <code class=\"inline\">key</code> is already present.</p> <p>This is useful if the value is very expensive to calculate or generally difficult to setup and teardown again.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; keyword = [a: 1]\niex&gt; fun = fn -&gt;\n...&gt;   # some expensive operation here\n...&gt;   3\n...&gt; end\niex&gt; Keyword.put_new_lazy(keyword, :a, fun)\n[a: 1]\niex&gt; Keyword.put_new_lazy(keyword, :b, fun)\n[b: 3, a: 1]</code></pre>    <h3 class=\"detail-header function\" id=\"split/2\">  <span class=\"signature\">split(keywords, keys)</span>  </h3>  <p>Takes all entries corresponding to the given keys and extracts them into a separate keyword list.</p> <p>Returns a tuple with the new list and the old list with removed keys.</p> <p>Keys for which there are no entries in the keyword list are ignored.</p> <p>Entries with duplicated keys end up in the same keyword list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])\n{[a: 1, c: 3], [b: 2]}\niex&gt; Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])\n{[a: 1, c: 3, a: 4], [b: 2]}</code></pre>    <h3 class=\"detail-header function\" id=\"take/2\">  <span class=\"signature\">take(keywords, keys)</span>  </h3>  <p>Takes all entries corresponding to the given keys and returns them in a new keyword list.</p> <p>Duplicated keys are preserved in the new keyword list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])\n[a: 1, c: 3]\niex&gt; Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])\n[a: 1, c: 3, a: 5]</code></pre>    <h3 class=\"detail-header function\" id=\"to_list/1\">  <span class=\"signature\">to_list(keyword)</span>  </h3>  <p>Returns the keyword list itself.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.to_list([a: 1])\n[a: 1]</code></pre>    <h3 class=\"detail-header function\" id=\"update/4\">  <span class=\"signature\">update(keywords, key, initial, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>, (<a href=\"#t:value/0\">value</a> -&gt; <a href=\"#t:value/0\">value</a>)) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Updates the <code class=\"inline\">key</code> in <code class=\"inline\">keywords</code> with the given function.</p> <p>If the <code class=\"inline\">key</code> does not exist, inserts the given <code class=\"inline\">initial</code> value.</p> <p>If there are duplicated keys, they are all removed and only the first one is updated.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.update([a: 1], :a, 13, &amp;(&amp;1 * 2))\n[a: 2]\niex&gt; Keyword.update([a: 1, a: 2], :a, 13, &amp;(&amp;1 * 2))\n[a: 2]\niex&gt; Keyword.update([a: 1], :b, 11, &amp;(&amp;1 * 2))\n[a: 1, b: 11]</code></pre>    <h3 class=\"detail-header function\" id=\"update!/3\">  <span class=\"signature\">update!(keywords, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update!(<a href=\"#t:t/0\">t</a>, <a href=\"#t:key/0\">key</a>, (<a href=\"#t:value/0\">value</a> -&gt; <a href=\"#t:value/0\">value</a>)) ::\n  <a href=\"#t:t/0\">t</a> |\n  no_return</code></pre>    <p>Updates the <code class=\"inline\">key</code> with the given function.</p> <p>If the <code class=\"inline\">key</code> does not exist, raises <a href=\"keyerror\"><code class=\"inline\">KeyError</code></a>.</p> <p>If there are duplicated keys, they are all removed and only the first one is updated.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.update!([a: 1], :a, &amp;(&amp;1 * 2))\n[a: 2]\niex&gt; Keyword.update!([a: 1, a: 2], :a, &amp;(&amp;1 * 2))\n[a: 2]\n\niex&gt; Keyword.update!([a: 1], :b, &amp;(&amp;1 * 2))\n** (KeyError) key :b not found in: [a: 1]</code></pre>    <h3 class=\"detail-header function\" id=\"values/1\">  <span class=\"signature\">values(keywords)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">values(<a href=\"#t:t/0\">t</a>) :: [<a href=\"#t:value/0\">value</a>]</code></pre>    <p>Returns all values from the keyword list.</p> <p>Values from duplicated keys will be kept in the final list of values.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Keyword.values([a: 1, b: 2])\n[1, 2]\niex&gt; Keyword.values([a: 1, b: 2, a: 3])\n[1, 2, 3]</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Keyword.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Keyword.html</a>\n  </p>\n</div>\n","elixir/macro":"<h1>  Macro  </h1>  <p>Conveniences for working with macros.</p> <h2 id=\"module-custom-sigils\" class=\"section-heading\">  Custom Sigils </h2> <p>To create a custom sigil, define a function with the name <code class=\"inline\">sigil_{identifier}</code> that takes two arguments. The first argument will be the string, the second will be a charlist containing any modifiers. If the sigil is lower case (such as <code class=\"inline\">sigil_x</code>) then the string argument will allow interpolation. If the sigil is upper case (such as <code class=\"inline\">sigil_X</code>) then the string will not be interpolated.</p> <p>Valid modifiers include only lower and upper case letters. Other characters will cause a syntax error.</p> <p>The module containing the custom sigil must be imported before the sigil syntax can be used.</p> <h3>Examples</h3> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MySigils do\n  defmacro sigil_x(term, [?r]) do\n    quote do\n      unquote(term) |&gt; String.reverse()\n    end\n  end\n  defmacro sigil_x(term, _modifiers) do\n    term\n  end\n  defmacro sigil_X(term, [?r]) do\n    quote do\n      unquote(term) |&gt; String.reverse()\n    end\n  end\n  defmacro sigil_X(term, _modifiers) do\n    term\n  end\nend\n\nimport MySigils\n\n~x(with #{\"inter\" &lt;&gt; \"polation\"})\n#=&gt;\"with interpolation\"\n\n~x(with #{\"inter\" &lt;&gt; \"polation\"})r\n#=&gt;\"noitalopretni htiw\"\n\n~X(without #{\"interpolation\"})\n#=&gt;\"without \\#{\"interpolation\"}\"\n\n~X(without #{\"interpolation\"})r\n#=&gt;\"}\\\"noitalopretni\\\"{# tuohtiw\"</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:expr/0\">expr()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Abstract Syntax Tree (AST)</p> </dd>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#camelize/1\">camelize(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given string to CamelCase format</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#decompose_call/1\">decompose_call(ast)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decomposes a local or remote call into its remote part (when provided), function name and argument list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#escape/2\">escape(expr, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Recursively escapes a value so it can be inserted into a syntax tree</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#expand/2\">expand(tree, env)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives an AST node and expands it until it can no longer be expanded</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#expand_once/2\">expand_once(ast, env)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives an AST node and expands it once</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pipe/3\">pipe(expr, call_args, position)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Pipes <code class=\"inline\">expr</code> into the <code class=\"inline\">call_args</code> at the given <code class=\"inline\">position</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#postwalk/2\">postwalk(ast, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Performs a depth-first, post-order traversal of quoted expressions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#postwalk/3\">postwalk(ast, acc, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Performs a depth-first, post-order traversal of quoted expressions using an accumulator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#prewalk/2\">prewalk(ast, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Performs a depth-first, pre-order traversal of quoted expressions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#prewalk/3\">prewalk(ast, acc, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Performs a depth-first, pre-order traversal of quoted expressions using an accumulator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/2\">to_string(tree, fun \\\\ fn _ast, string -&gt; string end)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given expression to a binary</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#traverse/4\">traverse(ast, acc, pre, post)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Performs a depth-first traversal of quoted expressions using an accumulator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#underscore/1\">underscore(atom)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given atom or binary to underscore format</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unescape_string/1\">unescape_string(chars)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Unescapes the given chars</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unescape_string/2\">unescape_string(chars, map)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Unescapes the given chars according to the map given</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unescape_tokens/1\">unescape_tokens(tokens)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Unescapes the given tokens according to the default map</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unescape_tokens/2\">unescape_tokens(tokens, map)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Unescapes the given tokens according to the given map</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unpipe/1\">unpipe(expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Breaks a pipeline expression into a list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update_meta/2\">update_meta(quoted, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Applies the given function to the node metadata if it contains one</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#validate/1\">validate(expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Validates the given expressions are valid quoted expressions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#var/2\">var(var, context)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates an AST node representing the variable given by the atoms <code class=\"inline\">var</code> and <code class=\"inline\">context</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:expr/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:expr/0\">expr</a> :: {<a href=\"#t:expr/0\">expr</a> | atom, <a href=\"keyword#t:t/0\">Keyword.t</a>, atom | [<a href=\"#t:t/0\">t</a>]}</code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> ::\n  <a href=\"#t:expr/0\">expr</a> |\n  {<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>} |\n  atom |\n  number |\n  binary |\n  pid |\n  (... -&gt; any) |\n  [<a href=\"#t:t/0\">t</a>]</code></pre> <p>Abstract Syntax Tree (AST)</p>  </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"camelize/1\">  <span class=\"signature\">camelize(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">camelize(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts the given string to CamelCase format.</p> <p>This function was designed to camelize language identifiers/tokens, that’s why it belongs to the <a href=\"macro#content\"><code class=\"inline\">Macro</code></a> module. Do not use it as a general mechanism for camelizing strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Macro.camelize \"foo_bar\"\n\"FooBar\"</code></pre>    <h3 class=\"detail-header function\" id=\"decompose_call/1\">  <span class=\"signature\">decompose_call(ast)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">decompose_call(<a href=\"macro#t:t/0\">Macro.t</a>) ::\n  {atom, [<a href=\"macro#t:t/0\">Macro.t</a>]} |\n  {<a href=\"macro#t:t/0\">Macro.t</a>, atom, [<a href=\"macro#t:t/0\">Macro.t</a>]} |\n  :error</code></pre>    <p>Decomposes a local or remote call into its remote part (when provided), function name and argument list.</p> <p>Returns <code class=\"inline\">:error</code> when an invalid call syntax is provided.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Macro.decompose_call(quote(do: foo))\n{:foo, []}\n\niex&gt; Macro.decompose_call(quote(do: foo()))\n{:foo, []}\n\niex&gt; Macro.decompose_call(quote(do: foo(1, 2, 3)))\n{:foo, [1, 2, 3]}\n\niex&gt; Macro.decompose_call(quote(do: Elixir.M.foo(1, 2, 3)))\n{{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n\niex&gt; Macro.decompose_call(quote(do: 42))\n:error</code></pre>    <h3 class=\"detail-header function\" id=\"escape/2\">  <span class=\"signature\">escape(expr, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">escape(term, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"macro#t:t/0\">Macro.t</a></code></pre>    <p>Recursively escapes a value so it can be inserted into a syntax tree.</p> <p>One may pass <code class=\"inline\">unquote: true</code> to <a href=\"#escape/2\"><code class=\"inline\">escape/2</code></a> which leaves <code class=\"inline\">unquote/1</code> statements unescaped, effectively unquoting the contents on escape.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Macro.escape(:foo)\n:foo\n\niex&gt; Macro.escape({:a, :b, :c})\n{:{}, [], [:a, :b, :c]}\n\niex&gt; Macro.escape({:unquote, [], [1]}, unquote: true)\n1</code></pre>    <h3 class=\"detail-header function\" id=\"expand/2\">  <span class=\"signature\">expand(tree, env)</span>  </h3>  <p>Receives an AST node and expands it until it can no longer be expanded.</p> <p>This function uses <a href=\"#expand_once/2\"><code class=\"inline\">expand_once/2</code></a> under the hood. Check it out for more information and examples.</p>    <h3 class=\"detail-header function\" id=\"expand_once/2\">  <span class=\"signature\">expand_once(ast, env)</span>  </h3>  <p>Receives an AST node and expands it once.</p> <p>The following contents are expanded:</p> <ul> <li>Macros (local or remote) </li> <li>Aliases are expanded (if possible) and return atoms </li> <li>Pseudo-variables (<code class=\"inline\">__ENV__</code>, <code class=\"inline\">__MODULE__</code> and <code class=\"inline\">__DIR__</code>) </li> <li>Module attributes reader (<code class=\"inline\">@foo</code>) </li> </ul> <p>If the expression cannot be expanded, it returns the expression itself. Notice that <a href=\"#expand_once/2\"><code class=\"inline\">expand_once/2</code></a> performs the expansion just once and it is not recursive. Check <a href=\"#expand/2\"><code class=\"inline\">expand/2</code></a> for expansion until the node can no longer be expanded.</p> <h4>Examples</h4> <p>In the example below, we have a macro that generates a module with a function named <code class=\"inline\">name_length</code> that returns the length of the module name. The value of this function will be calculated at compilation time and not at runtime.</p> <p>Consider the implementation below:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmacro defmodule_with_length(name, do: block) do\n  length = length(Atom.to_charlist(name))\n\n  quote do\n    defmodule unquote(name) do\n      def name_length, do: unquote(length)\n      unquote(block)\n    end\n  end\nend</code></pre> <p>When invoked like this:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule_with_length My.Module do\n  def other_function, do: ...\nend</code></pre> <p>The compilation will fail because <code class=\"inline\">My.Module</code> when quoted is not an atom, but a syntax tree as follow:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:__aliases__, [], [:My, :Module]}</code></pre> <p>That said, we need to expand the aliases node above to an atom, so we can retrieve its length. Expanding the node is not straight-forward because we also need to expand the caller aliases. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">alias MyHelpers, as: My\n\ndefmodule_with_length My.Module do\n  def other_function, do: ...\nend</code></pre> <p>The final module name will be <code class=\"inline\">MyHelpers.Module</code> and not <code class=\"inline\">My.Module</code>. With <a href=\"macro#expand/2\"><code class=\"inline\">Macro.expand/2</code></a>, such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmacro defmodule_with_length(name, do: block) do\n  expanded = Macro.expand(name, __CALLER__)\n  length   = length(Atom.to_charlist(expanded))\n\n  quote do\n    defmodule unquote(name) do\n      def name_length, do: unquote(length)\n      unquote(block)\n    end\n  end\nend</code></pre>    <h3 class=\"detail-header function\" id=\"pipe/3\">  <span class=\"signature\">pipe(expr, call_args, position)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">pipe(<a href=\"macro#t:t/0\">Macro.t</a>, <a href=\"macro#t:t/0\">Macro.t</a>, integer) ::\n  <a href=\"macro#t:t/0\">Macro.t</a> |\n  no_return</code></pre>    <p>Pipes <code class=\"inline\">expr</code> into the <code class=\"inline\">call_args</code> at the given <code class=\"inline\">position</code>.</p>    <h3 class=\"detail-header function\" id=\"postwalk/2\">  <span class=\"signature\">postwalk(ast, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">postwalk(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:t/0\">t</a> -&gt; <a href=\"#t:t/0\">t</a>)) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Performs a depth-first, post-order traversal of quoted expressions.</p>    <h3 class=\"detail-header function\" id=\"postwalk/3\">  <span class=\"signature\">postwalk(ast, acc, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">postwalk(<a href=\"#t:t/0\">t</a>, any, (<a href=\"#t:t/0\">t</a>, any -&gt; {<a href=\"#t:t/0\">t</a>, any})) :: {<a href=\"#t:t/0\">t</a>, any}</code></pre>    <p>Performs a depth-first, post-order traversal of quoted expressions using an accumulator.</p>    <h3 class=\"detail-header function\" id=\"prewalk/2\">  <span class=\"signature\">prewalk(ast, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">prewalk(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:t/0\">t</a> -&gt; <a href=\"#t:t/0\">t</a>)) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Performs a depth-first, pre-order traversal of quoted expressions.</p>    <h3 class=\"detail-header function\" id=\"prewalk/3\">  <span class=\"signature\">prewalk(ast, acc, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">prewalk(<a href=\"#t:t/0\">t</a>, any, (<a href=\"#t:t/0\">t</a>, any -&gt; {<a href=\"#t:t/0\">t</a>, any})) :: {<a href=\"#t:t/0\">t</a>, any}</code></pre>    <p>Performs a depth-first, pre-order traversal of quoted expressions using an accumulator.</p>    <h3 class=\"detail-header function\" id=\"to_string/2\">  <span class=\"signature\">to_string(tree, fun \\\\ fn _ast, string -&gt; string end)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_string(<a href=\"macro#t:t/0\">Macro.t</a>, (<a href=\"macro#t:t/0\">Macro.t</a>, <a href=\"string#t:t/0\">String.t</a> -&gt; <a href=\"string#t:t/0\">String.t</a>)) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts the given expression to a binary.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Macro.to_string(quote(do: foo.bar(1, 2, 3)))\n\"foo.bar(1, 2, 3)\"</code></pre>    <h3 class=\"detail-header function\" id=\"traverse/4\">  <span class=\"signature\">traverse(ast, acc, pre, post)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">traverse(<a href=\"#t:t/0\">t</a>, any, (<a href=\"#t:t/0\">t</a>, any -&gt; {<a href=\"#t:t/0\">t</a>, any}), (<a href=\"#t:t/0\">t</a>, any -&gt; {<a href=\"#t:t/0\">t</a>, any})) :: {<a href=\"#t:t/0\">t</a>, any}</code></pre>    <p>Performs a depth-first traversal of quoted expressions using an accumulator.</p>    <h3 class=\"detail-header function\" id=\"underscore/1\">  <span class=\"signature\">underscore(atom)</span>  </h3>  <p>Converts the given atom or binary to underscore format.</p> <p>If an atom is given, it is assumed to be an Elixir module, so it is converted to a binary and then processed.</p> <p>This function was designed to underscore language identifiers/tokens, that’s why it belongs to the <a href=\"macro#content\"><code class=\"inline\">Macro</code></a> module. Do not use it as a general mechanism for underscoring strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Macro.underscore \"FooBar\"\n\"foo_bar\"\n\niex&gt; Macro.underscore \"Foo.Bar\"\n\"foo/bar\"\n\niex&gt; Macro.underscore Foo.Bar\n\"foo/bar\"</code></pre> <p>In general, <code class=\"inline\">underscore</code> can be thought of as the reverse of <code class=\"inline\">camelize</code>, however, in some cases formatting may be lost:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Macro.underscore \"SAPExample\"\n\"sap_example\"\n\niex&gt; Macro.camelize \"sap_example\"\n\"SapExample\"\n\niex&gt; Macro.camelize \"hello_10\"\n\"Hello10\"</code></pre>    <h3 class=\"detail-header function\" id=\"unescape_string/1\">  <span class=\"signature\">unescape_string(chars)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unescape_string(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Unescapes the given chars.</p> <p>This is the unescaping behaviour used by default in Elixir single- and double-quoted strings. Check <a href=\"#unescape_string/2\"><code class=\"inline\">unescape_string/2</code></a> for information on how to customize the escaping map.</p> <p>In this setup, Elixir will escape the following: <code class=\"inline\">\\0</code>, <code class=\"inline\">\\a</code>, <code class=\"inline\">\\b</code>, <code class=\"inline\">\\d</code>, <code class=\"inline\">\\e</code>, <code class=\"inline\">\\f</code>, <code class=\"inline\">\\n</code>, <code class=\"inline\">\\r</code>, <code class=\"inline\">\\s</code>, <code class=\"inline\">\\t</code> and <code class=\"inline\">\\v</code>. Bytes can be given as hexadecimals via <code class=\"inline\">\\xNN</code> and Unicode Codepoints as <code class=\"inline\">\\uNNNN</code> escapes.</p> <p>This function is commonly used on sigil implementations (like <code class=\"inline\">~r</code>, <code class=\"inline\">~s</code> and others) which receive a raw, unescaped string.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Macro.unescape_string(\"example\\\\n\")\n\"example\\n\"</code></pre> <p>In the example above, we pass a string with <code class=\"inline\">\\n</code> escaped and return a version with it unescaped.</p>    <h3 class=\"detail-header function\" id=\"unescape_string/2\">  <span class=\"signature\">unescape_string(chars, map)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unescape_string(<a href=\"string#t:t/0\">String.t</a>, (non_neg_integer -&gt; non_neg_integer | false)) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Unescapes the given chars according to the map given.</p> <p>Check <a href=\"#unescape_string/1\"><code class=\"inline\">unescape_string/1</code></a> if you want to use the same map as Elixir single- and double-quoted strings.</p> <h4>Map</h4> <p>The map must be a function. The function receives an integer representing the codepoint of the character it wants to unescape. Here is the default mapping function implemented by Elixir:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def unescape_map(?0), do: ?0\ndef unescape_map(?a), do: ?\\a\ndef unescape_map(?b), do: ?\\b\ndef unescape_map(?d), do: ?\\d\ndef unescape_map(?e), do: ?\\e\ndef unescape_map(?f), do: ?\\f\ndef unescape_map(?n), do: ?\\n\ndef unescape_map(?r), do: ?\\r\ndef unescape_map(?s), do: ?\\s\ndef unescape_map(?t), do: ?\\t\ndef unescape_map(?v), do: ?\\v\ndef unescape_map(?x), do: true\ndef unescape_map(?u), do: true\ndef unescape_map(e),  do: e</code></pre> <p>If the <code class=\"inline\">unescape_map</code> function returns <code class=\"inline\">false</code>. The char is not escaped and <code class=\"inline\">\\</code> is kept in the charlist. Hexadecimals and Unicode codepoints will be escaped if the map function returns <code class=\"inline\">true</code> for <code class=\"inline\">?x</code>. Unicode codepoints if the map function returns <code class=\"inline\">true</code> for <code class=\"inline\">?u</code>. ## Examples Using the <code class=\"inline\">unescape_map</code> function defined above is easy: Macro.unescape_string “example\\n”, &amp;unescape_map(&amp;1)</p>    <h3 class=\"detail-header function\" id=\"unescape_tokens/1\">  <span class=\"signature\">unescape_tokens(tokens)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unescape_tokens([<a href=\"macro#t:t/0\">Macro.t</a>]) :: [<a href=\"macro#t:t/0\">Macro.t</a>]</code></pre>    <p>Unescapes the given tokens according to the default map.</p> <p>Check <a href=\"#unescape_string/1\"><code class=\"inline\">unescape_string/1</code></a> and <a href=\"#unescape_string/2\"><code class=\"inline\">unescape_string/2</code></a> for more information about unescaping.</p> <p>Only tokens that are binaries are unescaped, all others are ignored. This function is useful when implementing your own sigils. Check the implementation of <a href=\"kernel#sigil_s/2\"><code class=\"inline\">Kernel.sigil_s/2</code></a> for examples.</p>    <h3 class=\"detail-header function\" id=\"unescape_tokens/2\">  <span class=\"signature\">unescape_tokens(tokens, map)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unescape_tokens([<a href=\"macro#t:t/0\">Macro.t</a>], (non_neg_integer -&gt; non_neg_integer | false)) :: [<a href=\"macro#t:t/0\">Macro.t</a>]</code></pre>    <p>Unescapes the given tokens according to the given map.</p> <p>Check <a href=\"#unescape_tokens/1\"><code class=\"inline\">unescape_tokens/1</code></a> and <a href=\"#unescape_string/2\"><code class=\"inline\">unescape_string/2</code></a> for more information.</p>    <h3 class=\"detail-header function\" id=\"unpipe/1\">  <span class=\"signature\">unpipe(expr)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unpipe(<a href=\"macro#t:t/0\">Macro.t</a>) :: [<a href=\"macro#t:t/0\">Macro.t</a>]</code></pre>    <p>Breaks a pipeline expression into a list.</p> <p>The AST for a pipeline (a sequence of applications of <code class=\"inline\">|&gt;</code>) is similar to the AST of a sequence of binary operators or function applications: the top-level expression is the right-most <code class=\"inline\">:|&gt;</code> (which is the last one to be executed), and its left-hand and right-hand sides are its arguments:</p> <pre data-language=\"elixir\"><code class=\"elixir\">quote do: 100 |&gt; div(5) |&gt; div(2)\n#=&gt; {:|&gt;, _, [arg1, arg2]}</code></pre> <p>In the example above, the <code class=\"inline\">|&gt;</code> pipe is the right-most pipe; <code class=\"inline\">arg1</code> is the AST for <code class=\"inline\">100 |&gt; div(5)</code>, and <code class=\"inline\">arg2</code> is the AST for <code class=\"inline\">div(2)</code>.</p> <p>It’s often useful to have the AST for such a pipeline as a list of function applications. This function does exactly that:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Macro.unpipe(quote do: 100 |&gt; div(5) |&gt; div(2))\n#=&gt; [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}]</code></pre> <p>We get a list that follows the pipeline directly: first the <code class=\"inline\">100</code>, then the <code class=\"inline\">div(5)</code> (more precisely, its AST), then <code class=\"inline\">div(2)</code>. The <code class=\"inline\">0</code> as the second element of the tuples is the position of the previous element in the pipeline inside the current function application: <code class=\"inline\">{{:div, [], [5]}, 0}</code> means that the previous element (<code class=\"inline\">100</code>) will be inserted as the 0th (first) argument to the <code class=\"inline\">div/2</code> function, so that the AST for that function will become <code class=\"inline\">{:div, [],\n[100, 5]}</code> (<code class=\"inline\">div(100, 5)</code>).</p>    <h3 class=\"detail-header function\" id=\"update_meta/2\">  <span class=\"signature\">update_meta(quoted, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update_meta(<a href=\"#t:t/0\">t</a>, (<a href=\"keyword#t:t/0\">Keyword.t</a> -&gt; <a href=\"keyword#t:t/0\">Keyword.t</a>)) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Applies the given function to the node metadata if it contains one.</p> <p>This is often useful when used with <a href=\"macro#prewalk/2\"><code class=\"inline\">Macro.prewalk/2</code></a> to remove information like lines and hygienic counters from the expression for either storage or comparison.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; quoted = quote line: 10, do: sample()\n{:sample, [line: 10], []}\niex&gt; Macro.update_meta(quoted, &amp;Keyword.delete(&amp;1, :line))\n{:sample, [], []}</code></pre>    <h3 class=\"detail-header function\" id=\"validate/1\">  <span class=\"signature\">validate(expr)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">validate(term) :: :ok | {:error, term}</code></pre>    <p>Validates the given expressions are valid quoted expressions.</p> <p>Checks the <code class=\"inline\">type:Macro.t</code> for the specification of a valid quoted expression.</p> <p>It returns <code class=\"inline\">:ok</code> if the expression is valid. Otherwise it returns a tuple in the form of <code class=\"inline\">{:error, remainder}</code> where <code class=\"inline\">remainder</code> is the invalid part of the quoted expression.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Macro.validate({:two_element, :tuple})\n:ok\niex&gt; Macro.validate({:three, :element, :tuple})\n{:error, {:three, :element, :tuple}}\n\niex&gt; Macro.validate([1, 2, 3])\n:ok\niex&gt; Macro.validate([1, 2, 3, {4}])\n{:error, {4}}</code></pre>    <h3 class=\"detail-header function\" id=\"var/2\">  <span class=\"signature\">var(var, context)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">var(var, context) :: {var, [], context} when var: atom, context: atom</code></pre>    <p>Generates an AST node representing the variable given by the atoms <code class=\"inline\">var</code> and <code class=\"inline\">context</code>.</p> <h4>Examples</h4> <p>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be <code class=\"inline\">__MODULE__</code>:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Macro.var(:foo, __MODULE__)\n{:foo, [], __MODULE__}</code></pre> <p>However, if there is a need to access the user variable, nil can be given:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Macro.var(:foo, nil)\n{:foo, [], nil}</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Macro.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Macro.html</a>\n  </p>\n</div>\n","elixir/map":"<h1>  Map  </h1>  <p>A set of functions for working with maps.</p> <p>Maps are key-value stores where keys can be any value and are compared using the match operator (<code class=\"inline\">===</code>). Maps can be created with the <code class=\"inline\">%{}</code> special form defined in the <a href=\"kernel.specialforms\"><code class=\"inline\">Kernel.SpecialForms</code></a> module.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:key/0\">key()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:value/0\">value()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#delete/2\">delete(map, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes the entries in <code class=\"inline\">map</code> for a specific <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#drop/2\">drop(map, keys)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Drops the given <code class=\"inline\">keys</code> from <code class=\"inline\">map</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#equal?/2\">equal?(map1, map2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if two maps are equal</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch/2\">fetch(map, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches the value for a specific <code class=\"inline\">key</code> and returns it in a tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch!/2\">fetch!(map, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fetches the value for specific <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_struct/1\">from_struct(struct)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a <code class=\"inline\">struct</code> to map</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get/3\">get(map, key, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the value for a specific <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_and_update/3\">get_and_update(map, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the value from <code class=\"inline\">key</code> and updates it, all in one pass</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_and_update!/3\">get_and_update!(map, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the value from <code class=\"inline\">key</code> and updates it. Raises if there is no <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_lazy/3\">get_lazy(map, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the value for a specific <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#has_key?/2\">has_key?(map, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns whether a given <code class=\"inline\">key</code> exists in the given <code class=\"inline\">map</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#keys/1\">keys(map)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all keys from <code class=\"inline\">map</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#merge/2\">merge(map1, map2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Merges two maps into one</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#merge/3\">merge(map1, map2, callback)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Merges two maps into one</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/0\">new()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a new empty map</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/1\">new(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a map from an <code class=\"inline\">enumerable</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/2\">new(enumerable, transform)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a map from an <code class=\"inline\">enumerable</code> via the transformation function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pop/3\">pop(map, key, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns and removes the value associated with <code class=\"inline\">key</code> in <code class=\"inline\">map</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pop_lazy/3\">pop_lazy(map, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Lazily returns and removes the value associated with <code class=\"inline\">key</code> in <code class=\"inline\">map</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put/3\">put(map, key, val)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts the given <code class=\"inline\">value</code> under <code class=\"inline\">key</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_new/3\">put_new(map, key, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts the given <code class=\"inline\">value</code> under <code class=\"inline\">key</code> unless the entry <code class=\"inline\">key</code> already exists</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_new_lazy/3\">put_new_lazy(map, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Evaluates <code class=\"inline\">fun</code> and puts the result under <code class=\"inline\">key</code> in map unless <code class=\"inline\">key</code> is already present</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#split/2\">split(map, keys)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Takes all entries corresponding to the given <code class=\"inline\">keys</code> and extracts them into a separate <code class=\"inline\">map</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#take/2\">take(map, keys)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Takes all entries corresponding to the given keys and returns them in a new map</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_list/1\">to_list(map)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts <code class=\"inline\">map</code> to a list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update/4\">update(map, key, initial, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates the <code class=\"inline\">key</code> in <code class=\"inline\">map</code> with the given function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update!/3\">update!(map, key, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates the <code class=\"inline\">key</code> with the given function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#values/1\">values(map)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all values from <code class=\"inline\">map</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:key/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:key/0\">key</a> :: any</code></pre> </div> <div id=\"t:value/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:value/0\">value</a> :: any</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"delete/2\">  <span class=\"signature\">delete(map, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete(map, <a href=\"#t:key/0\">key</a>) :: map</code></pre>    <p>Deletes the entries in <code class=\"inline\">map</code> for a specific <code class=\"inline\">key</code>.</p> <p>If the <code class=\"inline\">key</code> does not exist, returns <code class=\"inline\">map</code> unchanged.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.delete(%{a: 1, b: 2}, :a)\n%{b: 2}\niex&gt; Map.delete(%{b: 2}, :a)\n%{b: 2}</code></pre>    <h3 class=\"detail-header function\" id=\"drop/2\">  <span class=\"signature\">drop(map, keys)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">drop(map, <a href=\"enumerable#t:t/0\">Enumerable.t</a>) :: map</code></pre>    <p>Drops the given <code class=\"inline\">keys</code> from <code class=\"inline\">map</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n%{a: 1, c: 3}</code></pre>    <h3 class=\"detail-header function\" id=\"equal?/2\">  <span class=\"signature\">equal?(map1, map2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">equal?(map, map) :: boolean</code></pre>    <p>Checks if two maps are equal.</p> <p>Two maps are considered to be equal if they contain the same keys and those keys contain the same values.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\ntrue\niex&gt; Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"fetch/2\">  <span class=\"signature\">fetch(map, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch(map, <a href=\"#t:key/0\">key</a>) :: {:ok, <a href=\"#t:value/0\">value</a>} | :error</code></pre>    <p>Fetches the value for a specific <code class=\"inline\">key</code> and returns it in a tuple.</p> <p>If the <code class=\"inline\">key</code> does not exist, returns <code class=\"inline\">:error</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.fetch(%{a: 1}, :a)\n{:ok, 1}\niex&gt; Map.fetch(%{a: 1}, :b)\n:error</code></pre>    <h3 class=\"detail-header function\" id=\"fetch!/2\">  <span class=\"signature\">fetch!(map, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch!(map, <a href=\"#t:key/0\">key</a>) :: <a href=\"#t:value/0\">value</a> | no_return</code></pre>    <p>Fetches the value for specific <code class=\"inline\">key</code>.</p> <p>If <code class=\"inline\">key</code> does not exist, a <a href=\"keyerror\"><code class=\"inline\">KeyError</code></a> is raised.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.fetch!(%{a: 1}, :a)\n1\niex&gt; Map.fetch!(%{a: 1}, :b)\n** (KeyError) key :b not found in: %{a: 1}</code></pre>    <h3 class=\"detail-header function\" id=\"from_struct/1\">  <span class=\"signature\">from_struct(struct)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_struct(atom | struct) :: map</code></pre>    <p>Converts a <code class=\"inline\">struct</code> to map.</p> <p>It accepts the struct module or a struct itself and simply removes the <code class=\"inline\">__struct__</code> field from the struct.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  defstruct [:name]\nend\n\nMap.from_struct(User)\n#=&gt; %{name: nil}\n\nMap.from_struct(%User{name: \"john\"})\n#=&gt; %{name: \"john\"}</code></pre>    <h3 class=\"detail-header function\" id=\"get/3\">  <span class=\"signature\">get(map, key, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get(map, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: <a href=\"#t:value/0\">value</a></code></pre>    <p>Gets the value for a specific <code class=\"inline\">key</code>.</p> <p>If <code class=\"inline\">key</code> does not exist, return the default value (<code class=\"inline\">nil</code> if no default value).</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.get(%{}, :a)\nnil\niex&gt; Map.get(%{a: 1}, :a)\n1\niex&gt; Map.get(%{a: 1}, :b)\nnil\niex&gt; Map.get(%{a: 1}, :b, 3)\n3</code></pre>    <h3 class=\"detail-header function\" id=\"get_and_update/3\">  <span class=\"signature\">get_and_update(map, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_and_update(map, <a href=\"#t:key/0\">key</a>, (<a href=\"#t:value/0\">value</a> -&gt; {get, <a href=\"#t:value/0\">value</a>} | :pop)) :: {get, map} when get: term</code></pre>    <p>Gets the value from <code class=\"inline\">key</code> and updates it, all in one pass.</p> <p>This <code class=\"inline\">fun</code> argument receives the value of <code class=\"inline\">key</code> (or <code class=\"inline\">nil</code> if <code class=\"inline\">key</code> is not present) and must return a two-element tuple: the “get” value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class=\"inline\">key</code>. The <code class=\"inline\">fun</code> may also return <code class=\"inline\">:pop</code>, implying the current value shall be removed from <code class=\"inline\">map</code> and returned.</p> <p>The returned value is a tuple with the “get” value returned by <code class=\"inline\">fun</code> and a new map with the updated value under <code class=\"inline\">key</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.get_and_update(%{a: 1}, :a, fn current_value -&gt;\n...&gt;   {current_value, \"new value!\"}\n...&gt; end)\n{1, %{a: \"new value!\"}}\n\niex&gt; Map.get_and_update(%{a: 1}, :b, fn current_value -&gt;\n...&gt;   {current_value, \"new value!\"}\n...&gt; end)\n{nil, %{b: \"new value!\", a: 1}}\n\niex&gt; Map.get_and_update(%{a: 1}, :a, fn _ -&gt; :pop end)\n{1, %{}}\n\niex&gt; Map.get_and_update(%{a: 1}, :b, fn _ -&gt; :pop end)\n{nil, %{a: 1}}</code></pre>    <h3 class=\"detail-header function\" id=\"get_and_update!/3\">  <span class=\"signature\">get_and_update!(map, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_and_update!(map, <a href=\"#t:key/0\">key</a>, (<a href=\"#t:value/0\">value</a> -&gt; {get, <a href=\"#t:value/0\">value</a>})) ::\n  {get, map} |\n  no_return when get: term</code></pre>    <p>Gets the value from <code class=\"inline\">key</code> and updates it. Raises if there is no <code class=\"inline\">key</code>.</p> <p>This <code class=\"inline\">fun</code> argument receives the value of <code class=\"inline\">key</code> and must return a two-element tuple: the “get” value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class=\"inline\">key</code>.</p> <p>The returned value is a tuple with the “get” value returned by <code class=\"inline\">fun</code> and a new map with the updated value under <code class=\"inline\">key</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.get_and_update!(%{a: 1}, :a, fn current_value -&gt;\n...&gt;   {current_value, \"new value!\"}\n...&gt; end)\n{1, %{a: \"new value!\"}}\n\niex&gt; Map.get_and_update!(%{a: 1}, :b, fn current_value -&gt;\n...&gt;   {current_value, \"new value!\"}\n...&gt; end)\n** (KeyError) key :b not found\n\niex&gt; Map.get_and_update!(%{a: 1}, :a, fn _ -&gt;\n...&gt;   :pop\n...&gt; end)\n{1, %{}}</code></pre>    <h3 class=\"detail-header function\" id=\"get_lazy/3\">  <span class=\"signature\">get_lazy(map, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_lazy(map, <a href=\"#t:key/0\">key</a>, (() -&gt; <a href=\"#t:value/0\">value</a>)) :: <a href=\"#t:value/0\">value</a></code></pre>    <p>Gets the value for a specific <code class=\"inline\">key</code>.</p> <p>If <code class=\"inline\">key</code> does not exist, lazily evaluates <code class=\"inline\">fun</code> and returns its result.</p> <p>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; map = %{a: 1}\niex&gt; fun = fn -&gt;\n...&gt;   # some expensive operation here\n...&gt;   13\n...&gt; end\niex&gt; Map.get_lazy(map, :a, fun)\n1\niex&gt; Map.get_lazy(map, :b, fun)\n13</code></pre>    <h3 class=\"detail-header function\" id=\"has_key?/2\">  <span class=\"signature\">has_key?(map, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">has_key?(map, <a href=\"#t:key/0\">key</a>) :: boolean</code></pre>    <p>Returns whether a given <code class=\"inline\">key</code> exists in the given <code class=\"inline\">map</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.has_key?(%{a: 1}, :a)\ntrue\niex&gt; Map.has_key?(%{a: 1}, :b)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"keys/1\">  <span class=\"signature\">keys(map)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">keys(map) :: [<a href=\"#t:key/0\">key</a>]</code></pre>    <p>Returns all keys from <code class=\"inline\">map</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.keys(%{a: 1, b: 2})\n[:a, :b]</code></pre>    <h3 class=\"detail-header function\" id=\"merge/2\">  <span class=\"signature\">merge(map1, map2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">merge(map, map) :: map</code></pre>    <p>Merges two maps into one.</p> <p>All keys in <code class=\"inline\">map2</code> will be added to <code class=\"inline\">map1</code>, overriding any existing one.</p> <p>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use <a href=\"kernel#struct/2\"><code class=\"inline\">Kernel.struct/2</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n%{a: 3, b: 2, d: 4}</code></pre>    <h3 class=\"detail-header function\" id=\"merge/3\">  <span class=\"signature\">merge(map1, map2, callback)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">merge(map, map, (<a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>, <a href=\"#t:value/0\">value</a> -&gt; <a href=\"#t:value/0\">value</a>)) :: map</code></pre>    <p>Merges two maps into one.</p> <p>All keys in <code class=\"inline\">map2</code> will be added to <code class=\"inline\">map1</code>. The given function will be invoked with the key, value1 and value2 to solve conflicts.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 -&gt;\n...&gt;   v1 + v2\n...&gt; end)\n%{a: 4, b: 2, d: 4}</code></pre>    <h3 class=\"detail-header function\" id=\"new/0\">  <span class=\"signature\">new()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new :: map</code></pre>    <p>Returns a new empty map.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.new\n%{}</code></pre>    <h3 class=\"detail-header function\" id=\"new/1\">  <span class=\"signature\">new(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new(<a href=\"enum#t:t/0\">Enum.t</a>) :: map</code></pre>    <p>Creates a map from an <code class=\"inline\">enumerable</code>.</p> <p>Duplicated keys are removed; the latest one prevails.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.new([{:b, 1}, {:a, 2}])\n%{a: 2, b: 1}\niex&gt; Map.new([a: 1, a: 2, a: 3])\n%{a: 3}</code></pre>    <h3 class=\"detail-header function\" id=\"new/2\">  <span class=\"signature\">new(enumerable, transform)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new(<a href=\"enum#t:t/0\">Enum.t</a>, (term -&gt; {<a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>})) :: map</code></pre>    <p>Creates a map from an <code class=\"inline\">enumerable</code> via the transformation function.</p> <p>Duplicated keys are removed; the latest one prevails.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.new([:a, :b], fn x -&gt; {x, x} end)\n%{a: :a, b: :b}</code></pre>    <h3 class=\"detail-header function\" id=\"pop/3\">  <span class=\"signature\">pop(map, key, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">pop(map, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: {<a href=\"#t:value/0\">value</a>, map}</code></pre>    <p>Returns and removes the value associated with <code class=\"inline\">key</code> in <code class=\"inline\">map</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.pop(%{a: 1}, :a)\n{1, %{}}\niex&gt; Map.pop(%{a: 1}, :b)\n{nil, %{a: 1}}\niex&gt; Map.pop(%{a: 1}, :b, 3)\n{3, %{a: 1}}</code></pre>    <h3 class=\"detail-header function\" id=\"pop_lazy/3\">  <span class=\"signature\">pop_lazy(map, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">pop_lazy(map, <a href=\"#t:key/0\">key</a>, (() -&gt; <a href=\"#t:value/0\">value</a>)) :: {<a href=\"#t:value/0\">value</a>, map}</code></pre>    <p>Lazily returns and removes the value associated with <code class=\"inline\">key</code> in <code class=\"inline\">map</code>.</p> <p>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; map = %{a: 1}\niex&gt; fun = fn -&gt;\n...&gt;   # some expensive operation here\n...&gt;   13\n...&gt; end\niex&gt; Map.pop_lazy(map, :a, fun)\n{1, %{}}\niex&gt; Map.pop_lazy(map, :b, fun)\n{13, %{a: 1}}</code></pre>    <h3 class=\"detail-header function\" id=\"put/3\">  <span class=\"signature\">put(map, key, val)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put(map, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: map</code></pre>    <p>Puts the given <code class=\"inline\">value</code> under <code class=\"inline\">key</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.put(%{a: 1}, :b, 2)\n%{a: 1, b: 2}\niex&gt; Map.put(%{a: 1, b: 2}, :a, 3)\n%{a: 3, b: 2}</code></pre>    <h3 class=\"detail-header function\" id=\"put_new/3\">  <span class=\"signature\">put_new(map, key, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_new(map, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>) :: map</code></pre>    <p>Puts the given <code class=\"inline\">value</code> under <code class=\"inline\">key</code> unless the entry <code class=\"inline\">key</code> already exists.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.put_new(%{a: 1}, :b, 2)\n%{b: 2, a: 1}\niex&gt; Map.put_new(%{a: 1, b: 2}, :a, 3)\n%{a: 1, b: 2}</code></pre>    <h3 class=\"detail-header function\" id=\"put_new_lazy/3\">  <span class=\"signature\">put_new_lazy(map, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_new_lazy(map, <a href=\"#t:key/0\">key</a>, (() -&gt; <a href=\"#t:value/0\">value</a>)) :: map</code></pre>    <p>Evaluates <code class=\"inline\">fun</code> and puts the result under <code class=\"inline\">key</code> in map unless <code class=\"inline\">key</code> is already present.</p> <p>This is useful if the value is very expensive to calculate or generally difficult to setup and teardown again.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; map = %{a: 1}\niex&gt; fun = fn -&gt;\n...&gt;   # some expensive operation here\n...&gt;   3\n...&gt; end\niex&gt; Map.put_new_lazy(map, :a, fun)\n%{a: 1}\niex&gt; Map.put_new_lazy(map, :b, fun)\n%{a: 1, b: 3}</code></pre>    <h3 class=\"detail-header function\" id=\"split/2\">  <span class=\"signature\">split(map, keys)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">split(map, <a href=\"enumerable#t:t/0\">Enumerable.t</a>) :: {map, map}</code></pre>    <p>Takes all entries corresponding to the given <code class=\"inline\">keys</code> and extracts them into a separate <code class=\"inline\">map</code>.</p> <p>Returns a tuple with the new map and the old map with removed keys.</p> <p>Keys for which there are no entries in <code class=\"inline\">map</code> are ignored.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n{%{a: 1, c: 3}, %{b: 2}}</code></pre>    <h3 class=\"detail-header function\" id=\"take/2\">  <span class=\"signature\">take(map, keys)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">take(map, <a href=\"enumerable#t:t/0\">Enumerable.t</a>) :: map</code></pre>    <p>Takes all entries corresponding to the given keys and returns them in a new map.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n%{a: 1, c: 3}</code></pre>    <h3 class=\"detail-header function\" id=\"to_list/1\">  <span class=\"signature\">to_list(map)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_list(map) :: [{term, term}]</code></pre>    <p>Converts <code class=\"inline\">map</code> to a list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.to_list(%{a: 1})\n[a: 1]\niex&gt; Map.to_list(%{1 =&gt; 2})\n[{1, 2}]</code></pre>    <h3 class=\"detail-header function\" id=\"update/4\">  <span class=\"signature\">update(map, key, initial, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update(map, <a href=\"#t:key/0\">key</a>, <a href=\"#t:value/0\">value</a>, (<a href=\"#t:value/0\">value</a> -&gt; <a href=\"#t:value/0\">value</a>)) :: map</code></pre>    <p>Updates the <code class=\"inline\">key</code> in <code class=\"inline\">map</code> with the given function.</p> <p>If the <code class=\"inline\">key</code> does not exist, inserts the given <code class=\"inline\">initial</code> value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.update(%{a: 1}, :a, 13, &amp;(&amp;1 * 2))\n%{a: 2}\niex&gt; Map.update(%{a: 1}, :b, 11, &amp;(&amp;1 * 2))\n%{a: 1, b: 11}</code></pre>    <h3 class=\"detail-header function\" id=\"update!/3\">  <span class=\"signature\">update!(map, key, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update!(map, <a href=\"#t:key/0\">key</a>, (<a href=\"#t:value/0\">value</a> -&gt; <a href=\"#t:value/0\">value</a>)) ::\n  map |\n  no_return</code></pre>    <p>Updates the <code class=\"inline\">key</code> with the given function.</p> <p>If the <code class=\"inline\">key</code> does not exist, raises <a href=\"keyerror\"><code class=\"inline\">KeyError</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.update!(%{a: 1}, :a, &amp;(&amp;1 * 2))\n%{a: 2}\n\niex&gt; Map.update!(%{a: 1}, :b, &amp;(&amp;1 * 2))\n** (KeyError) key :b not found</code></pre>    <h3 class=\"detail-header function\" id=\"values/1\">  <span class=\"signature\">values(map)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">values(map) :: [<a href=\"#t:value/0\">value</a>]</code></pre>    <p>Returns all values from <code class=\"inline\">map</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Map.values(%{a: 1, b: 2})\n[1, 2]</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Map.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Map.html</a>\n  </p>\n</div>\n","elixir/naivedatetime":"<h1>  NaiveDateTime  </h1>  <p>A NaiveDateTime struct (without a time zone) and functions.</p> <p>The NaiveDateTime struct contains the fields year, month, day, hour, minute, second, microsecond and calendar. New naive date times can be built with the <a href=\"#new/7\"><code class=\"inline\">new/7</code></a> function or using the <code class=\"inline\">~N</code> sigil:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~N[2000-01-01 23:00:07]\n~N[2000-01-01 23:00:07]</code></pre> <p>Both <a href=\"#new/7\"><code class=\"inline\">new/7</code></a> and sigil return a struct where the date fields can be accessed directly:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; naive = ~N[2000-01-01 23:00:07]\niex&gt; naive.year\n2000\niex&gt; naive.second\n7</code></pre> <p>The naive bit implies this datetime representation does not have a timezone. This means the datetime may not actually exist in certain areas in the world even though it is valid.</p> <p>For example, when daylight saving changes are applied by a region, the clock typically moves forward or backward by one hour. This means certain datetimes never occur or may occur more than once. Since <a href=\"naivedatetime#content\"><code class=\"inline\">NaiveDateTime</code></a> is not validated against a timezone, such errors would go unnoticed.</p> <p>Developers should avoid creating the NaiveDateTime struct directly and instead rely on the functions provided by this module as well as the ones in 3rd party calendar libraries.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#from_erl/2\">from_erl(arg, microsecond \\\\ {0, 0})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an Erlang datetime tuple to a <a href=\"naivedatetime#content\"><code class=\"inline\">NaiveDateTime</code></a> struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_erl!/2\">from_erl!(tuple, microsecond \\\\ {0, 0})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an Erlang datetime tuple to a <a href=\"naivedatetime#content\"><code class=\"inline\">NaiveDateTime</code></a> struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_iso8601/1\">from_iso8601(arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses the extended “Date and time of day” format described by ISO8601:2004</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_iso8601!/1\">from_iso8601!(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses the extended “Date and time of day” format described by ISO8601:2004</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/2\">new(date, time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Builds a naive date time from date and time structs</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/7\">new(year, month, day, hour, minute, second, microsecond \\\\ {0, 0})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Builds a new ISO naive date time</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_date/1\">to_date(naive_date_time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a <a href=\"naivedatetime#content\"><code class=\"inline\">NaiveDateTime</code></a> into a <a href=\"date\"><code class=\"inline\">Date</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_erl/1\">to_erl(naive_date_time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a <a href=\"naivedatetime#content\"><code class=\"inline\">NaiveDateTime</code></a> struct to an Erlang datetime tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_iso8601/1\">to_iso8601(naive)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given naive date time to ISO8601</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(naive)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given naive date time to a string according to its calendar</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_time/1\">to_time(naive_date_time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a <a href=\"naivedatetime#content\"><code class=\"inline\">NaiveDateTime</code></a> into <a href=\"time\"><code class=\"inline\">Time</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %NaiveDateTime{calendar: <a href=\"calendar#t:calendar/0\">Calendar.calendar</a>, day: <a href=\"calendar#t:day/0\">Calendar.day</a>, hour: <a href=\"calendar#t:hour/0\">Calendar.hour</a>, microsecond: <a href=\"calendar#t:microsecond/0\">Calendar.microsecond</a>, minute: <a href=\"calendar#t:minute/0\">Calendar.minute</a>, month: <a href=\"calendar#t:month/0\">Calendar.month</a>, second: <a href=\"calendar#t:second/0\">Calendar.second</a>, year: <a href=\"calendar#t:year/0\">Calendar.year</a>}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"from_erl/2\">  <span class=\"signature\">from_erl(arg, microsecond \\\\ {0, 0})</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_erl(:calendar.datetime, <a href=\"calendar#t:microsecond/0\">Calendar.microsecond</a>) ::\n  {:ok, <a href=\"naivedatetime#t:t/0\">NaiveDateTime.t</a>} |\n  {:error, atom}</code></pre>    <p>Converts an Erlang datetime tuple to a <a href=\"naivedatetime#content\"><code class=\"inline\">NaiveDateTime</code></a> struct.</p> <p>Attempting to convert an invalid ISO calendar date will produce an error tuple.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}})\n{:ok, ~N[2000-01-01 13:30:15]}\niex&gt; NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n{:ok, ~N[2000-01-01 13:30:15.005]}\niex&gt; NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n{:error, :invalid_date}\niex&gt; NaiveDateTime.from_erl({{2000, 13, 1},{13, 30, 15}})\n{:error, :invalid_date}</code></pre>    <h3 class=\"detail-header function\" id=\"from_erl!/2\">  <span class=\"signature\">from_erl!(tuple, microsecond \\\\ {0, 0})</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_erl!(:calendar.datetime, <a href=\"calendar#t:microsecond/0\">Calendar.microsecond</a>) ::\n  <a href=\"naivedatetime#t:t/0\">NaiveDateTime.t</a> |\n  no_return</code></pre>    <p>Converts an Erlang datetime tuple to a <a href=\"naivedatetime#content\"><code class=\"inline\">NaiveDateTime</code></a> struct.</p> <p>Raises if the datetime is invalid. Attempting to convert an invalid ISO calendar date will produce an error tuple.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}})\n~N[2000-01-01 13:30:15]\niex&gt; NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n~N[2000-01-01 13:30:15.005]\niex&gt; NaiveDateTime.from_erl!({{2000, 13, 1}, {13, 30, 15}})\n** (ArgumentError) cannot convert {{2000, 13, 1}, {13, 30, 15}} to naive date time, reason: :invalid_date</code></pre>    <h3 class=\"detail-header function\" id=\"from_iso8601/1\">  <span class=\"signature\">from_iso8601(arg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_iso8601(<a href=\"string#t:t/0\">String.t</a>) ::\n  {:ok, <a href=\"naivedatetime#t:t/0\">NaiveDateTime.t</a>} |\n  {:error, atom}</code></pre>    <p>Parses the extended “Date and time of day” format described by ISO8601:2004.</p> <p>Timezone offset may be included in the string but they will be simply discarded as such information is not included in naive date times.</p> <p>As specified in the standard, the separator “T” may be omitted if desired as there is no ambiguity within this function.</p> <p>Time representations with reduced accuracy are not supported.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07\")\n{:ok, ~N[2015-01-23 23:50:07]}\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07\")\n{:ok, ~N[2015-01-23 23:50:07]}\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n{:ok, ~N[2015-01-23 23:50:07]}\n\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0\")\n{:ok, ~N[2015-01-23 23:50:07.0]}\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0123456\")\n{:ok, ~N[2015-01-23 23:50:07.012345]}\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123Z\")\n{:ok, ~N[2015-01-23 23:50:07.123]}\n\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23P23:50:07\")\n{:error, :invalid_format}\niex&gt; NaiveDateTime.from_iso8601(\"2015:01:23 23-50-07\")\n{:error, :invalid_format}\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07A\")\n{:error, :invalid_format}\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23 23:50:61\")\n{:error, :invalid_time}\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-32 23:50:07\")\n{:error, :invalid_date}\n\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n{:ok, ~N[2015-01-23 23:50:07.123]}\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+00:00\")\n{:ok, ~N[2015-01-23 23:50:07.123]}\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-02:30\")\n{:ok, ~N[2015-01-23 23:50:07.123]}\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n{:error, :invalid_format}\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:60\")\n{:error, :invalid_format}\niex&gt; NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-24:00\")\n{:error, :invalid_format}</code></pre>    <h3 class=\"detail-header function\" id=\"from_iso8601!/1\">  <span class=\"signature\">from_iso8601!(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_iso8601!(<a href=\"string#t:t/0\">String.t</a>) ::\n  <a href=\"naivedatetime#t:t/0\">NaiveDateTime.t</a> |\n  no_return</code></pre>    <p>Parses the extended “Date and time of day” format described by ISO8601:2004.</p> <p>Raises if the format is invalid.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07.123Z\")\n~N[2015-01-23 23:50:07.123]\niex&gt; NaiveDateTime.from_iso8601!(\"2015-01-23P23:50:07\")\n** (ArgumentError) cannot parse \"2015-01-23P23:50:07\" as naive date time, reason: :invalid_format</code></pre>    <h3 class=\"detail-header function\" id=\"new/2\">  <span class=\"signature\">new(date, time)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new(<a href=\"date#t:t/0\">Date.t</a>, <a href=\"time#t:t/0\">Time.t</a>) :: {:ok, <a href=\"naivedatetime#t:t/0\">NaiveDateTime.t</a>}</code></pre>    <p>Builds a naive date time from date and time structs.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; NaiveDateTime.new(~D[2010-01-13], ~T[23:00:07.005])\n{:ok, ~N[2010-01-13 23:00:07.005]}</code></pre>    <h3 class=\"detail-header function\" id=\"new/7\">  <span class=\"signature\">new(year, month, day, hour, minute, second, microsecond \\\\ {0, 0})</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new(<a href=\"calendar#t:year/0\">Calendar.year</a>, <a href=\"calendar#t:month/0\">Calendar.month</a>, <a href=\"calendar#t:day/0\">Calendar.day</a>, <a href=\"calendar#t:hour/0\">Calendar.hour</a>, <a href=\"calendar#t:minute/0\">Calendar.minute</a>, <a href=\"calendar#t:second/0\">Calendar.second</a>, <a href=\"calendar#t:microsecond/0\">Calendar.microsecond</a>) ::\n  {:ok, <a href=\"naivedatetime#t:t/0\">NaiveDateTime.t</a>} |\n  {:error, atom}</code></pre>    <p>Builds a new ISO naive date time.</p> <p>Expects all values to be integers. Returns <code class=\"inline\">{:ok, naive_date_time}</code> if each entry fits its appropriate range, returns <code class=\"inline\">{:error, reason}</code> otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; NaiveDateTime.new(2000, 1, 1, 0, 0, 0)\n{:ok, ~N[2000-01-01 00:00:00]}\niex&gt; NaiveDateTime.new(2000, 13, 1, 0, 0, 0)\n{:error, :invalid_date}\niex&gt; NaiveDateTime.new(2000, 2, 29, 0, 0, 0)\n{:ok, ~N[2000-02-29 00:00:00]}\niex&gt; NaiveDateTime.new(2000, 2, 30, 0, 0, 0)\n{:error, :invalid_date}\niex&gt; NaiveDateTime.new(2001, 2, 29, 0, 0, 0)\n{:error, :invalid_date}\n\niex&gt; NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1})\n{:ok, ~N[2000-01-01 23:59:59.0]}\niex&gt; NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 999_999)\n{:ok, ~N[2000-01-01 23:59:59.999999]}\niex&gt; NaiveDateTime.new(2000, 1, 1, 23, 59, 60, 999_999)\n{:ok, ~N[2000-01-01 23:59:60.999999]}\niex&gt; NaiveDateTime.new(2000, 1, 1, 24, 59, 59, 999_999)\n{:error, :invalid_time}\niex&gt; NaiveDateTime.new(2000, 1, 1, 23, 60, 59, 999_999)\n{:error, :invalid_time}\niex&gt; NaiveDateTime.new(2000, 1, 1, 23, 59, 61, 999_999)\n{:error, :invalid_time}\niex&gt; NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 1_000_000)\n{:error, :invalid_time}</code></pre>    <h3 class=\"detail-header function\" id=\"to_date/1\">  <span class=\"signature\">to_date(naive_date_time)</span>  </h3>  <p>Converts a <a href=\"naivedatetime#content\"><code class=\"inline\">NaiveDateTime</code></a> into a <a href=\"date\"><code class=\"inline\">Date</code></a>.</p> <p>Because <a href=\"date\"><code class=\"inline\">Date</code></a> does not hold time information, data will be lost during the conversion.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; NaiveDateTime.to_date(~N[2002-01-13 23:00:07])\n~D[2002-01-13]</code></pre>    <h3 class=\"detail-header function\" id=\"to_erl/1\">  <span class=\"signature\">to_erl(naive_date_time)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_erl(<a href=\"naivedatetime#t:t/0\">NaiveDateTime.t</a>) :: :calendar.datetime</code></pre>    <p>Converts a <a href=\"naivedatetime#content\"><code class=\"inline\">NaiveDateTime</code></a> struct to an Erlang datetime tuple.</p> <p>Only supports converting naive date times which are in the ISO calendar, attempting to convert naive date times from other calendars will raise.</p> <p>WARNING: Loss of precision may occur, as Erlang time tuples only store hour/minute/second.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; NaiveDateTime.to_erl(~N[2000-01-01 13:30:15])\n{{2000, 1, 1}, {13, 30, 15}}</code></pre>    <h3 class=\"detail-header function\" id=\"to_iso8601/1\">  <span class=\"signature\">to_iso8601(naive)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_iso8601(<a href=\"naivedatetime#t:t/0\">NaiveDateTime.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts the given naive date time to ISO8601.</p> <p>Only supports converting naive date times which are in the ISO calendar, attempting to convert naive date times from other calendars will raise.</p> <h3>Examples</h3> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13])\n\"2000-02-28T23:00:13\"\n\niex&gt; NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001])\n\"2000-02-28T23:00:13.001\"</code></pre>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(naive)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_string(<a href=\"naivedatetime#t:t/0\">NaiveDateTime.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts the given naive date time to a string according to its calendar.</p> <h3>Examples</h3> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; NaiveDateTime.to_string(~N[2000-02-28 23:00:13])\n\"2000-02-28 23:00:13\"\n\niex&gt; NaiveDateTime.to_string(~N[2000-02-28 23:00:13.001])\n\"2000-02-28 23:00:13.001\"</code></pre>    <h3 class=\"detail-header function\" id=\"to_time/1\">  <span class=\"signature\">to_time(naive_date_time)</span>  </h3>  <p>Converts a <a href=\"naivedatetime#content\"><code class=\"inline\">NaiveDateTime</code></a> into <a href=\"time\"><code class=\"inline\">Time</code></a>.</p> <p>Because <a href=\"time\"><code class=\"inline\">Time</code></a> does not hold date information, data will be lost during the conversion.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; NaiveDateTime.to_time(~N[2002-01-13 23:00:07])\n~T[23:00:07]</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/NaiveDateTime.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/NaiveDateTime.html</a>\n  </p>\n</div>\n","elixir/node":"<h1>  Node  </h1>  <p>Functions related to VM nodes.</p> <p>Some of the functions in this module are inlined by the compiler, similar to functions in the <a href=\"kernel\"><code class=\"inline\">Kernel</code></a> module and they are explicitly marked in their docs as “inlined by the compiler”. For more information about inlined functions, check out the <a href=\"kernel\"><code class=\"inline\">Kernel</code></a> module.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#alive?/0\">alive?()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the local node is alive</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#connect/1\">connect(node)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Establishes a connection to <code class=\"inline\">node</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#disconnect/1\">disconnect(node)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Forces the disconnection of a node</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_cookie/0\">get_cookie()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the magic cookie of the local node</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#list/0\">list()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of all visible nodes in the system, excluding the local node</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#list/1\">list(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of nodes according to argument given</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#monitor/2\">monitor(node, flag)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Monitors the status of the node</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#monitor/3\">monitor(node, flag, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Behaves as <a href=\"#monitor/2\"><code class=\"inline\">monitor/2</code></a> except that it allows an extra option to be given, namely <code class=\"inline\">:allow_passive_connect</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ping/1\">ping(node)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Tries to set up a connection to node</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#self/0\">self()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current node</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#set_cookie/2\">set_cookie(node \\\\ Node.self(), cookie)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets the magic cookie of <code class=\"inline\">node</code> to the atom <code class=\"inline\">cookie</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn/2\">spawn(node, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the pid of a new process started by the application of <code class=\"inline\">fun</code> on <code class=\"inline\">node</code>. If <code class=\"inline\">node</code> does not exist, a useless pid is returned</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn/3\">spawn(node, fun, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the pid of a new process started by the application of <code class=\"inline\">fun</code> on <code class=\"inline\">node</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn/4\">spawn(node, module, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the pid of a new process started by the application of <code class=\"inline\">module.function(args)</code> on <code class=\"inline\">node</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn/5\">spawn(node, module, fun, args, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the pid of a new process started by the application of <code class=\"inline\">module.function(args)</code> on <code class=\"inline\">node</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn_link/2\">spawn_link(node, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the pid of a new linked process started by the application of <code class=\"inline\">fun</code> on <code class=\"inline\">node</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn_link/4\">spawn_link(node, module, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the pid of a new linked process started by the application of <code class=\"inline\">module.function(args)</code> on <code class=\"inline\">node</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start/3\">start(name, type \\\\ :longnames, tick_time \\\\ 15000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Turns a non-distributed node into a distributed node</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stop/0\">stop()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Turns a distributed node into a non-distributed node</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: node</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"alive?/0\">  <span class=\"signature\">alive?()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">alive? :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if the local node is alive.</p> <p>That is, if the node can be part of a distributed system.</p>    <h3 class=\"detail-header function\" id=\"connect/1\">  <span class=\"signature\">connect(node)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">connect(<a href=\"#t:t/0\">t</a>) :: boolean | :ignored</code></pre>    <p>Establishes a connection to <code class=\"inline\">node</code>.</p> <p>Returns <code class=\"inline\">true</code> if successful, <code class=\"inline\">false</code> if not, and the atom <code class=\"inline\">:ignored</code> if the local node is not alive.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/net_kernel.html#connect_node-1\"><code class=\"inline\">:erlang.connect_node/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"disconnect/1\">  <span class=\"signature\">disconnect(node)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">disconnect(<a href=\"#t:t/0\">t</a>) :: boolean | :ignored</code></pre>    <p>Forces the disconnection of a node.</p> <p>This will appear to the <code class=\"inline\">node</code> as if the local node has crashed. This function is mainly used in the Erlang network authentication protocols. Returns <code class=\"inline\">true</code> if disconnection succeeds, otherwise <code class=\"inline\">false</code>. If the local node is not alive, the function returns <code class=\"inline\">:ignored</code>.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#disconnect_node-1\"><code class=\"inline\">:erlang.disconnect_node/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"get_cookie/0\">  <span class=\"signature\">get_cookie()</span>  </h3>  <p>Returns the magic cookie of the local node.</p> <p>Returns the cookie if the node is alive, otherwise <code class=\"inline\">:nocookie</code>.</p>    <h3 class=\"detail-header function\" id=\"list/0\">  <span class=\"signature\">list()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">list :: [<a href=\"#t:t/0\">t</a>]</code></pre>    <p>Returns a list of all visible nodes in the system, excluding the local node.</p> <p>Same as <code class=\"inline\">list(:visible)</code>.</p>    <h3 class=\"detail-header function\" id=\"list/1\">  <span class=\"signature\">list(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">list(state | [state]) :: [<a href=\"#t:t/0\">t</a>]</code></pre>    <p>Returns a list of nodes according to argument given.</p> <p>The result returned when the argument is a list, is the list of nodes satisfying the disjunction(s) of the list elements.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#nodes-1\"><code class=\"inline\">:erlang.nodes/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"monitor/2\">  <span class=\"signature\">monitor(node, flag)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">monitor(<a href=\"#t:t/0\">t</a>, boolean) :: true</code></pre>    <p>Monitors the status of the node.</p> <p>If <code class=\"inline\">flag</code> is <code class=\"inline\">true</code>, monitoring is turned on. If <code class=\"inline\">flag</code> is <code class=\"inline\">false</code>, monitoring is turned off.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#monitor_node-2\"><code class=\"inline\">:erlang.monitor_node/2</code></a>.</p>    <h3 class=\"detail-header function\" id=\"monitor/3\">  <span class=\"signature\">monitor(node, flag, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">monitor(<a href=\"#t:t/0\">t</a>, boolean, [:allow_passive_connect]) :: true</code></pre>    <p>Behaves as <a href=\"#monitor/2\"><code class=\"inline\">monitor/2</code></a> except that it allows an extra option to be given, namely <code class=\"inline\">:allow_passive_connect</code>.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#monitor_node-3\"><code class=\"inline\">:erlang.monitor_node/3</code></a>.</p>    <h3 class=\"detail-header function\" id=\"ping/1\">  <span class=\"signature\">ping(node)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">ping(<a href=\"#t:t/0\">t</a>) :: :pong | :pang</code></pre>    <p>Tries to set up a connection to node.</p> <p>Returns <code class=\"inline\">:pang</code> if it fails, or <code class=\"inline\">:pong</code> if it is successful.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Node.ping(:unknown_node)\n:pang</code></pre>    <h3 class=\"detail-header function\" id=\"self/0\">  <span class=\"signature\">self()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">self :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns the current node.</p> <p>It returns the same as the built-in <code class=\"inline\">node()</code>.</p>    <h3 class=\"detail-header function\" id=\"set_cookie/2\">  <span class=\"signature\">set_cookie(node \\\\ Node.self(), cookie)</span>  </h3>  <p>Sets the magic cookie of <code class=\"inline\">node</code> to the atom <code class=\"inline\">cookie</code>.</p> <p>The default node is <a href=\"node#self/0\"><code class=\"inline\">Node.self/0</code></a>, the local node. If <code class=\"inline\">node</code> is the local node, the function also sets the cookie of all other unknown nodes to <code class=\"inline\">cookie</code>.</p> <p>This function will raise <a href=\"functionclauseerror\"><code class=\"inline\">FunctionClauseError</code></a> if the given <code class=\"inline\">node</code> is not alive.</p>    <h3 class=\"detail-header function\" id=\"spawn/2\">  <span class=\"signature\">spawn(node, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn(<a href=\"#t:t/0\">t</a>, (() -&gt; any)) :: pid</code></pre>    <p>Returns the pid of a new process started by the application of <code class=\"inline\">fun</code> on <code class=\"inline\">node</code>. If <code class=\"inline\">node</code> does not exist, a useless pid is returned.</p> <p>For the list of available options, see <a href=\"http://www.erlang.org/doc/man/erlang.html#spawn-2\"><code class=\"inline\">:erlang.spawn/2</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"spawn/3\">  <span class=\"signature\">spawn(node, fun, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn(<a href=\"#t:t/0\">t</a>, (() -&gt; any), <a href=\"process#t:spawn_opts/0\">Process.spawn_opts</a>) ::\n  pid |\n  {pid, reference}</code></pre>    <p>Returns the pid of a new process started by the application of <code class=\"inline\">fun</code> on <code class=\"inline\">node</code>.</p> <p>If <code class=\"inline\">node</code> does not exist, a useless pid is returned.</p> <p>For the list of available options, see <a href=\"http://www.erlang.org/doc/man/erlang.html#spawn_opt-3\"><code class=\"inline\">:erlang.spawn_opt/3</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"spawn/4\">  <span class=\"signature\">spawn(node, module, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn(<a href=\"#t:t/0\">t</a>, module, atom, [any]) :: pid</code></pre>    <p>Returns the pid of a new process started by the application of <code class=\"inline\">module.function(args)</code> on <code class=\"inline\">node</code>.</p> <p>If <code class=\"inline\">node</code> does not exist, a useless pid is returned.</p> <p>For the list of available options, see <a href=\"http://www.erlang.org/doc/man/erlang.html#spawn-4\"><code class=\"inline\">:erlang.spawn/4</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"spawn/5\">  <span class=\"signature\">spawn(node, module, fun, args, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn(<a href=\"#t:t/0\">t</a>, module, atom, [any], <a href=\"process#t:spawn_opts/0\">Process.spawn_opts</a>) ::\n  pid |\n  {pid, reference}</code></pre>    <p>Returns the pid of a new process started by the application of <code class=\"inline\">module.function(args)</code> on <code class=\"inline\">node</code>.</p> <p>If <code class=\"inline\">node</code> does not exist, a useless pid is returned.</p> <p>For the list of available options, see <a href=\"http://www.erlang.org/doc/man/erlang.html#spawn_opt-5\"><code class=\"inline\">:erlang.spawn/5</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"spawn_link/2\">  <span class=\"signature\">spawn_link(node, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn_link(<a href=\"#t:t/0\">t</a>, (() -&gt; any)) :: pid</code></pre>    <p>Returns the pid of a new linked process started by the application of <code class=\"inline\">fun</code> on <code class=\"inline\">node</code>.</p> <p>A link is created between the calling process and the new process, atomically. If <code class=\"inline\">node</code> does not exist, a useless pid is returned (and due to the link, an exit signal with exit reason <code class=\"inline\">:noconnection</code> will be received).</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"spawn_link/4\">  <span class=\"signature\">spawn_link(node, module, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn_link(<a href=\"#t:t/0\">t</a>, module, atom, [any]) :: pid</code></pre>    <p>Returns the pid of a new linked process started by the application of <code class=\"inline\">module.function(args)</code> on <code class=\"inline\">node</code>.</p> <p>A link is created between the calling process and the new process, atomically. If <code class=\"inline\">node</code> does not exist, a useless pid is returned (and due to the link, an exit signal with exit reason <code class=\"inline\">:noconnection</code> will be received).</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"start/3\">  <span class=\"signature\">start(name, type \\\\ :longnames, tick_time \\\\ 15000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start(node, :longnames | :shortnames, non_neg_integer) ::\n  {:ok, pid} |\n  {:error, term}</code></pre>    <p>Turns a non-distributed node into a distributed node.</p> <p>This functionality starts the <code class=\"inline\">:net_kernel</code> and other related processes.</p>    <h3 class=\"detail-header function\" id=\"stop/0\">  <span class=\"signature\">stop()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stop :: :ok | {:error, :not_allowed | :not_found}</code></pre>    <p>Turns a distributed node into a non-distributed node.</p> <p>For other nodes in the network, this is the same as the node going down. Only possible when the node was started with <a href=\"node#start/3\"><code class=\"inline\">Node.start/3</code></a>, otherwise returns <code class=\"inline\">{:error, :not_allowed}</code>. Returns <code class=\"inline\">{:error, :not_found}</code> if the local node is not alive.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Node.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Node.html</a>\n  </p>\n</div>\n","elixir/optionparser":"<h1>  OptionParser  </h1>  <p>This module contains functions to parse command line options.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:argv/0\">argv()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:errors/0\">errors()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:options/0\">options()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:parsed/0\">parsed()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#next/2\">next(argv, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Low-level function that parses one option</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#parse/2\">parse(argv, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses <code class=\"inline\">argv</code> into a keywords list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#parse!/2\">parse!(argv, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>The same as <a href=\"#parse/2\"><code class=\"inline\">parse/2</code></a> but raises an <a href=\"optionparser.parseerror\"><code class=\"inline\">OptionParser.ParseError</code></a> exception if any invalid options are given</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#parse_head/2\">parse_head(argv, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Similar to <a href=\"#parse/2\"><code class=\"inline\">parse/2</code></a> but only parses the head of <code class=\"inline\">argv</code>; as soon as it finds a non-switch, it stops parsing</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#parse_head!/2\">parse_head!(argv, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>The same as <a href=\"#parse_head/2\"><code class=\"inline\">parse_head/2</code></a> but raises an <a href=\"optionparser.parseerror\"><code class=\"inline\">OptionParser.ParseError</code></a> exception if any invalid options are given</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#split/1\">split(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Splits a string into argv chunks</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_argv/1\">to_argv(enum)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a key-value enumerable and converts it to argv</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:argv/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:argv/0\">argv</a> :: [<a href=\"string#t:t/0\">String.t</a>]</code></pre> </div> <div id=\"t:errors/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:errors/0\">errors</a> :: [{<a href=\"string#t:t/0\">String.t</a>, <a href=\"string#t:t/0\">String.t</a> | nil}]</code></pre> </div> <div id=\"t:options/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:options/0\">options</a> :: [switches: <a href=\"keyword#t:t/0\">Keyword.t</a>, strict: <a href=\"keyword#t:t/0\">Keyword.t</a>, aliases: <a href=\"keyword#t:t/0\">Keyword.t</a>]</code></pre> </div> <div id=\"t:parsed/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:parsed/0\">parsed</a> :: <a href=\"keyword#t:t/0\">Keyword.t</a></code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"next/2\">  <span class=\"signature\">next(argv, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">next(<a href=\"#t:argv/0\">argv</a>, <a href=\"#t:options/0\">options</a>) ::\n  {:ok, key :: atom, value :: term, <a href=\"#t:argv/0\">argv</a>} |\n  {:invalid, <a href=\"string#t:t/0\">String.t</a>, <a href=\"string#t:t/0\">String.t</a> | nil, <a href=\"#t:argv/0\">argv</a>} |\n  {:undefined, <a href=\"string#t:t/0\">String.t</a>, <a href=\"string#t:t/0\">String.t</a> | nil, <a href=\"#t:argv/0\">argv</a>} |\n  {:error, <a href=\"#t:argv/0\">argv</a>}</code></pre>    <p>Low-level function that parses one option.</p> <p>It accepts the same options as <a href=\"#parse/2\"><code class=\"inline\">parse/2</code></a> and <a href=\"#parse_head/2\"><code class=\"inline\">parse_head/2</code></a> as both functions are built on top of this function. This function may return:</p> <ul> <li>\n<p><code class=\"inline\">{:ok, key, value, rest}</code> - the option <code class=\"inline\">key</code> with <code class=\"inline\">value</code> was successfully parsed</p> </li> <li>\n<p><code class=\"inline\">{:invalid, key, value, rest}</code> - the option <code class=\"inline\">key</code> is invalid with <code class=\"inline\">value</code> (returned when the value cannot be parsed according to the switch type)</p> </li> <li>\n<p><code class=\"inline\">{:undefined, key, value, rest}</code> - the option <code class=\"inline\">key</code> is undefined (returned in strict mode when the switch is unknown)</p> </li> <li>\n<code class=\"inline\">{:error, rest}</code> - there are no switches at the head of the given <code class=\"inline\">argv</code> </li> </ul>    <h3 class=\"detail-header function\" id=\"parse/2\">  <span class=\"signature\">parse(argv, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">parse(<a href=\"#t:argv/0\">argv</a>, <a href=\"#t:options/0\">options</a>) :: {<a href=\"#t:parsed/0\">parsed</a>, <a href=\"#t:argv/0\">argv</a>, <a href=\"#t:errors/0\">errors</a>}</code></pre>    <p>Parses <code class=\"inline\">argv</code> into a keywords list.</p> <p>It returns a three-element tuple with the form <code class=\"inline\">{parsed, args, invalid}</code>, where:</p> <ul> <li>\n<code class=\"inline\">parsed</code> is a keyword list of parsed switches with <code class=\"inline\">{switch_name, value}</code> tuples in it; <code class=\"inline\">switch_name</code> is the atom representing the switch name while <code class=\"inline\">value</code> is the value for that switch parsed according to <code class=\"inline\">opts</code> (see the “Examples” section for more information) </li> <li>\n<code class=\"inline\">args</code> is a list of the remaining arguments in <code class=\"inline\">argv</code> as strings </li> <li>\n<code class=\"inline\">invalid</code> is a list of invalid options as <code class=\"inline\">{option_name, value}</code> where <code class=\"inline\">option_name</code> is the raw option and <code class=\"inline\">value</code> is <code class=\"inline\">nil</code> if the option wasn’t expected or the string value if the value didn’t have the expected type for the corresponding option </li> </ul> <p>Elixir converts switches to underscored atoms, so <code class=\"inline\">--source-path</code> becomes <code class=\"inline\">:source_path</code>. This is done to better suit Elixir conventions. However, this means that switches can’t contain underscores and switches that do contain underscores are always returned in the list of invalid options.</p> <p>Without any options, this function will try to parse all switches in the <code class=\"inline\">argv</code>.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; OptionParser.parse([\"--debug\"])\n{[debug: true], [], []}\n\niex&gt; OptionParser.parse([\"--source\", \"lib\"])\n{[source: \"lib\"], [], []}\n\niex&gt; OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs\", \"--verbose\"])\n{[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}</code></pre> <p>Switches followed by a value will be assigned the value, as a string. Switches without an argument, like <code class=\"inline\">--debug</code> in the examples above, will automatically be set to <code class=\"inline\">true</code>.</p> <h4>Options</h4> <p>The following options are supported:</p> <ul> <li>\n<code class=\"inline\">:switches</code> or <code class=\"inline\">:strict</code> - see the “Switch definitions” section below </li> <li>\n<code class=\"inline\">:aliases</code> - see the “Aliases” section below </li> </ul> <h4>Switch definitions</h4> <p>Often it is better to explicitly list the known switches and their formats. The switches can be specified via one of two options:</p> <ul> <li>\n<code class=\"inline\">:switches</code> - defines some switches and their types. This function still attempts to parse switches that are not in this list. </li> <li>\n<code class=\"inline\">:strict</code> - defines strict switches. Any switch in <code class=\"inline\">argv</code> that is not specified in the list is returned in the invalid options list. </li> </ul> <p>Both these options accept a keyword list of <code class=\"inline\">{name, type}</code> tuples where <code class=\"inline\">name</code> is an atom defining the name of the switch and <code class=\"inline\">type</code> is an atom that specifies the type for the value of this switch (see the “Types” section below for the possible types and more information about type casting).</p> <p>Note that you should only supply the <code class=\"inline\">:switches</code> or <code class=\"inline\">:strict</code> option. If you supply both, an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> exception will be raised.</p> <h3>Types</h3> <p>Switches parsed by <a href=\"optionparser#content\"><code class=\"inline\">OptionParser</code></a> may take zero or one arguments.</p> <p>The following switches types take no arguments:</p> <ul> <li>\n<code class=\"inline\">:boolean</code> - sets the value to <code class=\"inline\">true</code> when given (see also the “Negation switches” section below) </li> <li>\n<code class=\"inline\">:count</code> - counts the number of times the switch is given </li> </ul> <p>The following switches take one argument:</p> <ul> <li>\n<code class=\"inline\">:integer</code> - parses the value as an integer </li> <li>\n<code class=\"inline\">:float</code> - parses the value as a float </li> <li>\n<code class=\"inline\">:string</code> - parses the value as a string </li> </ul> <p>If a switch can’t be parsed according to the given type, it is returned in the invalid options list.</p> <h3>Modifiers</h3> <p>Switches can be specified with modifiers, which change how they behave. The following modifiers are supported:</p> <ul> <li>\n<code class=\"inline\">:keep</code> - keeps duplicated items instead of overriding them; works with all types except <code class=\"inline\">:count</code>. Specifying <code class=\"inline\">switch_name: :keep</code> assumes the type of <code class=\"inline\">:switch_name</code> will be <code class=\"inline\">:string</code>. </li> </ul> <p>Note that if you want to use <code class=\"inline\">:keep</code> with a type other than <code class=\"inline\">:string</code>, use a list as the type for the switch. For example: <code class=\"inline\">[foo: [:integer, :keep]]</code>.</p> <h3>Negation switches</h3> <p>In case a switch <code class=\"inline\">SWITCH</code> is specified to have type <code class=\"inline\">:boolean</code>, it may be passed as <code class=\"inline\">--no-SWITCH</code> as well which will set the option to <code class=\"inline\">false</code>:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :boolean])\n{[op: false], [\"path/to/file\"], []}</code></pre> <h4>Aliases</h4> <p>A set of aliases can be specified in the <code class=\"inline\">:aliases</code> option:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; OptionParser.parse([\"-d\"], aliases: [d: :debug])\n{[debug: true], [], []}</code></pre> <h4>Examples</h4> <p>Here are some examples of working with different types and modifiers:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: [unlock: :boolean])\n{[unlock: true], [\"path/to/file\"], []}\n\niex&gt; OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file\"],\n...&gt;                    strict: [unlock: :boolean, limit: :integer])\n{[unlock: true, limit: 0], [\"path/to/file\"], []}\n\niex&gt; OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :integer])\n{[limit: 3], [], []}\n\niex&gt; OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :integer])\n{[], [], [{\"--limit\", \"xyz\"}]}\n\niex&gt; OptionParser.parse([\"--verbose\"], switches: [verbose: :count])\n{[verbose: 1], [], []}\n\niex&gt; OptionParser.parse([\"-v\", \"-v\"], aliases: [v: :verbose], strict: [verbose: :count])\n{[verbose: 2], [], []}\n\niex&gt; OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n{[], [\"xyz\"], [{\"--unknown\", nil}]}\n\niex&gt; OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n...&gt;                    switches: [limit: :integer])\n{[limit: 3, unknown: \"xyz\"], [], []}\n\niex&gt; OptionParser.parse([\"--unlock\", \"path/to/file\", \"--unlock\", \"path/to/another/file\"], strict: [unlock: :keep])\n{[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}</code></pre>    <h3 class=\"detail-header function\" id=\"parse!/2\">  <span class=\"signature\">parse!(argv, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">parse!(<a href=\"#t:argv/0\">argv</a>, <a href=\"#t:options/0\">options</a>) ::\n  {<a href=\"#t:parsed/0\">parsed</a>, <a href=\"#t:argv/0\">argv</a>} |\n  no_return</code></pre>    <p>The same as <a href=\"#parse/2\"><code class=\"inline\">parse/2</code></a> but raises an <a href=\"optionparser.parseerror\"><code class=\"inline\">OptionParser.ParseError</code></a> exception if any invalid options are given.</p> <p>If there are no errors, returns a <code class=\"inline\">{parsed, rest}</code> tuple where:</p> <ul> <li>\n<code class=\"inline\">parsed</code> is the list of parsed switches (same as in <a href=\"#parse/2)\"><code class=\"inline\">parse/2</code></a> </li> <li>\n<code class=\"inline\">rest</code> is the list of arguments (same as in <a href=\"#parse/2)\"><code class=\"inline\">parse/2</code></a> </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; OptionParser.parse!([\"--debug\", \"path/to/file\"], strict: [debug: :boolean])\n{[debug: true], [\"path/to/file\"]}\n\niex&gt; OptionParser.parse!([\"--limit\", \"xyz\"], strict: [limit: :integer])\n** (OptionParser.ParseError) 1 error found!\n--limit : Expected type integer, got \"xyz\"\n\niex&gt; OptionParser.parse!([\"--unknown\", \"xyz\"], strict: [])\n** (OptionParser.ParseError) 1 error found!\n--unknown : Unknown option\n\niex&gt; OptionParser.parse!([\"-l\", \"xyz\", \"-f\", \"bar\"],\n...&gt;                     switches: [limit: :integer, foo: :integer], aliases: [l: :limit, f: :foo])\n** (OptionParser.ParseError) 2 errors found!\n-l : Expected type integer, got \"xyz\"\n-f : Expected type integer, got \"bar\"</code></pre>    <h3 class=\"detail-header function\" id=\"parse_head/2\">  <span class=\"signature\">parse_head(argv, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">parse_head(<a href=\"#t:argv/0\">argv</a>, <a href=\"#t:options/0\">options</a>) :: {<a href=\"#t:parsed/0\">parsed</a>, <a href=\"#t:argv/0\">argv</a>, <a href=\"#t:errors/0\">errors</a>}</code></pre>    <p>Similar to <a href=\"#parse/2\"><code class=\"inline\">parse/2</code></a> but only parses the head of <code class=\"inline\">argv</code>; as soon as it finds a non-switch, it stops parsing.</p> <p>See <a href=\"#parse/2\"><code class=\"inline\">parse/2</code></a> for more information.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs\", \"--verbose\"])\n{[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n\niex&gt; OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"])\n{[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock\"], []}</code></pre>    <h3 class=\"detail-header function\" id=\"parse_head!/2\">  <span class=\"signature\">parse_head!(argv, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">parse_head!(<a href=\"#t:argv/0\">argv</a>, <a href=\"#t:options/0\">options</a>) ::\n  {<a href=\"#t:parsed/0\">parsed</a>, <a href=\"#t:argv/0\">argv</a>} |\n  no_return</code></pre>    <p>The same as <a href=\"#parse_head/2\"><code class=\"inline\">parse_head/2</code></a> but raises an <a href=\"optionparser.parseerror\"><code class=\"inline\">OptionParser.ParseError</code></a> exception if any invalid options are given.</p> <p>If there are no errors, returns a <code class=\"inline\">{parsed, rest}</code> tuple where:</p> <ul> <li>\n<code class=\"inline\">parsed</code> is the list of parsed switches (same as in <a href=\"#parse_head/2)\"><code class=\"inline\">parse_head/2</code></a> </li> <li>\n<code class=\"inline\">rest</code> is the list of arguments (same as in <a href=\"#parse_head/2)\"><code class=\"inline\">parse_head/2</code></a> </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; OptionParser.parse_head!([\"--source\", \"lib\", \"path/to/file\", \"--verbose\"])\n{[source: \"lib\"], [\"path/to/file\", \"--verbose\"]}\n\niex&gt; OptionParser.parse_head!([\"--number\", \"lib\", \"test/enum_test.exs\", \"--verbose\"], strict: [number: :integer])\n** (OptionParser.ParseError) 1 error found!\n--number : Expected type integer, got \"lib\"\n\niex&gt; OptionParser.parse_head!([\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"],\n...&gt;                          strict: [verbose: :integer, source: :integer])\n** (OptionParser.ParseError) 2 errors found!\n--verbose : Missing argument of type integer\n--source : Expected type integer, got \"lib\"</code></pre>    <h3 class=\"detail-header function\" id=\"split/1\">  <span class=\"signature\">split(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">split(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"#t:argv/0\">argv</a></code></pre>    <p>Splits a string into argv chunks.</p> <p>This function splits the given <code class=\"inline\">string</code> into a list of strings in a similar way to many shells.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; OptionParser.split(\"foo bar\")\n[\"foo\", \"bar\"]\n\niex&gt; OptionParser.split(\"foo \\\"bar baz\\\"\")\n[\"foo\", \"bar baz\"]</code></pre>    <h3 class=\"detail-header function\" id=\"to_argv/1\">  <span class=\"signature\">to_argv(enum)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_argv(<a href=\"enumerable#t:t/0\">Enumerable.t</a>) :: <a href=\"#t:argv/0\">argv</a></code></pre>    <p>Receives a key-value enumerable and converts it to argv.</p> <p>Keys must be atoms. Keys with <code class=\"inline\">nil</code> value are discarded, boolean values are converted to <code class=\"inline\">--key</code> or <code class=\"inline\">--no-key</code> (if the value is <code class=\"inline\">true</code> or <code class=\"inline\">false</code>, respectively), and all other values are converted using <code class=\"inline\">to_string/1</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt;  OptionParser.to_argv([foo_bar: \"baz\"])\n[\"--foo-bar\", \"baz\"]\n\niex&gt;  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n[\"--bool\", \"--no-bool\"]</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/OptionParser.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/OptionParser.html</a>\n  </p>\n</div>\n","elixir/protocol":"<h1>  Protocol  </h1>  <p>Functions for working with protocols.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#assert_impl!/2\">assert_impl!(protocol, base)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the given module is loaded and is an implementation of the given protocol</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#assert_protocol!/1\">assert_protocol!(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the given module is loaded and is protocol</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#consolidate/2\">consolidate(protocol, types)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a protocol and a list of implementations and consolidates the given protocol</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#consolidated?/1\">consolidated?(protocol)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the protocol was consolidated</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#extract_impls/2\">extract_impls(protocol, paths)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Extracts all types implemented for the given protocol from the given paths</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#extract_protocols/1\">extract_protocols(paths)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Extracts all protocols from the given paths</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#def/1\">def(signature)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a new protocol function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#derive/3\">derive(protocol, module, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Derives the <code class=\"inline\">protocol</code> for <code class=\"inline\">module</code> with the given options</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"assert_impl!/2\">  <span class=\"signature\">assert_impl!(protocol, base)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">assert_impl!(module, module) :: :ok | no_return</code></pre>    <p>Checks if the given module is loaded and is an implementation of the given protocol.</p> <p>Returns <code class=\"inline\">:ok</code> if so, otherwise raises <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a>.</p>    <h3 class=\"detail-header function\" id=\"assert_protocol!/1\">  <span class=\"signature\">assert_protocol!(module)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">assert_protocol!(module) :: :ok | no_return</code></pre>    <p>Checks if the given module is loaded and is protocol.</p> <p>Returns <code class=\"inline\">:ok</code> if so, otherwise raises <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a>.</p>    <h3 class=\"detail-header function\" id=\"consolidate/2\">  <span class=\"signature\">consolidate(protocol, types)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">consolidate(module, [module]) ::\n  {:ok, binary} |\n  {:error, :not_a_protocol} |\n  {:error, :no_beam_info}</code></pre>    <p>Receives a protocol and a list of implementations and consolidates the given protocol.</p> <p>Consolidation happens by changing the protocol <code class=\"inline\">impl_for</code> in the abstract format to have fast lookup rules. Usually the list of implementations to use during consolidation are retrieved with the help of <a href=\"#extract_impls/2\"><code class=\"inline\">extract_impls/2</code></a>.</p> <p>It returns the updated version of the protocol bytecode. A given bytecode or protocol implementation can be checked to be consolidated or not by analyzing the protocol attribute:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Protocol.consolidated?(Enumerable)</code></pre> <p>If the first element of the tuple is <code class=\"inline\">true</code>, it means the protocol was consolidated.</p> <p>This function does not load the protocol at any point nor loads the new bytecode for the compiled module. However each implementation must be available and it will be loaded.</p>    <h3 class=\"detail-header function\" id=\"consolidated?/1\">  <span class=\"signature\">consolidated?(protocol)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">consolidated?(module) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if the protocol was consolidated.</p>    <h3 class=\"detail-header function\" id=\"extract_impls/2\">  <span class=\"signature\">extract_impls(protocol, paths)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">extract_impls(module, [charlist | <a href=\"string#t:t/0\">String.t</a>]) :: [atom]</code></pre>    <p>Extracts all types implemented for the given protocol from the given paths.</p> <p>The paths can be either a charlist or a string. Internally they are worked on as charlists, so passing them as lists avoid extra conversion.</p> <p>Does not load any of the implementations.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Get Elixir's ebin and retrieve all protocols\niex&gt; path = :code.lib_dir(:elixir, :ebin)\niex&gt; mods = Protocol.extract_impls(Enumerable, [path])\niex&gt; List in mods\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"extract_protocols/1\">  <span class=\"signature\">extract_protocols(paths)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">extract_protocols([charlist | <a href=\"string#t:t/0\">String.t</a>]) :: [atom]</code></pre>    <p>Extracts all protocols from the given paths.</p> <p>The paths can be either a charlist or a string. Internally they are worked on as charlists, so passing them as lists avoid extra conversion.</p> <p>Does not load any of the protocols.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Get Elixir's ebin and retrieve all protocols\niex&gt; path = :code.lib_dir(:elixir, :ebin)\niex&gt; mods = Protocol.extract_protocols([path])\niex&gt; Enumerable in mods\ntrue</code></pre>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"def/1\">  <span class=\"signature\">def(signature)</span>  </h3>  <p>Defines a new protocol function.</p> <p>Protocols do not allow functions to be defined directly, instead, the regular <code class=\"inline\">Kernel.def/*</code> macros are replaced by this macro which defines the protocol functions with the appropriate callbacks.</p>    <h3 class=\"detail-header macro\" id=\"derive/3\">  <span class=\"signature\">derive(protocol, module, options \\\\ [])</span>  </h3>  <p>Derives the <code class=\"inline\">protocol</code> for <code class=\"inline\">module</code> with the given options.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Protocol.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Protocol.html</a>\n  </p>\n</div>\n","elixir/range":"<h1>  Range  </h1>  <p>Defines a range.</p> <p>A range represents a discrete number of values where the first and last values are integers.</p> <p>Ranges can be either increasing (first &lt;= last) or decreasing (first &gt; last). Ranges are also always inclusive.</p> <p>A Range is represented internally as a struct. However, the most common form of creating and matching on ranges is via the <code class=\"inline\">../2</code> macro, auto-imported from Kernel:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; range = 1..3\n1..3\niex&gt; first..last = range\niex&gt; first\n1\niex&gt; last\n3</code></pre> <p>A Range implements the Enumerable protocol, which means all of the functions in the Enum module is available:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; range = 1..10\n1..10\niex&gt; Enum.reduce(range, 0, fn i, acc -&gt; i * i + acc end)\n385\niex&gt; Enum.count(range)\n10\niex&gt; Enum.member?(range, 11)\nfalse\niex&gt; Enum.member?(range, 8)\ntrue</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/2\">t(first, last)</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#new/2\">new(first, last)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a new range</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#range?/1\">range?(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the given <code class=\"inline\">term</code> is a valid range</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Range{first: integer, last: integer}</code></pre> </div> <div id=\"t:t/2\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/2\">t(first, last)</a> :: %Range{first: first, last: last}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"new/2\">  <span class=\"signature\">new(first, last)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new(integer, integer) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Creates a new range.</p>    <h3 class=\"detail-header function\" id=\"range?/1\">  <span class=\"signature\">range?(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">range?(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if the given <code class=\"inline\">term</code> is a valid range.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Range.range?(1..3)\ntrue\n\niex&gt; Range.range?(0)\nfalse</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Range.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Range.html</a>\n  </p>\n</div>\n","elixir/enum":"<h1>  Enum  </h1>  <p>Provides a set of algorithms that enumerate over enumerables according to the <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> protocol.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.map([1, 2, 3], fn(x) -&gt; x * 2 end)\n[2, 4, 6]</code></pre> <p>Some particular types, like maps, yield a specific format on enumeration. For example, the argument is always a <code class=\"inline\">{key, value}</code> tuple for maps:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; map = %{a: 1, b: 2}\niex&gt; Enum.map(map, fn {k, v} -&gt; {k, v * 2} end)\n[a: 2, b: 4]</code></pre> <p>Note that the functions in the <a href=\"enum#content\"><code class=\"inline\">Enum</code></a> module are eager: they always start the enumeration of the given enumerable. The <a href=\"stream\"><code class=\"inline\">Stream</code></a> module allows lazy enumeration of enumerables and provides infinite streams.</p> <p>Since the majority of the functions in <a href=\"enum#content\"><code class=\"inline\">Enum</code></a> enumerate the whole enumerable and return a list as result, infinite streams need to be carefully used with such functions, as they can potentially run forever. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Enum.each Stream.cycle([1, 2, 3]), &amp;IO.puts(&amp;1)</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:default/0\">default()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:element/0\">element()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:index/0\">index()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#all?/2\">all?(enumerable, fun \\\\ fn x -&gt; x end)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invokes the given <code class=\"inline\">fun</code> for each item in the enumerable. It stops the iteration at the first invocation that returns <code class=\"inline\">false</code> or <code class=\"inline\">nil</code>. It returns <code class=\"inline\">false</code> if at least one invocation returns <code class=\"inline\">false</code> or <code class=\"inline\">nil</code>. Otherwise returns <code class=\"inline\">true</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#any?/2\">any?(enumerable, fun \\\\ fn x -&gt; x end)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invokes the given <code class=\"inline\">fun</code> for each item in the enumerable. It stops the iteration at the first invocation that returns a truthy value. Returns <code class=\"inline\">true</code> if at least one invocation returns a truthy value. Otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#at/3\">at(enumerable, index, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Finds the element at the given <code class=\"inline\">index</code> (zero-based)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chunk/2\">chunk(enumerable, count)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Shortcut to <code class=\"inline\">chunk(enumerable, count, count)</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chunk/4\">chunk(enumerable, count, step, leftover \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns list of lists containing <code class=\"inline\">count</code> items each, where each new chunk starts <code class=\"inline\">step</code> elements into the enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chunk_by/2\">chunk_by(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Splits enumerable on every element for which <code class=\"inline\">fun</code> returns a new value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#concat/1\">concat(enumerables)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Given an enumerable of enumerables, concatenates the enumerables into a single list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#concat/2\">concat(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Concatenates the enumerable on the right with the enumerable on the left</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#count/1\">count(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the size of the enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#count/2\">count(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the count of items in the enumerable for which <code class=\"inline\">fun</code> returns a truthy value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dedup/1\">dedup(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Enumerates the <code class=\"inline\">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dedup_by/2\">dedup_by(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Enumerates the <code class=\"inline\">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#drop/2\">drop(enumerable, n)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Drops the first <code class=\"inline\">n</code> items from then enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#drop_every/2\">drop_every(enumerable, nth)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of every <code class=\"inline\">nth</code> item in the enumerable dropped, starting with the first element</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#drop_while/2\">drop_while(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Drops items at the beginning of the enumerable while <code class=\"inline\">fun</code> returns a truthy value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#each/2\">each(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invokes the given <code class=\"inline\">fun</code> for each item in the enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#empty?/1\">empty?(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Determines if the enumerable is empty</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch/2\">fetch(enumerable, index)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Finds the element at the given <code class=\"inline\">index</code> (zero-based)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fetch!/2\">fetch!(enumerable, index)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Finds the element at the given <code class=\"inline\">index</code> (zero-based)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#filter/2\">filter(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Filters the enumerable, i.e. returns only those elements for which <code class=\"inline\">fun</code> returns a truthy value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#filter_map/3\">filter_map(enumerable, filter, mapper)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Filters the enumerable and maps its elements in one pass</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#find/3\">find(enumerable, default \\\\ nil, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the first item for which <code class=\"inline\">fun</code> returns a truthy value. If no such item is found, returns <code class=\"inline\">default</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#find_index/2\">find_index(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Similar to <a href=\"#find/3\"><code class=\"inline\">find/3</code></a>, but returns the index (zero-based) of the element instead of the element itself</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#find_value/3\">find_value(enumerable, default \\\\ nil, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Similar to <a href=\"#find/3\"><code class=\"inline\">find/3</code></a>, but returns the value of the function invocation instead of the element itself</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#flat_map/2\">flat_map(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a new enumerable appending the result of invoking <code class=\"inline\">fun</code> on each corresponding item of <code class=\"inline\">enumerable</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#flat_map_reduce/3\">flat_map_reduce(enumerable, acc, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Maps and reduces an enumerable, flattening the given results (only one level deep)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#group_by/3\">group_by(enumerable, key_fun, mapper_fun \\\\ fn x -&gt; x end)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Splits the enumerable into groups based on <code class=\"inline\">fun</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#intersperse/2\">intersperse(enumerable, element)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Intersperses <code class=\"inline\">element</code> between each element of the enumeration</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#into/2\">into(enumerable, collectable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts the given <code class=\"inline\">enumerable</code> into a <code class=\"inline\">collectable</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#into/3\">into(enumerable, collectable, transform)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts the given <code class=\"inline\">enumerable</code> into a <code class=\"inline\">collectable</code> according to the transformation function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#join/2\">join(enumerable, joiner \\\\ \"\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Joins the given enumerable into a binary using <code class=\"inline\">joiner</code> as a separator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#map/2\">map(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list where each item is the result of invoking <code class=\"inline\">fun</code> on each corresponding item of <code class=\"inline\">enumerable</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#map_join/3\">map_join(enumerable, joiner \\\\ \"\", mapper)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Maps and joins the given enumerable in one pass</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#map_reduce/3\">map_reduce(enumerable, acc, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invokes the given function to each item in the enumerable to reduce it to a single element, while keeping an accumulator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#max/1\">max(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the maximal element in the enumerable according to Erlang’s term ordering</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#max_by/2\">max_by(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the maximal element in the enumerable as calculated by the given function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#member?/2\">member?(enumerable, element)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if <code class=\"inline\">element</code> exists within the enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#min/1\">min(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the minimal element in the enumerable according to Erlang’s term ordering</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#min_by/2\">min_by(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the minimal element in the enumerable as calculated by the given function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#min_max/1\">min_max(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang’s term ordering</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#min_max_by/2\">min_max_by(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#partition/2\">partition(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Partitions <code class=\"inline\">enumerable</code> into two lists, where the first one contains elements for which <code class=\"inline\">fun</code> returns a truthy value, and the second one – for which <code class=\"inline\">fun</code> returns <code class=\"inline\">false</code> or <code class=\"inline\">nil</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#random/1\">random(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a random element of an enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reduce/2\">reduce(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invokes <code class=\"inline\">fun</code> for each element in the <code class=\"inline\">enumerable</code>, passing that element and the accumulator as arguments. <code class=\"inline\">fun</code>’s return value is stored in the accumulator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reduce/3\">reduce(enumerable, acc, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invokes <code class=\"inline\">fun</code> for each element in the <code class=\"inline\">enumerable</code>, passing that element and the accumulator <code class=\"inline\">acc</code> as arguments. <code class=\"inline\">fun</code>’s return value is stored in <code class=\"inline\">acc</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reduce_while/3\">reduce_while(enumerable, acc, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reduces the enumerable until <code class=\"inline\">halt</code> is emitted</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reject/2\">reject(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns elements of <code class=\"inline\">enumerable</code> for which the function <code class=\"inline\">fun</code> returns <code class=\"inline\">false</code> or <code class=\"inline\">nil</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reverse/1\">reverse(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of elements in <code class=\"inline\">enumerable</code> in reverse order</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reverse/2\">reverse(enumerable, tail)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reverses the elements in <code class=\"inline\">enumerable</code>, appends the tail, and returns it as a list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reverse_slice/3\">reverse_slice(enumerable, start, count)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reverses the enumerable in the range from initial position <code class=\"inline\">start</code> through <code class=\"inline\">count</code> elements</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#scan/2\">scan(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Applies the given function to each element in the enumerable, storing the result in a list and passing it as the accumulator for the next computation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#scan/3\">scan(enumerable, acc, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Applies the given function to each element in the enumerable, storing the result in a list and passing it as the accumulator for the next computation. Uses the given <code class=\"inline\">acc</code> as the starting value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#shuffle/1\">shuffle(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list with the elements of <code class=\"inline\">enumerable</code> shuffled</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#slice/2\">slice(enumerable, range)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a subset list of the given enumerable. Drops elements until element position <code class=\"inline\">range.first</code>, then takes elements until element position <code class=\"inline\">range.last</code> (inclusive)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#slice/3\">slice(enumerable, start, count)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a subset list of the given enumerable. Drops elements until element position <code class=\"inline\">start</code>, then takes <code class=\"inline\">count</code> elements</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sort/1\">sort(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sorts the enumerable according to Erlang’s term ordering</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sort/2\">sort(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sorts the enumerable by the given function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sort_by/3\">sort_by(enumerable, mapper, sorter \\\\ &amp;&lt;=/2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sorts the mapped results of the enumerable according to the <code class=\"inline\">sorter</code> function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#split/2\">split(enumerable, count)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Splits the <code class=\"inline\">enumerable</code> into two enumerables, leaving <code class=\"inline\">count</code> elements in the first one. If <code class=\"inline\">count</code> is a negative number, it starts counting from the back to the beginning of the enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#split_while/2\">split_while(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Splits enumerable in two at the position of the element for which <code class=\"inline\">fun</code> returns <code class=\"inline\">false</code> for the first time</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sum/1\">sum(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the sum of all elements</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#take/2\">take(enumerable, count)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Takes the first <code class=\"inline\">count</code> items from the enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#take_every/2\">take_every(enumerable, nth)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of every <code class=\"inline\">nth</code> item in the enumerable, starting with the first element</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#take_random/2\">take_random(enumerable, count)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Takes random items from <code class=\"inline\">enumerable</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#take_while/2\">take_while(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Takes the items from the beginning of the enumerable while <code class=\"inline\">fun</code> returns a truthy value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_list/1\">to_list(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts <code class=\"inline\">enumerable</code> to a list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#uniq/1\">uniq(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Enumerates the <code class=\"inline\">enumerable</code>, removing all duplicated elements</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#uniq_by/2\">uniq_by(enumerable, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Enumerates the <code class=\"inline\">enumerable</code>, by removing the elements for which function <code class=\"inline\">fun</code> returned duplicate items</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unzip/1\">unzip(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Opposite of <a href=\"enum#zip/2\"><code class=\"inline\">Enum.zip/2</code></a>; extracts a two-element tuples from the enumerable and groups them together</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#with_index/2\">with_index(enumerable, offset \\\\ 0)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the enumerable with each element wrapped in a tuple alongside its index</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#zip/2\">zip(enumerable1, enumerable2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Zips corresponding elements from two enumerables into one list of tuples</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:default/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:default/0\">default</a> :: any</code></pre> </div> <div id=\"t:element/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:element/0\">element</a> :: any</code></pre> </div> <div id=\"t:index/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:index/0\">index</a> :: non_neg_integer</code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"all?/2\">  <span class=\"signature\">all?(enumerable, fun \\\\ fn x -&gt; x end)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">all?(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term))) :: boolean</code></pre>    <p>Invokes the given <code class=\"inline\">fun</code> for each item in the enumerable. It stops the iteration at the first invocation that returns <code class=\"inline\">false</code> or <code class=\"inline\">nil</code>. It returns <code class=\"inline\">false</code> if at least one invocation returns <code class=\"inline\">false</code> or <code class=\"inline\">nil</code>. Otherwise returns <code class=\"inline\">true</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.all?([2, 4, 6], fn(x) -&gt; rem(x, 2) == 0 end)\ntrue\n\niex&gt; Enum.all?([2, 3, 4], fn(x) -&gt; rem(x, 2) == 0 end)\nfalse</code></pre> <p>If no function is given, it defaults to checking if all items in the enumerable are truthy values.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.all?([1, 2, 3])\ntrue\n\niex&gt; Enum.all?([1, nil, 3])\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"any?/2\">  <span class=\"signature\">any?(enumerable, fun \\\\ fn x -&gt; x end)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">any?(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term))) :: boolean</code></pre>    <p>Invokes the given <code class=\"inline\">fun</code> for each item in the enumerable. It stops the iteration at the first invocation that returns a truthy value. Returns <code class=\"inline\">true</code> if at least one invocation returns a truthy value. Otherwise returns <code class=\"inline\">false</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.any?([2, 4, 6], fn(x) -&gt; rem(x, 2) == 1 end)\nfalse\n\niex&gt; Enum.any?([2, 3, 4], fn(x) -&gt; rem(x, 2) == 1 end)\ntrue</code></pre> <p>If no function is given, it defaults to checking if at least one item in the enumerable is a truthy value.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.any?([false, false, false])\nfalse\n\niex&gt; Enum.any?([false, true, false])\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"at/3\">  <span class=\"signature\">at(enumerable, index, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">at(<a href=\"#t:t/0\">t</a>, integer, <a href=\"#t:default/0\">default</a>) :: <a href=\"#t:element/0\">element</a> | <a href=\"#t:default/0\">default</a></code></pre>    <p>Finds the element at the given <code class=\"inline\">index</code> (zero-based).</p> <p>Returns <code class=\"inline\">default</code> if <code class=\"inline\">index</code> is out of bounds.</p> <p>A negative <code class=\"inline\">index</code> can be passed, which means the <code class=\"inline\">enumerable</code> is enumerated once and the <code class=\"inline\">index</code> is counted from the end (e.g. <code class=\"inline\">-1</code> finds the last element).</p> <p>Note this operation takes linear time. In order to access the element at index <code class=\"inline\">index</code>, it will need to traverse <code class=\"inline\">index</code> previous elements.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.at([2, 4, 6], 0)\n2\n\niex&gt; Enum.at([2, 4, 6], 2)\n6\n\niex&gt; Enum.at([2, 4, 6], 4)\nnil\n\niex&gt; Enum.at([2, 4, 6], 4, :none)\n:none</code></pre>    <h3 class=\"detail-header function\" id=\"chunk/2\">  <span class=\"signature\">chunk(enumerable, count)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chunk(<a href=\"#t:t/0\">t</a>, pos_integer) :: [list]</code></pre>    <p>Shortcut to <code class=\"inline\">chunk(enumerable, count, count)</code>.</p>    <h3 class=\"detail-header function\" id=\"chunk/4\">  <span class=\"signature\">chunk(enumerable, count, step, leftover \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chunk(<a href=\"#t:t/0\">t</a>, pos_integer, pos_integer, <a href=\"#t:t/0\">t</a> | nil) :: [list]</code></pre>    <p>Returns list of lists containing <code class=\"inline\">count</code> items each, where each new chunk starts <code class=\"inline\">step</code> elements into the enumerable.</p> <p><code class=\"inline\">step</code> is optional and, if not passed, defaults to <code class=\"inline\">count</code>, i.e. chunks do not overlap.</p> <p>If the final chunk does not have <code class=\"inline\">count</code> elements to fill the chunk, elements are taken as necessary from <code class=\"inline\">leftover</code> if it was passed.</p> <p>If <code class=\"inline\">leftover</code> is passed and does not have enough elements to fill the chunk, then a partial chunk is returned with less than <code class=\"inline\">count</code> elements. If <code class=\"inline\">leftover</code> is not passed at all or is <code class=\"inline\">nil</code>, then the partial chunk is discarded from the result.</p> <p>If <code class=\"inline\">count</code> is greater than the number of elements in the enumerable and <code class=\"inline\">leftover</code> is not passed, empty list will be returned.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n[[1, 2], [3, 4], [5, 6]]\n\niex&gt; Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n[[1, 2, 3], [3, 4, 5]]\n\niex&gt; Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n[[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\niex&gt; Enum.chunk([1, 2, 3, 4], 3, 3, [])\n[[1, 2, 3], [4]]\n\niex&gt; Enum.chunk([1, 2, 3, 4], 10)\n[]\n\niex&gt; Enum.chunk([1, 2, 3, 4], 10, 10, [])\n[[1, 2, 3, 4]]</code></pre>    <h3 class=\"detail-header function\" id=\"chunk_by/2\">  <span class=\"signature\">chunk_by(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chunk_by(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; any)) :: [list]</code></pre>    <p>Splits enumerable on every element for which <code class=\"inline\">fun</code> returns a new value.</p> <p>Returns a list of lists.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &amp;(rem(&amp;1, 2) == 1))\n[[1], [2, 2], [3], [4, 4, 6], [7, 7]]</code></pre>    <h3 class=\"detail-header function\" id=\"concat/1\">  <span class=\"signature\">concat(enumerables)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">concat(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Given an enumerable of enumerables, concatenates the enumerables into a single list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.concat([1..3, 4..6, 7..9])\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\niex&gt; Enum.concat([[1, [2], 3], [4], [5, 6]])\n[1, [2], 3, 4, 5, 6]</code></pre>    <h3 class=\"detail-header function\" id=\"concat/2\">  <span class=\"signature\">concat(left, right)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">concat(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Concatenates the enumerable on the right with the enumerable on the left.</p> <p>This function produces the same result as the <a href=\"kernel#++/2\"><code class=\"inline\">Kernel.++/2</code></a> operator for lists.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.concat(1..3, 4..6)\n[1, 2, 3, 4, 5, 6]\n\niex&gt; Enum.concat([1, 2, 3], [4, 5, 6])\n[1, 2, 3, 4, 5, 6]</code></pre>    <h3 class=\"detail-header function\" id=\"count/1\">  <span class=\"signature\">count(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">count(<a href=\"#t:t/0\">t</a>) :: non_neg_integer</code></pre>    <p>Returns the size of the enumerable.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.count([1, 2, 3])\n3</code></pre>    <h3 class=\"detail-header function\" id=\"count/2\">  <span class=\"signature\">count(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">count(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term))) :: non_neg_integer</code></pre>    <p>Returns the count of items in the enumerable for which <code class=\"inline\">fun</code> returns a truthy value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.count([1, 2, 3, 4, 5], fn(x) -&gt; rem(x, 2) == 0 end)\n2</code></pre>    <h3 class=\"detail-header function\" id=\"dedup/1\">  <span class=\"signature\">dedup(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">dedup(<a href=\"#t:t/0\">t</a>) :: list</code></pre>    <p>Enumerates the <code class=\"inline\">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p> <p>Elements are compared using <code class=\"inline\">===</code>.</p> <p>If you want to remove all duplicated elements, regardless of order, see <a href=\"#uniq/1\"><code class=\"inline\">uniq/1</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.dedup([1, 2, 3, 3, 2, 1])\n[1, 2, 3, 2, 1]\n\niex&gt; Enum.dedup([1, 1, 2, 2.0, :three, :\"three\"])\n[1, 2, 2.0, :three]</code></pre>    <h3 class=\"detail-header function\" id=\"dedup_by/2\">  <span class=\"signature\">dedup_by(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">dedup_by(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; term)) :: list</code></pre>    <p>Enumerates the <code class=\"inline\">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p> <p>The function <code class=\"inline\">fun</code> maps every element to a term which is used to determine if two elements are duplicates.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -&gt; x end)\n[{1, :a}, {2, :b}, {1, :a}]\n\niex&gt; Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -&gt; x &gt; 2 end)\n[5, 1, 3, 2]</code></pre>    <h3 class=\"detail-header function\" id=\"drop/2\">  <span class=\"signature\">drop(enumerable, n)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">drop(<a href=\"#t:t/0\">t</a>, integer) :: list</code></pre>    <p>Drops the first <code class=\"inline\">n</code> items from then enumerable.</p> <p>If a negative value <code class=\"inline\">n</code> is given, the last <code class=\"inline\">n</code> values will be dropped.</p> <p>The <code class=\"inline\">enumerable</code> is enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.drop([1, 2, 3], 2)\n[3]\n\niex&gt; Enum.drop([1, 2, 3], 10)\n[]\n\niex&gt; Enum.drop([1, 2, 3], 0)\n[1, 2, 3]\n\niex&gt; Enum.drop([1, 2, 3], -1)\n[1, 2]</code></pre>    <h3 class=\"detail-header function\" id=\"drop_every/2\">  <span class=\"signature\">drop_every(enumerable, nth)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">drop_every(<a href=\"#t:t/0\">t</a>, non_neg_integer) :: list | no_return</code></pre>    <p>Returns a list of every <code class=\"inline\">nth</code> item in the enumerable dropped, starting with the first element.</p> <p>The first item is always dropped, unless <code class=\"inline\">nth</code> is 0.</p> <p>The second argument specifying every <code class=\"inline\">nth</code> item must be a non-negative integer, otherwise <a href=\"functionclauseerror\"><code class=\"inline\">FunctionClauseError</code></a> will be raised.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.drop_every(1..10, 2)\n[2, 4, 6, 8, 10]\n\niex&gt; Enum.drop_every(1..10, 0)\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\niex&gt; Enum.drop_every([1, 2, 3], 1)\n[]</code></pre>    <h3 class=\"detail-header function\" id=\"drop_while/2\">  <span class=\"signature\">drop_while(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">drop_while(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term))) :: list</code></pre>    <p>Drops items at the beginning of the enumerable while <code class=\"inline\">fun</code> returns a truthy value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.drop_while([1, 2, 3, 4, 5], fn(x) -&gt; x &lt; 3 end)\n[3, 4, 5]</code></pre>    <h3 class=\"detail-header function\" id=\"each/2\">  <span class=\"signature\">each(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">each(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; any)) :: :ok</code></pre>    <p>Invokes the given <code class=\"inline\">fun</code> for each item in the enumerable.</p> <p>Returns <code class=\"inline\">:ok</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Enum.each([\"some\", \"example\"], fn(x) -&gt; IO.puts x end)\n\"some\"\n\"example\"\n#=&gt; :ok</code></pre>    <h3 class=\"detail-header function\" id=\"empty?/1\">  <span class=\"signature\">empty?(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">empty?(<a href=\"#t:t/0\">t</a>) :: boolean</code></pre>    <p>Determines if the enumerable is empty.</p> <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">enumerable</code> is empty, otherwise <code class=\"inline\">false</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.empty?([])\ntrue\n\niex&gt; Enum.empty?([1, 2, 3])\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"fetch/2\">  <span class=\"signature\">fetch(enumerable, index)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch(<a href=\"#t:t/0\">t</a>, integer) :: {:ok, <a href=\"#t:element/0\">element</a>} | :error</code></pre>    <p>Finds the element at the given <code class=\"inline\">index</code> (zero-based).</p> <p>Returns <code class=\"inline\">{:ok, element}</code> if found, otherwise <code class=\"inline\">:error</code>.</p> <p>A negative <code class=\"inline\">index</code> can be passed, which means the <code class=\"inline\">enumerable</code> is enumerated once and the <code class=\"inline\">index</code> is counted from the end (e.g. <code class=\"inline\">-1</code> fetches the last element).</p> <p>Note this operation takes linear time. In order to access the element at index <code class=\"inline\">index</code>, it will need to traverse <code class=\"inline\">index</code> previous elements.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.fetch([2, 4, 6], 0)\n{:ok, 2}\n\niex&gt; Enum.fetch([2, 4, 6], 2)\n{:ok, 6}\n\niex&gt; Enum.fetch([2, 4, 6], 4)\n:error</code></pre>    <h3 class=\"detail-header function\" id=\"fetch!/2\">  <span class=\"signature\">fetch!(enumerable, index)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">fetch!(<a href=\"#t:t/0\">t</a>, integer) :: <a href=\"#t:element/0\">element</a> | no_return</code></pre>    <p>Finds the element at the given <code class=\"inline\">index</code> (zero-based).</p> <p>Raises <code class=\"inline\">OutOfBoundsError</code> if the given <code class=\"inline\">index</code> is outside the range of the enumerable.</p> <p>Note this operation takes linear time. In order to access the element at index <code class=\"inline\">index</code>, it will need to traverse <code class=\"inline\">index</code> previous elements.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.fetch!([2, 4, 6], 0)\n2\n\niex&gt; Enum.fetch!([2, 4, 6], 2)\n6\n\niex&gt; Enum.fetch!([2, 4, 6], 4)\n** (Enum.OutOfBoundsError) out of bounds error</code></pre>    <h3 class=\"detail-header function\" id=\"filter/2\">  <span class=\"signature\">filter(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">filter(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term))) :: list</code></pre>    <p>Filters the enumerable, i.e. returns only those elements for which <code class=\"inline\">fun</code> returns a truthy value.</p> <p>See also <a href=\"#reject/2\"><code class=\"inline\">reject/2</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.filter([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)\n[2]</code></pre>    <h3 class=\"detail-header function\" id=\"filter_map/3\">  <span class=\"signature\">filter_map(enumerable, filter, mapper)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">filter_map(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term)), (<a href=\"#t:element/0\">element</a> -&gt; <a href=\"#t:element/0\">element</a>)) :: list</code></pre>    <p>Filters the enumerable and maps its elements in one pass.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.filter_map([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end, &amp;(&amp;1 * 2))\n[4]</code></pre>    <h3 class=\"detail-header function\" id=\"find/3\">  <span class=\"signature\">find(enumerable, default \\\\ nil, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">find(<a href=\"#t:t/0\">t</a>, <a href=\"#t:default/0\">default</a>, (<a href=\"#t:element/0\">element</a> -&gt; any)) ::\n  <a href=\"#t:element/0\">element</a> |\n  <a href=\"#t:default/0\">default</a></code></pre>    <p>Returns the first item for which <code class=\"inline\">fun</code> returns a truthy value. If no such item is found, returns <code class=\"inline\">default</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.find([2, 4, 6], fn(x) -&gt; rem(x, 2) == 1 end)\nnil\n\niex&gt; Enum.find([2, 4, 6], 0, fn(x) -&gt; rem(x, 2) == 1 end)\n0\n\niex&gt; Enum.find([2, 3, 4], fn(x) -&gt; rem(x, 2) == 1 end)\n3</code></pre>    <h3 class=\"detail-header function\" id=\"find_index/2\">  <span class=\"signature\">find_index(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">find_index(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; any)) :: <a href=\"#t:index/0\">index</a> | nil</code></pre>    <p>Similar to <a href=\"#find/3\"><code class=\"inline\">find/3</code></a>, but returns the index (zero-based) of the element instead of the element itself.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.find_index([2, 4, 6], fn(x) -&gt; rem(x, 2) == 1 end)\nnil\n\niex&gt; Enum.find_index([2, 3, 4], fn(x) -&gt; rem(x, 2) == 1 end)\n1</code></pre>    <h3 class=\"detail-header function\" id=\"find_value/3\">  <span class=\"signature\">find_value(enumerable, default \\\\ nil, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">find_value(<a href=\"#t:t/0\">t</a>, any, (<a href=\"#t:element/0\">element</a> -&gt; any)) :: any | nil</code></pre>    <p>Similar to <a href=\"#find/3\"><code class=\"inline\">find/3</code></a>, but returns the value of the function invocation instead of the element itself.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.find_value([2, 4, 6], fn(x) -&gt; rem(x, 2) == 1 end)\nnil\n\niex&gt; Enum.find_value([2, 3, 4], fn(x) -&gt; rem(x, 2) == 1 end)\ntrue\n\niex&gt; Enum.find_value([1, 2, 3], \"no bools!\", &amp;is_boolean/1)\n\"no bools!\"</code></pre>    <h3 class=\"detail-header function\" id=\"flat_map/2\">  <span class=\"signature\">flat_map(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">flat_map(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; <a href=\"#t:t/0\">t</a>)) :: list</code></pre>    <p>Returns a new enumerable appending the result of invoking <code class=\"inline\">fun</code> on each corresponding item of <code class=\"inline\">enumerable</code>.</p> <p>The given function must return an enumerable.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.flat_map([:a, :b, :c], fn(x) -&gt; [x, x] end)\n[:a, :a, :b, :b, :c, :c]\n\niex&gt; Enum.flat_map([{1, 3}, {4, 6}], fn({x, y}) -&gt; x..y end)\n[1, 2, 3, 4, 5, 6]\n\niex&gt; Enum.flat_map([:a, :b, :c], fn(x) -&gt; [[x]] end)\n[[:a], [:b], [:c]]</code></pre>    <h3 class=\"detail-header function\" id=\"flat_map_reduce/3\">  <span class=\"signature\">flat_map_reduce(enumerable, acc, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">flat_map_reduce(<a href=\"#t:t/0\">t</a>, acc, fun) :: {[any], any} when fun: (<a href=\"#t:element/0\">element</a>, acc -&gt; {<a href=\"#t:t/0\">t</a>, acc} | {:halt, acc}), acc: any</code></pre>    <p>Maps and reduces an enumerable, flattening the given results (only one level deep).</p> <p>It expects an accumulator and a function that receives each enumerable item, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with <code class=\"inline\">:halt</code> as first element and the accumulator as second.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; enum = 1..100\niex&gt; n = 3\niex&gt; Enum.flat_map_reduce(enum, 0, fn i, acc -&gt;\n...&gt;   if acc &lt; n, do: {[i], acc + 1}, else: {:halt, acc}\n...&gt; end)\n{[1, 2, 3], 3}\n\niex&gt; Enum.flat_map_reduce(1..5, 0, fn(i, acc) -&gt; {[[i]], acc + i} end)\n{[[1], [2], [3], [4], [5]], 15}</code></pre>    <h3 class=\"detail-header function\" id=\"group_by/3\">  <span class=\"signature\">group_by(enumerable, key_fun, mapper_fun \\\\ fn x -&gt; x end)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">group_by(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; any), (<a href=\"#t:element/0\">element</a> -&gt; any)) :: map</code></pre>    <p>Splits the enumerable into groups based on <code class=\"inline\">fun</code>.</p> <p>The result is a map where each key is given by <code class=\"inline\">key_fun</code> and each value is a list of elements given by <code class=\"inline\">value_fun</code>. Ordering is preserved.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.group_by(~w{ant buffalo cat dingo}, &amp;String.length/1)\n%{3 =&gt; [\"ant\", \"cat\"], 7 =&gt; [\"buffalo\"], 5 =&gt; [\"dingo\"]}\n\niex&gt; Enum.group_by(~w{ant buffalo cat dingo}, &amp;String.length/1, &amp;String.first/1)\n%{3 =&gt; [\"a\", \"c\"], 7 =&gt; [\"b\"], 5 =&gt; [\"d\"]}</code></pre>    <h3 class=\"detail-header function\" id=\"intersperse/2\">  <span class=\"signature\">intersperse(enumerable, element)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">intersperse(<a href=\"#t:t/0\">t</a>, <a href=\"#t:element/0\">element</a>) :: list</code></pre>    <p>Intersperses <code class=\"inline\">element</code> between each element of the enumeration.</p> <p>Complexity: O(n).</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.intersperse([1, 2, 3], 0)\n[1, 0, 2, 0, 3]\n\niex&gt; Enum.intersperse([1], 0)\n[1]\n\niex&gt; Enum.intersperse([], 0)\n[]</code></pre>    <h3 class=\"detail-header function\" id=\"into/2\">  <span class=\"signature\">into(enumerable, collectable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">into(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, <a href=\"collectable#t:t/0\">Collectable.t</a>) :: <a href=\"collectable#t:t/0\">Collectable.t</a></code></pre>    <p>Inserts the given <code class=\"inline\">enumerable</code> into a <code class=\"inline\">collectable</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.into([1, 2], [0])\n[0, 1, 2]\n\niex&gt; Enum.into([a: 1, b: 2], %{})\n%{a: 1, b: 2}\n\niex&gt; Enum.into(%{a: 1}, %{b: 2})\n%{a: 1, b: 2}\n\niex&gt; Enum.into([a: 1, a: 2], %{})\n%{a: 2}</code></pre>    <h3 class=\"detail-header function\" id=\"into/3\">  <span class=\"signature\">into(enumerable, collectable, transform)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">into(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, <a href=\"collectable#t:t/0\">Collectable.t</a>, (term -&gt; term)) :: <a href=\"collectable#t:t/0\">Collectable.t</a></code></pre>    <p>Inserts the given <code class=\"inline\">enumerable</code> into a <code class=\"inline\">collectable</code> according to the transformation function.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.into([2, 3], [3], fn x -&gt; x * 3 end)\n[3, 6, 9]</code></pre>    <h3 class=\"detail-header function\" id=\"join/2\">  <span class=\"signature\">join(enumerable, joiner \\\\ \"\")</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">join(<a href=\"#t:t/0\">t</a>, <a href=\"string#t:t/0\">String.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Joins the given enumerable into a binary using <code class=\"inline\">joiner</code> as a separator.</p> <p>If <code class=\"inline\">joiner</code> is not passed at all, it defaults to the empty binary.</p> <p>All items in the enumerable must be convertible to a binary, otherwise an error is raised.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.join([1, 2, 3])\n\"123\"\n\niex&gt; Enum.join([1, 2, 3], \" = \")\n\"1 = 2 = 3\"</code></pre>    <h3 class=\"detail-header function\" id=\"map/2\">  <span class=\"signature\">map(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">map(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; any)) :: list</code></pre>    <p>Returns a list where each item is the result of invoking <code class=\"inline\">fun</code> on each corresponding item of <code class=\"inline\">enumerable</code>.</p> <p>For maps, the function expects a key-value tuple.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.map([1, 2, 3], fn(x) -&gt; x * 2 end)\n[2, 4, 6]\n\niex&gt; Enum.map([a: 1, b: 2], fn({k, v}) -&gt; {k, -v} end)\n[a: -1, b: -2]</code></pre>    <h3 class=\"detail-header function\" id=\"map_join/3\">  <span class=\"signature\">map_join(enumerable, joiner \\\\ \"\", mapper)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">map_join(<a href=\"#t:t/0\">t</a>, <a href=\"string#t:t/0\">String.t</a>, (<a href=\"#t:element/0\">element</a> -&gt; any)) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Maps and joins the given enumerable in one pass.</p> <p><code class=\"inline\">joiner</code> can be either a binary or a list and the result will be of the same type as <code class=\"inline\">joiner</code>. If <code class=\"inline\">joiner</code> is not passed at all, it defaults to an empty binary.</p> <p>All items in the enumerable must be convertible to a binary, otherwise an error is raised.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.map_join([1, 2, 3], &amp;(&amp;1 * 2))\n\"246\"\n\niex&gt; Enum.map_join([1, 2, 3], \" = \", &amp;(&amp;1 * 2))\n\"2 = 4 = 6\"</code></pre>    <h3 class=\"detail-header function\" id=\"map_reduce/3\">  <span class=\"signature\">map_reduce(enumerable, acc, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">map_reduce(<a href=\"#t:t/0\">t</a>, any, (<a href=\"#t:element/0\">element</a>, any -&gt; {any, any})) :: {any, any}</code></pre>    <p>Invokes the given function to each item in the enumerable to reduce it to a single element, while keeping an accumulator.</p> <p>Returns a tuple where the first element is the mapped enumerable and the second one is the final accumulator.</p> <p>The function, <code class=\"inline\">fun</code>, receives two arguments: the first one is the element, and the second one is the accumulator. <code class=\"inline\">fun</code> must return a tuple with two elements in the form of <code class=\"inline\">{result, accumulator}</code>.</p> <p>For maps, the first tuple element must be a <code class=\"inline\">{key, value}</code> tuple.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -&gt; {x * 2, x + acc} end)\n{[2, 4, 6], 6}</code></pre>    <h3 class=\"detail-header function\" id=\"max/1\">  <span class=\"signature\">max(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">max(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:element/0\">element</a> | no_return</code></pre>    <p>Returns the maximal element in the enumerable according to Erlang’s term ordering.</p> <p>If multiple elements are considered maximal, the first one that was found is returned.</p> <p>Raises <a href=\"enum.emptyerror\"><code class=\"inline\">Enum.EmptyError</code></a> if <code class=\"inline\">enumerable</code> is empty.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.max([1, 2, 3])\n3</code></pre>    <h3 class=\"detail-header function\" id=\"max_by/2\">  <span class=\"signature\">max_by(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">max_by(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; any)) ::\n  <a href=\"#t:element/0\">element</a> |\n  no_return</code></pre>    <p>Returns the maximal element in the enumerable as calculated by the given function.</p> <p>If multiple elements are considered maximal, the first one that was found is returned.</p> <p>Raises <a href=\"enum.emptyerror\"><code class=\"inline\">Enum.EmptyError</code></a> if <code class=\"inline\">enumerable</code> is empty.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -&gt; String.length(x) end)\n\"aaa\"\n\niex&gt; Enum.max_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &amp;String.length/1)\n\"aaa\"</code></pre>    <h3 class=\"detail-header function\" id=\"member?/2\">  <span class=\"signature\">member?(enumerable, element)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">member?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:element/0\">element</a>) :: boolean</code></pre>    <p>Checks if <code class=\"inline\">element</code> exists within the enumerable.</p> <p>Membership is tested with the match (<code class=\"inline\">===</code>) operator.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.member?(1..10, 5)\ntrue\niex&gt; Enum.member?(1..10, 5.0)\nfalse\n\niex&gt; Enum.member?([1.0, 2.0, 3.0], 2)\nfalse\niex&gt; Enum.member?([1.0, 2.0, 3.0], 2.000)\ntrue\n\niex&gt; Enum.member?([:a, :b, :c], :d)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"min/1\">  <span class=\"signature\">min(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">min(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:element/0\">element</a> | no_return</code></pre>    <p>Returns the minimal element in the enumerable according to Erlang’s term ordering.</p> <p>If multiple elements are considered minimal, the first one that was found is returned.</p> <p>Raises <a href=\"enum.emptyerror\"><code class=\"inline\">Enum.EmptyError</code></a> if <code class=\"inline\">enumerable</code> is empty.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.min([1, 2, 3])\n1</code></pre>    <h3 class=\"detail-header function\" id=\"min_by/2\">  <span class=\"signature\">min_by(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">min_by(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; any)) ::\n  <a href=\"#t:element/0\">element</a> |\n  no_return</code></pre>    <p>Returns the minimal element in the enumerable as calculated by the given function.</p> <p>If multiple elements are considered minimal, the first one that was found is returned.</p> <p>Raises <a href=\"enum.emptyerror\"><code class=\"inline\">Enum.EmptyError</code></a> if <code class=\"inline\">enumerable</code> is empty.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -&gt; String.length(x) end)\n\"a\"\n\niex&gt; Enum.min_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &amp;String.length/1)\n\"a\"</code></pre>    <h3 class=\"detail-header function\" id=\"min_max/1\">  <span class=\"signature\">min_max(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">min_max(<a href=\"#t:t/0\">t</a>) :: {<a href=\"#t:element/0\">element</a>, <a href=\"#t:element/0\">element</a>} | no_return</code></pre>    <p>Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang’s term ordering.</p> <p>If multiple elements are considered maximal or minimal, the first one that was found is returned.</p> <p>Raises <a href=\"enum.emptyerror\"><code class=\"inline\">Enum.EmptyError</code></a> if <code class=\"inline\">enumerable</code> is empty.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.min_max([2, 3, 1])\n{1, 3}</code></pre>    <h3 class=\"detail-header function\" id=\"min_max_by/2\">  <span class=\"signature\">min_max_by(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">min_max_by(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; any)) ::\n  {<a href=\"#t:element/0\">element</a>, <a href=\"#t:element/0\">element</a>} |\n  no_return</code></pre>    <p>Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function.</p> <p>If multiple elements are considered maximal or minimal, the first one that was found is returned.</p> <p>Raises <a href=\"enum.emptyerror\"><code class=\"inline\">Enum.EmptyError</code></a> if <code class=\"inline\">enumerable</code> is empty.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn(x) -&gt; String.length(x) end)\n{\"c\", \"aaa\"}\n\niex&gt; Enum.min_max_by([\"aaa\", \"a\", \"bb\", \"c\", \"ccc\"], &amp;String.length/1)\n{\"a\", \"aaa\"}</code></pre>    <h3 class=\"detail-header function\" id=\"partition/2\">  <span class=\"signature\">partition(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">partition(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; any)) :: {list, list}</code></pre>    <p>Partitions <code class=\"inline\">enumerable</code> into two lists, where the first one contains elements for which <code class=\"inline\">fun</code> returns a truthy value, and the second one – for which <code class=\"inline\">fun</code> returns <code class=\"inline\">false</code> or <code class=\"inline\">nil</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.partition([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)\n{[2], [1, 3]}</code></pre>    <h3 class=\"detail-header function\" id=\"random/1\">  <span class=\"signature\">random(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">random(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:element/0\">element</a> | no_return</code></pre>    <p>Returns a random element of an enumerable.</p> <p>Raises <a href=\"enum.emptyerror\"><code class=\"inline\">Enum.EmptyError</code></a> if <code class=\"inline\">enumerable</code> is empty.</p> <p>This function uses Erlang’s <code class=\"inline\">:rand</code> module to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</p> <p>The implementation is based on the <a href=\"https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle\">reservoir sampling</a> algorithm. It assumes that the sample being returned can fit into memory; the input <code class=\"inline\">enumerable</code> doesn’t have to, as it is traversed just once.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Although not necessary, let's seed the random algorithm\niex&gt; :rand.seed(:exsplus, {1, 2, 3})\niex&gt; Enum.random([1, 2, 3])\n2\niex&gt; Enum.random([1, 2, 3])\n1</code></pre>    <h3 class=\"detail-header function\" id=\"reduce/2\">  <span class=\"signature\">reduce(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reduce(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a>, any -&gt; any)) :: any</code></pre>    <p>Invokes <code class=\"inline\">fun</code> for each element in the <code class=\"inline\">enumerable</code>, passing that element and the accumulator as arguments. <code class=\"inline\">fun</code>’s return value is stored in the accumulator.</p> <p>The first element of the enumerable is used as the initial value of the accumulator. If you wish to use another value for the accumulator, use <a href=\"enumerable#reduce/3\"><code class=\"inline\">Enumerable.reduce/3</code></a>. This function won’t call the specified function for enumerables that are one-element long.</p> <p>Returns the accumulator.</p> <p>Note that since the first element of the enumerable is used as the initial value of the accumulator, <code class=\"inline\">fun</code> will only be executed <code class=\"inline\">n - 1</code> times where <code class=\"inline\">n</code> is the length of the enumerable.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.reduce([1, 2, 3, 4], fn(x, acc) -&gt; x * acc end)\n24</code></pre>    <h3 class=\"detail-header function\" id=\"reduce/3\">  <span class=\"signature\">reduce(enumerable, acc, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reduce(<a href=\"#t:t/0\">t</a>, any, (<a href=\"#t:element/0\">element</a>, any -&gt; any)) :: any</code></pre>    <p>Invokes <code class=\"inline\">fun</code> for each element in the <code class=\"inline\">enumerable</code>, passing that element and the accumulator <code class=\"inline\">acc</code> as arguments. <code class=\"inline\">fun</code>’s return value is stored in <code class=\"inline\">acc</code>.</p> <p>Returns the accumulator.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.reduce([1, 2, 3], 0, fn(x, acc) -&gt; x + acc end)\n6</code></pre>    <h3 class=\"detail-header function\" id=\"reduce_while/3\">  <span class=\"signature\">reduce_while(enumerable, acc, fun)</span>  </h3>  <p>Reduces the enumerable until <code class=\"inline\">halt</code> is emitted.</p> <p>The return value for <code class=\"inline\">fun</code> is expected to be <code class=\"inline\">{:cont, acc}</code>, return <code class=\"inline\">{:halt, acc}</code> to end the reduction early.</p> <p>Returns the accumulator.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.reduce_while(1..100, 0, fn i, acc -&gt;\n...&gt;   if i &lt; 3, do: {:cont, acc + i}, else: {:halt, acc}\n...&gt; end)\n3</code></pre>    <h3 class=\"detail-header function\" id=\"reject/2\">  <span class=\"signature\">reject(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reject(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term))) :: list</code></pre>    <p>Returns elements of <code class=\"inline\">enumerable</code> for which the function <code class=\"inline\">fun</code> returns <code class=\"inline\">false</code> or <code class=\"inline\">nil</code>.</p> <p>See also <a href=\"#filter/2\"><code class=\"inline\">filter/2</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.reject([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)\n[1, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"reverse/1\">  <span class=\"signature\">reverse(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reverse(<a href=\"#t:t/0\">t</a>) :: list</code></pre>    <p>Returns a list of elements in <code class=\"inline\">enumerable</code> in reverse order.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.reverse([1, 2, 3])\n[3, 2, 1]</code></pre>    <h3 class=\"detail-header function\" id=\"reverse/2\">  <span class=\"signature\">reverse(enumerable, tail)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reverse(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: list</code></pre>    <p>Reverses the elements in <code class=\"inline\">enumerable</code>, appends the tail, and returns it as a list.</p> <p>This is an optimization for <code class=\"inline\">Enum.concat(Enum.reverse(enumerable), tail)</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.reverse([1, 2, 3], [4, 5, 6])\n[3, 2, 1, 4, 5, 6]</code></pre>    <h3 class=\"detail-header function\" id=\"reverse_slice/3\">  <span class=\"signature\">reverse_slice(enumerable, start, count)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reverse_slice(<a href=\"#t:t/0\">t</a>, non_neg_integer, non_neg_integer) :: list</code></pre>    <p>Reverses the enumerable in the range from initial position <code class=\"inline\">start</code> through <code class=\"inline\">count</code> elements.</p> <p>If <code class=\"inline\">count</code> is greater than the size of the rest of the enumerable, then this function will reverse the rest of the enumerable.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n[1, 2, 6, 5, 4, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"scan/2\">  <span class=\"signature\">scan(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">scan(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a>, any -&gt; any)) :: list</code></pre>    <p>Applies the given function to each element in the enumerable, storing the result in a list and passing it as the accumulator for the next computation.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.scan(1..5, &amp;(&amp;1 + &amp;2))\n[1, 3, 6, 10, 15]</code></pre>    <h3 class=\"detail-header function\" id=\"scan/3\">  <span class=\"signature\">scan(enumerable, acc, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">scan(<a href=\"#t:t/0\">t</a>, any, (<a href=\"#t:element/0\">element</a>, any -&gt; any)) :: list</code></pre>    <p>Applies the given function to each element in the enumerable, storing the result in a list and passing it as the accumulator for the next computation. Uses the given <code class=\"inline\">acc</code> as the starting value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.scan(1..5, 0, &amp;(&amp;1 + &amp;2))\n[1, 3, 6, 10, 15]</code></pre>    <h3 class=\"detail-header function\" id=\"shuffle/1\">  <span class=\"signature\">shuffle(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">shuffle(<a href=\"#t:t/0\">t</a>) :: list</code></pre>    <p>Returns a list with the elements of <code class=\"inline\">enumerable</code> shuffled.</p> <p>This function uses Erlang’s <code class=\"inline\">:rand</code> module to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Although not necessary, let's seed the random algorithm\niex&gt; :rand.seed(:exsplus, {1, 2, 3})\niex&gt; Enum.shuffle([1, 2, 3])\n[2, 1, 3]\niex&gt; Enum.shuffle([1, 2, 3])\n[2, 3, 1]</code></pre>    <h3 class=\"detail-header function\" id=\"slice/2\">  <span class=\"signature\">slice(enumerable, range)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">slice(<a href=\"#t:t/0\">t</a>, <a href=\"range#t:t/0\">Range.t</a>) :: list</code></pre>    <p>Returns a subset list of the given enumerable. Drops elements until element position <code class=\"inline\">range.first</code>, then takes elements until element position <code class=\"inline\">range.last</code> (inclusive).</p> <p>Positions are calculated by adding the number of items in the enumerable to negative positions (e.g. position -3 in an enumerable with count 5 becomes position 2).</p> <p>The first position (after adding count to negative positions) must be smaller or equal to the last position.</p> <p>If the start of the range is not a valid offset for the given enumerable or if the range is in reverse order, returns <code class=\"inline\">[]</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.slice(1..100, 5..10)\n[6, 7, 8, 9, 10, 11]\n\niex&gt; Enum.slice(1..10, 5..20)\n[6, 7, 8, 9, 10]\n\niex&gt; Enum.slice(1..10, 11..20)\n[]\n\niex&gt; Enum.slice(1..10, 6..5)\n[]</code></pre>    <h3 class=\"detail-header function\" id=\"slice/3\">  <span class=\"signature\">slice(enumerable, start, count)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">slice(<a href=\"#t:t/0\">t</a>, integer, non_neg_integer) :: list</code></pre>    <p>Returns a subset list of the given enumerable. Drops elements until element position <code class=\"inline\">start</code>, then takes <code class=\"inline\">count</code> elements.</p> <p>If the count is greater than <code class=\"inline\">enumerable</code> length, it returns as many as possible. If zero, then it returns <code class=\"inline\">[]</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.slice(1..100, 5, 10)\n[6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\niex&gt; Enum.slice(1..10, 5, 100)\n[6, 7, 8, 9, 10]\n\niex&gt; Enum.slice(1..10, 5, 0)\n[]</code></pre>    <h3 class=\"detail-header function\" id=\"sort/1\">  <span class=\"signature\">sort(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">sort(<a href=\"#t:t/0\">t</a>) :: list</code></pre>    <p>Sorts the enumerable according to Erlang’s term ordering.</p> <p>Uses the merge sort algorithm.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.sort([3, 2, 1])\n[1, 2, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"sort/2\">  <span class=\"signature\">sort(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">sort(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a>, <a href=\"#t:element/0\">element</a> -&gt; boolean)) :: list</code></pre>    <p>Sorts the enumerable by the given function.</p> <p>This function uses the merge sort algorithm. The given function should compare two arguments, and return <code class=\"inline\">false</code> if the first argument follows the second one.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.sort([1, 2, 3], &amp;(&amp;1 &gt; &amp;2))\n[3, 2, 1]</code></pre> <p>The sorting algorithm will be stable as long as the given function returns <code class=\"inline\">true</code> for values considered equal:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], &amp;(byte_size(&amp;1) &lt;= byte_size(&amp;2))\n[\"of\", \"some\", \"kind\", \"monster\"]</code></pre> <p>If the function does not return <code class=\"inline\">true</code> for equal values, the sorting is not stable and the order of equal terms may be shuffled. For example:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], &amp;(byte_size(&amp;1) &lt; byte_size(&amp;2))\n[\"of\", \"kind\", \"some\", \"monster\"]</code></pre>    <h3 class=\"detail-header function\" id=\"sort_by/3\">  <span class=\"signature\">sort_by(enumerable, mapper, sorter \\\\ &amp;&lt;=/2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">sort_by(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; mapped_element), (mapped_element, mapped_element -&gt; boolean)) :: list when mapped_element: <a href=\"#t:element/0\">element</a></code></pre>    <p>Sorts the mapped results of the enumerable according to the <code class=\"inline\">sorter</code> function.</p> <p>This function maps each element of the enumerable using the <code class=\"inline\">mapper</code> function. The enumerable is then sorted by the mapped elements using the <code class=\"inline\">sorter</code> function, which defaults to <a href=\"kernel#%253C=/2\"><code class=\"inline\">Kernel.&lt;=/2</code></a></p> <p><a href=\"#sort_by/3\"><code class=\"inline\">sort_by/3</code></a> differs from <a href=\"#sort/2\"><code class=\"inline\">sort/2</code></a> in that it only calculates the comparison value for each element in the enumerable once instead of once for each element in each comparison. If the same function is being called on both element, it’s also more compact to use <a href=\"#sort_by/3\"><code class=\"inline\">sort_by/3</code></a>.</p> <p>This technique is also known as a <em><a href=\"https://en.wikipedia.org/wiki/Schwartzian_transform\">Schwartzian Transform</a></em>, or the <em>Lisp decorate-sort-undecorate idiom</em> as the <code class=\"inline\">mapper</code> is decorating the original <code class=\"inline\">enumerable</code>; then <code class=\"inline\">sorter</code> is sorting the decorations; and finally the enumerable is being undecorated so only the original elements remain, but now in sorted order.</p> <h4>Examples</h4> <p>Using the default <code class=\"inline\">sorter</code> of <code class=\"inline\">&lt;=/2</code>:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], &amp;byte_size/1\n[\"of\", \"some\", \"kind\", \"monster\"]</code></pre> <p>Using a custom <code class=\"inline\">sorter</code> to override the order:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], &amp;byte_size/1, &amp;&gt;=/2\n[\"monster\", \"some\", \"kind\", \"of\"]</code></pre>    <h3 class=\"detail-header function\" id=\"split/2\">  <span class=\"signature\">split(enumerable, count)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">split(<a href=\"#t:t/0\">t</a>, integer) :: {list, list}</code></pre>    <p>Splits the <code class=\"inline\">enumerable</code> into two enumerables, leaving <code class=\"inline\">count</code> elements in the first one. If <code class=\"inline\">count</code> is a negative number, it starts counting from the back to the beginning of the enumerable.</p> <p>Be aware that a negative <code class=\"inline\">count</code> implies the <code class=\"inline\">enumerable</code> will be enumerated twice: once to calculate the position, and a second time to do the actual splitting.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.split([1, 2, 3], 2)\n{[1, 2], [3]}\n\niex&gt; Enum.split([1, 2, 3], 10)\n{[1, 2, 3], []}\n\niex&gt; Enum.split([1, 2, 3], 0)\n{[], [1, 2, 3]}\n\niex&gt; Enum.split([1, 2, 3], -1)\n{[1, 2], [3]}\n\niex&gt; Enum.split([1, 2, 3], -5)\n{[], [1, 2, 3]}</code></pre>    <h3 class=\"detail-header function\" id=\"split_while/2\">  <span class=\"signature\">split_while(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">split_while(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term))) :: {list, list}</code></pre>    <p>Splits enumerable in two at the position of the element for which <code class=\"inline\">fun</code> returns <code class=\"inline\">false</code> for the first time.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.split_while([1, 2, 3, 4], fn(x) -&gt; x &lt; 3 end)\n{[1, 2], [3, 4]}</code></pre>    <h3 class=\"detail-header function\" id=\"sum/1\">  <span class=\"signature\">sum(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">sum(<a href=\"#t:t/0\">t</a>) :: number</code></pre>    <p>Returns the sum of all elements.</p> <p>Raises <a href=\"arithmeticerror\"><code class=\"inline\">ArithmeticError</code></a> if <code class=\"inline\">enumerable</code> contains a non-numeric value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.sum([1, 2, 3])\n6</code></pre>    <h3 class=\"detail-header function\" id=\"take/2\">  <span class=\"signature\">take(enumerable, count)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">take(<a href=\"#t:t/0\">t</a>, integer) :: list</code></pre>    <p>Takes the first <code class=\"inline\">count</code> items from the enumerable.</p> <p><code class=\"inline\">count</code> must be an integer. If a negative <code class=\"inline\">count</code> is given, the last <code class=\"inline\">count</code> values will be taken. For such, the enumerable is fully enumerated keeping up to <code class=\"inline\">2 * count</code> elements in memory. Once the end of the enumerable is reached, the last <code class=\"inline\">count</code> elements are returned.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.take([1, 2, 3], 2)\n[1, 2]\n\niex&gt; Enum.take([1, 2, 3], 10)\n[1, 2, 3]\n\niex&gt; Enum.take([1, 2, 3], 0)\n[]\n\niex&gt; Enum.take([1, 2, 3], -1)\n[3]</code></pre>    <h3 class=\"detail-header function\" id=\"take_every/2\">  <span class=\"signature\">take_every(enumerable, nth)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">take_every(<a href=\"#t:t/0\">t</a>, non_neg_integer) :: list | no_return</code></pre>    <p>Returns a list of every <code class=\"inline\">nth</code> item in the enumerable, starting with the first element.</p> <p>The first item is always included, unless <code class=\"inline\">nth</code> is 0.</p> <p>The second argument specifying every <code class=\"inline\">nth</code> item must be a non-negative integer, otherwise <a href=\"functionclauseerror\"><code class=\"inline\">FunctionClauseError</code></a> will be raised.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.take_every(1..10, 2)\n[1, 3, 5, 7, 9]\n\niex&gt; Enum.take_every(1..10, 0)\n[]\n\niex&gt; Enum.take_every([1, 2, 3], 1)\n[1, 2, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"take_random/2\">  <span class=\"signature\">take_random(enumerable, count)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">take_random(<a href=\"#t:t/0\">t</a>, non_neg_integer) :: list</code></pre>    <p>Takes random items from <code class=\"inline\">enumerable</code>.</p> <p>Notice this function will traverse the whole <code class=\"inline\">enumerable</code> to get the random sublist.</p> <p>See <a href=\"#random/1\"><code class=\"inline\">random/1</code></a> for notes on implementation and random seed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Although not necessary, let's seed the random algorithm\niex&gt; :rand.seed(:exsplus, {1, 2, 3})\niex&gt; Enum.take_random(1..10, 2)\n[5, 8]\niex&gt; Enum.take_random(?a..?z, 5)\n'fhjni'</code></pre>    <h3 class=\"detail-header function\" id=\"take_while/2\">  <span class=\"signature\">take_while(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">take_while(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term))) :: list</code></pre>    <p>Takes the items from the beginning of the enumerable while <code class=\"inline\">fun</code> returns a truthy value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.take_while([1, 2, 3], fn(x) -&gt; x &lt; 3 end)\n[1, 2]</code></pre>    <h3 class=\"detail-header function\" id=\"to_list/1\">  <span class=\"signature\">to_list(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_list(<a href=\"#t:t/0\">t</a>) :: [<a href=\"#t:element/0\">element</a>]</code></pre>    <p>Converts <code class=\"inline\">enumerable</code> to a list.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.to_list(1..3)\n[1, 2, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"uniq/1\">  <span class=\"signature\">uniq(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">uniq(<a href=\"#t:t/0\">t</a>) :: list</code></pre>    <p>Enumerates the <code class=\"inline\">enumerable</code>, removing all duplicated elements.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.uniq([1, 2, 3, 3, 2, 1])\n[1, 2, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"uniq_by/2\">  <span class=\"signature\">uniq_by(enumerable, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">uniq_by(<a href=\"#t:t/0\">t</a>, (<a href=\"#t:element/0\">element</a> -&gt; term)) :: list</code></pre>    <p>Enumerates the <code class=\"inline\">enumerable</code>, by removing the elements for which function <code class=\"inline\">fun</code> returned duplicate items.</p> <p>The function <code class=\"inline\">fun</code> maps every element to a term which is used to determine if two elements are duplicates.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -&gt; x end)\n[{1, :x}, {2, :y}]\n\niex&gt; Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -&gt; y end)\n[a: {:tea, 2}, c: {:coffee, 1}]</code></pre>    <h3 class=\"detail-header function\" id=\"unzip/1\">  <span class=\"signature\">unzip(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unzip(<a href=\"#t:t/0\">t</a>) :: {[<a href=\"#t:element/0\">element</a>], [<a href=\"#t:element/0\">element</a>]}</code></pre>    <p>Opposite of <a href=\"enum#zip/2\"><code class=\"inline\">Enum.zip/2</code></a>; extracts a two-element tuples from the enumerable and groups them together.</p> <p>It takes an enumerable with items being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively.</p> <p>This function fails unless <code class=\"inline\">enumerable</code> is or can be converted into a list of tuples with <em>exactly</em> two elements in each tuple.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n{[:a, :b, :c], [1, 2, 3]}\n\niex&gt; Enum.unzip(%{a: 1, b: 2})\n{[:a, :b], [1, 2]}</code></pre>    <h3 class=\"detail-header function\" id=\"with_index/2\">  <span class=\"signature\">with_index(enumerable, offset \\\\ 0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">with_index(<a href=\"#t:t/0\">t</a>, integer) :: [{<a href=\"#t:element/0\">element</a>, integer}]</code></pre>    <p>Returns the enumerable with each element wrapped in a tuple alongside its index.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.with_index([:a, :b, :c])\n[a: 0, b: 1, c: 2]\n\niex&gt; Enum.with_index([:a, :b, :c], 3)\n[a: 3, b: 4, c: 5]</code></pre>    <h3 class=\"detail-header function\" id=\"zip/2\">  <span class=\"signature\">zip(enumerable1, enumerable2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">zip(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: [{any, any}]</code></pre>    <p>Zips corresponding elements from two enumerables into one list of tuples.</p> <p>The zipping finishes as soon as any enumerable completes.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.zip([1, 2, 3], [:a, :b, :c])\n[{1, :a}, {2, :b}, {3, :c}]\n\niex&gt; Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n[{1, :a}, {2, :b}, {3, :c}]</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Enum.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Enum.html</a>\n  </p>\n</div>\n","elixir/module":"<h1>  Module  </h1>  <p>Provides functions to deal with modules during compilation time.</p> <p>It allows a developer to dynamically add, delete and register attributes, attach documentation and so forth.</p> <p>After a module is compiled, using many of the functions in this module will raise errors, since it is out of their scope to inspect runtime data. Most of the runtime data can be inspected via the <code class=\"inline\">__info__(attr)</code> function attached to each compiled module.</p> <h2 id=\"module-module-attributes\" class=\"section-heading\">  Module attributes </h2> <p>Each module can be decorated with one or more attributes. The following ones are currently defined by Elixir:</p> <ul> <li>\n<p><code class=\"inline\">@after_compile</code></p> <p>A hook that will be invoked right after the current module is compiled. Accepts a module or a tuple <code class=\"inline\">{&lt;module&gt;, &lt;function atom&gt;}</code>. See the “Compile callbacks” section below.</p> </li> <li>\n<p><code class=\"inline\">@before_compile</code></p> <p>A hook that will be invoked before the module is compiled. Accepts a module or a tuple <code class=\"inline\">{&lt;module&gt;, &lt;function/macro atom&gt;}</code>. See the “Compile callbacks” section below.</p> </li> <li>\n<p><code class=\"inline\">@behaviour</code> (notice the British spelling)</p> <p>Behaviours can be referenced by modules to ensure they implement required specific function signatures defined by <code class=\"inline\">@callback</code>.</p> <p>For example, you can specify the URI.Parser behaviour as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule URI.Parser do\n  @doc \"Parses the given URL\"\n  @callback parse(uri_info :: URI.t) :: URI.t\n\n  @doc \"Defines a default port\"\n  @callback default_port() :: integer\nend\n\nAnd then a module may use it as:\n\ndefmodule URI.HTTP do\n  @behaviour URI.Parser\n  def default_port(), do: 80\n  def parse(info), do: info\nend</code></pre> <p>If the behaviour changes or URI.HTTP does not implement one of the callbacks, a warning will be raised.</p> <p>Specifies an OTP or user-defined behaviour.</p> <h3>Example</h3> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule M do\n  @behaviour :gen_event\n\n  # ...\nend</code></pre> </li> <li>\n<p><code class=\"inline\">@callback</code>, <code class=\"inline\">@macrocallback</code>, and <code class=\"inline\">@optional_callbacks</code></p> <p>These attributes are used to define a behaviour (as shown in the documentation for <code class=\"inline\">@behaviour</code> above). <code class=\"inline\">@callback</code> defines a function callback, <code class=\"inline\">@macrocallback</code> defines a macro callback, and <code class=\"inline\">@optional_callbacks</code> specifies which callbacks and macrocallbacks are optional.</p> </li> <li>\n<p><code class=\"inline\">@compile</code></p> <p>Defines options for module compilation. This is used to configure both Elixir and Erlang compilers, as any other compilation pass added by external tools.</p> <p>Multiple uses of <code class=\"inline\">@compile</code> will accumulate instead of overriding previous ones. See the “Compile options” section below.</p> <h3>Example</h3> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule M do\n  @compile {:inline, myfun: 1}\n\n  def myfun(arg) do\n    to_string(arg)\n  end\nend</code></pre> </li> <li>\n<p><code class=\"inline\">@doc</code></p> <p>Provides documentation for the function or macro that follows the attribute.</p> <p>Accepts a string (often a heredoc) or <code class=\"inline\">false</code> where <code class=\"inline\">@doc false</code> will make the function/macro invisible to the documentation extraction tools like ExDoc.</p> <p>Can be invoked more than once.</p> <h3>Example</h3> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule M do\n  @doc \"Hello world\"\n  def hello do\n    \"world\"\n  end\n\n  @doc \"\"\"\n  Sums `a` to `b`.\n  \"\"\"\n  def sum(a, b) do\n    a + b\n  end\nend</code></pre> </li> <li>\n<p><code class=\"inline\">@dialyzer</code></p> <p>Defines warnings to request or suppress when using a version of <code class=\"inline\">:dialyzer</code> that supports module attributes.</p> <p>Accepts an atom, a tuple, or a list of atoms and tuples.</p> <p>For the list of supported warnings, see <a href=\"http://www.erlang.org/doc/man/dialyzer.html\"><code class=\"inline\">:dialyzer</code> module</a>.</p> <p>Multiple uses of <code class=\"inline\">@dialyzer</code> will accumulate instead of overriding previous ones.</p> <h3>Example</h3> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule M do\n  @dialyzer {:nowarn_function, myfun: 1}\n\n  def myfun(arg) do\n    M.not_a_function(arg)\n  end\nend</code></pre> </li> <li>\n<p><code class=\"inline\">@external_resource</code></p> <p>Specifies an external resource to the current module.</p> <p>Many times a module embeds information from an external file. This attribute allows the module to annotate which external resources have been used.</p> <p>Tools like Mix may use this information to ensure the module is recompiled in case any of the external resources change.</p> </li> <li>\n<p><code class=\"inline\">@file</code></p> <p>Changes the filename used in stacktraces for the function or macro that follows the attribute.</p> <p>Accepts a string. Can be used more than once.</p> <h3>Example</h3> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule M do\n  @doc \"Hello world\"\n  @file \"hello.ex\"\n  def hello do\n    \"world\"\n  end\nend</code></pre> </li> <li>\n<p><code class=\"inline\">@moduledoc</code></p> <p>Provides documentation for the current module.</p> <p>Accepts a string (which is often a heredoc) or <code class=\"inline\">false</code> where <code class=\"inline\">@moduledoc false</code> will make the module invisible to the documentation extraction tools like ExDoc.</p> <h3>Example</h3> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule M do\n  @moduledoc \"\"\"\n  A very useful module\n  \"\"\"\nend</code></pre> </li> <li>\n<p><code class=\"inline\">@on_definition</code></p> <p>A hook that will be invoked when each function or macro in the current module is defined. Useful when annotating functions.</p> <p>Accepts a module or a tuple <code class=\"inline\">{&lt;module&gt;, &lt;function atom&gt;}</code>. See the “Compile callbacks” section below.</p> </li> <li>\n<p><code class=\"inline\">@on_load</code></p> <p>A hook that will be invoked whenever the module is loaded.</p> <p>Accepts a function atom of a function in the current module. The function must have arity 0 (no arguments) and has to return <code class=\"inline\">:ok</code>, otherwise the loading of the module will be aborted.</p> <h3>Example</h3> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule M do\n  @on_load :load_check\n\n  def load_check do\n    if some_condition() do\n      :ok\n    else\n      nil\n    end\n  end\n\n  def some_condition do\n    false\n  end\nend</code></pre> </li> <li>\n<p><code class=\"inline\">@vsn</code></p> <p>Specify the module version. Accepts any valid Elixir value.</p> <h3>Example</h3> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule M do\n  @vsn \"1.0\"\nend</code></pre> </li> </ul> <p>The following attributes are part of typespecs and are also reserved by Elixir:</p> <ul> <li>\n<code class=\"inline\">@type</code> - defines a type to be used in <code class=\"inline\">@spec</code> </li> <li>\n<code class=\"inline\">@typep</code> - defines a private type to be used in <code class=\"inline\">@spec</code> </li> <li>\n<code class=\"inline\">@opaque</code> - defines an opaque type to be used in <code class=\"inline\">@spec</code> </li> <li>\n<code class=\"inline\">@spec</code> - provides a specification for a function </li> <li>\n<code class=\"inline\">@callback</code> - provides a specification for a behaviour callback </li> <li>\n<code class=\"inline\">@macrocallback</code> - provides a specification for a macro behaviour callback </li> <li>\n<code class=\"inline\">@optional_callbacks</code> - specifies which behaviour callbacks and macro behaviour callbacks are optional </li> </ul> <p>In addition to the built-in attributes outlined above, custom attributes may also be added. A custom attribute is any valid identifier prefixed with an <code class=\"inline\">@</code> and followed by a valid Elixir value:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule M do\n  @custom_attr [some: \"stuff\"]\nend</code></pre> <p>For more advanced options available when defining custom attributes, see <a href=\"#register_attribute/3\"><code class=\"inline\">register_attribute/3</code></a>.</p> <h2 id=\"module-compile-callbacks\" class=\"section-heading\">  Compile callbacks </h2> <p>There are three callbacks that are invoked when functions are defined, as well as before and immediately after the module bytecode is generated.</p> <h3><code class=\"inline\">@after_compile</code></h3> <p>A hook that will be invoked right after the current module is compiled.</p> <p>Accepts a module or a tuple <code class=\"inline\">{&lt;module&gt;, &lt;function atom&gt;}</code>. The function must take two arguments: the module environment and its bytecode. When just a module is provided, the function is assumed to be <code class=\"inline\">__after_compile__/2</code>.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule M do\n  @after_compile __MODULE__\n\n  def __after_compile__(env, _bytecode) do\n    IO.inspect env\n  end\nend</code></pre> <h3><code class=\"inline\">@before_compile</code></h3> <p>A hook that will be invoked before the module is compiled.</p> <p>Accepts a module or a tuple <code class=\"inline\">{&lt;module&gt;, &lt;function/macro atom&gt;}</code>. The function/macro must take one argument: the module environment. If it’s a macro, its returned value will be injected at the end of the module definition before the compilation starts.</p> <p>When just a module is provided, the function/macro is assumed to be <code class=\"inline\">__before_compile__/1</code>.</p> <p>Note: unlike <code class=\"inline\">@after_compile</code>, the callback function/macro must be placed in a separate module (because when the callback is invoked, the current module does not yet exist).</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule A do\n  defmacro __before_compile__(_env) do\n    quote do\n      def hello, do: \"world\"\n    end\n  end\nend\n\ndefmodule B do\n  @before_compile A\nend</code></pre> <h3><code class=\"inline\">@on_definition</code></h3> <p>A hook that will be invoked when each function or macro in the current module is defined. Useful when annotating functions.</p> <p>Accepts a module or a tuple <code class=\"inline\">{&lt;module&gt;, &lt;function atom&gt;}</code>. The function must take 6 arguments:</p> <ul> <li>the module environment </li> <li>kind: <code class=\"inline\">:def</code>, <code class=\"inline\">:defp</code>, <code class=\"inline\">:defmacro</code>, or <code class=\"inline\">:defmacrop</code> </li> <li>function/macro name </li> <li>list of quoted arguments </li> <li>list of quoted guards </li> <li>quoted function body </li> </ul> <p>Note the hook receives the quoted arguments and it is invoked before the function is stored in the module. So <a href=\"module#defines?/2\"><code class=\"inline\">Module.defines?/2</code></a> will return <code class=\"inline\">false</code> for the first clause of every function.</p> <p>If the function/macro being defined has multiple clauses, the hook will be called for each clause.</p> <p>Unlike other hooks, <code class=\"inline\">@on_definition</code> will only invoke functions and never macros. This is because the hook is invoked inside the context of the function (and nested function definitions are not allowed in Elixir).</p> <p>When just a module is provided, the function is assumed to be <code class=\"inline\">__on_definition__/6</code>.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule H do\n  def on_def(_env, kind, name, args, guards, body) do\n    IO.puts \"Defining #{kind} named #{name} with args:\"\n    IO.inspect args\n    IO.puts \"and guards\"\n    IO.inspect guards\n    IO.puts \"and body\"\n    IO.puts Macro.to_string(body)\n  end\nend\n\ndefmodule M do\n  @on_definition {H, :on_def}\n\n  def hello(arg) when is_binary(arg) or is_list(arg) do\n    \"Hello\" &lt;&gt; to_string(arg)\n  end\n\n  def hello(_) do\n    :ok\n  end\nend</code></pre> <h2 id=\"module-compile-options\" class=\"section-heading\">  Compile options </h2> <p>The <code class=\"inline\">@compile</code> attribute accepts diverse options that is used by both Elixir and Erlang compilers. Some of the common use cases are documented below:</p> <ul> <li>\n<p><code class=\"inline\">@compile :debug_info</code> - includes <code class=\"inline\">:debug_info</code> regardless of the setting in <code class=\"inline\">Code.compiler_options</code></p> </li> <li>\n<p><code class=\"inline\">@compile {:debug_info, false}</code> - disables <code class=\"inline\">:debug_info</code> regardless of the setting in <code class=\"inline\">Code.compiler_options</code></p> </li> <li>\n<p><code class=\"inline\">@compile {:inline, some_fun: 2, other_fun: 3}</code> - inlines the given name/arity pairs</p> </li> <li>\n<code class=\"inline\">@compile {:autoload, false}</code> - disables automatic loading of modules after compilation. Instead, the module will be loaded after it is dispatched to </li> </ul> <p>You can see a handful more options used by the Erlang compiler in the documentation for the <code class=\"inline\">:compile</code> module.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#__info__/1\">__info__(kind)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Provides runtime information about functions and macros defined by the module, enables docstring extraction, etc</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#add_doc/6\">add_doc(module, line, kind, tuple, signature \\\\ [], doc)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Attaches documentation to a given function or type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#concat/1\">concat(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Concatenates a list of aliases and returns a new alias</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#concat/2\">concat(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Concatenates two aliases and returns a new alias</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#create/3\">create(module, quoted, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a module with the given name and defined by the given quoted expressions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defines?/2\">defines?(module, tuple)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the module defines the given function or macro</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defines?/3\">defines?(module, tuple, kind)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the module defines a function or macro of the given <code class=\"inline\">kind</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#definitions_in/1\">definitions_in(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all functions defined in <code class=\"inline\">module</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#definitions_in/2\">definitions_in(module, kind)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all functions defined in <code class=\"inline\">module</code>, according to its kind</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete_attribute/2\">delete_attribute(module, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes all attributes that match the given key</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#eval_quoted/4\">eval_quoted(module, quoted, binding \\\\ [], opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Evaluates the quoted contents in the given module’s context</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_attribute/2\">get_attribute(module, key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the given attribute from a module</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#make_overridable/2\">make_overridable(module, tuples)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Makes the given functions in <code class=\"inline\">module</code> overridable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#open?/1\">open?(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if a module is open, i.e. it is currently being defined and its attributes and functions can be modified</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#overridable?/2\">overridable?(module, tuple)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">tuple</code> in <code class=\"inline\">module</code> is marked as overridable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_attribute/3\">put_attribute(module, key, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts an Erlang attribute to the given module with the given key and value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#register_attribute/3\">register_attribute(module, new, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Registers an attribute. By registering an attribute, a developer is able to customize how Elixir will store and accumulate the attribute values</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#safe_concat/1\">safe_concat(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Concatenates a list of aliases and returns a new alias only if the alias was already referenced</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#safe_concat/2\">safe_concat(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Concatenates two aliases and returns a new alias only if the alias was already referenced</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#split/1\">split(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Splits the given module name into binary parts</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"__info__/1\">  <span class=\"signature\">__info__(kind)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">__info__(:attributes | :compile | :exports | :functions | :macros | :md5 | :module | :native_addresses) ::\n  atom |\n  [{atom, any} | {atom, byte, integer}]</code></pre>    <p>Provides runtime information about functions and macros defined by the module, enables docstring extraction, etc.</p> <p>Each module gets an <a href=\"#__info__/1\"><code class=\"inline\">__info__/1</code></a> function when it’s compiled. The function takes one of the following atoms:</p> <ul> <li>\n<p><code class=\"inline\">:functions</code> - keyword list of public functions along with their arities</p> </li> <li>\n<p><code class=\"inline\">:macros</code> - keyword list of public macros along with their arities</p> </li> <li>\n<code class=\"inline\">:module</code> - module name (<code class=\"inline\">Module == Module.__info__(:module)</code>) </li> </ul> <p>In addition to the above, you may also pass to <a href=\"#__info__/1\"><code class=\"inline\">__info__/1</code></a> any atom supported by <a href=\"http://www.erlang.org/doc/man/erlang.html#module_info-0\"><code class=\"inline\">:erlang.module_info/0</code></a> which also gets defined for each compiled module.</p> <p>For a list of supported attributes and more information, see <a href=\"http://www.erlang.org/doc/reference_manual/modules.html#id77056\">Modules – Erlang Reference Manual</a>.</p>    <h3 class=\"detail-header function\" id=\"add_doc/6\">  <span class=\"signature\">add_doc(module, line, kind, tuple, signature \\\\ [], doc)</span>  </h3>  <p>Attaches documentation to a given function or type.</p> <p>It expects the module the function/type belongs to, the line (a non negative integer), the kind (<code class=\"inline\">def</code> or <code class=\"inline\">defmacro</code>), a tuple representing the function and its arity, the function signature (the signature should be omitted for types) and the documentation, which should be either a binary or a boolean.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyModule do\n  Module.add_doc(__MODULE__, __ENV__.line + 1, :def, {:version, 0}, [], \"Manually added docs\")\n  def version, do: 1\nend</code></pre>    <h3 class=\"detail-header function\" id=\"concat/1\">  <span class=\"signature\">concat(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">concat([binary | atom]) :: atom</code></pre>    <p>Concatenates a list of aliases and returns a new alias.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Module.concat([Foo, Bar])\nFoo.Bar\n\niex&gt; Module.concat([Foo, \"Bar\"])\nFoo.Bar</code></pre>    <h3 class=\"detail-header function\" id=\"concat/2\">  <span class=\"signature\">concat(left, right)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">concat(binary | atom, binary | atom) :: atom</code></pre>    <p>Concatenates two aliases and returns a new alias.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Module.concat(Foo, Bar)\nFoo.Bar\n\niex&gt; Module.concat(Foo, \"Bar\")\nFoo.Bar</code></pre>    <h3 class=\"detail-header function\" id=\"create/3\">  <span class=\"signature\">create(module, quoted, opts)</span>  </h3>  <p>Creates a module with the given name and defined by the given quoted expressions.</p> <p>The line where the module is defined and its file <strong>must</strong> be passed as options.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">contents =\n  quote do\n    def world, do: true\n  end\n\nModule.create(Hello, contents, Macro.Env.location(__ENV__))\n\nHello.world #=&gt; true</code></pre> <h4>Differences from <code class=\"inline\">defmodule</code>\n</h4> <p><a href=\"module#create/3\"><code class=\"inline\">Module.create/3</code></a> works similarly to <code class=\"inline\">defmodule</code> and return the same results. While one could also use <code class=\"inline\">defmodule</code> to define modules dynamically, this function is preferred when the module body is given by a quoted expression.</p> <p>Another important distinction is that <a href=\"module#create/3\"><code class=\"inline\">Module.create/3</code></a> allows you to control the environment variables used when defining the module, while <code class=\"inline\">defmodule</code> automatically shares the same environment.</p>    <h3 class=\"detail-header function\" id=\"defines?/2\">  <span class=\"signature\">defines?(module, tuple)</span>  </h3>  <p>Checks if the module defines the given function or macro.</p> <p>Use <a href=\"#defines?/3\"><code class=\"inline\">defines?/3</code></a> to assert for a specific type.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Example do\n  Module.defines? __MODULE__, {:version, 0} #=&gt; false\n  def version, do: 1\n  Module.defines? __MODULE__, {:version, 0} #=&gt; true\nend</code></pre>    <h3 class=\"detail-header function\" id=\"defines?/3\">  <span class=\"signature\">defines?(module, tuple, kind)</span>  </h3>  <p>Checks if the module defines a function or macro of the given <code class=\"inline\">kind</code>.</p> <p><code class=\"inline\">kind</code> can be any of <code class=\"inline\">:def</code>, <code class=\"inline\">:defp</code>, <code class=\"inline\">:defmacro</code> or <code class=\"inline\">:defmacrop</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Example do\n  Module.defines? __MODULE__, {:version, 0}, :defp #=&gt; false\n  def version, do: 1\n  Module.defines? __MODULE__, {:version, 0}, :defp #=&gt; false\nend</code></pre>    <h3 class=\"detail-header function\" id=\"definitions_in/1\">  <span class=\"signature\">definitions_in(module)</span>  </h3>  <p>Returns all functions defined in <code class=\"inline\">module</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Example do\n  def version, do: 1\n  Module.definitions_in __MODULE__ #=&gt; [{:version, 0}]\nend</code></pre>    <h3 class=\"detail-header function\" id=\"definitions_in/2\">  <span class=\"signature\">definitions_in(module, kind)</span>  </h3>  <p>Returns all functions defined in <code class=\"inline\">module</code>, according to its kind.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Example do\n  def version, do: 1\n  Module.definitions_in __MODULE__, :def  #=&gt; [{:version, 0}]\n  Module.definitions_in __MODULE__, :defp #=&gt; []\nend</code></pre>    <h3 class=\"detail-header function\" id=\"delete_attribute/2\">  <span class=\"signature\">delete_attribute(module, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete_attribute(atom, atom) :: :ok</code></pre>    <p>Deletes all attributes that match the given key.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyModule do\n  Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n  Module.delete_attribute __MODULE__, :custom_threshold_for_lib\nend</code></pre>    <h3 class=\"detail-header function\" id=\"eval_quoted/4\">  <span class=\"signature\">eval_quoted(module, quoted, binding \\\\ [], opts \\\\ [])</span>  </h3>  <p>Evaluates the quoted contents in the given module’s context.</p> <p>A list of environment options can also be given as argument. See <a href=\"code#eval_string/3\"><code class=\"inline\">Code.eval_string/3</code></a> for more information.</p> <p>Raises an error if the module was already compiled.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Foo do\n  contents = quote do: (def sum(a, b), do: a + b)\n  Module.eval_quoted __MODULE__, contents\nend\n\nFoo.sum(1, 2) #=&gt; 3</code></pre> <p>For convenience, you can pass <code class=\"inline\">__ENV__</code> as an argument and all options will be automatically extracted from the environment:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Foo do\n  contents = quote do: (def sum(a, b), do: a + b)\n  Module.eval_quoted __MODULE__, contents, [], __ENV__\nend\n\nFoo.sum(1, 2) #=&gt; 3</code></pre>    <h3 class=\"detail-header function\" id=\"get_attribute/2\">  <span class=\"signature\">get_attribute(module, key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_attribute(atom, atom) :: term</code></pre>    <p>Gets the given attribute from a module.</p> <p>If the attribute was marked with <code class=\"inline\">accumulate</code> with <a href=\"module#register_attribute/3\"><code class=\"inline\">Module.register_attribute/3</code></a>, a list is always returned. <code class=\"inline\">nil</code> is returned if the attribute has not been marked with <code class=\"inline\">accumulate</code> and has not been set to any value.</p> <p>The <code class=\"inline\">@</code> macro compiles to a call to this function. For example, the following code:</p> <pre data-language=\"elixir\"><code class=\"elixir\">@foo</code></pre> <p>Expands close to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Module.get_attribute(__MODULE__, :foo)</code></pre> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Foo do\n  Module.put_attribute __MODULE__, :value, 1\n  Module.get_attribute __MODULE__, :value #=&gt; 1\n\n  Module.register_attribute __MODULE__, :value, accumulate: true\n  Module.put_attribute __MODULE__, :value, 1\n  Module.get_attribute __MODULE__, :value #=&gt; [1]\nend</code></pre>    <h3 class=\"detail-header function\" id=\"make_overridable/2\">  <span class=\"signature\">make_overridable(module, tuples)</span>  </h3>  <p>Makes the given functions in <code class=\"inline\">module</code> overridable.</p> <p>An overridable function is lazily defined, allowing a developer to customize it. See <a href=\"kernel#defoverridable/1\"><code class=\"inline\">Kernel.defoverridable/1</code></a> for more information and documentation.</p>    <h3 class=\"detail-header function\" id=\"open?/1\">  <span class=\"signature\">open?(module)</span>  </h3>  <p>Checks if a module is open, i.e. it is currently being defined and its attributes and functions can be modified.</p>    <h3 class=\"detail-header function\" id=\"overridable?/2\">  <span class=\"signature\">overridable?(module, tuple)</span>  </h3>  <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">tuple</code> in <code class=\"inline\">module</code> is marked as overridable.</p>    <h3 class=\"detail-header function\" id=\"put_attribute/3\">  <span class=\"signature\">put_attribute(module, key, value)</span>  </h3>  <p>Puts an Erlang attribute to the given module with the given key and value.</p> <p>The semantics of putting the attribute depends if the attribute was registered or not via <a href=\"#register_attribute/3\"><code class=\"inline\">register_attribute/3</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyModule do\n  Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\nend</code></pre>    <h3 class=\"detail-header function\" id=\"register_attribute/3\">  <span class=\"signature\">register_attribute(module, new, opts)</span>  </h3>  <p>Registers an attribute. By registering an attribute, a developer is able to customize how Elixir will store and accumulate the attribute values.</p> <h4>Options</h4> <p>When registering an attribute, two options can be given:</p> <ul> <li>\n<p><code class=\"inline\">:accumulate</code> - several calls to the same attribute will accumulate instead of override the previous one. New attributes are always added to the top of the accumulated list.</p> </li> <li>\n<code class=\"inline\">:persist</code> - the attribute will be persisted in the Erlang Abstract Format. Useful when interfacing with Erlang libraries. </li> </ul> <p>By default, both options are <code class=\"inline\">false</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyModule do\n  Module.register_attribute __MODULE__,\n    :custom_threshold_for_lib,\n    accumulate: true, persist: false\n\n  @custom_threshold_for_lib 10\n  @custom_threshold_for_lib 20\n  @custom_threshold_for_lib #=&gt; [20, 10]\nend</code></pre>    <h3 class=\"detail-header function\" id=\"safe_concat/1\">  <span class=\"signature\">safe_concat(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">safe_concat([binary | atom]) :: atom | no_return</code></pre>    <p>Concatenates a list of aliases and returns a new alias only if the alias was already referenced.</p> <p>If the alias was not referenced yet, fails with <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a>. It handles charlists, binaries and atoms.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Module.safe_concat([Module, Unknown])\n** (ArgumentError) argument error\n\niex&gt; Module.safe_concat([List, Chars])\nList.Chars</code></pre>    <h3 class=\"detail-header function\" id=\"safe_concat/2\">  <span class=\"signature\">safe_concat(left, right)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">safe_concat(binary | atom, binary | atom) ::\n  atom |\n  no_return</code></pre>    <p>Concatenates two aliases and returns a new alias only if the alias was already referenced.</p> <p>If the alias was not referenced yet, fails with <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a>. It handles charlists, binaries and atoms.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Module.safe_concat(Module, Unknown)\n** (ArgumentError) argument error\n\niex&gt; Module.safe_concat(List, Chars)\nList.Chars</code></pre>    <h3 class=\"detail-header function\" id=\"split/1\">  <span class=\"signature\">split(module)</span>  </h3>  <p>Splits the given module name into binary parts.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Module.split Very.Long.Module.Name.And.Even.Longer\n[\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", \"Longer\"]</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Module.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Module.html</a>\n  </p>\n</div>\n","elixir/port":"<h1>  Port  </h1>  <p>Functions related to Erlang ports.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:name/0\">name()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#call/3\">call(port, operation, data)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Makes a synchronous call to the <code class=\"inline\">port</code> and returns its reply as a term</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#close/1\">close(port)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Closes the <code class=\"inline\">port</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#command/3\">command(port, data, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends <code class=\"inline\">data</code> to the port driver <code class=\"inline\">port</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#connect/2\">connect(port, pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Associates the <code class=\"inline\">port</code> identifier with a <code class=\"inline\">pid</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#control/3\">control(port, operation, data)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends a synchronous control command to the <code class=\"inline\">port</code> and returns its reply as a binary</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#info/1\">info(port)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns information about the <code class=\"inline\">port</code> or <code class=\"inline\">nil</code> if the port is closed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#info/2\">info(port, spec)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns information about the <code class=\"inline\">port</code> or <code class=\"inline\">nil</code> if the port is closed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#list/0\">list()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of the ports for the current node</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#open/2\">open(name, settings)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Opens an Erlang port given a tuple <code class=\"inline\">name</code> and a list of <code class=\"inline\">settings</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:name/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:name/0\">name</a> ::\n  {:spawn, charlist | binary} |\n  {:spawn_driver, charlist | binary} |\n  {:spawn_executable, charlist | atom} |\n  {:fd, non_neg_integer, non_neg_integer}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"call/3\">  <span class=\"signature\">call(port, operation, data)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">call(port, integer, term) :: term</code></pre>    <p>Makes a synchronous call to the <code class=\"inline\">port</code> and returns its reply as a term.</p> <p>Not all port drivers support this control feature.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#port_call-3\"><code class=\"inline\">:erlang.port_call/3</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"close/1\">  <span class=\"signature\">close(port)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">close(port) :: true</code></pre>    <p>Closes the <code class=\"inline\">port</code>.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#port_close-1\"><code class=\"inline\">:erlang.port_close/1</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"command/3\">  <span class=\"signature\">command(port, data, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">command(port, iodata, [:force | :nosuspend]) :: boolean</code></pre>    <p>Sends <code class=\"inline\">data</code> to the port driver <code class=\"inline\">port</code>.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#port_command-2\"><code class=\"inline\">:erlang.port_command/2</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"connect/2\">  <span class=\"signature\">connect(port, pid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">connect(port, pid) :: true</code></pre>    <p>Associates the <code class=\"inline\">port</code> identifier with a <code class=\"inline\">pid</code>.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#port_connect-2\"><code class=\"inline\">:erlang.port_connect/2</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"control/3\">  <span class=\"signature\">control(port, operation, data)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">control(port, integer, iodata) :: iodata | binary</code></pre>    <p>Sends a synchronous control command to the <code class=\"inline\">port</code> and returns its reply as a binary.</p> <p>Not all port drivers support this feature.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#port_control-3\"><code class=\"inline\">:erlang.port_control/3</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"info/1\">  <span class=\"signature\">info(port)</span>  </h3>  <p>Returns information about the <code class=\"inline\">port</code> or <code class=\"inline\">nil</code> if the port is closed.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#port_info-1\"><code class=\"inline\">:erlang.port_info/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"info/2\">  <span class=\"signature\">info(port, spec)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">info(port, atom) :: {atom, term} | nil</code></pre>    <p>Returns information about the <code class=\"inline\">port</code> or <code class=\"inline\">nil</code> if the port is closed.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#port_info-2\"><code class=\"inline\">:erlang.port_info/2</code></a>.</p>    <h3 class=\"detail-header function\" id=\"list/0\">  <span class=\"signature\">list()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">list :: [port]</code></pre>    <p>Returns a list of the ports for the current node.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#ports-0\"><code class=\"inline\">:erlang.ports/0</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"open/2\">  <span class=\"signature\">open(name, settings)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">open(<a href=\"#t:name/0\">name</a>, list) :: port</code></pre>    <p>Opens an Erlang port given a tuple <code class=\"inline\">name</code> and a list of <code class=\"inline\">settings</code>.</p> <h4>Name</h4> <p>The supported values for <code class=\"inline\">name</code> are:</p> <ul> <li>\n<code class=\"inline\">{:spawn, command}</code> - to run an external program. The first space separated word of <code class=\"inline\">command</code> will be considered as the name of the program to run, so use <code class=\"inline\">{:spawn_executable, command}</code> to run a program having spaces in its name. </li> <li>\n<code class=\"inline\">{:spawn_driver, command}</code> - similar to <code class=\"inline\">{:spawn, command}</code>, but to run a loaded driver. </li> <li>\n<code class=\"inline\">{:spawn_executable, filename}</code> - similar to <code class=\"inline\">{:spawn, filename}</code>, but to run an external executable. With this option, <code class=\"inline\">filename</code> in its whole is considered the name of the program to execute. </li> <li>\n<code class=\"inline\">{:fd, fd_in, fd_out}</code> - to access file descriptors used by Erlang, <code class=\"inline\">fd_in</code> being used for standard input, <code class=\"inline\">fd_out</code> for standard output. </li> </ul> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#open_port-2\"><code class=\"inline\">:erlang.open_port/2</code></a>.</p> <p>Inlined by the compiler.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Port.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Port.html</a>\n  </p>\n</div>\n","elixir/record":"<h1>  Record  </h1>  <p>Module to work with, define and import records.</p> <p>Records are simply tuples where the first element is an atom:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Record.is_record {User, \"john\", 27}\ntrue</code></pre> <p>This module provides conveniences for working with records at compilation time, where compile-time field names are used to manipulate the tuples, providing fast operations on top of the tuples’ compact structure.</p> <p>In Elixir, records are used mostly in two situations:</p> <ol> <li>to work with short, internal data </li> <li>to interface with Erlang records </li> </ol> <p>The macros <a href=\"#defrecord/3\"><code class=\"inline\">defrecord/3</code></a> and <a href=\"#defrecordp/3\"><code class=\"inline\">defrecordp/3</code></a> can be used to create records while <a href=\"#extract/2\"><code class=\"inline\">extract/2</code></a> can be used to extract records from Erlang files.</p> <h2 id=\"module-types\" class=\"section-heading\">  Types </h2> <p>Types can be defined for tuples with the <code class=\"inline\">record/2</code> macro (only available in typespecs). Like with the generated record macros it will expand to a tuple.</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyModule do\n  require Record\n  Record.defrecord :user, name: \"john\", age: 25\n\n  @type user :: record(:user, name: String.t, age: integer)\n  # expands to: \"@type user :: {:user, String.t, integer}\"\nend</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#extract/2\">extract(name, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Extracts record information from an Erlang file</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#extract_all/1\">extract_all(opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Extracts all records information from an Erlang file</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#defrecord/3\">defrecord(name, tag \\\\ nil, kv)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a set of macros to create and access a record</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defrecordp/3\">defrecordp(name, tag \\\\ nil, kv)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#defrecord/3\"><code class=\"inline\">defrecord/3</code></a> but generates private macros</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_record/1\">is_record(data)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the given <code class=\"inline\">data</code> is a record</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_record/2\">is_record(data, kind)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the given <code class=\"inline\">data</code> is a record of <code class=\"inline\">kind</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"extract/2\">  <span class=\"signature\">extract(name, opts)</span>  </h3>  <p>Extracts record information from an Erlang file.</p> <p>Returns a quoted expression containing the fields as a list of tuples. It expects the record name to be an atom and the library path to be a string at expansion time.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n[size: :undefined, type: :undefined, access: :undefined, atime: :undefined,\n mtime: :undefined, ctime: :undefined, mode: :undefined, links: :undefined,\n major_device: :undefined, minor_device: :undefined, inode: :undefined,\n uid: :undefined, gid: :undefined]</code></pre>    <h3 class=\"detail-header function\" id=\"extract_all/1\">  <span class=\"signature\">extract_all(opts)</span>  </h3>  <p>Extracts all records information from an Erlang file.</p> <p>Returns a keyword list containing extracted record names as keys, and lists of tuples describing the fields as values. It expects a named argument :from or :from_lib, which correspond to <em>include</em> or <em>include_lib</em> attribute from Erlang modules, respectively.</p>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"defrecord/3\">  <span class=\"signature\">defrecord(name, tag \\\\ nil, kv)</span>  </h3>  <p>Defines a set of macros to create and access a record.</p> <p>The macros are going to have <code class=\"inline\">name</code>, a tag (which defaults) to the name if none is given, and a set of fields given by <code class=\"inline\">kv</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  require Record\n  Record.defrecord :user, [name: \"meg\", age: \"25\"]\nend</code></pre> <p>In the example above, a set of macros named <code class=\"inline\">user</code> but with different arities will be defined to manipulate the underlying record:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># To create records\nrecord = user()        #=&gt; {:user, \"meg\", 25}\nrecord = user(age: 26) #=&gt; {:user, \"meg\", 26}\n\n# To get a field from the record\nuser(record, :name) #=&gt; \"meg\"\n\n# To update the record\nuser(record, age: 26) #=&gt; {:user, \"meg\", 26}\n\n# Convert a record to a keyword list\nuser(record) #=&gt; [name: \"meg\", age: 26]</code></pre> <p>The generated macros can also be used in order to pattern match on records and to bind variables during the match:</p> <pre data-language=\"elixir\"><code class=\"elixir\">record = user() #=&gt; {:user, \"meg\", 25}\n\nuser(name: name) = record\nname #=&gt; \"meg\"</code></pre> <p>By default, Elixir uses the record name as the first element of the tuple (the tag). But it can be changed to something else:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  require Record\n  Record.defrecord :user, User, name: nil\nend\n\nrequire User\nUser.user() #=&gt; {User, nil}</code></pre> <h4>Defining extracted records with anonymous functions</h4> <p>If a record defines an anonymous function, an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> will occur if you attempt to create a record with it. This can occur unintentionally when defining a record after extracting it from an Erlang library that uses anonymous functions for defaults.</p> <pre data-language=\"elixir\"><code class=\"elixir\">Record.defrecord :my_rec, Record.extract(...)\n#=&gt; ** (ArgumentError) invalid value for record field fun_field,\ncannot escape #Function&lt;12.90072148/2 in :erl_eval.expr/5&gt;.</code></pre> <p>To work around this error, redefine the field with your own &amp;M.f/a function, like so:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyRec do\n  require Record\n  Record.defrecord :my_rec, Record.extract(...) |&gt; Keyword.merge(fun_field: &amp;__MODULE__.foo/2)\n  def foo(bar, baz), do: IO.inspect({bar, baz})\nend</code></pre>    <h3 class=\"detail-header macro\" id=\"defrecordp/3\">  <span class=\"signature\">defrecordp(name, tag \\\\ nil, kv)</span>  </h3>  <p>Same as <a href=\"#defrecord/3\"><code class=\"inline\">defrecord/3</code></a> but generates private macros.</p>    <h3 class=\"detail-header macro\" id=\"is_record/1\">  <span class=\"signature\">is_record(data)</span>  </h3>  <p>Checks if the given <code class=\"inline\">data</code> is a record.</p> <p>This is implemented as a macro so it can be used in guard clauses.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; record = {User, \"john\", 27}\niex&gt; Record.is_record(record)\ntrue\niex&gt; tuple = {}\niex&gt; Record.is_record(tuple)\nfalse</code></pre>    <h3 class=\"detail-header macro\" id=\"is_record/2\">  <span class=\"signature\">is_record(data, kind)</span>  </h3>  <p>Checks if the given <code class=\"inline\">data</code> is a record of <code class=\"inline\">kind</code>.</p> <p>This is implemented as a macro so it can be used in guard clauses.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; record = {User, \"john\", 27}\niex&gt; Record.is_record(record, User)\ntrue</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Record.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Record.html</a>\n  </p>\n</div>\n","elixir/set":"<h1>  Set  </h1>  <p>WARNING: this module is deprecated.</p> <p>Use the <a href=\"mapset\"><code class=\"inline\">MapSet</code></a> module instead.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:value/0\">value()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:values/0\">values()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#delete/2\">delete(set, value)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#difference/2\">difference(set1, set2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#disjoint?/2\">disjoint?(set1, set2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#equal?/2\">equal?(set1, set2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#intersection/2\">intersection(set1, set2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#member?/2\">member?(set, value)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#put/2\">put(set, value)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#size/1\">size(set)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#subset?/2\">subset?(set1, set2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#to_list/1\">to_list(set)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#union/2\">union(set1, set2)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: map</code></pre> </div> <div id=\"t:value/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:value/0\">value</a> :: any</code></pre> </div> <div id=\"t:values/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:values/0\">values</a> :: [<a href=\"#t:value/0\">value</a>]</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"delete/2\">  <span class=\"signature\">delete(set, value)</span>  </h3>     <h3 class=\"detail-header function\" id=\"difference/2\">  <span class=\"signature\">difference(set1, set2)</span>  </h3>     <h3 class=\"detail-header function\" id=\"disjoint?/2\">  <span class=\"signature\">disjoint?(set1, set2)</span>  </h3>     <h3 class=\"detail-header function\" id=\"equal?/2\">  <span class=\"signature\">equal?(set1, set2)</span>  </h3>     <h3 class=\"detail-header function\" id=\"intersection/2\">  <span class=\"signature\">intersection(set1, set2)</span>  </h3>     <h3 class=\"detail-header function\" id=\"member?/2\">  <span class=\"signature\">member?(set, value)</span>  </h3>     <h3 class=\"detail-header function\" id=\"put/2\">  <span class=\"signature\">put(set, value)</span>  </h3>     <h3 class=\"detail-header function\" id=\"size/1\">  <span class=\"signature\">size(set)</span>  </h3>     <h3 class=\"detail-header function\" id=\"subset?/2\">  <span class=\"signature\">subset?(set1, set2)</span>  </h3>     <h3 class=\"detail-header function\" id=\"to_list/1\">  <span class=\"signature\">to_list(set)</span>  </h3>     <h3 class=\"detail-header function\" id=\"union/2\">  <span class=\"signature\">union(set1, set2)</span>  </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Set.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Set.html</a>\n  </p>\n</div>\n","elixir/kernel.specialforms":"<h1>  Kernel.SpecialForms  </h1>  <p>Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.</p> <p>We define them in this module. Some of these forms are lexical (like <a href=\"#alias/2\"><code class=\"inline\">alias/2</code></a>, <a href=\"#case/2\"><code class=\"inline\">case/2</code></a>, etc). The macros <code class=\"inline\">{}</code> and <code class=\"inline\">&lt;&lt;&gt;&gt;</code> are also special forms used to define tuple and binary data structures respectively.</p> <p>This module also documents Elixir’s pseudo variables (<code class=\"inline\">__ENV__</code>, <code class=\"inline\">__MODULE__</code>, <code class=\"inline\">__DIR__</code> and <code class=\"inline\">__CALLER__</code>). Pseudo variables return information about Elixir’s compilation environment and can only be read, never assigned to.</p> <p>Finally, it also documents two special forms, <code class=\"inline\">__block__</code> and <code class=\"inline\">__aliases__</code>, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir’s constructs.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#%25/2\">%</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%25%7B%7D/1\">%{}</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a map</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#&amp;/1\">&amp;(expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Captures or creates an anonymous function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#./2\">left . right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a remote call or an alias</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#::/2\">left :: right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Used by types and bitstrings to specify types</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%3C%3C%3E%3E/1\">&lt;&lt;args&gt;&gt;</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a new bitstring</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#=/2\">left = right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Matches the value on the right against the pattern on the left</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%5E/1\">^var</a> </dt> <dd class=\"summary-synopsis\">\n<p>Accesses an already bound variable in match clauses. Also known as the pin operator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#__CALLER__/0\">__CALLER__</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current calling environment as a <a href=\"macro.env\"><code class=\"inline\">Macro.Env</code></a> struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#__DIR__/0\">__DIR__</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the absolute path of the directory of the current file as a binary</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#__ENV__/0\">__ENV__</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current environment information as a <a href=\"macro.env\"><code class=\"inline\">Macro.Env</code></a> struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#__MODULE__/0\">__MODULE__</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current module name as an atom or <code class=\"inline\">nil</code> otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#__aliases__/1\">__aliases__(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Internal special form to hold aliases information</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#__block__/1\">__block__(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Internal special form for block expressions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#alias/2\">alias(module, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p><a href=\"#alias/2\"><code class=\"inline\">alias/2</code></a> is used to setup aliases, often useful with modules names</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#case/2\">case(condition, clauses)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Matches the given expression against the given clauses</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cond/1\">cond(clauses)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Evaluates the expression corresponding to the first clause that evaluates to a truthy value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#fn/1\">fn [clauses] end</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines an anonymous function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#for/1\">for(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#import/2\">import(module, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Imports functions and macros from other modules</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#quote/2\">quote(opts, block)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the representation of any expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#receive/1\">receive(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if there is a message matching the given clauses in the current process mailbox</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#require/2\">require(module, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Requires a given module to be compiled and loaded</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#super/1\">super(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calls the overridden function when overriding it with <a href=\"kernel#defoverridable/1\"><code class=\"inline\">Kernel.defoverridable/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#try/1\">try(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Evaluates the given expressions and handles any error, exit or throw that may have happened</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unquote/1\">unquote(expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Unquotes the given expression from inside a macro</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unquote_splicing/1\">unquote_splicing(expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Unquotes the given list expanding its arguments. Similar to <a href=\"#unquote/1\"><code class=\"inline\">unquote/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#with/1\">with(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Used to combine matching clauses</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%7B%7D/1\">{args}</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a tuple</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"%25/2\">  <span class=\"signature\">%</span>  </h3>  <p>Creates a struct.</p> <p>A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions.</p> <p>Structs are usually defined with the <a href=\"kernel#defstruct/1\"><code class=\"inline\">Kernel.defstruct/1</code></a> macro:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  defstruct name: \"john\", age: 27\nend</code></pre> <p>Now a struct can be created as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%User{}</code></pre> <p>Underneath a struct is just a map with a <code class=\"inline\">:__struct__</code> key pointing to the <code class=\"inline\">User</code> module:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%User{} == %{__struct__: User, name: \"john\", age: 27}</code></pre> <p>A struct also validates that the given keys are part of the defined struct. The example below will fail because there is no key <code class=\"inline\">:full_name</code> in the <code class=\"inline\">User</code> struct:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%User{full_name: \"john doe\"}</code></pre> <p>An update operation specific for structs is also available:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%User{user | age: 28}</code></pre> <p>The syntax above will guarantee the given keys are valid at compilation time and it will guarantee at runtime the given argument is a struct, failing with <a href=\"badstructerror\"><code class=\"inline\">BadStructError</code></a> otherwise.</p> <p>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. Check <a href=\"kernel#defprotocol/2\"><code class=\"inline\">Kernel.defprotocol/2</code></a> for more information on how structs can be used with protocols for polymorphic dispatch. Also see <a href=\"kernel#struct/2\"><code class=\"inline\">Kernel.struct/2</code></a> and <a href=\"kernel#struct!/2\"><code class=\"inline\">Kernel.struct!/2</code></a> for examples on how to create and update structs dynamically.</p>    <h3 class=\"detail-header macro\" id=\"%25%7B%7D/1\">  <span class=\"signature\">%{}</span>  </h3>  <p>Creates a map.</p> <p>Maps are key-value stores where keys are compared using the match operator (<code class=\"inline\">===</code>). Maps can be created with the <code class=\"inline\">%{}</code> special form where keys are associated via <code class=\"inline\">=&gt;</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%{1 =&gt; 2}</code></pre> <p>Maps also support the keyword notation, as other special forms, as long as they are at the end of the argument list:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%{hello: :world, with: :keywords}\n%{:hello =&gt; :world, with: :keywords}</code></pre> <p>If a map has duplicated keys, the last key will always have higher precedence:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; %{a: :b, a: :c}\n%{a: :c}</code></pre> <p>Conveniences for manipulating maps can be found in the <a href=\"map\"><code class=\"inline\">Map</code></a> module.</p> <h4>Access syntax</h4> <p>Besides the access functions available in the <a href=\"map\"><code class=\"inline\">Map</code></a> module, like <a href=\"map#get/3\"><code class=\"inline\">Map.get/3</code></a> and <a href=\"map#fetch/2\"><code class=\"inline\">Map.fetch/2</code></a>, a map can be accessed using the <code class=\"inline\">.</code> operator:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; map = %{a: :b}\niex&gt; map.a\n:b</code></pre> <p>Note that the <code class=\"inline\">.</code> operator expects the key <code class=\"inline\">:a</code> to exist in the map. If not, an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> is raised.</p> <h4>Update syntax</h4> <p>Maps also support an update syntax:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; map = %{:a =&gt; :b}\niex&gt; %{map | :a =&gt; :c}\n%{:a =&gt; :c}</code></pre> <p>Notice the update syntax requires the given keys to exist. Trying to update a key that does not exist will raise an <a href=\"keyerror\"><code class=\"inline\">KeyError</code></a>.</p> <h4>AST representation</h4> <p>Regardless if <code class=\"inline\">=&gt;</code> or the keywords syntax is used, Maps are always represented internally as a list of two-element tuples for simplicity:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; quote do\n...&gt;   %{\"a\" =&gt; :b, c: :d}\n...&gt; end\n{:%{}, [], [{\"a\", :b}, {:c, :d}]}</code></pre>    <h3 class=\"detail-header macro\" id=\"&amp;/1\">  <span class=\"signature\">&amp;(expr)</span>  </h3>  <p>Captures or creates an anonymous function.</p> <h4>Capture</h4> <p>The capture operator is most commonly used to capture a function with given name and arity from a module:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; fun = &amp;Kernel.is_atom/1\niex&gt; fun.(:atom)\ntrue\niex&gt; fun.(\"string\")\nfalse</code></pre> <p>In the example above, we captured <a href=\"kernel#is_atom/1\"><code class=\"inline\">Kernel.is_atom/1</code></a> as an anonymous function and then invoked it.</p> <p>The capture operator can also be used to capture local functions, including private ones, and imported functions by omitting the module name:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&amp;local_function/1</code></pre> <h4>Anonymous functions</h4> <p>The capture operator can also be used to partially apply functions, where <code class=\"inline\">&amp;1</code>, <code class=\"inline\">&amp;2</code> and so on can be used as value placeholders. For example:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; double = &amp;(&amp;1 * 2)\niex&gt; double.(2)\n4</code></pre> <p>In other words, <code class=\"inline\">&amp;(&amp;1 * 2)</code> is equivalent to <code class=\"inline\">fn x -&gt; x * 2 end</code>. Another example using a local function:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; fun = &amp;is_atom(&amp;1)\niex&gt; fun.(:atom)\ntrue</code></pre> <p>The <code class=\"inline\">&amp;</code> operator can be used with more complex expressions:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; fun = &amp;(&amp;1 + &amp;2 + &amp;3)\niex&gt; fun.(1, 2, 3)\n6</code></pre> <p>As well as with lists and tuples:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; fun = &amp;{&amp;1, &amp;2}\niex&gt; fun.(1, 2)\n{1, 2}\n\niex&gt; fun = &amp;[&amp;1 | &amp;2]\niex&gt; fun.(1, 2)\n[1 | 2]</code></pre> <p>The only restrictions when creating anonymous functions is that at least one placeholder must be present, i.e. it must contain at least <code class=\"inline\">&amp;1</code>, and that block expressions are not supported:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># No placeholder, fails to compile.\n&amp;(:foo)\n\n# Block expression, fails to compile.\n&amp;(&amp;1; &amp;2)</code></pre>    <h3 class=\"detail-header macro\" id=\"./2\">  <span class=\"signature\">left . right</span>  </h3>  <p>Defines a remote call or an alias.</p> <p>The dot (<code class=\"inline\">.</code>) in Elixir can be used for remote calls:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.downcase(\"FOO\")\n\"foo\"</code></pre> <p>In this example above, we have used <code class=\"inline\">.</code> to invoke <code class=\"inline\">downcase</code> in the <a href=\"string\"><code class=\"inline\">String</code></a> alias, passing “FOO” as argument. We can also use the dot for creating aliases:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Hello.World\nHello.World</code></pre> <p>This time, we have joined two aliases, defining the final alias <code class=\"inline\">Hello.World</code>.</p> <h4>Syntax</h4> <p>The right side of <code class=\"inline\">.</code> may be a word starting in upcase, which represents an alias, a word starting with lowercase or underscore, any valid language operator or any name wrapped in single- or double-quotes. Those are all valid examples:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Kernel.Sample\nKernel.Sample\n\niex&gt; Kernel.length([1, 2, 3])\n3\n\niex&gt; Kernel.+(1, 2)\n3\n\niex&gt; Kernel.\"length\"([1, 2, 3])\n3\n\niex&gt; Kernel.'+'(1, 2)\n3</code></pre> <p>Note that <code class=\"inline\">Kernel.\"HELLO\"</code> will be treated as a remote call and not an alias. This choice was done so every time single- or double-quotes are used, we have a remote call regardless of the quote contents. This decision is also reflected in the quoted expressions discussed below.</p> <h4>Quoted expression</h4> <p>When <code class=\"inline\">.</code> is used, the quoted expression may take two distinct forms. When the right side starts with a lowercase letter (or underscore):</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; quote do\n...&gt;   String.downcase(\"FOO\")\n...&gt; end\n{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}</code></pre> <p>Notice we have an inner tuple, containing the atom <code class=\"inline\">:.</code> representing the dot as first element:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}</code></pre> <p>This tuple follows the general quoted expression structure in Elixir, with the name as first argument, some keyword list as metadata as second, and the number of arguments as third. In this case, the arguments is the alias <a href=\"string\"><code class=\"inline\">String</code></a> and the atom <code class=\"inline\">:downcase</code>. The second argument is <strong>always</strong> an atom:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; quote do\n...&gt;   String.\"downcase\"(\"FOO\")\n...&gt; end\n{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}</code></pre> <p>The tuple containing <code class=\"inline\">:.</code> is wrapped in another tuple, which actually represents the function call, and has <code class=\"inline\">\"FOO\"</code> as argument.</p> <p>When the right side is an alias (i.e. starts with uppercase), we get instead:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; quote do\n...&gt;   Hello.World\n...&gt; end\n{:__aliases__, [alias: false], [:Hello, :World]}</code></pre> <p>We go into more details about aliases in the <code class=\"inline\">__aliases__</code> special form documentation.</p> <h4>Unquoting</h4> <p>We can also use unquote to generate a remote call in a quoted expression:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; x = :downcase\niex&gt; quote do\n...&gt;   String.unquote(x)(\"FOO\")\n...&gt; end\n{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}</code></pre> <p>Similar to <code class=\"inline\">Kernel.\"HELLO\"</code>, <code class=\"inline\">unquote(x)</code> will always generate a remote call, independent of the value of <code class=\"inline\">x</code>. To generate an alias via the quoted expression, one needs to rely on <a href=\"module#concat/2\"><code class=\"inline\">Module.concat/2</code></a>:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; x = Sample\niex&gt; quote do\n...&gt;   Module.concat(String, unquote(x))\n...&gt; end\n{{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],\n [{:__aliases__, [alias: false], [:String]}, Sample]}</code></pre>    <h3 class=\"detail-header macro\" id=\"::/2\">  <span class=\"signature\">left :: right</span>  </h3>  <p>Used by types and bitstrings to specify types.</p> <p>This operator is used in two distinct occasions in Elixir. It is used in typespecs to specify the type of a variable, function or of a type itself:</p> <pre data-language=\"elixir\"><code class=\"elixir\">@type number :: integer | float\n@spec add(number, number) :: number</code></pre> <p>It may also be used in bit strings to specify the type of a given bit segment:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;&lt;int::integer-little, rest::bits&gt;&gt; = bits</code></pre> <p>Read the documentation on the <code class=\"inline\">Typespec</code> page and <a href=\"#%253C%253C%253E%253E/1\"><code class=\"inline\">&lt;&lt;&gt;&gt;/1</code></a> for more information on typespecs and bitstrings respectively.</p>    <h3 class=\"detail-header macro\" id=\"%3C%3C%3E%3E/1\">  <span class=\"signature\">&lt;&lt;args&gt;&gt;</span>  </h3>  <p>Defines a new bitstring.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; &lt;&lt;1, 2, 3&gt;&gt;\n&lt;&lt;1, 2, 3&gt;&gt;</code></pre> <h4>Types</h4> <p>A bitstring is made of many segments and each segment has a type. There are 9 types used in bitstrings:</p> <ul> <li>\n<code class=\"inline\">integer</code> </li> <li>\n<code class=\"inline\">float</code> </li> <li>\n<code class=\"inline\">bits</code> (alias for bitstring) </li> <li>\n<code class=\"inline\">bitstring</code> </li> <li>\n<code class=\"inline\">binary</code> </li> <li>\n<code class=\"inline\">bytes</code> (alias for binary) </li> <li>\n<code class=\"inline\">utf8</code> </li> <li>\n<code class=\"inline\">utf16</code> </li> <li>\n<code class=\"inline\">utf32</code> </li> </ul> <p>When no type is specified, the default is <code class=\"inline\">integer</code>:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; &lt;&lt;1, 2, 3&gt;&gt;\n&lt;&lt;1, 2, 3&gt;&gt;</code></pre> <p>Elixir also accepts by default the segment to be a literal string or a literal charlist, which are by default expanded to integers:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; &lt;&lt;0, \"foo\"&gt;&gt;\n&lt;&lt;0, 102, 111, 111&gt;&gt;</code></pre> <p>Variables or any other type need to be explicitly tagged:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; rest = \"oo\"\niex&gt; &lt;&lt;102, rest&gt;&gt;\n** (ArgumentError) argument error</code></pre> <p>We can solve this by explicitly tagging it as a binary:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; rest = \"oo\"\niex&gt; &lt;&lt;102, rest::binary&gt;&gt;\n\"foo\"</code></pre> <p>The utf8, utf16, and utf32 types are for Unicode codepoints. They can also be applied to literal strings and charlists:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; &lt;&lt;\"foo\"::utf16&gt;&gt;\n&lt;&lt;0, 102, 0, 111, 0, 111&gt;&gt;\niex&gt; &lt;&lt;\"foo\"::utf32&gt;&gt;\n&lt;&lt;0, 0, 0, 102, 0, 0, 0, 111, 0, 0, 0, 111&gt;&gt;</code></pre> <h4>Options</h4> <p>Many options can be given by using <code class=\"inline\">-</code> as separator. Order is arbitrary, so the following are all equivalent:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;&lt;102::integer-native, rest::binary&gt;&gt;\n&lt;&lt;102::native-integer, rest::binary&gt;&gt;\n&lt;&lt;102::unsigned-big-integer, rest::binary&gt;&gt;\n&lt;&lt;102::unsigned-big-integer-size(8), rest::binary&gt;&gt;\n&lt;&lt;102::unsigned-big-integer-8, rest::binary&gt;&gt;\n&lt;&lt;102::8-integer-big-unsigned, rest::binary&gt;&gt;\n&lt;&lt;102, rest::binary&gt;&gt;</code></pre> <h3>Unit and Size</h3> <p>The length of the match is equal to the <code class=\"inline\">unit</code> (a number of bits) times the <code class=\"inline\">size</code> (the number of repeated segments of length <code class=\"inline\">unit</code>).</p> <table> <colgroup> <col> <col> </colgroup> <thead> <tr> <th style=\"text-align: left\">Type</th>\n<th style=\"text-align: left\">Default Unit</th> </tr> </thead> <tr> <td style=\"text-align: left\"><code class=\"inline\">integer</code></td>\n<td style=\"text-align: left\">1 bit</td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">float</code></td>\n<td style=\"text-align: left\">1 bit</td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">binary</code></td>\n<td style=\"text-align: left\">8 bits</td> </tr> </table> <p>Sizes for types are a bit more nuanced. The default size for integers is 8.</p> <p>For floats, it is 64. For floats, <code class=\"inline\">size * unit</code> must result in 32 or 64, corresponding to <a href=\"https://en.wikipedia.org/wiki/IEEE_floating_point\">IEEE 754</a> binary32 and binary64, respectively.</p> <p>For binaries, the default is the size of the binary. Only the last binary in a match can use the default size. All others must have their size specified explicitly, even if the match is unambiguous. For example:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; &lt;&lt;name::binary-size(5), \" the \", species::binary&gt;&gt; = &lt;&lt;\"Frank the Walrus\"&gt;&gt;\n\"Frank the Walrus\"\niex&gt; {name, species}\n{\"Frank\", \"Walrus\"}</code></pre> <p>Failing to specify the size for the non-last causes compilation to fail:</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;&lt;name::binary, \" the \", species::binary&gt;&gt; = &lt;&lt;\"Frank the Walrus\"&gt;&gt;\n** (CompileError): a binary field without size is only allowed at the end of a binary pattern</code></pre> <h4>Shortcut Syntax</h4> <p>Size and unit can also be specified using a syntax shortcut when passing integer values:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; x = 1\niex&gt; &lt;&lt;x::8&gt;&gt; == &lt;&lt;x::size(8)&gt;&gt;\ntrue\niex&gt; &lt;&lt;x::8 * 4&gt;&gt; == &lt;&lt;x::size(8)-unit(4)&gt;&gt;\ntrue</code></pre> <p>This syntax reflects the fact the effective size is given by multiplying the size by the unit.</p> <h3>Modifiers</h3> <p>Some types have associated modifiers to clear up ambiguity in byte representation.</p> <table> <colgroup> <col> <col> </colgroup> <thead> <tr> <th style=\"text-align: left\">Modifier</th>\n<th style=\"text-align: left\">Relevant Type(s)</th> </tr> </thead> <tr> <td style=\"text-align: left\"><code class=\"inline\">signed</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">integer</code></td> </tr> <tr> <td style=\"text-align: left\">\n<code class=\"inline\">unsigned</code> (default)</td>\n<td style=\"text-align: left\"><code class=\"inline\">integer</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">little</code></td>\n<td style=\"text-align: left\">\n<code class=\"inline\">integer</code>, <code class=\"inline\">utf16</code>, <code class=\"inline\">utf32</code>\n</td> </tr> <tr> <td style=\"text-align: left\">\n<code class=\"inline\">big</code> (default)</td>\n<td style=\"text-align: left\">\n<code class=\"inline\">integer</code>, <code class=\"inline\">utf16</code>, <code class=\"inline\">utf32</code>\n</td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">native</code></td>\n<td style=\"text-align: left\">\n<code class=\"inline\">integer</code>, <code class=\"inline\">utf16</code>, <code class=\"inline\">utf32</code>\n</td> </tr> </table> <h3>Sign</h3> <p>Integers can be <code class=\"inline\">signed</code> or <code class=\"inline\">unsigned</code>, defaulting to <code class=\"inline\">unsigned</code>.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; &lt;&lt;int::integer&gt;&gt; = &lt;&lt;-100&gt;&gt;\n&lt;&lt;156&gt;&gt;\niex&gt; int\n156\niex&gt; &lt;&lt;int::integer-signed&gt;&gt; = &lt;&lt;-100&gt;&gt;\n&lt;&lt;156&gt;&gt;\niex&gt; int\n-100</code></pre> <p><code class=\"inline\">signed</code> and <code class=\"inline\">unsigned</code> are only used for matching binaries (see below) and are only used for integers.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; &lt;&lt;-100::signed, _rest::binary&gt;&gt; = &lt;&lt;-100, \"foo\"&gt;&gt;\n&lt;&lt;156, 102, 111, 111&gt;&gt;</code></pre> <h3>Endianness</h3> <p>Elixir has three options for endianness: <code class=\"inline\">big</code>, <code class=\"inline\">little</code>, and <code class=\"inline\">native</code>. The default is <code class=\"inline\">big</code>:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; &lt;&lt;number::little-integer-size(16)&gt;&gt; = &lt;&lt;0, 1&gt;&gt;\n&lt;&lt;0, 1&gt;&gt;\niex&gt; number\n256\niex&gt; &lt;&lt;number::big-integer-size(16)&gt;&gt; = &lt;&lt;0, 1&gt;&gt;\n&lt;&lt;0, 1&gt;&gt;\niex&gt; number\n1</code></pre> <p><code class=\"inline\">native</code> is determined by the VM at startup and will depend on the host operating system.</p> <h4>Binary/Bitstring Matching</h4> <p>Binary matching is a powerful feature in Elixir that is useful for extracting information from binaries as well as pattern matching.</p> <p>Binary matching can be used by itself to extract information from binaries:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; &lt;&lt;\"Hello, \", place::binary&gt;&gt; = \"Hello, World\"\n\"Hello, World\"\niex&gt; place\n\"World\"</code></pre> <p>Or as a part of function definitions to pattern match:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule ImageTyper\n  @png_signature &lt;&lt;137::size(8), 80::size(8), 78::size(8), 71::size(8),\n                13::size(8), 10::size(8), 26::size(8), 10::size(8)&gt;&gt;\n  @jpg_signature &lt;&lt;255::size(8), 216::size(8)&gt;&gt;\n\n  def type(&lt;&lt;@png_signature, rest::binary&gt;&gt;), do: :png\n  def type(&lt;&lt;@jpg_signature, rest::binary&gt;&gt;), do: :jpg\n  def type(_), do :unknown\nend</code></pre> <h3>Performance &amp; Optimizations</h3> <p>The Erlang compiler can provide a number of optimizations on binary creation and matching. To see optimization output, set the <code class=\"inline\">bin_opt_info</code> compiler option:</p> <pre data-language=\"elixir\"><code class=\"elixir\">ERL_COMPILER_OPTIONS=bin_opt_info mix compile</code></pre> <p>To learn more about specific optimizations and performance considerations, check out <a href=\"http://www.erlang.org/doc/efficiency_guide/binaryhandling.html\">Erlang’s Efficiency Guide on handling binaries</a>.</p>    <h3 class=\"detail-header macro\" id=\"=/2\">  <span class=\"signature\">left = right</span>  </h3>  <p>Matches the value on the right against the pattern on the left.</p>    <h3 class=\"detail-header macro\" id=\"%5E/1\">  <span class=\"signature\">^var</span>  </h3>  <p>Accesses an already bound variable in match clauses. Also known as the pin operator.</p> <h4>Examples</h4> <p>Elixir allows variables to be rebound via static single assignment:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; x = 1\niex&gt; x = x + 1\niex&gt; x\n2</code></pre> <p>However, in some situations, it is useful to match against an existing value, instead of rebinding. This can be done with the <code class=\"inline\">^</code> special form, colloquially known as the pin operator:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; x = 1\niex&gt; ^x = List.first([1])\niex&gt; ^x = List.first([2])\n** (MatchError) no match of right hand side value: 2</code></pre> <p>Note that <code class=\"inline\">^x</code> always refers to the value of <code class=\"inline\">x</code> prior to the match. The following example will match:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; x = 0\niex&gt; {x, ^x} = {1, 0}\niex&gt; x\n1</code></pre>    <h3 class=\"detail-header macro\" id=\"__CALLER__/0\">  <span class=\"signature\">__CALLER__</span>  </h3>  <p>Returns the current calling environment as a <a href=\"macro.env\"><code class=\"inline\">Macro.Env</code></a> struct.</p> <p>In the environment you can access the filename, line numbers, set up aliases, the function and others.</p>    <h3 class=\"detail-header macro\" id=\"__DIR__/0\">  <span class=\"signature\">__DIR__</span>  </h3>  <p>Returns the absolute path of the directory of the current file as a binary.</p> <p>Although the directory can be accessed as <code class=\"inline\">Path.dirname(__ENV__.file)</code>, this macro is a convenient shortcut.</p>    <h3 class=\"detail-header macro\" id=\"__ENV__/0\">  <span class=\"signature\">__ENV__</span>  </h3>  <p>Returns the current environment information as a <a href=\"macro.env\"><code class=\"inline\">Macro.Env</code></a> struct.</p> <p>In the environment you can access the current filename, line numbers, set up aliases, the current function and others.</p>    <h3 class=\"detail-header macro\" id=\"__MODULE__/0\">  <span class=\"signature\">__MODULE__</span>  </h3>  <p>Returns the current module name as an atom or <code class=\"inline\">nil</code> otherwise.</p> <p>Although the module can be accessed in the <code class=\"inline\">__ENV__</code>, this macro is a convenient shortcut.</p>    <h3 class=\"detail-header macro\" id=\"__aliases__/1\">  <span class=\"signature\">__aliases__(args)</span>  </h3>  <p>Internal special form to hold aliases information.</p> <p>It is usually compiled to an atom:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; quote do\n...&gt;   Foo.Bar\n...&gt; end\n{:__aliases__, [alias: false], [:Foo, :Bar]}</code></pre> <p>Elixir represents <code class=\"inline\">Foo.Bar</code> as <code class=\"inline\">__aliases__</code> so calls can be unambiguously identified by the operator <code class=\"inline\">:.</code>. For example:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; quote do\n...&gt;   Foo.bar\n...&gt; end\n{{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}</code></pre> <p>Whenever an expression iterator sees a <code class=\"inline\">:.</code> as the tuple key, it can be sure that it represents a call and the second argument in the list is an atom.</p> <p>On the other hand, aliases holds some properties:</p> <ol> <li>\n<p>The head element of aliases can be any term that must expand to an atom at compilation time.</p> </li> <li>\n<p>The tail elements of aliases are guaranteed to always be atoms.</p> </li> <li>When the head element of aliases is the atom <code class=\"inline\">:Elixir</code>, no expansion happens. </li> </ol>    <h3 class=\"detail-header macro\" id=\"__block__/1\">  <span class=\"signature\">__block__(args)</span>  </h3>  <p>Internal special form for block expressions.</p> <p>This is the special form used whenever we have a block of expressions in Elixir. This special form is private and should not be invoked directly:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; quote do\n...&gt;   1\n...&gt;   2\n...&gt;   3\n...&gt; end\n{:__block__, [], [1, 2, 3]}</code></pre>    <h3 class=\"detail-header macro\" id=\"alias/2\">  <span class=\"signature\">alias(module, opts)</span>  </h3>  <p><a href=\"#alias/2\"><code class=\"inline\">alias/2</code></a> is used to setup aliases, often useful with modules names.</p> <h4>Examples</h4> <p><a href=\"#alias/2\"><code class=\"inline\">alias/2</code></a> can be used to setup an alias for any module:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Math do\n  alias MyKeyword, as: Keyword\nend</code></pre> <p>In the example above, we have set up <code class=\"inline\">MyKeyword</code> to be aliased as <a href=\"keyword\"><code class=\"inline\">Keyword</code></a>. So now, any reference to <a href=\"keyword\"><code class=\"inline\">Keyword</code></a> will be automatically replaced by <code class=\"inline\">MyKeyword</code>.</p> <p>In case one wants to access the original <a href=\"keyword\"><code class=\"inline\">Keyword</code></a>, it can be done by accessing <code class=\"inline\">Elixir</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Keyword.values   #=&gt; uses MyKeyword.values\nElixir.Keyword.values #=&gt; uses Keyword.values</code></pre> <p>Notice that calling <code class=\"inline\">alias</code> without the <code class=\"inline\">as:</code> option automatically sets an alias based on the last part of the module. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">alias Foo.Bar.Baz</code></pre> <p>Is the same as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">alias Foo.Bar.Baz, as: Baz</code></pre> <h4>Lexical scope</h4> <p><a href=\"#import/2\"><code class=\"inline\">import/2</code></a>, <a href=\"#require/2\"><code class=\"inline\">require/2</code></a> and <a href=\"#alias/2\"><code class=\"inline\">alias/2</code></a> are called directives and all have lexical scope. This means you can set up aliases inside specific functions and it won’t affect the overall scope.</p> <h4>Warnings</h4> <p>If you alias a module and you don’t use the alias, Elixir is going to issue a warning implying the alias is not being used.</p> <p>In case the alias is generated automatically by a macro, Elixir won’t emit any warnings though, since the alias was not explicitly defined.</p> <p>Both warning behaviours could be changed by explicitly setting the <code class=\"inline\">:warn</code> option to <code class=\"inline\">true</code> or <code class=\"inline\">false</code>.</p>    <h3 class=\"detail-header macro\" id=\"case/2\">  <span class=\"signature\">case(condition, clauses)</span>  </h3>  <p>Matches the given expression against the given clauses.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">case thing do\n  {:selector, i, value} when is_integer(i) -&gt;\n    value\n  value -&gt;\n    value\nend</code></pre> <p>In the example above, we match <code class=\"inline\">thing</code> against each clause “head” and execute the clause “body” corresponding to the first clause that matches.</p> <p>If no clause matches, an error is raised. For this reason, it may be necessary to add a final catch-all clause (like <code class=\"inline\">_</code>) which will always match.</p> <pre data-language=\"elixir\"><code class=\"elixir\">x = 10\n\ncase x do\n  0 -&gt;\n    \"This clause won't match\"\n  _ -&gt;\n    \"This clause would match any value (x = #{x})\"\nend\n#=&gt; \"This clause would match any value (x = 10)\"</code></pre> <h4>Variables handling</h4> <p>Notice that variables bound in a clause “head” do not leak to the outer context:</p> <pre data-language=\"elixir\"><code class=\"elixir\">case data do\n  {:ok, value} -&gt; value\n  :error -&gt; nil\nend\n\nvalue #=&gt; unbound variable value</code></pre> <p>However, variables explicitly bound in the clause “body” are accessible from the outer context:</p> <pre data-language=\"elixir\"><code class=\"elixir\">value = 7\n\ncase lucky? do\n  false -&gt; value = 13\n  true  -&gt; true\nend\n\nvalue #=&gt; 7 or 13</code></pre> <p>In the example above, value is going to be <code class=\"inline\">7</code> or <code class=\"inline\">13</code> depending on the value of <code class=\"inline\">lucky?</code>. In case <code class=\"inline\">value</code> has no previous value before case, clauses that do not explicitly bind a value have the variable bound to <code class=\"inline\">nil</code>.</p> <p>If you want to pattern match against an existing variable, you need to use the <a href=\"#%255E/1\"><code class=\"inline\">^/1</code></a> operator:</p> <pre data-language=\"elixir\"><code class=\"elixir\">x = 1\n\ncase 10 do\n  ^x -&gt; \"Won't match\"\n  _  -&gt; \"Will match\"\nend\n#=&gt; \"Will match\"</code></pre>    <h3 class=\"detail-header macro\" id=\"cond/1\">  <span class=\"signature\">cond(clauses)</span>  </h3>  <p>Evaluates the expression corresponding to the first clause that evaluates to a truthy value.</p> <pre data-language=\"elixir\"><code class=\"elixir\">cond do\n  hd([1, 2, 3]) -&gt;\n    \"1 is considered as true\"\nend\n#=&gt; \"1 is considered as true\"</code></pre> <p>Raises an error if all conditions evaluate to <code class=\"inline\">nil</code> or <code class=\"inline\">false</code>. For this reason, it may be necessary to add a final always-truthy condition (anything non-<code class=\"inline\">false</code> and non-<code class=\"inline\">nil</code>), which will always match.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">cond do\n  1 + 1 == 1 -&gt;\n    \"This will never match\"\n  2 * 2 != 4 -&gt;\n    \"Nor this\"\n  true -&gt;\n    \"This will\"\nend\n#=&gt; \"This will\"</code></pre>    <h3 class=\"detail-header macro\" id=\"fn/1\">  <span class=\"signature\">fn [clauses] end</span>  </h3>  <p>Defines an anonymous function.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; add = fn a, b -&gt; a + b end\niex&gt; add.(1, 2)\n3</code></pre>    <h3 class=\"detail-header macro\" id=\"for/1\">  <span class=\"signature\">for(args)</span>  </h3>  <p>Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.</p> <p>Let’s start with an example:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; for n &lt;- [1, 2, 3, 4], do: n * 2\n[2, 4, 6, 8]</code></pre> <p>A comprehension accepts many generators and filters. Enumerable generators are defined using <code class=\"inline\">&lt;-</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># A list generator:\niex&gt; for n &lt;- [1, 2, 3, 4], do: n * 2\n[2, 4, 6, 8]\n\n# A comprehension with two generators\niex&gt; for x &lt;- [1, 2], y &lt;- [2, 3], do: x*y\n[2, 3, 4, 6]</code></pre> <p>Filters can also be given:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># A comprehension with a generator and a filter\niex&gt; for n &lt;- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n\n[2, 4, 6]</code></pre> <p>Note generators can also be used to filter as it removes any value that doesn’t match the pattern on the left side of <code class=\"inline\">&lt;-</code>:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = [user: \"john\", admin: \"meg\", guest: \"barbara\"]\niex&gt; for {type, name} when type != :guest &lt;- users do\n...&gt;   String.upcase(name)\n...&gt; end\n[\"JOHN\", \"MEG\"]</code></pre> <p>Bitstring generators are also supported and are very useful when you need to organize bitstring streams:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; pixels = &lt;&lt;213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15&gt;&gt;\niex&gt; for &lt;&lt;r::8, g::8, b::8 &lt;- pixels &gt;&gt;, do: {r, g, b}\n[{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]</code></pre> <p>Variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension.</p> <h4>Into</h4> <p>In the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an <code class=\"inline\">:into</code> option, that accepts any structure as long as it implements the <a href=\"collectable\"><code class=\"inline\">Collectable</code></a> protocol.</p> <p>For example, we can use bitstring generators with the <code class=\"inline\">:into</code> option to easily remove all spaces in a string:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; for &lt;&lt;c &lt;- \" hello world \"&gt;&gt;, c != ?\\s, into: \"\", do: &lt;&lt;c&gt;&gt;\n\"helloworld\"</code></pre> <p>The <a href=\"io\"><code class=\"inline\">IO</code></a> module provides streams, that are both <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> and <a href=\"collectable\"><code class=\"inline\">Collectable</code></a>, here is an upcase echo server using comprehensions:</p> <pre data-language=\"elixir\"><code class=\"elixir\">for line &lt;- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do\n  String.upcase(line)\nend</code></pre>    <h3 class=\"detail-header macro\" id=\"import/2\">  <span class=\"signature\">import(module, opts)</span>  </h3>  <p>Imports functions and macros from other modules.</p> <p><a href=\"#import/2\"><code class=\"inline\">import/2</code></a> allows one to easily access functions or macros from others modules without using the qualified name.</p> <h4>Examples</h4> <p>If you are using several functions from a given module, you can import those functions and reference them as local functions, for example:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; import List\niex&gt; flatten([1, [2], 3])\n[1, 2, 3]</code></pre> <h4>Selector</h4> <p>By default, Elixir imports functions and macros from the given module, except the ones starting with underscore (which are usually callbacks):</p> <pre data-language=\"elixir\"><code class=\"elixir\">import List</code></pre> <p>A developer can filter to import only macros or functions via the only option:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import List, only: :functions\nimport List, only: :macros</code></pre> <p>Alternatively, Elixir allows a developer to pass pairs of name/arities to <code class=\"inline\">:only</code> or <code class=\"inline\">:except</code> as a fine grained control on what to import (or not):</p> <pre data-language=\"elixir\"><code class=\"elixir\">import List, only: [flatten: 1]\nimport String, except: [split: 2]</code></pre> <p>Notice that calling <code class=\"inline\">except</code> for a previously declared <a href=\"#import/2\"><code class=\"inline\">import/2</code></a> simply filters the previously imported elements. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import List, only: [flatten: 1, keyfind: 4]\nimport List, except: [flatten: 1]</code></pre> <p>After the two import calls above, only <a href=\"list#keyfind/4\"><code class=\"inline\">List.keyfind/4</code></a> will be imported.</p> <h4>Underscore functions</h4> <p>By default functions starting with <code class=\"inline\">_</code> are not imported. If you really want to import a function starting with <code class=\"inline\">_</code> you must explicitly include it in the <code class=\"inline\">:only</code> selector.</p> <pre data-language=\"elixir\"><code class=\"elixir\">import File.Stream, only: [__build__: 3]</code></pre> <h4>Lexical scope</h4> <p>It is important to notice that <a href=\"#import/2\"><code class=\"inline\">import/2</code></a> is lexical. This means you can import specific macros inside specific functions:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Math do\n  def some_function do\n    # 1) Disable \"if/2\" from Kernel\n    import Kernel, except: [if: 2]\n\n    # 2) Require the new \"if/2\" macro from MyMacros\n    import MyMacros\n\n    # 3) Use the new macro\n    if do_something, it_works\n  end\nend</code></pre> <p>In the example above, we imported macros from <code class=\"inline\">MyMacros</code>, replacing the original <code class=\"inline\">if/2</code> implementation by our own within that specific function. All other functions in that module will still be able to use the original one.</p> <h4>Warnings</h4> <p>If you import a module and you don’t use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used.</p> <p>In case the import is generated automatically by a macro, Elixir won’t emit any warnings though, since the import was not explicitly defined.</p> <p>Both warning behaviours could be changed by explicitly setting the <code class=\"inline\">:warn</code> option to <code class=\"inline\">true</code> or <code class=\"inline\">false</code>.</p> <h4>Ambiguous function/macro names</h4> <p>If two modules <code class=\"inline\">A</code> and <code class=\"inline\">B</code> are imported and they both contain a <code class=\"inline\">foo</code> function with an arity of <code class=\"inline\">1</code>, an error is only emitted if an ambiguous call to <code class=\"inline\">foo/1</code> is actually made; that is, the errors are emitted lazily, not eagerly.</p>    <h3 class=\"detail-header macro\" id=\"quote/2\">  <span class=\"signature\">quote(opts, block)</span>  </h3>  <p>Gets the representation of any expression.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; quote do\n...&gt;   sum(1, 2, 3)\n...&gt; end\n{:sum, [], [1, 2, 3]}</code></pre> <h4>Explanation</h4> <p>Any Elixir code can be represented using Elixir data structures. The building block of Elixir macros is a tuple with three elements, for example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:sum, [], [1, 2, 3]}</code></pre> <p>The tuple above represents a function call to <code class=\"inline\">sum</code> passing 1, 2 and 3 as arguments. The tuple elements are:</p> <ul> <li>\n<p>The first element of the tuple is always an atom or another tuple in the same representation.</p> </li> <li>\n<p>The second element of the tuple represents metadata.</p> </li> <li>The third element of the tuple are the arguments for the function call. The third argument may be an atom, which is usually a variable (or a local call). </li> </ul> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:unquote</code> - when <code class=\"inline\">false</code>, disables unquoting. Useful when you have a quote inside another quote and want to control what quote is able to unquote.</p> </li> <li>\n<p><code class=\"inline\">:location</code> - when set to <code class=\"inline\">:keep</code>, keeps the current line and file from quote. Read the Stacktrace information section below for more information.</p> </li> <li>\n<p><code class=\"inline\">:generated</code> - marks the given chunk as generated so it does not emit warnings. Currently it only works on special forms (for example, you can annotate a <code class=\"inline\">case</code> but not an <code class=\"inline\">if</code>).</p> </li> <li>\n<p><code class=\"inline\">:context</code> - sets the resolution context.</p> </li> <li>\n<code class=\"inline\">:bind_quoted</code> - passes a binding to the macro. Whenever a binding is given, <a href=\"#unquote/1\"><code class=\"inline\">unquote/1</code></a> is automatically disabled. </li> </ul> <h4>Quote literals</h4> <p>Besides the tuple described above, Elixir has a few literals that when quoted return themselves. They are:</p> <pre data-language=\"elixir\"><code class=\"elixir\">:sum         #=&gt; Atoms\n1            #=&gt; Integers\n2.0          #=&gt; Floats\n[1, 2]       #=&gt; Lists\n\"strings\"    #=&gt; Strings\n{key, value} #=&gt; Tuples with two elements</code></pre> <h4>Quote and macros</h4> <p><a href=\"#quote/2\"><code class=\"inline\">quote/2</code></a> is commonly used with macros for code generation. As an exercise, let’s define a macro that multiplies a number by itself (squared). Note there is no reason to define such as a macro (and it would actually be seen as a bad practice), but it is simple enough that it allows us to focus on the important aspects of quotes and macros:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Math do\n  defmacro squared(x) do\n    quote do\n      unquote(x) * unquote(x)\n    end\n  end\nend</code></pre> <p>We can invoke it as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import Math\nIO.puts \"Got #{squared(5)}\"</code></pre> <p>At first, there is nothing in this example that actually reveals it is a macro. But what is happening is that, at compilation time, <code class=\"inline\">squared(5)</code> becomes <code class=\"inline\">5 * 5</code>. The argument <code class=\"inline\">5</code> is duplicated in the produced code, we can see this behaviour in practice though because our macro actually has a bug:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import Math\nmy_number = fn -&gt;\n  IO.puts \"Returning 5\"\n  5\nend\nIO.puts \"Got #{squared(my_number.())}\"</code></pre> <p>The example above will print:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Returning 5\nReturning 5\nGot 25</code></pre> <p>Notice how “Returning 5” was printed twice, instead of just once. This is because a macro receives an expression and not a value (which is what we would expect in a regular function). This means that:</p> <pre data-language=\"elixir\"><code class=\"elixir\">squared(my_number.())</code></pre> <p>Actually expands to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">my_number.() * my_number.()</code></pre> <p>Which invokes the function twice, explaining why we get the printed value twice! In the majority of the cases, this is actually unexpected behaviour, and that’s why one of the first things you need to keep in mind when it comes to macros is to <strong>not unquote the same value more than once</strong>.</p> <p>Let’s fix our macro:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Math do\n  defmacro squared(x) do\n    quote do\n      x = unquote(x)\n      x * x\n    end\n  end\nend</code></pre> <p>Now invoking <code class=\"inline\">square(my_number.())</code> as before will print the value just once.</p> <p>In fact, this pattern is so common that most of the times you will want to use the <code class=\"inline\">bind_quoted</code> option with <a href=\"#quote/2\"><code class=\"inline\">quote/2</code></a>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Math do\n  defmacro squared(x) do\n    quote bind_quoted: [x: x] do\n      x * x\n    end\n  end\nend</code></pre> <p><code class=\"inline\">:bind_quoted</code> will translate to the same code as the example above. <code class=\"inline\">:bind_quoted</code> can be used in many cases and is seen as good practice, not only because it helps us from running into common mistakes but also because it allows us to leverage other tools exposed by macros, such as unquote fragments discussed in some sections below.</p> <p>Before we finish this brief introduction, you will notice that, even though we defined a variable <code class=\"inline\">x</code> inside our quote:</p> <pre data-language=\"elixir\"><code class=\"elixir\">quote do\n  x = unquote(x)\n  x * x\nend</code></pre> <p>When we call:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import Math\nsquared(5)\nx #=&gt; ** (CompileError) undefined variable x or undefined function x/0</code></pre> <p>We can see that <code class=\"inline\">x</code> did not leak to the user context. This happens because Elixir macros are hygienic, a topic we will discuss at length in the next sections as well.</p> <h4>Hygiene in variables</h4> <p>Consider the following example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Hygiene do\n  defmacro no_interference do\n    quote do\n      a = 1\n    end\n  end\nend\n\nrequire Hygiene\n\na = 10\nHygiene.no_interference\na #=&gt; 10</code></pre> <p>In the example above, <code class=\"inline\">a</code> returns 10 even if the macro is apparently setting it to 1 because variables defined in the macro do not affect the context the macro is executed in. If you want to set or get a variable in the caller’s context, you can do it with the help of the <code class=\"inline\">var!</code> macro:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule NoHygiene do\n  defmacro interference do\n    quote do\n      var!(a) = 1\n    end\n  end\nend\n\nrequire NoHygiene\n\na = 10\nNoHygiene.interference\na #=&gt; 1</code></pre> <p>Note that you cannot even access variables defined in the same module unless you explicitly give it a context:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Hygiene do\n  defmacro write do\n    quote do\n      a = 1\n    end\n  end\n\n  defmacro read do\n    quote do\n      a\n    end\n  end\nend\n\nHygiene.write\nHygiene.read\n#=&gt; ** (RuntimeError) undefined variable a or undefined function a/0</code></pre> <p>For such, you can explicitly pass the current module scope as argument:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule ContextHygiene do\n  defmacro write do\n    quote do\n      var!(a, ContextHygiene) = 1\n    end\n  end\n\n  defmacro read do\n    quote do\n      var!(a, ContextHygiene)\n    end\n  end\nend\n\nContextHygiene.write\nContextHygiene.read\n#=&gt; 1</code></pre> <h4>Hygiene in aliases</h4> <p>Aliases inside quote are hygienic by default. Consider the following example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Hygiene do\n  alias Map, as: M\n\n  defmacro no_interference do\n    quote do\n      M.new\n    end\n  end\nend\n\nrequire Hygiene\nHygiene.no_interference #=&gt; %{}</code></pre> <p>Notice that, even though the alias <code class=\"inline\">M</code> is not available in the context the macro is expanded, the code above works because <code class=\"inline\">M</code> still expands to <a href=\"map\"><code class=\"inline\">Map</code></a>.</p> <p>Similarly, even if we defined an alias with the same name before invoking a macro, it won’t affect the macro’s result:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Hygiene do\n  alias Map, as: M\n\n  defmacro no_interference do\n    quote do\n      M.new\n    end\n  end\nend\n\nrequire Hygiene\nalias SomethingElse, as: M\nHygiene.no_interference #=&gt; %{}</code></pre> <p>In some cases, you want to access an alias or a module defined in the caller. For such, you can use the <code class=\"inline\">alias!</code> macro:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Hygiene do\n  # This will expand to Elixir.Nested.hello\n  defmacro no_interference do\n    quote do\n      Nested.hello\n    end\n  end\n\n  # This will expand to Nested.hello for\n  # whatever is Nested in the caller\n  defmacro interference do\n    quote do\n      alias!(Nested).hello\n    end\n  end\nend\n\ndefmodule Parent do\n  defmodule Nested do\n    def hello, do: \"world\"\n  end\n\n  require Hygiene\n  Hygiene.no_interference\n  #=&gt; ** (UndefinedFunctionError) ...\n\n  Hygiene.interference\n  #=&gt; \"world\"\nend</code></pre> <h4>Hygiene in imports</h4> <p>Similar to aliases, imports in Elixir are hygienic. Consider the following code:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Hygiene do\n  defmacrop get_length do\n    quote do\n      length([1, 2, 3])\n    end\n  end\n\n  def return_length do\n    import Kernel, except: [length: 1]\n    get_length\n  end\nend\n\nHygiene.return_length #=&gt; 3</code></pre> <p>Notice how <code class=\"inline\">return_length</code> returns 3 even though the <code class=\"inline\">length/1</code> function is not imported. In fact, even if <code class=\"inline\">return_length</code> imported a function with the same name and arity from another module, it wouldn’t affect the function result:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def return_length do\n  import String, only: [length: 1]\n  get_length\nend</code></pre> <p>Calling this new <code class=\"inline\">return_length</code> will still return 3 as result.</p> <p>Elixir is smart enough to delay the resolution to the latest moment possible. So, if you call <code class=\"inline\">length([1, 2, 3])</code> inside quote, but no <code class=\"inline\">length/1</code> function is available, it is then expanded in the caller:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Lazy do\n  defmacrop get_length do\n    import Kernel, except: [length: 1]\n\n    quote do\n      length(\"hello\")\n    end\n  end\n\n  def return_length do\n    import Kernel, except: [length: 1]\n    import String, only: [length: 1]\n    get_length\n  end\nend\n\nLazy.return_length #=&gt; 5</code></pre> <h4>Stacktrace information</h4> <p>When defining functions via macros, developers have the option of choosing if runtime errors will be reported from the caller or from inside the quote. Let’s see an example:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># adder.ex\ndefmodule Adder do\n  @doc \"Defines a function that adds two numbers\"\n  defmacro defadd do\n    quote location: :keep do\n      def add(a, b), do: a + b\n    end\n  end\nend\n\n# sample.ex\ndefmodule Sample do\n  import Adder\n  defadd\nend\n\nrequire Sample\nSample.add(:one, :two)\n#=&gt; ** (ArithmeticError) bad argument in arithmetic expression\n#=&gt;     adder.ex:5: Sample.add/2</code></pre> <p>When using <code class=\"inline\">location: :keep</code> and invalid arguments are given to <code class=\"inline\">Sample.add/2</code>, the stacktrace information will point to the file and line inside the quote. Without <code class=\"inline\">location: :keep</code>, the error is reported to where <code class=\"inline\">defadd</code> was invoked. Note <code class=\"inline\">location: :keep</code> affects only definitions inside the quote.</p> <h4>Binding and unquote fragments</h4> <p>Elixir quote/unquote mechanisms provides a functionality called unquote fragments. Unquote fragments provide an easy way to generate functions on the fly. Consider this example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">kv = [foo: 1, bar: 2]\nEnum.each kv, fn {k, v} -&gt;\n  def unquote(k)(), do: unquote(v)\nend</code></pre> <p>In the example above, we have generated the functions <code class=\"inline\">foo/0</code> and <code class=\"inline\">bar/0</code> dynamically. Now, imagine that, we want to convert this functionality into a macro:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmacro defkv(kv) do\n  Enum.map kv, fn {k, v} -&gt;\n    quote do\n      def unquote(k)(), do: unquote(v)\n    end\n  end\nend</code></pre> <p>We can invoke this macro as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defkv [foo: 1, bar: 2]</code></pre> <p>However, we can’t invoke it as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\">kv = [foo: 1, bar: 2]\ndefkv kv</code></pre> <p>This is because the macro is expecting its arguments to be a keyword list at <strong>compilation</strong> time. Since in the example above we are passing the representation of the variable <code class=\"inline\">kv</code>, our code fails.</p> <p>This is actually a common pitfall when developing macros. We are assuming a particular shape in the macro. We can work around it by unquoting the variable inside the quoted expression:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmacro defkv(kv) do\n  quote do\n    Enum.each unquote(kv), fn {k, v} -&gt;\n      def unquote(k)(), do: unquote(v)\n    end\n  end\nend</code></pre> <p>If you try to run our new macro, you will notice it won’t even compile, complaining that the variables <code class=\"inline\">k</code> and <code class=\"inline\">v</code> do not exist. This is because of the ambiguity: <code class=\"inline\">unquote(k)</code> can either be an unquote fragment, as previously, or a regular unquote as in <code class=\"inline\">unquote(kv)</code>.</p> <p>One solution to this problem is to disable unquoting in the macro, however, doing that would make it impossible to inject the <code class=\"inline\">kv</code> representation into the tree. That’s when the <code class=\"inline\">:bind_quoted</code> option comes to the rescue (again!). By using <code class=\"inline\">:bind_quoted</code>, we can automatically disable unquoting while still injecting the desired variables into the tree:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmacro defkv(kv) do\n  quote bind_quoted: [kv: kv] do\n    Enum.each kv, fn {k, v} -&gt;\n      def unquote(k)(), do: unquote(v)\n    end\n  end\nend</code></pre> <p>In fact, the <code class=\"inline\">:bind_quoted</code> option is recommended every time one desires to inject a value into the quote.</p>    <h3 class=\"detail-header macro\" id=\"receive/1\">  <span class=\"signature\">receive(args)</span>  </h3>  <p>Checks if there is a message matching the given clauses in the current process mailbox.</p> <p>In case there is no such message, the current process hangs until a message arrives or waits until a given timeout value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">receive do\n  {:selector, i, value} when is_integer(i) -&gt;\n    value\n  value when is_atom(value) -&gt;\n    value\n  _ -&gt;\n    IO.puts :stderr, \"Unexpected message received\"\nend</code></pre> <p>An optional <code class=\"inline\">after</code> clause can be given in case the message was not received after the specified timeout period:</p> <pre data-language=\"elixir\"><code class=\"elixir\">receive do\n  {:selector, i, value} when is_integer(i) -&gt;\n    value\n  value when is_atom(value) -&gt;\n    value\n  _ -&gt;\n    IO.puts :stderr, \"Unexpected message received\"\nafter\n  5000 -&gt;\n    IO.puts :stderr, \"No message in 5 seconds\"\nend</code></pre> <p>The <code class=\"inline\">after</code> clause can be specified even if there are no match clauses. The timeout value given to <code class=\"inline\">after</code> can be a variable; two special values are allowed:</p> <ul> <li>\n<p><code class=\"inline\">:infinity</code> - the process should wait indefinitely for a matching message, this is the same as not using a timeout</p> </li> <li>\n<code class=\"inline\">0</code> - if there is no matching message in the mailbox, the timeout will occur immediately </li> </ul> <h4>Variables handling</h4> <p>The <a href=\"#receive/1\"><code class=\"inline\">receive/1</code></a> special form handles variables exactly as the <a href=\"#case/2\"><code class=\"inline\">case/2</code></a> special macro. For more information, check the docs for <a href=\"#case/2\"><code class=\"inline\">case/2</code></a>.</p>    <h3 class=\"detail-header macro\" id=\"require/2\">  <span class=\"signature\">require(module, opts)</span>  </h3>  <p>Requires a given module to be compiled and loaded.</p> <h4>Examples</h4> <p>Notice that usually modules should not be required before usage, the only exception is if you want to use the macros from a module. In such cases, you need to explicitly require them.</p> <p>Let’s suppose you created your own <code class=\"inline\">if/2</code> implementation in the module <code class=\"inline\">MyMacros</code>. If you want to invoke it, you need to first explicitly require the <code class=\"inline\">MyMacros</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Math do\n  require MyMacros\n  MyMacros.if do_something, it_works\nend</code></pre> <p>An attempt to call a macro that was not loaded will raise an error.</p> <h4>Alias shortcut</h4> <p><a href=\"#require/2\"><code class=\"inline\">require/2</code></a> also accepts <code class=\"inline\">as:</code> as an option so it automatically sets up an alias. Please check <a href=\"#alias/2\"><code class=\"inline\">alias/2</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"super/1\">  <span class=\"signature\">super(args)</span>  </h3>  <p>Calls the overridden function when overriding it with <a href=\"kernel#defoverridable/1\"><code class=\"inline\">Kernel.defoverridable/1</code></a>.</p> <p>See <a href=\"kernel#defoverridable/1\"><code class=\"inline\">Kernel.defoverridable/1</code></a> for more information and documentation.</p>    <h3 class=\"detail-header macro\" id=\"try/1\">  <span class=\"signature\">try(args)</span>  </h3>  <p>Evaluates the given expressions and handles any error, exit or throw that may have happened.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">try do\n  do_something_that_may_fail(some_arg)\nrescue\n  ArgumentError -&gt;\n    IO.puts \"Invalid argument given\"\ncatch\n  value -&gt;\n    IO.puts \"caught #{value}\"\nelse\n  value -&gt;\n    IO.puts \"Success! The result was #{value}\"\nafter\n  IO.puts \"This is printed regardless if it failed or succeed\"\nend</code></pre> <p>The rescue clause is used to handle exceptions, while the catch clause can be used to catch thrown values. The else clause can be used to control flow based on the result of the expression. Catch, rescue and else clauses work based on pattern matching.</p> <p>Note that calls inside <a href=\"#try/1\"><code class=\"inline\">try/1</code></a> are not tail recursive since the VM needs to keep the stacktrace in case an exception happens.</p> <h4>Rescue clauses</h4> <p>Besides relying on pattern matching, rescue clauses provides some conveniences around exceptions that allows one to rescue an exception by its name. All the following formats are valid rescue expressions:</p> <pre data-language=\"elixir\"><code class=\"elixir\">try do\n  UndefinedModule.undefined_function\nrescue\n  UndefinedFunctionError -&gt; nil\nend\n\ntry do\n  UndefinedModule.undefined_function\nrescue\n  [UndefinedFunctionError] -&gt; nil\nend\n\n# rescue and bind to x\ntry do\n  UndefinedModule.undefined_function\nrescue\n  x in [UndefinedFunctionError] -&gt; nil\nend\n\n# rescue all and bind to x\ntry do\n  UndefinedModule.undefined_function\nrescue\n  x -&gt; nil\nend</code></pre> <h4>Erlang errors</h4> <p>Erlang errors are transformed into Elixir ones during rescue:</p> <pre data-language=\"elixir\"><code class=\"elixir\">try do\n  :erlang.error(:badarg)\nrescue\n  ArgumentError -&gt; :ok\nend</code></pre> <p>The most common Erlang errors will be transformed into their Elixir counter-part. Those which are not will be transformed into <a href=\"erlangerror\"><code class=\"inline\">ErlangError</code></a>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">try do\n  :erlang.error(:unknown)\nrescue\n  ErlangError -&gt; :ok\nend</code></pre> <p>In fact, <a href=\"erlangerror\"><code class=\"inline\">ErlangError</code></a> can be used to rescue any error that is not an Elixir error proper. For example, it can be used to rescue the earlier <code class=\"inline\">:badarg</code> error too, prior to transformation:</p> <pre data-language=\"elixir\"><code class=\"elixir\">try do\n  :erlang.error(:badarg)\nrescue\n  ErlangError -&gt; :ok\nend</code></pre> <h4>Catching throws and exits</h4> <p>The catch clause can be used to catch throws values and exits.</p> <pre data-language=\"elixir\"><code class=\"elixir\">try do\n  exit(:shutdown)\ncatch\n  :exit, :shutdown -&gt; IO.puts \"Exited with shutdown reason\"\nend\n\ntry do\n  throw(:sample)\ncatch\n  :throw, :sample -&gt;\n    IO.puts \"sample thrown\"\nend</code></pre> <p>catch values also support <code class=\"inline\">:error</code>, as in Erlang, although it is commonly avoided in favor of raise/rescue control mechanisms.</p> <h4>After clauses</h4> <p>An <code class=\"inline\">after</code> clause allows you to define cleanup logic that will be invoked both when the tried block of code succeeds and also when an error is raised. Note that the process will exit as usually when receiving an exit signal that causes it to exit abruptly and so the <code class=\"inline\">after</code> clause is not guaranteed to be executed. Luckily, most resources in Elixir (such as open files, ETS tables, ports, sockets, etc.) are linked to or monitor the owning process and will automatically clean themselves up if that process exits.</p> <pre data-language=\"elixir\"><code class=\"elixir\">File.write!(\"tmp/story.txt\", \"Hello, World\")\ntry do\n  do_something_with(\"tmp/story.txt\")\nafter\n  File.rm(\"tmp/story.txt\")\nend</code></pre> <h4>Else clauses</h4> <p>Else clauses allow the result of the expression to be pattern matched on:</p> <pre data-language=\"elixir\"><code class=\"elixir\">x = 2\ntry do\n  1 / x\nrescue\n  ArithmeticError -&gt;\n    :infinity\nelse\n  y when y &lt; 1 and y &gt; -1 -&gt;\n    :small\n  _ -&gt;\n    :large\nend</code></pre> <p>If an else clause is not present and no exceptions are raised, the result of the expression will be returned:</p> <pre data-language=\"elixir\"><code class=\"elixir\">x = 1\n^x =\n  try do\n    1 / x\n  rescue\n    ArithmeticError -&gt;\n      :infinity\n  end</code></pre> <p>However when an else clause is present but the result of the expression does not match any of the patterns an exception will be raised. This exception will not be caught by a catch or rescue in the same try:</p> <pre data-language=\"elixir\"><code class=\"elixir\">x = 1\ntry do\n  try do\n    1 / x\n  rescue\n    # The TryClauseError can not be rescued here:\n    TryClauseError -&gt;\n      :error_a\n  else\n    0 -&gt;\n      :small\n  end\nrescue\n  # The TryClauseError is rescued here:\n  TryClauseError -&gt;\n    :error_b\nend</code></pre> <p>Similarly an exception inside an else clause is not caught or rescued inside the same try:</p> <pre data-language=\"elixir\"><code class=\"elixir\">try do\n  try do\n    nil\n  catch\n    # The exit(1) call below can not be caught here:\n    :exit, _ -&gt;\n      :exit_a\n  else\n    _ -&gt;\n      exit(1)\n  end\ncatch\n  # The exit is caught here:\n  :exit, _ -&gt;\n    :exit_b\nend</code></pre> <p>This means the VM no longer needs to keep the stacktrace once inside an else clause and so tail recursion is possible when using a <code class=\"inline\">try</code> with a tail call as the final call inside an else clause. The same is true for <code class=\"inline\">rescue</code> and <code class=\"inline\">catch</code> clauses.</p> <h4>Variable handling</h4> <p>Since an expression inside <code class=\"inline\">try</code> may not have been evaluated due to an exception, any variable created inside <code class=\"inline\">try</code> cannot be accessed externally. For instance:</p> <pre data-language=\"elixir\"><code class=\"elixir\">try do\n  x = 1\n  do_something_that_may_fail(same_arg)\n  :ok\ncatch\n  _, _ -&gt; :failed\nend\n\nx #=&gt; unbound variable \"x\"</code></pre> <p>In the example above, <code class=\"inline\">x</code> cannot be accessed since it was defined inside the <code class=\"inline\">try</code> clause. A common practice to address this issue is to return the variables defined inside <code class=\"inline\">try</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">x =\n  try do\n    x = 1\n    do_something_that_may_fail(same_arg)\n    x\n  catch\n    _, _ -&gt; :failed\n  end</code></pre>    <h3 class=\"detail-header macro\" id=\"unquote/1\">  <span class=\"signature\">unquote(expr)</span>  </h3>  <p>Unquotes the given expression from inside a macro.</p> <h4>Examples</h4> <p>Imagine the situation you have a variable <code class=\"inline\">value</code> and you want to inject it inside some quote. The first attempt would be:</p> <pre data-language=\"elixir\"><code class=\"elixir\">value = 13\nquote do\n  sum(1, value, 3)\nend</code></pre> <p>Which would then return:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:sum, [], [1, {:value, [], quoted}, 3]}</code></pre> <p>Which is not the expected result. For this, we use unquote:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; value = 13\niex&gt; quote do\n...&gt;   sum(1, unquote(value), 3)\n...&gt; end\n{:sum, [], [1, 13, 3]}</code></pre>    <h3 class=\"detail-header macro\" id=\"unquote_splicing/1\">  <span class=\"signature\">unquote_splicing(expr)</span>  </h3>  <p>Unquotes the given list expanding its arguments. Similar to <a href=\"#unquote/1\"><code class=\"inline\">unquote/1</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; values = [2, 3, 4]\niex&gt; quote do\n...&gt;   sum(1, unquote_splicing(values), 5)\n...&gt; end\n{:sum, [], [1, 2, 3, 4, 5]}</code></pre>    <h3 class=\"detail-header macro\" id=\"with/1\">  <span class=\"signature\">with(args)</span>  </h3>  <p>Used to combine matching clauses.</p> <p>Let’s start with an example:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; opts = %{width: 10, height: 15}\niex&gt; with {:ok, width} &lt;- Map.fetch(opts, :width),\n...&gt;      {:ok, height} &lt;- Map.fetch(opts, :height),\n...&gt;   do: {:ok, width * height}\n{:ok, 150}</code></pre> <p>If all clauses match, the <code class=\"inline\">do</code> block is executed, returning its result. Otherwise the chain is aborted and the non-matched value is returned:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; opts = %{width: 10}\niex&gt; with {:ok, width} &lt;- Map.fetch(opts, :width),\n...&gt;      {:ok, height} &lt;- Map.fetch(opts, :height),\n...&gt;   do: {:ok, width * height}\n:error</code></pre> <p>Guards can be used in patterns as well:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = %{\"melany\" =&gt; \"guest\", \"bob\" =&gt; :admin}\niex&gt; with {:ok, role} when not is_binary(role) &lt;- Map.fetch(users, \"bob\"),\n...&gt;   do: {:ok, to_string(role)}\n{:ok, \"admin\"}</code></pre> <p>As in <a href=\"#for/1\"><code class=\"inline\">for/1</code></a>, variables bound inside <a href=\"#with/1\"><code class=\"inline\">with/1</code></a> won’t leak; “bare expressions” may also be inserted between the clauses:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; width = nil\niex&gt; opts = %{width: 10, height: 15}\niex&gt; with {:ok, width} &lt;- Map.fetch(opts, :width),\n...&gt;      double_width = width * 2,\n...&gt;      {:ok, height} &lt;- Map.fetch(opts, :height),\n...&gt;   do: {:ok, double_width * height}\n{:ok, 300}\niex&gt; width\nnil</code></pre> <p>An <code class=\"inline\">else</code> option can be given to modify what is being returned from <code class=\"inline\">with</code> in the case of a failed match:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; opts = %{width: 10}\niex&gt; with {:ok, width} &lt;- Map.fetch(opts, :width),\n...&gt;      {:ok, height} &lt;- Map.fetch(opts, :height) do\n...&gt;   {:ok, width * height}\n...&gt; else\n...&gt;   :error -&gt;\n...&gt;     {:error, :wrong_data}\n...&gt; end\n{:error, :wrong_data}</code></pre> <p>If there is no matching <code class=\"inline\">else</code> condition, then a <a href=\"withclauseerror\"><code class=\"inline\">WithClauseError</code></a> exception is raised.</p>    <h3 class=\"detail-header macro\" id=\"%7B%7D/1\">  <span class=\"signature\">{args}</span>  </h3>  <p>Creates a tuple.</p> <p>Only two item tuples are considered literals in Elixir. Therefore all other tuples are represented in the AST as a call to the special form <code class=\"inline\">:{}</code>.</p> <p>Conveniences for manipulating tuples can be found in the <a href=\"tuple\"><code class=\"inline\">Tuple</code></a> module. Some functions for working with tuples are also available in <a href=\"kernel\"><code class=\"inline\">Kernel</code></a>, namely <a href=\"kernel#elem/2\"><code class=\"inline\">Kernel.elem/2</code></a>, <a href=\"kernel#put_elem/3\"><code class=\"inline\">Kernel.put_elem/3</code></a> and <a href=\"kernel#tuple_size/1\"><code class=\"inline\">Kernel.tuple_size/1</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; {1, 2, 3}\n{1, 2, 3}\n\niex&gt; quote do\n...&gt;   {1, 2, 3}\n...&gt; end\n{:{}, [], [1, 2, 3]}</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Kernel.SpecialForms.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Kernel.SpecialForms.html</a>\n  </p>\n</div>\n","elixir/path":"<h1>  Path  </h1>  <p>This module provides conveniences for manipulating or retrieving file system paths.</p> <p>The functions in this module may receive a chardata as argument (i.e. a string or a list of characters / string) and will always return a string (encoded in UTF-8).</p> <p>The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like <a href=\"#wildcard/2\"><code class=\"inline\">wildcard/2</code></a> and <a href=\"#expand/1)\"><code class=\"inline\">expand/1</code></a>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#absname/1\">absname(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given path to an absolute one. Unlike <a href=\"#expand/1\"><code class=\"inline\">expand/1</code></a>, no attempt is made to resolve <code class=\"inline\">..</code>, <code class=\"inline\">.</code> or <code class=\"inline\">~</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#absname/2\">absname(path, relative_to)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Builds a path from <code class=\"inline\">relative_to</code> to <code class=\"inline\">path</code>. If <code class=\"inline\">path</code> is already an absolute path, <code class=\"inline\">relative_to</code> is ignored. See also <a href=\"#relative_to/2\"><code class=\"inline\">relative_to/2</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#basename/1\">basename(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the last component of the path or the path itself if it does not contain any directory separators</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#basename/2\">basename(path, extension)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the last component of <code class=\"inline\">path</code> with the <code class=\"inline\">extension</code> stripped. This function should be used to remove a specific extension which may, or may not, be there</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dirname/1\">dirname(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the directory component of <code class=\"inline\">path</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#expand/1\">expand(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the path to an absolute one and expands any <code class=\"inline\">.</code> and <code class=\"inline\">..</code> characters and a leading <code class=\"inline\">~</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#expand/2\">expand(path, relative_to)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Expands the path relative to the path given as the second argument expanding any <code class=\"inline\">.</code> and <code class=\"inline\">..</code> characters. If the path is already an absolute path, <code class=\"inline\">relative_to</code> is ignored</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#extname/1\">extname(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the extension of the last component of <code class=\"inline\">path</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#join/1\">join(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Joins a list of strings</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#join/2\">join(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Joins two paths</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#relative/1\">relative(name)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Forces the path to be a relative path</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#relative_to/2\">relative_to(path, from)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the given <code class=\"inline\">path</code> relative to the given <code class=\"inline\">from</code> path. In other words, it tries to strip the <code class=\"inline\">from</code> prefix from <code class=\"inline\">path</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#relative_to_cwd/1\">relative_to_cwd(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Convenience to get the path relative to the current working directory. If, for some reason, the current working directory cannot be retrieved, returns the full path</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rootname/1\">rootname(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the <code class=\"inline\">path</code> with the <code class=\"inline\">extension</code> stripped</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rootname/2\">rootname(path, extension)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the <code class=\"inline\">path</code> with the <code class=\"inline\">extension</code> stripped. This function should be used to remove a specific extension which might, or might not, be there</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#split/1\">split(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Splits the path into a list at the path separator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#type/1\">type(name)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the path type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#wildcard/2\">wildcard(glob, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Traverses paths according to the given <code class=\"inline\">glob</code> expression, and returns a list of matches</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: :unicode.chardata</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"absname/1\">  <span class=\"signature\">absname(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">absname(<a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Converts the given path to an absolute one. Unlike <a href=\"#expand/1\"><code class=\"inline\">expand/1</code></a>, no attempt is made to resolve <code class=\"inline\">..</code>, <code class=\"inline\">.</code> or <code class=\"inline\">~</code>.</p> <h4>Unix examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Path.absname(\"foo\")\n#=&gt; \"/usr/local/foo\"\n\nPath.absname(\"../x\")\n#=&gt; \"/usr/local/../x\"</code></pre> <h4>Windows</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Path.absname(\"foo\").\n\"D:/usr/local/foo\"\nPath.absname(\"../x\").\n\"D:/usr/local/../x\"</code></pre>    <h3 class=\"detail-header function\" id=\"absname/2\">  <span class=\"signature\">absname(path, relative_to)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">absname(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Builds a path from <code class=\"inline\">relative_to</code> to <code class=\"inline\">path</code>. If <code class=\"inline\">path</code> is already an absolute path, <code class=\"inline\">relative_to</code> is ignored. See also <a href=\"#relative_to/2\"><code class=\"inline\">relative_to/2</code></a>.</p> <p>Unlike <a href=\"#expand/2\"><code class=\"inline\">expand/2</code></a>, no attempt is made to resolve <code class=\"inline\">..</code>, <code class=\"inline\">.</code> or <code class=\"inline\">~</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Path.absname(\"foo\", \"bar\")\n\"bar/foo\"\n\niex&gt; Path.absname(\"../x\", \"bar\")\n\"bar/../x\"</code></pre>    <h3 class=\"detail-header function\" id=\"basename/1\">  <span class=\"signature\">basename(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">basename(<a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Returns the last component of the path or the path itself if it does not contain any directory separators.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Path.basename(\"foo\")\n\"foo\"\n\niex&gt; Path.basename(\"foo/bar\")\n\"bar\"\n\niex&gt; Path.basename(\"/\")\n\"\"</code></pre>    <h3 class=\"detail-header function\" id=\"basename/2\">  <span class=\"signature\">basename(path, extension)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">basename(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Returns the last component of <code class=\"inline\">path</code> with the <code class=\"inline\">extension</code> stripped. This function should be used to remove a specific extension which may, or may not, be there.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Path.basename(\"~/foo/bar.ex\", \".ex\")\n\"bar\"\n\niex&gt; Path.basename(\"~/foo/bar.exs\", \".ex\")\n\"bar.exs\"\n\niex&gt; Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n\"bar.old\"</code></pre>    <h3 class=\"detail-header function\" id=\"dirname/1\">  <span class=\"signature\">dirname(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">dirname(<a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Returns the directory component of <code class=\"inline\">path</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Path.dirname(\"/foo/bar.ex\")\n\"/foo\"\n\niex&gt; Path.dirname(\"/foo/bar/baz.ex\")\n\"/foo/bar\"</code></pre>    <h3 class=\"detail-header function\" id=\"expand/1\">  <span class=\"signature\">expand(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">expand(<a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Converts the path to an absolute one and expands any <code class=\"inline\">.</code> and <code class=\"inline\">..</code> characters and a leading <code class=\"inline\">~</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Path.expand(\"/foo/bar/../bar\")\n#=&gt; \"/foo/bar\"</code></pre>    <h3 class=\"detail-header function\" id=\"expand/2\">  <span class=\"signature\">expand(path, relative_to)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">expand(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Expands the path relative to the path given as the second argument expanding any <code class=\"inline\">.</code> and <code class=\"inline\">..</code> characters. If the path is already an absolute path, <code class=\"inline\">relative_to</code> is ignored.</p> <p>Note, that this function treats <code class=\"inline\">path</code> with a leading <code class=\"inline\">~</code> as an absolute one.</p> <p>The second argument is first expanded to an absolute path.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Assuming that the absolute path to baz is /quux/baz\nPath.expand(\"foo/bar/../bar\", \"baz\")\n#=&gt; \"/quux/baz/foo/bar\"\n\nPath.expand(\"foo/bar/../bar\", \"/baz\")\n\"/baz/foo/bar\"\nPath.expand(\"/foo/bar/../bar\", \"/baz\")\n\"/foo/bar\"</code></pre>    <h3 class=\"detail-header function\" id=\"extname/1\">  <span class=\"signature\">extname(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">extname(<a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Returns the extension of the last component of <code class=\"inline\">path</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Path.extname(\"foo.erl\")\n\".erl\"\n\niex&gt; Path.extname(\"~/foo/bar\")\n\"\"</code></pre>    <h3 class=\"detail-header function\" id=\"join/1\">  <span class=\"signature\">join(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">join([<a href=\"#t:t/0\">t</a>]) :: binary</code></pre>    <p>Joins a list of strings.</p> <p>This function should be used to convert a list of strings to a path. Note that any trailing slash is removed on join.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Path.join([\"~\", \"foo\"])\n\"~/foo\"\n\niex&gt; Path.join([\"foo\"])\n\"foo\"\n\niex&gt; Path.join([\"/\", \"foo\", \"bar/\"])\n\"/foo/bar\"</code></pre>    <h3 class=\"detail-header function\" id=\"join/2\">  <span class=\"signature\">join(left, right)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">join(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Joins two paths.</p> <p>The right path will always be expanded to its relative format and any trailing slash is removed on join.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Path.join(\"foo\", \"bar\")\n\"foo/bar\"</code></pre>    <h3 class=\"detail-header function\" id=\"relative/1\">  <span class=\"signature\">relative(name)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">relative(<a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Forces the path to be a relative path.</p> <h4>Unix examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Path.relative(\"/usr/local/bin\")   #=&gt; \"usr/local/bin\"\nPath.relative(\"usr/local/bin\")    #=&gt; \"usr/local/bin\"\nPath.relative(\"../usr/local/bin\") #=&gt; \"../usr/local/bin\"</code></pre> <h4>Windows examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Path.relative(\"D:/usr/local/bin\") #=&gt; \"usr/local/bin\"\nPath.relative(\"usr/local/bin\")    #=&gt; \"usr/local/bin\"\nPath.relative(\"D:bar.ex\")         #=&gt; \"bar.ex\"\nPath.relative(\"/bar/foo.ex\")      #=&gt; \"bar/foo.ex\"</code></pre>    <h3 class=\"detail-header function\" id=\"relative_to/2\">  <span class=\"signature\">relative_to(path, from)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">relative_to(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Returns the given <code class=\"inline\">path</code> relative to the given <code class=\"inline\">from</code> path. In other words, it tries to strip the <code class=\"inline\">from</code> prefix from <code class=\"inline\">path</code>.</p> <p>This function does not query the file system, so it assumes no symlinks between the paths.</p> <p>In case a direct relative path cannot be found, it returns the original path.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n\"foo\"\n\niex&gt; Path.relative_to(\"/usr/local/foo\", \"/\")\n\"usr/local/foo\"\n\niex&gt; Path.relative_to(\"/usr/local/foo\", \"/etc\")\n\"/usr/local/foo\"</code></pre>    <h3 class=\"detail-header function\" id=\"relative_to_cwd/1\">  <span class=\"signature\">relative_to_cwd(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">relative_to_cwd(<a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Convenience to get the path relative to the current working directory. If, for some reason, the current working directory cannot be retrieved, returns the full path.</p>    <h3 class=\"detail-header function\" id=\"rootname/1\">  <span class=\"signature\">rootname(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rootname(<a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Returns the <code class=\"inline\">path</code> with the <code class=\"inline\">extension</code> stripped.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Path.rootname(\"/foo/bar\")\n\"/foo/bar\"\n\niex&gt; Path.rootname(\"/foo/bar.ex\")\n\"/foo/bar\"</code></pre>    <h3 class=\"detail-header function\" id=\"rootname/2\">  <span class=\"signature\">rootname(path, extension)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rootname(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Returns the <code class=\"inline\">path</code> with the <code class=\"inline\">extension</code> stripped. This function should be used to remove a specific extension which might, or might not, be there.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Path.rootname(\"/foo/bar.erl\", \".erl\")\n\"/foo/bar\"\n\niex&gt; Path.rootname(\"/foo/bar.erl\", \".ex\")\n\"/foo/bar.erl\"</code></pre>    <h3 class=\"detail-header function\" id=\"split/1\">  <span class=\"signature\">split(path)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">split(<a href=\"#t:t/0\">t</a>) :: [binary]</code></pre>    <p>Splits the path into a list at the path separator.</p> <p>If an empty string is given, returns an empty list.</p> <p>On Windows, path is split on both “\\” and “/“ separators and the driver letter, if there is one, is always returned in lowercase.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Path.split(\"\")\n[]\n\niex&gt; Path.split(\"foo\")\n[\"foo\"]\n\niex&gt; Path.split(\"/foo/bar\")\n[\"/\", \"foo\", \"bar\"]</code></pre>    <h3 class=\"detail-header function\" id=\"type/1\">  <span class=\"signature\">type(name)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">type(<a href=\"#t:t/0\">t</a>) :: :absolute | :relative | :volumerelative</code></pre>    <p>Returns the path type.</p> <h4>Unix examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Path.type(\"/\")                #=&gt; :absolute\nPath.type(\"/usr/local/bin\")   #=&gt; :absolute\nPath.type(\"usr/local/bin\")    #=&gt; :relative\nPath.type(\"../usr/local/bin\") #=&gt; :relative\nPath.type(\"~/file\")           #=&gt; :relative</code></pre> <h4>Windows examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Path.type(\"D:/usr/local/bin\") #=&gt; :absolute\nPath.type(\"usr/local/bin\")    #=&gt; :relative\nPath.type(\"D:bar.ex\")         #=&gt; :volumerelative\nPath.type(\"/bar/foo.ex\")      #=&gt; :volumerelative</code></pre>    <h3 class=\"detail-header function\" id=\"wildcard/2\">  <span class=\"signature\">wildcard(glob, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">wildcard(<a href=\"#t:t/0\">t</a>, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: [binary]</code></pre>    <p>Traverses paths according to the given <code class=\"inline\">glob</code> expression, and returns a list of matches.</p> <p>The wildcard looks like an ordinary path, except that certain “wildcard characters” are interpreted in a special way. The following characters are special:</p> <ul> <li>\n<p><code class=\"inline\">?</code> - matches one character</p> </li> <li>\n<p><code class=\"inline\">*</code> - matches any number of characters up to the end of the filename, the next dot, or the next slash</p> </li> <li>\n<p><code class=\"inline\">**</code> - two adjacent <code class=\"inline\">*</code>’s used as a single pattern will match all files and zero or more directories and subdirectories</p> </li> <li>\n<p><code class=\"inline\">[char1,char2,...]</code> - matches any of the characters listed; two characters separated by a hyphen will match a range of characters. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</p> </li> <li>\n<code class=\"inline\">{item1,item2,...}</code> - matches one of the alternatives Do not add spaces before and after the comma as it would then match paths containing the space character itself. </li> </ul> <p>Other characters represent themselves. Only paths that have exactly the same character in the same position will match. Note that matching is case-sensitive; i.e. “a” will not match “A”.</p> <p>By default, the patterns <code class=\"inline\">*</code> and <code class=\"inline\">?</code> do not match files starting with a dot <code class=\"inline\">.</code> unless <code class=\"inline\">match_dot: true</code> is given in <code class=\"inline\">opts</code>.</p> <h4>Examples</h4> <p>Imagine you have a directory called <code class=\"inline\">projects</code> with three Elixir projects inside of it: <code class=\"inline\">elixir</code>, <code class=\"inline\">ex_doc</code> and <code class=\"inline\">dynamo</code>. You can find all <code class=\"inline\">.beam</code> files inside the <code class=\"inline\">ebin</code> directory of each project as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Path.wildcard(\"projects/*/ebin/**/*.beam\")</code></pre> <p>If you want to search for both <code class=\"inline\">.beam</code> and <code class=\"inline\">.app</code> files, you could do:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Path.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Path.html</a>\n  </p>\n</div>\n","elixir/stringio":"<h1>  StringIO  </h1>  <p>Controls an IO device process that wraps a string.</p> <p>A <a href=\"stringio#content\"><code class=\"inline\">StringIO</code></a> IO device can be passed as a “device” to most of the functions in the <a href=\"io\"><code class=\"inline\">IO</code></a> module.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; {:ok, pid} = StringIO.open(\"foo\")\niex&gt; IO.read(pid, 2)\n\"fo\"</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#close/1\">close(pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stops the IO device and returns the remaining input/output buffers</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#contents/1\">contents(pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current input/output buffers for the given IO device</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#flush/1\">flush(pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Flushes the output buffer and returns its current contents</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#open/2\">open(string, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates an IO device</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"close/1\">  <span class=\"signature\">close(pid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">close(pid) :: {:ok, {binary, binary}}</code></pre>    <p>Stops the IO device and returns the remaining input/output buffers.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; {:ok, pid} = StringIO.open(\"in\")\niex&gt; IO.write(pid, \"out\")\niex&gt; StringIO.close(pid)\n{:ok, {\"in\", \"out\"}}</code></pre>    <h3 class=\"detail-header function\" id=\"contents/1\">  <span class=\"signature\">contents(pid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">contents(pid) :: {binary, binary}</code></pre>    <p>Returns the current input/output buffers for the given IO device.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; {:ok, pid} = StringIO.open(\"in\")\niex&gt; IO.write(pid, \"out\")\niex&gt; StringIO.contents(pid)\n{\"in\", \"out\"}</code></pre>    <h3 class=\"detail-header function\" id=\"flush/1\">  <span class=\"signature\">flush(pid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">flush(pid) :: binary</code></pre>    <p>Flushes the output buffer and returns its current contents.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; {:ok, pid} = StringIO.open(\"in\")\niex&gt; IO.write(pid, \"out\")\niex&gt; StringIO.flush(pid)\n\"out\"\niex&gt; StringIO.contents(pid)\n{\"in\", \"\"}</code></pre>    <h3 class=\"detail-header function\" id=\"open/2\">  <span class=\"signature\">open(string, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">open(binary, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: {:ok, pid}</code></pre>    <p>Creates an IO device.</p> <p><code class=\"inline\">string</code> will be the initial input of the newly created device.</p> <p>If the <code class=\"inline\">:capture_prompt</code> option is set to <code class=\"inline\">true</code>, prompts (specified as arguments to <code class=\"inline\">IO.get*</code> functions) are captured.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; {:ok, pid} = StringIO.open(\"foo\")\niex&gt; IO.gets(pid, \"&gt;\")\n\"foo\"\niex&gt; StringIO.contents(pid)\n{\"\", \"\"}\n\niex&gt; {:ok, pid} = StringIO.open(\"foo\", capture_prompt: true)\niex&gt; IO.gets(pid, \"&gt;\")\n\"foo\"\niex&gt; StringIO.contents(pid)\n{\"\", \"&gt;\"}</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/StringIO.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/StringIO.html</a>\n  </p>\n</div>\n","elixir/tuple":"<h1>  Tuple  </h1>  <p>Functions for working with tuples.</p> <p>See also <a href=\"kernel#elem/2\"><code class=\"inline\">Kernel.elem/2</code></a>, <a href=\"kernel#is_tuple/1\"><code class=\"inline\">Kernel.is_tuple/1</code></a>, <a href=\"kernel#put_elem/3\"><code class=\"inline\">Kernel.put_elem/3</code></a>, and <a href=\"kernel#tuple_size/1\"><code class=\"inline\">Kernel.tuple_size/1</code></a>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#append/2\">append(tuple, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts an element at the end of a tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete_at/2\">delete_at(tuple, index)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes an element from a tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#duplicate/2\">duplicate(data, size)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a new tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#insert_at/3\">insert_at(tuple, index, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts an element into a tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_list/1\">to_list(tuple)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a tuple to a list</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"append/2\">  <span class=\"signature\">append(tuple, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">append(tuple, term) :: tuple</code></pre>    <p>Inserts an element at the end of a tuple.</p> <p>Returns a new tuple with the element appended at the end, and contains the elements in <code class=\"inline\">tuple</code> followed by <code class=\"inline\">value</code> as the last element.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; tuple = {:foo, :bar}\niex&gt; Tuple.append(tuple, :baz)\n{:foo, :bar, :baz}</code></pre>    <h3 class=\"detail-header function\" id=\"delete_at/2\">  <span class=\"signature\">delete_at(tuple, index)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete_at(tuple, non_neg_integer) :: tuple</code></pre>    <p>Removes an element from a tuple.</p> <p>Deletes the element at the given <code class=\"inline\">index</code> from <code class=\"inline\">tuple</code>. Raises an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> if <code class=\"inline\">index</code> is negative or greater than or equal to the length of <code class=\"inline\">tuple</code>. Index is zero-based.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; tuple = {:foo, :bar, :baz}\niex&gt; Tuple.delete_at(tuple, 0)\n{:bar, :baz}</code></pre>    <h3 class=\"detail-header function\" id=\"duplicate/2\">  <span class=\"signature\">duplicate(data, size)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">duplicate(term, non_neg_integer) :: tuple</code></pre>    <p>Creates a new tuple.</p> <p>Creates a tuple of <code class=\"inline\">size</code> containing the given <code class=\"inline\">data</code> at every position.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Tuple.duplicate(:hello, 3)\n{:hello, :hello, :hello}</code></pre>    <h3 class=\"detail-header function\" id=\"insert_at/3\">  <span class=\"signature\">insert_at(tuple, index, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">insert_at(tuple, non_neg_integer, term) :: tuple</code></pre>    <p>Inserts an element into a tuple.</p> <p>Inserts <code class=\"inline\">value</code> into <code class=\"inline\">tuple</code> at the given <code class=\"inline\">index</code>. Raises an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> if <code class=\"inline\">index</code> is negative or greater than the length of <code class=\"inline\">tuple</code>. Index is zero-based.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; tuple = {:bar, :baz}\niex&gt; Tuple.insert_at(tuple, 0, :foo)\n{:foo, :bar, :baz}\niex&gt; Tuple.insert_at(tuple, 2, :bong)\n{:bar, :baz, :bong}</code></pre>    <h3 class=\"detail-header function\" id=\"to_list/1\">  <span class=\"signature\">to_list(tuple)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_list(tuple) :: list</code></pre>    <p>Converts a tuple to a list.</p> <p>Returns a new list with all the tuple elements.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; tuple = {:foo, :bar, :baz}\niex&gt; Tuple.to_list(tuple)\n[:foo, :bar, :baz]</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Tuple.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Tuple.html</a>\n  </p>\n</div>\n","elixir/process":"<h1>  Process  </h1>  <p>Conveniences for working with processes and the process dictionary.</p> <p>Besides the functions available in this module, the <a href=\"kernel\"><code class=\"inline\">Kernel</code></a> module exposes and auto-imports some basic functionality related to processes available through the functions:</p> <ul> <li>\n<a href=\"kernel#spawn/1\"><code class=\"inline\">Kernel.spawn/1</code></a> and <a href=\"kernel#spawn/3\"><code class=\"inline\">Kernel.spawn/3</code></a> </li> <li>\n<a href=\"kernel#spawn_link/1\"><code class=\"inline\">Kernel.spawn_link/1</code></a> and <a href=\"kernel#spawn_link/3\"><code class=\"inline\">Kernel.spawn_link/3</code></a> </li> <li>\n<a href=\"kernel#spawn_monitor/1\"><code class=\"inline\">Kernel.spawn_monitor/1</code></a> and <a href=\"kernel#spawn_monitor/3\"><code class=\"inline\">Kernel.spawn_monitor/3</code></a> </li> <li>\n<a href=\"kernel#self/0\"><code class=\"inline\">Kernel.self/0</code></a> </li> <li>\n<a href=\"kernel#send/2\"><code class=\"inline\">Kernel.send/2</code></a> </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:spawn_opt/0\">spawn_opt()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:spawn_opts/0\">spawn_opts()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#alive?/1\">alive?(pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the process exists and is alive (i.e. it is not exiting and has not exited yet). Otherwise, returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cancel_timer/1\">cancel_timer(timer_ref)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Cancels a timer created by <a href=\"#send_after/3\"><code class=\"inline\">send_after/3</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete/1\">delete(key)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes the given <code class=\"inline\">key</code> from the process dictionary</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#demonitor/2\">demonitor(monitor_ref, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>If <code class=\"inline\">monitor_ref</code> is a reference which the calling process obtained by calling <a href=\"#monitor/1\"><code class=\"inline\">monitor/1</code></a>, this monitoring is turned off. If the monitoring is already turned off, nothing happens</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#exit/2\">exit(pid, reason)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends an exit signal with the given <code class=\"inline\">reason</code> to the <code class=\"inline\">pid</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#flag/2\">flag(flag, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets certain flags for the process which calls this function. Returns the old value of the <code class=\"inline\">flag</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#flag/3\">flag(pid, flag, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets certain flags for the process <code class=\"inline\">pid</code>, in the same manner as <a href=\"#flag/2\"><code class=\"inline\">flag/2</code></a>. Returns the old value of the <code class=\"inline\">flag</code>. The allowed values for <code class=\"inline\">flag</code> are only a subset of those allowed in <a href=\"#flag/2\"><code class=\"inline\">flag/2</code></a>, namely <code class=\"inline\">:save_calls</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get/0\">get()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all key-value pairs in the process dictionary</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get/2\">get(key, default \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the value for the given <code class=\"inline\">key</code> or <code class=\"inline\">default</code> if <code class=\"inline\">key</code> is not set</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_keys/0\">get_keys()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all keys in the process dictionary</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_keys/1\">get_keys(value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all keys that have the given <code class=\"inline\">value</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#group_leader/0\">group_leader()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the pid of the group leader for the process which evaluates the function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#group_leader/2\">group_leader(pid, leader)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets the group leader of <code class=\"inline\">pid</code> to <code class=\"inline\">leader</code>. Typically, this is used when a processes started from a certain shell should have a group leader other than <code class=\"inline\">:init</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#hibernate/3\">hibernate(mod, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts the calling process into a wait state where its memory allocation has been reduced as much as possible, which is useful if the process does not expect to receive any messages in the near future</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#info/1\">info(pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns information about the process identified by <code class=\"inline\">pid</code>, or returns <code class=\"inline\">nil</code> if the process is not alive. Use this only for debugging information</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#info/2\">info(pid, spec)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns information about the process identified by <code class=\"inline\">pid</code>, or returns <code class=\"inline\">nil</code> if the process is not alive</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#link/1\">link(pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a link between the calling process and another process (or port) <code class=\"inline\">pid</code>, if there is not such a link already</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#list/0\">list()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of process identifiers corresponding to all the processes currently existing on the local node</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#monitor/1\">monitor(item)</a> </dt> <dd class=\"summary-synopsis\">\n<p>The calling process starts monitoring the given <code class=\"inline\">item</code>. It returns the monitor reference</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put/2\">put(key, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stores the given <code class=\"inline\">key</code>-<code class=\"inline\">value</code> pair in the process dictionary</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#read_timer/1\">read_timer(timer_ref)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reads a timer created by <a href=\"#send_after/3\"><code class=\"inline\">send_after/3</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#register/2\">register(pid, name)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Associates the atom <code class=\"inline\">name</code> with a <code class=\"inline\">pid</code> or a port identifier</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#registered/0\">registered()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of names which have been registered using <a href=\"#register/2\"><code class=\"inline\">register/2</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#send/3\">send(dest, msg, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends a message to the given process</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#send_after/3\">send_after(dest, msg, time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends <code class=\"inline\">msg</code> to <code class=\"inline\">dest</code> after <code class=\"inline\">time</code> milliseconds</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sleep/1\">sleep(timeout)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sleeps the current process by <code class=\"inline\">timeout</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn/2\">spawn(fun, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Spawns the given function according to the given options</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn/4\">spawn(mod, fun, args, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Spawns the given function from module <code class=\"inline\">mod</code>, passing the given <code class=\"inline\">args</code> according to the given options</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unlink/1\">unlink(pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes the link, if there is one, between the calling process and the process or port referred to by <code class=\"inline\">pid</code>. Returns <code class=\"inline\">true</code> and does not fail, even if there is no link or <code class=\"inline\">id</code> does not exist</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unregister/1\">unregister(name)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes the registered <code class=\"inline\">name</code>, associated with a pid or a port identifier</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#whereis/1\">whereis(name)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the pid or port identifier with the registered <code class=\"inline\">name</code>. Returns <code class=\"inline\">nil</code> if the name is not registered</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:spawn_opt/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:spawn_opt/0\">spawn_opt</a> ::\n  :link |\n  :monitor |\n  {:priority, :low | :normal | :high} |\n  {:fullsweep_after, non_neg_integer} |\n  {:min_heap_size, non_neg_integer} |\n  {:min_bin_vheap_size, non_neg_integer}</code></pre> </div> <div id=\"t:spawn_opts/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:spawn_opts/0\">spawn_opts</a> :: [<a href=\"#t:spawn_opt/0\">spawn_opt</a>]</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"alive?/1\">  <span class=\"signature\">alive?(pid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">alive?(pid) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if the process exists and is alive (i.e. it is not exiting and has not exited yet). Otherwise, returns <code class=\"inline\">false</code>.</p> <p><code class=\"inline\">pid</code> must refer to a process at the local node.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"cancel_timer/1\">  <span class=\"signature\">cancel_timer(timer_ref)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cancel_timer(reference) :: non_neg_integer | false</code></pre>    <p>Cancels a timer created by <a href=\"#send_after/3\"><code class=\"inline\">send_after/3</code></a>.</p> <p>When the result is an integer, it represents the time in milliseconds left until the timer would have expired.</p> <p>When the result is <code class=\"inline\">false</code>, a timer corresponding to <code class=\"inline\">timer_ref</code> could not be found. This can be either because the timer expired, already has been canceled, or because <code class=\"inline\">timer_ref</code> never corresponded to a timer.</p> <p>If the timer has expired, the timeout message has been sent, but it does not tell you whether or not it has arrived at its destination yet.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"delete/1\">  <span class=\"signature\">delete(key)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete(term) :: term | nil</code></pre>    <p>Deletes the given <code class=\"inline\">key</code> from the process dictionary.</p>    <h3 class=\"detail-header function\" id=\"demonitor/2\">  <span class=\"signature\">demonitor(monitor_ref, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">demonitor(reference, options :: [:flush | :info]) :: boolean</code></pre>    <p>If <code class=\"inline\">monitor_ref</code> is a reference which the calling process obtained by calling <a href=\"#monitor/1\"><code class=\"inline\">monitor/1</code></a>, this monitoring is turned off. If the monitoring is already turned off, nothing happens.</p> <p>See <a href=\"http://www.erlang.org/doc/man/erlang.html#demonitor-2\"><code class=\"inline\">:erlang.demonitor/2</code></a> for more info.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"exit/2\">  <span class=\"signature\">exit(pid, reason)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exit(pid, term) :: true</code></pre>    <p>Sends an exit signal with the given <code class=\"inline\">reason</code> to the <code class=\"inline\">pid</code>.</p> <p>The following behaviour applies if <code class=\"inline\">reason</code> is any term except <code class=\"inline\">:normal</code> or <code class=\"inline\">:kill</code>:</p> <ol> <li>\n<p>If <code class=\"inline\">pid</code> is not trapping exits, <code class=\"inline\">pid</code> will exit with the given <code class=\"inline\">reason</code>.</p> </li> <li>\n<p>If <code class=\"inline\">pid</code> is trapping exits, the exit signal is transformed into a message <code class=\"inline\">{:EXIT, from, reason}</code> and delivered to the message queue of <code class=\"inline\">pid</code>.</p> </li> <li>\n<p>If <code class=\"inline\">reason</code> is the atom <code class=\"inline\">:normal</code>, <code class=\"inline\">pid</code> will not exit (unless it is the calling process’s pid, in which case it will exit with the reason <code class=\"inline\">:normal</code>). If it is trapping exits, the exit signal is transformed into a message <code class=\"inline\">{:EXIT, from, :normal}</code> and delivered to its message queue.</p> </li> <li>If <code class=\"inline\">reason</code> is the atom <code class=\"inline\">:kill</code>, that is if <code class=\"inline\">exit(pid, :kill)</code> is called, an untrappable exit signal is sent to <code class=\"inline\">pid</code> which will unconditionally exit with exit reason <code class=\"inline\">:killed</code>. </li> </ol> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Process.exit(pid, :kill)</code></pre>    <h3 class=\"detail-header function\" id=\"flag/2\">  <span class=\"signature\">flag(flag, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">flag(process_flag, term) :: term</code></pre>    <p>Sets certain flags for the process which calls this function. Returns the old value of the <code class=\"inline\">flag</code>.</p> <p>See <a href=\"http://www.erlang.org/doc/man/erlang.html#process_flag-2\"><code class=\"inline\">:erlang.process_flag/2</code></a> for more info.</p>    <h3 class=\"detail-header function\" id=\"flag/3\">  <span class=\"signature\">flag(pid, flag, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">flag(pid, :save_calls, non_neg_integer) :: non_neg_integer</code></pre>    <p>Sets certain flags for the process <code class=\"inline\">pid</code>, in the same manner as <a href=\"#flag/2\"><code class=\"inline\">flag/2</code></a>. Returns the old value of the <code class=\"inline\">flag</code>. The allowed values for <code class=\"inline\">flag</code> are only a subset of those allowed in <a href=\"#flag/2\"><code class=\"inline\">flag/2</code></a>, namely <code class=\"inline\">:save_calls</code>.</p> <p>See <a href=\"http://www.erlang.org/doc/man/erlang.html#process_flag-3\"><code class=\"inline\">:erlang.process_flag/3</code></a> for more info.</p>    <h3 class=\"detail-header function\" id=\"get/0\">  <span class=\"signature\">get()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get :: [{term, term}]</code></pre>    <p>Returns all key-value pairs in the process dictionary.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"get/2\">  <span class=\"signature\">get(key, default \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get(term, default :: term) :: term</code></pre>    <p>Returns the value for the given <code class=\"inline\">key</code> or <code class=\"inline\">default</code> if <code class=\"inline\">key</code> is not set.</p>    <h3 class=\"detail-header function\" id=\"get_keys/0\">  <span class=\"signature\">get_keys()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_keys :: [term]</code></pre>    <p>Returns all keys in the process dictionary.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"get_keys/1\">  <span class=\"signature\">get_keys(value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_keys(term) :: [term]</code></pre>    <p>Returns all keys that have the given <code class=\"inline\">value</code>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"group_leader/0\">  <span class=\"signature\">group_leader()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">group_leader :: pid</code></pre>    <p>Returns the pid of the group leader for the process which evaluates the function.</p>    <h3 class=\"detail-header function\" id=\"group_leader/2\">  <span class=\"signature\">group_leader(pid, leader)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">group_leader(pid, leader :: pid) :: true</code></pre>    <p>Sets the group leader of <code class=\"inline\">pid</code> to <code class=\"inline\">leader</code>. Typically, this is used when a processes started from a certain shell should have a group leader other than <code class=\"inline\">:init</code>.</p>    <h3 class=\"detail-header function\" id=\"hibernate/3\">  <span class=\"signature\">hibernate(mod, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">hibernate(module, atom, list) :: no_return</code></pre>    <p>Puts the calling process into a wait state where its memory allocation has been reduced as much as possible, which is useful if the process does not expect to receive any messages in the near future.</p> <p>See <a href=\"http://www.erlang.org/doc/man/erlang.html#hibernate-3\"><code class=\"inline\">:erlang.hibernate/3</code></a> for more info.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"info/1\">  <span class=\"signature\">info(pid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">info(pid) :: <a href=\"keyword#t:t/0\">Keyword.t</a></code></pre>    <p>Returns information about the process identified by <code class=\"inline\">pid</code>, or returns <code class=\"inline\">nil</code> if the process is not alive. Use this only for debugging information.</p> <p>See <a href=\"http://www.erlang.org/doc/man/erlang.html#process_info-1\"><code class=\"inline\">:erlang.process_info/1</code></a> for more info.</p>    <h3 class=\"detail-header function\" id=\"info/2\">  <span class=\"signature\">info(pid, spec)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">info(pid, atom | [atom]) ::\n  {atom, term} |\n  [{atom, term}] |\n  nil</code></pre>    <p>Returns information about the process identified by <code class=\"inline\">pid</code>, or returns <code class=\"inline\">nil</code> if the process is not alive.</p> <p>See <a href=\"http://www.erlang.org/doc/man/erlang.html#process_info-2\"><code class=\"inline\">:erlang.process_info/2</code></a> for more info.</p>    <h3 class=\"detail-header function\" id=\"link/1\">  <span class=\"signature\">link(pid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">link(pid | port) :: true</code></pre>    <p>Creates a link between the calling process and another process (or port) <code class=\"inline\">pid</code>, if there is not such a link already.</p> <p>See <a href=\"http://www.erlang.org/doc/man/erlang.html#link-1\"><code class=\"inline\">:erlang.link/1</code></a> for more info.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"list/0\">  <span class=\"signature\">list()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">list :: [pid]</code></pre>    <p>Returns a list of process identifiers corresponding to all the processes currently existing on the local node.</p> <p>Note that a process that is exiting, exists but is not alive, i.e., <a href=\"#alive?/1\"><code class=\"inline\">alive?/1</code></a> will return <code class=\"inline\">false</code> for a process that is exiting, but its process identifier will be part of the result returned.</p> <p>See <a href=\"http://www.erlang.org/doc/man/erlang.html#processes-0\"><code class=\"inline\">:erlang.processes/0</code></a> for more info.</p>    <h3 class=\"detail-header function\" id=\"monitor/1\">  <span class=\"signature\">monitor(item)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">monitor(pid | {reg_name :: atom, node :: atom} | reg_name :: atom) :: reference</code></pre>    <p>The calling process starts monitoring the given <code class=\"inline\">item</code>. It returns the monitor reference.</p> <p>See <a href=\"http://elixir-lang.org/getting-started/mix-otp/genserver.html#the-need-for-monitoring\">the need for monitoring</a> for an example. See <a href=\"http://www.erlang.org/doc/man/erlang.html#monitor-2\"><code class=\"inline\">:erlang.monitor/2</code></a> for more info.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"put/2\">  <span class=\"signature\">put(key, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put(term, term) :: term | nil</code></pre>    <p>Stores the given <code class=\"inline\">key</code>-<code class=\"inline\">value</code> pair in the process dictionary.</p> <p>The return value is the value that was previously stored under the key <code class=\"inline\">key</code> (or <code class=\"inline\">nil</code> in case no value was stored under <code class=\"inline\">key</code>).</p>    <h3 class=\"detail-header function\" id=\"read_timer/1\">  <span class=\"signature\">read_timer(timer_ref)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">read_timer(reference) :: non_neg_integer | false</code></pre>    <p>Reads a timer created by <a href=\"#send_after/3\"><code class=\"inline\">send_after/3</code></a>.</p> <p>When the result is an integer, it represents the time in milliseconds left until the timer will expire.</p> <p>When the result is <code class=\"inline\">false</code>, a timer corresponding to <code class=\"inline\">timer_ref</code> could not be found. This can be either because the timer expired, already has been canceled, or because <code class=\"inline\">timer_ref</code> never corresponded to a timer.</p> <p>If the timer has expired, the timeout message has been sent, but it does not tell you whether or not it has arrived at its destination yet.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"register/2\">  <span class=\"signature\">register(pid, name)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">register(pid | port, atom) :: true</code></pre>    <p>Associates the atom <code class=\"inline\">name</code> with a <code class=\"inline\">pid</code> or a port identifier.</p> <p><code class=\"inline\">name</code>, can then be used instead of the <code class=\"inline\">pid</code> / port identifier with the <a href=\"kernel#send/2\"><code class=\"inline\">Kernel.send/2</code></a> function. <a href=\"process#register/2\"><code class=\"inline\">Process.register/2</code></a> will fail with <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> if the pid supplied is no longer alive, (check with <a href=\"#alive?/1)\"><code class=\"inline\">alive?/1</code></a> or if the name is already registered (check with <a href=\"#whereis/1)\"><code class=\"inline\">whereis/1</code></a> or if the <code class=\"inline\">pid</code> is already registered to a different <code class=\"inline\">name</code>.</p>    <h3 class=\"detail-header function\" id=\"registered/0\">  <span class=\"signature\">registered()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">registered :: [atom]</code></pre>    <p>Returns a list of names which have been registered using <a href=\"#register/2\"><code class=\"inline\">register/2</code></a>.</p>    <h3 class=\"detail-header function\" id=\"send/3\">  <span class=\"signature\">send(dest, msg, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">send(dest, msg, [option]) ::\n  :ok |\n  :noconnect |\n  :nosuspend when dest: pid | port | atom | {atom, node}, msg: any, option: :noconnect | :nosuspend</code></pre>    <p>Sends a message to the given process.</p> <p>If the option <code class=\"inline\">:noconnect</code> is used and sending the message would require an auto-connection to another node the message is not sent and <code class=\"inline\">:noconnect</code> is returned.</p> <p>If the option <code class=\"inline\">:nosuspend</code> is used and sending the message would cause the sender to be suspended the message is not sent and <code class=\"inline\">:nosuspend</code> is returned.</p> <p>Otherwise the message is sent and <code class=\"inline\">:ok</code> is returned.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Process.send({:name, :node_does_not_exist}, :hi, [:noconnect])\n:noconnect</code></pre>    <h3 class=\"detail-header function\" id=\"send_after/3\">  <span class=\"signature\">send_after(dest, msg, time)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">send_after(pid | atom, term, non_neg_integer) :: reference</code></pre>    <p>Sends <code class=\"inline\">msg</code> to <code class=\"inline\">dest</code> after <code class=\"inline\">time</code> milliseconds.</p> <p>If <code class=\"inline\">dest</code> is a pid, it must be the pid of a local process, dead or alive. If <code class=\"inline\">dest</code> is an atom, it must be the name of a registered process which is looked up at the time of delivery. No error is given if the name does not refer to a process.</p> <p>This function returns a timer reference, which can be read or canceled with <a href=\"#read_timer/1\"><code class=\"inline\">read_timer/1</code></a> and <a href=\"#cancel_timer/1\"><code class=\"inline\">cancel_timer/1</code></a>.</p> <p>Finally, the timer will be automatically canceled if the given <code class=\"inline\">dest</code> is a pid which is not alive or when the given pid exits. Note that timers will not be automatically canceled when <code class=\"inline\">dest</code> is an atom (as the atom resolution is done on delivery).</p>    <h3 class=\"detail-header function\" id=\"sleep/1\">  <span class=\"signature\">sleep(timeout)</span>  </h3>  <p>Sleeps the current process by <code class=\"inline\">timeout</code>.</p> <p><code class=\"inline\">timeout</code> is either the number of milliseconds to sleep as an integer or the atom <code class=\"inline\">:infinity</code>. When <code class=\"inline\">:infinity</code> is given, the current process will suspend forever.</p> <p><strong>Use this function with extreme care</strong>. For almost all situations where you would use <a href=\"#sleep/1\"><code class=\"inline\">sleep/1</code></a> in Elixir, there is likely a more correct, faster and precise way of achieving it with message passing.</p> <p>For example, if you are waiting a process to perform some action, it is better to communicate.</p> <p>In other words, <strong>do not</strong>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Task.start_link fn -&gt;\n  do_something()\n  ...\nend\n\n# Wait until work is done\nProcess.sleep(2000)</code></pre> <p>But <strong>do</strong>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">parent = self()\nTask.start_link fn -&gt;\n  do_something()\n  send parent, :work_is_done\n  ...\nend\n\nreceive do\n  :work_is_done -&gt; :ok\nafter\n  30_000 -&gt; :timeout # Optional timeout\nend</code></pre> <p>Or even use <a href=\"task#async/1\"><code class=\"inline\">Task.async/1</code></a> and <a href=\"task#await/2\"><code class=\"inline\">Task.await/2</code></a> in the example above.</p> <p>Similarly, if you are waiting for a process to terminate, use monitor instead of sleep. <strong>Do not</strong>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Task.start_link fn -&gt;\n  ...\nend\n\n# Wait until task terminates\nProcess.sleep(2000)</code></pre> <p>Instead <strong>do</strong>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:ok, pid} =\n  Task.start_link fn -&gt;\n    ...\n  end\n\nref = Process.monitor(pid)\nreceive do\n  {:DOWN, ^ref, _, _, _} -&gt; :task_is_down\nafter\n  30_000 -&gt; :timeout # Optional timeout\nend</code></pre>    <h3 class=\"detail-header function\" id=\"spawn/2\">  <span class=\"signature\">spawn(fun, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn((() -&gt; any), <a href=\"#t:spawn_opts/0\">spawn_opts</a>) ::\n  pid |\n  {pid, reference}</code></pre>    <p>Spawns the given function according to the given options.</p> <p>The result depends on the given options. In particular, if <code class=\"inline\">:monitor</code> is given as an option, it will return a tuple containing the pid and the monitoring reference, otherwise just the spawned process pid.</p> <p>It also accepts extra options, for the list of available options check <a href=\"http://www.erlang.org/doc/man/erlang.html#spawn_opt-4\"><code class=\"inline\">:erlang.spawn_opt/4</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"spawn/4\">  <span class=\"signature\">spawn(mod, fun, args, opts)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn(module, atom, list, <a href=\"#t:spawn_opts/0\">spawn_opts</a>) ::\n  pid |\n  {pid, reference}</code></pre>    <p>Spawns the given function from module <code class=\"inline\">mod</code>, passing the given <code class=\"inline\">args</code> according to the given options.</p> <p>The result depends on the given options. In particular, if <code class=\"inline\">:monitor</code> is given as an option, it will return a tuple containing the pid and the monitoring reference, otherwise just the spawned process pid.</p> <p>It also accepts extra options, for the list of available options check <a href=\"http://www.erlang.org/doc/man/erlang.html#spawn_opt-4\"><code class=\"inline\">:erlang.spawn_opt/4</code></a>.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"unlink/1\">  <span class=\"signature\">unlink(pid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unlink(pid | port) :: true</code></pre>    <p>Removes the link, if there is one, between the calling process and the process or port referred to by <code class=\"inline\">pid</code>. Returns <code class=\"inline\">true</code> and does not fail, even if there is no link or <code class=\"inline\">id</code> does not exist</p> <p>See <a href=\"http://www.erlang.org/doc/man/erlang.html#unlink-1\"><code class=\"inline\">:erlang.unlink/1</code></a> for more info.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"unregister/1\">  <span class=\"signature\">unregister(name)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unregister(atom) :: true</code></pre>    <p>Removes the registered <code class=\"inline\">name</code>, associated with a pid or a port identifier.</p> <p>Fails with <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> if the name is not registered to any pid or port.</p> <p>See <a href=\"http://www.erlang.org/doc/man/erlang.html#unregister-1\"><code class=\"inline\">:erlang.unregister/1</code></a> for more info.</p>    <h3 class=\"detail-header function\" id=\"whereis/1\">  <span class=\"signature\">whereis(name)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">whereis(atom) :: pid | port | nil</code></pre>    <p>Returns the pid or port identifier with the registered <code class=\"inline\">name</code>. Returns <code class=\"inline\">nil</code> if the name is not registered.</p> <p>See <a href=\"http://www.erlang.org/doc/man/erlang.html#whereis-1\"><code class=\"inline\">:erlang.whereis/1</code></a> for more info.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Process.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Process.html</a>\n  </p>\n</div>\n","elixir/regex":"<h1>  Regex  </h1>  <p>Provides regular expressions for Elixir. Built on top of Erlang’s <code class=\"inline\">:re</code> module.</p> <p>As the <code class=\"inline\">:re</code> module, Regex is based on PCRE (Perl Compatible Regular Expressions). More information can be found in the <a href=\"http://www.erlang.org/doc/man/re.html\"><code class=\"inline\">:re</code> module documentation</a>.</p> <p>Regular expressions in Elixir can be created using <a href=\"regex#compile!/2\"><code class=\"inline\">Regex.compile!/2</code></a> or using the special form with <a href=\"kernel#sigil_r/2\"><code class=\"inline\">~r</code></a> or <a href=\"kernel#sigil_R/2\"><code class=\"inline\">~R</code></a>:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># A simple regular expressions that matches foo anywhere in the string\n~r/foo/\n\n# A regular expression with case insensitive and Unicode options\n~r/foo/iu</code></pre> <p>A Regex is represented internally as the <a href=\"regex#content\"><code class=\"inline\">Regex</code></a> struct. Therefore, <code class=\"inline\">%Regex{}</code> can be used whenever there is a need to match on them.</p> <h2 id=\"module-modifiers\" class=\"section-heading\">  Modifiers </h2> <p>The modifiers available when creating a Regex are:</p> <ul> <li>\n<p><code class=\"inline\">unicode</code> (u) - enables Unicode specific patterns like <code class=\"inline\">\\p</code> and change modifiers like <code class=\"inline\">\\w</code>, <code class=\"inline\">\\W</code>, <code class=\"inline\">\\s</code> and friends to also match on Unicode. It expects valid Unicode strings to be given on match</p> </li> <li>\n<p><code class=\"inline\">caseless</code> (i) - add case insensitivity</p> </li> <li>\n<p><code class=\"inline\">dotall</code> (s) - causes dot to match newlines and also set newline to anycrlf; the new line setting can be overridden by setting <code class=\"inline\">(*CR)</code> or <code class=\"inline\">(*LF)</code> or <code class=\"inline\">(*CRLF)</code> or <code class=\"inline\">(*ANY)</code> according to re documentation</p> </li> <li>\n<p><code class=\"inline\">multiline</code> (m) - causes <code class=\"inline\">^</code> and <code class=\"inline\">$</code> to mark the beginning and end of each line; use <code class=\"inline\">\\A</code> and <code class=\"inline\">\\z</code> to match the end or beginning of the string</p> </li> <li>\n<p><code class=\"inline\">extended</code> (x) - whitespace characters are ignored except when escaped and allow <code class=\"inline\">#</code> to delimit comments</p> </li> <li>\n<p><code class=\"inline\">firstline</code> (f) - forces the unanchored pattern to match before or at the first newline, though the matched text may continue over the newline</p> </li> <li>\n<code class=\"inline\">ungreedy</code> (U) - inverts the “greediness” of the regexp (the previous <code class=\"inline\">r</code> option is deprecated in favor of <code class=\"inline\">U</code>) </li> </ul> <p>The options not available are:</p> <ul> <li>\n<code class=\"inline\">anchored</code> - not available, use <code class=\"inline\">^</code> or <code class=\"inline\">\\A</code> instead </li> <li>\n<code class=\"inline\">dollar_endonly</code> - not available, use <code class=\"inline\">\\z</code> instead </li> <li>\n<code class=\"inline\">no_auto_capture</code> - not available, use <code class=\"inline\">?:</code> instead </li> <li>\n<code class=\"inline\">newline</code> - not available, use <code class=\"inline\">(*CR)</code> or <code class=\"inline\">(*LF)</code> or <code class=\"inline\">(*CRLF)</code> or <code class=\"inline\">(*ANYCRLF)</code> or <code class=\"inline\">(*ANY)</code> at the beginning of the regexp according to the re documentation </li> </ul> <h2 id=\"module-captures\" class=\"section-heading\">  Captures </h2> <p>Many functions in this module handle what to capture in a regex match via the <code class=\"inline\">:capture</code> option. The supported values are:</p> <ul> <li>\n<p><code class=\"inline\">:all</code> - all captured subpatterns including the complete matching string (this is the default)</p> </li> <li>\n<p><code class=\"inline\">:first</code> - only the first captured subpattern, which is always the complete matching part of the string; all explicitly captured subpatterns are discarded</p> </li> <li>\n<p><code class=\"inline\">:all_but_first</code>- all but the first matching subpattern, i.e. all explicitly captured subpatterns, but not the complete matching part of the string</p> </li> <li>\n<p><code class=\"inline\">:none</code> - do not return matching subpatterns at all</p> </li> <li>\n<p><code class=\"inline\">:all_names</code> - captures all names in the Regex</p> </li> <li>\n<code class=\"inline\">list(binary)</code> - a list of named captures to capture </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#compile/2\">compile(source, options \\\\ \"\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compiles the regular expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compile!/2\">compile!(source, options \\\\ \"\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compiles the regular expression according to the given options. Fails with <a href=\"regex.compileerror\"><code class=\"inline\">Regex.CompileError</code></a> if the regex cannot be compiled</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#escape/1\">escape(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Escapes a string to be literally matched in a regex</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#match?/2\">match?(regex, string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a boolean indicating whether there was a match or not</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#named_captures/3\">named_captures(regex, string, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the given captures as a map or <code class=\"inline\">nil</code> if no captures are found. The option <code class=\"inline\">:return</code> can be set to <code class=\"inline\">:index</code> to get indexes back</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#names/1\">names(regex)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of names in the regex</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#opts/1\">opts(regex)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the regex options as a string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#re_pattern/1\">re_pattern(regex)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the underlying <code class=\"inline\">re_pattern</code> in the regular expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#regex?/1\">regex?(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the given <code class=\"inline\">term</code> is a regex. Otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#replace/4\">replace(regex, string, replacement, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a regex, a binary and a replacement, returns a new binary where all matches are replaced by the replacement</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#run/3\">run(regex, string, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Runs the regular expression against the given string until the first match. It returns a list with all captures or <code class=\"inline\">nil</code> if no match occurred</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#scan/3\">scan(regex, string, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#run/3\"><code class=\"inline\">run/3</code></a>, but scans the target several times collecting all matches of the regular expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#source/1\">source(regex)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the regex source as a binary</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#split/3\">split(regex, string, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Splits the given target based on the given pattern and in the given number of parts</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Regex{opts: binary, re_pattern: term, source: binary}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"compile/2\">  <span class=\"signature\">compile(source, options \\\\ \"\")</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">compile(binary, binary | [term]) ::\n  {:ok, <a href=\"#t:t/0\">t</a>} |\n  {:error, any}</code></pre>    <p>Compiles the regular expression.</p> <p>The given options can either be a binary with the characters representing the same regex options given to the <code class=\"inline\">~r</code> sigil, or a list of options, as expected by the Erlang’s <a href=\"http://www.erlang.org/doc/man/re.html\"><code class=\"inline\">:re</code> module</a>.</p> <p>It returns <code class=\"inline\">{:ok, regex}</code> in case of success, <code class=\"inline\">{:error, reason}</code> otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.compile(\"foo\")\n{:ok, ~r\"foo\"}\n\niex&gt; Regex.compile(\"*foo\")\n{:error, {'nothing to repeat', 0}}</code></pre>    <h3 class=\"detail-header function\" id=\"compile!/2\">  <span class=\"signature\">compile!(source, options \\\\ \"\")</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">compile!(binary, binary | [term]) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Compiles the regular expression according to the given options. Fails with <a href=\"regex.compileerror\"><code class=\"inline\">Regex.CompileError</code></a> if the regex cannot be compiled.</p>    <h3 class=\"detail-header function\" id=\"escape/1\">  <span class=\"signature\">escape(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">escape(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Escapes a string to be literally matched in a regex.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.escape(\".\")\n\"\\\\.\"\n\niex&gt; Regex.escape(\"\\\\what if\")\n\"\\\\\\\\what\\\\ if\"</code></pre>    <h3 class=\"detail-header function\" id=\"match?/2\">  <span class=\"signature\">match?(regex, string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">match?(<a href=\"#t:t/0\">t</a>, <a href=\"string#t:t/0\">String.t</a>) :: boolean</code></pre>    <p>Returns a boolean indicating whether there was a match or not.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.match?(~r/foo/, \"foo\")\ntrue\n\niex&gt; Regex.match?(~r/foo/, \"bar\")\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"named_captures/3\">  <span class=\"signature\">named_captures(regex, string, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">named_captures(<a href=\"#t:t/0\">t</a>, <a href=\"string#t:t/0\">String.t</a>, [term]) :: map | nil</code></pre>    <p>Returns the given captures as a map or <code class=\"inline\">nil</code> if no captures are found. The option <code class=\"inline\">:return</code> can be set to <code class=\"inline\">:index</code> to get indexes back.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.named_captures(~r/c(?&lt;foo&gt;d)/, \"abcd\")\n%{\"foo\" =&gt; \"d\"}\n\niex&gt; Regex.named_captures(~r/a(?&lt;foo&gt;b)c(?&lt;bar&gt;d)/, \"abcd\")\n%{\"bar\" =&gt; \"d\", \"foo\" =&gt; \"b\"}\n\niex&gt; Regex.named_captures(~r/a(?&lt;foo&gt;b)c(?&lt;bar&gt;d)/, \"efgh\")\nnil</code></pre>    <h3 class=\"detail-header function\" id=\"names/1\">  <span class=\"signature\">names(regex)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">names(<a href=\"#t:t/0\">t</a>) :: [<a href=\"string#t:t/0\">String.t</a>]</code></pre>    <p>Returns a list of names in the regex.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.names(~r/(?&lt;foo&gt;bar)/)\n[\"foo\"]</code></pre>    <h3 class=\"detail-header function\" id=\"opts/1\">  <span class=\"signature\">opts(regex)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">opts(<a href=\"#t:t/0\">t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Returns the regex options as a string.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.opts(~r(foo)m)\n\"m\"</code></pre>    <h3 class=\"detail-header function\" id=\"re_pattern/1\">  <span class=\"signature\">re_pattern(regex)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">re_pattern(<a href=\"#t:t/0\">t</a>) :: term</code></pre>    <p>Returns the underlying <code class=\"inline\">re_pattern</code> in the regular expression.</p>    <h3 class=\"detail-header function\" id=\"regex?/1\">  <span class=\"signature\">regex?(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">regex?(any) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if the given <code class=\"inline\">term</code> is a regex. Otherwise returns <code class=\"inline\">false</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.regex?(~r/foo/)\ntrue\n\niex&gt; Regex.regex?(0)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"replace/4\">  <span class=\"signature\">replace(regex, string, replacement, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">replace(<a href=\"#t:t/0\">t</a>, <a href=\"string#t:t/0\">String.t</a>, <a href=\"string#t:t/0\">String.t</a> | (... -&gt; <a href=\"string#t:t/0\">String.t</a>), [term]) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Receives a regex, a binary and a replacement, returns a new binary where all matches are replaced by the replacement.</p> <p>The replacement can be either a string or a function. The string is used as a replacement for every match and it allows specific captures to be accessed via <code class=\"inline\">\\\\N</code> or <code class=\"inline\">\\g{N}</code>, where <code class=\"inline\">N</code> is the capture. In case <code class=\"inline\">\\\\0</code> is used, the whole match is inserted.</p> <p>When the replacement is a function, the function may have arity N where each argument maps to a capture, with the first argument being the whole match. If the function expects more arguments than captures found, the remaining arguments will receive <code class=\"inline\">\"\"</code>.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:global</code> - when <code class=\"inline\">false</code>, replaces only the first occurrence (defaults to <code class=\"inline\">true</code>) </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.replace(~r/d/, \"abc\", \"d\")\n\"abc\"\n\niex&gt; Regex.replace(~r/b/, \"abc\", \"d\")\n\"adc\"\n\niex&gt; Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n\"a[b]c\"\n\niex&gt; Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n\"[b][d]\"\n\niex&gt; Regex.replace(~r/\\.(\\d)$/, \"500.5\", \".\\\\g{1}0\")\n\"500.50\"\n\niex&gt; Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -&gt; \"[#{x}]\" end)\n\"[b][d]\"\n\niex&gt; Regex.replace(~r/a/, \"abcadc\", \"A\", global: false)\n\"Abcadc\"</code></pre>    <h3 class=\"detail-header function\" id=\"run/3\">  <span class=\"signature\">run(regex, string, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">run(<a href=\"#t:t/0\">t</a>, binary, [term]) ::\n  nil |\n  [binary] |\n  [{integer, integer}]</code></pre>    <p>Runs the regular expression against the given string until the first match. It returns a list with all captures or <code class=\"inline\">nil</code> if no match occurred.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:return</code> - set to <code class=\"inline\">:index</code> to return indexes. Defaults to <code class=\"inline\">:binary</code>. </li> <li>\n<code class=\"inline\">:capture</code> - what to capture in the result. Check the moduledoc for <a href=\"regex#content\"><code class=\"inline\">Regex</code></a> to see the possible capture values. </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.run(~r/c(d)/, \"abcd\")\n[\"cd\", \"d\"]\n\niex&gt; Regex.run(~r/e/, \"abcd\")\nnil\n\niex&gt; Regex.run(~r/c(d)/, \"abcd\", return: :index)\n[{2, 2}, {3, 1}]</code></pre>    <h3 class=\"detail-header function\" id=\"scan/3\">  <span class=\"signature\">scan(regex, string, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">scan(<a href=\"#t:t/0\">t</a>, <a href=\"string#t:t/0\">String.t</a>, [term]) :: [[<a href=\"string#t:t/0\">String.t</a>]]</code></pre>    <p>Same as <a href=\"#run/3\"><code class=\"inline\">run/3</code></a>, but scans the target several times collecting all matches of the regular expression.</p> <p>A list of lists is returned, where each entry in the primary list represents a match and each entry in the secondary list represents the captured contents.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:return</code> - set to <code class=\"inline\">:index</code> to return indexes. Defaults to <code class=\"inline\">:binary</code>. </li> <li>\n<code class=\"inline\">:capture</code> - what to capture in the result. Check the moduledoc for <a href=\"regex#content\"><code class=\"inline\">Regex</code></a> to see the possible capture values. </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.scan(~r/c(d|e)/, \"abcd abce\")\n[[\"cd\", \"d\"], [\"ce\", \"e\"]]\n\niex&gt; Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n[[\"cd\"], [\"ce\"]]\n\niex&gt; Regex.scan(~r/e/, \"abcd\")\n[]</code></pre>    <h3 class=\"detail-header function\" id=\"source/1\">  <span class=\"signature\">source(regex)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">source(<a href=\"#t:t/0\">t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Returns the regex source as a binary.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.source(~r(foo))\n\"foo\"</code></pre>    <h3 class=\"detail-header function\" id=\"split/3\">  <span class=\"signature\">split(regex, string, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">split(<a href=\"#t:t/0\">t</a>, <a href=\"string#t:t/0\">String.t</a>, [term]) :: [<a href=\"string#t:t/0\">String.t</a>]</code></pre>    <p>Splits the given target based on the given pattern and in the given number of parts.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:parts</code> - when specified, splits the string into the given number of parts. If not specified, <code class=\"inline\">:parts</code> defaults to <code class=\"inline\">:infinity</code>, which will split the string into the maximum number of parts possible based on the given pattern.</p> </li> <li>\n<p><code class=\"inline\">:trim</code> - when <code class=\"inline\">true</code>, removes empty strings (<code class=\"inline\">\"\"</code>) from the result.</p> </li> <li>\n<p><code class=\"inline\">:on</code> - specifies which captures to split the string on, and in what order. Defaults to <code class=\"inline\">:first</code> which means captures inside the regex do not affect the splitting process.</p> </li> <li>\n<code class=\"inline\">:include_captures</code> - when <code class=\"inline\">true</code>, includes in the result the matches of the regular expression. Defaults to <code class=\"inline\">false</code>. </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.split(~r/-/, \"a-b-c\")\n[\"a\", \"b\", \"c\"]\n\niex&gt; Regex.split(~r/-/, \"a-b-c\", [parts: 2])\n[\"a\", \"b-c\"]\n\niex&gt; Regex.split(~r/-/, \"abc\")\n[\"abc\"]\n\niex&gt; Regex.split(~r//, \"abc\")\n[\"a\", \"b\", \"c\", \"\"]\n\niex&gt; Regex.split(~r/a(?&lt;second&gt;b)c/, \"abc\")\n[\"\", \"\"]\n\niex&gt; Regex.split(~r/a(?&lt;second&gt;b)c/, \"abc\", on: [:second])\n[\"a\", \"c\"]\n\niex&gt; Regex.split(~r/(x)/, \"Elixir\", include_captures: true)\n[\"Eli\", \"x\", \"ir\"]\n\niex&gt; Regex.split(~r/a(?&lt;second&gt;b)c/, \"abc\", on: [:second], include_captures: true)\n[\"a\", \"b\", \"c\"]</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Regex.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Regex.html</a>\n  </p>\n</div>\n","elixir/supervisor.spec":"<h1>  Supervisor.Spec  </h1>  <p>Convenience functions for defining supervisor specifications.</p> <h2 id=\"module-example\" class=\"section-heading\">  Example </h2> <p>By using the functions in this module one can specify the children to be used under a supervisor, started with <a href=\"supervisor#start_link/2\"><code class=\"inline\">Supervisor.start_link/2</code></a>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import Supervisor.Spec\n\nchildren = [\n  worker(MyWorker, [arg1, arg2, arg3]),\n  supervisor(MySupervisor, [arg1])\n]\n\nSupervisor.start_link(children, strategy: :one_for_one)</code></pre> <p>Sometimes, it may be handy to define supervisors backed by a module:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MySupervisor do\n  use Supervisor\n\n  def start_link(arg) do\n    Supervisor.start_link(__MODULE__, arg)\n  end\n\n  def init(arg) do\n    children = [\n      worker(MyWorker, [arg], restart: :temporary)\n    ]\n\n    supervise(children, strategy: :simple_one_for_one)\n  end\nend</code></pre> <p>Notice in this case we don’t have to explicitly import <a href=\"supervisor.spec#content\"><code class=\"inline\">Supervisor.Spec</code></a> as <code class=\"inline\">use Supervisor</code> automatically does so. Defining a module-based supervisor can be useful, for example, to perform initialization tasks in the <code class=\"inline\">init/1</code> callback.</p> <h2 id=\"module-supervisor-and-worker-options\" class=\"section-heading\">  Supervisor and worker options </h2> <p>In the example above, we defined specs for workers and supervisors. These specs (both for workers as well as supervisors) accept the following options:</p> <ul> <li>\n<p><code class=\"inline\">:id</code> - a name used to identify the child specification internally by the supervisor; defaults to the given module name for the child worker/supervisor</p> </li> <li>\n<p><code class=\"inline\">:function</code> - the function to invoke on the child to start it</p> </li> <li>\n<p><code class=\"inline\">:restart</code> - an atom that defines when a terminated child process should be restarted (see the “Restart values” section below)</p> </li> <li>\n<p><code class=\"inline\">:shutdown</code> - an atom that defines how a child process should be terminated (see the “Shutdown values” section below)</p> </li> <li>\n<code class=\"inline\">:modules</code> - it should be a list with one element <code class=\"inline\">[module]</code>, where module is the name of the callback module only if the child process is a <a href=\"supervisor\"><code class=\"inline\">Supervisor</code></a> or <a href=\"genserver\"><code class=\"inline\">GenServer</code></a>; if the child process is a <a href=\"genevent\"><code class=\"inline\">GenEvent</code></a>, <code class=\"inline\">:modules</code> should be <code class=\"inline\">:dynamic</code> </li> </ul> <h3>Restart values (:restart)</h3> <p>The following restart values are supported in the <code class=\"inline\">:restart</code> option:</p> <ul> <li>\n<p><code class=\"inline\">:permanent</code> - the child process is always restarted</p> </li> <li>\n<p><code class=\"inline\">:temporary</code> - the child process is never restarted (not even when the supervisor’s strategy is <code class=\"inline\">:rest_for_one</code> or <code class=\"inline\">:one_for_all</code>)</p> </li> <li>\n<code class=\"inline\">:transient</code> - the child process is restarted only if it terminates abnormally, i.e., with an exit reason other than <code class=\"inline\">:normal</code>, <code class=\"inline\">:shutdown</code> or <code class=\"inline\">{:shutdown, term}</code> </li> </ul> <h3>Shutdown values (:shutdown)</h3> <p>The following shutdown values are supported in the <code class=\"inline\">:shutdown</code> option:</p> <ul> <li>\n<p><code class=\"inline\">:brutal_kill</code> - the child process is unconditionally terminated using <code class=\"inline\">exit(child, :kill)</code></p> </li> <li>\n<p><code class=\"inline\">:infinity</code> - if the child process is a supervisor, this is a mechanism to give the subtree enough time to shutdown; it can also be used with workers with care</p> </li> <li>any integer - the value of <code class=\"inline\">:shutdown</code> can also be any integer meaning that the supervisor tells the child process to terminate by calling <code class=\"inline\">Process.exit(child, :shutdown)</code> and then waits for an exit signal back. If no exit signal is received within the specified time (the value of this option, in milliseconds), the child process is unconditionally terminated using <code class=\"inline\">Process.exit(child, :kill)</code> </li> </ul>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:child_id/0\">child_id()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Supported id values</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:modules/0\">modules()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Supported module values</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:restart/0\">restart()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Supported restart values</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:shutdown/0\">shutdown()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Supported shutdown values</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:spec/0\">spec()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The supervisor specification</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:strategy/0\">strategy()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Supported strategies</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:worker/0\">worker()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Supported worker values</p> </dd>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#supervise/2\">supervise(children, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a list of children (workers or supervisors) to supervise and a set of options</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#supervisor/3\">supervisor(module, args, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines the given <code class=\"inline\">module</code> as a supervisor which will be started with the given arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#worker/3\">worker(module, args, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines the given <code class=\"inline\">module</code> as a worker which will be started with the given arguments</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:child_id/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:child_id/0\">child_id</a> :: term</code></pre> <p>Supported id values</p>  </div> <div id=\"t:modules/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:modules/0\">modules</a> :: :dynamic | [module]</code></pre> <p>Supported module values</p>  </div> <div id=\"t:restart/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:restart/0\">restart</a> :: :permanent | :transient | :temporary</code></pre> <p>Supported restart values</p>  </div> <div id=\"t:shutdown/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:shutdown/0\">shutdown</a> :: :brutal_kill | :infinity | non_neg_integer</code></pre> <p>Supported shutdown values</p>  </div> <div id=\"t:spec/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:spec/0\">spec</a> :: {<a href=\"#t:child_id/0\">child_id</a>, start_fun :: {module, atom, [term]}, <a href=\"#t:restart/0\">restart</a>, <a href=\"#t:shutdown/0\">shutdown</a>, <a href=\"#t:worker/0\">worker</a>, <a href=\"#t:modules/0\">modules</a>}</code></pre> <p>The supervisor specification</p>  </div> <div id=\"t:strategy/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:strategy/0\">strategy</a> ::\n  :simple_one_for_one |\n  :one_for_one |\n  :one_for_all |\n  :rest_for_one</code></pre> <p>Supported strategies</p>  </div> <div id=\"t:worker/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:worker/0\">worker</a> :: :worker | :supervisor</code></pre> <p>Supported worker values</p>  </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"supervise/2\">  <span class=\"signature\">supervise(children, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">supervise([<a href=\"#t:spec/0\">spec</a>], strategy: <a href=\"#t:strategy/0\">strategy</a>, max_restarts: non_neg_integer, max_seconds: non_neg_integer) :: {:ok, tuple}</code></pre>    <p>Receives a list of children (workers or supervisors) to supervise and a set of options.</p> <p>Returns a tuple containing the supervisor specification. This tuple can be used as the return value of the <code class=\"inline\">init/1</code> callback when implementing a module-based supervisor.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">supervise(children, strategy: :one_for_one)</code></pre> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:strategy</code> - the restart strategy option. It can be either <code class=\"inline\">:one_for_one</code>, <code class=\"inline\">:rest_for_one</code>, <code class=\"inline\">:one_for_all</code>, or <code class=\"inline\">:simple_one_for_one</code>. You can learn more about strategies in the <a href=\"supervisor\"><code class=\"inline\">Supervisor</code></a> module docs.</p> </li> <li>\n<p><code class=\"inline\">:max_restarts</code> - the maximum amount of restarts allowed in a time frame. Defaults to <code class=\"inline\">3</code>.</p> </li> <li>\n<code class=\"inline\">:max_seconds</code> - the time frame in which <code class=\"inline\">:max_restarts</code> applies. Defaults to <code class=\"inline\">5</code>. </li> </ul> <p>The <code class=\"inline\">:strategy</code> option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the <a href=\"supervisor\"><code class=\"inline\">Supervisor</code></a> module for a detailed description of the available strategies.</p>    <h3 class=\"detail-header function\" id=\"supervisor/3\">  <span class=\"signature\">supervisor(module, args, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">supervisor(module, [term], restart: <a href=\"#t:restart/0\">restart</a>, shutdown: <a href=\"#t:shutdown/0\">shutdown</a>, id: term, function: atom, modules: <a href=\"#t:modules/0\">modules</a>) :: <a href=\"#t:spec/0\">spec</a></code></pre>    <p>Defines the given <code class=\"inline\">module</code> as a supervisor which will be started with the given arguments.</p> <pre data-language=\"elixir\"><code class=\"elixir\">supervisor(ExUnit.Runner, [], restart: :permanent)</code></pre> <p>By default, the function <code class=\"inline\">start_link</code> is invoked on the given module. Overall, the default values for the options are:</p> <pre data-language=\"elixir\"><code class=\"elixir\">[id: module,\n function: :start_link,\n restart: :permanent,\n shutdown: :infinity,\n modules: [module]]</code></pre> <p>Check the documentation for the <a href=\"supervisor.spec#content\"><code class=\"inline\">Supervisor.Spec</code></a> module for more information on the options.</p>    <h3 class=\"detail-header function\" id=\"worker/3\">  <span class=\"signature\">worker(module, args, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">worker(module, [term], restart: <a href=\"#t:restart/0\">restart</a>, shutdown: <a href=\"#t:shutdown/0\">shutdown</a>, id: term, function: atom, modules: <a href=\"#t:modules/0\">modules</a>) :: <a href=\"#t:spec/0\">spec</a></code></pre>    <p>Defines the given <code class=\"inline\">module</code> as a worker which will be started with the given arguments.</p> <pre data-language=\"elixir\"><code class=\"elixir\">worker(ExUnit.Runner, [], restart: :permanent)</code></pre> <p>By default, the function <code class=\"inline\">start_link</code> is invoked on the given module. Overall, the default values for the options are:</p> <pre data-language=\"elixir\"><code class=\"elixir\">[id: module,\n function: :start_link,\n restart: :permanent,\n shutdown: 5000,\n modules: [module]]</code></pre> <p>Check the documentation for the <a href=\"supervisor.spec#content\"><code class=\"inline\">Supervisor.Spec</code></a> module for more information on the options.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Supervisor.Spec.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Supervisor.Spec.html</a>\n  </p>\n</div>\n","elixir/task.supervisor":"<h1>  Task.Supervisor  </h1>  <p>A task supervisor.</p> <p>This module defines a supervisor which can be used to dynamically supervise tasks. Behind the scenes, this module is implemented as a <code class=\"inline\">:simple_one_for_one</code> supervisor where the workers are temporary (i.e. they are not restarted after they die).</p> <p>See the <a href=\"task\"><code class=\"inline\">Task</code></a> module for more information.</p> <h2 id=\"module-name-registration\" class=\"section-heading\">  Name Registration </h2> <p>A <a href=\"task.supervisor#content\"><code class=\"inline\">Task.Supervisor</code></a> is bound to the same name registration rules as a <a href=\"genserver\"><code class=\"inline\">GenServer</code></a>. Read more about them in the <a href=\"genserver\"><code class=\"inline\">GenServer</code></a> docs.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#async/2\">async(supervisor, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a task that can be awaited on</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#async/4\">async(supervisor, module, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a task that can be awaited on</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#async_nolink/2\">async_nolink(supervisor, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a task that can be awaited on</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#async_nolink/4\">async_nolink(supervisor, module, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a task that can be awaited on</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#children/1\">children(supervisor)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all children pids</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_child/2\">start_child(supervisor, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a task as a child of the given <code class=\"inline\">supervisor</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_child/4\">start_child(supervisor, module, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a task as a child of the given <code class=\"inline\">supervisor</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/1\">start_link(opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a new supervisor</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#terminate_child/2\">terminate_child(supervisor, pid)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Terminates the child with the given <code class=\"inline\">pid</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"async/2\">  <span class=\"signature\">async(supervisor, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">async(<a href=\"supervisor#t:supervisor/0\">Supervisor.supervisor</a>, (... -&gt; any)) :: <a href=\"task#t:t/0\">Task.t</a></code></pre>    <p>Starts a task that can be awaited on.</p> <p>The <code class=\"inline\">supervisor</code> must be a reference as defined in <a href=\"task.supervisor#content\"><code class=\"inline\">Task.Supervisor</code></a>. The task will still be linked to the caller, see <a href=\"task#async/3\"><code class=\"inline\">Task.async/3</code></a> for more information and <a href=\"#async_nolink/2\"><code class=\"inline\">async_nolink/2</code></a> for a non-linked variant.</p>    <h3 class=\"detail-header function\" id=\"async/4\">  <span class=\"signature\">async(supervisor, module, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">async(<a href=\"supervisor#t:supervisor/0\">Supervisor.supervisor</a>, module, atom, [term]) :: <a href=\"task#t:t/0\">Task.t</a></code></pre>    <p>Starts a task that can be awaited on.</p> <p>The <code class=\"inline\">supervisor</code> must be a reference as defined in <a href=\"task.supervisor#content\"><code class=\"inline\">Task.Supervisor</code></a>. The task will still be linked to the caller, see <a href=\"task#async/3\"><code class=\"inline\">Task.async/3</code></a> for more information and <a href=\"#async_nolink/2\"><code class=\"inline\">async_nolink/2</code></a> for a non-linked variant.</p>    <h3 class=\"detail-header function\" id=\"async_nolink/2\">  <span class=\"signature\">async_nolink(supervisor, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">async_nolink(<a href=\"supervisor#t:supervisor/0\">Supervisor.supervisor</a>, (... -&gt; any)) :: <a href=\"task#t:t/0\">Task.t</a></code></pre>    <p>Starts a task that can be awaited on.</p> <p>The <code class=\"inline\">supervisor</code> must be a reference as defined in <a href=\"task.supervisor#content\"><code class=\"inline\">Task.Supervisor</code></a>. The task won’t be linked to the caller, see <a href=\"task#async/3\"><code class=\"inline\">Task.async/3</code></a> for more information.</p> <h4>Compatibility with OTP behaviours</h4> <p>If you create a task using <code class=\"inline\">async_nolink</code> inside an OTP behaviour like <a href=\"genserver\"><code class=\"inline\">GenServer</code></a>, you should match on the message coming from the task inside your <code class=\"inline\">handle_info</code> callback.</p> <p>The reply sent by the task will be in the format <code class=\"inline\">{ref, result}</code>, where <code class=\"inline\">ref</code> is the monitor reference held by the task struct and <code class=\"inline\">result</code> is the return value of the task function.</p> <p>Keep in mind that, regardless of how the task created with <code class=\"inline\">async_nolink</code> terminates, the caller’s process will always receive a <code class=\"inline\">:DOWN</code> message with the same <code class=\"inline\">ref</code> value that is held by the task struct. If the task terminates normally, the reason in the <code class=\"inline\">:DOWN</code> message will be <code class=\"inline\">:normal</code>.</p>    <h3 class=\"detail-header function\" id=\"async_nolink/4\">  <span class=\"signature\">async_nolink(supervisor, module, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">async_nolink(<a href=\"supervisor#t:supervisor/0\">Supervisor.supervisor</a>, module, atom, [term]) :: <a href=\"task#t:t/0\">Task.t</a></code></pre>    <p>Starts a task that can be awaited on.</p> <p>The <code class=\"inline\">supervisor</code> must be a reference as defined in <a href=\"task.supervisor#content\"><code class=\"inline\">Task.Supervisor</code></a>. The task won’t be linked to the caller, see <a href=\"task#async/3\"><code class=\"inline\">Task.async/3</code></a> for more information.</p>    <h3 class=\"detail-header function\" id=\"children/1\">  <span class=\"signature\">children(supervisor)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">children(<a href=\"supervisor#t:supervisor/0\">Supervisor.supervisor</a>) :: [pid]</code></pre>    <p>Returns all children pids.</p>    <h3 class=\"detail-header function\" id=\"start_child/2\">  <span class=\"signature\">start_child(supervisor, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_child(<a href=\"supervisor#t:supervisor/0\">Supervisor.supervisor</a>, (... -&gt; any)) :: {:ok, pid}</code></pre>    <p>Starts a task as a child of the given <code class=\"inline\">supervisor</code>.</p> <p>Note that the spawned process is not linked to the caller, but only to the supervisor. This command is useful in case the task needs to perform side-effects (like I/O) and does not need to report back to the caller.</p>    <h3 class=\"detail-header function\" id=\"start_child/4\">  <span class=\"signature\">start_child(supervisor, module, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_child(<a href=\"supervisor#t:supervisor/0\">Supervisor.supervisor</a>, module, atom, [term]) :: {:ok, pid}</code></pre>    <p>Starts a task as a child of the given <code class=\"inline\">supervisor</code>.</p> <p>Similar to <a href=\"#start_child/2\"><code class=\"inline\">start_child/2</code></a> except the task is specified by the given <code class=\"inline\">module</code>, <code class=\"inline\">fun</code> and <code class=\"inline\">args</code>.</p>    <h3 class=\"detail-header function\" id=\"start_link/1\">  <span class=\"signature\">start_link(opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_link(<a href=\"supervisor#t:options/0\">Supervisor.options</a>) :: <a href=\"supervisor#t:on_start/0\">Supervisor.on_start</a></code></pre>    <p>Starts a new supervisor.</p> <p>The supported options are:</p> <ul> <li>\n<p><code class=\"inline\">:name</code> - used to register a supervisor name, the supported values are described under the <code class=\"inline\">Name Registration</code> section in the <a href=\"genserver\"><code class=\"inline\">GenServer</code></a> module docs;</p> </li> <li>\n<p><code class=\"inline\">:restart</code> - the restart strategy, may be <code class=\"inline\">:temporary</code> (the default), <code class=\"inline\">:transient</code> or <code class=\"inline\">:permanent</code>. Check <a href=\"supervisor.spec\"><code class=\"inline\">Supervisor.Spec</code></a> for more info. Defaults to <code class=\"inline\">:temporary</code> so tasks aren’t automatically restarted when they complete nor in case of crashes;</p> </li> <li>\n<p><code class=\"inline\">:shutdown</code> - <code class=\"inline\">:brutal_kill</code> if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds;</p> </li> <li>\n<code class=\"inline\">:max_restarts</code> and <code class=\"inline\">:max_seconds</code> - as specified in <a href=\"supervisor.spec#supervise/2\"><code class=\"inline\">Supervisor.Spec.supervise/2</code></a>; </li> </ul>    <h3 class=\"detail-header function\" id=\"terminate_child/2\">  <span class=\"signature\">terminate_child(supervisor, pid)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">terminate_child(<a href=\"supervisor#t:supervisor/0\">Supervisor.supervisor</a>, pid) :: :ok</code></pre>    <p>Terminates the child with the given <code class=\"inline\">pid</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Task.Supervisor.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Task.Supervisor.html</a>\n  </p>\n</div>\n","elixir/time":"<h1>  Time  </h1>  <p>A Time struct and functions.</p> <p>The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the <a href=\"#new/4\"><code class=\"inline\">new/4</code></a> function or using the <code class=\"inline\">~T</code> sigil:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~T[23:00:07.001]\n~T[23:00:07.001]</code></pre> <p>Both <a href=\"#new/4\"><code class=\"inline\">new/4</code></a> and sigil return a struct where the time fields can be accessed directly:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; time = ~T[23:00:07.001]\niex&gt; time.hour\n23\niex&gt; time.microsecond\n{1000, 3}</code></pre> <p>Developers should avoid creating the Time struct directly and instead rely on the functions provided by this module as well as the ones in 3rd party calendar libraries.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#from_erl/2\">from_erl(arg, microsecond \\\\ {0, 0})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an Erlang time tuple to a <a href=\"time#content\"><code class=\"inline\">Time</code></a> struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_erl!/2\">from_erl!(tuple, microsecond \\\\ {0, 0})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts an Erlang time tuple to a <a href=\"time#content\"><code class=\"inline\">Time</code></a> struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_iso8601/1\">from_iso8601(arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses the extended “Local time” format described by ISO8601:2004</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#from_iso8601!/1\">from_iso8601!(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses the extended “Local time” format described by ISO8601:2004</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#new/4\">new(hour, minute, second, microsecond \\\\ {0, 0})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Builds a new time</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_erl/1\">to_erl(time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a <a href=\"time#content\"><code class=\"inline\">Time</code></a> struct to an Erlang time tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_iso8601/1\">to_iso8601(time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given time to ISO8601</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(time)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the given time to a string</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Time{hour: <a href=\"calendar#t:hour/0\">Calendar.hour</a>, microsecond: <a href=\"calendar#t:microsecond/0\">Calendar.microsecond</a>, minute: <a href=\"calendar#t:minute/0\">Calendar.minute</a>, second: <a href=\"calendar#t:second/0\">Calendar.second</a>}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"from_erl/2\">  <span class=\"signature\">from_erl(arg, microsecond \\\\ {0, 0})</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_erl(:calendar.time, <a href=\"calendar#t:microsecond/0\">Calendar.microsecond</a>) ::\n  {:ok, <a href=\"time#t:t/0\">Time.t</a>} |\n  {:error, atom}</code></pre>    <p>Converts an Erlang time tuple to a <a href=\"time#content\"><code class=\"inline\">Time</code></a> struct.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Time.from_erl({23, 30, 15}, {5000, 3})\n{:ok, ~T[23:30:15.005]}\niex&gt; Time.from_erl({24, 30, 15})\n{:error, :invalid_time}</code></pre>    <h3 class=\"detail-header function\" id=\"from_erl!/2\">  <span class=\"signature\">from_erl!(tuple, microsecond \\\\ {0, 0})</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_erl!(:calendar.time, <a href=\"calendar#t:microsecond/0\">Calendar.microsecond</a>) ::\n  <a href=\"time#t:t/0\">Time.t</a> |\n  no_return</code></pre>    <p>Converts an Erlang time tuple to a <a href=\"time#content\"><code class=\"inline\">Time</code></a> struct.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Time.from_erl!({23, 30, 15})\n~T[23:30:15]\niex&gt; Time.from_erl!({23, 30, 15}, {5000, 3})\n~T[23:30:15.005]\niex&gt; Time.from_erl!({24, 30, 15})\n** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time</code></pre>    <h3 class=\"detail-header function\" id=\"from_iso8601/1\">  <span class=\"signature\">from_iso8601(arg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_iso8601(<a href=\"string#t:t/0\">String.t</a>) ::\n  {:ok, <a href=\"time#t:t/0\">Time.t</a>} |\n  {:error, atom}</code></pre>    <p>Parses the extended “Local time” format described by ISO8601:2004.</p> <p>Timezone offset may be included in the string but they will be simply discarded as such information is not included in times.</p> <p>As specified in the standard, the separator “T” may be omitted if desired as there is no ambiguity within this function.</p> <p>Time representations with reduced accuracy are not supported.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Time.from_iso8601(\"23:50:07\")\n{:ok, ~T[23:50:07]}\niex&gt; Time.from_iso8601(\"23:50:07Z\")\n{:ok, ~T[23:50:07]}\niex&gt; Time.from_iso8601(\"T23:50:07Z\")\n{:ok, ~T[23:50:07]}\n\niex&gt; Time.from_iso8601(\"23:50:07.0123456\")\n{:ok, ~T[23:50:07.012345]}\niex&gt; Time.from_iso8601(\"23:50:07.123Z\")\n{:ok, ~T[23:50:07.123]}\n\niex&gt; Time.from_iso8601(\"2015:01:23 23-50-07\")\n{:error, :invalid_format}\niex&gt; Time.from_iso8601(\"23:50:07A\")\n{:error, :invalid_format}\niex&gt; Time.from_iso8601(\"23:50:07.\")\n{:error, :invalid_format}\niex&gt; Time.from_iso8601(\"23:50:61\")\n{:error, :invalid_time}</code></pre>    <h3 class=\"detail-header function\" id=\"from_iso8601!/1\">  <span class=\"signature\">from_iso8601!(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">from_iso8601!(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"time#t:t/0\">Time.t</a> | no_return</code></pre>    <p>Parses the extended “Local time” format described by ISO8601:2004.</p> <p>Raises if the format is invalid.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Time.from_iso8601!(\"23:50:07.123Z\")\n~T[23:50:07.123]\niex&gt; Time.from_iso8601!(\"2015:01:23 23-50-07\")\n** (ArgumentError) cannot parse \"2015:01:23 23-50-07\" as time, reason: :invalid_format</code></pre>    <h3 class=\"detail-header function\" id=\"new/4\">  <span class=\"signature\">new(hour, minute, second, microsecond \\\\ {0, 0})</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">new(<a href=\"calendar#t:hour/0\">Calendar.hour</a>, <a href=\"calendar#t:minute/0\">Calendar.minute</a>, <a href=\"calendar#t:second/0\">Calendar.second</a>, <a href=\"calendar#t:microsecond/0\">Calendar.microsecond</a>) ::\n  {:ok, <a href=\"time#t:t/0\">Time.t</a>} |\n  {:error, atom}</code></pre>    <p>Builds a new time.</p> <p>Expects all values to be integers. Returns <code class=\"inline\">{:ok, time}</code> if each entry fits its appropriate range, returns <code class=\"inline\">{:error, reason}</code> otherwise.</p> <p>Note a time may have 60 seconds in case of leap seconds.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Time.new(0, 0, 0, 0)\n{:ok, ~T[00:00:00.000000]}\niex&gt; Time.new(23, 59, 59, 999_999)\n{:ok, ~T[23:59:59.999999]}\niex&gt; Time.new(23, 59, 60, 999_999)\n{:ok, ~T[23:59:60.999999]}\n\n# Time with microseconds and their precision\niex&gt; Time.new(23, 59, 60, {10_000, 2})\n{:ok, ~T[23:59:60.01]}\n\niex&gt; Time.new(24, 59, 59, 999_999)\n{:error, :invalid_time}\niex&gt; Time.new(23, 60, 59, 999_999)\n{:error, :invalid_time}\niex&gt; Time.new(23, 59, 61, 999_999)\n{:error, :invalid_time}\niex&gt; Time.new(23, 59, 59, 1_000_000)\n{:error, :invalid_time}</code></pre>    <h3 class=\"detail-header function\" id=\"to_erl/1\">  <span class=\"signature\">to_erl(time)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_erl(<a href=\"time#t:t/0\">Time.t</a>) :: :calendar.time</code></pre>    <p>Converts a <a href=\"time#content\"><code class=\"inline\">Time</code></a> struct to an Erlang time tuple.</p> <p>WARNING: Loss of precision may occur, as Erlang time tuples only contain hours/minutes/seconds.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Time.to_erl(~T[23:30:15.999])\n{23, 30, 15}</code></pre>    <h3 class=\"detail-header function\" id=\"to_iso8601/1\">  <span class=\"signature\">to_iso8601(time)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_iso8601(<a href=\"time#t:t/0\">Time.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts the given time to ISO8601.</p> <h3>Examples</h3> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Time.to_iso8601(~T[23:00:13])\n\"23:00:13\"\n\niex&gt; Time.to_iso8601(~T[23:00:13.001])\n\"23:00:13.001\"</code></pre>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(time)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_string(<a href=\"time#t:t/0\">Time.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Converts the given time to a string.</p> <h3>Examples</h3> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Time.to_string(~T[23:00:00])\n\"23:00:00\"\niex&gt; Time.to_string(~T[23:00:00.001])\n\"23:00:00.001\"\niex&gt; Time.to_string(~T[23:00:00.123456])\n\"23:00:00.123456\"</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Time.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Time.html</a>\n  </p>\n</div>\n","elixir/version.requirement":"<h1>  Version.Requirement  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Version.Requirement{compiled: term, matchspec: term, source: term}</code></pre> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Version.Requirement.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Version.Requirement.html</a>\n  </p>\n</div>\n","elixir/argumenterror":"<h1>  ArgumentError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/ArgumentError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/ArgumentError.html</a>\n  </p>\n</div>\n","elixir/arithmeticerror":"<h1>  ArithmeticError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/ArithmeticError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/ArithmeticError.html</a>\n  </p>\n</div>\n","elixir/supervisor":"<h1>  Supervisor <small>behaviour</small>  </h1>  <p>A behaviour module for implementing supervision functionality.</p> <p>A supervisor is a process which supervises other processes, which we refer to as <em>child processes</em>. Supervisors are used to build a hierarchical process structure called a <em>supervision tree</em>. Supervision trees are a nice way to structure fault-tolerant applications.</p> <p>A supervisor implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into a supervision tree.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <p>In order to define a supervisor, we need to first define a child process that is going to be supervised. In order to do so, we will define a GenServer that represents a stack:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Stack do\n  use GenServer\n\n  def start_link(state, opts \\\\ []) do\n    GenServer.start_link(__MODULE__, state, opts)\n  end\n\n  def handle_call(:pop, _from, [h | t]) do\n    {:reply, h, t}\n  end\n\n  def handle_cast({:push, h}, t) do\n    {:noreply, [h | t]}\n  end\nend</code></pre> <p>We can now define our supervisor and start it as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Import helpers for defining supervisors\nimport Supervisor.Spec\n\n# Supervise the Stack server which will be started with\n# a single argument [:hello] and the default registered\n# name of MyStack.\nchildren = [\n  worker(Stack, [[:hello], [name: MyStack]])\n]\n\n# Start the supervisor with our child\n{:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)</code></pre> <p>Notice that when starting the GenServer, we are registering it with name <code class=\"inline\">MyStack</code>, which allows us to call it directly and get what is on the stack:</p> <pre data-language=\"elixir\"><code class=\"elixir\">GenServer.call(MyStack, :pop)\n#=&gt; :hello\n\nGenServer.cast(MyStack, {:push, :world})\n#=&gt; :ok\n\nGenServer.call(MyStack, :pop)\n#=&gt; :world</code></pre> <p>However, there is a bug in our stack server. If we call <code class=\"inline\">:pop</code> and the stack is empty, it is going to crash because no clause matches:</p> <pre data-language=\"elixir\"><code class=\"elixir\">GenServer.call(:sup_stack, :pop)\n** (exit) exited in: GenServer.call(MyStack, :pop, 5000)</code></pre> <p>Luckily, since the server is being supervised by a supervisor, the supervisor will automatically start a new one, with the initial stack of <code class=\"inline\">[:hello]</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">GenServer.call(MyStack, :pop)\n#=&gt; :hello</code></pre> <p>Supervisors support different strategies; in the example above, we have chosen <code class=\"inline\">:one_for_one</code>. Furthermore, each supervisor can have many workers and supervisors as children, each of them with their specific configuration, shutdown values, and restart strategies.</p> <p>The rest of this documentation will cover supervision strategies; also read the documentation for the <a href=\"supervisor.spec\"><code class=\"inline\">Supervisor.Spec</code></a> module to learn about the specification for workers and supervisors.</p> <h2 id=\"module-module-based-supervisors\" class=\"section-heading\">  Module-based supervisors </h2> <p>In the example above, a supervisor was started by passing the supervision structure to <a href=\"#start_link/2\"><code class=\"inline\">start_link/2</code></a>. However, supervisors can also be created by explicitly defining a supervision module:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp.Supervisor do\n  use Supervisor\n\n  def start_link do\n    Supervisor.start_link(__MODULE__, [])\n  end\n\n  def init([]) do\n    children = [\n      worker(Stack, [[:hello]])\n    ]\n\n    # supervise/2 is imported from Supervisor.Spec\n    supervise(children, strategy: :one_for_one)\n  end\nend</code></pre> <p>You may want to use a module-based supervisor if:</p> <ul> <li>\n<p>You need to perform some particular action on supervisor initialization, like setting up an ETS table.</p> </li> <li>You want to perform partial hot-code swapping of the tree. For example, if you add or remove children, the module-based supervision will add and remove the new children directly, while dynamic supervision requires the whole tree to be restarted in order to perform such swaps. </li> </ul> <h2 id=\"module-strategies\" class=\"section-heading\">  Strategies </h2> <p>Supervisors support different supervision strategies (through the <code class=\"inline\">:strategy</code> option, as seen above):</p> <ul> <li>\n<p><code class=\"inline\">:one_for_one</code> - if a child process terminates, only that process is restarted.</p> </li> <li>\n<p><code class=\"inline\">:one_for_all</code> - if a child process terminates, all other child processes are terminated and then all child processes (including the terminated one) are restarted.</p> </li> <li>\n<p><code class=\"inline\">:rest_for_one</code> - if a child process terminates, the “rest” of the child processes, i.e., the child processes after the terminated one in start order, are terminated. Then the terminated child process and the rest of the child processes are restarted.</p> </li> <li>\n<code class=\"inline\">:simple_one_for_one</code> - similar to <code class=\"inline\">:one_for_one</code> but suits better when dynamically attaching children. This strategy requires the supervisor specification to contain only one child. Many functions in this module behave slightly differently when this strategy is used. </li> </ul> <h2 id=\"module-simple-one-for-one\" class=\"section-heading\">  Simple one for one </h2> <p>The <code class=\"inline\">:simple_one_for_one</code> supervisor is useful when you want to dynamically start and stop supervised children. For example, imagine you want to dynamically create multiple stacks. We can do so by defining a <code class=\"inline\">:simple_one_for_one</code> supervisor:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Import helpers for defining supervisors\nimport Supervisor.Spec\n\n# This time, we don't pass any argument because\n# the argument will be given when we start the child\nchildren = [\n  worker(Stack, [], restart: :transient)\n]\n\n# Start the supervisor with our one child\n{:ok, sup_pid} = Supervisor.start_link(children, strategy: :simple_one_for_one)</code></pre> <p>There are a couple differences here:</p> <ul> <li>\n<p>the simple one for one specification can define only one child which works as a template for when we call <a href=\"#start_child/2\"><code class=\"inline\">start_child/2</code></a></p> </li> <li>we have defined the child to have a restart strategy of <code class=\"inline\">:transient</code>. This means that, if the child process exits due to a <code class=\"inline\">:normal</code>, <code class=\"inline\">:shutdown</code>, or <code class=\"inline\">{:shutdown, term}</code> reason, it won’t be restarted. This is useful as it allows our workers to politely shutdown and be removed from the <code class=\"inline\">:simple_one_for_one</code> supervisor, without being restarted. You can find more information about restart strategies in the documentation for the <a href=\"supervisor.spec\"><code class=\"inline\">Supervisor.Spec</code></a> module </li> </ul> <p>With the supervisor defined, let’s dynamically start stacks:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:ok, pid} = Supervisor.start_child(sup_pid, [[:hello, :world], []])\nGenServer.call(pid, :pop) #=&gt; :hello\nGenServer.call(pid, :pop) #=&gt; :world\n\n{:ok, pid} = Supervisor.start_child(sup_pid, [[:something, :else], []])\nGenServer.call(pid, :pop) #=&gt; :something\nGenServer.call(pid, :pop) #=&gt; :else\n\nSupervisor.count_children(sup_pid)\n#=&gt; %{active: 2, specs: 1, supervisors: 0, workers: 2}</code></pre> <h2 id=\"module-exit-reasons\" class=\"section-heading\">  Exit reasons </h2> <p>From the example above, you may have noticed that the <code class=\"inline\">:transient</code> restart strategy for the worker does not restart the child in case it exits with reason <code class=\"inline\">:normal</code>, <code class=\"inline\">:shutdown</code> or <code class=\"inline\">{:shutdown, term}</code>.</p> <p>So one may ask: which exit reason should I choose when exiting my worker? There are three options:</p> <ul> <li>\n<p><code class=\"inline\">:normal</code> - in such cases, the exit won’t be logged, there is no restart in transient mode, and linked processes do not exit</p> </li> <li>\n<p><code class=\"inline\">:shutdown</code> or <code class=\"inline\">{:shutdown, term}</code> - in such cases, the exit won’t be logged, there is no restart in transient mode, and linked processes exit with the same reason unless they’re trapping exits</p> </li> <li>any other term - in such cases, the exit will be logged, there are restarts in transient mode, and linked processes exit with the same reason unless they’re trapping exits </li> </ul> <h2 id=\"module-name-registration\" class=\"section-heading\">  Name registration </h2> <p>A supervisor is bound to the same name registration rules as a <a href=\"genserver\"><code class=\"inline\">GenServer</code></a>. Read more about these rules in the documentation for <a href=\"genserver\"><code class=\"inline\">GenServer</code></a>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:child/0\">child()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:name/0\">name()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The Supervisor name</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:on_start/0\">on_start()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Return values of <code class=\"inline\">start_link</code> functions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:on_start_child/0\">on_start_child()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Return values of <code class=\"inline\">start_child</code> functions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:options/0\">options()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Options used by the <code class=\"inline\">start*</code> functions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t:supervisor/0\">supervisor()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The supervisor reference</p> </dd>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#count_children/1\">count_children(supervisor)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a map containing count values for the given supervisor</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete_child/2\">delete_child(supervisor, child_id)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes the child specification identified by <code class=\"inline\">child_id</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#restart_child/2\">restart_child(supervisor, child_id)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Restarts a child process identified by <code class=\"inline\">child_id</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_child/2\">start_child(supervisor, child_spec_or_args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Dynamically adds a child specification to <code class=\"inline\">supervisor</code> and starts that child</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/2\">start_link(children, options)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a supervisor with the given children</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/3\">start_link(module, arg, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a supervisor module with the given <code class=\"inline\">arg</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stop/3\">stop(supervisor, reason \\\\ :normal, timeout \\\\ :infinity)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stops the given supervisor with the given <code class=\"inline\">reason</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#terminate_child/2\">terminate_child(supervisor, pid_or_child_id)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Terminates the given children, identified by pid or child id</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#which_children/1\">which_children(supervisor)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list with information about all children of the given supervisor</p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:init/1\">init(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback invoked to start the supervisor and during hot code upgrades</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:child/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:child/0\">child</a> :: pid | :undefined</code></pre> </div> <div id=\"t:name/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:name/0\">name</a> ::\n  atom |\n  {:global, term} |\n  {:via, module, term}</code></pre> <p>The Supervisor name</p>  </div> <div id=\"t:on_start/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:on_start/0\">on_start</a> ::\n  {:ok, pid} |\n  :ignore |\n  {:error, {:already_started, pid} | {:shutdown, term} | term}</code></pre> <p>Return values of <code class=\"inline\">start_link</code> functions</p>  </div> <div id=\"t:on_start_child/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:on_start_child/0\">on_start_child</a> ::\n  {:ok, <a href=\"#t:child/0\">child</a>} |\n  {:ok, <a href=\"#t:child/0\">child</a>, info :: term} |\n  {:error, {:already_started, <a href=\"#t:child/0\">child</a>} | :already_present | term}</code></pre> <p>Return values of <code class=\"inline\">start_child</code> functions</p>  </div> <div id=\"t:options/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:options/0\">options</a> :: [name: <a href=\"#t:name/0\">name</a>, strategy: <a href=\"supervisor.spec#t:strategy/0\">Supervisor.Spec.strategy</a>, max_restarts: non_neg_integer, max_seconds: non_neg_integer]</code></pre> <p>Options used by the <code class=\"inline\">start*</code> functions</p>  </div> <div id=\"t:supervisor/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:supervisor/0\">supervisor</a> :: pid | <a href=\"#t:name/0\">name</a> | {atom, node}</code></pre> <p>The supervisor reference</p>  </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"count_children/1\">  <span class=\"signature\">count_children(supervisor)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">count_children(<a href=\"#t:supervisor/0\">supervisor</a>) :: %{specs: non_neg_integer, active: non_neg_integer, supervisors: non_neg_integer, workers: non_neg_integer}</code></pre>    <p>Returns a map containing count values for the given supervisor.</p> <p>The map contains the following keys:</p> <ul> <li>\n<p><code class=\"inline\">:specs</code> - the total count of children, dead or alive</p> </li> <li>\n<p><code class=\"inline\">:active</code> - the count of all actively running child processes managed by this supervisor</p> </li> <li>\n<p><code class=\"inline\">:supervisors</code> - the count of all supervisors whether or not these child supervisors are still alive</p> </li> <li>\n<code class=\"inline\">:workers</code> - the count of all workers, whether or not these child workers are still alive </li> </ul>    <h3 class=\"detail-header function\" id=\"delete_child/2\">  <span class=\"signature\">delete_child(supervisor, child_id)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete_child(<a href=\"#t:supervisor/0\">supervisor</a>, <a href=\"supervisor.spec#t:child_id/0\">Supervisor.Spec.child_id</a>) ::\n  :ok |\n  {:error, error} when error: :not_found | :simple_one_for_one | :running | :restarting</code></pre>    <p>Deletes the child specification identified by <code class=\"inline\">child_id</code>.</p> <p>The corresponding child process must not be running; use <a href=\"#terminate_child/2\"><code class=\"inline\">terminate_child/2</code></a> to terminate it if it’s running.</p> <p>If successful, this function returns <code class=\"inline\">:ok</code>. This function may return an error with an appropriate error tuple if the <code class=\"inline\">child_id</code> is not found, or if the current process is running or being restarted.</p> <p>This operation is not supported by <code class=\"inline\">:simple_one_for_one</code> supervisors.</p>    <h3 class=\"detail-header function\" id=\"restart_child/2\">  <span class=\"signature\">restart_child(supervisor, child_id)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">restart_child(<a href=\"#t:supervisor/0\">supervisor</a>, <a href=\"supervisor.spec#t:child_id/0\">Supervisor.Spec.child_id</a>) ::\n  {:ok, <a href=\"#t:child/0\">child</a>} |\n  {:ok, <a href=\"#t:child/0\">child</a>, term} |\n  {:error, error} when error: :not_found | :simple_one_for_one | :running | :restarting | term</code></pre>    <p>Restarts a child process identified by <code class=\"inline\">child_id</code>.</p> <p>The child specification must exist and the corresponding child process must not be running.</p> <p>Note that for temporary children, the child specification is automatically deleted when the child terminates, and thus it is not possible to restart such children.</p> <p>If the child process start function returns <code class=\"inline\">{:ok, child}</code> or <code class=\"inline\">{:ok, child, info}</code>, the pid is added to the supervisor and this function returns the same value.</p> <p>If the child process start function returns <code class=\"inline\">:ignore</code>, the pid remains set to <code class=\"inline\">:undefined</code> and this function returns <code class=\"inline\">{:ok, :undefined}</code>.</p> <p>This function may return an error with an appropriate error tuple if the <code class=\"inline\">child_id</code> is not found, or if the current process is running or being restarted.</p> <p>If the child process start function returns an error tuple or an erroneous value, or if it fails, this function returns <code class=\"inline\">{:error, error}</code>.</p> <p>This operation is not supported by <code class=\"inline\">:simple_one_for_one</code> supervisors.</p>    <h3 class=\"detail-header function\" id=\"start_child/2\">  <span class=\"signature\">start_child(supervisor, child_spec_or_args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_child(<a href=\"#t:supervisor/0\">supervisor</a>, <a href=\"supervisor.spec#t:spec/0\">Supervisor.Spec.spec</a> | [term]) :: <a href=\"#t:on_start_child/0\">on_start_child</a></code></pre>    <p>Dynamically adds a child specification to <code class=\"inline\">supervisor</code> and starts that child.</p> <p><code class=\"inline\">child_spec</code> should be a valid child specification (unless the supervisor is a <code class=\"inline\">:simple_one_for_one</code> supervisor, see below). The child process will be started as defined in the child specification.</p> <p>In the case of <code class=\"inline\">:simple_one_for_one</code>, the child specification defined in the supervisor is used and instead of a <code class=\"inline\">child_spec</code>, an arbitrary list of terms is expected. The child process will then be started by appending the given list to the existing function arguments in the child specification.</p> <p>If a child specification with the specified id already exists, <code class=\"inline\">child_spec</code> is discarded and this function returns an error with <code class=\"inline\">:already_started</code> or <code class=\"inline\">:already_present</code> if the corresponding child process is running or not, respectively.</p> <p>If the child process start function returns <code class=\"inline\">{:ok, child}</code> or <code class=\"inline\">{:ok, child,\ninfo}</code>, then child specification and pid are added to the supervisor and this function returns the same value.</p> <p>If the child process start function returns <code class=\"inline\">:ignore</code>, the child specification is added to the supervisor, the pid is set to <code class=\"inline\">:undefined</code> and this function returns <code class=\"inline\">{:ok, :undefined}</code>.</p> <p>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns <code class=\"inline\">{:error, error}</code> where <code class=\"inline\">error</code> is a term containing information about the error and child specification.</p>    <h3 class=\"detail-header function\" id=\"start_link/2\">  <span class=\"signature\">start_link(children, options)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_link([<a href=\"supervisor.spec#t:spec/0\">Supervisor.Spec.spec</a>], <a href=\"#t:options/0\">options</a>) :: <a href=\"#t:on_start/0\">on_start</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">start_link(module, term) :: <a href=\"#t:on_start/0\">on_start</a></code></pre>    <p>Starts a supervisor with the given children.</p> <p>A strategy is required to be provided through the <code class=\"inline\">:strategy</code> option. Furthermore, the <code class=\"inline\">:max_restarts</code> and <code class=\"inline\">:max_seconds</code> options can be configured as described in the documentation for <a href=\"supervisor.spec#supervise/2\"><code class=\"inline\">Supervisor.Spec.supervise/2</code></a>.</p> <p>The options can also be used to register a supervisor name. The supported values are described under the “Name registration” section in the <a href=\"genserver\"><code class=\"inline\">GenServer</code></a> module docs.</p> <p>If the supervisor and its child processes are successfully created (i.e., if the start function of each child process returns <code class=\"inline\">{:ok, child}</code>, <code class=\"inline\">{:ok, child, info}</code>, or <code class=\"inline\">:ignore</code>) this function returns <code class=\"inline\">{:ok, pid}</code>, where <code class=\"inline\">pid</code> is the pid of the supervisor. If a process with the specified name already exists, the function returns <code class=\"inline\">{:error,\n {:already_started, pid}}</code>, where <code class=\"inline\">pid</code> is the pid of that process.</p> <p>If the start function of any of the child processes fails or returns an error tuple or an erroneous value, the supervisor first terminates with reason <code class=\"inline\">:shutdown</code> all the child processes that have already been started, and then terminates itself and returns <code class=\"inline\">{:error, {:shutdown, reason}}</code>.</p> <p>Note that a supervisor started with this function is linked to the parent process and exits not only on crashes but also if the parent process exits with <code class=\"inline\">:normal</code> reason.</p>    <h3 class=\"detail-header function\" id=\"start_link/3\">  <span class=\"signature\">start_link(module, arg, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_link(module, term, <a href=\"#t:options/0\">options</a>) :: <a href=\"#t:on_start/0\">on_start</a></code></pre>    <p>Starts a supervisor module with the given <code class=\"inline\">arg</code>.</p> <p>To start the supervisor, the <code class=\"inline\">init/1</code> callback will be invoked in the given <code class=\"inline\">module</code>, with <code class=\"inline\">arg</code> as its argument. The <code class=\"inline\">init/1</code> callback must return a supervisor specification which can be created with the help of the functions in the <a href=\"supervisor.spec\"><code class=\"inline\">Supervisor.Spec</code></a> module (especially <a href=\"supervisor.spec#supervise/2)\"><code class=\"inline\">Supervisor.Spec.supervise/2</code></a>.</p> <p>If the <code class=\"inline\">init/1</code> callback returns <code class=\"inline\">:ignore</code>, this function returns <code class=\"inline\">:ignore</code> as well and the supervisor terminates with reason <code class=\"inline\">:normal</code>. If it fails or returns an incorrect value, this function returns <code class=\"inline\">{:error, term}</code> where <code class=\"inline\">term</code> is a term with information about the error, and the supervisor terminates with reason <code class=\"inline\">term</code>.</p> <p>The <code class=\"inline\">:name</code> option can also be given in order to register a supervisor name, the supported values are described in the “Name registration” section in the <a href=\"genserver\"><code class=\"inline\">GenServer</code></a> module docs.</p>    <h3 class=\"detail-header function\" id=\"stop/3\">  <span class=\"signature\">stop(supervisor, reason \\\\ :normal, timeout \\\\ :infinity)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">stop(<a href=\"#t:supervisor/0\">supervisor</a>, reason :: term, timeout) :: :ok</code></pre>    <p>Stops the given supervisor with the given <code class=\"inline\">reason</code>.</p> <p>It returns <code class=\"inline\">:ok</code> if the supervisor terminates with the given reason. If it terminates with another reason, the call exits.</p> <p>This function keeps OTP semantics regarding error reporting. If the reason is any other than <code class=\"inline\">:normal</code>, <code class=\"inline\">:shutdown</code> or <code class=\"inline\">{:shutdown, _}</code>, an error report is logged.</p>    <h3 class=\"detail-header function\" id=\"terminate_child/2\">  <span class=\"signature\">terminate_child(supervisor, pid_or_child_id)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">terminate_child(<a href=\"#t:supervisor/0\">supervisor</a>, pid | <a href=\"supervisor.spec#t:child_id/0\">Supervisor.Spec.child_id</a>) ::\n  :ok |\n  {:error, error} when error: :not_found | :simple_one_for_one</code></pre>    <p>Terminates the given children, identified by pid or child id.</p> <p>If the supervisor is not a <code class=\"inline\">:simple_one_for_one</code>, the child id is expected and the process, if there’s one, is terminated; the child specification is kept unless the child is temporary.</p> <p>In case of a <code class=\"inline\">:simple_one_for_one</code> supervisor, a pid is expected. If the child specification identifier is given instead of a <code class=\"inline\">pid</code>, this function returns <code class=\"inline\">{:error, :simple_one_for_one}</code>.</p> <p>A non-temporary child process may later be restarted by the supervisor. The child process can also be restarted explicitly by calling <a href=\"#restart_child/2\"><code class=\"inline\">restart_child/2</code></a>. Use <a href=\"#delete_child/2\"><code class=\"inline\">delete_child/2</code></a> to remove the child specification.</p> <p>If successful, this function returns <code class=\"inline\">:ok</code>. If there is no child specification for the given child id or there is no process with the given pid, this function returns <code class=\"inline\">{:error, :not_found}</code>.</p>    <h3 class=\"detail-header function\" id=\"which_children/1\">  <span class=\"signature\">which_children(supervisor)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">which_children(<a href=\"#t:supervisor/0\">supervisor</a>) :: [{<a href=\"supervisor.spec#t:child_id/0\">Supervisor.Spec.child_id</a> | :undefined, <a href=\"#t:child/0\">child</a> | :restarting, <a href=\"supervisor.spec#t:worker/0\">Supervisor.Spec.worker</a>, <a href=\"supervisor.spec#t:modules/0\">Supervisor.Spec.modules</a>}]</code></pre>    <p>Returns a list with information about all children of the given supervisor.</p> <p>Note that calling this function when supervising a large number of children under low memory conditions can cause an out of memory exception.</p> <p>This function returns a list of <code class=\"inline\">{id, child, type, modules}</code> tuples, where:</p> <ul> <li>\n<p><code class=\"inline\">id</code> - as defined in the child specification or <code class=\"inline\">:undefined</code> in the case of a <code class=\"inline\">simple_one_for_one</code> supervisor</p> </li> <li>\n<p><code class=\"inline\">child</code> - the pid of the corresponding child process, <code class=\"inline\">:restarting</code> if the process is about to be restarted, or <code class=\"inline\">:undefined</code> if there is no such process</p> </li> <li>\n<p><code class=\"inline\">type</code> - <code class=\"inline\">:worker</code> or <code class=\"inline\">:supervisor</code>, as specified by the child specification</p> </li> <li>\n<code class=\"inline\">modules</code> - as specified by the child specification </li> </ul>     <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:init/1\">  <span class=\"signature\">init(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">init(args :: term) ::\n  {:ok, {:supervisor.sup_flags, [<a href=\"supervisor.spec#t:spec/0\">Supervisor.Spec.spec</a>]}} |\n  :ignore</code></pre>    <p>Callback invoked to start the supervisor and during hot code upgrades.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Supervisor.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Supervisor.html</a>\n  </p>\n</div>\n","elixir/task":"<h1>  Task  </h1>  <p>Conveniences for spawning and awaiting tasks.</p> <p>Tasks are processes meant to execute one particular action throughout their lifetime, often with little or no communication with other processes. The most common use case for tasks is to convert sequential code into concurrent code by computing a value asynchronously:</p> <pre data-language=\"elixir\"><code class=\"elixir\">task = Task.async(fn -&gt; do_some_work() end)\nres  = do_some_other_work()\nres + Task.await(task)</code></pre> <p>Tasks spawned with <code class=\"inline\">async</code> can be awaited on by their caller process (and only their caller) as shown in the example above. They are implemented by spawning a process that sends a message to the caller once the given computation is performed.</p> <p>Besides <a href=\"#async/1\"><code class=\"inline\">async/1</code></a> and <a href=\"#await/2\"><code class=\"inline\">await/2</code></a>, tasks can also be started as part of a supervision tree and dynamically spawned on remote nodes. We will explore all three scenarios next.</p> <h2 id=\"module-async-and-await\" class=\"section-heading\">  async and await </h2> <p>One of the common uses of tasks is to convert sequential code into concurrent code with <a href=\"task#async/1\"><code class=\"inline\">Task.async/1</code></a> while keeping its semantics. When invoked, a new process will be created, linked and monitored by the caller. Once the task action finishes, a message will be sent to the caller with the result.</p> <p><a href=\"task#await/2\"><code class=\"inline\">Task.await/2</code></a> is used to read the message sent by the task.</p> <p>There are two important things to consider when using <code class=\"inline\">async</code>:</p> <ol> <li>\n<p>If you are using async tasks, you must await a reply as they are <em>always</em> sent. If you are not expecting a reply, consider using <a href=\"task#start_link/1\"><code class=\"inline\">Task.start_link/1</code></a> detailed below.</p> </li> <li>\n<p>async tasks link the caller and the spawned process. This means that, if the caller crashes, the task will crash too and vice-versa. This is on purpose: if the process meant to receive the result no longer exists, there is no purpose in completing the computation.</p> <p> If this is not desired, use <a href=\"task#start/1\"><code class=\"inline\">Task.start/1</code></a> or consider starting the task under a <a href=\"task.supervisor\"><code class=\"inline\">Task.Supervisor</code></a> using <code class=\"inline\">async_nolink</code> or <code class=\"inline\">start_child</code>.</p> </li> </ol> <p><a href=\"task#yield/2\"><code class=\"inline\">Task.yield/2</code></a> is an alternative to <a href=\"#await/2\"><code class=\"inline\">await/2</code></a> where the caller will temporarily block, waiting until the task replies or crashes. If the result does not arrive within the timeout, it can be called again at a later moment. This allows checking for the result of a task multiple times. If a reply does not arrive within the desired time, <a href=\"task#shutdown/2\"><code class=\"inline\">Task.shutdown/2</code></a> can be used to stop the task.</p> <h2 id=\"module-supervised-tasks\" class=\"section-heading\">  Supervised tasks </h2> <p>It is also possible to spawn a task under a supervisor with <a href=\"#start_link/1\"><code class=\"inline\">start_link/1</code></a> and <a href=\"#start_link/3\"><code class=\"inline\">start_link/3</code></a>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Task.start_link(fn -&gt; IO.puts \"ok\" end)</code></pre> <p>Such tasks can be mounted in your supervision tree as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import Supervisor.Spec\n\nchildren = [\n  worker(Task, [fn -&gt; IO.puts \"ok\" end])\n]</code></pre> <p>Since these tasks are supervised and not directly linked to the caller, they cannot be awaited on. Note <a href=\"#start_link/1\"><code class=\"inline\">start_link/1</code></a>, unlike <a href=\"#async/1\"><code class=\"inline\">async/1</code></a>, returns <code class=\"inline\">{:ok, pid}</code> (which is the result expected by supervision trees).</p> <p>By default, most supervision strategies will try to restart a worker after it exits regardless of the reason. If you design the task to terminate normally (as in the example with <a href=\"io#puts/2\"><code class=\"inline\">IO.puts/2</code></a> above), consider passing <code class=\"inline\">restart: :transient</code> in the options to <code class=\"inline\">worker/3</code>.</p> <h2 id=\"module-dynamically-supervised-tasks\" class=\"section-heading\">  Dynamically supervised tasks </h2> <p>The <a href=\"task.supervisor\"><code class=\"inline\">Task.Supervisor</code></a> module allows developers to dynamically create multiple supervised tasks.</p> <p>A short example is:</p> <pre data-language=\"elixir\"><code class=\"elixir\">{:ok, pid} = Task.Supervisor.start_link()\ntask = Task.Supervisor.async(pid, fn -&gt;\n  # Do something\nend)\nTask.await(task)</code></pre> <p>However, in the majority of cases, you want to add the task supervisor to your supervision tree:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import Supervisor.Spec\n\nchildren = [\n  supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])\n]</code></pre> <p>Now you can dynamically start supervised tasks:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Task.Supervisor.start_child(MyApp.TaskSupervisor, fn -&gt;\n  # Do something\nend)</code></pre> <p>Or even use the async/await pattern:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Task.Supervisor.async(MyApp.TaskSupervisor, fn -&gt;\n  # Do something\nend) |&gt; Task.await()</code></pre> <p>Finally, check <a href=\"task.supervisor\"><code class=\"inline\">Task.Supervisor</code></a> for other supported operations.</p> <h2 id=\"module-distributed-tasks\" class=\"section-heading\">  Distributed tasks </h2> <p>Since Elixir provides a Task supervisor, it is easy to use one to dynamically spawn tasks across nodes:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># On the remote node\nTask.Supervisor.start_link(name: MyApp.DistSupervisor)\n\n# On the client\nTask.Supervisor.async({MyApp.DistSupervisor, :remote@local},\n                      MyMod, :my_fun, [arg1, arg2, arg3])</code></pre> <p>Note that, when working with distributed tasks, one should use the <code class=\"inline\">async/4</code> function that expects explicit module, function and arguments, instead of <code class=\"inline\">async/2</code> that works with anonymous functions. That’s because anonymous functions expect the same module version to exist on all involved nodes. Check the <a href=\"agent\"><code class=\"inline\">Agent</code></a> module documentation for more information on distributed processes as the limitations described there apply to the whole ecosystem.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#__struct__/0\">__struct__()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The Task struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#async/1\">async(fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a task that must be awaited on</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#async/3\">async(mod, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a task that must be awaited on</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#await/2\">await(task, timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Awaits a task reply</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#shutdown/2\">shutdown(task, shutdown \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Unlinks and shuts down the task, and then checks for a reply</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start/1\">start(fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a task</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start/3\">start(mod, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a task</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/1\">start_link(fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a task as part of a supervision tree</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#start_link/3\">start_link(mod, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Starts a task as part of a supervision tree</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#yield/2\">yield(task, timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Temporarily blocks the current process waiting for a task reply</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#yield_many/2\">yield_many(tasks, timeout \\\\ 5000)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Yields to multiple tasks in the given time interval</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Task{owner: term, pid: term, ref: term}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"__struct__/0\">  <span class=\"signature\">__struct__()</span>  </h3>  <p>The Task struct.</p> <p>It contains these fields:</p> <ul> <li>\n<p><code class=\"inline\">:pid</code> - the PID of the task process; <code class=\"inline\">nil</code> if the task does not use a task process</p> </li> <li>\n<p><code class=\"inline\">:ref</code> - the task monitor reference</p> </li> <li>\n<code class=\"inline\">:owner</code> - the PID of the process that started the task </li> </ul>    <h3 class=\"detail-header function\" id=\"async/1\">  <span class=\"signature\">async(fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">async((... -&gt; any)) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Starts a task that must be awaited on.</p> <p>This function spawns a process that is linked to and monitored by the caller process. A <a href=\"task#content\"><code class=\"inline\">Task</code></a> struct is returned containing the relevant information.</p> <p>Read the <a href=\"task#content\"><code class=\"inline\">Task</code></a> module documentation for more info on general usage of <a href=\"#async/1\"><code class=\"inline\">async/1</code></a> and <a href=\"#async/3\"><code class=\"inline\">async/3</code></a>.</p> <p>See also <a href=\"#async/3\"><code class=\"inline\">async/3</code></a>.</p>    <h3 class=\"detail-header function\" id=\"async/3\">  <span class=\"signature\">async(mod, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">async(module, atom, [term]) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Starts a task that must be awaited on.</p> <p>A <a href=\"task#content\"><code class=\"inline\">Task</code></a> struct is returned containing the relevant information. Developers must eventually call <a href=\"task#await/2\"><code class=\"inline\">Task.await/2</code></a> or <a href=\"task#yield/2\"><code class=\"inline\">Task.yield/2</code></a> followed by <a href=\"task#shutdown/2\"><code class=\"inline\">Task.shutdown/2</code></a> on the returned task.</p> <p>Read the <a href=\"task#content\"><code class=\"inline\">Task</code></a> module documentation for more info on general usage of <a href=\"#async/1\"><code class=\"inline\">async/1</code></a> and <a href=\"#async/3\"><code class=\"inline\">async/3</code></a>.</p> <h4>Linking</h4> <p>This function spawns a process that is linked to and monitored by the caller process. The linking part is important because it aborts the task if the parent process dies. It also guarantees the code before async/await has the same properties after you add the async call. For example, imagine you have this:</p> <pre data-language=\"elixir\"><code class=\"elixir\">x = heavy_fun()\ny = some_fun()\nx + y</code></pre> <p>Now you want to make the <code class=\"inline\">heavy_fun()</code> async:</p> <pre data-language=\"elixir\"><code class=\"elixir\">x = Task.async(&amp;heavy_fun/0)\ny = some_fun()\nTask.await(x) + y</code></pre> <p>As before, if <code class=\"inline\">heavy_fun/0</code> fails, the whole computation will fail, including the parent process. If you don’t want the task to fail then you must change the <code class=\"inline\">heavy_fun/0</code> code in the same way you would achieve it if you didn’t have the async call. For example, to either return <code class=\"inline\">{:ok, val} | :error</code> results or, in more extreme cases, by using <code class=\"inline\">try/rescue</code>. In other words, an asynchronous task should be thought of as an extension of a process rather than a mechanism to isolate it from all errors.</p> <p>If you don’t want to link the caller to the task, then you must use a supervised task with <a href=\"task.supervisor\"><code class=\"inline\">Task.Supervisor</code></a> and call <a href=\"task.supervisor#async_nolink/2\"><code class=\"inline\">Task.Supervisor.async_nolink/2</code></a>.</p> <p>In any case, avoid any of the following:</p> <ul> <li>\n<p>Setting <code class=\"inline\">:trap_exit</code> to <code class=\"inline\">true</code> - trapping exits should be used only in special circumstances as it would make your process immune to not only exits from the task but from any other processes.</p> <p>Moreover, even when trapping exists, calling <code class=\"inline\">await</code> will still exit if the task has terminated without sending its result back.</p> </li> <li>Unlinking the task process started with <code class=\"inline\">async</code>/<code class=\"inline\">await</code>. If you unlink the processes and the task does not belong to any supervisor, you may leave dangling tasks in case the parent dies. </li> </ul> <h4>Message format</h4> <p>The reply sent by the task will be in the format <code class=\"inline\">{ref, result}</code>, where <code class=\"inline\">ref</code> is the monitor reference held by the task struct and <code class=\"inline\">result</code> is the return value of the task function.</p>    <h3 class=\"detail-header function\" id=\"await/2\">  <span class=\"signature\">await(task, timeout \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">await(<a href=\"#t:t/0\">t</a>, timeout) :: term | no_return</code></pre>    <p>Awaits a task reply.</p> <p>A timeout, in milliseconds, can be given with default value of <code class=\"inline\">5000</code>. In case the task process dies, this function will exit with the same reason as the task.</p> <p>If the timeout is exceeded, <code class=\"inline\">await</code> will exit; however, the task will continue to run. When the calling process exits, its exit signal will terminate the task if it is not trapping exits.</p> <p>This function assumes the task’s monitor is still active or the monitor’s <code class=\"inline\">:DOWN</code> message is in the message queue. If it has been demonitored, or the message already received, this function will wait for the duration of the timeout awaiting the message.</p> <p>This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use <a href=\"#yield/2\"><code class=\"inline\">yield/2</code></a> instead.</p> <h4>Compatibility with OTP behaviours</h4> <p>It is not recommended to <code class=\"inline\">await</code> a long-running task inside an OTP behaviour such as <a href=\"genserver\"><code class=\"inline\">GenServer</code></a>. Instead, you should match on the message coming from a task inside your <code class=\"inline\">handle_info</code> callback.</p>    <h3 class=\"detail-header function\" id=\"shutdown/2\">  <span class=\"signature\">shutdown(task, shutdown \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">shutdown(<a href=\"#t:t/0\">t</a>, timeout | :brutal_kill) ::\n  {:ok, term} |\n  {:exit, term} |\n  nil</code></pre>    <p>Unlinks and shuts down the task, and then checks for a reply.</p> <p>Returns <code class=\"inline\">{:ok, reply}</code> if the reply is received while shutting down the task, <code class=\"inline\">{:exit, reason}</code> if the task died, otherwise <code class=\"inline\">nil</code>.</p> <p>The shutdown method is either a timeout or <code class=\"inline\">:brutal_kill</code>. In case of a <code class=\"inline\">timeout</code>, a <code class=\"inline\">:shutdown</code> exit signal is sent to the task process and if it does not exit within the timeout, it is killed. With <code class=\"inline\">:brutal_kill</code> the task is killed straight away. In case the task terminates abnormally (possibly killed by another process), this function will exit with the same reason.</p> <p>It is not required to call this function when terminating the caller, unless exiting with reason <code class=\"inline\">:normal</code> or if the task is trapping exits. If the caller is exiting with a reason other than <code class=\"inline\">:normal</code> and the task is not trapping exits, the caller’s exit signal will stop the task. The caller can exit with reason <code class=\"inline\">:shutdown</code> to shutdown all of its linked processes, including tasks, that are not trapping exits without generating any log messages.</p> <p>This function assumes the task’s monitor is still active or the monitor’s <code class=\"inline\">:DOWN</code> message is in the message queue. If it has been demonitored, or the message already received, this function will block forever awaiting the message.</p>    <h3 class=\"detail-header function\" id=\"start/1\">  <span class=\"signature\">start(fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start((... -&gt; any)) :: {:ok, pid}</code></pre>    <p>Starts a task.</p> <p>This is only used when the task is used for side-effects (i.e. no interest in the returned result) and it should not be linked to the current process.</p>    <h3 class=\"detail-header function\" id=\"start/3\">  <span class=\"signature\">start(mod, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start(module, atom, [term]) :: {:ok, pid}</code></pre>    <p>Starts a task.</p> <p>This is only used when the task is used for side-effects (i.e. no interest in the returned result) and it should not be linked to the current process.</p>    <h3 class=\"detail-header function\" id=\"start_link/1\">  <span class=\"signature\">start_link(fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_link((... -&gt; any)) :: {:ok, pid}</code></pre>    <p>Starts a task as part of a supervision tree.</p>    <h3 class=\"detail-header function\" id=\"start_link/3\">  <span class=\"signature\">start_link(mod, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">start_link(module, atom, [term]) :: {:ok, pid}</code></pre>    <p>Starts a task as part of a supervision tree.</p>    <h3 class=\"detail-header function\" id=\"yield/2\">  <span class=\"signature\">yield(task, timeout \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">yield(<a href=\"#t:t/0\">t</a>, timeout) ::\n  {:ok, term} |\n  {:exit, term} |\n  nil</code></pre>    <p>Temporarily blocks the current process waiting for a task reply.</p> <p>Returns <code class=\"inline\">{:ok, reply}</code> if the reply is received, <code class=\"inline\">nil</code> if no reply has arrived, or <code class=\"inline\">{:exit, reason}</code> if the task has already exited. Keep in mind that normally a task failure also causes the process owning the task to exit. Therefore this function can return <code class=\"inline\">{:exit, reason}</code> only if</p> <ul> <li>the task process exited with the reason <code class=\"inline\">:normal</code> </li> <li>it isn’t linked to the caller </li> <li>the caller is trapping exits </li> </ul> <p>A timeout, in milliseconds, can be given with default value of <code class=\"inline\">5000</code>. If the time runs out before a message from the task is received, this function will return <code class=\"inline\">nil</code> and the monitor will remain active. Therefore <a href=\"#yield/2\"><code class=\"inline\">yield/2</code></a> can be called multiple times on the same task.</p> <p>This function assumes the task’s monitor is still active or the monitor’s <code class=\"inline\">:DOWN</code> message is in the message queue. If it has been demonitored or the message already received, this function will wait for the duration of the timeout awaiting the message.</p>    <h3 class=\"detail-header function\" id=\"yield_many/2\">  <span class=\"signature\">yield_many(tasks, timeout \\\\ 5000)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">yield_many([<a href=\"#t:t/0\">t</a>], timeout) :: [{<a href=\"#t:t/0\">t</a>, {:ok, term} | {:exit, term} | nil}]</code></pre>    <p>Yields to multiple tasks in the given time interval.</p> <p>This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of tuples of two elements, with the task as the first element and the yielded result as the second.</p> <p>Similarly to <a href=\"#yield/2\"><code class=\"inline\">yield/2</code></a>, each task’s result will be</p> <ul> <li>\n<code class=\"inline\">{:ok, term}</code> if the task has successfully reported its result back in the given time interval </li> <li>\n<code class=\"inline\">{:exit, reason}</code> if the task has died </li> <li>\n<code class=\"inline\">nil</code> if the task keeps running past the timeout </li> </ul> <p>Check <a href=\"#yield/2\"><code class=\"inline\">yield/2</code></a> for more information.</p> <h4>Example</h4> <p><a href=\"task#yield_many/2\"><code class=\"inline\">Task.yield_many/2</code></a> allows developers to spawn multiple tasks and retrieve the results received in a given timeframe. If we combine it with <a href=\"task#shutdown/2\"><code class=\"inline\">Task.shutdown/2</code></a>, it allows us to gather those results and cancel the tasks that have not replied in time.</p> <p>Let’s see an example.</p> <pre data-language=\"elixir\"><code class=\"elixir\">tasks =\n  for i &lt;- 1..10 do\n    Task.async(fn -&gt;\n      :timer.sleep(i * 1000)\n      i\n    end)\n  end\n\ntasks_with_results = Task.yield_many(tasks, 5000)\n\nresults = Enum.map(tasks_with_results, fn {task, res} -&gt;\n  # Shutdown the tasks that did not reply nor exit\n  res || Task.shutdown(task, :brutal_kill)\nend)\n\n# Here we are matching only on {:ok, value} and\n# ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\nfor {:ok, value} &lt;- results do\n  IO.inspect value\nend</code></pre> <p>In the example above, we create tasks that sleep from 1 up to 10 seconds and return the amount of seconds they slept. If you execute the code all at once, you should see 1 up to 5 printed, as those were the tasks that have replied in the given time. All other tasks will have been shut down using the <a href=\"task#shutdown/2\"><code class=\"inline\">Task.shutdown/2</code></a> call.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Task.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Task.html</a>\n  </p>\n</div>\n","elixir/uri":"<h1>  URI  </h1>  <p>Utilities for working with URIs.</p> <p>This module provides functions for working with URIs (for example, parsing URIs or encoding query strings). For reference, most of the functions in this module refer to <a href=\"https://tools.ietf.org/html/rfc3986\">RFC 3986</a>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#char_reserved?/1\">char_reserved?(char)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the character is a “reserved” character in a URI</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#char_unescaped?/1\">char_unescaped?(char)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the character is allowed unescaped in a URI</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#char_unreserved?/1\">char_unreserved?(char)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the character is a “unreserved” character in a URI</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#decode/1\">decode(uri)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Percent-unescapes a URI</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#decode_query/2\">decode_query(query, map \\\\ %{})</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes a query string into a map</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#decode_www_form/1\">decode_www_form(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Decodes a string as “x-www-form-urlencoded”</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#default_port/1\">default_port(scheme)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the default port for a given scheme</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#default_port/2\">default_port(scheme, port)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Registers the default port <code class=\"inline\">port</code> for the given <code class=\"inline\">scheme</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#encode/2\">encode(string, predicate \\\\ &amp;char_unescaped?/1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Percent-escapes the given string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#encode_query/1\">encode_query(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Encodes an enumerable into a query string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#encode_www_form/1\">encode_www_form(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Encodes a string as “x-www-form-urlencoded”</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#merge/2\">merge(uri, rel)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Merges two URIs</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#parse/1\">parse(uri)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses a well-formed URI reference into its components</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#path_to_segments/1\">path_to_segments(path)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#query_decoder/1\">query_decoder(query)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a stream of two-element tuples representing key-value pairs in the given <code class=\"inline\">query</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(uri)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the string representation of the given <a href=\"uri#content\"><code class=\"inline\">URI</code></a> struct</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %URI{authority: nil | binary, fragment: nil | binary, host: nil | binary, path: nil | binary, port: nil | :inet.port_number, query: nil | binary, scheme: nil | binary, userinfo: nil | binary}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"char_reserved?/1\">  <span class=\"signature\">char_reserved?(char)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">char_reserved?(char) :: boolean</code></pre>    <p>Checks if the character is a “reserved” character in a URI.</p> <p>Reserved characters are specified in <a href=\"http://tools.ietf.org/html/rfc3986#section-2.2\">RFC 3986, section 2.2</a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.char_reserved?(?+)\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"char_unescaped?/1\">  <span class=\"signature\">char_unescaped?(char)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">char_unescaped?(char) :: boolean</code></pre>    <p>Checks if the character is allowed unescaped in a URI.</p> <p>This is the default used by <a href=\"uri#encode/2\"><code class=\"inline\">URI.encode/2</code></a> where both reserved and unreserved characters are kept unescaped.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.char_unescaped?(?{)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"char_unreserved?/1\">  <span class=\"signature\">char_unreserved?(char)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">char_unreserved?(char) :: boolean</code></pre>    <p>Checks if the character is a “unreserved” character in a URI.</p> <p>Unreserved characters are specified in <a href=\"http://tools.ietf.org/html/rfc3986#section-2.3\">RFC 3986, section 2.3</a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.char_unreserved?(?_)\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"decode/1\">  <span class=\"signature\">decode(uri)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">decode(binary) :: binary</code></pre>    <p>Percent-unescapes a URI.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.decode(\"http%3A%2F%2Felixir-lang.org\")\n\"http://elixir-lang.org\"</code></pre>    <h3 class=\"detail-header function\" id=\"decode_query/2\">  <span class=\"signature\">decode_query(query, map \\\\ %{})</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">decode_query(binary, map) :: map</code></pre>    <p>Decodes a query string into a map.</p> <p>Given a query string of the form of <code class=\"inline\">key1=value1&amp;key2=value2...</code>, this function inserts each key-value pair in the query string as one entry in the given <code class=\"inline\">map</code>. Keys and values in the resulting map will be binaries. Keys and values will be percent-unescaped.</p> <p>Use <a href=\"#query_decoder/1\"><code class=\"inline\">query_decoder/1</code></a> if you want to iterate over each value manually.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.decode_query(\"foo=1&amp;bar=2\")\n%{\"bar\" =&gt; \"2\", \"foo\" =&gt; \"1\"}\n\niex&gt; URI.decode_query(\"percent=oh+yes%21\", %{\"starting\" =&gt; \"map\"})\n%{\"percent\" =&gt; \"oh yes!\", \"starting\" =&gt; \"map\"}</code></pre>    <h3 class=\"detail-header function\" id=\"decode_www_form/1\">  <span class=\"signature\">decode_www_form(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">decode_www_form(binary) :: binary</code></pre>    <p>Decodes a string as “x-www-form-urlencoded”.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.decode_www_form(\"%3Call+in%2F\")\n\"&lt;all in/\"</code></pre>    <h3 class=\"detail-header function\" id=\"default_port/1\">  <span class=\"signature\">default_port(scheme)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">default_port(binary) :: nil | pos_integer</code></pre>    <p>Returns the default port for a given scheme.</p> <p>If the scheme is unknown to the <a href=\"uri#content\"><code class=\"inline\">URI</code></a> module, this function returns <code class=\"inline\">nil</code>. The default port for any scheme can be configured globally via <a href=\"#default_port/2\"><code class=\"inline\">default_port/2</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.default_port(\"ftp\")\n21\n\niex&gt; URI.default_port(\"ponzi\")\nnil</code></pre>    <h3 class=\"detail-header function\" id=\"default_port/2\">  <span class=\"signature\">default_port(scheme, port)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">default_port(binary, pos_integer) :: :ok</code></pre>    <p>Registers the default port <code class=\"inline\">port</code> for the given <code class=\"inline\">scheme</code>.</p> <p>After this function is called, <code class=\"inline\">port</code> will be returned by <a href=\"#default_port/1\"><code class=\"inline\">default_port/1</code></a> for the given scheme <code class=\"inline\">scheme</code>. Note that this function changes the default port for the given <code class=\"inline\">scheme</code> <em>globally</em>, meaning for every application.</p> <p>It is recommended for this function to be invoked in your application’s start callback in case you want to register new URIs.</p>    <h3 class=\"detail-header function\" id=\"encode/2\">  <span class=\"signature\">encode(string, predicate \\\\ &amp;char_unescaped?/1)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">encode(binary, (byte -&gt; boolean)) :: binary</code></pre>    <p>Percent-escapes the given string.</p> <p>This function accepts a <code class=\"inline\">predicate</code> function as an optional argument; if passed, this function will be called with each character (byte) in <code class=\"inline\">str</code> as its argument and should return <code class=\"inline\">true</code> if that character should not be escaped and left as is.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.encode(\"ftp://s-ite.tld/?value=put it+й\")\n\"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n\niex&gt; URI.encode(\"a string\", &amp;(&amp;1 != ?i))\n\"a str%69ng\"</code></pre>    <h3 class=\"detail-header function\" id=\"encode_query/1\">  <span class=\"signature\">encode_query(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">encode_query(term) :: binary</code></pre>    <p>Encodes an enumerable into a query string.</p> <p>Takes an enumerable that enumerates as a list of two-element tuples (e.g., a map or a keyword list) and returns a string in the form of <code class=\"inline\">key1=value1&amp;key2=value2...</code> where keys and values are URL encoded as per <a href=\"#encode_www_form/1\"><code class=\"inline\">encode_www_form/1</code></a>.</p> <p>Keys and values can be any term that implements the <a href=\"string.chars\"><code class=\"inline\">String.Chars</code></a> protocol, except lists which are explicitly forbidden.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; hd = %{\"foo\" =&gt; 1, \"bar\" =&gt; 2}\niex&gt; URI.encode_query(hd)\n\"bar=2&amp;foo=1\"\n\niex&gt; query = %{\"key\" =&gt; \"value with spaces\"}\niex&gt; URI.encode_query(query)\n\"key=value+with+spaces\"\n\niex&gt; URI.encode_query %{key: [:a, :list]}\n** (ArgumentError) encode_query/1 values cannot be lists, got: [:a, :list]</code></pre>    <h3 class=\"detail-header function\" id=\"encode_www_form/1\">  <span class=\"signature\">encode_www_form(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">encode_www_form(binary) :: binary</code></pre>    <p>Encodes a string as “x-www-form-urlencoded”.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.encode_www_form(\"put: it+й\")\n\"put%3A+it%2B%D0%B9\"</code></pre>    <h3 class=\"detail-header function\" id=\"merge/2\">  <span class=\"signature\">merge(uri, rel)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">merge(<a href=\"#t:t/0\">t</a> | binary, <a href=\"#t:t/0\">t</a> | binary) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Merges two URIs.</p> <p>This function merges two URIs as per <a href=\"http://tools.ietf.org/html/rfc3986#section-5.2\">RFC 3986, section 5.2</a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.merge(URI.parse(\"http://google.com\"), \"/query\") |&gt; to_string\n\"http://google.com/query\"\n\niex&gt; URI.merge(\"http://example.com\", \"http://google.com\") |&gt; to_string\n\"http://google.com\"</code></pre>    <h3 class=\"detail-header function\" id=\"parse/1\">  <span class=\"signature\">parse(uri)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">parse(<a href=\"#t:t/0\">t</a> | binary) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Parses a well-formed URI reference into its components.</p> <p>Note this function expects a well-formed URI and does not perform any validation. See the “Examples” section below for examples of how <a href=\"uri#parse/1\"><code class=\"inline\">URI.parse/1</code></a> can be used to parse a wide range of URIs.</p> <p>This function uses the parsing regular expression as defined in <a href=\"http://tools.ietf.org/html/rfc3986#appendix-B\">RFC 3986, Appendix B</a>.</p> <p>When a URI is given without a port, the value returned by <a href=\"uri#default_port/1\"><code class=\"inline\">URI.default_port/1</code></a> for the URI’s scheme is used for the <code class=\"inline\">:port</code> field.</p> <p>If a <code class=\"inline\">%URI{}</code> struct is given to this function, this function returns it unmodified.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.parse(\"http://elixir-lang.org/\")\n%URI{scheme: \"http\", path: \"/\", query: nil, fragment: nil,\n     authority: \"elixir-lang.org\", userinfo: nil,\n     host: \"elixir-lang.org\", port: 80}\n\niex&gt; URI.parse(\"//elixir-lang.org/\")\n%URI{authority: \"elixir-lang.org\", fragment: nil, host: \"elixir-lang.org\",\n     path: \"/\", port: nil, query: nil, scheme: nil, userinfo: nil}\n\niex&gt; URI.parse(\"/foo/bar\")\n%URI{authority: nil, fragment: nil, host: nil, path: \"/foo/bar\",\n     port: nil, query: nil, scheme: nil, userinfo: nil}\n\niex&gt; URI.parse(\"foo/bar\")\n%URI{authority: nil, fragment: nil, host: nil, path: \"foo/bar\",\n     port: nil, query: nil, scheme: nil, userinfo: nil}</code></pre>    <h3 class=\"detail-header function\" id=\"path_to_segments/1\">  <span class=\"signature\">path_to_segments(path)</span>  </h3>     <h3 class=\"detail-header function\" id=\"query_decoder/1\">  <span class=\"signature\">query_decoder(query)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">query_decoder(binary) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Returns a stream of two-element tuples representing key-value pairs in the given <code class=\"inline\">query</code>.</p> <p>Key and value in each tuple will be binaries and will be percent-unescaped.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.query_decoder(\"foo=1&amp;bar=2\") |&gt; Enum.to_list()\n[{\"foo\", \"1\"}, {\"bar\", \"2\"}]</code></pre>    <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(uri)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_string(<a href=\"#t:t/0\">t</a>) :: binary</code></pre>    <p>Returns the string representation of the given <a href=\"uri#content\"><code class=\"inline\">URI</code></a> struct.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; URI.to_string(URI.parse(\"http://google.com\"))\n\"http://google.com\"\n\niex&gt; URI.to_string(%URI{scheme: \"foo\", host: \"bar.baz\"})\n\"foo://bar.baz\"</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/URI.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/URI.html</a>\n  </p>\n</div>\n","elixir/version":"<h1>  Version  </h1>  <p>Functions for parsing and matching versions against requirements.</p> <p>A version is a string in a specific format or a <a href=\"version#content\"><code class=\"inline\">Version</code></a> generated after parsing via <a href=\"version#parse/1\"><code class=\"inline\">Version.parse/1</code></a>.</p> <p><a href=\"version#content\"><code class=\"inline\">Version</code></a> parsing and requirements follow <a href=\"http://semver.org/\">SemVer 2.0 schema</a>.</p> <h2 id=\"module-versions\" class=\"section-heading\">  Versions </h2> <p>In a nutshell, a version is represented by three numbers:</p> <pre data-language=\"elixir\"><code class=\"elixir\">MAJOR.MINOR.PATCH</code></pre> <p>Pre-releases are supported by appending <code class=\"inline\">-[0-9A-Za-z-\\.]</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">\"1.0.0-alpha.3\"</code></pre> <p>Build information can be added by appending <code class=\"inline\">+[0-9A-Za-z-\\.]</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">\"1.0.0-alpha.3+20130417140000\"</code></pre> <h2 id=\"module-struct\" class=\"section-heading\">  Struct </h2> <p>The version is represented by the Version struct and fields are named according to Semver: <code class=\"inline\">:major</code>, <code class=\"inline\">:minor</code>, <code class=\"inline\">:patch</code>, <code class=\"inline\">:pre</code> and <code class=\"inline\">:build</code>.</p> <h2 id=\"module-requirements\" class=\"section-heading\">  Requirements </h2> <p>Requirements allow you to specify which versions of a given dependency you are willing to work against. It supports common operators like <code class=\"inline\">&gt;=</code>, <code class=\"inline\">&lt;=</code>, <code class=\"inline\">&gt;</code>, <code class=\"inline\">==</code> and friends that work as one would expect:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Only version 2.0.0\n\"== 2.0.0\"\n\n# Anything later than 2.0.0\n\"&gt; 2.0.0\"</code></pre> <p>Requirements also support <code class=\"inline\">and</code> and <code class=\"inline\">or</code> for complex conditions:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># 2.0.0 and later until 2.1.0\n\"&gt;= 2.0.0 and &lt; 2.1.0\"</code></pre> <p>Since the example above is such a common requirement, it can be expressed as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">\"~&gt; 2.0.0\"</code></pre> <p><code class=\"inline\">~&gt;</code> will never include pre-release versions of its upper bound. It can also be used to set an upper bound on only the major version part. See the table below for <code class=\"inline\">~&gt;</code> requirements and their corresponding translation.</p> <table> <colgroup> <col> <col> </colgroup> <thead> <tr> <th style=\"text-align: left\"><code class=\"inline\">~&gt;</code></th>\n<th style=\"text-align: left\">Translation</th> </tr> </thead> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.0.0</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">&gt;= 2.0.0 and &lt; 2.1.0</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.1.2</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">&gt;= 2.1.2 and &lt; 2.2.0</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.1.3-dev</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">&gt;= 2.1.3-dev and &lt; 2.2.0</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.0</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">&gt;= 2.0.0 and &lt; 3.0.0</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.1</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">&gt;= 2.1.0 and &lt; 3.0.0</code></td> </tr> </table> <p>When <code class=\"inline\">allow_pre: false</code> is set the requirement will not match a pre-release version unless the operand is a pre-release version. The default is to allow always allow pre-releases but note that in Hex <code class=\"inline\">:allow_pre</code> is set to <code class=\"inline\">false.</code> See the table below for examples.</p> <table> <colgroup> <col> <col> <col> <col> </colgroup> <thead> <tr> <th style=\"text-align: left\">Requirement</th>\n<th style=\"text-align: left\">Version</th>\n<th style=\"text-align: left\"><code class=\"inline\">:allow_pre</code></th>\n<th style=\"text-align: left\">Matches</th> </tr> </thead> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.0</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">2.1.0</code></td>\n<td style=\"text-align: left\">-</td>\n<td style=\"text-align: left\"><code class=\"inline\">true</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.0</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">3.0.0</code></td>\n<td style=\"text-align: left\">-</td>\n<td style=\"text-align: left\"><code class=\"inline\">false</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.0.0</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">2.0.1</code></td>\n<td style=\"text-align: left\">-</td>\n<td style=\"text-align: left\"><code class=\"inline\">true</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.0.0</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">2.1.0</code></td>\n<td style=\"text-align: left\">-</td>\n<td style=\"text-align: left\"><code class=\"inline\">false</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.1.2</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">2.1.3-dev</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">true</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">true</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.1.2</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">2.1.3-dev</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">false</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">false</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.1-dev</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">2.2.0-dev</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">false</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">true</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">~&gt; 2.1.2-dev</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">2.1.3-dev</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">false</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">true</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">&gt;= 2.1.0</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">2.2.0-dev</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">false</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">false</code></td> </tr> <tr> <td style=\"text-align: left\"><code class=\"inline\">&gt;= 2.1.0-dev</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">2.2.3-dev</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">true</code></td>\n<td style=\"text-align: left\"><code class=\"inline\">true</code></td> </tr> </table>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:build/0\">build()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:major/0\">major()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:matchable/0\">matchable()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:minor/0\">minor()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:patch/0\">patch()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:pre/0\">pre()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:requirement/0\">requirement()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:version/0\">version()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#compare/2\">compare(version1, version2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compares two versions. Returns <code class=\"inline\">:gt</code> if first version is greater than the second and <code class=\"inline\">:lt</code> for vice versa. If the two versions are equal <code class=\"inline\">:eq</code> is returned</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compile_requirement/1\">compile_requirement(req)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compiles a requirement to its internal representation with <a href=\"http://www.erlang.org/doc/man/ets.html#match_spec_compile-1\"><code class=\"inline\">:ets.match_spec_compile/1</code></a> for faster matching</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#match?/3\">match?(version, requirement, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the given version matches the specification</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#parse/1\">parse(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses a version string into a <a href=\"version#content\"><code class=\"inline\">Version</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#parse!/1\">parse!(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses a version string into a <a href=\"version#content\"><code class=\"inline\">Version</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#parse_requirement/1\">parse_requirement(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Parses a version requirement string into a <a href=\"version.requirement\"><code class=\"inline\">Version.Requirement</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:build/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:build/0\">build</a> :: <a href=\"string#t:t/0\">String.t</a> | nil</code></pre> </div> <div id=\"t:major/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:major/0\">major</a> :: <a href=\"string#t:t/0\">String.t</a> | non_neg_integer</code></pre> </div> <div id=\"t:matchable/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:matchable/0\">matchable</a> :: {major :: <a href=\"#t:major/0\">major</a>, minor :: <a href=\"#t:minor/0\">minor</a>, patch :: <a href=\"#t:patch/0\">patch</a>, pre :: <a href=\"#t:pre/0\">pre</a>}</code></pre> </div> <div id=\"t:minor/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:minor/0\">minor</a> :: non_neg_integer | nil</code></pre> </div> <div id=\"t:patch/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:patch/0\">patch</a> :: non_neg_integer | nil</code></pre> </div> <div id=\"t:pre/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:pre/0\">pre</a> :: [<a href=\"string#t:t/0\">String.t</a> | non_neg_integer]</code></pre> </div> <div id=\"t:requirement/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:requirement/0\">requirement</a> :: <a href=\"string#t:t/0\">String.t</a> | <a href=\"version.requirement#t:t/0\">Version.Requirement.t</a></code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: %Version{build: <a href=\"#t:build/0\">build</a>, major: <a href=\"#t:major/0\">major</a>, minor: <a href=\"#t:minor/0\">minor</a>, patch: <a href=\"#t:patch/0\">patch</a>, pre: <a href=\"#t:pre/0\">pre</a>}</code></pre> </div> <div id=\"t:version/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:version/0\">version</a> :: <a href=\"string#t:t/0\">String.t</a> | <a href=\"#t:t/0\">t</a></code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"compare/2\">  <span class=\"signature\">compare(version1, version2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">compare(<a href=\"#t:version/0\">version</a>, <a href=\"#t:version/0\">version</a>) :: :gt | :eq | :lt</code></pre>    <p>Compares two versions. Returns <code class=\"inline\">:gt</code> if first version is greater than the second and <code class=\"inline\">:lt</code> for vice versa. If the two versions are equal <code class=\"inline\">:eq</code> is returned</p> <p>Raises a <a href=\"version.invalidversionerror\"><code class=\"inline\">Version.InvalidVersionError</code></a> exception if <code class=\"inline\">version</code> is not parsable. If given an already parsed version this function won’t raise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Version.compare(\"2.0.1-alpha1\", \"2.0.0\")\n:gt\n\niex&gt; Version.compare(\"2.0.1+build0\", \"2.0.1\")\n:eq\n\niex&gt; Version.compare(\"invalid\", \"2.0.1\")\n** (Version.InvalidVersionError) invalid</code></pre>    <h3 class=\"detail-header function\" id=\"compile_requirement/1\">  <span class=\"signature\">compile_requirement(req)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">compile_requirement(<a href=\"version.requirement#t:t/0\">Version.Requirement.t</a>) :: <a href=\"version.requirement#t:t/0\">Version.Requirement.t</a></code></pre>    <p>Compiles a requirement to its internal representation with <a href=\"http://www.erlang.org/doc/man/ets.html#match_spec_compile-1\"><code class=\"inline\">:ets.match_spec_compile/1</code></a> for faster matching.</p> <p>The internal representation is opaque and can not be converted to external term format and then back again without losing its properties (meaning it can not be sent to a process on another node and still remain a valid compiled match_spec, nor can it be stored on disk).</p>    <h3 class=\"detail-header function\" id=\"match?/3\">  <span class=\"signature\">match?(version, requirement, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">match?(<a href=\"#t:version/0\">version</a>, <a href=\"#t:requirement/0\">requirement</a>, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: boolean</code></pre>    <p>Checks if the given version matches the specification.</p> <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">version</code> satisfies <code class=\"inline\">requirement</code>, <code class=\"inline\">false</code> otherwise. Raises a <a href=\"version.invalidrequirementerror\"><code class=\"inline\">Version.InvalidRequirementError</code></a> exception if <code class=\"inline\">requirement</code> is not parsable, or <a href=\"version.invalidversionerror\"><code class=\"inline\">Version.InvalidVersionError</code></a> if <code class=\"inline\">version</code> is not parsable. If given an already parsed version and requirement this function won’t raise.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:allow_pre</code> - when <code class=\"inline\">false</code> pre-release versions will not match unless the operand is a pre-release version, see the table above for examples (default: <code class=\"inline\">true</code>); </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Version.match?(\"2.0.0\", \"&gt;1.0.0\")\ntrue\n\niex&gt; Version.match?(\"2.0.0\", \"==1.0.0\")\nfalse\n\niex&gt; Version.match?(\"foo\", \"==1.0.0\")\n** (Version.InvalidVersionError) foo\n\niex&gt; Version.match?(\"2.0.0\", \"== ==1.0.0\")\n** (Version.InvalidRequirementError) == ==1.0.0</code></pre>    <h3 class=\"detail-header function\" id=\"parse/1\">  <span class=\"signature\">parse(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">parse(<a href=\"string#t:t/0\">String.t</a>) :: {:ok, <a href=\"#t:t/0\">t</a>} | :error</code></pre>    <p>Parses a version string into a <a href=\"version#content\"><code class=\"inline\">Version</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; {:ok, version} = Version.parse(\"2.0.1-alpha1\")\niex&gt; version\n#Version&lt;2.0.1-alpha1&gt;\n\niex&gt; Version.parse(\"2.0-alpha1\")\n:error</code></pre>    <h3 class=\"detail-header function\" id=\"parse!/1\">  <span class=\"signature\">parse!(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">parse!(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"#t:t/0\">t</a> | no_return</code></pre>    <p>Parses a version string into a <a href=\"version#content\"><code class=\"inline\">Version</code></a>.</p> <p>If <code class=\"inline\">string</code> is an invalid version, an <code class=\"inline\">InvalidVersionError</code> is raised.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Version.parse!(\"2.0.1-alpha1\")\n#Version&lt;2.0.1-alpha1&gt;\n\niex&gt; Version.parse!(\"2.0-alpha1\")\n** (Version.InvalidVersionError) 2.0-alpha1</code></pre>    <h3 class=\"detail-header function\" id=\"parse_requirement/1\">  <span class=\"signature\">parse_requirement(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">parse_requirement(<a href=\"string#t:t/0\">String.t</a>) ::\n  {:ok, <a href=\"version.requirement#t:t/0\">Version.Requirement.t</a>} |\n  :error</code></pre>    <p>Parses a version requirement string into a <a href=\"version.requirement\"><code class=\"inline\">Version.Requirement</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; {:ok, req} = Version.parse_requirement(\"== 2.0.1\")\niex&gt; req\n#Version.Requirement&lt;== 2.0.1&gt;\n\niex&gt; Version.parse_requirement(\"== == 2.0.1\")\n:error</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Version.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Version.html</a>\n  </p>\n</div>\n","elixir/badarityerror":"<h1>  BadArityError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/BadArityError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/BadArityError.html</a>\n  </p>\n</div>\n","elixir/badfunctionerror":"<h1>  BadFunctionError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/BadFunctionError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/BadFunctionError.html</a>\n  </p>\n</div>\n","elixir/badmaperror":"<h1>  BadMapError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/BadMapError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/BadMapError.html</a>\n  </p>\n</div>\n","elixir/badstructerror":"<h1>  BadStructError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/BadStructError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/BadStructError.html</a>\n  </p>\n</div>\n","elixir/stream":"<h1>  Stream  </h1>  <p>Module for creating and composing streams.</p> <p>Streams are composable, lazy enumerables. Any enumerable that generates items one by one during enumeration is called a stream. For example, Elixir’s <a href=\"range\"><code class=\"inline\">Range</code></a> is a stream:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; range = 1..5\n1..5\niex&gt; Enum.map range, &amp;(&amp;1 * 2)\n[2, 4, 6, 8, 10]</code></pre> <p>In the example above, as we mapped over the range, the elements being enumerated were created one by one, during enumeration. The <a href=\"stream#content\"><code class=\"inline\">Stream</code></a> module allows us to map the range, without triggering its enumeration:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; range = 1..3\niex&gt; stream = Stream.map(range, &amp;(&amp;1 * 2))\niex&gt; Enum.map(stream, &amp;(&amp;1 + 1))\n[3, 5, 7]</code></pre> <p>Notice we started with a range and then we created a stream that is meant to multiply each item in the range by 2. At this point, no computation was done. Only when <a href=\"enum#map/2\"><code class=\"inline\">Enum.map/2</code></a> is called we actually enumerate over each item in the range, multiplying it by 2 and adding 1. We say the functions in <a href=\"stream#content\"><code class=\"inline\">Stream</code></a> are <em>lazy</em> and the functions in <a href=\"enum\"><code class=\"inline\">Enum</code></a> are <em>eager</em>.</p> <p>Due to their laziness, streams are useful when working with large (or even infinite) collections. When chaining many operations with <a href=\"enum\"><code class=\"inline\">Enum</code></a>, intermediate lists are created, while <a href=\"stream#content\"><code class=\"inline\">Stream</code></a> creates a recipe of computations that are executed at a later moment. Let’s see another example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">1..3\n|&gt; Enum.map(&amp;IO.inspect(&amp;1))\n|&gt; Enum.map(&amp;(&amp;1 * 2))\n|&gt; Enum.map(&amp;IO.inspect(&amp;1))\n1\n2\n3\n2\n4\n6\n#=&gt; [2, 4, 6]</code></pre> <p>Notice that we first printed each item in the list, then multiplied each element by 2 and finally printed each new value. In this example, the list was enumerated three times. Let’s see an example with streams:</p> <pre data-language=\"elixir\"><code class=\"elixir\">stream = 1..3\n|&gt; Stream.map(&amp;IO.inspect(&amp;1))\n|&gt; Stream.map(&amp;(&amp;1 * 2))\n|&gt; Stream.map(&amp;IO.inspect(&amp;1))\nEnum.to_list(stream)\n1\n2\n2\n4\n3\n6\n#=&gt; [2, 4, 6]</code></pre> <p>Although the end result is the same, the order in which the items were printed changed! With streams, we print the first item and then print its double. In this example, the list was enumerated just once!</p> <p>That’s what we meant when we said earlier that streams are composable, lazy enumerables. Notice we could call <a href=\"stream#map/2\"><code class=\"inline\">Stream.map/2</code></a> multiple times, effectively composing the streams and keeping them lazy. The computations are only performed when you call a function from the <a href=\"enum\"><code class=\"inline\">Enum</code></a> module.</p> <h2 id=\"module-creating-streams\" class=\"section-heading\">  Creating Streams </h2> <p>There are many functions in Elixir’s standard library that return streams, some examples are:</p> <ul> <li>\n<a href=\"io#stream/2\"><code class=\"inline\">IO.stream/2</code></a> - streams input lines, one by one </li> <li>\n<a href=\"uri#query_decoder/1\"><code class=\"inline\">URI.query_decoder/1</code></a> - decodes a query string, pair by pair </li> </ul> <p>This module also provides many convenience functions for creating streams, like <a href=\"stream#cycle/1\"><code class=\"inline\">Stream.cycle/1</code></a>, <a href=\"stream#unfold/2\"><code class=\"inline\">Stream.unfold/2</code></a>, <a href=\"stream#resource/3\"><code class=\"inline\">Stream.resource/3</code></a> and more.</p> <p>Note the functions in this module are guaranteed to return enumerables. Since enumerables can have different shapes (structs, anonymous functions, and so on), the functions in this module may return any of those shapes and that this may change at any time. For example, a function that today returns an anonymous function may return a struct in future releases.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:acc/0\">acc()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:default/0\">default()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:element/0\">element()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:index/0\">index()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#chunk/2\">chunk(enum, n)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Shortcut to <code class=\"inline\">chunk(enum, n, n)</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chunk/4\">chunk(enum, n, step, leftover \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Streams the enumerable in chunks, containing <code class=\"inline\">n</code> items each, where each new chunk starts <code class=\"inline\">step</code> elements into the enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chunk_by/2\">chunk_by(enum, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Chunks the <code class=\"inline\">enum</code> by buffering elements for which <code class=\"inline\">fun</code> returns the same value and only emit them when <code class=\"inline\">fun</code> returns a new value or the <code class=\"inline\">enum</code> finishes</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#concat/1\">concat(enumerables)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that enumerates each enumerable in an enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#concat/2\">concat(first, second)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that enumerates the first argument, followed by the second</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cycle/1\">cycle(enumerable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that cycles through the given enumerable, infinitely</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dedup/1\">dedup(enum)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that only emits elements if they are different from the last emitted element</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#dedup_by/2\">dedup_by(enum, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that only emits elements if the result of calling <code class=\"inline\">fun</code> on the element is different from the (stored) result of calling <code class=\"inline\">fun</code> on the last emitted element</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#drop/2\">drop(enum, n)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Lazily drops the next <code class=\"inline\">n</code> items from the enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#drop_every/2\">drop_every(enum, nth)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that drops every <code class=\"inline\">nth</code> item from the enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#drop_while/2\">drop_while(enum, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Lazily drops elements of the enumerable while the given function returns <code class=\"inline\">true</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#each/2\">each(enum, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Executes the given function for each item</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#filter/2\">filter(enum, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that filters elements according to the given function on enumeration</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#filter_map/3\">filter_map(enum, filter, mapper)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that filters and then maps elements according to given functions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#flat_map/2\">flat_map(enum, mapper)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that will apply the given function on enumeration and flatten the result, but only one level deep</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#interval/1\">interval(n)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that emits a value after the given period <code class=\"inline\">n</code> in milliseconds</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#into/3\">into(enum, collectable, transform \\\\ fn x -&gt; x end)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Injects the stream values into the given collectable as a side-effect</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#iterate/2\">iterate(start_value, next_fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Emits a sequence of values, starting with <code class=\"inline\">start_value</code>. Successive values are generated by calling <code class=\"inline\">next_fun</code> on the previous value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#map/2\">map(enum, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that will apply the given function on enumeration</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reject/2\">reject(enum, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that will reject elements according to the given function on enumeration</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#repeatedly/1\">repeatedly(generator_fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a stream generated by calling <code class=\"inline\">generator_fun</code> repeatedly</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#resource/3\">resource(start_fun, next_fun, after_fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Emits a sequence of values for the given resource</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#run/1\">run(stream)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Runs the given stream</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#scan/2\">scan(enum, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#scan/3\">scan(enum, acc, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation. Uses the given <code class=\"inline\">acc</code> as the starting value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#take/2\">take(enum, count)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Lazily takes the next <code class=\"inline\">count</code> items from the enumerable and stops enumeration</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#take_every/2\">take_every(enum, nth)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that takes every <code class=\"inline\">nth</code> item from the enumerable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#take_while/2\">take_while(enum, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Lazily takes elements of the enumerable while the given function returns <code class=\"inline\">true</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#timer/1\">timer(n)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that emits a single value after <code class=\"inline\">n</code> milliseconds</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#transform/3\">transform(enum, acc, reducer)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Transforms an existing stream</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#transform/4\">transform(enum, start_fun, reducer, after_fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Transforms an existing stream with function-based start and finish</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unfold/2\">unfold(next_acc, next_fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Emits a sequence of values for the given accumulator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#uniq/2\">uniq(enum, fun \\\\ fn x -&gt; x end)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream that only emits elements if they are unique</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#with_index/2\">with_index(enum, offset \\\\ 0)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a stream where each item in the enumerable will be wrapped in a tuple alongside its index</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#zip/2\">zip(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Zips two collections together, lazily</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:acc/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:acc/0\">acc</a> :: any</code></pre> </div> <div id=\"t:default/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:default/0\">default</a> :: any</code></pre> </div> <div id=\"t:element/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:element/0\">element</a> :: any</code></pre> </div> <div id=\"t:index/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:index/0\">index</a> :: non_neg_integer</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"chunk/2\">  <span class=\"signature\">chunk(enum, n)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chunk(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, non_neg_integer) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Shortcut to <code class=\"inline\">chunk(enum, n, n)</code>.</p>    <h3 class=\"detail-header function\" id=\"chunk/4\">  <span class=\"signature\">chunk(enum, n, step, leftover \\\\ nil)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chunk(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, pos_integer, pos_integer, <a href=\"enumerable#t:t/0\">Enumerable.t</a> | nil) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Streams the enumerable in chunks, containing <code class=\"inline\">n</code> items each, where each new chunk starts <code class=\"inline\">step</code> elements into the enumerable.</p> <p><code class=\"inline\">step</code> is optional and, if not passed, defaults to <code class=\"inline\">n</code>, i.e. chunks do not overlap. If the final chunk does not have <code class=\"inline\">n</code> elements to fill the chunk, elements are taken as necessary from <code class=\"inline\">leftover</code> if it was passed. If <code class=\"inline\">leftover</code> is passed and does not have enough elements to fill the chunk, then the chunk is returned anyway with less than <code class=\"inline\">n</code> elements. If <code class=\"inline\">leftover</code> is not passed at all or is <code class=\"inline\">nil</code>, then the partial chunk is discarded from the result.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Stream.chunk([1, 2, 3, 4, 5, 6], 2) |&gt; Enum.to_list\n[[1, 2], [3, 4], [5, 6]]\n\niex&gt; Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2) |&gt; Enum.to_list\n[[1, 2, 3], [3, 4, 5]]\n\niex&gt; Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7]) |&gt; Enum.to_list\n[[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\niex&gt; Stream.chunk([1, 2, 3, 4, 5, 6], 3, 3, []) |&gt; Enum.to_list\n[[1, 2, 3], [4, 5, 6]]</code></pre>    <h3 class=\"detail-header function\" id=\"chunk_by/2\">  <span class=\"signature\">chunk_by(enum, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chunk_by(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (<a href=\"#t:element/0\">element</a> -&gt; any)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Chunks the <code class=\"inline\">enum</code> by buffering elements for which <code class=\"inline\">fun</code> returns the same value and only emit them when <code class=\"inline\">fun</code> returns a new value or the <code class=\"inline\">enum</code> finishes.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &amp;(rem(&amp;1, 2) == 1))\niex&gt; Enum.to_list(stream)\n[[1], [2, 2], [3], [4, 4, 6], [7, 7]]</code></pre>    <h3 class=\"detail-header function\" id=\"concat/1\">  <span class=\"signature\">concat(enumerables)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">concat(<a href=\"enumerable#t:t/0\">Enumerable.t</a>) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that enumerates each enumerable in an enumerable.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.concat([1..3, 4..6, 7..9])\niex&gt; Enum.to_list(stream)\n[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>    <h3 class=\"detail-header function\" id=\"concat/2\">  <span class=\"signature\">concat(first, second)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">concat(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, <a href=\"enumerable#t:t/0\">Enumerable.t</a>) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that enumerates the first argument, followed by the second.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.concat(1..3, 4..6)\niex&gt; Enum.to_list(stream)\n[1, 2, 3, 4, 5, 6]\n\niex&gt; stream1 = Stream.cycle([1, 2, 3])\niex&gt; stream2 = Stream.cycle([4, 5, 6])\niex&gt; stream = Stream.concat(stream1, stream2)\niex&gt; Enum.take(stream, 6)\n[1, 2, 3, 1, 2, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"cycle/1\">  <span class=\"signature\">cycle(enumerable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cycle(<a href=\"enumerable#t:t/0\">Enumerable.t</a>) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that cycles through the given enumerable, infinitely.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.cycle([1, 2, 3])\niex&gt; Enum.take(stream, 5)\n[1, 2, 3, 1, 2]</code></pre>    <h3 class=\"detail-header function\" id=\"dedup/1\">  <span class=\"signature\">dedup(enum)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">dedup(<a href=\"enumerable#t:t/0\">Enumerable.t</a>) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that only emits elements if they are different from the last emitted element.</p> <p>This function only ever needs to store the last emitted element.</p> <p>Elements are compared using <code class=\"inline\">===</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Stream.dedup([1, 2, 3, 3, 2, 1]) |&gt; Enum.to_list\n[1, 2, 3, 2, 1]</code></pre>    <h3 class=\"detail-header function\" id=\"dedup_by/2\">  <span class=\"signature\">dedup_by(enum, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">dedup_by(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (<a href=\"#t:element/0\">element</a> -&gt; term)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that only emits elements if the result of calling <code class=\"inline\">fun</code> on the element is different from the (stored) result of calling <code class=\"inline\">fun</code> on the last emitted element.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -&gt; x end) |&gt; Enum.to_list\n[{1, :x}, {2, :y}, {1, :x}]</code></pre>    <h3 class=\"detail-header function\" id=\"drop/2\">  <span class=\"signature\">drop(enum, n)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">drop(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, non_neg_integer) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Lazily drops the next <code class=\"inline\">n</code> items from the enumerable.</p> <p>If a negative <code class=\"inline\">n</code> is given, it will drop the last <code class=\"inline\">n</code> items from the collection. Note that the mechanism by which this is implemented will delay the emission of any item until <code class=\"inline\">n</code> additional items have been emitted by the enum.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.drop(1..10, 5)\niex&gt; Enum.to_list(stream)\n[6, 7, 8, 9, 10]\n\niex&gt; stream = Stream.drop(1..10, -5)\niex&gt; Enum.to_list(stream)\n[1, 2, 3, 4, 5]</code></pre>    <h3 class=\"detail-header function\" id=\"drop_every/2\">  <span class=\"signature\">drop_every(enum, nth)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">drop_every(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, non_neg_integer) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that drops every <code class=\"inline\">nth</code> item from the enumerable.</p> <p>The first item is always dropped, unless <code class=\"inline\">nth</code> is 0.</p> <p><code class=\"inline\">nth</code> must be a non-negative integer, or <a href=\"functionclauseerror\"><code class=\"inline\">FunctionClauseError</code></a> will be thrown.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.drop_every(1..10, 2)\niex&gt; Enum.to_list(stream)\n[2, 4, 6, 8, 10]\n\niex&gt; stream = Stream.drop_every(1..1000, 1)\niex&gt; Enum.to_list(stream)\n[]\n\niex&gt; stream = Stream.drop_every([1, 2, 3, 4, 5], 0)\niex&gt; Enum.to_list(stream)\n[1, 2, 3, 4, 5]</code></pre>    <h3 class=\"detail-header function\" id=\"drop_while/2\">  <span class=\"signature\">drop_while(enum, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">drop_while(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term))) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Lazily drops elements of the enumerable while the given function returns <code class=\"inline\">true</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.drop_while(1..10, &amp;(&amp;1 &lt;= 5))\niex&gt; Enum.to_list(stream)\n[6, 7, 8, 9, 10]</code></pre>    <h3 class=\"detail-header function\" id=\"each/2\">  <span class=\"signature\">each(enum, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">each(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (<a href=\"#t:element/0\">element</a> -&gt; term)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Executes the given function for each item.</p> <p>Useful for adding side effects (like printing) to a stream.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.each([1, 2, 3], fn(x) -&gt; send self, x end)\niex&gt; Enum.to_list(stream)\niex&gt; receive do: (x when is_integer(x) -&gt; x)\n1\niex&gt; receive do: (x when is_integer(x) -&gt; x)\n2\niex&gt; receive do: (x when is_integer(x) -&gt; x)\n3</code></pre>    <h3 class=\"detail-header function\" id=\"filter/2\">  <span class=\"signature\">filter(enum, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">filter(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term))) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that filters elements according to the given function on enumeration.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.filter([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)\niex&gt; Enum.to_list(stream)\n[2]</code></pre>    <h3 class=\"detail-header function\" id=\"filter_map/3\">  <span class=\"signature\">filter_map(enum, filter, mapper)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">filter_map(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term)), (<a href=\"#t:element/0\">element</a> -&gt; any)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that filters and then maps elements according to given functions.</p> <p>Exists for symmetry with <a href=\"enum#filter_map/3\"><code class=\"inline\">Enum.filter_map/3</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.filter_map(1..6, fn(x) -&gt; rem(x, 2) == 0 end, &amp;(&amp;1 * 2))\niex&gt; Enum.to_list(stream)\n[4, 8, 12]</code></pre>    <h3 class=\"detail-header function\" id=\"flat_map/2\">  <span class=\"signature\">flat_map(enum, mapper)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">flat_map(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (<a href=\"#t:element/0\">element</a> -&gt; <a href=\"enumerable#t:t/0\">Enumerable.t</a>)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that will apply the given function on enumeration and flatten the result, but only one level deep.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.flat_map([1, 2, 3], fn(x) -&gt; [x, x * 2] end)\niex&gt; Enum.to_list(stream)\n[1, 2, 2, 4, 3, 6]\n\niex&gt; stream = Stream.flat_map([1, 2, 3], fn(x) -&gt; [[x]] end)\niex&gt; Enum.to_list(stream)\n[[1], [2], [3]]</code></pre>    <h3 class=\"detail-header function\" id=\"interval/1\">  <span class=\"signature\">interval(n)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">interval(non_neg_integer) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that emits a value after the given period <code class=\"inline\">n</code> in milliseconds.</p> <p>The values emitted are an increasing counter starting at <code class=\"inline\">0</code>. This operation will block the caller by the given interval every time a new item is streamed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Stream.interval(10) |&gt; Enum.take(10)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>    <h3 class=\"detail-header function\" id=\"into/3\">  <span class=\"signature\">into(enum, collectable, transform \\\\ fn x -&gt; x end)</span>  </h3>  <p>Injects the stream values into the given collectable as a side-effect.</p> <p>This function is often used with <a href=\"#run/1\"><code class=\"inline\">run/1</code></a> since any evaluation is delayed until the stream is executed. See <a href=\"#run/1\"><code class=\"inline\">run/1</code></a> for an example.</p>    <h3 class=\"detail-header function\" id=\"iterate/2\">  <span class=\"signature\">iterate(start_value, next_fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">iterate(<a href=\"#t:element/0\">element</a>, (<a href=\"#t:element/0\">element</a> -&gt; <a href=\"#t:element/0\">element</a>)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Emits a sequence of values, starting with <code class=\"inline\">start_value</code>. Successive values are generated by calling <code class=\"inline\">next_fun</code> on the previous value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Stream.iterate(0, &amp;(&amp;1+1)) |&gt; Enum.take(5)\n[0, 1, 2, 3, 4]</code></pre>    <h3 class=\"detail-header function\" id=\"map/2\">  <span class=\"signature\">map(enum, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">map(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (<a href=\"#t:element/0\">element</a> -&gt; any)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that will apply the given function on enumeration.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.map([1, 2, 3], fn(x) -&gt; x * 2 end)\niex&gt; Enum.to_list(stream)\n[2, 4, 6]</code></pre>    <h3 class=\"detail-header function\" id=\"reject/2\">  <span class=\"signature\">reject(enum, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reject(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term))) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that will reject elements according to the given function on enumeration.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.reject([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)\niex&gt; Enum.to_list(stream)\n[1, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"repeatedly/1\">  <span class=\"signature\">repeatedly(generator_fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">repeatedly((() -&gt; <a href=\"#t:element/0\">element</a>)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Returns a stream generated by calling <code class=\"inline\">generator_fun</code> repeatedly.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># Although not necessary, let's seed the random algorithm\niex&gt; :rand.seed(:exsplus, {1, 2, 3})\niex&gt; Stream.repeatedly(&amp;:rand.uniform/0) |&gt; Enum.take(3)\n[0.40502929729990744, 0.45336720247823126, 0.04094511692041057]</code></pre>    <h3 class=\"detail-header function\" id=\"resource/3\">  <span class=\"signature\">resource(start_fun, next_fun, after_fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">resource((() -&gt; <a href=\"#t:acc/0\">acc</a>), (<a href=\"#t:acc/0\">acc</a> -&gt; {[<a href=\"#t:element/0\">element</a>], <a href=\"#t:acc/0\">acc</a>} | {:halt, <a href=\"#t:acc/0\">acc</a>}), (<a href=\"#t:acc/0\">acc</a> -&gt; term)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Emits a sequence of values for the given resource.</p> <p>Similar to <a href=\"#transform/3\"><code class=\"inline\">transform/3</code></a> but the initial accumulated value is computed lazily via <code class=\"inline\">start_fun</code> and executes an <code class=\"inline\">after_fun</code> at the end of enumeration (both in cases of success and failure).</p> <p>Successive values are generated by calling <code class=\"inline\">next_fun</code> with the previous accumulator (the initial value being the result returned by <code class=\"inline\">start_fun</code>) and it must return a tuple containing a list of items to be emitted and the next accumulator. The enumeration finishes if it returns <code class=\"inline\">{:halt, acc}</code>.</p> <p>As the name says, this function is useful to stream values from resources.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Stream.resource(fn -&gt; File.open!(\"sample\") end,\n                fn file -&gt;\n                  case IO.read(file, :line) do\n                    data when is_binary(data) -&gt; {[data], file}\n                    _ -&gt; {:halt, file}\n                  end\n                end,\n                fn file -&gt; File.close(file) end)</code></pre>    <h3 class=\"detail-header function\" id=\"run/1\">  <span class=\"signature\">run(stream)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">run(<a href=\"enumerable#t:t/0\">Enumerable.t</a>) :: :ok</code></pre>    <p>Runs the given stream.</p> <p>This is useful when a stream needs to be run, for side effects, and there is no interest in its return result.</p> <h4>Examples</h4> <p>Open up a file, replace all <code class=\"inline\">#</code> by <code class=\"inline\">%</code> and stream to another file without loading the whole file in memory:</p> <pre data-language=\"elixir\"><code class=\"elixir\">stream = File.stream!(\"code\")\n|&gt; Stream.map(&amp;String.replace(&amp;1, \"#\", \"%\"))\n|&gt; Stream.into(File.stream!(\"new\"))\n|&gt; Stream.run</code></pre> <p>No computation will be done until we call one of the Enum functions or <a href=\"stream#run/1\"><code class=\"inline\">Stream.run/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"scan/2\">  <span class=\"signature\">scan(enum, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">scan(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (<a href=\"#t:element/0\">element</a>, <a href=\"#t:acc/0\">acc</a> -&gt; any)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.scan(1..5, &amp;(&amp;1 + &amp;2))\niex&gt; Enum.to_list(stream)\n[1, 3, 6, 10, 15]</code></pre>    <h3 class=\"detail-header function\" id=\"scan/3\">  <span class=\"signature\">scan(enum, acc, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">scan(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, <a href=\"#t:acc/0\">acc</a>, (<a href=\"#t:element/0\">element</a>, <a href=\"#t:acc/0\">acc</a> -&gt; any)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation. Uses the given <code class=\"inline\">acc</code> as the starting value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.scan(1..5, 0, &amp;(&amp;1 + &amp;2))\niex&gt; Enum.to_list(stream)\n[1, 3, 6, 10, 15]</code></pre>    <h3 class=\"detail-header function\" id=\"take/2\">  <span class=\"signature\">take(enum, count)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">take(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, integer) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Lazily takes the next <code class=\"inline\">count</code> items from the enumerable and stops enumeration.</p> <p>If a negative <code class=\"inline\">count</code> is given, the last <code class=\"inline\">count</code> values will be taken. For such, the collection is fully enumerated keeping up to <code class=\"inline\">2 * count</code> elements in memory. Once the end of the collection is reached, the last <code class=\"inline\">count</code> elements will be executed. Therefore, using a negative <code class=\"inline\">count</code> on an infinite collection will never return.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.take(1..100, 5)\niex&gt; Enum.to_list(stream)\n[1, 2, 3, 4, 5]\n\niex&gt; stream = Stream.take(1..100, -5)\niex&gt; Enum.to_list(stream)\n[96, 97, 98, 99, 100]\n\niex&gt; stream = Stream.cycle([1, 2, 3]) |&gt; Stream.take(5)\niex&gt; Enum.to_list(stream)\n[1, 2, 3, 1, 2]</code></pre>    <h3 class=\"detail-header function\" id=\"take_every/2\">  <span class=\"signature\">take_every(enum, nth)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">take_every(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, non_neg_integer) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that takes every <code class=\"inline\">nth</code> item from the enumerable.</p> <p>The first item is always included, unless <code class=\"inline\">nth</code> is 0.</p> <p><code class=\"inline\">nth</code> must be a non-negative integer, or <a href=\"functionclauseerror\"><code class=\"inline\">FunctionClauseError</code></a> will be thrown.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.take_every(1..10, 2)\niex&gt; Enum.to_list(stream)\n[1, 3, 5, 7, 9]\n\niex&gt; stream = Stream.take_every([1, 2, 3, 4, 5], 1)\niex&gt; Enum.to_list(stream)\n[1, 2, 3, 4, 5]\n\niex&gt; stream = Stream.take_every(1..1000, 0)\niex&gt; Enum.to_list(stream)\n[]</code></pre>    <h3 class=\"detail-header function\" id=\"take_while/2\">  <span class=\"signature\">take_while(enum, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">take_while(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (<a href=\"#t:element/0\">element</a> -&gt; as_boolean(term))) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Lazily takes elements of the enumerable while the given function returns <code class=\"inline\">true</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.take_while(1..100, &amp;(&amp;1 &lt;= 5))\niex&gt; Enum.to_list(stream)\n[1, 2, 3, 4, 5]</code></pre>    <h3 class=\"detail-header function\" id=\"timer/1\">  <span class=\"signature\">timer(n)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">timer(non_neg_integer) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that emits a single value after <code class=\"inline\">n</code> milliseconds.</p> <p>The value emitted is <code class=\"inline\">0</code>. This operation will block the caller by the given time until the item is streamed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Stream.timer(10) |&gt; Enum.to_list\n[0]</code></pre>    <h3 class=\"detail-header function\" id=\"transform/3\">  <span class=\"signature\">transform(enum, acc, reducer)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">transform(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, acc, fun) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a> when fun: (<a href=\"#t:element/0\">element</a>, acc -&gt; {<a href=\"enumerable#t:t/0\">Enumerable.t</a>, acc} | {:halt, acc}), acc: any</code></pre>    <p>Transforms an existing stream.</p> <p>It expects an accumulator and a function that receives each stream item and an accumulator, and must return a tuple containing a new stream (often a list) with the new accumulator or a tuple with <code class=\"inline\">:halt</code> as first element and the accumulator as second.</p> <p>Note: this function is similar to <a href=\"enum#flat_map_reduce/3\"><code class=\"inline\">Enum.flat_map_reduce/3</code></a> except the latter returns both the flat list and accumulator, while this one returns only the stream.</p> <h4>Examples</h4> <p><a href=\"stream#transform/3\"><code class=\"inline\">Stream.transform/3</code></a> is useful as it can be used as the basis to implement many of the functions defined in this module. For example, we can implement <code class=\"inline\">Stream.take(enum, n)</code> as follows:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; enum = 1..100\niex&gt; n = 3\niex&gt; stream = Stream.transform(enum, 0, fn i, acc -&gt;\n...&gt;   if acc &lt; n, do: {[i], acc + 1}, else: {:halt, acc}\n...&gt; end)\niex&gt; Enum.to_list(stream)\n[1, 2, 3]</code></pre>    <h3 class=\"detail-header function\" id=\"transform/4\">  <span class=\"signature\">transform(enum, start_fun, reducer, after_fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">transform(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (() -&gt; acc), fun, (acc -&gt; term)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a> when fun: (<a href=\"#t:element/0\">element</a>, acc -&gt; {<a href=\"enumerable#t:t/0\">Enumerable.t</a>, acc} | {:halt, acc}), acc: any</code></pre>    <p>Transforms an existing stream with function-based start and finish.</p> <p>The accumulator is only calculated when transformation starts. It also allows an after function to be given which is invoked when the stream halts or completes.</p> <p>This function can be seen as a combination of <a href=\"stream#resource/3\"><code class=\"inline\">Stream.resource/3</code></a> with <a href=\"stream#transform/3\"><code class=\"inline\">Stream.transform/3</code></a>.</p>    <h3 class=\"detail-header function\" id=\"unfold/2\">  <span class=\"signature\">unfold(next_acc, next_fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unfold(<a href=\"#t:acc/0\">acc</a>, (<a href=\"#t:acc/0\">acc</a> -&gt; {<a href=\"#t:element/0\">element</a>, <a href=\"#t:acc/0\">acc</a>} | nil)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Emits a sequence of values for the given accumulator.</p> <p>Successive values are generated by calling <code class=\"inline\">next_fun</code> with the previous accumulator and it must return a tuple with the current value and next accumulator. The enumeration finishes if it returns <code class=\"inline\">nil</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Stream.unfold(5, fn 0 -&gt; nil; n -&gt; {n, n-1} end) |&gt; Enum.to_list()\n[5, 4, 3, 2, 1]</code></pre>    <h3 class=\"detail-header function\" id=\"uniq/2\">  <span class=\"signature\">uniq(enum, fun \\\\ fn x -&gt; x end)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">uniq(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, (<a href=\"#t:element/0\">element</a> -&gt; term)) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream that only emits elements if they are unique.</p> <p>Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of items stored will grow infinitely, never being garbage collected.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Stream.uniq([1, 2, 3, 3, 2, 1]) |&gt; Enum.to_list\n[1, 2, 3]\n\niex&gt; Stream.uniq([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -&gt; x end) |&gt; Enum.to_list\n[{1, :x}, {2, :y}]</code></pre>    <h3 class=\"detail-header function\" id=\"with_index/2\">  <span class=\"signature\">with_index(enum, offset \\\\ 0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">with_index(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, integer) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Creates a stream where each item in the enumerable will be wrapped in a tuple alongside its index.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; stream = Stream.with_index([1, 2, 3])\niex&gt; Enum.to_list(stream)\n[{1, 0}, {2, 1}, {3, 2}]\n\niex&gt; stream = Stream.with_index([1, 2, 3], 3)\niex&gt; Enum.to_list(stream)\n[{1, 3}, {2, 4}, {3, 5}]</code></pre>    <h3 class=\"detail-header function\" id=\"zip/2\">  <span class=\"signature\">zip(left, right)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">zip(<a href=\"enumerable#t:t/0\">Enumerable.t</a>, <a href=\"enumerable#t:t/0\">Enumerable.t</a>) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Zips two collections together, lazily.</p> <p>The zipping finishes as soon as any enumerable completes.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; concat = Stream.concat(1..3, 4..6)\niex&gt; cycle  = Stream.cycle([:a, :b, :c])\niex&gt; Stream.zip(concat, cycle) |&gt; Enum.to_list\n[{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Stream.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Stream.html</a>\n  </p>\n</div>\n","elixir/system":"<h1>  System  </h1>  <p>The <a href=\"system#content\"><code class=\"inline\">System</code></a> module provides functions that interact directly with the VM or the host system.</p> <h2 id=\"module-time\" class=\"section-heading\">  Time </h2> <p>The <a href=\"system#content\"><code class=\"inline\">System</code></a> module also provides functions that work with time, returning different times kept by the system with support for different time units.</p> <p>One of the complexities in relying on system times is that they may be adjusted. For example, when you enter and leave daylight saving time, the system clock will be adjusted, often adding or removing one hour. We call such changes “time warps”. In order to understand how such changes may be harmful, imagine the following code:</p> <pre data-language=\"elixir\"><code class=\"elixir\">## DO NOT DO THIS\nprev = System.os_time()\n# ... execute some code ...\nnext = System.os_time()\ndiff = next - prev</code></pre> <p>If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via <a href=\"system#monotonic_time/0\"><code class=\"inline\">System.monotonic_time/0</code></a> which never decreases and does not leap:</p> <pre data-language=\"elixir\"><code class=\"elixir\">## DO THIS\nprev = System.monotonic_time()\n# ... execute some code ...\nnext = System.monotonic_time()\ndiff = next - prev</code></pre> <p>Generally speaking, the VM provides three time measurements:</p> <ul> <li>\n<p><a href=\"#os_time/0\"><code class=\"inline\">os_time/0</code></a> - the time reported by the OS. This time may be adjusted forwards or backwards in time with no limitation;</p> </li> <li>\n<p><a href=\"#system_time/0\"><code class=\"inline\">system_time/0</code></a> - the VM view of the <a href=\"#os_time/0\"><code class=\"inline\">os_time/0</code></a>. The system time and OS time may not match in case of time warps although the VM works towards aligning them. This time is not monotonic (i.e., it may decrease) as its behaviour is configured <a href=\"http://www.erlang.org/doc/apps/erts/time_correction.html#Time_Warp_Modes\">by the VM time warp mode</a>;</p> </li> <li>\n<a href=\"#monotonic_time/0\"><code class=\"inline\">monotonic_time/0</code></a> - a monotonically increasing time provided by the Erlang VM. </li> </ul> <p>The time functions in this module work in the <code class=\"inline\">:native</code> unit (unless specified otherwise), which is OS dependent. Most of the time, all calculations are done in the <code class=\"inline\">:native</code> unit, to avoid loss of precision, with <a href=\"#convert_time_unit/3\"><code class=\"inline\">convert_time_unit/3</code></a> being invoked at the end to convert to a specific time unit like milliseconds or microseconds. See the <code class=\"inline\">t:time_unit/0</code> type for more information.</p> <p>For a more complete rundown on the VM support for different times, see the <a href=\"http://www.erlang.org/doc/apps/erts/time_correction.html\">chapter on time and time correction</a> in the Erlang docs.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:time_unit/0\">time_unit()</a> </dt> <dd class=\"summary-synopsis\">\n<p>The time unit to be passed to functions like <a href=\"#monotonic_time/1\"><code class=\"inline\">monotonic_time/1</code></a> and others</p> </dd>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#argv/0\">argv()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Lists command line arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#argv/1\">argv(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Modifies command line arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#at_exit/1\">at_exit(fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Registers a program exit handler function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#build_info/0\">build_info()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Elixir build information</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cmd/3\">cmd(command, args, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Executes the given <code class=\"inline\">command</code> with <code class=\"inline\">args</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compiled_endianness/0\">compiled_endianness()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the endianness the system was compiled with</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#convert_time_unit/3\">convert_time_unit(time, from_unit, to_unit)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts <code class=\"inline\">time</code> from time unit <code class=\"inline\">from_unit</code> to time unit <code class=\"inline\">to_unit</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cwd/0\">cwd()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Current working directory</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cwd!/0\">cwd!()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Current working directory, exception on error</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#delete_env/1\">delete_env(varname)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deletes an environment variable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#endianness/0\">endianness()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the endianness</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#find_executable/1\">find_executable(program)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Locates an executable on the system</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_env/0\">get_env()</a> </dt> <dd class=\"summary-synopsis\">\n<p>System environment variables</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_env/1\">get_env(varname)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Environment variable value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_pid/0\">get_pid()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Erlang VM process identifier</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#halt/1\">halt(status \\\\ 0)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Halts the Erlang runtime system</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#monotonic_time/0\">monotonic_time()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current monotonic time in the <code class=\"inline\">:native</code> time unit</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#monotonic_time/1\">monotonic_time(unit)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current monotonic time in the given time unit</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#os_time/0\">os_time()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current OS time</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#os_time/1\">os_time(unit)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current OS time in the given time <code class=\"inline\">unit</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#otp_release/0\">otp_release()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the OTP release number</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_env/1\">put_env(enum)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets multiple environment variables</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_env/2\">put_env(varname, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sets an environment variable value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#schedulers/0\">schedulers()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the number of schedulers in the VM</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#schedulers_online/0\">schedulers_online()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the number of schedulers online in the VM</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#stacktrace/0\">stacktrace()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Last exception stacktrace</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#system_time/0\">system_time()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current system time in the <code class=\"inline\">:native</code> time unit</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#system_time/1\">system_time(unit)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current system time in the given time unit</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#time_offset/0\">time_offset()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current time offset between the Erlang VM monotonic time and the Erlang VM system time</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#time_offset/1\">time_offset(unit)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the current time offset between the Erlang VM monotonic time and the Erlang VM system time</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#tmp_dir/0\">tmp_dir()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Writable temporary directory</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#tmp_dir!/0\">tmp_dir!()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Writable temporary directory, exception on error</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unique_integer/1\">unique_integer(modifiers \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Generates and returns an integer that is unique in the current runtime instance</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#user_home/0\">user_home()</a> </dt> <dd class=\"summary-synopsis\">\n<p>User home directory</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#user_home!/0\">user_home!()</a> </dt> <dd class=\"summary-synopsis\">\n<p>User home directory, exception on error</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#version/0\">version()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Elixir version information</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:time_unit/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:time_unit/0\">time_unit</a> ::\n  :seconds |\n  :milliseconds |\n  :microseconds |\n  :nanoseconds |\n  pos_integer</code></pre> <p>The time unit to be passed to functions like <a href=\"#monotonic_time/1\"><code class=\"inline\">monotonic_time/1</code></a> and others.</p> <p>The <code class=\"inline\">:seconds</code>, <code class=\"inline\">:milliseconds</code>, <code class=\"inline\">:microseconds</code> and <code class=\"inline\">:nanoseconds</code> time units controls the return value of the functions that accept a time unit.</p> <p>A time unit can also be a strictly positive integer. In this case, it represents the “parts per second”: the time will be returned in <code class=\"inline\">1 /\nparts_per_second</code> seconds. For example, using the <code class=\"inline\">:milliseconds</code> time unit is equivalent to using <code class=\"inline\">1000</code> as the time unit (as the time will be returned in 1/1000 seconds - milliseconds).</p> <p>Keep in mind the Erlang API will use <code class=\"inline\">:milli_seconds</code>, <code class=\"inline\">:micro_seconds</code> and <code class=\"inline\">:nano_seconds</code> as time units although Elixir normalizes their spelling to match the SI convention.</p>  </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"argv/0\">  <span class=\"signature\">argv()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">argv :: [<a href=\"string#t:t/0\">String.t</a>]</code></pre>    <p>Lists command line arguments.</p> <p>Returns the list of command line arguments passed to the program.</p>    <h3 class=\"detail-header function\" id=\"argv/1\">  <span class=\"signature\">argv(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">argv([<a href=\"string#t:t/0\">String.t</a>]) :: :ok</code></pre>    <p>Modifies command line arguments.</p> <p>Changes the list of command line arguments. Use it with caution, as it destroys any previous argv information.</p>    <h3 class=\"detail-header function\" id=\"at_exit/1\">  <span class=\"signature\">at_exit(fun)</span>  </h3>  <p>Registers a program exit handler function.</p> <p>Registers a function that will be invoked at the end of program execution. Useful for invoking a hook in “script” mode.</p> <p>The handler always executes in a different process from the one it was registered in. As a consequence, any resources managed by the calling process (ETS tables, open files, etc.) won’t be available by the time the handler function is invoked.</p> <p>The function must receive the exit status code as an argument.</p>    <h3 class=\"detail-header function\" id=\"build_info/0\">  <span class=\"signature\">build_info()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">build_info :: map</code></pre>    <p>Elixir build information.</p> <p>Returns a keyword list with Elixir version, Git short revision hash and compilation date.</p>    <h3 class=\"detail-header function\" id=\"cmd/3\">  <span class=\"signature\">cmd(command, args, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">cmd(binary, [binary], <a href=\"keyword#t:t/0\">Keyword.t</a>) :: {<a href=\"collectable#t:t/0\">Collectable.t</a>, exit_status :: non_neg_integer}</code></pre>    <p>Executes the given <code class=\"inline\">command</code> with <code class=\"inline\">args</code>.</p> <p><code class=\"inline\">command</code> is expected to be an executable available in PATH unless an absolute path is given.</p> <p><code class=\"inline\">args</code> must be a list of binaries which the executable will receive as its arguments as is. This means that:</p> <ul> <li>environment variables will not be interpolated </li> <li>wildcard expansion will not happen (unless <a href=\"path#wildcard/2\"><code class=\"inline\">Path.wildcard/2</code></a> is used explicitly) </li> <li>arguments do not need to be escaped or quoted for shell safety </li> </ul> <p>This function returns a tuple containing the collected result and the command exit status.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; System.cmd \"echo\", [\"hello\"]\n{\"hello\\n\", 0}\n\niex&gt; System.cmd \"echo\", [\"hello\"], env: [{\"MIX_ENV\", \"test\"}]\n{\"hello\\n\", 0}\n\niex&gt; System.cmd \"echo\", [\"hello\"], into: IO.stream(:stdio, :line)\nhello\n{%IO.Stream{}, 0}</code></pre> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:into</code> - injects the result into the given collectable, defaults to <code class=\"inline\">\"\"</code> </li> <li>\n<code class=\"inline\">:cd</code> - the directory to run the command in </li> <li>\n<code class=\"inline\">:env</code> - an enumerable of tuples containing environment key-value as binary </li> <li>\n<code class=\"inline\">:arg0</code> - set the command arg0 </li> <li>\n<code class=\"inline\">:stderr_to_stdout</code> - redirects stderr to stdout when <code class=\"inline\">true</code> </li> <li>\n<code class=\"inline\">:parallelism</code> - when <code class=\"inline\">true</code>, the VM will schedule port tasks to improve parallelism in the system. If set to <code class=\"inline\">false</code>, the VM will try to perform commands immediately, improving latency at the expense of parallelism. The default can be set on system startup by passing the “+spp” argument to <code class=\"inline\">--erl</code>. </li> </ul> <h4>Error reasons</h4> <p>If invalid arguments are given, <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> is raised by <a href=\"system#cmd/3\"><code class=\"inline\">System.cmd/3</code></a>. <a href=\"system#cmd/3\"><code class=\"inline\">System.cmd/3</code></a> also expects a strict set of options and will raise if unknown or invalid options are given.</p> <p>Furthermore, <a href=\"system#cmd/3\"><code class=\"inline\">System.cmd/3</code></a> may fail with one of the POSIX reasons detailed below:</p> <ul> <li>\n<p><code class=\"inline\">:system_limit</code> - all available ports in the Erlang emulator are in use</p> </li> <li>\n<p><code class=\"inline\">:enomem</code> - there was not enough memory to create the port</p> </li> <li>\n<p><code class=\"inline\">:eagain</code> - there are no more available operating system processes</p> </li> <li>\n<p><code class=\"inline\">:enametoolong</code> - the external command given was too long</p> </li> <li>\n<p><code class=\"inline\">:emfile</code> - there are no more available file descriptors (for the operating system process that the Erlang emulator runs in)</p> </li> <li>\n<p><code class=\"inline\">:enfile</code> - the file table is full (for the entire operating system)</p> </li> <li>\n<p><code class=\"inline\">:eacces</code> - the command does not point to an executable file</p> </li> <li>\n<code class=\"inline\">:enoent</code> - the command does not point to an existing file </li> </ul> <h4>Shell commands</h4> <p>If you desire to execute a trusted command inside a shell, with pipes, redirecting and so on, please check <a href=\"http://www.erlang.org/doc/man/os.html#cmd-1\"><code class=\"inline\">:os.cmd/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"compiled_endianness/0\">  <span class=\"signature\">compiled_endianness()</span>  </h3>  <p>Returns the endianness the system was compiled with.</p>    <h3 class=\"detail-header function\" id=\"convert_time_unit/3\">  <span class=\"signature\">convert_time_unit(time, from_unit, to_unit)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">convert_time_unit(integer, <a href=\"#t:time_unit/0\">time_unit</a> | :native, <a href=\"#t:time_unit/0\">time_unit</a> | :native) :: integer</code></pre>    <p>Converts <code class=\"inline\">time</code> from time unit <code class=\"inline\">from_unit</code> to time unit <code class=\"inline\">to_unit</code>.</p> <p>The result is rounded via the floor function.</p> <p><a href=\"#convert_time_unit/3\"><code class=\"inline\">convert_time_unit/3</code></a> accepts an additional time unit (other than the ones in the <code class=\"inline\">time_unit</code> type) called <code class=\"inline\">:native</code>. <code class=\"inline\">:native</code> is the time unit used by the Erlang runtime system. It’s determined when the runtime starts and stays the same until the runtime is stopped. To determine what the <code class=\"inline\">:native</code> unit amounts to in a system, you can call this function to convert 1 second to the <code class=\"inline\">:native</code> time unit (i.e., <code class=\"inline\">System.convert_time_unit(1, :seconds, :native)</code>).</p>    <h3 class=\"detail-header function\" id=\"cwd/0\">  <span class=\"signature\">cwd()</span>  </h3>  <p>Current working directory.</p> <p>Returns the current working directory or <code class=\"inline\">nil</code> if one is not available.</p>    <h3 class=\"detail-header function\" id=\"cwd!/0\">  <span class=\"signature\">cwd!()</span>  </h3>  <p>Current working directory, exception on error.</p> <p>Returns the current working directory or raises <a href=\"runtimeerror\"><code class=\"inline\">RuntimeError</code></a>.</p>    <h3 class=\"detail-header function\" id=\"delete_env/1\">  <span class=\"signature\">delete_env(varname)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">delete_env(<a href=\"string#t:t/0\">String.t</a>) :: :ok</code></pre>    <p>Deletes an environment variable.</p> <p>Removes the variable <code class=\"inline\">varname</code> from the environment.</p>    <h3 class=\"detail-header function\" id=\"endianness/0\">  <span class=\"signature\">endianness()</span>  </h3>  <p>Returns the endianness.</p>    <h3 class=\"detail-header function\" id=\"find_executable/1\">  <span class=\"signature\">find_executable(program)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">find_executable(binary) :: binary | nil</code></pre>    <p>Locates an executable on the system.</p> <p>This function looks up an executable program given its name using the environment variable PATH on Unix and Windows. It also considers the proper executable extension for each OS, so for Windows it will try to lookup files with <code class=\"inline\">.com</code>, <code class=\"inline\">.cmd</code> or similar extensions.</p>    <h3 class=\"detail-header function\" id=\"get_env/0\">  <span class=\"signature\">get_env()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_env :: %{optional(<a href=\"string#t:t/0\">String.t</a>) =&gt; <a href=\"string#t:t/0\">String.t</a>}</code></pre>    <p>System environment variables.</p> <p>Returns a list of all environment variables. Each variable is given as a <code class=\"inline\">{name, value}</code> tuple where both <code class=\"inline\">name</code> and <code class=\"inline\">value</code> are strings.</p>    <h3 class=\"detail-header function\" id=\"get_env/1\">  <span class=\"signature\">get_env(varname)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_env(binary) :: binary | nil</code></pre>    <p>Environment variable value.</p> <p>Returns the value of the environment variable <code class=\"inline\">varname</code> as a binary, or <code class=\"inline\">nil</code> if the environment variable is undefined.</p>    <h3 class=\"detail-header function\" id=\"get_pid/0\">  <span class=\"signature\">get_pid()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_pid :: binary</code></pre>    <p>Erlang VM process identifier.</p> <p>Returns the process identifier of the current Erlang emulator in the format most commonly used by the operating system environment.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/os.html#getpid-0\"><code class=\"inline\">:os.getpid/0</code></a>.</p>    <h3 class=\"detail-header function\" id=\"halt/1\">  <span class=\"signature\">halt(status \\\\ 0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">halt(non_neg_integer | binary | :abort) :: no_return</code></pre>    <p>Halts the Erlang runtime system.</p> <p>Halts the Erlang runtime system where the argument <code class=\"inline\">status</code> must be a non-negative integer, the atom <code class=\"inline\">:abort</code> or a binary.</p> <ul> <li>\n<p>If an integer, the runtime system exits with the integer value which is returned to the operating system.</p> </li> <li>\n<p>If <code class=\"inline\">:abort</code>, the runtime system aborts producing a core dump, if that is enabled in the operating system.</p> </li> <li>If a string, an Erlang crash dump is produced with status as slogan, and then the runtime system exits with status code 1. </li> </ul> <p>Note that on many platforms, only the status codes 0-255 are supported by the operating system.</p> <p>For more information, see <a href=\"http://www.erlang.org/doc/man/erlang.html#halt-1\"><code class=\"inline\">:erlang.halt/1</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">System.halt(0)\nSystem.halt(1)\nSystem.halt(:abort)</code></pre>    <h3 class=\"detail-header function\" id=\"monotonic_time/0\">  <span class=\"signature\">monotonic_time()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">monotonic_time :: integer</code></pre>    <p>Returns the current monotonic time in the <code class=\"inline\">:native</code> time unit.</p> <p>This time is monotonically increasing and starts in an unspecified point in time.</p> <p>Inlined by the compiler into <a href=\"http://www.erlang.org/doc/man/erlang.html#monotonic_time-0\"><code class=\"inline\">:erlang.monotonic_time/0</code></a>.</p>    <h3 class=\"detail-header function\" id=\"monotonic_time/1\">  <span class=\"signature\">monotonic_time(unit)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">monotonic_time(<a href=\"#t:time_unit/0\">time_unit</a>) :: integer</code></pre>    <p>Returns the current monotonic time in the given time unit.</p> <p>This time is monotonically increasing and starts in an unspecified point in time.</p>    <h3 class=\"detail-header function\" id=\"os_time/0\">  <span class=\"signature\">os_time()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">os_time :: integer</code></pre>    <p>Returns the current OS time.</p> <p>The result is returned in the <code class=\"inline\">:native</code> time unit.</p> <p>This time may be adjusted forwards or backwards in time with no limitation and is not monotonic.</p> <p>Inlined by the compiler into <a href=\"http://www.erlang.org/doc/man/os.html#system_time-0\"><code class=\"inline\">:os.system_time/0</code></a>.</p>    <h3 class=\"detail-header function\" id=\"os_time/1\">  <span class=\"signature\">os_time(unit)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">os_time(<a href=\"#t:time_unit/0\">time_unit</a>) :: integer</code></pre>    <p>Returns the current OS time in the given time <code class=\"inline\">unit</code>.</p> <p>This time may be adjusted forwards or backwards in time with no limitation and is not monotonic.</p>    <h3 class=\"detail-header function\" id=\"otp_release/0\">  <span class=\"signature\">otp_release()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">otp_release :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Returns the OTP release number.</p>    <h3 class=\"detail-header function\" id=\"put_env/1\">  <span class=\"signature\">put_env(enum)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_env(<a href=\"enumerable#t:t/0\">Enumerable.t</a>) :: :ok</code></pre>    <p>Sets multiple environment variables.</p> <p>Sets a new value for each environment variable corresponding to each key in <code class=\"inline\">dict</code>.</p>    <h3 class=\"detail-header function\" id=\"put_env/2\">  <span class=\"signature\">put_env(varname, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_env(binary, binary) :: :ok</code></pre>    <p>Sets an environment variable value.</p> <p>Sets a new <code class=\"inline\">value</code> for the environment variable <code class=\"inline\">varname</code>.</p>    <h3 class=\"detail-header function\" id=\"schedulers/0\">  <span class=\"signature\">schedulers()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">schedulers :: pos_integer</code></pre>    <p>Returns the number of schedulers in the VM.</p>    <h3 class=\"detail-header function\" id=\"schedulers_online/0\">  <span class=\"signature\">schedulers_online()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">schedulers_online :: pos_integer</code></pre>    <p>Returns the number of schedulers online in the VM.</p>    <h3 class=\"detail-header function\" id=\"stacktrace/0\">  <span class=\"signature\">stacktrace()</span>  </h3>  <p>Last exception stacktrace.</p> <p>Note that the Erlang VM (and therefore this function) does not return the current stacktrace but rather the stacktrace of the latest exception.</p> <p>Inlined by the compiler into <a href=\"http://www.erlang.org/doc/man/erlang.html#get_stacktrace-0\"><code class=\"inline\">:erlang.get_stacktrace/0</code></a>.</p>    <h3 class=\"detail-header function\" id=\"system_time/0\">  <span class=\"signature\">system_time()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">system_time :: integer</code></pre>    <p>Returns the current system time in the <code class=\"inline\">:native</code> time unit.</p> <p>It is the VM view of the <a href=\"#os_time/0\"><code class=\"inline\">os_time/0</code></a>. They may not match in case of time warps although the VM works towards aligning them. This time is not monotonic.</p> <p>Inlined by the compiler into <a href=\"http://www.erlang.org/doc/man/erlang.html#system_time-0\"><code class=\"inline\">:erlang.system_time/0</code></a>.</p>    <h3 class=\"detail-header function\" id=\"system_time/1\">  <span class=\"signature\">system_time(unit)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">system_time(<a href=\"#t:time_unit/0\">time_unit</a>) :: integer</code></pre>    <p>Returns the current system time in the given time unit.</p> <p>It is the VM view of the <a href=\"#os_time/0\"><code class=\"inline\">os_time/0</code></a>. They may not match in case of time warps although the VM works towards aligning them. This time is not monotonic.</p>    <h3 class=\"detail-header function\" id=\"time_offset/0\">  <span class=\"signature\">time_offset()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">time_offset :: integer</code></pre>    <p>Returns the current time offset between the Erlang VM monotonic time and the Erlang VM system time.</p> <p>The result is returned in the <code class=\"inline\">:native</code> time unit.</p> <p>See <a href=\"#time_offset/1\"><code class=\"inline\">time_offset/1</code></a> for more information.</p> <p>Inlined by the compiler into <a href=\"http://www.erlang.org/doc/man/erlang.html#time_offset-0\"><code class=\"inline\">:erlang.time_offset/0</code></a>.</p>    <h3 class=\"detail-header function\" id=\"time_offset/1\">  <span class=\"signature\">time_offset(unit)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">time_offset(<a href=\"#t:time_unit/0\">time_unit</a>) :: integer</code></pre>    <p>Returns the current time offset between the Erlang VM monotonic time and the Erlang VM system time.</p> <p>The result is returned in the given time unit <code class=\"inline\">unit</code>. The returned offset, added to an Erlang monotonic time (e.g., obtained with <a href=\"#monotonic_time/1)\"><code class=\"inline\">monotonic_time/1</code></a>, gives the Erlang system time that corresponds to that monotonic time.</p>    <h3 class=\"detail-header function\" id=\"tmp_dir/0\">  <span class=\"signature\">tmp_dir()</span>  </h3>  <p>Writable temporary directory.</p> <p>Returns a writable temporary directory. Searches for directories in the following order:</p> <ol> <li>the directory named by the TMPDIR environment variable </li> <li>the directory named by the TEMP environment variable </li> <li>the directory named by the TMP environment variable </li> <li>\n<code class=\"inline\">C:\\TMP</code> on Windows or <code class=\"inline\">/tmp</code> on Unix </li> <li>as a last resort, the current working directory </li> </ol> <p>Returns <code class=\"inline\">nil</code> if none of the above are writable.</p>    <h3 class=\"detail-header function\" id=\"tmp_dir!/0\">  <span class=\"signature\">tmp_dir!()</span>  </h3>  <p>Writable temporary directory, exception on error.</p> <p>Same as <a href=\"#tmp_dir/0\"><code class=\"inline\">tmp_dir/0</code></a> but raises <a href=\"runtimeerror\"><code class=\"inline\">RuntimeError</code></a> instead of returning <code class=\"inline\">nil</code> if no temp dir is set.</p>    <h3 class=\"detail-header function\" id=\"unique_integer/1\">  <span class=\"signature\">unique_integer(modifiers \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">unique_integer([:positive | :monotonic]) :: integer</code></pre>    <p>Generates and returns an integer that is unique in the current runtime instance.</p> <p>“Unique” means that this function, called with the same list of <code class=\"inline\">modifiers</code>, will never return the same integer more than once on the current runtime instance.</p> <p>If <code class=\"inline\">modifiers</code> is <code class=\"inline\">[]</code>, then a unique integer (that can be positive or negative) is returned. Other modifiers can be passed to change the properties of the returned integer:</p> <ul> <li>\n<code class=\"inline\">:positive</code> - the returned integer is guaranteed to be positive. </li> <li>\n<code class=\"inline\">:monotonic</code> - the returned integer is monotonically increasing. This means that, on the same runtime instance (but even on different processes), integers returned using the <code class=\"inline\">:monotonic</code> modifier will always be strictly less than integers returned by successive calls with the <code class=\"inline\">:monotonic</code> modifier. </li> </ul> <p>All modifiers listed above can be combined; repeated modifiers in <code class=\"inline\">modifiers</code> will be ignored.</p> <p>Inlined by the compiler into <a href=\"http://www.erlang.org/doc/man/erlang.html#unique_integer-1\"><code class=\"inline\">:erlang.unique_integer/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"user_home/0\">  <span class=\"signature\">user_home()</span>  </h3>  <p>User home directory.</p> <p>Returns the user home directory (platform independent).</p>    <h3 class=\"detail-header function\" id=\"user_home!/0\">  <span class=\"signature\">user_home!()</span>  </h3>  <p>User home directory, exception on error.</p> <p>Same as <a href=\"#user_home/0\"><code class=\"inline\">user_home/0</code></a> but raises <a href=\"runtimeerror\"><code class=\"inline\">RuntimeError</code></a> instead of returning <code class=\"inline\">nil</code> if no user home is set.</p>    <h3 class=\"detail-header function\" id=\"version/0\">  <span class=\"signature\">version()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">version :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Elixir version information.</p> <p>Returns Elixir’s version as binary.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/System.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/System.html</a>\n  </p>\n</div>\n","elixir/caseclauseerror":"<h1>  CaseClauseError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/CaseClauseError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/CaseClauseError.html</a>\n  </p>\n</div>\n","elixir/code.loaderror":"<h1>  Code.LoadError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Code.LoadError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Code.LoadError.html</a>\n  </p>\n</div>\n","elixir/compileerror":"<h1>  CompileError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(map)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(map)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/CompileError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/CompileError.html</a>\n  </p>\n</div>\n","elixir/condclauseerror":"<h1>  CondClauseError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/CondClauseError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/CondClauseError.html</a>\n  </p>\n</div>\n","elixir/enum.emptyerror":"<h1>  Enum.EmptyError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Enum.EmptyError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Enum.EmptyError.html</a>\n  </p>\n</div>\n","elixir/enum.outofboundserror":"<h1>  Enum.OutOfBoundsError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Enum.OutOfBoundsError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Enum.OutOfBoundsError.html</a>\n  </p>\n</div>\n","elixir/erlangerror":"<h1>  ErlangError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/ErlangError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/ErlangError.html</a>\n  </p>\n</div>\n","elixir/file.copyerror":"<h1>  File.CopyError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/File.CopyError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/File.CopyError.html</a>\n  </p>\n</div>\n","elixir/file.error":"<h1>  File.Error <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/File.Error.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/File.Error.html</a>\n  </p>\n</div>\n","elixir/functionclauseerror":"<h1>  FunctionClauseError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/FunctionClauseError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/FunctionClauseError.html</a>\n  </p>\n</div>\n","elixir/io.streamerror":"<h1>  IO.StreamError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/IO.StreamError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/IO.StreamError.html</a>\n  </p>\n</div>\n","elixir/inspect.error":"<h1>  Inspect.Error <small>exception</small>  </h1>  <p>Raised when a struct cannot be inspected.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Inspect.Error.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Inspect.Error.html</a>\n  </p>\n</div>\n","elixir/keyerror":"<h1>  KeyError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/KeyError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/KeyError.html</a>\n  </p>\n</div>\n","elixir/matcherror":"<h1>  MatchError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/MatchError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/MatchError.html</a>\n  </p>\n</div>\n","elixir/optionparser.parseerror":"<h1>  OptionParser.ParseError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/OptionParser.ParseError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/OptionParser.ParseError.html</a>\n  </p>\n</div>\n","elixir/protocol.undefinederror":"<h1>  Protocol.UndefinedError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Protocol.UndefinedError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Protocol.UndefinedError.html</a>\n  </p>\n</div>\n","elixir/regex.compileerror":"<h1>  Regex.CompileError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Regex.CompileError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Regex.CompileError.html</a>\n  </p>\n</div>\n","elixir/runtimeerror":"<h1>  RuntimeError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/RuntimeError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/RuntimeError.html</a>\n  </p>\n</div>\n","elixir/syntaxerror":"<h1>  SyntaxError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/SyntaxError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/SyntaxError.html</a>\n  </p>\n</div>\n","elixir/systemlimiterror":"<h1>  SystemLimitError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message()</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/SystemLimitError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/SystemLimitError.html</a>\n  </p>\n</div>\n","elixir/tokenmissingerror":"<h1>  TokenMissingError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(map)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(map)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/TokenMissingError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/TokenMissingError.html</a>\n  </p>\n</div>\n","elixir/tryclauseerror":"<h1>  TryClauseError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/TryClauseError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/TryClauseError.html</a>\n  </p>\n</div>\n","elixir/undefinedfunctionerror":"<h1>  UndefinedFunctionError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(e)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(e)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/UndefinedFunctionError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/UndefinedFunctionError.html</a>\n  </p>\n</div>\n","elixir/unicodeconversionerror":"<h1>  UnicodeConversionError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/UnicodeConversionError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/UnicodeConversionError.html</a>\n  </p>\n</div>\n","elixir/version.invalidrequirementerror":"<h1>  Version.InvalidRequirementError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Version.InvalidRequirementError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Version.InvalidRequirementError.html</a>\n  </p>\n</div>\n","elixir/version.invalidversionerror":"<h1>  Version.InvalidVersionError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"string#t:t/0\">String.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"exception#t:t/0\">Exception.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Version.InvalidVersionError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Version.InvalidVersionError.html</a>\n  </p>\n</div>\n","elixir/string":"<h1>  String  </h1>  <p>A String in Elixir is a UTF-8 encoded binary.</p> <h2 id=\"module-codepoints-and-graphemes\" class=\"section-heading\">  Codepoints and graphemes </h2> <p>The functions in this module act according to the Unicode Standard, version 6.3.0.</p> <p>As per the standard, a codepoint is a single Unicode Character, which may be represented by one or more bytes.</p> <p>For example, the codepoint “é” is two bytes:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; byte_size(\"é\")\n2</code></pre> <p>However, this module returns the proper length:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.length(\"é\")\n1</code></pre> <p>Furthermore, this module also presents the concept of graphemes. A single grapheme can consist of multiple codepoints that may be perceived as a single character by readers. For example, the “é” grapheme can be represented either as a single “e with acute” codepoint (like above), or as the letter “e” followed by a “combining acute accent” (two codepoints):</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; string = \"\\u0065\\u0301\"\niex&gt; byte_size(string)\n3\niex&gt; String.length(string)\n1\niex&gt; String.codepoints(string)\n[\"e\", \"́\"]\niex&gt; String.graphemes(string)\n[\"é\"]</code></pre> <p>Although the example above is made of two characters, it is perceived by users as one.</p> <p>Graphemes can also be two characters that are interpreted as one by some languages. For example, some languages may consider “ch” as a grapheme. However, since this information depends on the locale, it is not taken into account by this module.</p> <p>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour.</p> <p>More information about graphemes can be found in the <a href=\"http://www.unicode.org/reports/tr29/\">Unicode Standard Annex #29</a>. The current Elixir version implements Extended Grapheme Cluster algorithm.</p> <h2 id=\"module-string-and-binary-operations\" class=\"section-heading\">  String and binary operations </h2> <p>To act according to the Unicode Standard, many functions in this module run in linear time, as they need to traverse the whole string considering the proper Unicode codepoints.</p> <p>For example, <a href=\"string#length/1\"><code class=\"inline\">String.length/1</code></a> will take longer as the input grows. On the other hand, <a href=\"kernel#byte_size/1\"><code class=\"inline\">Kernel.byte_size/1</code></a> always runs in constant time (i.e. regardless of the input size).</p> <p>This means often there are performance costs in using the functions in this module, compared to the more low-level operations that work directly with binaries:</p> <ul> <li>\n<a href=\"kernel#binary_part/3\"><code class=\"inline\">Kernel.binary_part/3</code></a> - retrieves part of the binary </li> <li>\n<a href=\"kernel#bit_size/1\"><code class=\"inline\">Kernel.bit_size/1</code></a> and <a href=\"kernel#byte_size/1\"><code class=\"inline\">Kernel.byte_size/1</code></a> - size related functions </li> <li>\n<a href=\"kernel#is_bitstring/1\"><code class=\"inline\">Kernel.is_bitstring/1</code></a> and <a href=\"kernel#is_binary/1\"><code class=\"inline\">Kernel.is_binary/1</code></a> - type checking function </li> <li>Plus a number of functions for working with binaries (bytes) in the <a href=\"http://www.erlang.org/doc/man/binary.html\"><code class=\"inline\">:binary</code> module</a> </li> </ul> <p>There are many situations where using the <a href=\"string#content\"><code class=\"inline\">String</code></a> module can be avoided in favor of binary functions or pattern matching. For example, imagine you have a string <code class=\"inline\">prefix</code> and you want to remove this prefix from another string named <code class=\"inline\">full</code>.</p> <p>One may be tempted to write:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; take_prefix = fn full, prefix -&gt;\n...&gt;   base = String.length(prefix)\n...&gt;   String.slice(full, base, String.length(full) - base)\n...&gt; end\niex&gt; take_prefix.(\"Mr. John\", \"Mr. \")\n\"John\"</code></pre> <p>Although the function above works, it performs poorly. To calculate the length of the string, we need to traverse it fully, so we traverse both <code class=\"inline\">prefix</code> and <code class=\"inline\">full</code> strings, then slice the <code class=\"inline\">full</code> one, traversing it again.</p> <p>A first attempt at improving it could be with ranges:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; take_prefix = fn full, prefix -&gt;\n...&gt;   base = String.length(prefix)\n...&gt;   String.slice(full, base..-1)\n...&gt; end\niex&gt; take_prefix.(\"Mr. John\", \"Mr. \")\n\"John\"</code></pre> <p>While this is much better (we don’t traverse <code class=\"inline\">full</code> twice), it could still be improved. In this case, since we want to extract a substring from a string, we can use <code class=\"inline\">byte_size/1</code> and <code class=\"inline\">binary_part/3</code> as there is no chance we will slice in the middle of a codepoint made of more than one byte:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; take_prefix = fn full, prefix -&gt;\n...&gt;   base = byte_size(prefix)\n...&gt;   binary_part(full, base, byte_size(full) - base)\n...&gt; end\niex&gt; take_prefix.(\"Mr. John\", \"Mr. \")\n\"John\"</code></pre> <p>Or simply use pattern matching:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; take_prefix = fn full, prefix -&gt;\n...&gt;   base = byte_size(prefix)\n...&gt;   &lt;&lt;_::binary-size(base), rest::binary&gt;&gt; = full\n...&gt;   rest\n...&gt; end\niex&gt; take_prefix.(\"Mr. John\", \"Mr. \")\n\"John\"</code></pre> <p>On the other hand, if you want to dynamically slice a string based on an integer value, then using <a href=\"string#slice/3\"><code class=\"inline\">String.slice/3</code></a> is the best option as it guarantees we won’t incorrectly split a valid codepoint into multiple bytes.</p> <h2 id=\"module-integer-codepoints\" class=\"section-heading\">  Integer codepoints </h2> <p>Although codepoints could be represented as integers, this module represents all codepoints as strings. For example:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.codepoints(\"olá\")\n[\"o\", \"l\", \"á\"]</code></pre> <p>There are a couple of ways to retrieve a character integer codepoint. One may use the <code class=\"inline\">?</code> construct:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ?o\n111\n\niex&gt; ?á\n225</code></pre> <p>Or also via pattern matching:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; &lt;&lt;aacute::utf8&gt;&gt; = \"á\"\niex&gt; aacute\n225</code></pre> <p>As we have seen above, codepoints can be inserted into a string by their hexadecimal code:</p> <pre data-language=\"elixir\"><code class=\"elixir\">\"ol\\u0061\\u0301\" #=&gt;\n\"olá\"</code></pre> <h2 id=\"module-self-synchronization\" class=\"section-heading\">  Self-synchronization </h2> <p>The UTF-8 encoding is self-synchronizing. This means that if malformed data (i.e., data that is not possible according to the definition of the encoding) is encountered, only one codepoint needs to be rejected.</p> <p>This module relies on this behaviour to ignore such invalid characters. For example, <a href=\"#length/1\"><code class=\"inline\">length/1</code></a> will return a correct result even if an invalid codepoint is fed into it.</p> <p>In other words, this module expects invalid data to be detected when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding.</p> <h2 id=\"module-patterns\" class=\"section-heading\">  Patterns </h2> <p>Many functions in this module work with patterns. For example, String.split/2 can split a string into multiple patterns given a pattern. This pattern can be a string, a list of strings or a compiled pattern:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.split(\"foo bar\", \" \")\n[\"foo\", \"bar\"]\n\niex&gt; String.split(\"foo bar!\", [\" \", \"!\"])\n[\"foo\", \"bar\", \"\"]\n\niex&gt; pattern = :binary.compile_pattern([\" \", \"!\"])\niex&gt; String.split(\"foo bar!\", pattern)\n[\"foo\", \"bar\", \"\"]</code></pre> <p>The compiled pattern is useful when the same match will be done over and over again. Note though the compiled pattern cannot be stored in a module attribute as the pattern is generated at runtime and does not survive compile term.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:codepoint/0\">codepoint()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:grapheme/0\">grapheme()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:pattern/0\">pattern()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#at/2\">at(string, position)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the grapheme at the <code class=\"inline\">position</code> of the given utf8 <code class=\"inline\">string</code>. If <code class=\"inline\">position</code> is greater than <code class=\"inline\">string</code> length, then it returns <code class=\"inline\">nil</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#capitalize/1\">capitalize(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the first character in the given string to uppercase and the remainder to lowercase</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#chunk/2\">chunk(string, trait)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Splits the string into chunks of characters that share a common trait</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#codepoints/1\">codepoints(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all codepoints in the string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#contains?/2\">contains?(string, contents)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if <code class=\"inline\">string</code> contains any of the given <code class=\"inline\">contents</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#downcase/1\">downcase(binary)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts all characters in the given string to lowercase</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#duplicate/2\">duplicate(subject, n)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a string <code class=\"inline\">subject</code> duplicated <code class=\"inline\">n</code> times</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ends_with?/2\">ends_with?(string, suffixes)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">string</code> ends with any of the suffixes given</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#equivalent?/2\">equivalent?(string1, string2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">string1</code> is canonically equivalent to ‘string2’</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#first/1\">first(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the first grapheme from a utf8 string, <code class=\"inline\">nil</code> if the string is empty</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#graphemes/1\">graphemes(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns Unicode graphemes in the string as per Extended Grapheme Cluster algorithm</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#jaro_distance/2\">jaro_distance(string1, string2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a float value between 0 (equates to no similarity) and 1 (is an exact match) representing <a href=\"https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\">Jaro</a> distance between <code class=\"inline\">string1</code> and <code class=\"inline\">string2</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#last/1\">last(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the last grapheme from a utf8 string, <code class=\"inline\">nil</code> if the string is empty</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#length/1\">length(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the number of Unicode graphemes in a utf8 string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#match?/2\">match?(string, regex)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if <code class=\"inline\">string</code> matches the given regular expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#myers_difference/2\">myers_difference(str1, str2)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a keyword list that represents an edit script</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#next_codepoint/1\">next_codepoint(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the next codepoint in a string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#next_grapheme/1\">next_grapheme(binary)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the next grapheme in a string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#next_grapheme_size/1\">next_grapheme_size(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the size of the next grapheme</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#normalize/2\">normalize(string, form)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts all characters in <code class=\"inline\">string</code> to Unicode normalization form identified by <code class=\"inline\">form</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pad_leading/3\">pad_leading(string, count, padding \\\\ [\" \"])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a new string padded with a leading filler which is made of elements from the <code class=\"inline\">padding</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pad_trailing/3\">pad_trailing(string, count, padding \\\\ [\" \"])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a new string padded with a trailing filler which is made of elements from the <code class=\"inline\">padding</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#printable?/1\">printable?(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if a string contains only printable characters</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#replace/4\">replace(subject, pattern, replacement, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a new string created by replacing occurrences of <code class=\"inline\">pattern</code> in <code class=\"inline\">subject</code> with <code class=\"inline\">replacement</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#replace_leading/3\">replace_leading(string, match, replacement)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Replaces all leading occurrences of <code class=\"inline\">match</code> by <code class=\"inline\">replacement</code> of <code class=\"inline\">match</code> in <code class=\"inline\">string</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#replace_prefix/3\">replace_prefix(string, match, replacement)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Replaces prefix in <code class=\"inline\">string</code> by <code class=\"inline\">replacement</code> if it matches <code class=\"inline\">match</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#replace_suffix/3\">replace_suffix(string, match, replacement)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Replaces suffix in <code class=\"inline\">string</code> by <code class=\"inline\">replacement</code> if it matches <code class=\"inline\">match</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#replace_trailing/3\">replace_trailing(string, match, replacement)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Replaces all trailing occurrences of <code class=\"inline\">match</code> by <code class=\"inline\">replacement</code> in <code class=\"inline\">string</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reverse/1\">reverse(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reverses the graphemes in given string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#slice/2\">slice(string, range)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a substring from the offset given by the start of the range to the offset given by the end of the range</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#slice/3\">slice(string, start, len)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a substring starting at the offset <code class=\"inline\">start</code>, and of length <code class=\"inline\">len</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#split/1\">split(binary)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored. Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#split/3\">split(string, pattern, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Divides a string into substrings based on a pattern</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#split_at/2\">split_at(string, position)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Splits a string into two at the specified offset. When the offset given is negative, location is counted from the end of the string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#splitter/3\">splitter(string, pattern, options \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an enumerable that splits a string on demand</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#starts_with?/2\">starts_with?(string, prefix)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">string</code> starts with any of the prefixes given</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_atom/1\">to_atom(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a string to an atom</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_charlist/1\">to_charlist(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a string into a charlist</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_existing_atom/1\">to_existing_atom(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts a string to an existing atom</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_float/1\">to_float(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a float whose text representation is <code class=\"inline\">string</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_integer/1\">to_integer(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an integer whose text representation is <code class=\"inline\">string</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_integer/2\">to_integer(string, base)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an integer whose text representation is <code class=\"inline\">string</code> in base <code class=\"inline\">base</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#trim/1\">trim(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a string where all leading and trailing Unicode whitespaces have been removed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#trim/2\">trim(string, to_trim)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a string where all leading and trailing <code class=\"inline\">to_trim</code>s have been removed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#trim_leading/1\">trim_leading(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a string where all leading Unicode whitespaces have been removed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#trim_leading/2\">trim_leading(string, to_trim)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a string where all leading <code class=\"inline\">to_trim</code>s have been removed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#trim_trailing/1\">trim_trailing(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a string where all trailing Unicode whitespaces has been removed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#trim_trailing/2\">trim_trailing(string, to_trim)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a string where all trailing <code class=\"inline\">to_trim</code>s have been removed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#upcase/1\">upcase(binary)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts all characters in the given string to uppercase</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#valid?/1\">valid?(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks whether <code class=\"inline\">string</code> contains only valid characters</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:codepoint/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:codepoint/0\">codepoint</a> :: <a href=\"#t:t/0\">t</a></code></pre> </div> <div id=\"t:grapheme/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:grapheme/0\">grapheme</a> :: <a href=\"#t:t/0\">t</a></code></pre> </div> <div id=\"t:pattern/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:pattern/0\">pattern</a> :: <a href=\"#t:t/0\">t</a> | [<a href=\"#t:t/0\">t</a>] | :binary.cp</code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: binary</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"at/2\">  <span class=\"signature\">at(string, position)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">at(<a href=\"#t:t/0\">t</a>, integer) :: <a href=\"#t:grapheme/0\">grapheme</a> | nil</code></pre>    <p>Returns the grapheme at the <code class=\"inline\">position</code> of the given utf8 <code class=\"inline\">string</code>. If <code class=\"inline\">position</code> is greater than <code class=\"inline\">string</code> length, then it returns <code class=\"inline\">nil</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.at(\"elixir\", 0)\n\"e\"\n\niex&gt; String.at(\"elixir\", 1)\n\"l\"\n\niex&gt; String.at(\"elixir\", 10)\nnil\n\niex&gt; String.at(\"elixir\", -1)\n\"r\"\n\niex&gt; String.at(\"elixir\", -10)\nnil</code></pre>    <h3 class=\"detail-header function\" id=\"capitalize/1\">  <span class=\"signature\">capitalize(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">capitalize(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Converts the first character in the given string to uppercase and the remainder to lowercase.</p> <p>This relies on the titlecase information provided by the Unicode Standard. Note this function makes no attempt to capitalize all words in the string (usually known as titlecase).</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.capitalize(\"abcd\")\n\"Abcd\"\n\niex&gt; String.capitalize(\"ﬁn\")\n\"Fin\"\n\niex&gt; String.capitalize(\"olá\")\n\"Olá\"</code></pre>    <h3 class=\"detail-header function\" id=\"chunk/2\">  <span class=\"signature\">chunk(string, trait)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">chunk(<a href=\"#t:t/0\">t</a>, :valid | :printable) :: [<a href=\"#t:t/0\">t</a>]</code></pre>    <p>Splits the string into chunks of characters that share a common trait.</p> <p>The trait can be one of two options:</p> <ul> <li>\n<p><code class=\"inline\">:valid</code> - the string is split into chunks of valid and invalid character sequences</p> </li> <li>\n<code class=\"inline\">:printable</code> - the string is split into chunks of printable and non-printable character sequences </li> </ul> <p>Returns a list of binaries each of which contains only one kind of characters.</p> <p>If the given string is empty, an empty list is returned.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0&gt;&gt;, :valid)\n[\"abc\\0\"]\n\niex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0, 0x0FFFF::utf8&gt;&gt;, :valid)\n[\"abc\\0\", &lt;&lt;0x0FFFF::utf8&gt;&gt;]\n\niex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0, 0x0FFFF::utf8&gt;&gt;, :printable)\n[\"abc\", &lt;&lt;0, 0x0FFFF::utf8&gt;&gt;]</code></pre>    <h3 class=\"detail-header function\" id=\"codepoints/1\">  <span class=\"signature\">codepoints(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">codepoints(<a href=\"#t:t/0\">t</a>) :: [<a href=\"#t:codepoint/0\">codepoint</a>]</code></pre>    <p>Returns all codepoints in the string.</p> <p>For details about codepoints and graphemes, see the <a href=\"string#content\"><code class=\"inline\">String</code></a> module documentation.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.codepoints(\"olá\")\n[\"o\", \"l\", \"á\"]\n\niex&gt; String.codepoints(\"оптими зации\")\n[\"о\", \"п\", \"т\", \"и\", \"м\", \"и\", \" \", \"з\", \"а\", \"ц\", \"и\", \"и\"]\n\niex&gt; String.codepoints(\"ἅἪῼ\")\n[\"ἅ\", \"Ἢ\", \"ῼ\"]\n\niex&gt; String.codepoints(\"é\")\n[\"é\"]\n\niex&gt; String.codepoints(\"é\")\n[\"e\", \"́\"]</code></pre>    <h3 class=\"detail-header function\" id=\"contains?/2\">  <span class=\"signature\">contains?(string, contents)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">contains?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:pattern/0\">pattern</a>) :: boolean</code></pre>    <p>Checks if <code class=\"inline\">string</code> contains any of the given <code class=\"inline\">contents</code>.</p> <p><code class=\"inline\">contents</code> can be either a single string or a list of strings.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.contains? \"elixir of life\", \"of\"\ntrue\niex&gt; String.contains? \"elixir of life\", [\"life\", \"death\"]\ntrue\niex&gt; String.contains? \"elixir of life\", [\"death\", \"mercury\"]\nfalse</code></pre> <p>An empty string will always match:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.contains? \"elixir of life\", \"\"\ntrue\niex&gt; String.contains? \"elixir of life\", [\"\", \"other\"]\ntrue</code></pre> <p>The argument can also be a precompiled pattern:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; pattern = :binary.compile_pattern([\"life\", \"death\"])\niex&gt; String.contains? \"elixir of life\", pattern\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"downcase/1\">  <span class=\"signature\">downcase(binary)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">downcase(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Converts all characters in the given string to lowercase.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.downcase(\"ABCD\")\n\"abcd\"\n\niex&gt; String.downcase(\"AB 123 XPTO\")\n\"ab 123 xpto\"\n\niex&gt; String.downcase(\"OLÁ\")\n\"olá\"</code></pre>    <h3 class=\"detail-header function\" id=\"duplicate/2\">  <span class=\"signature\">duplicate(subject, n)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">duplicate(<a href=\"#t:t/0\">t</a>, non_neg_integer) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a string <code class=\"inline\">subject</code> duplicated <code class=\"inline\">n</code> times.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.duplicate(\"abc\", 0)\n\"\"\n\niex&gt; String.duplicate(\"abc\", 1)\n\"abc\"\n\niex&gt; String.duplicate(\"abc\", 2)\n\"abcabc\"</code></pre>    <h3 class=\"detail-header function\" id=\"ends_with?/2\">  <span class=\"signature\">ends_with?(string, suffixes)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">ends_with?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a> | [<a href=\"#t:t/0\">t</a>]) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">string</code> ends with any of the suffixes given.</p> <p><code class=\"inline\">suffixes</code> can be either a single suffix or a list of suffixes.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.ends_with? \"language\", \"age\"\ntrue\niex&gt; String.ends_with? \"language\", [\"youth\", \"age\"]\ntrue\niex&gt; String.ends_with? \"language\", [\"youth\", \"elixir\"]\nfalse</code></pre> <p>An empty string will always match:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.ends_with? \"language\", \"\"\ntrue\niex&gt; String.ends_with? \"language\", [\"\", \"other\"]\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"equivalent?/2\">  <span class=\"signature\">equivalent?(string1, string2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">equivalent?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">string1</code> is canonically equivalent to ‘string2’.</p> <p>It performs Normalization Form Canonical Decomposition (NFD) on the strings before comparing them. This function is equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">String.normalize(string1, :nfd) == String.normalize(string2, :nfd)</code></pre> <p>Therefore, if you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.equivalent?(\"abc\", \"abc\")\ntrue\n\niex&gt; String.equivalent?(\"man\\u0303ana\", \"mañana\")\ntrue\n\niex&gt; String.equivalent?(\"abc\", \"ABC\")\nfalse\n\niex&gt; String.equivalent?(\"nø\", \"nó\")\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"first/1\">  <span class=\"signature\">first(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">first(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:grapheme/0\">grapheme</a> | nil</code></pre>    <p>Returns the first grapheme from a utf8 string, <code class=\"inline\">nil</code> if the string is empty.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.first(\"elixir\")\n\"e\"\n\niex&gt; String.first(\"եոգլի\")\n\"ե\"</code></pre>    <h3 class=\"detail-header function\" id=\"graphemes/1\">  <span class=\"signature\">graphemes(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">graphemes(<a href=\"#t:t/0\">t</a>) :: [<a href=\"#t:grapheme/0\">grapheme</a>]</code></pre>    <p>Returns Unicode graphemes in the string as per Extended Grapheme Cluster algorithm.</p> <p>The algorithm is outlined in the <a href=\"http://www.unicode.org/reports/tr29/\">Unicode Standard Annex #29, Unicode Text Segmentation</a>.</p> <p>For details about codepoints and graphemes, see the <a href=\"string#content\"><code class=\"inline\">String</code></a> module documentation.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.graphemes(\"Ńaïve\")\n[\"Ń\", \"a\", \"ï\", \"v\", \"e\"]\n\niex&gt; String.graphemes(\"é\")\n[\"é\"]\n\niex&gt; String.graphemes(\"é\")\n[\"é\"]</code></pre>    <h3 class=\"detail-header function\" id=\"jaro_distance/2\">  <span class=\"signature\">jaro_distance(string1, string2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">jaro_distance(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: float</code></pre>    <p>Returns a float value between 0 (equates to no similarity) and 1 (is an exact match) representing <a href=\"https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\">Jaro</a> distance between <code class=\"inline\">string1</code> and <code class=\"inline\">string2</code>.</p> <p>The Jaro distance metric is designed and best suited for short strings such as person names.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.jaro_distance(\"dwayne\", \"duane\")\n0.8222222222222223\niex&gt; String.jaro_distance(\"even\", \"odd\")\n0.0</code></pre>    <h3 class=\"detail-header function\" id=\"last/1\">  <span class=\"signature\">last(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">last(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:grapheme/0\">grapheme</a> | nil</code></pre>    <p>Returns the last grapheme from a utf8 string, <code class=\"inline\">nil</code> if the string is empty.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.last(\"elixir\")\n\"r\"\n\niex&gt; String.last(\"եոգլի\")\n\"ի\"</code></pre>    <h3 class=\"detail-header function\" id=\"length/1\">  <span class=\"signature\">length(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">length(<a href=\"#t:t/0\">t</a>) :: non_neg_integer</code></pre>    <p>Returns the number of Unicode graphemes in a utf8 string.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.length(\"elixir\")\n6\n\niex&gt; String.length(\"եոգլի\")\n5</code></pre>    <h3 class=\"detail-header function\" id=\"match?/2\">  <span class=\"signature\">match?(string, regex)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">match?(<a href=\"#t:t/0\">t</a>, <a href=\"regex#t:t/0\">Regex.t</a>) :: boolean</code></pre>    <p>Checks if <code class=\"inline\">string</code> matches the given regular expression.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.match?(\"foo\", ~r/foo/)\ntrue\n\niex&gt; String.match?(\"bar\", ~r/foo/)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"myers_difference/2\">  <span class=\"signature\">myers_difference(str1, str2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">myers_difference(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) ::\n  [{:eq | :ins | :del, <a href=\"#t:t/0\">t</a>}] |\n  nil</code></pre>    <p>Returns a keyword list that represents an edit script.</p> <p>The algorithm is outlined in the “An O(ND) Difference Algorithm and Its Variations” paper by E. Myers.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; string1 = \"fox hops over the dog\"\niex&gt; string2 = \"fox jumps over the lazy cat\"\niex&gt; String.myers_difference(string1, string2)\n[eq: \"fox \", del: \"ho\", ins: \"jum\", eq: \"ps over the \", del: \"dog\", ins: \"lazy cat\"]</code></pre>    <h3 class=\"detail-header function\" id=\"next_codepoint/1\">  <span class=\"signature\">next_codepoint(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">next_codepoint(<a href=\"#t:t/0\">t</a>) :: {<a href=\"#t:codepoint/0\">codepoint</a>, <a href=\"#t:t/0\">t</a>} | nil</code></pre>    <p>Returns the next codepoint in a string.</p> <p>The result is a tuple with the codepoint and the remainder of the string or <code class=\"inline\">nil</code> in case the string reached its end.</p> <p>As with other functions in the String module, this function does not check for the validity of the codepoint. That said, if an invalid codepoint is found, it will be returned by this function.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.next_codepoint(\"olá\")\n{\"o\", \"lá\"}</code></pre>    <h3 class=\"detail-header function\" id=\"next_grapheme/1\">  <span class=\"signature\">next_grapheme(binary)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">next_grapheme(<a href=\"#t:t/0\">t</a>) :: {<a href=\"#t:grapheme/0\">grapheme</a>, <a href=\"#t:t/0\">t</a>} | nil</code></pre>    <p>Returns the next grapheme in a string.</p> <p>The result is a tuple with the grapheme and the remainder of the string or <code class=\"inline\">nil</code> in case the String reached its end.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.next_grapheme(\"olá\")\n{\"o\", \"lá\"}</code></pre>    <h3 class=\"detail-header function\" id=\"next_grapheme_size/1\">  <span class=\"signature\">next_grapheme_size(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">next_grapheme_size(<a href=\"#t:t/0\">t</a>) :: {pos_integer, <a href=\"#t:t/0\">t</a>} | nil</code></pre>    <p>Returns the size of the next grapheme.</p> <p>The result is a tuple with the next grapheme size and the remainder of the string or <code class=\"inline\">nil</code> in case the string reached its end.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.next_grapheme_size(\"olá\")\n{1, \"lá\"}</code></pre>    <h3 class=\"detail-header function\" id=\"normalize/2\">  <span class=\"signature\">normalize(string, form)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">normalize(<a href=\"#t:t/0\">t</a>, atom) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Converts all characters in <code class=\"inline\">string</code> to Unicode normalization form identified by <code class=\"inline\">form</code>.</p> <h4>Forms</h4> <p>The supported forms are:</p> <ul> <li>\n<p><code class=\"inline\">:nfd</code> - Normalization Form Canonical Decomposition. Characters are decomposed by canonical equivalence, and multiple combining characters are arranged in a specific order.</p> </li> <li>\n<code class=\"inline\">:nfc</code> - Normalization Form Canonical Composition. Characters are decomposed and then recomposed by canonical equivalence. </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.normalize(\"yêṩ\", :nfd)\n\"yêṩ\"\n\niex&gt; String.normalize(\"leña\", :nfc)\n\"leña\"</code></pre>    <h3 class=\"detail-header function\" id=\"pad_leading/3\">  <span class=\"signature\">pad_leading(string, count, padding \\\\ [\" \"])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">pad_leading(<a href=\"#t:t/0\">t</a>, non_neg_integer, <a href=\"#t:t/0\">t</a> | [<a href=\"#t:t/0\">t</a>]) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a new string padded with a leading filler which is made of elements from the <code class=\"inline\">padding</code>.</p> <p>Passing a list of strings as <code class=\"inline\">padding</code> will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string <code class=\"inline\">padding</code> is equivalent to passing the list of graphemes in it. If no <code class=\"inline\">padding</code> is given, it defaults to whitespace.</p> <p>When <code class=\"inline\">count</code> is less than or equal to the length of <code class=\"inline\">string</code>, given <code class=\"inline\">string</code> is returned.</p> <p>Raises <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> if the given <code class=\"inline\">padding</code> contains non-string element.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.pad_leading(\"abc\", 5)\n\"  abc\"\n\niex&gt; String.pad_leading(\"abc\", 4, \"12\")\n\"1abc\"\n\niex&gt; String.pad_leading(\"abc\", 6, \"12\")\n\"121abc\"\n\niex&gt; String.pad_leading(\"abc\", 5, [\"1\", \"23\"])\n\"123abc\"</code></pre>    <h3 class=\"detail-header function\" id=\"pad_trailing/3\">  <span class=\"signature\">pad_trailing(string, count, padding \\\\ [\" \"])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">pad_trailing(<a href=\"#t:t/0\">t</a>, non_neg_integer, <a href=\"#t:t/0\">t</a> | [<a href=\"#t:t/0\">t</a>]) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a new string padded with a trailing filler which is made of elements from the <code class=\"inline\">padding</code>.</p> <p>Passing a list of strings as <code class=\"inline\">padding</code> will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string <code class=\"inline\">padding</code> is equivalent to passing the list of graphemes in it. If no <code class=\"inline\">padding</code> is given, it defaults to whitespace.</p> <p>When <code class=\"inline\">count</code> is less than or equal to the length of <code class=\"inline\">string</code>, given <code class=\"inline\">string</code> is returned.</p> <p>Raises <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> if the given <code class=\"inline\">padding</code> contains non-string element.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.pad_trailing(\"abc\", 5)\n\"abc  \"\n\niex&gt; String.pad_trailing(\"abc\", 4, \"12\")\n\"abc1\"\n\niex&gt; String.pad_trailing(\"abc\", 6, \"12\")\n\"abc121\"\n\niex&gt; String.pad_trailing(\"abc\", 5, [\"1\", \"23\"])\n\"abc123\"</code></pre>    <h3 class=\"detail-header function\" id=\"printable?/1\">  <span class=\"signature\">printable?(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">printable?(<a href=\"#t:t/0\">t</a>) :: boolean</code></pre>    <p>Checks if a string contains only printable characters.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.printable?(\"abc\")\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"replace/4\">  <span class=\"signature\">replace(subject, pattern, replacement, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">replace(<a href=\"#t:t/0\">t</a>, <a href=\"#t:pattern/0\">pattern</a> | <a href=\"regex#t:t/0\">Regex.t</a>, <a href=\"#t:t/0\">t</a>, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a new string created by replacing occurrences of <code class=\"inline\">pattern</code> in <code class=\"inline\">subject</code> with <code class=\"inline\">replacement</code>.</p> <p>By default, it replaces all occurrences, unless the <code class=\"inline\">global</code> option is set to <code class=\"inline\">false</code>, where it will only replace the first one</p> <p>The <code class=\"inline\">pattern</code> may be a string or a regular expression.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.replace(\"a,b,c\", \",\", \"-\")\n\"a-b-c\"\n\niex&gt; String.replace(\"a,b,c\", \",\", \"-\", global: false)\n\"a-b,c\"</code></pre> <p>When the pattern is a regular expression, one can give <code class=\"inline\">\\N</code> or <code class=\"inline\">\\g{N}</code> in the <code class=\"inline\">replacement</code> string to access a specific capture in the regular expression:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\g{1}\")\n\"a,bb,cc\"</code></pre> <p>Notice we had to escape the escape character <code class=\"inline\">\\</code>. By giving <code class=\"inline\">\\0</code>, one can inject the whole matched pattern in the replacement string. When the pattern is a string, a developer can use the replaced part inside the <code class=\"inline\">replacement</code> by using the <code class=\"inline\">:insert_replace</code> option and specifying the position(s) inside the <code class=\"inline\">replacement</code> where the string pattern will be inserted: iex&gt; String.replace(“a,b,c”, “b”, “[]“, insert_replaced: 1) “a,[b],c” iex&gt; String.replace(“a,b,c”, “,”, “[]“, insert_replaced: 2) “a[],b[],c” iex&gt; String.replace(“a,b,c”, “,”, “[]“, insert_replaced: [1, 1]) “a[,,]b[,,]c” If any position given in the <code class=\"inline\">:insert_replace</code> option is larger than the replacement string, or is negative, an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> is raised.</p>    <h3 class=\"detail-header function\" id=\"replace_leading/3\">  <span class=\"signature\">replace_leading(string, match, replacement)</span>  </h3>  <p>Replaces all leading occurrences of <code class=\"inline\">match</code> by <code class=\"inline\">replacement</code> of <code class=\"inline\">match</code> in <code class=\"inline\">string</code>.</p> <p>Returns the string untouched if there are no occurrences.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.replace_leading(\"hello world\", \"hello \", \"\")\n\"world\"\niex&gt; String.replace_leading(\"hello hello world\", \"hello \", \"\")\n\"world\"\n\niex&gt; String.replace_leading(\"hello world\", \"hello \", \"ola \")\n\"ola world\"\niex&gt; String.replace_leading(\"hello hello world\", \"hello \", \"ola \")\n\"ola ola world\"</code></pre>    <h3 class=\"detail-header function\" id=\"replace_prefix/3\">  <span class=\"signature\">replace_prefix(string, match, replacement)</span>  </h3>  <p>Replaces prefix in <code class=\"inline\">string</code> by <code class=\"inline\">replacement</code> if it matches <code class=\"inline\">match</code>.</p> <p>Returns the string untouched if there is no match.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.replace_prefix(\"world\", \"hello \", \"\")\n\"world\"\niex&gt; String.replace_prefix(\"hello world\", \"hello \", \"\")\n\"world\"\niex&gt; String.replace_prefix(\"hello hello world\", \"hello \", \"\")\n\"hello world\"\n\niex&gt; String.replace_prefix(\"world\", \"hello \", \"ola \")\n\"world\"\niex&gt; String.replace_prefix(\"hello world\", \"hello \", \"ola \")\n\"ola world\"\niex&gt; String.replace_prefix(\"hello hello world\", \"hello \", \"ola \")\n\"ola hello world\"</code></pre>    <h3 class=\"detail-header function\" id=\"replace_suffix/3\">  <span class=\"signature\">replace_suffix(string, match, replacement)</span>  </h3>  <p>Replaces suffix in <code class=\"inline\">string</code> by <code class=\"inline\">replacement</code> if it matches <code class=\"inline\">match</code>.</p> <p>Returns the string untouched if there is no match.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.replace_suffix(\"hello\", \" world\", \"\")\n\"hello\"\niex&gt; String.replace_suffix(\"hello world\", \" world\", \"\")\n\"hello\"\niex&gt; String.replace_suffix(\"hello world world\", \" world\", \"\")\n\"hello world\"\n\niex&gt; String.replace_suffix(\"hello\", \" world\", \" mundo\")\n\"hello\"\niex&gt; String.replace_suffix(\"hello world\", \" world\", \" mundo\")\n\"hello mundo\"\niex&gt; String.replace_suffix(\"hello world world\", \" world\", \" mundo\")\n\"hello world mundo\"</code></pre>    <h3 class=\"detail-header function\" id=\"replace_trailing/3\">  <span class=\"signature\">replace_trailing(string, match, replacement)</span>  </h3>  <p>Replaces all trailing occurrences of <code class=\"inline\">match</code> by <code class=\"inline\">replacement</code> in <code class=\"inline\">string</code>.</p> <p>Returns the string untouched if there are no occurrences.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.replace_trailing(\"hello world\", \" world\", \"\")\n\"hello\"\niex&gt; String.replace_trailing(\"hello world world\", \" world\", \"\")\n\"hello\"\n\niex&gt; String.replace_trailing(\"hello world\", \" world\", \" mundo\")\n\"hello mundo\"\niex&gt; String.replace_trailing(\"hello world world\", \" world\", \" mundo\")\n\"hello mundo mundo\"</code></pre>    <h3 class=\"detail-header function\" id=\"reverse/1\">  <span class=\"signature\">reverse(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reverse(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Reverses the graphemes in given string.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.reverse(\"abcd\")\n\"dcba\"\n\niex&gt; String.reverse(\"hello world\")\n\"dlrow olleh\"\n\niex&gt; String.reverse(\"hello ∂og\")\n\"go∂ olleh\"</code></pre> <p>Keep in mind reversing the same string twice does not necessarily yield the original string:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; \"̀e\"\n\"̀e\"\niex&gt; String.reverse(\"̀e\")\n\"è\"\niex&gt; String.reverse String.reverse(\"̀e\")\n\"è\"</code></pre> <p>In the first example the accent is before the vowel, so it is considered two graphemes. However, when you reverse it once, you have the vowel followed by the accent, which becomes one grapheme. Reversing it again will keep it as one single grapheme.</p>    <h3 class=\"detail-header function\" id=\"slice/2\">  <span class=\"signature\">slice(string, range)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">slice(<a href=\"#t:t/0\">t</a>, <a href=\"range#t:t/0\">Range.t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a substring from the offset given by the start of the range to the offset given by the end of the range.</p> <p>If the start of the range is not a valid offset for the given string or if the range is in reverse order, returns <code class=\"inline\">\"\"</code>.</p> <p>If the start or end of the range is negative, the whole string is traversed first in order to convert the negative indices into positive ones.</p> <p>Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check <a href=\"kernel#binary_part/3\"><code class=\"inline\">Kernel.binary_part/3</code></a> instead.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.slice(\"elixir\", 1..3)\n\"lix\"\n\niex&gt; String.slice(\"elixir\", 1..10)\n\"lixir\"\n\niex&gt; String.slice(\"elixir\", 10..3)\n\"\"\n\niex&gt; String.slice(\"elixir\", -4..-1)\n\"ixir\"\n\niex&gt; String.slice(\"elixir\", 2..-1)\n\"ixir\"\n\niex&gt; String.slice(\"elixir\", -4..6)\n\"ixir\"\n\niex&gt; String.slice(\"elixir\", -1..-4)\n\"\"\n\niex&gt; String.slice(\"elixir\", -10..-7)\n\"\"\n\niex&gt; String.slice(\"a\", 0..1500)\n\"a\"\n\niex&gt; String.slice(\"a\", 1..1500)\n\"\"</code></pre>    <h3 class=\"detail-header function\" id=\"slice/3\">  <span class=\"signature\">slice(string, start, len)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">slice(<a href=\"#t:t/0\">t</a>, integer, integer) :: <a href=\"#t:grapheme/0\">grapheme</a></code></pre>    <p>Returns a substring starting at the offset <code class=\"inline\">start</code>, and of length <code class=\"inline\">len</code>.</p> <p>If the offset is greater than string length, then it returns <code class=\"inline\">\"\"</code>.</p> <p>Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check <a href=\"kernel#binary_part/3\"><code class=\"inline\">Kernel.binary_part/3</code></a> instead.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.slice(\"elixir\", 1, 3)\n\"lix\"\n\niex&gt; String.slice(\"elixir\", 1, 10)\n\"lixir\"\n\niex&gt; String.slice(\"elixir\", 10, 3)\n\"\"\n\niex&gt; String.slice(\"elixir\", -4, 4)\n\"ixir\"\n\niex&gt; String.slice(\"elixir\", -10, 3)\n\"\"\n\niex&gt; String.slice(\"a\", 0, 1500)\n\"a\"\n\niex&gt; String.slice(\"a\", 1, 1500)\n\"\"\n\niex&gt; String.slice(\"a\", 2, 1500)\n\"\"</code></pre>    <h3 class=\"detail-header function\" id=\"split/1\">  <span class=\"signature\">split(binary)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">split(<a href=\"#t:t/0\">t</a>) :: [<a href=\"#t:t/0\">t</a>]</code></pre>    <p>Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored. Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.split(\"foo bar\")\n[\"foo\", \"bar\"]\n\niex&gt; String.split(\"foo\" &lt;&gt; &lt;&lt;194, 133&gt;&gt; &lt;&gt; \"bar\")\n[\"foo\", \"bar\"]\n\niex&gt; String.split(\" foo   bar \")\n[\"foo\", \"bar\"]\n\niex&gt; String.split(\"no\\u00a0break\")\n[\"no\\u00a0break\"]</code></pre>    <h3 class=\"detail-header function\" id=\"split/3\">  <span class=\"signature\">split(string, pattern, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">split(<a href=\"#t:t/0\">t</a>, <a href=\"#t:pattern/0\">pattern</a> | <a href=\"regex#t:t/0\">Regex.t</a>, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: [<a href=\"#t:t/0\">t</a>]</code></pre>    <p>Divides a string into substrings based on a pattern.</p> <p>Returns a list of these substrings. The pattern can be a string, a list of strings or a regular expression.</p> <p>The string is split into as many parts as possible by default, but can be controlled via the <code class=\"inline\">parts: pos_integer</code> option. If you pass <code class=\"inline\">parts: :infinity</code>, it will return all possible parts (<code class=\"inline\">:infinity</code> is the default).</p> <p>Empty strings are only removed from the result if the <code class=\"inline\">trim</code> option is set to <code class=\"inline\">true</code> (default is <code class=\"inline\">false</code>).</p> <h4>Examples</h4> <p>Splitting with a string pattern:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.split(\"a,b,c\", \",\")\n[\"a\", \"b\", \"c\"]\n\niex&gt; String.split(\"a,b,c\", \",\", parts: 2)\n[\"a\", \"b,c\"]\n\niex&gt; String.split(\" a b c \", \" \", trim: true)\n[\"a\", \"b\", \"c\"]</code></pre> <p>A list of patterns:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.split(\"1,2 3,4\", [\" \", \",\"])\n[\"1\", \"2\", \"3\", \"4\"]</code></pre> <p>A regular expression:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.split(\"a,b,c\", ~r{,})\n[\"a\", \"b\", \"c\"]\n\niex&gt; String.split(\"a,b,c\", ~r{,}, parts: 2)\n[\"a\", \"b,c\"]\n\niex&gt; String.split(\" a b c \", ~r{\\s}, trim: true)\n[\"a\", \"b\", \"c\"]</code></pre> <p>Splitting on empty patterns returns graphemes:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.split(\"abc\", ~r{})\n[\"a\", \"b\", \"c\", \"\"]\n\niex&gt; String.split(\"abc\", \"\")\n[\"a\", \"b\", \"c\", \"\"]\n\niex&gt; String.split(\"abc\", \"\", trim: true)\n[\"a\", \"b\", \"c\"]\n\niex&gt; String.split(\"abc\", \"\", parts: 2)\n[\"a\", \"bc\"]</code></pre> <p>A precompiled pattern can also be given:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; pattern = :binary.compile_pattern([\" \", \",\"])\niex&gt; String.split(\"1,2 3,4\", pattern)\n[\"1\", \"2\", \"3\", \"4\"]</code></pre>    <h3 class=\"detail-header function\" id=\"split_at/2\">  <span class=\"signature\">split_at(string, position)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">split_at(<a href=\"#t:t/0\">t</a>, integer) :: {<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>}</code></pre>    <p>Splits a string into two at the specified offset. When the offset given is negative, location is counted from the end of the string.</p> <p>The offset is capped to the length of the string. Returns a tuple with two elements.</p> <p>Note: keep in mind this function splits on graphemes and for such it has to linearly traverse the string. If you want to split a string or a binary based on the number of bytes, use <a href=\"kernel#binary_part/3\"><code class=\"inline\">Kernel.binary_part/3</code></a> instead.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.split_at \"sweetelixir\", 5\n{\"sweet\", \"elixir\"}\n\niex&gt; String.split_at \"sweetelixir\", -6\n{\"sweet\", \"elixir\"}\n\niex&gt; String.split_at \"abc\", 0\n{\"\", \"abc\"}\n\niex&gt; String.split_at \"abc\", 1000\n{\"abc\", \"\"}\n\niex&gt; String.split_at \"abc\", -1000\n{\"\", \"abc\"}</code></pre>    <h3 class=\"detail-header function\" id=\"splitter/3\">  <span class=\"signature\">splitter(string, pattern, options \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">splitter(<a href=\"#t:t/0\">t</a>, <a href=\"#t:pattern/0\">pattern</a>, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"enumerable#t:t/0\">Enumerable.t</a></code></pre>    <p>Returns an enumerable that splits a string on demand.</p> <p>This is in contrast to <a href=\"#split/3\"><code class=\"inline\">split/3</code></a> which splits all the string upfront.</p> <p>Note splitter does not support regular expressions (as it is often more efficient to have the regular expressions traverse the string at once than in multiple passes).</p> <h4>Options</h4> <ul> <li>:trim - when <code class=\"inline\">true</code>, does not emit empty patterns </li> </ul>    <h3 class=\"detail-header function\" id=\"starts_with?/2\">  <span class=\"signature\">starts_with?(string, prefix)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">starts_with?(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a> | [<a href=\"#t:t/0\">t</a>]) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">string</code> starts with any of the prefixes given.</p> <p><code class=\"inline\">prefix</code> can be either a single prefix or a list of prefixes.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.starts_with? \"elixir\", \"eli\"\ntrue\niex&gt; String.starts_with? \"elixir\", [\"erlang\", \"elixir\"]\ntrue\niex&gt; String.starts_with? \"elixir\", [\"erlang\", \"ruby\"]\nfalse</code></pre> <p>An empty string will always match:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.starts_with? \"elixir\", \"\"\ntrue\niex&gt; String.starts_with? \"elixir\", [\"\", \"other\"]\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"to_atom/1\">  <span class=\"signature\">to_atom(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_atom(<a href=\"string#t:t/0\">String.t</a>) :: atom</code></pre>    <p>Converts a string to an atom.</p> <p>Currently Elixir does not support the conversion of strings that contain Unicode codepoints greater than 0xFF.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.to_atom(\"my_atom\")\n:my_atom</code></pre>    <h3 class=\"detail-header function\" id=\"to_charlist/1\">  <span class=\"signature\">to_charlist(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_charlist(<a href=\"#t:t/0\">t</a>) :: charlist</code></pre>    <p>Converts a string into a charlist.</p> <p>Specifically, this functions takes a UTF-8 encoded binary and returns a list of its integer codepoints. It is similar to <a href=\"#codepoints/1\"><code class=\"inline\">codepoints/1</code></a> except that the latter returns a list of codepoints as strings.</p> <p>In case you need to work with bytes, take a look at the <a href=\"http://www.erlang.org/doc/man/binary.html\"><code class=\"inline\">:binary</code> module</a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.to_charlist(\"æß\")\n'æß'</code></pre>    <h3 class=\"detail-header function\" id=\"to_existing_atom/1\">  <span class=\"signature\">to_existing_atom(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_existing_atom(<a href=\"string#t:t/0\">String.t</a>) :: atom</code></pre>    <p>Converts a string to an existing atom.</p> <p>Currently Elixir does not support the conversion of strings that contain Unicode codepoints greater than 0xFF.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; _ = :my_atom\niex&gt; String.to_existing_atom(\"my_atom\")\n:my_atom\n\niex&gt; String.to_existing_atom(\"this_atom_will_never_exist\")\n** (ArgumentError) argument error</code></pre>    <h3 class=\"detail-header function\" id=\"to_float/1\">  <span class=\"signature\">to_float(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_float(<a href=\"string#t:t/0\">String.t</a>) :: float</code></pre>    <p>Returns a float whose text representation is <code class=\"inline\">string</code>.</p> <p><code class=\"inline\">string</code> must be the string representation of a float. If a string representation of an integer wants to be used, then <a href=\"float#parse/1\"><code class=\"inline\">Float.parse/1</code></a> should be used instead, otherwise an argument error will be raised.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.to_float(\"2.2017764e+0\")\n2.2017764\n\niex&gt; String.to_float(\"3.0\")\n3.0</code></pre>    <h3 class=\"detail-header function\" id=\"to_integer/1\">  <span class=\"signature\">to_integer(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_integer(<a href=\"string#t:t/0\">String.t</a>) :: integer</code></pre>    <p>Returns an integer whose text representation is <code class=\"inline\">string</code>.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.to_integer(\"123\")\n123</code></pre>    <h3 class=\"detail-header function\" id=\"to_integer/2\">  <span class=\"signature\">to_integer(string, base)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">to_integer(<a href=\"string#t:t/0\">String.t</a>, 2..36) :: integer</code></pre>    <p>Returns an integer whose text representation is <code class=\"inline\">string</code> in base <code class=\"inline\">base</code>.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.to_integer(\"3FF\", 16)\n1023</code></pre>    <h3 class=\"detail-header function\" id=\"trim/1\">  <span class=\"signature\">trim(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">trim(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a string where all leading and trailing Unicode whitespaces have been removed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.trim(\"\\n  abc\\n  \")\n\"abc\"</code></pre>    <h3 class=\"detail-header function\" id=\"trim/2\">  <span class=\"signature\">trim(string, to_trim)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">trim(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a string where all leading and trailing <code class=\"inline\">to_trim</code>s have been removed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.trim(\"a  abc  a\", \"a\")\n\"  abc  \"</code></pre>    <h3 class=\"detail-header function\" id=\"trim_leading/1\">  <span class=\"signature\">trim_leading(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">trim_leading(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a string where all leading Unicode whitespaces have been removed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.trim_leading(\"\\n  abc   \")\n\"abc   \"</code></pre>    <h3 class=\"detail-header function\" id=\"trim_leading/2\">  <span class=\"signature\">trim_leading(string, to_trim)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">trim_leading(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a string where all leading <code class=\"inline\">to_trim</code>s have been removed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.trim_leading(\"__ abc _\", \"_\")\n\" abc _\"\n\niex&gt; String.trim_leading(\"1 abc\", \"11\")\n\"1 abc\"</code></pre>    <h3 class=\"detail-header function\" id=\"trim_trailing/1\">  <span class=\"signature\">trim_trailing(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">trim_trailing(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a string where all trailing Unicode whitespaces has been removed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.trim_trailing(\"   abc\\n  \")\n\"   abc\"</code></pre>    <h3 class=\"detail-header function\" id=\"trim_trailing/2\">  <span class=\"signature\">trim_trailing(string, to_trim)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">trim_trailing(<a href=\"#t:t/0\">t</a>, <a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Returns a string where all trailing <code class=\"inline\">to_trim</code>s have been removed.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.trim_trailing(\"_ abc __\", \"_\")\n\"_ abc \"\n\niex&gt; String.trim_trailing(\"abc 1\", \"11\")\n\"abc 1\"</code></pre>    <h3 class=\"detail-header function\" id=\"upcase/1\">  <span class=\"signature\">upcase(binary)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">upcase(<a href=\"#t:t/0\">t</a>) :: <a href=\"#t:t/0\">t</a></code></pre>    <p>Converts all characters in the given string to uppercase.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.upcase(\"abcd\")\n\"ABCD\"\n\niex&gt; String.upcase(\"ab 123 xpto\")\n\"AB 123 XPTO\"\n\niex&gt; String.upcase(\"olá\")\n\"OLÁ\"</code></pre>    <h3 class=\"detail-header function\" id=\"valid?/1\">  <span class=\"signature\">valid?(string)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">valid?(<a href=\"#t:t/0\">t</a>) :: boolean</code></pre>    <p>Checks whether <code class=\"inline\">string</code> contains only valid characters.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; String.valid?(\"a\")\ntrue\n\niex&gt; String.valid?(\"ø\")\ntrue\n\niex&gt; String.valid?(&lt;&lt;0xFFFF :: 16&gt;&gt;)\nfalse\n\niex&gt; String.valid?(\"asd\" &lt;&gt; &lt;&lt;0xFFFF :: 16&gt;&gt;)\nfalse</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/String.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/String.html</a>\n  </p>\n</div>\n","elixir/withclauseerror":"<h1>  WithClauseError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <a href=\"exception#c:exception/1\"><code class=\"inline\">Exception.exception/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <p>Callback implementation for <a href=\"exception#c:message/1\"><code class=\"inline\">Exception.message/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/WithClauseError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/WithClauseError.html</a>\n  </p>\n</div>\n","elixir/collectable":"<h1>  Collectable <small>protocol</small>  </h1>  <p>A protocol to traverse data structures.</p> <p>The <a href=\"enum#into/2\"><code class=\"inline\">Enum.into/2</code></a> function uses this protocol to insert an enumerable into a collection:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.into([a: 1, b: 2], %{})\n%{a: 1, b: 2}</code></pre> <h2 id=\"module-why-collectable\" class=\"section-heading\">  Why Collectable? </h2> <p>The <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> protocol is useful to take values out of a collection. In order to support a wide range of values, the functions provided by the <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> protocol do not keep shape. For example, passing a map to <a href=\"enum#map/2\"><code class=\"inline\">Enum.map/2</code></a> always returns a list.</p> <p>This design is intentional. <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> was designed to support infinite collections, resources and other structures with fixed shape. For example, it doesn’t make sense to insert values into a range, as it has a fixed shape where just the range limits are stored.</p> <p>The <a href=\"collectable#content\"><code class=\"inline\">Collectable</code></a> module was designed to fill the gap left by the <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> protocol. <a href=\"#into/1\"><code class=\"inline\">into/1</code></a> can be seen as the opposite of <a href=\"enumerable#reduce/3\"><code class=\"inline\">Enumerable.reduce/3</code></a>. If <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> is about taking values out, <a href=\"collectable#into/1\"><code class=\"inline\">Collectable.into/1</code></a> is about collecting those values into a structure.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:command/0\">command()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#into/1\">into(collectable)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a function that collects values alongside the initial accumulation value</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:command/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:command/0\">command</a> :: {:cont, term} | :done | :halt</code></pre> </div> <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: term</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"into/1\">  <span class=\"signature\">into(collectable)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">into(<a href=\"#t:t/0\">t</a>) :: {term, (term, <a href=\"#t:command/0\">command</a> -&gt; <a href=\"#t:t/0\">t</a> | term)}</code></pre>    <p>Returns a function that collects values alongside the initial accumulation value.</p> <p>The returned function receives a collectable and injects a given value into it for every <code class=\"inline\">{:cont, term}</code> instruction.</p> <p><code class=\"inline\">:done</code> is passed when no further values will be injected, useful for closing resources and normalizing values. A collectable must be returned on <code class=\"inline\">:done</code>.</p> <p>If injection is suddenly interrupted, <code class=\"inline\">:halt</code> is passed and it can return any value, as it won’t be used.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Collectable.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Collectable.html</a>\n  </p>\n</div>\n","elixir/inspect":"<h1>  Inspect <small>protocol</small>  </h1>  <p>The <a href=\"inspect#content\"><code class=\"inline\">Inspect</code></a> protocol is responsible for converting any Elixir data structure into an algebra document. This document is then formatted, either in pretty printing format or a regular one.</p> <p>The <a href=\"#inspect/2\"><code class=\"inline\">inspect/2</code></a> function receives the entity to be inspected followed by the inspecting options, represented by the struct <a href=\"inspect.opts\"><code class=\"inline\">Inspect.Opts</code></a>.</p> <p>Inspection is done using the functions available in <a href=\"inspect.algebra\"><code class=\"inline\">Inspect.Algebra</code></a>.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <p>Many times, inspecting a structure can be implemented in function of existing entities. For example, here is <a href=\"mapset\"><code class=\"inline\">MapSet</code></a>’s <code class=\"inline\">inspect</code> implementation:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defimpl Inspect, for: MapSet do\n  import Inspect.Algebra\n\n  def inspect(dict, opts) do\n    concat [\"#MapSet&lt;\", to_doc(MapSet.to_list(dict), opts), \"&gt;\"]\n  end\nend</code></pre> <p>The <code class=\"inline\">concat</code> function comes from <a href=\"inspect.algebra\"><code class=\"inline\">Inspect.Algebra</code></a> and it concatenates algebra documents together. In the example above, it is concatenating the string <code class=\"inline\">\"MapSet&lt;\"</code> (all strings are valid algebra documents that keep their formatting when pretty printed), the document returned by <a href=\"inspect.algebra#to_doc/2\"><code class=\"inline\">Inspect.Algebra.to_doc/2</code></a> and the other string <code class=\"inline\">\"&gt;\"</code>.</p> <p>Since regular strings are valid entities in an algebra document, an implementation of inspect may simply return a string, although that will devoid it of any pretty-printing.</p> <h2 id=\"module-error-handling\" class=\"section-heading\">  Error handling </h2> <p>In case there is an error while your structure is being inspected, Elixir will raise an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> error and will automatically fall back to a raw representation for printing the structure.</p> <p>You can however access the underlying error by invoking the Inspect implementation directly. For example, to test Inspect.MapSet above, you can invoke it as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Inspect.MapSet.inspect(MapSet.new, %Inspect.Opts{})</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#inspect/2\">inspect(term, opts)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: term</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"inspect/2\">  <span class=\"signature\">inspect(term, opts)</span>  </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Inspect.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Inspect.html</a>\n  </p>\n</div>\n","elixir/list.chars":"<h1>  List.Chars <small>protocol</small>  </h1>  <p>The List.Chars protocol is responsible for converting a structure to a list (only if applicable). The only function required to be implemented is <code class=\"inline\">to_charlist</code> which does the conversion.</p> <p>The <code class=\"inline\">to_charlist</code> function automatically imported by Kernel invokes this protocol.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#to_charlist/1\">to_charlist(term)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: term</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"to_charlist/1\">  <span class=\"signature\">to_charlist(term)</span>  </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/List.Chars.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/List.Chars.html</a>\n  </p>\n</div>\n","elixir/string.chars":"<h1>  String.Chars <small>protocol</small>  </h1>  <p>The <a href=\"string.chars#content\"><code class=\"inline\">String.Chars</code></a> protocol is responsible for converting a structure to a Binary (only if applicable). The only function required to be implemented is <code class=\"inline\">to_string</code> which does the conversion.</p> <p>The <code class=\"inline\">to_string</code> function automatically imported by Kernel invokes this protocol. String interpolation also invokes <code class=\"inline\">to_string</code> in its arguments. For example, <code class=\"inline\">\"foo#{bar}\"</code> is the same as <code class=\"inline\">\"foo\" &lt;&gt; to_string(bar)</code>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:t/0\">t()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(term)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:t/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:t/0\">t</a> :: term</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"to_string/1\">  <span class=\"signature\">to_string(term)</span>  </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/String.Chars.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/String.Chars.html</a>\n  </p>\n</div>\n","eex/eex.smartengine":"<h1>  EEx.SmartEngine  </h1>  <p>The default engine used by EEx.</p> <p>It includes assigns (like <code class=\"inline\">@foo</code>) and possibly other conveniences in the future.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; EEx.eval_string(\"&lt;%= @foo %&gt;\", assigns: [foo: 1])\n\"1\"</code></pre> <p>In the example above, we can access the value <code class=\"inline\">foo</code> under the binding <code class=\"inline\">assigns</code> using <code class=\"inline\">@foo</code>. This is useful because a template, after being compiled, can receive different assigns and would not require recompilation for each variable set.</p> <p>Assigns can also be used when compiled to a function:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># sample.eex\n&lt;%= @a + @b %&gt;\n\n# sample.ex\ndefmodule Sample do\n  require EEx\n  EEx.function_from_file :def, :sample, \"sample.eex\", [:assigns]\nend\n\n# iex\nSample.sample(a: 1, b: 2) #=&gt; \"3\"</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#handle_body/1\">handle_body(body)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"eex.engine#c:handle_body/1\"><code class=\"inline\">EEx.Engine.handle_body/1</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#handle_expr/3\">handle_expr(buffer, marker, expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"eex.engine#c:handle_expr/3\"><code class=\"inline\">EEx.Engine.handle_expr/3</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#handle_text/2\">handle_text(buffer, text)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"eex.engine#c:handle_text/2\"><code class=\"inline\">EEx.Engine.handle_text/2</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#init/1\">init(opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <a href=\"eex.engine#c:init/1\"><code class=\"inline\">EEx.Engine.init/1</code></a></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"handle_body/1\">  <span class=\"signature\">handle_body(body)</span>  </h3>  <p>Callback implementation for <a href=\"eex.engine#c:handle_body/1\"><code class=\"inline\">EEx.Engine.handle_body/1</code></a>.</p>    <h3 class=\"detail-header function\" id=\"handle_expr/3\">  <span class=\"signature\">handle_expr(buffer, marker, expr)</span>  </h3>  <p>Callback implementation for <a href=\"eex.engine#c:handle_expr/3\"><code class=\"inline\">EEx.Engine.handle_expr/3</code></a>.</p>    <h3 class=\"detail-header function\" id=\"handle_text/2\">  <span class=\"signature\">handle_text(buffer, text)</span>  </h3>  <p>Callback implementation for <a href=\"eex.engine#c:handle_text/2\"><code class=\"inline\">EEx.Engine.handle_text/2</code></a>.</p>    <h3 class=\"detail-header function\" id=\"init/1\">  <span class=\"signature\">init(opts)</span>  </h3>  <p>Callback implementation for <a href=\"eex.engine#c:init/1\"><code class=\"inline\">EEx.Engine.init/1</code></a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/eex/EEx.SmartEngine.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/eex/EEx.SmartEngine.html</a>\n  </p>\n</div>\n","eex/eex.engine":"<h1>  EEx.Engine <small>behaviour</small>  </h1>  <p>Basic EEx engine that ships with Elixir.</p> <p>An engine needs to implement three functions:</p> <ul> <li>\n<p><code class=\"inline\">init(opts)</code> - returns the initial buffer</p> </li> <li>\n<p><code class=\"inline\">handle_body(quoted)</code> - receives the final built quoted expression, should do final post-processing and return a quoted expression.</p> </li> <li>\n<p><code class=\"inline\">handle_text(buffer, text)</code> - it receives the buffer, the text and must return a new quoted expression.</p> </li> <li>\n<p><code class=\"inline\">handle_expr(buffer, marker, expr)</code> - it receives the buffer, the marker, the expr and must return a new quoted expression.</p> <p>The marker is what follows exactly after <code class=\"inline\">&lt;%</code>. For example, <code class=\"inline\">&lt;% foo %&gt;</code> has an empty marker, but <code class=\"inline\">&lt;%= foo %&gt;</code> has <code class=\"inline\">\"=\"</code> as marker. The allowed markers so far are: <code class=\"inline\">\"\"</code> and <code class=\"inline\">\"=\"</code>.</p> <p>Read <a href=\"#handle_expr/3\"><code class=\"inline\">handle_expr/3</code></a> below for more information about the markers implemented by default by this engine.</p> </li> </ul> <p><a href=\"eex.engine#content\"><code class=\"inline\">EEx.Engine</code></a> can be used directly if one desires to use the default implementations for the functions above.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#handle_assign/1\">handle_assign(arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles assigns in quoted expressions</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#handle_body/1\">handle_body(quoted)</a> </dt> <dd class=\"summary-synopsis\">\n<p>The default implementation simply returns the given expression</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#handle_expr/3\">handle_expr(buffer, binary, expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Implements expressions according to the markers</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#handle_text/2\">handle_text(buffer, text)</a> </dt> <dd class=\"summary-synopsis\">\n<p>The default implementation simply concatenates text to the buffer</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#init/1\">init(opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an empty string as initial buffer</p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:handle_body/1\">handle_body(arg0)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:handle_expr/3\">handle_expr(arg0, arg1, arg2)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:handle_text/2\">handle_text(arg0, arg1)</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#c:init/1\">init(arg0)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"handle_assign/1\">  <span class=\"signature\">handle_assign(arg)</span>  </h3>  <p>Handles assigns in quoted expressions.</p> <p>A warning will be printed on missing assigns. Future versions will raise.</p> <p>This can be added to any custom engine by invoking <a href=\"#handle_assign/1\"><code class=\"inline\">handle_assign/1</code></a> with <code class=\"inline\">Macro.prewalk/2</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def handle_expr(buffer, token, expr) do\n  expr = Macro.prewalk(expr, &amp;EEx.Engine.handle_assign/1)\n  EEx.Engine.handle_expr(buffer, token, expr)\nend</code></pre>    <h3 class=\"detail-header function\" id=\"handle_body/1\">  <span class=\"signature\">handle_body(quoted)</span>  </h3>  <p>The default implementation simply returns the given expression.</p>    <h3 class=\"detail-header function\" id=\"handle_expr/3\">  <span class=\"signature\">handle_expr(buffer, binary, expr)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_expr(<a href=\"../elixir/macro#t:t/0\">Macro.t</a>, <a href=\"../elixir/string#t:t/0\">String.t</a>, <a href=\"../elixir/macro#t:t/0\">Macro.t</a>) :: <a href=\"../elixir/macro#t:t/0\">Macro.t</a></code></pre>    <p>Implements expressions according to the markers.</p> <pre data-language=\"elixir\"><code class=\"elixir\">&lt;% Elixir expression - inline with output %&gt;\n&lt;%= Elixir expression - replace with result %&gt;</code></pre> <p>All other markers are not implemented by this engine.</p>    <h3 class=\"detail-header function\" id=\"handle_text/2\">  <span class=\"signature\">handle_text(buffer, text)</span>  </h3>  <p>The default implementation simply concatenates text to the buffer.</p>    <h3 class=\"detail-header function\" id=\"init/1\">  <span class=\"signature\">init(opts)</span>  </h3>  <p>Returns an empty string as initial buffer.</p>     <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:handle_body/1\">  <span class=\"signature\">handle_body(arg0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_body(<a href=\"../elixir/macro#t:t/0\">Macro.t</a>) :: <a href=\"../elixir/macro#t:t/0\">Macro.t</a></code></pre>       <h3 class=\"detail-header callback\" id=\"c:handle_expr/3\">  <span class=\"signature\">handle_expr(arg0, arg1, arg2)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_expr(<a href=\"../elixir/macro#t:t/0\">Macro.t</a>, <a href=\"../elixir/string#t:t/0\">String.t</a>, <a href=\"../elixir/macro#t:t/0\">Macro.t</a>) :: <a href=\"../elixir/macro#t:t/0\">Macro.t</a></code></pre>       <h3 class=\"detail-header callback\" id=\"c:handle_text/2\">  <span class=\"signature\">handle_text(arg0, arg1)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">handle_text(<a href=\"../elixir/macro#t:t/0\">Macro.t</a>, <a href=\"../elixir/string#t:t/0\">String.t</a>) :: <a href=\"../elixir/macro#t:t/0\">Macro.t</a></code></pre>       <h3 class=\"detail-header callback\" id=\"c:init/1\">  <span class=\"signature\">init(arg0)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">init(<a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: <a href=\"../elixir/macro#t:t/0\">Macro.t</a></code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/eex/EEx.Engine.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/eex/EEx.Engine.html</a>\n  </p>\n</div>\n","elixir/kernel":"<h1>  Kernel  </h1>  <p>Provides the default macros and functions Elixir imports into your environment.</p> <p>These macros and functions can be skipped or cherry-picked via the <code class=\"inline\">import/2</code> macro. For instance, if you want to tell Elixir not to import the <a href=\"#if/2\"><code class=\"inline\">if/2</code></a> macro, you can do:</p> <pre data-language=\"elixir\"><code class=\"elixir\">import Kernel, except: [if: 2]</code></pre> <p>Elixir also has special forms that are always imported and cannot be skipped. These are described in <a href=\"kernel.specialforms\"><code class=\"inline\">Kernel.SpecialForms</code></a>.</p> <p>Some of the functions described in this module are inlined by the Elixir compiler into their Erlang counterparts in the <code class=\"inline\">:erlang</code> module. Those functions are called BIFs (builtin internal functions) in Erlang-land and they exhibit interesting properties, as some of them are allowed in guards and others are used for compiler optimizations.</p> <p>Most of the inlined functions can be seen in effect when capturing the function:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; &amp;Kernel.is_atom/1\n&amp;:erlang.is_atom/1</code></pre> <p>Those functions will be explicitly marked in their docs as “inlined by the compiler”.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#!=/2\">left != right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the two items are not equal</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#!==/2\">left !== right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the two items do not match</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#*/2\">left * right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Arithmetic multiplication</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#+/1\">+value</a> </dt> <dd class=\"summary-synopsis\">\n<p>Arithmetic unary plus</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#+/2\">left + right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Arithmetic addition</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#++/2\">left ++ right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Concatenates two lists</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#-/1\">-value</a> </dt> <dd class=\"summary-synopsis\">\n<p>Arithmetic unary minus</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#-/2\">left - right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Arithmetic subtraction</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#--/2\">left -- right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Removes the first occurrence of an item on the left list for each item on the right</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#//2\">left / right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Arithmetic division</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%3C/2\">left &lt; right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if left is less than right</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%3C=/2\">left &lt;= right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if left is less than or equal to right</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#==/2\">left == right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the two items are equal</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#===/2\">left === right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if the two items are match</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#=~/2\">left =~ right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Matches the term on the left against the regular expression or string on the right. Returns <code class=\"inline\">true</code> if <code class=\"inline\">left</code> matches <code class=\"inline\">right</code> (if it’s a regular expression) or contains <code class=\"inline\">right</code> (if it’s a string)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%3E/2\">left &gt; right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if left is more than right</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%3E=/2\">left &gt;= right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if left is more than or equal to right</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#abs/1\">abs(number)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an integer or float which is the arithmetical absolute value of <code class=\"inline\">number</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#apply/2\">apply(fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invokes the given <code class=\"inline\">fun</code> with the list of arguments <code class=\"inline\">args</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#apply/3\">apply(module, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Invokes the given <code class=\"inline\">fun</code> from <code class=\"inline\">module</code> with the list of arguments <code class=\"inline\">args</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#binary_part/3\">binary_part(binary, start, length)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Extracts the part of the binary starting at <code class=\"inline\">start</code> with length <code class=\"inline\">length</code>. Binaries are zero-indexed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#bit_size/1\">bit_size(bitstring)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an integer which is the size in bits of <code class=\"inline\">bitstring</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#byte_size/1\">byte_size(bitstring)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the number of bytes needed to contain <code class=\"inline\">bitstring</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#div/2\">div(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Performs an integer division</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#elem/2\">elem(tuple, index)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the element at the zero-based <code class=\"inline\">index</code> in <code class=\"inline\">tuple</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#exit/1\">exit(reason)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Stops the execution of the calling process with the given reason</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#function_exported?/3\">function_exported?(module, function, arity)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">module</code> is loaded and contains a public <code class=\"inline\">function</code> with the given <code class=\"inline\">arity</code>, otherwise <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_and_update_in/3\">get_and_update_in(data, keys, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets a value and updates a nested structure</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_in/2\">get_in(data, keys)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets a value from a nested structure</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#hd/1\">hd(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the head of a list; raises <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> if the list is empty</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#inspect/2\">inspect(arg, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inspects the given argument according to the <a href=\"inspect\"><code class=\"inline\">Inspect</code></a> protocol. The second argument is a keyword list with options to control inspection</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_atom/1\">is_atom(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is an atom; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_binary/1\">is_binary(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a binary; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_bitstring/1\">is_bitstring(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a bitstring (including a binary); otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_boolean/1\">is_boolean(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is either the atom <code class=\"inline\">true</code> or the atom <code class=\"inline\">false</code> (i.e., a boolean); otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_float/1\">is_float(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a floating point number; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_function/1\">is_function(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a function; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_function/2\">is_function(term, arity)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a function that can be applied with <code class=\"inline\">arity</code> number of arguments; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_integer/1\">is_integer(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is an integer; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_list/1\">is_list(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a list with zero or more elements; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_map/1\">is_map(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a map; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_number/1\">is_number(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is either an integer or a floating point number; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_pid/1\">is_pid(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a pid (process identifier); otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_port/1\">is_port(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a port identifier; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_reference/1\">is_reference(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a reference; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_tuple/1\">is_tuple(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a tuple; otherwise returns <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#length/1\">length(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the length of <code class=\"inline\">list</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#macro_exported?/3\">macro_exported?(module, macro, arity)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">module</code> is loaded and contains a public <code class=\"inline\">macro</code> with the given <code class=\"inline\">arity</code>, otherwise <code class=\"inline\">false</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#make_ref/0\">make_ref()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an almost unique reference</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#map_size/1\">map_size(map)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the size of a map</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#max/2\">max(first, second)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the biggest of the two given terms according to Erlang’s term ordering. If the terms compare equal, the first one is returned</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#min/2\">min(first, second)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the smallest of the two given terms according to Erlang’s term ordering. If the terms compare equal, the first one is returned</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#node/0\">node()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns an atom representing the name of the local node. If the node is not alive, <code class=\"inline\">:nonode@nohost</code> is returned instead</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#node/1\">node(arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the node where the given argument is located. The argument can be a pid, a reference, or a port. If the local node is not alive, <code class=\"inline\">:nonode@nohost</code> is returned</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#not/1\">not arg</a> </dt> <dd class=\"summary-synopsis\">\n<p>Boolean not</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pop_in/2\">pop_in(data, keys)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Pops a key from the given nested structure</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_elem/3\">put_elem(tuple, index, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Inserts <code class=\"inline\">value</code> at the given zero-based <code class=\"inline\">index</code> in <code class=\"inline\">tuple</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_in/3\">put_in(data, keys, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts a value in a nested structure</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rem/2\">rem(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Computes the remainder of an integer division</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#round/1\">round(number)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Rounds a number to the nearest integer</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#self/0\">self()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the pid (process identifier) of the calling process</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#send/2\">send(dest, msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Sends a message to the given <code class=\"inline\">dest</code> and returns the message</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn/1\">spawn(fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Spawns the given function and returns its pid</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn/3\">spawn(module, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Spawns the given module and function passing the given args and returns its pid</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn_link/1\">spawn_link(fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Spawns the given function, links it to the current process and returns its pid</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn_link/3\">spawn_link(module, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Spawns the given module and function passing the given args, links it to the current process and returns its pid</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn_monitor/1\">spawn_monitor(fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Spawns the given function, monitors it and returns its pid and monitoring reference</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#spawn_monitor/3\">spawn_monitor(module, fun, args)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Spawns the given module and function passing the given args, monitors it and returns its pid and monitoring reference</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#struct/2\">struct(struct, kv \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates and updates structs</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#struct!/2\">struct!(struct, kv \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Similar to <a href=\"#struct/2\"><code class=\"inline\">struct/2</code></a> but checks for key validity</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#throw/1\">throw(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A non-local return from a function. Check <a href=\"kernel.specialforms#try/1\"><code class=\"inline\">Kernel.SpecialForms.try/1</code></a> for more information</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#tl/1\">tl(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the tail of a list. Raises <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> if the list is empty</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#trunc/1\">trunc(number)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the integer part of <code class=\"inline\">number</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#tuple_size/1\">tuple_size(tuple)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the size of a tuple</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update_in/3\">update_in(data, keys, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates a key in a nested structure</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#!/1\">!arg</a> </dt> <dd class=\"summary-synopsis\">\n<p>Boolean not</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#&amp;&amp;/2\">left &amp;&amp; right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to <code class=\"inline\">true</code> (i.e., it is neither <code class=\"inline\">nil</code> nor <code class=\"inline\">false</code>). Returns the first expression otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#../2\">first..last</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a range with the specified start and end</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%3C%3E/2\">left &lt;&gt; right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Concatenates two binaries</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#@/1\">@expr</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reads and writes attributes of the current module</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#alias!/1\">alias!(alias)</a> </dt> <dd class=\"summary-synopsis\">\n<p>When used inside quoting, marks that the given alias should not be hygienized. This means the alias will be expanded when the macro is expanded</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#and/2\">left and right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Boolean and</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#binding/1\">binding(context \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the binding for the given context as a keyword list</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#def/2\">def(call, expr \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a function with the given name and body</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defdelegate/2\">defdelegate(funs, opts)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a function that delegates to another module</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defexception/1\">defexception(fields)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines an exception</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defimpl/3\">defimpl(name, opts, do_block \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines an implementation for the given protocol</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defmacro/2\">defmacro(call, expr \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a macro with the given name and body</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defmacrop/2\">defmacrop(call, expr \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a private macro with the given name and body</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defmodule/2\">defmodule(alias, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a module given by name with the given contents</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defoverridable/1\">defoverridable(keywords)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Makes the given functions in the current module overridable</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defp/2\">defp(call, expr \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a private function with the given name and body</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defprotocol/2\">defprotocol(name, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a protocol</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#defstruct/1\">defstruct(fields)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a struct</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#destructure/2\">destructure(left, right)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Destructures two lists, assigning each term in the right one to the matching term in the left one</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get_and_update_in/2\">get_and_update_in(path, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets a value and updates a nested data structure via the given <code class=\"inline\">path</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#if/2\">if(condition, clauses)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Provides an <a href=\"#if/2\"><code class=\"inline\">if/2</code></a> macro</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#in/2\">left in right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the element on the left-hand side is a member of the collection on the right-hand side</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#is_nil/1\">is_nil(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is <code class=\"inline\">nil</code>, <code class=\"inline\">false</code> otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#match?/2\">match?(pattern, expr)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A convenience macro that checks if the right side (an expression) matches the left side (a pattern)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#or/2\">left or right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Boolean or</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pop_in/1\">pop_in(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Pops a key from the nested structure via the given <code class=\"inline\">path</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#put_in/2\">put_in(path, value)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Puts a value in a nested structure via the given <code class=\"inline\">path</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#raise/1\">raise(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Raises an exception</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#raise/2\">raise(exception, attrs)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Raises an exception</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reraise/2\">reraise(msg, stacktrace)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Raises an exception preserving a previous stacktrace</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reraise/3\">reraise(exception, attrs, stacktrace)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Raises an exception preserving a previous stacktrace</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sigil_C/2\">sigil_C(term, modifiers)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles the sigil <code class=\"inline\">~C</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sigil_D/2\">sigil_D(date, modifiers)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles the sigil <code class=\"inline\">~D</code> for dates</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sigil_N/2\">sigil_N(date, modifiers)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles the sigil <code class=\"inline\">~N</code> for naive date times</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sigil_R/2\">sigil_R(term, modifiers)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles the sigil <code class=\"inline\">~R</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sigil_S/2\">sigil_S(term, modifiers)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles the sigil <code class=\"inline\">~S</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sigil_T/2\">sigil_T(date, modifiers)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles the sigil <code class=\"inline\">~T</code> for times</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sigil_W/2\">sigil_W(term, modifiers)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles the sigil <code class=\"inline\">~W</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sigil_c/2\">sigil_c(term, modifiers)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles the sigil <code class=\"inline\">~c</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sigil_r/2\">sigil_r(term, modifiers)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles the sigil <code class=\"inline\">~r</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sigil_s/2\">sigil_s(term, modifiers)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles the sigil <code class=\"inline\">~s</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#sigil_w/2\">sigil_w(term, modifiers)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Handles the sigil <code class=\"inline\">~w</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_charlist/1\">to_charlist(arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the argument to a charlist according to the <a href=\"list.chars\"><code class=\"inline\">List.Chars</code></a> protocol</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#to_string/1\">to_string(arg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Converts the argument to a string according to the <a href=\"string.chars\"><code class=\"inline\">String.Chars</code></a> protocol</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#unless/2\">unless(condition, clauses)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Provides an <code class=\"inline\">unless</code> macro</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#update_in/2\">update_in(path, fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Updates a nested structure via the given <code class=\"inline\">path</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#use/2\">use(module, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Uses the given module in the current context</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#var!/2\">var!(var, context \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>When used inside quoting, marks that the given variable should not be hygienized</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%7C%3E/2\">left |&gt; right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Pipe operator</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#%7C%7C/2\">left || right</a> </dt> <dd class=\"summary-synopsis\">\n<p>Provides a short-circuit operator that evaluates and returns the second expression only if the first one does not evaluate to <code class=\"inline\">true</code> (i.e., it is either <code class=\"inline\">nil</code> or <code class=\"inline\">false</code>). Returns the first expression otherwise</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"!=/2\">  <span class=\"signature\">left != right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">term != term :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if the two items are not equal.</p> <p>This operator considers 1 and 1.0 to be equal. For match comparison, use <code class=\"inline\">!==</code> instead.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 != 2\ntrue\n\niex&gt; 1 != 1.0\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"!==/2\">  <span class=\"signature\">left !== right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">term !== term :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if the two items do not match.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 !== 2\ntrue\n\niex&gt; 1 !== 1.0\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"*/2\">  <span class=\"signature\">left * right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">number * number :: number</code></pre>    <p>Arithmetic multiplication.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 * 2\n2</code></pre>    <h3 class=\"detail-header function\" id=\"+/1\">  <span class=\"signature\">+value</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">+number :: number</code></pre>    <p>Arithmetic unary plus.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; +1\n1</code></pre>    <h3 class=\"detail-header function\" id=\"+/2\">  <span class=\"signature\">left + right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">number + number :: number</code></pre>    <p>Arithmetic addition.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 + 2\n3</code></pre>    <h3 class=\"detail-header function\" id=\"++/2\">  <span class=\"signature\">left ++ right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">list ++ term :: maybe_improper_list</code></pre>    <p>Concatenates two lists.</p> <p>The complexity of <code class=\"inline\">a ++ b</code> is proportional to <code class=\"inline\">length(a)</code>, so avoid repeatedly appending to lists of arbitrary length, e.g. <code class=\"inline\">list ++ [item]</code>.</p> <p>Instead, consider prepending via <code class=\"inline\">[item | rest]</code> and then reversing.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; [1] ++ [2, 3]\n[1, 2, 3]\n\niex&gt; 'foo' ++ 'bar'\n'foobar'</code></pre>    <h3 class=\"detail-header function\" id=\"-/1\">  <span class=\"signature\">-value</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">-number :: number</code></pre>    <p>Arithmetic unary minus.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; -2\n-2</code></pre>    <h3 class=\"detail-header function\" id=\"-/2\">  <span class=\"signature\">left - right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">number - number :: number</code></pre>    <p>Arithmetic subtraction.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 - 2\n-1</code></pre>    <h3 class=\"detail-header function\" id=\"--/2\">  <span class=\"signature\">left -- right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">list -- list :: list</code></pre>    <p>Removes the first occurrence of an item on the left list for each item on the right.</p> <p>The complexity of <code class=\"inline\">a -- b</code> is proportional to <code class=\"inline\">length(a) * length(b)</code>, meaning that it will be very slow if both <code class=\"inline\">a</code> and <code class=\"inline\">b</code> are long lists. In such cases, consider converting each list to a <a href=\"mapset\"><code class=\"inline\">MapSet</code></a> and using <a href=\"mapset#difference/2\"><code class=\"inline\">MapSet.difference/2</code></a>.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; [1, 2, 3] -- [1, 2]\n[3]\n\niex&gt; [1, 2, 3, 2, 1] -- [1, 2, 2]\n[3, 1]</code></pre>    <h3 class=\"detail-header function\" id=\"//2\">  <span class=\"signature\">left / right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">number / number :: float</code></pre>    <p>Arithmetic division.</p> <p>The result is always a float. Use <a href=\"#div/2\"><code class=\"inline\">div/2</code></a> and <a href=\"#rem/2\"><code class=\"inline\">rem/2</code></a> if you want an integer division or the remainder.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 / 2\n0.5\n\niex&gt; 2 / 1\n2.0</code></pre>    <h3 class=\"detail-header function\" id=\"%3C/2\">  <span class=\"signature\">left &lt; right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">term &lt; term :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if left is less than right.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 &lt; 2\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"%3C=/2\">  <span class=\"signature\">left &lt;= right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">term &lt;= term :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if left is less than or equal to right.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 &lt;= 2\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"==/2\">  <span class=\"signature\">left == right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">term == term :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if the two items are equal.</p> <p>This operator considers 1 and 1.0 to be equal. For match semantics, use <code class=\"inline\">===</code> instead.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 == 2\nfalse\n\niex&gt; 1 == 1.0\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"===/2\">  <span class=\"signature\">left === right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">term === term :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if the two items are match.</p> <p>This operator gives the same semantics as the one existing in pattern matching, i.e., <code class=\"inline\">1</code> and <code class=\"inline\">1.0</code> are equal, but they do not match.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 === 2\nfalse\n\niex&gt; 1 === 1.0\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"=~/2\">  <span class=\"signature\">left =~ right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"string#t:t/0\">String.t</a> =~ (<a href=\"string#t:t/0\">String.t</a> | <a href=\"regex#t:t/0\">Regex.t</a>) :: boolean</code></pre>    <p>Matches the term on the left against the regular expression or string on the right. Returns <code class=\"inline\">true</code> if <code class=\"inline\">left</code> matches <code class=\"inline\">right</code> (if it’s a regular expression) or contains <code class=\"inline\">right</code> (if it’s a string).</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; \"abcd\" =~ ~r/c(d)/\ntrue\n\niex&gt; \"abcd\" =~ ~r/e/\nfalse\n\niex&gt; \"abcd\" =~ \"bc\"\ntrue\n\niex&gt; \"abcd\" =~ \"ad\"\nfalse\n\niex&gt; \"abcd\" =~ \"\"\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"%3E/2\">  <span class=\"signature\">left &gt; right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">term &gt; term :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if left is more than right.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 &gt; 2\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"%3E=/2\">  <span class=\"signature\">left &gt;= right</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">term &gt;= term :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if left is more than or equal to right.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 1 &gt;= 2\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"abs/1\">  <span class=\"signature\">abs(number)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">abs(number) :: number</code></pre>    <p>Returns an integer or float which is the arithmetical absolute value of <code class=\"inline\">number</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; abs(-3.33)\n3.33\n\niex&gt; abs(-3)\n3</code></pre>    <h3 class=\"detail-header function\" id=\"apply/2\">  <span class=\"signature\">apply(fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">apply((... -&gt; any), [any]) :: any</code></pre>    <p>Invokes the given <code class=\"inline\">fun</code> with the list of arguments <code class=\"inline\">args</code>.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; apply(fn x -&gt; x * 2 end, [2])\n4</code></pre>    <h3 class=\"detail-header function\" id=\"apply/3\">  <span class=\"signature\">apply(module, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">apply(module, atom, [any]) :: any</code></pre>    <p>Invokes the given <code class=\"inline\">fun</code> from <code class=\"inline\">module</code> with the list of arguments <code class=\"inline\">args</code>.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; apply(Enum, :reverse, [[1, 2, 3]])\n[3, 2, 1]</code></pre>    <h3 class=\"detail-header function\" id=\"binary_part/3\">  <span class=\"signature\">binary_part(binary, start, length)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">binary_part(binary, pos_integer, integer) :: binary</code></pre>    <p>Extracts the part of the binary starting at <code class=\"inline\">start</code> with length <code class=\"inline\">length</code>. Binaries are zero-indexed.</p> <p>If <code class=\"inline\">start</code> or <code class=\"inline\">length</code> reference in any way outside the binary, an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> exception is raised.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; binary_part(\"foo\", 1, 2)\n\"oo\"</code></pre> <p>A negative <code class=\"inline\">length</code> can be used to extract bytes that come <em>before</em> the byte at <code class=\"inline\">start</code>:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; binary_part(\"Hello\", 5, -3)\n\"llo\"</code></pre>    <h3 class=\"detail-header function\" id=\"bit_size/1\">  <span class=\"signature\">bit_size(bitstring)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">bit_size(bitstring) :: non_neg_integer</code></pre>    <p>Returns an integer which is the size in bits of <code class=\"inline\">bitstring</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; bit_size(&lt;&lt;433::16, 3::3&gt;&gt;)\n19\n\niex&gt; bit_size(&lt;&lt;1, 2, 3&gt;&gt;)\n24</code></pre>    <h3 class=\"detail-header function\" id=\"byte_size/1\">  <span class=\"signature\">byte_size(bitstring)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">byte_size(bitstring) :: non_neg_integer</code></pre>    <p>Returns the number of bytes needed to contain <code class=\"inline\">bitstring</code>.</p> <p>That is, if the number of bits in <code class=\"inline\">bitstring</code> is not divisible by 8, the resulting number of bytes will be rounded up (by excess). This operation happens in constant time.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; byte_size(&lt;&lt;433::16, 3::3&gt;&gt;)\n3\n\niex&gt; byte_size(&lt;&lt;1, 2, 3&gt;&gt;)\n3</code></pre>    <h3 class=\"detail-header function\" id=\"div/2\">  <span class=\"signature\">div(left, right)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">div(integer, integer) :: integer</code></pre>    <p>Performs an integer division.</p> <p>Raises an <a href=\"arithmeticerror\"><code class=\"inline\">ArithmeticError</code></a> exception if one of the arguments is not an integer.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; div(5, 2)\n2</code></pre>    <h3 class=\"detail-header function\" id=\"elem/2\">  <span class=\"signature\">elem(tuple, index)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">elem(tuple, non_neg_integer) :: term</code></pre>    <p>Gets the element at the zero-based <code class=\"inline\">index</code> in <code class=\"inline\">tuple</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; tuple = {:foo, :bar, 3}\niex&gt; elem(tuple, 1)\n:bar</code></pre>    <h3 class=\"detail-header function\" id=\"exit/1\">  <span class=\"signature\">exit(reason)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exit(term) :: no_return</code></pre>    <p>Stops the execution of the calling process with the given reason.</p> <p>Since evaluating this function causes the process to terminate, it has no return value.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <p>When a process reaches its end, by default it exits with reason <code class=\"inline\">:normal</code>. You can also call <a href=\"#exit/1\"><code class=\"inline\">exit/1</code></a> explicitly if you want to terminate a process but not signal any failure:</p> <pre data-language=\"elixir\"><code class=\"elixir\">exit(:normal)</code></pre> <p>In case something goes wrong, you can also use <a href=\"#exit/1\"><code class=\"inline\">exit/1</code></a> with a different reason:</p> <pre data-language=\"elixir\"><code class=\"elixir\">exit(:seems_bad)</code></pre> <p>If the exit reason is not <code class=\"inline\">:normal</code>, all the processes linked to the process that exited will crash (unless they are trapping exits).</p> <h4>OTP exits</h4> <p>Exits are used by the OTP to determine if a process exited abnormally or not. The following exits are considered “normal”:</p> <ul> <li>\n<code class=\"inline\">exit(:normal)</code> </li> <li>\n<code class=\"inline\">exit(:shutdown)</code> </li> <li>\n<code class=\"inline\">exit({:shutdown, term})</code> </li> </ul> <p>Exiting with any other reason is considered abnormal and treated as a crash. This means the default supervisor behaviour kicks in, error reports are emitted, etc.</p> <p>This behaviour is relied on in many different places. For example, <code class=\"inline\">ExUnit</code> uses <code class=\"inline\">exit(:shutdown)</code> when exiting the test process to signal linked processes, supervision trees and so on to politely shutdown too.</p> <h4>CLI exits</h4> <p>Building on top of the exit signals mentioned above, if the process started by the command line exits with any of the three reasons above, its exit is considered normal and the Operating System process will exit with status 0.</p> <p>It is, however, possible to customize the Operating System exit signal by invoking:</p> <pre data-language=\"elixir\"><code class=\"elixir\">exit({:shutdown, integer})</code></pre> <p>This will cause the OS process to exit with the status given by <code class=\"inline\">integer</code> while signaling all linked OTP processes to politely shutdown.</p> <p>Any other exit reason will cause the OS process to exit with status <code class=\"inline\">1</code> and linked OTP processes to crash.</p>    <h3 class=\"detail-header function\" id=\"function_exported?/3\">  <span class=\"signature\">function_exported?(module, function, arity)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">function_exported?(atom | tuple, atom, arity) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">module</code> is loaded and contains a public <code class=\"inline\">function</code> with the given <code class=\"inline\">arity</code>, otherwise <code class=\"inline\">false</code>.</p> <p>Note that this function does not load the module in case it is not loaded. Check <a href=\"code#ensure_loaded/1\"><code class=\"inline\">Code.ensure_loaded/1</code></a> for more information.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; function_exported?(Enum, :member?, 2)\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"get_and_update_in/3\">  <span class=\"signature\">get_and_update_in(data, keys, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_and_update_in(<a href=\"access#t:t/0\">Access.t</a>, [term, ...], (term -&gt; {get, term})) :: {get, <a href=\"access#t:t/0\">Access.t</a>} when get: var</code></pre>    <p>Gets a value and updates a nested structure.</p> <p>It expects a tuple to be returned, containing the value retrieved and the update one.</p> <p>It uses the <a href=\"access\"><code class=\"inline\">Access</code></a> module to traverse the structures according to the given <code class=\"inline\">keys</code>, unless the <code class=\"inline\">key</code> is a function.</p> <p>If a key is a function, the function will be invoked passing three arguments, the operation (<code class=\"inline\">:get_and_update</code>), the data to be accessed, and a function to be invoked next.</p> <p>This means <a href=\"#get_and_update_in/3\"><code class=\"inline\">get_and_update_in/3</code></a> can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</p> <h4>Examples</h4> <p>This function is useful when there is a need to retrieve the current value (or something calculated in function of the current value) and update it at the same time. For example, it could be used to increase the age of a user by one and return the previous age in one pass:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; get_and_update_in(users, [\"john\", :age], &amp;{&amp;1, &amp;1 + 1})\n{27, %{\"john\" =&gt; %{age: 28}, \"meg\" =&gt; %{age: 23}}}</code></pre> <p>When one of the keys is a function, the function is invoked. In the example below, we use a function to get and increment all ages inside a list:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\niex&gt; all = fn :get_and_update, data, next -&gt;\n...&gt;   Enum.map(data, next) |&gt; :lists.unzip\n...&gt; end\niex&gt; get_and_update_in(users, [all, :age], &amp;{&amp;1, &amp;1 + 1})\n{[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}</code></pre> <p>If the previous value before invoking the function is <code class=\"inline\">nil</code>, the function <em>will</em> receive <code class=\"inline\">nil</code> as a value and must handle it accordingly (be it by failing or providing a sane default).</p> <p>The <a href=\"access\"><code class=\"inline\">Access</code></a> module ships with many convenience accessor functions, like the <code class=\"inline\">all</code> function defined above. See <a href=\"access#all/0\"><code class=\"inline\">Access.all/0</code></a>, <code class=\"inline\">Access.key/1</code> and others as examples.</p>    <h3 class=\"detail-header function\" id=\"get_in/2\">  <span class=\"signature\">get_in(data, keys)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get_in(<a href=\"access#t:t/0\">Access.t</a>, [term, ...]) :: term</code></pre>    <p>Gets a value from a nested structure.</p> <p>Uses the <a href=\"access\"><code class=\"inline\">Access</code></a> module to traverse the structures according to the given <code class=\"inline\">keys</code>, unless the <code class=\"inline\">key</code> is a function.</p> <p>If a key is a function, the function will be invoked passing three arguments, the operation (<code class=\"inline\">:get</code>), the data to be accessed, and a function to be invoked next.</p> <p>This means <a href=\"#get_in/2\"><code class=\"inline\">get_in/2</code></a> can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; get_in(users, [\"john\", :age])\n27</code></pre> <p>In case any of entries in the middle returns <code class=\"inline\">nil</code>, <code class=\"inline\">nil</code> will be returned as per the Access module:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; get_in(users, [\"unknown\", :age])\nnil</code></pre> <p>When one of the keys is a function, the function is invoked. In the example below, we use a function to get all the maps inside a list:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\niex&gt; all = fn :get, data, next -&gt; Enum.map(data, next) end\niex&gt; get_in(users, [all, :age])\n[27, 23]</code></pre> <p>If the previous value before invoking the function is <code class=\"inline\">nil</code>, the function <em>will</em> receive nil as a value and must handle it accordingly.</p>    <h3 class=\"detail-header function\" id=\"hd/1\">  <span class=\"signature\">hd(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">hd(maybe_improper_list) :: term</code></pre>    <p>Returns the head of a list; raises <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> if the list is empty.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; hd([1, 2, 3, 4])\n1</code></pre>    <h3 class=\"detail-header function\" id=\"inspect/2\">  <span class=\"signature\">inspect(arg, opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">inspect(<a href=\"inspect#t:t/0\">Inspect.t</a>, <a href=\"keyword#t:t/0\">Keyword.t</a>) :: <a href=\"string#t:t/0\">String.t</a></code></pre>    <p>Inspects the given argument according to the <a href=\"inspect\"><code class=\"inline\">Inspect</code></a> protocol. The second argument is a keyword list with options to control inspection.</p> <h4>Options</h4> <p><a href=\"#inspect/2\"><code class=\"inline\">inspect/2</code></a> accepts a list of options that are internally translated to an <a href=\"inspect.opts\"><code class=\"inline\">Inspect.Opts</code></a> struct. Check the docs for <a href=\"inspect.opts\"><code class=\"inline\">Inspect.Opts</code></a> to see the supported options.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; inspect(:foo)\n\":foo\"\n\niex&gt; inspect [1, 2, 3, 4, 5], limit: 3\n\"[1, 2, 3, ...]\"\n\niex&gt; inspect [1, 2, 3], pretty: true, width: 0\n\"[1,\\n 2,\\n 3]\"\n\niex&gt; inspect(\"olá\" &lt;&gt; &lt;&lt;0&gt;&gt;)\n\"&lt;&lt;111, 108, 195, 161, 0&gt;&gt;\"\n\niex&gt; inspect(\"olá\" &lt;&gt; &lt;&lt;0&gt;&gt;, binaries: :as_strings)\n\"\\\"olá\\\\0\\\"\"\n\niex&gt; inspect(\"olá\", binaries: :as_binaries)\n\"&lt;&lt;111, 108, 195, 161&gt;&gt;\"\n\niex&gt; inspect('bar')\n\"'bar'\"\n\niex&gt; inspect([0 | 'bar'])\n\"[0, 98, 97, 114]\"\n\niex&gt; inspect(100, base: :octal)\n\"0o144\"\n\niex&gt; inspect(100, base: :hex)\n\"0x64\"</code></pre> <p>Note that the <a href=\"inspect\"><code class=\"inline\">Inspect</code></a> protocol does not necessarily return a valid representation of an Elixir term. In such cases, the inspected result must start with <code class=\"inline\">#</code>. For example, inspecting a function will return:</p> <pre data-language=\"elixir\"><code class=\"elixir\">inspect fn a, b -&gt; a + b end\n#=&gt; #Function&lt;...&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"is_atom/1\">  <span class=\"signature\">is_atom(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_atom(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is an atom; otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"is_binary/1\">  <span class=\"signature\">is_binary(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_binary(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a binary; otherwise returns <code class=\"inline\">false</code>.</p> <p>A binary always contains a complete number of bytes.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; is_binary \"foo\"\ntrue\niex&gt; is_binary &lt;&lt;1::3&gt;&gt;\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"is_bitstring/1\">  <span class=\"signature\">is_bitstring(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_bitstring(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a bitstring (including a binary); otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; is_bitstring \"foo\"\ntrue\niex&gt; is_bitstring &lt;&lt;1::3&gt;&gt;\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"is_boolean/1\">  <span class=\"signature\">is_boolean(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_boolean(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is either the atom <code class=\"inline\">true</code> or the atom <code class=\"inline\">false</code> (i.e., a boolean); otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"is_float/1\">  <span class=\"signature\">is_float(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_float(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a floating point number; otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"is_function/1\">  <span class=\"signature\">is_function(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_function(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a function; otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"is_function/2\">  <span class=\"signature\">is_function(term, arity)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_function(term, non_neg_integer) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a function that can be applied with <code class=\"inline\">arity</code> number of arguments; otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; is_function(fn(x) -&gt; x * 2 end, 1)\ntrue\niex&gt; is_function(fn(x) -&gt; x * 2 end, 2)\nfalse</code></pre>    <h3 class=\"detail-header function\" id=\"is_integer/1\">  <span class=\"signature\">is_integer(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_integer(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is an integer; otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"is_list/1\">  <span class=\"signature\">is_list(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_list(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a list with zero or more elements; otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"is_map/1\">  <span class=\"signature\">is_map(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_map(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a map; otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"is_number/1\">  <span class=\"signature\">is_number(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_number(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is either an integer or a floating point number; otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"is_pid/1\">  <span class=\"signature\">is_pid(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_pid(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a pid (process identifier); otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"is_port/1\">  <span class=\"signature\">is_port(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_port(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a port identifier; otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"is_reference/1\">  <span class=\"signature\">is_reference(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_reference(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a reference; otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"is_tuple/1\">  <span class=\"signature\">is_tuple(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">is_tuple(term) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is a tuple; otherwise returns <code class=\"inline\">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"length/1\">  <span class=\"signature\">length(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">length(list) :: non_neg_integer</code></pre>    <p>Returns the length of <code class=\"inline\">list</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n9</code></pre>    <h3 class=\"detail-header function\" id=\"macro_exported?/3\">  <span class=\"signature\">macro_exported?(module, macro, arity)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">macro_exported?(atom, atom, integer) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">module</code> is loaded and contains a public <code class=\"inline\">macro</code> with the given <code class=\"inline\">arity</code>, otherwise <code class=\"inline\">false</code>.</p> <p>Note that this function does not load the module in case it is not loaded. Check <a href=\"code#ensure_loaded/1\"><code class=\"inline\">Code.ensure_loaded/1</code></a> for more information.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; macro_exported?(Kernel, :use, 2)\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"make_ref/0\">  <span class=\"signature\">make_ref()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">make_ref :: reference</code></pre>    <p>Returns an almost unique reference.</p> <p>The returned reference will re-occur after approximately 2^82 calls; therefore it is unique enough for practical purposes.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">make_ref() #=&gt; #Reference&lt;0.0.0.135&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"map_size/1\">  <span class=\"signature\">map_size(map)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">map_size(map) :: non_neg_integer</code></pre>    <p>Returns the size of a map.</p> <p>The size of a map is the number of key-value pairs that the map contains.</p> <p>This operation happens in constant time.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; map_size(%{a: \"foo\", b: \"bar\"})\n2</code></pre>    <h3 class=\"detail-header function\" id=\"max/2\">  <span class=\"signature\">max(first, second)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">max(term, term) :: term</code></pre>    <p>Returns the biggest of the two given terms according to Erlang’s term ordering. If the terms compare equal, the first one is returned.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; max(1, 2)\n2\niex&gt; max(:a, :b)\n:b</code></pre>    <h3 class=\"detail-header function\" id=\"min/2\">  <span class=\"signature\">min(first, second)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">min(term, term) :: term</code></pre>    <p>Returns the smallest of the two given terms according to Erlang’s term ordering. If the terms compare equal, the first one is returned.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; min(1, 2)\n1\niex&gt; min(\"foo\", \"bar\")\n\"bar\"</code></pre>    <h3 class=\"detail-header function\" id=\"node/0\">  <span class=\"signature\">node()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">node :: node</code></pre>    <p>Returns an atom representing the name of the local node. If the node is not alive, <code class=\"inline\">:nonode@nohost</code> is returned instead.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"node/1\">  <span class=\"signature\">node(arg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">node(pid | reference | port) :: node</code></pre>    <p>Returns the node where the given argument is located. The argument can be a pid, a reference, or a port. If the local node is not alive, <code class=\"inline\">:nonode@nohost</code> is returned.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"not/1\">  <span class=\"signature\">not arg</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">not boolean :: boolean</code></pre>    <p>Boolean not.</p> <p><code class=\"inline\">arg</code> must be a boolean; if it’s not, an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> exception is raised.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; not false\ntrue</code></pre>    <h3 class=\"detail-header function\" id=\"pop_in/2\">  <span class=\"signature\">pop_in(data, keys)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">pop_in(<a href=\"access#t:t/0\">Access.t</a>, [term, ...]) :: {term, <a href=\"access#t:t/0\">Access.t</a>}</code></pre>    <p>Pops a key from the given nested structure.</p> <p>Uses the <a href=\"access\"><code class=\"inline\">Access</code></a> protocol to traverse the structures according to the given <code class=\"inline\">keys</code>, unless the <code class=\"inline\">key</code> is a function. If the key is a function, it will be invoked as specified in <a href=\"#get_and_update_in/3\"><code class=\"inline\">get_and_update_in/3</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; pop_in(users, [\"john\", :age])\n{27, %{\"john\" =&gt; %{}, \"meg\" =&gt; %{age: 23}}}</code></pre> <p>In case any entry returns <code class=\"inline\">nil</code>, its key will be removed and the deletion will be considered a success.</p>    <h3 class=\"detail-header function\" id=\"put_elem/3\">  <span class=\"signature\">put_elem(tuple, index, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_elem(tuple, non_neg_integer, term) :: tuple</code></pre>    <p>Inserts <code class=\"inline\">value</code> at the given zero-based <code class=\"inline\">index</code> in <code class=\"inline\">tuple</code>.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; tuple = {:foo, :bar, 3}\niex&gt; put_elem(tuple, 0, :baz)\n{:baz, :bar, 3}</code></pre>    <h3 class=\"detail-header function\" id=\"put_in/3\">  <span class=\"signature\">put_in(data, keys, value)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">put_in(<a href=\"access#t:t/0\">Access.t</a>, [term, ...], term) :: <a href=\"access#t:t/0\">Access.t</a></code></pre>    <p>Puts a value in a nested structure.</p> <p>Uses the <a href=\"access\"><code class=\"inline\">Access</code></a> module to traverse the structures according to the given <code class=\"inline\">keys</code>, unless the <code class=\"inline\">key</code> is a function. If the key is a function, it will be invoked as specified in <a href=\"#get_and_update_in/3\"><code class=\"inline\">get_and_update_in/3</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; put_in(users, [\"john\", :age], 28)\n%{\"john\" =&gt; %{age: 28}, \"meg\" =&gt; %{age: 23}}</code></pre> <p>In case any of entries in the middle returns <code class=\"inline\">nil</code>, an error will be raised when trying to access it next.</p>    <h3 class=\"detail-header function\" id=\"rem/2\">  <span class=\"signature\">rem(left, right)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rem(integer, integer) :: integer</code></pre>    <p>Computes the remainder of an integer division.</p> <p>Raises an <a href=\"arithmeticerror\"><code class=\"inline\">ArithmeticError</code></a> exception if one of the arguments is not an integer.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; rem(5, 2)\n1</code></pre>    <h3 class=\"detail-header function\" id=\"round/1\">  <span class=\"signature\">round(number)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">round(number) :: integer</code></pre>    <p>Rounds a number to the nearest integer.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; round(5.6)\n6\niex&gt; round(5.2)\n5\niex&gt; round(-9.9)\n-10</code></pre>    <h3 class=\"detail-header function\" id=\"self/0\">  <span class=\"signature\">self()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">self :: pid</code></pre>    <p>Returns the pid (process identifier) of the calling process.</p> <p>Allowed in guard clauses. Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"send/2\">  <span class=\"signature\">send(dest, msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">send(dest :: pid | port | atom | {atom, node}, msg) :: msg when msg: any</code></pre>    <p>Sends a message to the given <code class=\"inline\">dest</code> and returns the message.</p> <p><code class=\"inline\">dest</code> may be a remote or local pid, a (local) port, a locally registered name, or a tuple <code class=\"inline\">{registered_name, node}</code> for a registered name at another node.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; send self(), :hello\n:hello</code></pre>    <h3 class=\"detail-header function\" id=\"spawn/1\">  <span class=\"signature\">spawn(fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn((() -&gt; any)) :: pid</code></pre>    <p>Spawns the given function and returns its pid.</p> <p>Check the <a href=\"process\"><code class=\"inline\">Process</code></a> and <a href=\"node\"><code class=\"inline\">Node</code></a> modules for other functions to handle processes, including spawning functions in nodes.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">current = self()\nchild   = spawn(fn -&gt; send current, {self(), 1 + 2} end)\n\nreceive do\n  {^child, 3} -&gt; IO.puts \"Received 3 back\"\nend</code></pre>    <h3 class=\"detail-header function\" id=\"spawn/3\">  <span class=\"signature\">spawn(module, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn(module, atom, list) :: pid</code></pre>    <p>Spawns the given module and function passing the given args and returns its pid.</p> <p>Check the <a href=\"process\"><code class=\"inline\">Process</code></a> and <a href=\"node\"><code class=\"inline\">Node</code></a> modules for other functions to handle processes, including spawning functions in nodes.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">spawn(SomeModule, :function, [1, 2, 3])</code></pre>    <h3 class=\"detail-header function\" id=\"spawn_link/1\">  <span class=\"signature\">spawn_link(fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn_link((() -&gt; any)) :: pid</code></pre>    <p>Spawns the given function, links it to the current process and returns its pid.</p> <p>Check the <a href=\"process\"><code class=\"inline\">Process</code></a> and <a href=\"node\"><code class=\"inline\">Node</code></a> modules for other functions to handle processes, including spawning functions in nodes.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">current = self()\nchild   = spawn_link(fn -&gt; send current, {self(), 1 + 2} end)\n\nreceive do\n  {^child, 3} -&gt; IO.puts \"Received 3 back\"\nend</code></pre>    <h3 class=\"detail-header function\" id=\"spawn_link/3\">  <span class=\"signature\">spawn_link(module, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn_link(module, atom, list) :: pid</code></pre>    <p>Spawns the given module and function passing the given args, links it to the current process and returns its pid.</p> <p>Check the <a href=\"process\"><code class=\"inline\">Process</code></a> and <a href=\"node\"><code class=\"inline\">Node</code></a> modules for other functions to handle processes, including spawning functions in nodes.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">spawn_link(SomeModule, :function, [1, 2, 3])</code></pre>    <h3 class=\"detail-header function\" id=\"spawn_monitor/1\">  <span class=\"signature\">spawn_monitor(fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn_monitor((() -&gt; any)) :: {pid, reference}</code></pre>    <p>Spawns the given function, monitors it and returns its pid and monitoring reference.</p> <p>Check the <a href=\"process\"><code class=\"inline\">Process</code></a> and <a href=\"node\"><code class=\"inline\">Node</code></a> modules for other functions to handle processes, including spawning functions in nodes.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">current = self()\nspawn_monitor(fn -&gt; send current, {self(), 1 + 2} end)</code></pre>    <h3 class=\"detail-header function\" id=\"spawn_monitor/3\">  <span class=\"signature\">spawn_monitor(module, fun, args)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">spawn_monitor(module, atom, list) :: {pid, reference}</code></pre>    <p>Spawns the given module and function passing the given args, monitors it and returns its pid and monitoring reference.</p> <p>Check the <a href=\"process\"><code class=\"inline\">Process</code></a> and <a href=\"node\"><code class=\"inline\">Node</code></a> modules for other functions to handle processes, including spawning functions in nodes.</p> <p>Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">spawn_monitor(SomeModule, :function, [1, 2, 3])</code></pre>    <h3 class=\"detail-header function\" id=\"struct/2\">  <span class=\"signature\">struct(struct, kv \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">struct(module | map, <a href=\"enum#t:t/0\">Enum.t</a>) :: map</code></pre>    <p>Creates and updates structs.</p> <p>The <code class=\"inline\">struct</code> argument may be an atom (which defines <code class=\"inline\">defstruct</code>) or a <code class=\"inline\">struct</code> itself. The second argument is any <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> that emits two-element tuples (key-value pairs) during enumeration.</p> <p>Keys in the <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> that don’t exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct.</p> <p>This function is useful for dynamically creating and updating structs, as well as for converting maps to structs; in the latter case, just inserting the appropriate <code class=\"inline\">:__struct__</code> field into the map may not be enough and <a href=\"#struct/2\"><code class=\"inline\">struct/2</code></a> should be used instead.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  defstruct name: \"john\"\nend\n\nstruct(User)\n#=&gt; %User{name: \"john\"}\n\nopts = [name: \"meg\"]\nuser = struct(User, opts)\n#=&gt; %User{name: \"meg\"}\n\nstruct(user, unknown: \"value\")\n#=&gt; %User{name: \"meg\"}\n\nstruct(User, %{name: \"meg\"})\n#=&gt; %User{name: \"meg\"}\n\n# String keys are ignored\nstruct(User, %{\"name\" =&gt; \"meg\"})\n#=&gt; %User{name: \"john\"}</code></pre>    <h3 class=\"detail-header function\" id=\"struct!/2\">  <span class=\"signature\">struct!(struct, kv \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">struct!(module | map, <a href=\"enum#t:t/0\">Enum.t</a>) :: map | no_return</code></pre>    <p>Similar to <a href=\"#struct/2\"><code class=\"inline\">struct/2</code></a> but checks for key validity.</p> <p>The function <a href=\"#struct!/2\"><code class=\"inline\">struct!/2</code></a> emulates the compile time behaviour of structs. This means that:</p> <ul> <li>\n<p>when building a struct, as in <code class=\"inline\">struct!(SomeStruct, key: :value)</code>, it is equivalent to <code class=\"inline\">%SomeStruct{key: :value}</code> and therefore this function will check if every given key-value belongs to the struct. If the struct is enforcing any key via <code class=\"inline\">@enforce_keys</code>, those will be enforced as well;</p> </li> <li>when updating a struct, as in <code class=\"inline\">struct!(%SomeStruct{}, key: :value)</code>, it is equivalent to <code class=\"inline\">%SomeStruct{struct | key: :value}</code> and therefore this function will check if every given key-value belongs to the struct. However, updating structs does not enforce keys, as keys are enforced only when building; </li> </ul>    <h3 class=\"detail-header function\" id=\"throw/1\">  <span class=\"signature\">throw(term)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">throw(term) :: no_return</code></pre>    <p>A non-local return from a function. Check <a href=\"kernel.specialforms#try/1\"><code class=\"inline\">Kernel.SpecialForms.try/1</code></a> for more information.</p> <p>Inlined by the compiler.</p>    <h3 class=\"detail-header function\" id=\"tl/1\">  <span class=\"signature\">tl(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">tl(maybe_improper_list) :: maybe_improper_list</code></pre>    <p>Returns the tail of a list. Raises <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> if the list is empty.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; tl([1, 2, 3, :go])\n[2, 3, :go]</code></pre>    <h3 class=\"detail-header function\" id=\"trunc/1\">  <span class=\"signature\">trunc(number)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">trunc(number) :: integer</code></pre>    <p>Returns the integer part of <code class=\"inline\">number</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; trunc(5.4)\n5\niex&gt; trunc(5.99)\n5</code></pre>    <h3 class=\"detail-header function\" id=\"tuple_size/1\">  <span class=\"signature\">tuple_size(tuple)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">tuple_size(tuple) :: non_neg_integer</code></pre>    <p>Returns the size of a tuple.</p> <p>This operation happens in constant time.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; tuple_size {:a, :b, :c}\n3</code></pre>    <h3 class=\"detail-header function\" id=\"update_in/3\">  <span class=\"signature\">update_in(data, keys, fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">update_in(<a href=\"access#t:t/0\">Access.t</a>, [term, ...], (term -&gt; term)) :: <a href=\"access#t:t/0\">Access.t</a></code></pre>    <p>Updates a key in a nested structure.</p> <p>Uses the <a href=\"access\"><code class=\"inline\">Access</code></a> module to traverse the structures according to the given <code class=\"inline\">keys</code>, unless the <code class=\"inline\">key</code> is a function. If the key is a function, it will be invoked as specified in <a href=\"#get_and_update_in/3\"><code class=\"inline\">get_and_update_in/3</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; update_in(users, [\"john\", :age], &amp;(&amp;1 + 1))\n%{\"john\" =&gt; %{age: 28}, \"meg\" =&gt; %{age: 23}}</code></pre> <p>In case any of entries in the middle returns <code class=\"inline\">nil</code>, an error will be raised when trying to access it next.</p>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"!/1\">  <span class=\"signature\">!arg</span>  </h3>  <p>Boolean not.</p> <p>Receives any argument (not just booleans) and returns <code class=\"inline\">true</code> if the argument is <code class=\"inline\">false</code> or <code class=\"inline\">nil</code>; returns <code class=\"inline\">false</code> otherwise.</p> <p>Not allowed in guard clauses.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; !Enum.empty?([])\nfalse\n\niex&gt; !List.first([])\ntrue</code></pre>    <h3 class=\"detail-header macro\" id=\"&amp;&amp;/2\">  <span class=\"signature\">left &amp;&amp; right</span>  </h3>  <p>Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to <code class=\"inline\">true</code> (i.e., it is neither <code class=\"inline\">nil</code> nor <code class=\"inline\">false</code>). Returns the first expression otherwise.</p> <p>Not allowed in guard clauses.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.empty?([]) &amp;&amp; Enum.empty?([])\ntrue\n\niex&gt; List.first([]) &amp;&amp; true\nnil\n\niex&gt; Enum.empty?([]) &amp;&amp; List.first([1])\n1\n\niex&gt; false &amp;&amp; throw(:bad)\nfalse</code></pre> <p>Note that, unlike <a href=\"#and/2\"><code class=\"inline\">and/2</code></a>, this operator accepts any expression as the first argument, not only booleans.</p>    <h3 class=\"detail-header macro\" id=\"../2\">  <span class=\"signature\">first..last</span>  </h3>  <p>Returns a range with the specified start and end.</p> <p>Both ends are included.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; 0 in 1..3\nfalse\n\niex&gt; 1 in 1..3\ntrue\n\niex&gt; 2 in 1..3\ntrue\n\niex&gt; 3 in 1..3\ntrue</code></pre>    <h3 class=\"detail-header macro\" id=\"%3C%3E/2\">  <span class=\"signature\">left &lt;&gt; right</span>  </h3>  <p>Concatenates two binaries.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; \"foo\" &lt;&gt; \"bar\"\n\"foobar\"</code></pre> <p>The <code class=\"inline\">&lt;&gt;</code> operator can also be used in pattern matching (and guard clauses) as long as the first part is a literal binary:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; \"foo\" &lt;&gt; x = \"foobar\"\niex&gt; x\n\"bar\"</code></pre> <p><code class=\"inline\">x &lt;&gt; \"bar\" = \"foobar\"</code> would have resulted in a <a href=\"compileerror\"><code class=\"inline\">CompileError</code></a> exception.</p>    <h3 class=\"detail-header macro\" id=\"@/1\">  <span class=\"signature\">@expr</span>  </h3>  <p>Reads and writes attributes of the current module.</p> <p>The canonical example for attributes is annotating that a module implements the OTP behaviour called <code class=\"inline\">gen_server</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyServer do\n  @behaviour :gen_server\n  # ... callbacks ...\nend</code></pre> <p>By default Elixir supports all the module attributes supported by Erlang, but custom attributes can be used as well:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyServer do\n  @my_data 13\n  IO.inspect @my_data #=&gt; 13\nend</code></pre> <p>Unlike Erlang, such attributes are not stored in the module by default since it is common in Elixir to use custom attributes to store temporary data that will be available at compile-time. Custom attributes may be configured to behave closer to Erlang by using <a href=\"module#register_attribute/3\"><code class=\"inline\">Module.register_attribute/3</code></a>.</p> <p>Finally, notice that attributes can also be read inside functions:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyServer do\n  @my_data 11\n  def first_data, do: @my_data\n  @my_data 13\n  def second_data, do: @my_data\nend\n\nMyServer.first_data #=&gt; 11\nMyServer.second_data #=&gt; 13</code></pre> <p>It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the <a href=\"module\"><code class=\"inline\">Module</code></a> module for other functions to manipulate module attributes.</p>    <h3 class=\"detail-header macro\" id=\"alias!/1\">  <span class=\"signature\">alias!(alias)</span>  </h3>  <p>When used inside quoting, marks that the given alias should not be hygienized. This means the alias will be expanded when the macro is expanded.</p> <p>Check <a href=\"kernel.specialforms#quote/2\"><code class=\"inline\">Kernel.SpecialForms.quote/2</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"and/2\">  <span class=\"signature\">left and right</span>  </h3>  <p>Boolean and.</p> <p>If the first argument is <code class=\"inline\">false</code>, <code class=\"inline\">false</code> is returned; otherwise, the second argument is returned.</p> <p>Requires only the first argument to be a boolean since it short-circuits. If the first argument is not a boolean, an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> exception is raised.</p> <p>Allowed in guard tests.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; true and false\nfalse\niex&gt; true and \"yay!\"\n\"yay!\"</code></pre>    <h3 class=\"detail-header macro\" id=\"binding/1\">  <span class=\"signature\">binding(context \\\\ nil)</span>  </h3>  <p>Returns the binding for the given context as a keyword list.</p> <p>In the returned result, keys are variable names and values are the corresponding variable values.</p> <p>If the given <code class=\"inline\">context</code> is <code class=\"inline\">nil</code> (by default it is), the binding for the current context is returned.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; x = 1\niex&gt; binding()\n[x: 1]\niex&gt; x = 2\niex&gt; binding()\n[x: 2]\n\niex&gt; binding(:foo)\n[]\niex&gt; var!(x, :foo) = 1\n1\niex&gt; binding(:foo)\n[x: 1]</code></pre>    <h3 class=\"detail-header macro\" id=\"def/2\">  <span class=\"signature\">def(call, expr \\\\ nil)</span>  </h3>  <p>Defines a function with the given name and body.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Foo do\n  def bar, do: :baz\nend\n\nFoo.bar #=&gt; :baz</code></pre> <p>A function that expects arguments can be defined as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Foo do\n  def sum(a, b) do\n    a + b\n  end\nend</code></pre> <p>In the example above, a <code class=\"inline\">sum/2</code> function is defined; this function receives two arguments and returns their sum.</p> <h4>Function and variable names</h4> <p>Function and variable names have the following syntax: A <em>lowercase ASCII letter</em> or an <em>underscore</em>, followed by any number of <em>lowercase or uppercase ASCII letters</em>, <em>numbers</em>, or <em>underscores</em>. Optionally they can end in either an <em>exclamation mark</em> or a <em>question mark</em>.</p> <p>For variables, any identifier starting with an underscore should indicate an unused variable. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">def foo(bar) do\n  []\nend\n#=&gt; warning: variable bar is unused\n\ndef foo(_bar) do\n  []\nend\n#=&gt; no warning\n\ndef foo(_bar) do\n  _bar\nend\n#=&gt; warning: the underscored variable \"_bar\" is used after being set</code></pre>    <h3 class=\"detail-header macro\" id=\"defdelegate/2\">  <span class=\"signature\">defdelegate(funs, opts)</span>  </h3>  <p>Defines a function that delegates to another module.</p> <p>Functions defined with <a href=\"#defdelegate/2\"><code class=\"inline\">defdelegate/2</code></a> are public and can be invoked from outside the module they’re defined in (like if they were defined using <a href=\"#def/2)\"><code class=\"inline\">def/2</code></a>. When the desire is to delegate as private functions, <code class=\"inline\">import/2</code> should be used.</p> <p>Delegation only works with functions; delegating macros is not supported.</p> <h4>Options</h4> <ul> <li>\n<p><code class=\"inline\">:to</code> - the expression to delegate to. Any expression is allowed and its results will be evaluated at runtime. Usually evaluates to the name of a module.</p> </li> <li>\n<p><code class=\"inline\">:as</code> - the function to call on the target given in <code class=\"inline\">:to</code>. This parameter is optional and defaults to the name being delegated (<code class=\"inline\">funs</code>).</p> </li> <li>\n<p><code class=\"inline\">:append_first</code> - if <code class=\"inline\">true</code>, when delegated, the first argument passed to the delegated function will be relocated to the end of the arguments when dispatched to the target.</p> <p>The motivation behind this is because Elixir normalizes the “handle” as the first argument while some Erlang modules expect it as the last argument.</p> </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyList do\n  defdelegate reverse(list), to: :lists\n  defdelegate other_reverse(list), to: :lists, as: :reverse\n  defdelegate [reverse(list), map(list, callback)], to: :lists, append_first: true\nend\n\nMyList.reverse([1, 2, 3])\n#=&gt; [3, 2, 1]\n\nMyList.other_reverse([1, 2, 3])\n#=&gt; [3, 2, 1]\n\nMyList.map([1, 2, 3], &amp;(&amp;1 * 2))\n#=&gt; [2, 4, 6]</code></pre>    <h3 class=\"detail-header macro\" id=\"defexception/1\">  <span class=\"signature\">defexception(fields)</span>  </h3>  <p>Defines an exception.</p> <p>Exceptions are structs backed by a module that implements the <a href=\"exception\"><code class=\"inline\">Exception</code></a> behaviour. The <a href=\"exception\"><code class=\"inline\">Exception</code></a> behaviour requires two functions to be implemented:</p> <ul> <li>\n<p><code class=\"inline\">exception/1</code> - receives the arguments given to <a href=\"#raise/2\"><code class=\"inline\">raise/2</code></a> and returns the exception struct. The default implementation accepts either a set of keyword arguments that is merged into the struct or a string to be used as the exception’s message.</p> </li> <li>\n<code class=\"inline\">message/1</code> - receives the exception struct and must return its message. Most commonly exceptions have a message field which by default is accessed by this function. However, if an exception does not have a message field, this function must be explicitly implemented. </li> </ul> <p>Since exceptions are structs, the API supported by <a href=\"#defstruct/1\"><code class=\"inline\">defstruct/1</code></a> is also available in <a href=\"#defexception/1\"><code class=\"inline\">defexception/1</code></a>.</p> <h4>Raising exceptions</h4> <p>The most common way to raise an exception is via <a href=\"#raise/2\"><code class=\"inline\">raise/2</code></a>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyAppError do\n  defexception [:message]\nend\n\nvalue = [:hello]\n\nraise MyAppError,\n  message: \"did not get what was expected, got: #{inspect value}\"</code></pre> <p>In many cases it is more convenient to pass the expected value to <a href=\"#raise/2\"><code class=\"inline\">raise/2</code></a> and generate the message in the <code class=\"inline\">exception/1</code> callback:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyAppError do\n  defexception [:message]\n\n  def exception(value) do\n    msg = \"did not get what was expected, got: #{inspect value}\"\n    %MyAppError{message: msg}\n  end\nend\n\nraise MyAppError, value</code></pre> <p>The example above shows the preferred strategy for customizing exception messages.</p>    <h3 class=\"detail-header macro\" id=\"defimpl/3\">  <span class=\"signature\">defimpl(name, opts, do_block \\\\ [])</span>  </h3>  <p>Defines an implementation for the given protocol.</p> <p>See <a href=\"#defprotocol/2\"><code class=\"inline\">defprotocol/2</code></a> for more information and examples on protocols.</p> <p>Inside an implementation, the name of the protocol can be accessed via <code class=\"inline\">@protocol</code> and the current target as <code class=\"inline\">@for</code>.</p>    <h3 class=\"detail-header macro\" id=\"defmacro/2\">  <span class=\"signature\">defmacro(call, expr \\\\ nil)</span>  </h3>  <p>Defines a macro with the given name and body.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyLogic do\n  defmacro unless(expr, opts) do\n    quote do\n      if !unquote(expr), unquote(opts)\n    end\n  end\nend\n\nrequire MyLogic\nMyLogic.unless false do\n  IO.puts \"It works\"\nend</code></pre>    <h3 class=\"detail-header macro\" id=\"defmacrop/2\">  <span class=\"signature\">defmacrop(call, expr \\\\ nil)</span>  </h3>  <p>Defines a private macro with the given name and body.</p> <p>Private macros are only accessible from the same module in which they are defined.</p> <p>Check <a href=\"#defmacro/2\"><code class=\"inline\">defmacro/2</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"defmodule/2\">  <span class=\"signature\">defmodule(alias, list)</span>  </h3>  <p>Defines a module given by name with the given contents.</p> <p>This macro defines a module with the given <code class=\"inline\">alias</code> as its name and with the given contents. It returns a tuple with four elements:</p> <ul> <li>\n<code class=\"inline\">:module</code> </li> <li>the module name </li> <li>the binary contents of the module </li> <li>the result of evaluating the contents block </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; defmodule Foo do\n...&gt;   def bar, do: :baz\n...&gt; end\niex&gt; Foo.bar\n:baz</code></pre> <h4>Nesting</h4> <p>Nesting a module inside another module affects the name of the nested module:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Foo do\n  defmodule Bar do\n  end\nend</code></pre> <p>In the example above, two modules - <code class=\"inline\">Foo</code> and <code class=\"inline\">Foo.Bar</code> - are created. When nesting, Elixir automatically creates an alias to the inner module, allowing the second module <code class=\"inline\">Foo.Bar</code> to be accessed as <code class=\"inline\">Bar</code> in the same lexical scope where it’s defined (the <code class=\"inline\">Foo</code> module).</p> <p>If the <code class=\"inline\">Foo.Bar</code> module is moved somewhere else, the references to <code class=\"inline\">Bar</code> in the <code class=\"inline\">Foo</code> module need to be updated to the fully-qualified name (<code class=\"inline\">Foo.Bar</code>) or an alias has to be explicitly set in the <code class=\"inline\">Foo</code> module with the help of <a href=\"kernel.specialforms#alias/2\"><code class=\"inline\">Kernel.SpecialForms.alias/2</code></a>.</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Foo.Bar do\n  # code\nend\n\ndefmodule Foo do\n  alias Foo.Bar\n  # code here can refer to \"Foo.Bar\" as just \"Bar\"\nend</code></pre> <h4>Module names</h4> <p>A module name can be any atom, but Elixir provides a special syntax which is usually used for module names. What is called a module name is an <em>uppercase ASCII letter</em> followed by any number of <em>lowercase or uppercase ASCII letters</em>, <em>numbers</em>, or <em>underscores</em>. This identifier is equivalent to an atom prefixed by <code class=\"inline\">Elixir.</code>. So in the <code class=\"inline\">defmodule Foo</code> example <code class=\"inline\">Foo</code> is equivalent to <code class=\"inline\">:\"Elixir.Foo\"</code></p> <h4>Dynamic names</h4> <p>Elixir module names can be dynamically generated. This is very useful when working with macros. For instance, one could write:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule String.to_atom(\"Foo#{1}\") do\n  # contents ...\nend</code></pre> <p>Elixir will accept any module name as long as the expression passed as the first argument to <a href=\"#defmodule/2\"><code class=\"inline\">defmodule/2</code></a> evaluates to an atom. Note that, when a dynamic name is used, Elixir won’t nest the name under the current module nor automatically set up an alias.</p>    <h3 class=\"detail-header macro\" id=\"defoverridable/1\">  <span class=\"signature\">defoverridable(keywords)</span>  </h3>  <p>Makes the given functions in the current module overridable.</p> <p>An overridable function is lazily defined, allowing a developer to override it.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule DefaultMod do\n  defmacro __using__(_opts) do\n    quote do\n      def test(x, y) do\n        x + y\n      end\n\n      defoverridable [test: 2]\n    end\n  end\nend\n\ndefmodule InheritMod do\n  use DefaultMod\n\n  def test(x, y) do\n    x * y + super(x, y)\n  end\nend</code></pre> <p>As seen as in the example above, <code class=\"inline\">super</code> can be used to call the default implementation.</p>    <h3 class=\"detail-header macro\" id=\"defp/2\">  <span class=\"signature\">defp(call, expr \\\\ nil)</span>  </h3>  <p>Defines a private function with the given name and body.</p> <p>Private functions are only accessible from within the module in which they are defined. Trying to access a private function from outside the module it’s defined in results in an <a href=\"undefinedfunctionerror\"><code class=\"inline\">UndefinedFunctionError</code></a> exception.</p> <p>Check <a href=\"#def/2\"><code class=\"inline\">def/2</code></a> for more information.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Foo do\n  def bar do\n    sum(1, 2)\n  end\n\n  defp sum(a, b), do: a + b\nend\n\nFoo.bar #=&gt; 3\nFoo.sum(1, 2) #=&gt; ** (UndefinedFunctionError) undefined function Foo.sum/2</code></pre>    <h3 class=\"detail-header macro\" id=\"defprotocol/2\">  <span class=\"signature\">defprotocol(name, list)</span>  </h3>  <p>Defines a protocol.</p> <p>A protocol specifies an API that should be defined by its implementations.</p> <h4>Examples</h4> <p>In Elixir, only <code class=\"inline\">false</code> and <code class=\"inline\">nil</code> are considered falsy values. Everything else evaluates to <code class=\"inline\">true</code> in <a href=\"#if/2\"><code class=\"inline\">if/2</code></a> clauses. Depending on the application, it may be important to specify a <code class=\"inline\">blank?</code> protocol that returns a boolean for other data types that should be considered “blank”. For instance, an empty list or an empty binary could be considered blank.</p> <p>Such protocol could be implemented as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defprotocol Blank do\n  @doc \"Returns `true` if `data` is considered blank/empty\"\n  def blank?(data)\nend</code></pre> <p>Now that the protocol is defined it can be implemented. It needs to be implemented for each Elixir type; for example:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Integers are never blank\ndefimpl Blank, for: Integer do\n  def blank?(number), do: false\nend\n\n# The only blank list is the empty one\ndefimpl Blank, for: List do\n  def blank?([]), do: true\n  def blank?(_),  do: false\nend\n\n# The only blank atoms are \"false\" and \"nil\"\ndefimpl Blank, for: Atom do\n  def blank?(false), do: true\n  def blank?(nil),   do: true\n  def blank?(_),     do: false\nend</code></pre> <p>The implementation of the <code class=\"inline\">Blank</code> protocol would need to be defined for all Elixir types. The available types are:</p> <ul> <li>Structs (see below) </li> <li>\n<a href=\"tuple\"><code class=\"inline\">Tuple</code></a> </li> <li>\n<a href=\"atom\"><code class=\"inline\">Atom</code></a> </li> <li>\n<a href=\"list\"><code class=\"inline\">List</code></a> </li> <li>\n<code class=\"inline\">BitString</code> </li> <li>\n<a href=\"integer\"><code class=\"inline\">Integer</code></a> </li> <li>\n<a href=\"float\"><code class=\"inline\">Float</code></a> </li> <li>\n<code class=\"inline\">Function</code> </li> <li>\n<code class=\"inline\">PID</code> </li> <li>\n<a href=\"map\"><code class=\"inline\">Map</code></a> </li> <li>\n<a href=\"port\"><code class=\"inline\">Port</code></a> </li> <li>\n<code class=\"inline\">Reference</code> </li> <li>\n<code class=\"inline\">Any</code> (see below) </li> </ul> <h4>Protocols and Structs</h4> <p>The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like <a href=\"mapset\"><code class=\"inline\">MapSet</code></a>. We can implement the <code class=\"inline\">Blank</code> protocol for those types as well:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defimpl Blank, for: MapSet do\n  def blank?(enum_like), do: Enum.empty?(enum_like)\nend</code></pre> <p>When implementing a protocol for a struct, the <code class=\"inline\">:for</code> option can be omitted if the <code class=\"inline\">defimpl</code> call is inside the module that defines the struct:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  defstruct [:email, :name]\n\n  defimpl Blank do\n    def blank?(%User{}), do: false\n  end\nend</code></pre> <p>If a protocol is not found for a given type, it will fallback to <code class=\"inline\">Any</code>. Protocols that are implemented for maps don’t work by default on structs; look at <a href=\"#defstruct/1\"><code class=\"inline\">defstruct/1</code></a> for more information about deriving protocols.</p> <h4>Fallback to any</h4> <p>In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the <code class=\"inline\">@fallback_to_any</code> attribute to <code class=\"inline\">true</code> in the protocol definition:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defprotocol Blank do\n  @fallback_to_any true\n  def blank?(data)\nend</code></pre> <p>The <code class=\"inline\">Blank</code> protocol can now be implemented for <code class=\"inline\">Any</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defimpl Blank, for: Any do\n  def blank?(_), do: true\nend</code></pre> <p>One may wonder why such behaviour (fallback to any) is not the default one.</p> <p>It is two-fold: first, the majority of protocols cannot implement an action in a generic way for all types; in fact, providing a default implementation may be harmful, because users may rely on the default implementation instead of providing a specialized one.</p> <p>Second, falling back to <code class=\"inline\">Any</code> adds an extra lookup to all types, which is unnecessary overhead unless an implementation for <code class=\"inline\">Any</code> is required.</p> <h4>Types</h4> <p>Defining a protocol automatically defines a type named <code class=\"inline\">t</code>, which can be used as follows:</p> <pre data-language=\"elixir\"><code class=\"elixir\">@spec present?(Blank.t) :: boolean\ndef present?(blank) do\n  not Blank.blank?(blank)\nend</code></pre> <p>The <code class=\"inline\">@spec</code> above expresses that all types allowed to implement the given protocol are valid argument types for the given function.</p> <h4>Reflection</h4> <p>Any protocol module contains three extra functions:</p> <ul> <li>\n<p><code class=\"inline\">__protocol__/1</code> - returns the protocol name when <code class=\"inline\">:name</code> is given, and a keyword list with the protocol functions and their arities when <code class=\"inline\">:functions</code> is given</p> </li> <li>\n<p><code class=\"inline\">impl_for/1</code> - receives a structure and returns the module that implements the protocol for the structure, <code class=\"inline\">nil</code> otherwise</p> </li> <li>\n<p><code class=\"inline\">impl_for!/1</code> - same as above but raises an error if an implementation is not found</p> <pre data-language=\"elixir\"><code class=\"elixir\">Enumerable.__protocol__(:functions)\n#=&gt; [count: 1, member?: 2, reduce: 3]\n\nEnumerable.impl_for([])\n#=&gt; Enumerable.List\n\nEnumerable.impl_for(42)\n#=&gt; nil</code></pre> </li> </ul> <h4>Consolidation</h4> <p>In order to cope with code loading in development, protocols in Elixir provide a slow implementation of protocol dispatching specific to development.</p> <p>In order to speed up dispatching in production environments, where all implementations are known up-front, Elixir provides a feature called protocol consolidation. For this reason, all protocols are compiled with <code class=\"inline\">debug_info</code> set to <code class=\"inline\">true</code>, regardless of the option set by <code class=\"inline\">elixirc</code> compiler. The debug info though may be removed after consolidation.</p> <p>For more information on how to apply protocol consolidation to a given project, please check the functions in the <a href=\"protocol\"><code class=\"inline\">Protocol</code></a> module or the <code class=\"inline\">mix compile.protocols</code> task.</p>    <h3 class=\"detail-header macro\" id=\"defstruct/1\">  <span class=\"signature\">defstruct(fields)</span>  </h3>  <p>Defines a struct.</p> <p>A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions.</p> <p>To define a struct, a developer must define both <code class=\"inline\">__struct__/0</code> and <code class=\"inline\">__struct__/1</code> functions. <a href=\"#defstruct/1\"><code class=\"inline\">defstruct/1</code></a> is a convenience macro which defines such functions with some conveniences.</p> <p>For more information about structs, please check <code class=\"inline\">Kernel.SpecialForms.%/2</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  defstruct name: nil, age: nil\nend</code></pre> <p>Struct fields are evaluated at compile-time, which allows them to be dynamic. In the example below, <code class=\"inline\">10 + 11</code> is evaluated at compile-time and the age field is stored with value <code class=\"inline\">21</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  defstruct name: nil, age: 10 + 11\nend</code></pre> <p>The <code class=\"inline\">fields</code> argument is usually a keyword list with field names as atom keys and default values as corresponding values. <a href=\"#defstruct/1\"><code class=\"inline\">defstruct/1</code></a> also supports a list of atoms as its argument: in that case, the atoms in the list will be used as the struct’s field names and they will all default to <code class=\"inline\">nil</code>.</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Post do\n  defstruct [:title, :content, :author]\nend</code></pre> <h4>Deriving</h4> <p>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. For example, attempting to use a protocol with the <code class=\"inline\">User</code> struct leads to an error:</p> <pre data-language=\"elixir\"><code class=\"elixir\">john = %User{name: \"John\"}\nMyProtocol.call(john)\n** (Protocol.UndefinedError) protocol MyProtocol not implemented for %User{...}</code></pre> <p><a href=\"#defstruct/1\"><code class=\"inline\">defstruct/1</code></a>, however, allows protocol implementations to be <em>derived</em>. This can be done by defining a <code class=\"inline\">@derive</code> attribute as a list before invoking <a href=\"#defstruct/1\"><code class=\"inline\">defstruct/1</code></a>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  @derive [MyProtocol]\n  defstruct name: nil, age: 10 + 11\nend\n\nMyProtocol.call(john) #=&gt; works</code></pre> <p>For each protocol in the <code class=\"inline\">@derive</code> list, Elixir will assert there is an implementation of that protocol for any (regardless if fallback to any is <code class=\"inline\">true</code>) and check if the any implementation defines a <code class=\"inline\">__deriving__/3</code> callback. If so, the callback is invoked, otherwise an implementation that simply points to the any implementation is automatically derived.</p> <h4>Enforcing keys</h4> <p>When building a struct, Elixir will automatically guarantee all keys belongs to the struct:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%User{name: \"john\", unknown: :key}\n** (KeyError) key :unknown not found in: %User{age: 21, name: nil}</code></pre> <p>Elixir also allows developers to enforce certain keys must always be given when building the struct:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  @enforce_keys [:name]\n  defstruct name: nil, age: 10 + 11\nend</code></pre> <p>Now trying to build a struct without the name key will fail:</p> <pre data-language=\"elixir\"><code class=\"elixir\">%User{age: 21}\n** (ArgumentError) the following keys must also be given when building struct User: [:name]</code></pre> <p>Keep in mind <code class=\"inline\">@enforce_keys</code> is a simply a compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation.</p> <h4>Types</h4> <p>It is recommended to define types for structs. By convention such type is called <code class=\"inline\">t</code>. To define a struct inside a type, the struct literal syntax is used:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule User do\n  defstruct name: \"John\", age: 25\n  @type t :: %User{name: String.t, age: non_neg_integer}\nend</code></pre> <p>It is recommended to only use the struct syntax when defining the struct’s type. When referring to another struct it’s better to use <code class=\"inline\">User.t</code>instead of <code class=\"inline\">%User{}</code>.</p> <p>The types of the struct fields that are not included in <code class=\"inline\">%User{}</code> default to <code class=\"inline\">term</code>.</p> <p>Structs whose internal structure is private to the local module (pattern matching them or directly accessing their fields should not be allowed) should use the <code class=\"inline\">@opaque</code> attribute. Structs whose internal structure is public should use <code class=\"inline\">@type</code>.</p>    <h3 class=\"detail-header macro\" id=\"destructure/2\">  <span class=\"signature\">destructure(left, right)</span>  </h3>  <p>Destructures two lists, assigning each term in the right one to the matching term in the left one.</p> <p>Unlike pattern matching via <code class=\"inline\">=</code>, if the sizes of the left and right lists don’t match, destructuring simply stops instead of raising an error.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; destructure([x, y, z], [1, 2, 3, 4, 5])\niex&gt; {x, y, z}\n{1, 2, 3}</code></pre> <p>In the example above, even though the right list has more entries than the left one, destructuring works fine. If the right list is smaller, the remaining items are simply set to <code class=\"inline\">nil</code>:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; destructure([x, y, z], [1])\niex&gt; {x, y, z}\n{1, nil, nil}</code></pre> <p>The left-hand side supports any expression you would use on the left-hand side of a match:</p> <pre data-language=\"elixir\"><code class=\"elixir\">x = 1\ndestructure([^x, y, z], [1, 2, 3])</code></pre> <p>The example above will only work if <code class=\"inline\">x</code> matches the first value in the right list. Otherwise, it will raise a <a href=\"matcherror\"><code class=\"inline\">MatchError</code></a> (like the <code class=\"inline\">=</code> operator would do).</p>    <h3 class=\"detail-header macro\" id=\"get_and_update_in/2\">  <span class=\"signature\">get_and_update_in(path, fun)</span>  </h3>  <p>Gets a value and updates a nested data structure via the given <code class=\"inline\">path</code>.</p> <p>This is similar to <a href=\"#get_and_update_in/3\"><code class=\"inline\">get_and_update_in/3</code></a>, except the path is extracted via a macro rather than passing a list. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">get_and_update_in(opts[:foo][:bar], &amp;{&amp;1, &amp;1 + 1})</code></pre> <p>Is equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">get_and_update_in(opts, [:foo, :bar], &amp;{&amp;1, &amp;1 + 1})</code></pre> <p>Note that in order for this macro to work, the complete path must always be visible by this macro. See the Paths section below.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; get_and_update_in(users[\"john\"].age, &amp;{&amp;1, &amp;1 + 1})\n{27, %{\"john\" =&gt; %{age: 28}, \"meg\" =&gt; %{age: 23}}}</code></pre> <h4>Paths</h4> <p>A path may start with a variable, local or remote call, and must be followed by one or more:</p> <ul> <li>\n<p><code class=\"inline\">foo[bar]</code> - access the key <code class=\"inline\">bar</code> in <code class=\"inline\">foo</code>; in case <code class=\"inline\">foo</code> is nil, <code class=\"inline\">nil</code> is returned</p> </li> <li>\n<code class=\"inline\">foo.bar</code> - access a map/struct field; in case the field is not present, an error is raised </li> </ul> <p>Here are some valid paths:</p> <pre data-language=\"elixir\"><code class=\"elixir\">users[\"john\"][:age]\nusers[\"john\"].age\nUser.all[\"john\"].age\nall_users()[\"john\"].age</code></pre> <p>Here are some invalid ones:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Does a remote call after the initial value\nusers[\"john\"].do_something(arg1, arg2)\n\n# Does not access any key or field\nusers</code></pre>    <h3 class=\"detail-header macro\" id=\"if/2\">  <span class=\"signature\">if(condition, clauses)</span>  </h3>  <p>Provides an <a href=\"#if/2\"><code class=\"inline\">if/2</code></a> macro.</p> <p>This macro expects the first argument to be a condition and the second argument to be a keyword list.</p> <h4>One-liner examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">if(foo, do: bar)</code></pre> <p>In the example above, <code class=\"inline\">bar</code> will be returned if <code class=\"inline\">foo</code> evaluates to <code class=\"inline\">true</code> (i.e., it is neither <code class=\"inline\">false</code> nor <code class=\"inline\">nil</code>). Otherwise, <code class=\"inline\">nil</code> will be returned.</p> <p>An <code class=\"inline\">else</code> option can be given to specify the opposite:</p> <pre data-language=\"elixir\"><code class=\"elixir\">if(foo, do: bar, else: baz)</code></pre> <h4>Blocks examples</h4> <p>It’s also possible to pass a block to the <a href=\"#if/2\"><code class=\"inline\">if/2</code></a> macro. The first example above would be translated to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">if foo do\n  bar\nend</code></pre> <p>Note that <code class=\"inline\">do/end</code> become delimiters. The second example would translate to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">if foo do\n  bar\nelse\n  baz\nend</code></pre> <p>In order to compare more than two clauses, the <code class=\"inline\">cond/1</code> macro has to be used.</p>    <h3 class=\"detail-header macro\" id=\"in/2\">  <span class=\"signature\">left in right</span>  </h3>  <p>Checks if the element on the left-hand side is a member of the collection on the right-hand side.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; x = 1\niex&gt; x in [1, 2, 3]\ntrue</code></pre> <p>This operator (which is a macro) simply translates to a call to <a href=\"enum#member?/2\"><code class=\"inline\">Enum.member?/2</code></a>. The example above would translate to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Enum.member?([1, 2, 3], x)</code></pre> <h4>Guards</h4> <p>The <a href=\"#in/2\"><code class=\"inline\">in/2</code></a> operator can be used in guard clauses as long as the right-hand side is a range or a list. In such cases, Elixir will expand the operator to a valid guard expression. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">when x in [1, 2, 3]</code></pre> <p>translates to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">when x === 1 or x === 2 or x === 3</code></pre> <p>When using ranges:</p> <pre data-language=\"elixir\"><code class=\"elixir\">when x in 1..3</code></pre> <p>translates to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">when x &gt;= 1 and x &lt;= 3</code></pre>    <h3 class=\"detail-header macro\" id=\"is_nil/1\">  <span class=\"signature\">is_nil(term)</span>  </h3>  <p>Returns <code class=\"inline\">true</code> if <code class=\"inline\">term</code> is <code class=\"inline\">nil</code>, <code class=\"inline\">false</code> otherwise.</p> <p>Allowed in guard clauses.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; is_nil(1)\nfalse\n\niex&gt; is_nil(nil)\ntrue</code></pre>    <h3 class=\"detail-header macro\" id=\"match?/2\">  <span class=\"signature\">match?(pattern, expr)</span>  </h3>  <p>A convenience macro that checks if the right side (an expression) matches the left side (a pattern).</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; match?(1, 1)\ntrue\n\niex&gt; match?(1, 2)\nfalse\n\niex&gt; match?({1, _}, {1, 2})\ntrue\n\niex&gt; map = %{a: 1, b: 2}\niex&gt; match?(%{a: _}, map)\ntrue\n\niex&gt; a = 1\niex&gt; match?(^a, 1)\ntrue</code></pre> <p><a href=\"#match?/2\"><code class=\"inline\">match?/2</code></a> is very useful when filtering of finding a value in an enumerable:</p> <pre data-language=\"elixir\"><code class=\"elixir\">list = [{:a, 1}, {:b, 2}, {:a, 3}]\nEnum.filter list, &amp;match?({:a, _}, &amp;1)\n#=&gt; [{:a, 1}, {:a, 3}]</code></pre> <p>Guard clauses can also be given to the match:</p> <pre data-language=\"elixir\"><code class=\"elixir\">list = [{:a, 1}, {:b, 2}, {:a, 3}]\nEnum.filter list, &amp;match?({:a, x} when x &lt; 2, &amp;1)\n#=&gt; [{:a, 1}]</code></pre> <p>However, variables assigned in the match will not be available outside of the function call (unlike regular pattern matching with the <code class=\"inline\">=</code> operator):</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; match?(_x, 1)\ntrue\niex&gt; binding()\n[]</code></pre>    <h3 class=\"detail-header macro\" id=\"or/2\">  <span class=\"signature\">left or right</span>  </h3>  <p>Boolean or.</p> <p>If the first argument is <code class=\"inline\">true</code>, <code class=\"inline\">true</code> is returned; otherwise, the second argument is returned.</p> <p>Requires only the first argument to be a boolean since it short-circuits. If the first argument is not a boolean, an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> exception is raised.</p> <p>Allowed in guard tests.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; true or false\ntrue\niex&gt; false or 42\n42</code></pre>    <h3 class=\"detail-header macro\" id=\"pop_in/1\">  <span class=\"signature\">pop_in(path)</span>  </h3>  <p>Pops a key from the nested structure via the given <code class=\"inline\">path</code>.</p> <p>This is similar to <a href=\"#pop_in/2\"><code class=\"inline\">pop_in/2</code></a>, except the path is extracted via a macro rather than passing a list. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">pop_in(opts[:foo][:bar])</code></pre> <p>Is equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">pop_in(opts, [:foo, :bar])</code></pre> <p>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check <a href=\"#get_and_update_in/2\"><code class=\"inline\">get_and_update_in/2</code></a> docs.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; pop_in(users[\"john\"][:age])\n{27, %{\"john\" =&gt; %{}, \"meg\" =&gt; %{age: 23}}}\n\niex&gt; users = %{john: %{age: 27}, meg: %{age: 23}}\niex&gt; pop_in(users.john[:age])\n{27, %{john: %{}, meg: %{age: 23}}}</code></pre> <p>In case any entry returns <code class=\"inline\">nil</code>, its key will be removed and the deletion will be considered a success.</p>    <h3 class=\"detail-header macro\" id=\"put_in/2\">  <span class=\"signature\">put_in(path, value)</span>  </h3>  <p>Puts a value in a nested structure via the given <code class=\"inline\">path</code>.</p> <p>This is similar to <a href=\"#put_in/3\"><code class=\"inline\">put_in/3</code></a>, except the path is extracted via a macro rather than passing a list. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">put_in(opts[:foo][:bar], :baz)</code></pre> <p>Is equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">put_in(opts, [:foo, :bar], :baz)</code></pre> <p>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check <a href=\"#get_and_update_in/2\"><code class=\"inline\">get_and_update_in/2</code></a> docs.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; put_in(users[\"john\"][:age], 28)\n%{\"john\" =&gt; %{age: 28}, \"meg\" =&gt; %{age: 23}}\n\niex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; put_in(users[\"john\"].age, 28)\n%{\"john\" =&gt; %{age: 28}, \"meg\" =&gt; %{age: 23}}</code></pre>    <h3 class=\"detail-header macro\" id=\"raise/1\">  <span class=\"signature\">raise(msg)</span>  </h3>  <p>Raises an exception.</p> <p>If the argument <code class=\"inline\">msg</code> is a binary, it raises a <a href=\"runtimeerror\"><code class=\"inline\">RuntimeError</code></a> exception using the given argument as message.</p> <p>If <code class=\"inline\">msg</code> is an atom, it just calls <a href=\"#raise/2\"><code class=\"inline\">raise/2</code></a> with the atom as the first argument and <code class=\"inline\">[]</code> as the second argument.</p> <p>If <code class=\"inline\">msg</code> is anything else, raises an <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> exception.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; raise \"oops\"\n** (RuntimeError) oops\n\ntry do\n  1 + :foo\nrescue\n  x in [ArithmeticError] -&gt;\n    IO.puts \"that was expected\"\n    raise x\nend</code></pre>    <h3 class=\"detail-header macro\" id=\"raise/2\">  <span class=\"signature\">raise(exception, attrs)</span>  </h3>  <p>Raises an exception.</p> <p>Calls the <code class=\"inline\">exception/1</code> function on the given argument (which has to be a module name like <a href=\"argumenterror\"><code class=\"inline\">ArgumentError</code></a> or <a href=\"runtimeerror.html)\"><code class=\"inline\">RuntimeError</code></a> passing <code class=\"inline\">attrs</code> as the attributes in order to retrieve the exception struct.</p> <p>Any module that contains a call to the <a href=\"#defexception/1\"><code class=\"inline\">defexception/1</code></a> macro automatically implements the <code class=\"inline\">exception/1</code> callback expected by <a href=\"#raise/2\"><code class=\"inline\">raise/2</code></a>. See the docs for <a href=\"#defexception/1\"><code class=\"inline\">defexception/1</code></a> for more information.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; raise(ArgumentError, message: \"Sample\")\n** (ArgumentError) Sample</code></pre>    <h3 class=\"detail-header macro\" id=\"reraise/2\">  <span class=\"signature\">reraise(msg, stacktrace)</span>  </h3>  <p>Raises an exception preserving a previous stacktrace.</p> <p>Works like <a href=\"#raise/1\"><code class=\"inline\">raise/1</code></a> but does not generate a new stacktrace.</p> <p>Notice that <a href=\"system#stacktrace/0\"><code class=\"inline\">System.stacktrace/0</code></a> returns the stacktrace of the last exception. That said, it is common to assign the stacktrace as the first expression inside a <code class=\"inline\">rescue</code> clause as any other exception potentially raised (and rescued) between the rescue clause and the raise call may change the <a href=\"system#stacktrace/0\"><code class=\"inline\">System.stacktrace/0</code></a> value.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">try do\n  raise \"oops\"\nrescue\n  exception -&gt;\n    stacktrace = System.stacktrace\n    if Exception.message(exception) == \"oops\" do\n      reraise exception, stacktrace\n    end\nend</code></pre>    <h3 class=\"detail-header macro\" id=\"reraise/3\">  <span class=\"signature\">reraise(exception, attrs, stacktrace)</span>  </h3>  <p>Raises an exception preserving a previous stacktrace.</p> <p><a href=\"#reraise/3\"><code class=\"inline\">reraise/3</code></a> works like <a href=\"#reraise/2\"><code class=\"inline\">reraise/2</code></a>, except it passes arguments to the <code class=\"inline\">exception/1</code> function like explained in <a href=\"#raise/2\"><code class=\"inline\">raise/2</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">try do\n  raise \"oops\"\nrescue\n  exception -&gt;\n    stacktrace = System.stacktrace\n    reraise WrapperError, [exception: exception], stacktrace\nend</code></pre>    <h3 class=\"detail-header macro\" id=\"sigil_C/2\">  <span class=\"signature\">sigil_C(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class=\"inline\">~C</code>.</p> <p>It simply returns a charlist without escaping characters and without interpolations.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~C(foo)\n'foo'\n\niex&gt; ~C(f#{o}o)\n'f\\#{o}o'</code></pre>    <h3 class=\"detail-header macro\" id=\"sigil_D/2\">  <span class=\"signature\">sigil_D(date, modifiers)</span>  </h3>  <p>Handles the sigil <code class=\"inline\">~D</code> for dates.</p> <p>The lower case <code class=\"inline\">~d</code> variant does not exist as interpolation and escape characters are not useful for date sigils.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~D[2015-01-13]\n~D[2015-01-13]</code></pre>    <h3 class=\"detail-header macro\" id=\"sigil_N/2\">  <span class=\"signature\">sigil_N(date, modifiers)</span>  </h3>  <p>Handles the sigil <code class=\"inline\">~N</code> for naive date times.</p> <p>The lower case <code class=\"inline\">~n</code> variant does not exist as interpolation and escape characters are not useful for datetime sigils.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~N[2015-01-13 13:00:07]\n~N[2015-01-13 13:00:07]\niex&gt; ~N[2015-01-13T13:00:07.001]\n~N[2015-01-13 13:00:07.001]</code></pre>    <h3 class=\"detail-header macro\" id=\"sigil_R/2\">  <span class=\"signature\">sigil_R(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class=\"inline\">~R</code>.</p> <p>It returns a regular expression pattern without escaping nor interpreting interpolations.</p> <p>More information on regexes can be found in the <a href=\"regex\"><code class=\"inline\">Regex</code></a> module.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.match?(~R(f#{1,3}o), \"f#o\")\ntrue</code></pre>    <h3 class=\"detail-header macro\" id=\"sigil_S/2\">  <span class=\"signature\">sigil_S(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class=\"inline\">~S</code>.</p> <p>It simply returns a string without escaping characters and without interpolations.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~S(foo)\n\"foo\"\n\niex&gt; ~S(f#{o}o)\n\"f\\#{o}o\"</code></pre>    <h3 class=\"detail-header macro\" id=\"sigil_T/2\">  <span class=\"signature\">sigil_T(date, modifiers)</span>  </h3>  <p>Handles the sigil <code class=\"inline\">~T</code> for times.</p> <p>The lower case <code class=\"inline\">~t</code> variant does not exist as interpolation and escape characters are not useful for time sigils.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~T[13:00:07]\n~T[13:00:07]\niex&gt; ~T[13:00:07.001]\n~T[13:00:07.001]</code></pre>    <h3 class=\"detail-header macro\" id=\"sigil_W/2\">  <span class=\"signature\">sigil_W(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class=\"inline\">~W</code>.</p> <p>It returns a list of “words” split by whitespace without escaping nor interpreting interpolations.</p> <h4>Modifiers</h4> <ul> <li>\n<code class=\"inline\">s</code>: words in the list are strings (default) </li> <li>\n<code class=\"inline\">a</code>: words in the list are atoms </li> <li>\n<code class=\"inline\">c</code>: words in the list are charlists </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~W(foo #{bar} baz)\n[\"foo\", \"\\#{bar}\", \"baz\"]</code></pre>    <h3 class=\"detail-header macro\" id=\"sigil_c/2\">  <span class=\"signature\">sigil_c(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class=\"inline\">~c</code>.</p> <p>It returns a charlist as if it were a single quoted string, unescaping characters and replacing interpolations.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~c(foo)\n'foo'\n\niex&gt; ~c(f#{:o}o)\n'foo'\n\niex&gt; ~c(f\\#{:o}o)\n'f\\#{:o}o'</code></pre>    <h3 class=\"detail-header macro\" id=\"sigil_r/2\">  <span class=\"signature\">sigil_r(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class=\"inline\">~r</code>.</p> <p>It returns a regular expression pattern, unescaping characters and replacing interpolations.</p> <p>More information on regexes can be found in the <a href=\"regex\"><code class=\"inline\">Regex</code></a> module.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Regex.match?(~r(foo), \"foo\")\ntrue\n\niex&gt; Regex.match?(~r/abc/, \"abc\")\ntrue</code></pre>    <h3 class=\"detail-header macro\" id=\"sigil_s/2\">  <span class=\"signature\">sigil_s(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class=\"inline\">~s</code>.</p> <p>It returns a string as if it was a double quoted string, unescaping characters and replacing interpolations.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~s(foo)\n\"foo\"\n\niex&gt; ~s(f#{:o}o)\n\"foo\"\n\niex&gt; ~s(f\\#{:o}o)\n\"f\\#{:o}o\"</code></pre>    <h3 class=\"detail-header macro\" id=\"sigil_w/2\">  <span class=\"signature\">sigil_w(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class=\"inline\">~w</code>.</p> <p>It returns a list of “words” split by whitespace. Character unescaping and interpolation happens for each word.</p> <h4>Modifiers</h4> <ul> <li>\n<code class=\"inline\">s</code>: words in the list are strings (default) </li> <li>\n<code class=\"inline\">a</code>: words in the list are atoms </li> <li>\n<code class=\"inline\">c</code>: words in the list are charlists </li> </ul> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; ~w(foo #{:bar} baz)\n[\"foo\", \"bar\", \"baz\"]\n\niex&gt; ~w(foo #{\" bar baz \"})\n[\"foo\", \"bar\", \"baz\"]\n\niex&gt; ~w(--source test/enum_test.exs)\n[\"--source\", \"test/enum_test.exs\"]\n\niex&gt; ~w(foo bar baz)a\n[:foo, :bar, :baz]</code></pre>    <h3 class=\"detail-header macro\" id=\"to_charlist/1\">  <span class=\"signature\">to_charlist(arg)</span>  </h3>  <p>Converts the argument to a charlist according to the <a href=\"list.chars\"><code class=\"inline\">List.Chars</code></a> protocol.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; to_charlist(:foo)\n'foo'</code></pre>    <h3 class=\"detail-header macro\" id=\"to_string/1\">  <span class=\"signature\">to_string(arg)</span>  </h3>  <p>Converts the argument to a string according to the <a href=\"string.chars\"><code class=\"inline\">String.Chars</code></a> protocol.</p> <p>This is the function invoked when there is string interpolation.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; to_string(:foo)\n\"foo\"</code></pre>    <h3 class=\"detail-header macro\" id=\"unless/2\">  <span class=\"signature\">unless(condition, clauses)</span>  </h3>  <p>Provides an <code class=\"inline\">unless</code> macro.</p> <p>This macro evaluates and returns the <code class=\"inline\">do</code> block passed in as the second argument unless <code class=\"inline\">clause</code> evaluates to <code class=\"inline\">true</code>. Otherwise, it returns the value of the <code class=\"inline\">else</code> block if present or <code class=\"inline\">nil</code> if not.</p> <p>See also <a href=\"#if/2\"><code class=\"inline\">if/2</code></a>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; unless(Enum.empty?([]), do: \"Hello\")\nnil\n\niex&gt; unless(Enum.empty?([1, 2, 3]), do: \"Hello\")\n\"Hello\"\n\niex&gt; unless Enum.sum([2, 2]) == 5 do\n...&gt;   \"Math still works\"\n...&gt; else\n...&gt;   \"Math is broken\"\n...&gt; end\n\"Math still works\"</code></pre>    <h3 class=\"detail-header macro\" id=\"update_in/2\">  <span class=\"signature\">update_in(path, fun)</span>  </h3>  <p>Updates a nested structure via the given <code class=\"inline\">path</code>.</p> <p>This is similar to <a href=\"#update_in/3\"><code class=\"inline\">update_in/3</code></a>, except the path is extracted via a macro rather than passing a list. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">update_in(opts[:foo][:bar], &amp;(&amp;1 + 1))</code></pre> <p>Is equivalent to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">update_in(opts, [:foo, :bar], &amp;(&amp;1 + 1))</code></pre> <p>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check <a href=\"#get_and_update_in/2\"><code class=\"inline\">get_and_update_in/2</code></a> docs.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; update_in(users[\"john\"][:age], &amp;(&amp;1 + 1))\n%{\"john\" =&gt; %{age: 28}, \"meg\" =&gt; %{age: 23}}\n\niex&gt; users = %{\"john\" =&gt; %{age: 27}, \"meg\" =&gt; %{age: 23}}\niex&gt; update_in(users[\"john\"].age, &amp;(&amp;1 + 1))\n%{\"john\" =&gt; %{age: 28}, \"meg\" =&gt; %{age: 23}}</code></pre>    <h3 class=\"detail-header macro\" id=\"use/2\">  <span class=\"signature\">use(module, opts \\\\ [])</span>  </h3>  <p>Uses the given module in the current context.</p> <h4>Examples</h4> <p>For example, in order to write tests using the ExUnit framework, a developer should use the <code class=\"inline\">ExUnit.Case</code> module:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule AssertionTest do\n  use ExUnit.Case, async: true\n\n  test \"always pass\" do\n    assert true\n  end\nend</code></pre> <p>By calling <a href=\"#use/2\"><code class=\"inline\">use/2</code></a>, a hook called <code class=\"inline\">__using__/1</code> will be invoked in <code class=\"inline\">ExUnit.Case</code> which will then do the proper setup.</p> <p>Simply put, <a href=\"#use/2\"><code class=\"inline\">use/2</code></a> translates to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule AssertionTest do\n  require ExUnit.Case\n  ExUnit.Case.__using__([async: true])\n\n  test \"always pass\" do\n    assert true\n  end\nend</code></pre> <p>Where <code class=\"inline\">__using__/1</code> is just a regular macro that can be defined in any module:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyModule do\n  defmacro __using__(opts) do\n    quote do\n      # code that will run in the module that uses MyModule\n    end\n  end\nend</code></pre> <h4>Best practices</h4> <p><code class=\"inline\">__using__/1</code> is typically used when there is a need to set some state (via module attributes) or callbacks (like <code class=\"inline\">@before_compile</code>) into the caller.</p> <p><code class=\"inline\">__using__/1</code> may also be used to alias, require or import functionality from different modules:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyModule do\n  defmacro __using__(opts) do\n    quote do\n      import MyModule.Foo\n      import MyModule.Bar\n      import MyModule.Baz\n\n      alias MyModule.Repo\n    end\n  end\nend</code></pre> <p>However, do not provide <code class=\"inline\">__using__/1</code> if all it does is to import, alias or require the module itself. For example, do not:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyModule do\n  defmacro __using__(opts) do\n    quote do\n      import MyModule\n    end\n  end\nend</code></pre> <p>In such cases, developers must just import or alias the module directly, allowing developers to customize those as they wish, without the indirection behind <a href=\"#use/2\"><code class=\"inline\">use/2</code></a>.</p> <p>Finally, developers should also avoid defining functions inside the <code class=\"inline\">__using__/1</code> callback, unless those functions are the default implementation of a previously defined <code class=\"inline\">@callback</code>. In case you want to provide some existing functionality to the user module, please define it in a module which will be imported accordingly.</p>    <h3 class=\"detail-header macro\" id=\"var!/2\">  <span class=\"signature\">var!(var, context \\\\ nil)</span>  </h3>  <p>When used inside quoting, marks that the given variable should not be hygienized.</p> <p>The argument can be either a variable unquoted or in standard tuple form <code class=\"inline\">{name, meta, context}</code>.</p> <p>Check <a href=\"kernel.specialforms#quote/2\"><code class=\"inline\">Kernel.SpecialForms.quote/2</code></a> for more information.</p>    <h3 class=\"detail-header macro\" id=\"%7C%3E/2\">  <span class=\"signature\">left |&gt; right</span>  </h3>  <p>Pipe operator.</p> <p>This operator introduces the expression on the left-hand side as the first argument to the function call on the right-hand side.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; [1, [2], 3] |&gt; List.flatten()\n[1, 2, 3]</code></pre> <p>The example above is the same as calling <code class=\"inline\">List.flatten([1, [2], 3])</code>.</p> <p>The <code class=\"inline\">|&gt;</code> operator is mostly useful when there is a desire to execute a series of operations resembling a pipeline:</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; [1, [2], 3] |&gt; List.flatten |&gt; Enum.map(fn x -&gt; x * 2 end)\n[2, 4, 6]</code></pre> <p>In the example above, the list <code class=\"inline\">[1, [2], 3]</code> is passed as the first argument to the <a href=\"list#flatten/1\"><code class=\"inline\">List.flatten/1</code></a> function, then the flattened list is passed as the first argument to the <a href=\"enum#map/2\"><code class=\"inline\">Enum.map/2</code></a> function which doubles each element of the list.</p> <p>In other words, the expression above simply translates to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Enum.map(List.flatten([1, [2], 3]), fn x -&gt; x * 2 end)</code></pre> <h4>Pitfalls</h4> <p>There are two common pitfalls when using the pipe operator.</p> <p>The first one is related to operator precedence. For example, the following expression:</p> <pre data-language=\"elixir\"><code class=\"elixir\">String.graphemes \"Hello\" |&gt; Enum.reverse</code></pre> <p>Translates to:</p> <pre data-language=\"elixir\"><code class=\"elixir\">String.graphemes(\"Hello\" |&gt; Enum.reverse)</code></pre> <p>which results in an error as the <a href=\"enumerable\"><code class=\"inline\">Enumerable</code></a> protocol is not defined for binaries. Adding explicit parentheses resolves the ambiguity:</p> <pre data-language=\"elixir\"><code class=\"elixir\">String.graphemes(\"Hello\") |&gt; Enum.reverse</code></pre> <p>Or, even better:</p> <pre data-language=\"elixir\"><code class=\"elixir\">\"Hello\" |&gt; String.graphemes |&gt; Enum.reverse</code></pre> <p>The second pitfall is that the <code class=\"inline\">|&gt;</code> operator works on calls. For example, when you write:</p> <pre data-language=\"elixir\"><code class=\"elixir\">\"Hello\" |&gt; some_function()</code></pre> <p>Elixir sees the right-hand side is a function call and pipes to it. This means that, if you want to pipe to an anonymous or captured function, it must also be explicitly called.</p> <p>Given the anonymous function:</p> <pre data-language=\"elixir\"><code class=\"elixir\">fun = fn x -&gt; IO.puts(x) end\nfun.(\"Hello\")</code></pre> <p>This won’t work as it will rather try to invoke the local function <code class=\"inline\">fun</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">\"Hello\" |&gt; fun()</code></pre> <p>This works:</p> <pre data-language=\"elixir\"><code class=\"elixir\">\"Hello\" |&gt; fun.()</code></pre> <p>As you can see, the <code class=\"inline\">|&gt;</code> operator retains the same semantics as when the pipe is not used since both require the <code class=\"inline\">fun.(...)</code> notation.</p>    <h3 class=\"detail-header macro\" id=\"%7C%7C/2\">  <span class=\"signature\">left || right</span>  </h3>  <p>Provides a short-circuit operator that evaluates and returns the second expression only if the first one does not evaluate to <code class=\"inline\">true</code> (i.e., it is either <code class=\"inline\">nil</code> or <code class=\"inline\">false</code>). Returns the first expression otherwise.</p> <p>Not allowed in guard clauses.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Enum.empty?([1]) || Enum.empty?([1])\nfalse\n\niex&gt; List.first([]) || true\ntrue\n\niex&gt; Enum.empty?([1]) || 1\n1\n\niex&gt; Enum.empty?([]) || throw(:bad)\ntrue</code></pre> <p>Note that, unlike <a href=\"#or/2\"><code class=\"inline\">or/2</code></a>, this operator accepts any expression as the first argument, not only booleans.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/elixir/Kernel.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/elixir/Kernel.html</a>\n  </p>\n</div>\n","ex_unit/exunit.case":"<h1>  ExUnit.Case  </h1>  <p>Sets up an ExUnit test case.</p> <p>This module must be used in other modules as a way to configure and prepare them for testing.</p> <p>When used, it accepts the following options:</p> <ul> <li>:async - configure this specific test case to able to run in parallel with other test cases. May be used for performance when this test case does not change any global state. Defaults to <code class=\"inline\">false</code>. </li> </ul> <p>This module automatically includes all callbacks defined in <a href=\"exunit.callbacks\"><code class=\"inline\">ExUnit.Callbacks</code></a>. See that module’s documentation for more information.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <pre data-language=\"elixir\"><code class=\"elixir\"> defmodule AssertionTest do\n   # Use the module\n   use ExUnit.Case, async: true\n\n   # The \"test\" macro is imported by ExUnit.Case\n   test \"always pass\" do\n     assert true\n   end\n end</code></pre> <h2 id=\"module-context\" class=\"section-heading\">  Context </h2> <p>All tests receive a context as an argument. The context is particularly useful for sharing information between callbacks and tests:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule KVTest do\n  use ExUnit.Case\n\n  setup do\n    {:ok, pid} = KV.start_link\n    {:ok, [pid: pid]}\n  end\n\n  test \"stores key-value pairs\", context do\n    assert KV.put(context[:pid], :hello, :world) == :ok\n    assert KV.get(context[:pid], :hello) == :world\n  end\nend</code></pre> <p>As the context is a map, it can be pattern matched on to extract information:</p> <pre data-language=\"elixir\"><code class=\"elixir\">test \"stores key-value pairs\", %{pid: pid} do\n  assert KV.put(pid, :hello, :world) == :ok\n  assert KV.get(pid, :hello) == :world\nend</code></pre> <h2 id=\"module-tags\" class=\"section-heading\">  Tags </h2> <p>The context is used to pass information from the callbacks to the test. In order to pass information from the test to the callback, ExUnit provides tags.</p> <p>By tagging a test, the tag value can be accessed in the context, allowing the developer to customize the test. Let’s see an example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule FileTest do\n  # Changing directory cannot be async\n  use ExUnit.Case, async: false\n\n  setup context do\n    # Read the :cd tag value\n    if cd = context[:cd] do\n      prev_cd = File.cwd!\n      File.cd!(cd)\n      on_exit fn -&gt; File.cd!(prev_cd) end\n    end\n\n    :ok\n  end\n\n  @tag cd: \"fixtures\"\n  test \"reads utf-8 fixtures\" do\n    File.read(\"hello\")\n  end\nend</code></pre> <p>In the example above, we have defined a tag called <code class=\"inline\">:cd</code> that is read in the setup callback to configure the working directory the test is going to run on.</p> <p>Tags are also very effective when used with case templates (<a href=\"exunit.casetemplate.html)\"><code class=\"inline\">ExUnit.CaseTemplate</code></a> allowing callbacks in the case template to customize the test behaviour.</p> <p>Note a tag can be set in two different ways:</p> <pre data-language=\"elixir\"><code class=\"elixir\">@tag key: value\n@tag :key       # equivalent to setting @tag key: true</code></pre> <p>If a tag is given more than once, the last value wins.</p> <h3>Module tags</h3> <p>A tag can be set for all tests in a module by setting <code class=\"inline\">@moduletag</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">@moduletag :external</code></pre> <p>If the same key is set via <code class=\"inline\">@tag</code>, the <code class=\"inline\">@tag</code> value has higher precedence.</p> <h3>Known tags</h3> <p>The following tags are set automatically by ExUnit and are therefore reserved:</p> <ul> <li>\n<code class=\"inline\">:case</code> - the test case module </li> <li>\n<code class=\"inline\">:file</code> - the file on which the test was defined </li> <li>\n<code class=\"inline\">:line</code> - the line on which the test was defined </li> <li>\n<code class=\"inline\">:test</code> - the test name </li> <li>\n<code class=\"inline\">:async</code> - if the test case is in async mode </li> <li>\n<code class=\"inline\">:type</code> - the type of the test (<code class=\"inline\">:test</code>, <code class=\"inline\">:property</code>, etc) </li> <li>\n<code class=\"inline\">:registered</code> - used for <a href=\"exunit.case#register_attribute/3\"><code class=\"inline\">ExUnit.Case.register_attribute/3</code></a> values </li> <li>\n<code class=\"inline\">:describe</code> - the describe block the test belongs to </li> </ul> <p>The following tags customize how tests behaves:</p> <ul> <li>\n<code class=\"inline\">:capture_log</code> - see the “Log Capture” section below </li> <li>\n<code class=\"inline\">:skip</code> - skips the test with the given reason </li> <li>\n<code class=\"inline\">:timeout</code> - customizes the test timeout in milliseconds (defaults to 60000) </li> <li>\n<code class=\"inline\">:report</code> - include the given tags and context keys on error reports, see the “Reporting tags” section </li> </ul> <h3>Reporting tags</h3> <p>ExUnit also allows tags or any other key in your context to be included in error reports, making it easy for developers to see under which circumstances a test was evaluated. To do so, you use the <code class=\"inline\">:report</code> tag:</p> <pre data-language=\"elixir\"><code class=\"elixir\">@moduletag report: [:user_id]</code></pre> <h2 id=\"module-filters\" class=\"section-heading\">  Filters </h2> <p>Tags can also be used to identify specific tests, which can then be included or excluded using filters. The most common functionality is to exclude some particular tests from running, which can be done via <a href=\"exunit#configure/1\"><code class=\"inline\">ExUnit.configure/1</code></a>:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># Exclude all external tests from running\nExUnit.configure(exclude: [external: true])</code></pre> <p>From now on, ExUnit will not run any test that has the <code class=\"inline\">external</code> flag set to <code class=\"inline\">true</code>. This behaviour can be reversed with the <code class=\"inline\">:include</code> option which is usually passed through the command line:</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix test --include external:true</code></pre> <p>Run <code class=\"inline\">mix help test</code> for more information on how to run filters via Mix.</p> <p>Another use case for tags and filters is to exclude all tests that have a particular tag by default, regardless of its value, and include only a certain subset:</p> <pre data-language=\"elixir\"><code class=\"elixir\">ExUnit.configure(exclude: :os, include: [os: :unix])</code></pre> <p>Keep in mind that all tests are included by default, so unless they are excluded first, the <code class=\"inline\">include</code> option has no effect.</p> <h2 id=\"module-log-capture\" class=\"section-heading\">  Log Capture </h2> <p>ExUnit can optionally suppress printing of log messages that are generated during a test. Log messages generated while running a test are captured and only if the test fails are they printed to aid with debugging.</p> <p>You can opt into this behaviour for individual tests by tagging them with <code class=\"inline\">:capture_log</code> or enable log capture for all tests in the ExUnit configuration:</p> <pre data-language=\"elixir\"><code class=\"elixir\">ExUnit.start(capture_log: true)</code></pre> <p>This default can be overridden by <code class=\"inline\">@tag capture_log: false</code> or <code class=\"inline\">@moduletag capture_log: false</code>.</p> <p>Since <code class=\"inline\">setup_all</code> blocks don’t belong to a specific test, log messages generated in them (or between tests) are never captured. If you want to suppress these messages as well, remove the console backend globally:</p> <pre data-language=\"elixir\"><code class=\"elixir\">config :logger, backends: []</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#register_attribute/3\">register_attribute(env, name, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Registers a new attribute to be used during <a href=\"exunit.case#content\"><code class=\"inline\">ExUnit.Case</code></a> tests</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#register_test/4\">register_test(map, type, name, tags)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Registers a function to run as part of this case</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#describe/2\">describe(message, list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Describes tests together</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#test/1\">test(message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a not implemented test with a string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#test/3\">test(message, var \\\\ quote() do _ end, contents)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a test with a string</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"register_attribute/3\">  <span class=\"signature\">register_attribute(env, name, opts \\\\ [])</span>  </h3>  <p>Registers a new attribute to be used during <a href=\"exunit.case#content\"><code class=\"inline\">ExUnit.Case</code></a> tests.</p> <p>The attribute values will be available as a key/value pair in <code class=\"inline\">context.registered</code>. The key/value pairs will be cleared after each <code class=\"inline\">ExUnit.Case.test</code> similar to <code class=\"inline\">@tag</code>.</p> <p><code class=\"inline\">Module.register_attribute/3</code> is used to register the attribute, this function takes the same options.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyTest do\n  use ExUnit.Case\n  ExUnit.Case.register_attribute __ENV__, :foobar\n\n  @foobar hello: \"world\"\n  test \"using custom test attribute\", context do\n    assert context.registered.hello == \"world\"\n  end\nend</code></pre>    <h3 class=\"detail-header function\" id=\"register_test/4\">  <span class=\"signature\">register_test(map, type, name, tags)</span>  </h3>  <p>Registers a function to run as part of this case.</p> <p>This is used by 3rd party projects, like QuickCheck, to implement macros like <code class=\"inline\">property/3</code> that works like <code class=\"inline\">test</code> but instead defines a property. See <a href=\"#test/3\"><code class=\"inline\">test/3</code></a> implementation for an example of invoking this function.</p> <p>The test type will be converted to a string and pluralized for display. You can use <a href=\"exunit#plural_rule/2\"><code class=\"inline\">ExUnit.plural_rule/2</code></a> to set a custom pluralization.</p>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"describe/2\">  <span class=\"signature\">describe(message, list)</span>  </h3>  <p>Describes tests together.</p> <p>Every describe block receives a name which is used as prefix for upcoming tests. Inside a block, <a href=\"exunit.callbacks#setup/1\"><code class=\"inline\">ExUnit.Callbacks.setup/1</code></a> may be invoked and it will define a setup callback to run only for the current block. The describe name is also added as a tag, allowing developers to run tests for specific blocks.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule StringTest do\n  use ExUnit.Case, async: true\n\n  describe \"String.capitalize/1\" do\n    test \"first grapheme is in uppercase\" do\n      assert String.capitalize(\"hello\") == \"Hello\"\n    end\n\n    test \"converts remaining graphemes to lowercase\" do\n      assert String.capitalize(\"HELLO\") == \"Hello\"\n    end\n  end\nend</code></pre> <p>When using Mix, you can run all tests in a describe block as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">mix test --only describe:\"String.capitalize/1\"</code></pre> <p>Note describe blocks cannot be nested. Instead of relying on hierarchy for composition, developers should build on top of named setups. For example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule UserManagementTest do\n  use ExUnit.Case, async: true\n\n  describe \"when user is logged in and is an admin\" do\n    setup [:log_user_in, :set_type_to_admin]\n\n    test ...\n  end\n\n  describe \"when user is logged in and is a manager\" do\n    setup [:log_user_in, :set_type_to_manager]\n\n    test ...\n  end\n\n  defp log_user_in(context) do\n    # ...\n  end\nend</code></pre> <p>By forbidding hierarchies in favor of named setups, it is straight-forward for the developer to glance at each describe block and know exactly the setup steps involved.</p>    <h3 class=\"detail-header macro\" id=\"test/1\">  <span class=\"signature\">test(message)</span>  </h3>  <p>Defines a not implemented test with a string.</p> <p>Provides a convenient macro that allows a test to be defined with a string, but not yet implemented. The resulting test will always fail and print “Not yet implemented” error message. The resulting test case is also tagged with :not_implemented.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">test \"this will be a test in future\"</code></pre>    <h3 class=\"detail-header macro\" id=\"test/3\">  <span class=\"signature\">test(message, var \\\\ quote() do _ end, contents)</span>  </h3>  <p>Defines a test with a string.</p> <p>Provides a convenient macro that allows a test to be defined with a string. This macro automatically inserts the atom <code class=\"inline\">:ok</code> as the last line of the test. That said, a passing test always returns <code class=\"inline\">:ok</code>, but, more importantly, it forces Elixir to not tail call optimize the test and therefore avoids hiding lines from the backtrace.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">test \"true is equal to true\" do\n  assert true == true\nend</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/ex_unit/ExUnit.Case.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/ex_unit/ExUnit.Case.html</a>\n  </p>\n</div>\n","ex_unit/exunit.callbacks":"<h1>  ExUnit.Callbacks  </h1>  <p>Defines ExUnit Callbacks.</p> <p>This module defines both <code class=\"inline\">setup_all</code> and <code class=\"inline\">setup</code> callbacks, as well as the <code class=\"inline\">on_exit</code> facility.</p> <p>The setup callbacks are defined via macros and each one can optionally receive a map with metadata, usually referred to as <code class=\"inline\">context</code>. The callback may optionally put extra data into <code class=\"inline\">context</code> to be used in the tests.</p> <p>The <code class=\"inline\">setup_all</code> callbacks are invoked once to setup the test case before any test is run and all <code class=\"inline\">setup</code> callbacks are run before each test. No callback runs if the test case has no tests or all tests were filtered out.</p> <p><code class=\"inline\">on_exit</code> callbacks are registered on demand, usually to undo an action performed by a setup callback. <code class=\"inline\">on_exit</code> may also take a reference, allowing callback to be overridden in the future. A registered <code class=\"inline\">on_exit</code> callback always runs, while failures in <code class=\"inline\">setup</code> and <code class=\"inline\">setup_all</code> will stop all remaining setup callbacks from executing.</p> <p>Finally, <code class=\"inline\">setup_all</code> callbacks run in the test case process, while all <code class=\"inline\">setup</code> callbacks run in the same process as the test itself. <code class=\"inline\">on_exit</code> callbacks always run in a separate process than the test case or the test itself. Since the test process exits with reason <code class=\"inline\">:shutdown</code>, most of times <code class=\"inline\">on_exit/1</code> can be avoided as processes are going to clean up on their own.</p> <h2 id=\"module-context\" class=\"section-heading\">  Context </h2> <p>If you return <code class=\"inline\">{:ok, keywords}</code> from <code class=\"inline\">setup_all</code>, the keyword will be merged into the current context and be available in all subsequent <code class=\"inline\">setup_all</code>, <code class=\"inline\">setup</code> and the test itself.</p> <p>Similarly, returning <code class=\"inline\">{:ok, keywords}</code> from <code class=\"inline\">setup</code>, the keyword returned will be merged into the current context and be available in all subsequent <code class=\"inline\">setup</code> and the <code class=\"inline\">test</code> itself.</p> <p>Returning <code class=\"inline\">:ok</code> leaves the context unchanged in both cases.</p> <p>Returning anything else from <code class=\"inline\">setup_all</code> will force all tests to fail, while a bad response from <code class=\"inline\">setup</code> causes the current test to fail.</p> <h2 id=\"module-examples\" class=\"section-heading\">  Examples </h2> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule AssertionTest do\n  use ExUnit.Case, async: true\n\n  # \"setup_all\" is called once to setup the case before any test is run\n  setup_all do\n    IO.puts \"Starting AssertionTest\"\n\n    # No metadata\n    :ok\n  end\n\n  # \"setup\" is called before each test is run\n  setup do\n    IO.puts \"This is a setup callback\"\n\n    on_exit fn -&gt;\n      IO.puts \"This is invoked once the test is done\"\n    end\n\n    # Returns extra metadata to be merged into context\n    [hello: \"world\"]\n  end\n\n  # Same as \"setup\", but receives the context\n  # for the current test\n  setup context do\n    IO.puts \"Setting up: #{context[:test]}\"\n    :ok\n  end\n\n  # Setups can also invoke a local or imported function\n  setup :invoke_local_or_imported_function\n\n  test \"always pass\" do\n    assert true\n  end\n\n  test \"another one\", context do\n    assert context[:hello] == \"world\"\n  end\n\n  defp invoke_local_or_imported_function(context) do\n    [from_named_setup: true]\n  end\nend</code></pre>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#on_exit/2\">on_exit(ref \\\\ make_ref, callback)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a callback that runs on the test (or test case) exit</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#setup/1\">setup(block)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a callback to be run before each test in a case</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#setup/2\">setup(var, block)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a callback to be run before each test in a case</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#setup_all/1\">setup_all(block)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a callback to be run before all tests in a case</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#setup_all/2\">setup_all(var, block)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Defines a callback to be run before all tests in a case</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"on_exit/2\">  <span class=\"signature\">on_exit(ref \\\\ make_ref, callback)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">on_exit(term, (() -&gt; term)) :: :ok</code></pre>    <p>Defines a callback that runs on the test (or test case) exit.</p> <p>An <code class=\"inline\">on_exit</code> callback is a function that receives no arguments and runs in a separate process than the caller.</p> <p><a href=\"#on_exit/2\"><code class=\"inline\">on_exit/2</code></a> is usually called from <code class=\"inline\">setup</code> and <code class=\"inline\">setup_all</code> callbacks, often to undo the action performed during <code class=\"inline\">setup</code>. However, <code class=\"inline\">on_exit</code> may also be called dynamically, where a reference can be used to guarantee the callback will be invoked only once.</p>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"setup/1\">  <span class=\"signature\">setup(block)</span>  </h3>  <p>Defines a callback to be run before each test in a case.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">setup :clean_up_tmp_directory</code></pre>    <h3 class=\"detail-header macro\" id=\"setup/2\">  <span class=\"signature\">setup(var, block)</span>  </h3>  <p>Defines a callback to be run before each test in a case.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">setup context do\n  [conn: Plug.Conn.build_conn()]\nend</code></pre>    <h3 class=\"detail-header macro\" id=\"setup_all/1\">  <span class=\"signature\">setup_all(block)</span>  </h3>  <p>Defines a callback to be run before all tests in a case.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">setup_all :clean_up_tmp_directory</code></pre>    <h3 class=\"detail-header macro\" id=\"setup_all/2\">  <span class=\"signature\">setup_all(var, block)</span>  </h3>  <p>Defines a callback to be run before all tests in a case.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">setup_all context do\n  [conn: Plug.Conn.build_conn()]\nend</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/ex_unit/ExUnit.Callbacks.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/ex_unit/ExUnit.Callbacks.html</a>\n  </p>\n</div>\n","mix/mix.shell.io":"<h1>  Mix.Shell.IO  </h1>  <p>This is Mix’s default shell.</p> <p>It simply prints messages to stdio and stderr.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#cmd/2\">cmd(command, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Executes the given command and prints its output to stdout as it comes</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#error/1\">error(message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Writes an error message to the shell followed by new line</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#info/1\">info(message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Writes a message to the shell followed by new line</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#print_app/0\">print_app()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prints the currently running application if it was not printed yet</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#prompt/1\">prompt(message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Writes a message shell followed by prompting the user for input. Input will be consumed until enter is pressed</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#yes?/1\">yes?(message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a message and asks the user if they want to proceed. The user must press enter or type anything that matches the “yes” regex <code class=\"inline\">~r/^Y(es)?$/i</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"cmd/2\">  <span class=\"signature\">cmd(command, opts \\\\ [])</span>  </h3>  <p>Executes the given command and prints its output to stdout as it comes.</p>    <h3 class=\"detail-header function\" id=\"error/1\">  <span class=\"signature\">error(message)</span>  </h3>  <p>Writes an error message to the shell followed by new line.</p>    <h3 class=\"detail-header function\" id=\"info/1\">  <span class=\"signature\">info(message)</span>  </h3>  <p>Writes a message to the shell followed by new line.</p>    <h3 class=\"detail-header function\" id=\"print_app/0\">  <span class=\"signature\">print_app()</span>  </h3>  <p>Prints the currently running application if it was not printed yet.</p>    <h3 class=\"detail-header function\" id=\"prompt/1\">  <span class=\"signature\">prompt(message)</span>  </h3>  <p>Writes a message shell followed by prompting the user for input. Input will be consumed until enter is pressed.</p>    <h3 class=\"detail-header function\" id=\"yes?/1\">  <span class=\"signature\">yes?(message)</span>  </h3>  <p>Receives a message and asks the user if they want to proceed. The user must press enter or type anything that matches the “yes” regex <code class=\"inline\">~r/^Y(es)?$/i</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/mix/Mix.Shell.IO.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/mix/Mix.Shell.IO.html</a>\n  </p>\n</div>\n","logger/logger.translator":"<h1>  Logger.Translator  </h1>  <p>Default translation for Erlang log messages.</p> <p>Logger allows developers to rewrite log messages provided by Erlang applications into a format more compatible with Elixir log messages by providing a translator.</p> <p>A translator is simply a tuple containing a module and a function that can be added and removed via the <a href=\"logger#add_translator/1\"><code class=\"inline\">Logger.add_translator/1</code></a> and <a href=\"logger#remove_translator/1\"><code class=\"inline\">Logger.remove_translator/1</code></a> functions and is invoked for every Erlang message above the minimum log level with four arguments:</p> <ul> <li>\n<code class=\"inline\">min_level</code> - the current Logger level </li> <li>\n<code class=\"inline\">level</code> - the level of the message being translated </li> <li>\n<code class=\"inline\">kind</code> - if the message is a report or a format </li> <li>\n<code class=\"inline\">message</code> - the message to format. If it is a report, it is a tuple with <code class=\"inline\">{report_type, report_data}</code>, if it is a format, it is a tuple with <code class=\"inline\">{format_message, format_args}</code> </li> </ul> <p>The function must return:</p> <ul> <li>\n<code class=\"inline\">{:ok, chardata}</code> - if the message was translated with its translation </li> <li>\n<code class=\"inline\">:skip</code> - if the message is not meant to be translated nor logged </li> <li>\n<code class=\"inline\">:none</code> - if there is no translation, which triggers the next translator </li> </ul> <p>See the function <a href=\"#translate/4\"><code class=\"inline\">translate/4</code></a> in this module for an example implementation and the default messages translated by Logger.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#translate/4\">translate(min_level, level, kind, message)</a> </dt>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"translate/4\">  <span class=\"signature\">translate(min_level, level, kind, message)</span>  </h3><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/logger/Logger.Translator.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/logger/Logger.Translator.html</a>\n  </p>\n</div>\n","logger/logger.formatter":"<h1>  Logger.Formatter  </h1>  <p>Conveniences for formatting data for logs.</p> <p>This module allows developers to specify a string that serves as template for log messages, for example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">$time $metadata[$level] $message\\n</code></pre> <p>Will print error messages as:</p> <pre data-language=\"elixir\"><code class=\"elixir\">18:43:12.439 user_id=13 [error] Hello\\n</code></pre> <p>The valid parameters you can use are:</p> <ul> <li>\n<code class=\"inline\">$time</code> - time the log message was sent </li> <li>\n<code class=\"inline\">$date</code> - date the log message was sent </li> <li>\n<code class=\"inline\">$message</code> - the log message </li> <li>\n<code class=\"inline\">$level</code> - the log level </li> <li>\n<code class=\"inline\">$node</code> - the node that prints the message </li> <li>\n<code class=\"inline\">$metadata</code> - user controlled data presented in <code class=\"inline\">\"key=val key2=val2\"</code> format </li> <li>\n<code class=\"inline\">$levelpad</code> - set to a single space if level is 4 characters long, otherwise set to the empty space. Used to align the message after level. </li> </ul> <p>Backends typically allow developers to supply such control strings via configuration files. This module provides <a href=\"#compile/1\"><code class=\"inline\">compile/1</code></a>, which compiles the string into a format for fast operations at runtime and <a href=\"#format/5\"><code class=\"inline\">format/5</code></a> to format the compiled pattern into an actual IO data.</p> <h2 id=\"module-metadata\" class=\"section-heading\">  Metadata </h2> <p>Metadata to be sent to the Logger can be read and written with the <a href=\"logger#metadata/0\"><code class=\"inline\">Logger.metadata/0</code></a> and <a href=\"logger#metadata/1\"><code class=\"inline\">Logger.metadata/1</code></a> functions. For example, you can set <code class=\"inline\">Logger.metadata([user_id: 13])</code> to add user_id metadata to the current process. The user can configure the backend to chose which metadata it wants to print and it will replace the <code class=\"inline\">$metadata</code> value.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:pattern/0\">pattern()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:time/0\">time()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#compile/1\">compile(str)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compiles a format string into a data structure that the <a href=\"#format/5\"><code class=\"inline\">format/5</code></a> can handle</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#format/5\">format(config, level, msg, ts, md)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Takes a compiled format and injects the, level, timestamp, message and metadata listdict and returns a properly formatted string</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#prune/1\">prune(binary)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prune non-valid UTF-8 codepoints</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:pattern/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:pattern/0\">pattern</a> ::\n  :date |\n  :level |\n  :levelpad |\n  :message |\n  :metadata |\n  :node |\n  :time</code></pre> </div> <div id=\"t:time/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:time/0\">time</a> :: {{1970..10000, 1..12, 1..31}, {0..23, 0..59, 0..59, 0..999}}</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"compile/1\">  <span class=\"signature\">compile(str)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">compile(binary | nil) :: [<a href=\"#t:pattern/0\">pattern</a> | binary]</code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">compile({atom, atom}) :: {atom, atom}</code></pre>    <p>Compiles a format string into a data structure that the <a href=\"#format/5\"><code class=\"inline\">format/5</code></a> can handle.</p> <p>Check the module doc for documentation on the valid parameters. If you pass <code class=\"inline\">nil</code>, it defaults to: <code class=\"inline\">$time $metadata [$level] $levelpad$message\\n</code></p> <p>If you would like to make your own custom formatter simply pass <code class=\"inline\">{module, function}</code> to <a href=\"#compile/1\"><code class=\"inline\">compile/1</code></a> and the rest is handled.</p> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; Logger.Formatter.compile(\"$time $metadata [$level] $message\\n\")\n[:time, \" \", :metadata, \" [\", :level, \"] \", :message, \"\\n\"]</code></pre>    <h3 class=\"detail-header function\" id=\"format/5\">  <span class=\"signature\">format(config, level, msg, ts, md)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">format({atom, atom} | [<a href=\"#t:pattern/0\">pattern</a> | binary], <a href=\"logger#t:level/0\">Logger.level</a>, <a href=\"logger#t:message/0\">Logger.message</a>, <a href=\"#t:time/0\">time</a>, <a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: <a href=\"../elixir/io#t:chardata/0\">IO.chardata</a></code></pre>    <p>Takes a compiled format and injects the, level, timestamp, message and metadata listdict and returns a properly formatted string.</p>    <h3 class=\"detail-header function\" id=\"prune/1\">  <span class=\"signature\">prune(binary)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">prune(<a href=\"../elixir/io#t:chardata/0\">IO.chardata</a>) :: <a href=\"../elixir/io#t:chardata/0\">IO.chardata</a></code></pre>    <p>Prune non-valid UTF-8 codepoints.</p> <p>Typically called after formatting when the data cannot be printed.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/logger/Logger.Formatter.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/logger/Logger.Formatter.html</a>\n  </p>\n</div>\n","ex_unit/exunit.assertions":"<h1>  ExUnit.Assertions  </h1>  <p>This module contains a set of assertion functions that are imported by default into your test cases.</p> <p>In general, a developer will want to use the general <code class=\"inline\">assert</code> macro in tests. This macro introspects your code and provide good reporting whenever there is a failure. For example, <code class=\"inline\">assert some_fun() == 10</code> will fail (assuming <code class=\"inline\">some_fun()</code> returns 13):</p> <pre data-language=\"elixir\"><code class=\"elixir\">Comparison (using ==) failed in:\ncode: some_fun() == 10\nlhs:  13\nrhs:  10</code></pre> <p>This module also provides other convenience functions like <code class=\"inline\">assert_in_delta</code> and <code class=\"inline\">assert_raise</code> to easily handle other common cases such as checking a floating point number or handling exceptions.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#assert/2\">assert(value, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts <code class=\"inline\">value</code> is <code class=\"inline\">true</code>, displaying the given <code class=\"inline\">message</code> otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#assert_in_delta/4\">assert_in_delta(value1, value2, delta, message \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts that <code class=\"inline\">value1</code> and <code class=\"inline\">value2</code> differ by no more than <code class=\"inline\">delta</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#assert_raise/2\">assert_raise(exception, function)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts the <code class=\"inline\">exception</code> is raised during <code class=\"inline\">function</code> execution. Returns the rescued exception, fails otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#assert_raise/3\">assert_raise(exception, message, function)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts the <code class=\"inline\">exception</code> is raised during <code class=\"inline\">function</code> execution with the expected <code class=\"inline\">message</code>, which can be a <code class=\"inline\">Regex</code> or an exact <code class=\"inline\">String</code>. Returns the rescued exception, fails otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#flunk/1\">flunk(message \\\\ \"Flunked!\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Fails with a message</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#refute/2\">refute(value, message)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts <code class=\"inline\">value</code> is <code class=\"inline\">nil</code> or <code class=\"inline\">false</code> (that is, <code class=\"inline\">value</code> is not truthy)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#refute_in_delta/4\">refute_in_delta(value1, value2, delta, message \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts <code class=\"inline\">value1</code> and <code class=\"inline\">value2</code> are not within <code class=\"inline\">delta</code></p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#assert/1\">assert(assertion)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts its argument is a truthy value</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#assert_receive/3\">assert_receive(pattern, timeout \\\\ Application.fetch_env!(:ex_unit, :assert_receive_timeout), failure_message \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts that a message matching <code class=\"inline\">pattern</code> was or is going to be received</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#assert_received/2\">assert_received(pattern, failure_message \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts that a message matching <code class=\"inline\">pattern</code> was received and is in the current process’ mailbox</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#catch_error/1\">catch_error(expression)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts <code class=\"inline\">expression</code> will cause an error. Returns the error or fails otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#catch_exit/1\">catch_exit(expression)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts <code class=\"inline\">expression</code> will exit. Returns the exit status/message or fails otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#catch_throw/1\">catch_throw(expression)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts <code class=\"inline\">expression</code> will throw a value. Returns the thrown value or fails otherwise</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#refute/1\">refute(assertion)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A negative assertion, expects the expression to be <code class=\"inline\">false</code> or <code class=\"inline\">nil</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#refute_receive/3\">refute_receive(pattern, timeout \\\\ Application.fetch_env!(:ex_unit, :refute_receive_timeout), failure_message \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts that a message matching <code class=\"inline\">pattern</code> was not received (and won’t be received) within the <code class=\"inline\">timeout</code> period</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#refute_received/2\">refute_received(pattern, failure_message \\\\ nil)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Asserts a message matching <code class=\"inline\">pattern</code> was not received (i.e. it is not in the current process’ mailbox)</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"assert/2\">  <span class=\"signature\">assert(value, message)</span>  </h3>  <p>Asserts <code class=\"inline\">value</code> is <code class=\"inline\">true</code>, displaying the given <code class=\"inline\">message</code> otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">assert false, \"it will never be true\"</code></pre>    <h3 class=\"detail-header function\" id=\"assert_in_delta/4\">  <span class=\"signature\">assert_in_delta(value1, value2, delta, message \\\\ nil)</span>  </h3>  <p>Asserts that <code class=\"inline\">value1</code> and <code class=\"inline\">value2</code> differ by no more than <code class=\"inline\">delta</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">assert_in_delta 1.1, 1.5, 0.2\nassert_in_delta 10, 15, 4</code></pre>    <h3 class=\"detail-header function\" id=\"assert_raise/2\">  <span class=\"signature\">assert_raise(exception, function)</span>  </h3>  <p>Asserts the <code class=\"inline\">exception</code> is raised during <code class=\"inline\">function</code> execution. Returns the rescued exception, fails otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">assert_raise ArithmeticError, fn -&gt;\n  1 + \"test\"\nend</code></pre>    <h3 class=\"detail-header function\" id=\"assert_raise/3\">  <span class=\"signature\">assert_raise(exception, message, function)</span>  </h3>  <p>Asserts the <code class=\"inline\">exception</code> is raised during <code class=\"inline\">function</code> execution with the expected <code class=\"inline\">message</code>, which can be a <code class=\"inline\">Regex</code> or an exact <code class=\"inline\">String</code>. Returns the rescued exception, fails otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">assert_raise ArithmeticError, \"bad argument in arithmetic expression\", fn -&gt;\n  1 + \"test\"\nend\n\nassert_raise RuntimeError, ~r/^today's lucky number is 0.+!$/, fn -&gt;\n  raise \"today's lucky number is 0.05366788832789447!\"\nend</code></pre>    <h3 class=\"detail-header function\" id=\"flunk/1\">  <span class=\"signature\">flunk(message \\\\ \"Flunked!\")</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">flunk(<a href=\"../elixir/string#t:t/0\">String.t</a>) :: no_return</code></pre>    <p>Fails with a message.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">flunk \"This should raise an error\"</code></pre>    <h3 class=\"detail-header function\" id=\"refute/2\">  <span class=\"signature\">refute(value, message)</span>  </h3>  <p>Asserts <code class=\"inline\">value</code> is <code class=\"inline\">nil</code> or <code class=\"inline\">false</code> (that is, <code class=\"inline\">value</code> is not truthy).</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">refute true, \"This will obviously fail\"</code></pre>    <h3 class=\"detail-header function\" id=\"refute_in_delta/4\">  <span class=\"signature\">refute_in_delta(value1, value2, delta, message \\\\ nil)</span>  </h3>  <p>Asserts <code class=\"inline\">value1</code> and <code class=\"inline\">value2</code> are not within <code class=\"inline\">delta</code>.</p> <p>If you supply <code class=\"inline\">message</code>, information about the values will automatically be appended to it.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">refute_in_delta 1.1, 1.2, 0.2\nrefute_in_delta 10, 11, 2</code></pre>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"assert/1\">  <span class=\"signature\">assert(assertion)</span>  </h3>  <p>Asserts its argument is a truthy value.</p> <p><code class=\"inline\">assert</code> instrospects the underlying expression and provide good reporting whenever there is a failure. For example, if the expression uses the comparison operator, the message will show the values of the two sides. The assertion</p> <pre data-language=\"elixir\"><code class=\"elixir\">assert 1+2+3+4 &gt; 15</code></pre> <p> will fail with the message:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Assertion with &gt; failed\ncode: 1+2+3+4 &gt; 15\nlhs:  10\nrhs:  15</code></pre> <p>Similarly, if a match expression is given, it will report any failure in terms of that match. Given</p> <pre data-language=\"elixir\"><code class=\"elixir\">assert [one] = [two]</code></pre> <p>you’ll see:</p> <pre data-language=\"elixir\"><code class=\"elixir\">match (=) failed\ncode: [one] = [two]\nrhs:  [2]</code></pre> <p>Keep in mind that <code class=\"inline\">assert</code> does not change its semantics based on the expression. In other words, the expression is still required to return a truthy value. For example, the following will fail:</p> <pre data-language=\"elixir\"><code class=\"elixir\">assert nil = some_function_that_returns_nil()</code></pre> <p>Even though the match works, <code class=\"inline\">assert</code> still expects a truth value. In such cases, simply use <code class=\"inline\">Kernel.==/2</code> or <code class=\"inline\">Kernel.match?/2</code>.</p>    <h3 class=\"detail-header macro\" id=\"assert_receive/3\">  <span class=\"signature\">assert_receive(pattern, timeout \\\\ Application.fetch_env!(:ex_unit, :assert_receive_timeout), failure_message \\\\ nil)</span>  </h3>  <p>Asserts that a message matching <code class=\"inline\">pattern</code> was or is going to be received.</p> <p>Unlike <code class=\"inline\">assert_received</code>, it has a default timeout of 100 milliseconds.</p> <p>The <code class=\"inline\">pattern</code> argument must be a match pattern. Flunks with <code class=\"inline\">failure_message</code> if a message matching <code class=\"inline\">pattern</code> is not received.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">assert_receive :hello</code></pre> <p>Asserts against a larger timeout:</p> <pre data-language=\"elixir\"><code class=\"elixir\">assert_receive :hello, 20_000</code></pre> <p>You can also match against specific patterns:</p> <pre data-language=\"elixir\"><code class=\"elixir\">assert_receive {:hello, _}\n\nx = 5\nassert_receive {:count, ^x}</code></pre>    <h3 class=\"detail-header macro\" id=\"assert_received/2\">  <span class=\"signature\">assert_received(pattern, failure_message \\\\ nil)</span>  </h3>  <p>Asserts that a message matching <code class=\"inline\">pattern</code> was received and is in the current process’ mailbox.</p> <p>The <code class=\"inline\">pattern</code> argument must be a match pattern. Flunks with <code class=\"inline\">failure_message</code> if a message matching <code class=\"inline\">pattern</code> was not received.</p> <p>Timeout is set to 0, so there is no waiting time.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">send self, :hello\nassert_received :hello\n\nsend self, :bye\nassert_received :hello, \"Oh No!\"\n** (ExUnit.AssertionError) Oh No!\nProcess mailbox:\n  :bye</code></pre> <p>You can also match against specific patterns:</p> <pre data-language=\"elixir\"><code class=\"elixir\">send self, {:hello, \"world\"}\nassert_received {:hello, _}</code></pre>    <h3 class=\"detail-header macro\" id=\"catch_error/1\">  <span class=\"signature\">catch_error(expression)</span>  </h3>  <p>Asserts <code class=\"inline\">expression</code> will cause an error. Returns the error or fails otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">assert catch_error(error 1) == 1</code></pre>    <h3 class=\"detail-header macro\" id=\"catch_exit/1\">  <span class=\"signature\">catch_exit(expression)</span>  </h3>  <p>Asserts <code class=\"inline\">expression</code> will exit. Returns the exit status/message or fails otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">assert catch_exit(exit 1) == 1</code></pre>    <h3 class=\"detail-header macro\" id=\"catch_throw/1\">  <span class=\"signature\">catch_throw(expression)</span>  </h3>  <p>Asserts <code class=\"inline\">expression</code> will throw a value. Returns the thrown value or fails otherwise.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">assert catch_throw(throw 1) == 1</code></pre>    <h3 class=\"detail-header macro\" id=\"refute/1\">  <span class=\"signature\">refute(assertion)</span>  </h3>  <p>A negative assertion, expects the expression to be <code class=\"inline\">false</code> or <code class=\"inline\">nil</code>.</p> <p>Keep in mind that <code class=\"inline\">refute</code> does not change the semantics of the given expression. In other words, the following will fail:</p> <pre data-language=\"elixir\"><code class=\"elixir\">refute {:ok, _} = some_function_that_returns_error_tuple()</code></pre> <p>The code above will fail because the <code class=\"inline\">=</code> operator always fails when the sides do not match and <a href=\"#refute/2\"><code class=\"inline\">refute/2</code></a> does not change it.</p> <p>The correct way to write the refutation above is to use <code class=\"inline\">Kernel.match?/2</code>:</p> <pre data-language=\"elixir\"><code class=\"elixir\">refute match? {:ok, _}, some_function_that_returns_error_tuple()</code></pre> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">refute age &lt; 0</code></pre>    <h3 class=\"detail-header macro\" id=\"refute_receive/3\">  <span class=\"signature\">refute_receive(pattern, timeout \\\\ Application.fetch_env!(:ex_unit, :refute_receive_timeout), failure_message \\\\ nil)</span>  </h3>  <p>Asserts that a message matching <code class=\"inline\">pattern</code> was not received (and won’t be received) within the <code class=\"inline\">timeout</code> period.</p> <p>The <code class=\"inline\">pattern</code> argument must be a match pattern. Flunks with <code class=\"inline\">failure_message</code> if a message matching <code class=\"inline\">pattern</code> is received.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">refute_receive :bye</code></pre> <p>Refute received with an explicit timeout:</p> <pre data-language=\"elixir\"><code class=\"elixir\">refute_receive :bye, 1000</code></pre>    <h3 class=\"detail-header macro\" id=\"refute_received/2\">  <span class=\"signature\">refute_received(pattern, failure_message \\\\ nil)</span>  </h3>  <p>Asserts a message matching <code class=\"inline\">pattern</code> was not received (i.e. it is not in the current process’ mailbox).</p> <p>The <code class=\"inline\">pattern</code> argument must be a match pattern. Flunks with <code class=\"inline\">failure_message</code> if a message matching <code class=\"inline\">pattern</code> was received.</p> <p>Timeout is set to 0, so there is no waiting time.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">send self, :hello\nrefute_received :bye\n\nsend self, :hello\nrefute_received :hello, \"Oh No!\"\n** (ExUnit.AssertionError) Oh No!\nProcess mailbox:\n  :bye</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/ex_unit/ExUnit.Assertions.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/ex_unit/ExUnit.Assertions.html</a>\n  </p>\n</div>\n","iex/iex.helpers":"<h1>  IEx.Helpers  </h1>  <p>Welcome to Interactive Elixir. You are currently seeing the documentation for the module <a href=\"iex.helpers#content\"><code class=\"inline\">IEx.Helpers</code></a> which provides many helpers to make Elixir’s shell more joyful to work with.</p> <p>This message was triggered by invoking the helper <code class=\"inline\">h()</code>, usually referred to as <a href=\"#h/0\"><code class=\"inline\">h/0</code></a> (since it expects 0 arguments).</p> <p>You can use the <code class=\"inline\">h</code> function to invoke the documentation for any Elixir module or function:</p> <pre data-language=\"elixir\"><code class=\"elixir\">h Enum\nh Enum.map\nh Enum.reverse/1</code></pre> <p>You can also use the <code class=\"inline\">i</code> function to introspect any value you have in the shell:</p> <pre data-language=\"elixir\"><code class=\"elixir\">i \"hello\"</code></pre> <p>There are many other helpers available:</p> <ul> <li>\n<a href=\"#b/1\"><code class=\"inline\">b/1</code></a> - prints callbacks info and docs for a given module </li> <li>\n<code class=\"inline\">c/1</code> - compiles a file into the current directory </li> <li>\n<a href=\"#c/2\"><code class=\"inline\">c/2</code></a> - compiles a file to the given path </li> <li>\n<a href=\"#cd/1\"><code class=\"inline\">cd/1</code></a> - changes the current directory </li> <li>\n<a href=\"#clear/0\"><code class=\"inline\">clear/0</code></a> - clears the screen </li> <li>\n<a href=\"#flush/0\"><code class=\"inline\">flush/0</code></a> - flushes all messages sent to the shell </li> <li>\n<a href=\"#h/0\"><code class=\"inline\">h/0</code></a> - prints this help message </li> <li>\n<a href=\"#h/1\"><code class=\"inline\">h/1</code></a> - prints help for the given module, function or macro </li> <li>\n<a href=\"#i/1\"><code class=\"inline\">i/1</code></a> - prints information about the given data type </li> <li>\n<code class=\"inline\">import_file/1</code> - evaluates the given file in the shell’s context </li> <li>\n<a href=\"#l/1\"><code class=\"inline\">l/1</code></a> - loads the given module’s beam code </li> <li>\n<code class=\"inline\">ls/0</code> - lists the contents of the current directory </li> <li>\n<a href=\"#ls/1\"><code class=\"inline\">ls/1</code></a> - lists the contents of the specified directory </li> <li>\n<a href=\"#nl/2\"><code class=\"inline\">nl/2</code></a> - deploys local beam code to a list of nodes </li> <li>\n<a href=\"#pid/1\"><code class=\"inline\">pid/1</code></a> - creates a PID from a string </li> <li>\n<a href=\"#pid/3\"><code class=\"inline\">pid/3</code></a> - creates a PID with the 3 integer arguments passed </li> <li>\n<a href=\"#pwd/0\"><code class=\"inline\">pwd/0</code></a> - prints the current working directory </li> <li>\n<a href=\"#r/1\"><code class=\"inline\">r/1</code></a> - recompiles the given module’s source file </li> <li>\n<a href=\"#recompile/0\"><code class=\"inline\">recompile/0</code></a> - recompiles the current project </li> <li>\n<a href=\"#respawn/0\"><code class=\"inline\">respawn/0</code></a> - respawns the current shell </li> <li>\n<a href=\"#s/1\"><code class=\"inline\">s/1</code></a> - prints spec information </li> <li>\n<a href=\"#t/1\"><code class=\"inline\">t/1</code></a> - prints type information </li> <li>\n<code class=\"inline\">v/0</code> - retrieves the last value from the history </li> <li>\n<a href=\"#v/1\"><code class=\"inline\">v/1</code></a> - retrieves the nth value from the history </li> </ul> <p>Help for all of those functions can be consulted directly from the command line using the <code class=\"inline\">h</code> helper itself. Try:</p> <pre data-language=\"elixir\"><code class=\"elixir\">h(v/0)</code></pre> <p>To learn more about IEx as a whole, just type <code class=\"inline\">h(IEx)</code>.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#c/2\">c(files, path \\\\ \".\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compiles the given files</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#cd/1\">cd(directory)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Changes the current working directory to the given path</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#clear/0\">clear()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Clears the console screen</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#flush/0\">flush()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Flushes all messages sent to the shell and prints them out</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#h/0\">h()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prints the documentation for <a href=\"iex.helpers#content\"><code class=\"inline\">IEx.Helpers</code></a></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#i/1\">i(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prints information about the given data type</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#l/1\">l(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Loads the given module’s beam code (and ensures any previous old version was properly purged before)</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ls/1\">ls(path \\\\ \".\")</a> </dt> <dd class=\"summary-synopsis\">\n<p>Produces a simple list of a directory’s contents</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#nl/2\">nl(nodes \\\\ Node.list(), module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Deloys a given module’s beam code to a list of nodes</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pid/1\">pid(string)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a PID from <code class=\"inline\">string</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pid/3\">pid(x, y, z)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Creates a PID with 3 non negative integers passed as arguments to the function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#pwd/0\">pwd()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prints the current working directory</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#r/1\">r(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Recompiles and reloads the given <code class=\"inline\">module</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#recompile/0\">recompile()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Recompiles the current Mix application</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#respawn/0\">respawn()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Respawns the current shell by starting a new shell process</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#v/1\">v(n \\\\ -1)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Retrieves the nth expression’s value from the history</p> </dd>  </dl> <h2> Macros </h2>\n<dl class=\"summary-macros summary\">   <dt class=\"summary-signature\"> <a href=\"#b/1\">b(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prints the documentation for the given callback function</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#h/1\">h(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prints the documentation for the given module or for the given function/arity pair</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#import_file/2\">import_file(path, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Evaluates the contents of the file at <code class=\"inline\">path</code> as if it were directly typed into the shell</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#import_file_if_available/1\">import_file_if_available(path)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Similar to <code class=\"inline\">import_file</code> but only imports it if it is available</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#import_if_available/2\">import_if_available(quoted_module, opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Calls <code class=\"inline\">import/2</code> with the given arguments, but only if the module is available</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#s/1\">s(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prints the specs for the given module or for the given function/arity pair</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#t/1\">t(term)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Prints the types for the given module or for the given function/arity pair</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"c/2\">  <span class=\"signature\">c(files, path \\\\ \".\")</span>  </h3>  <p>Compiles the given files.</p> <p>It expects a list of files to compile and an optional path to write the compiled code to (defaults to the current directory). When compiling one file, there is no need to wrap it in a list.</p> <p>It returns the name of the compiled modules.</p> <p>If you want to recompile an existing module, check <a href=\"#r/1\"><code class=\"inline\">r/1</code></a> instead.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">c [\"foo.ex\", \"bar.ex\"], \"ebin\"\n#=&gt; [Foo, Bar]\n\nc \"baz.ex\"\n#=&gt; [Baz]</code></pre>    <h3 class=\"detail-header function\" id=\"cd/1\">  <span class=\"signature\">cd(directory)</span>  </h3>  <p>Changes the current working directory to the given path.</p>    <h3 class=\"detail-header function\" id=\"clear/0\">  <span class=\"signature\">clear()</span>  </h3>  <p>Clears the console screen.</p> <p>This function only works if ANSI escape codes are enabled on the shell, which means this function is by default unavailable on Windows machines.</p>    <h3 class=\"detail-header function\" id=\"flush/0\">  <span class=\"signature\">flush()</span>  </h3>  <p>Flushes all messages sent to the shell and prints them out.</p>    <h3 class=\"detail-header function\" id=\"h/0\">  <span class=\"signature\">h()</span>  </h3>  <p>Prints the documentation for <a href=\"iex.helpers#content\"><code class=\"inline\">IEx.Helpers</code></a>.</p>    <h3 class=\"detail-header function\" id=\"i/1\">  <span class=\"signature\">i(term)</span>  </h3>  <p>Prints information about the given data type.</p>    <h3 class=\"detail-header function\" id=\"l/1\">  <span class=\"signature\">l(module)</span>  </h3>  <p>Loads the given module’s beam code (and ensures any previous old version was properly purged before).</p> <p>This function is useful when you know the bytecode for module has been updated in the filesystem and you want to tell the VM to load it.</p>    <h3 class=\"detail-header function\" id=\"ls/1\">  <span class=\"signature\">ls(path \\\\ \".\")</span>  </h3>  <p>Produces a simple list of a directory’s contents.</p> <p>If <code class=\"inline\">path</code> points to a file, prints its full path.</p>    <h3 class=\"detail-header function\" id=\"nl/2\">  <span class=\"signature\">nl(nodes \\\\ Node.list(), module)</span>  </h3>  <p>Deloys a given module’s beam code to a list of nodes.</p> <p>This function is useful for development and debugging when you have code that has been compiled or updated locally that you want to run on other nodes.</p> <p>The node list defaults to a list of all connected nodes.</p> <p>Returns <code class=\"inline\">{:error, :nofile}</code> if the object code (i.e. “.beam” file) for the module could not be found locally.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">nl(HelloWorld)\n#=&gt; {:ok, [{:node1@easthost, :loaded, HelloWorld},\n           {:node1@westhost, :loaded, HelloWorld}]}\n\nnl(NoSuchModuleExists)\n#=&gt; {:error, :nofile}</code></pre>    <h3 class=\"detail-header function\" id=\"pid/1\">  <span class=\"signature\">pid(string)</span>  </h3>  <p>Creates a PID from <code class=\"inline\">string</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; pid(\"0.21.32\")\n#PID&lt;0.21.32&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"pid/3\">  <span class=\"signature\">pid(x, y, z)</span>  </h3>  <p>Creates a PID with 3 non negative integers passed as arguments to the function.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"iex elixir\">iex&gt; pid(0, 21, 32)\n#PID&lt;0.21.32&gt;\niex&gt; pid(0, 64, 2048)\n#PID&lt;0.64.2048&gt;</code></pre>    <h3 class=\"detail-header function\" id=\"pwd/0\">  <span class=\"signature\">pwd()</span>  </h3>  <p>Prints the current working directory.</p>    <h3 class=\"detail-header function\" id=\"r/1\">  <span class=\"signature\">r(module)</span>  </h3>  <p>Recompiles and reloads the given <code class=\"inline\">module</code>.</p> <p>Please note that all the modules defined in the same file as <code class=\"inline\">module</code> are recompiled and reloaded.</p> <p>This function is meant to be used for development and debugging purposes. Do not depend on it in production code.</p> <h4>In-memory reloading</h4> <p>When we reload the module in IEx, we recompile the module source code, updating its contents in memory. The original <code class=\"inline\">.beam</code> file in disk, probably the one where the first definition of the module came from, does not change at all.</p> <p>Since typespecs and docs are loaded from the .beam file (they are not loaded in memory with the module because there is no need for them to be in memory), they are not reloaded when you reload the module.</p>    <h3 class=\"detail-header function\" id=\"recompile/0\">  <span class=\"signature\">recompile()</span>  </h3>  <p>Recompiles the current Mix application.</p> <p>This helper only works when IEx is started with a Mix project, for example, <code class=\"inline\">iex -S mix</code>. The application is not restarted after compilation, which means any long running process may crash as the code is updated but the state does not go through the proper code changes callback. In any case, the supervision tree should notice the failure and restart such servers.</p> <p>If you want to reload a single module, consider using <code class=\"inline\">r ModuleName</code> instead.</p> <p>This function is meant to be used for development and debugging purposes. Do not depend on it in production code.</p>    <h3 class=\"detail-header function\" id=\"respawn/0\">  <span class=\"signature\">respawn()</span>  </h3>  <p>Respawns the current shell by starting a new shell process.</p> <p>Returns <code class=\"inline\">true</code> if it worked.</p>    <h3 class=\"detail-header function\" id=\"v/1\">  <span class=\"signature\">v(n \\\\ -1)</span>  </h3>  <p>Retrieves the nth expression’s value from the history.</p> <p>Use negative values to look up expression values relative to the current one. For instance, v(-1) returns the result of the last evaluated expression.</p>     <h1 class=\"section-heading\" id=\"macros\">  Macros </h1>  <h3 class=\"detail-header macro\" id=\"b/1\">  <span class=\"signature\">b(term)</span>  </h3>  <p>Prints the documentation for the given callback function.</p> <p>It also accepts single module argument to list all available behaviour callbacks.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">b(Mix.Task.run/1)\nb(Mix.Task.run)\nb(Dict)</code></pre>    <h3 class=\"detail-header macro\" id=\"h/1\">  <span class=\"signature\">h(term)</span>  </h3>  <p>Prints the documentation for the given module or for the given function/arity pair.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">h(Enum)\n#=&gt; Prints documentation for Enum</code></pre> <p>It also accepts functions in the format <code class=\"inline\">fun/arity</code> and <code class=\"inline\">module.fun/arity</code>, for example:</p> <pre data-language=\"elixir\"><code class=\"elixir\">h receive/1\nh Enum.all?/2\nh Enum.all?</code></pre>    <h3 class=\"detail-header macro\" id=\"import_file/2\">  <span class=\"signature\">import_file(path, opts \\\\ [])</span>  </h3>  <p>Evaluates the contents of the file at <code class=\"inline\">path</code> as if it were directly typed into the shell.</p> <p><code class=\"inline\">path</code> has to be a literal string. <code class=\"inline\">path</code> is automatically expanded via <code class=\"inline\">Path.expand/1</code>.</p> <h4>Non-existent files</h4> <p>By default, <code class=\"inline\">import_file/1</code> fails when the given file does not exist. However, since this macro is expanded at compile-time, it’s not possible to conditionally import a file since the macro is always expanded:</p> <pre data-language=\"elixir\"><code class=\"elixir\"># This raises a File.Error if ~/.iex.exs doesn't exist.\nif (\"~/.iex.exs\" |&gt; Path.expand |&gt; File.exists?) do\n  import_file \"~/.iex.exs\"\nend</code></pre> <p>This is why an <code class=\"inline\">:optional</code> option can be passed to <code class=\"inline\">import_file/1</code>. The default value of this option is <code class=\"inline\">false</code>, meaning that an exception will be raised if the given file is missing. If <code class=\"inline\">:optional</code> is set to <code class=\"inline\">true</code>, missing files will be ignored and <code class=\"inline\">import_file/1</code> will just compile to <code class=\"inline\">nil</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># ~/file.exs\nvalue = 13\n\n# in the shell\niex(1)&gt; import_file \"~/file.exs\"\n13\niex(2)&gt; value\n13\niex(3)&gt; import_file \"nonexisting.file.ex\", optional: true\nnil</code></pre>    <h3 class=\"detail-header macro\" id=\"import_file_if_available/1\">  <span class=\"signature\">import_file_if_available(path)</span>  </h3>  <p>Similar to <code class=\"inline\">import_file</code> but only imports it if it is available.</p>    <h3 class=\"detail-header macro\" id=\"import_if_available/2\">  <span class=\"signature\">import_if_available(quoted_module, opts \\\\ [])</span>  </h3>  <p>Calls <code class=\"inline\">import/2</code> with the given arguments, but only if the module is available.</p> <p>This lets you put imports in <code class=\"inline\">.iex.exs</code> files (including <code class=\"inline\">~/.iex.exs</code>) without getting compile errors if you open a console where the module is not available.</p> <h4>Example</h4> <pre data-language=\"elixir\"><code class=\"elixir\"># In ~/.iex.exs\nimport_if_available Ecto.Query</code></pre>    <h3 class=\"detail-header macro\" id=\"s/1\">  <span class=\"signature\">s(term)</span>  </h3>  <p>Prints the specs for the given module or for the given function/arity pair.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">s(Enum)\ns(Enum.all?)\ns(Enum.all?/2)\ns(is_atom)\ns(is_atom/1)</code></pre>    <h3 class=\"detail-header macro\" id=\"t/1\">  <span class=\"signature\">t(term)</span>  </h3>  <p>Prints the types for the given module or for the given function/arity pair.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">t(Enum)\nt(Enum.t/0)\nt(Enum.t)</code></pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/iex/IEx.Helpers.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/iex/IEx.Helpers.html</a>\n  </p>\n</div>\n","mix/mix.project":"<h1>  Mix.Project  </h1>  <p>Defines and manipulate Mix projects.</p> <p>In order to configure Mix, a developer needs to use <a href=\"mix.project#content\"><code class=\"inline\">Mix.Project</code></a> in a module and define a function named <code class=\"inline\">project</code> that returns a keyword list with configuration.</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule MyApp do\n  use Mix.Project\n\n  def project do\n    [app: :my_app,\n     version: \"0.6.0\"]\n  end\nend</code></pre> <p>After being defined, the configuration for this project can be read as <a href=\"mix.project#config/0\"><code class=\"inline\">Mix.Project.config/0</code></a>. Notice that <a href=\"#config/0\"><code class=\"inline\">config/0</code></a> won’t fail if a project is not defined; this allows many Mix tasks to work without a project.</p> <p>In case the developer needs a project or wants to access a special function in the project, the developer can call <a href=\"mix.project#get!/0\"><code class=\"inline\">Mix.Project.get!/0</code></a> which fails with <a href=\"mix.noprojecterror\"><code class=\"inline\">Mix.NoProjectError</code></a> in case a project is not defined.</p> <h2 id=\"module-erlang-projects\" class=\"section-heading\">  Erlang projects </h2> <p>Mix can be used to manage Erlang projects that don’t have any Elixir code. To ensure Mix tasks work correctly for an Erlang project, <code class=\"inline\">language: :erlang</code> has to be added to <code class=\"inline\">project</code>.</p> <p>The setting also makes sure Elixir is not added as a dependency to the generated .app file or to the escript generated with <code class=\"inline\">mix escript.build</code>, etc.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#app_path/1\">app_path(config \\\\ config())</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the application path inside the build</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#build_path/1\">build_path(config \\\\ config())</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the build path for this project</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#build_structure/2\">build_structure(config \\\\ config(), opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Builds the project structure for the current application</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compile/2\">compile(args, config \\\\ config())</a> </dt> <dd class=\"summary-synopsis\">\n<p>Compiles the given project</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#compile_path/1\">compile_path(config \\\\ config())</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the paths this project compiles to</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#config/0\">config()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the project configuration</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#config_files/0\">config_files()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns a list of project configuration files for this project</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#consolidation_path/1\">consolidation_path(config \\\\ config())</a> </dt> <dd class=\"summary-synopsis\">\n<p>The path where protocol consolidations are stored</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#deps_path/1\">deps_path(config \\\\ config())</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the path to store dependencies for this project</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#deps_paths/0\">deps_paths()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the full path of all dependencies as a map</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#ensure_structure/2\">ensure_structure(config \\\\ config(), opts \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Ensures the project structure exists</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get/0\">get()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Retrieves the current project if there is one</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get!/0\">get!()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Same as <a href=\"#get/0\"><code class=\"inline\">get/0</code></a>, but raises an exception if there is no current project</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#in_project/4\">in_project(app, path, post_config \\\\ [], fun)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Runs the given <code class=\"inline\">fun</code> inside the given project</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#load_paths/1\">load_paths(config \\\\ config())</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all load paths for this project</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#manifest_path/1\">manifest_path(config \\\\ config())</a> </dt> <dd class=\"summary-synopsis\">\n<p>The path to store manifests</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#umbrella?/1\">umbrella?(config \\\\ config())</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if project is an umbrella project</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"app_path/1\">  <span class=\"signature\">app_path(config \\\\ config())</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">app_path(<a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: <a href=\"../elixir/path#t:t/0\">Path.t</a></code></pre>    <p>Returns the application path inside the build.</p> <p>The returned path will be expanded.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Mix.Project.app_path\n#=&gt; \"/path/to/project/_build/shared/lib/app\"</code></pre>    <h3 class=\"detail-header function\" id=\"build_path/1\">  <span class=\"signature\">build_path(config \\\\ config())</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">build_path(<a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: <a href=\"../elixir/path#t:t/0\">Path.t</a></code></pre>    <p>Returns the build path for this project.</p> <p>The returned path will be expanded.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Mix.Project.build_path\n#=&gt; \"/path/to/project/_build/shared\"</code></pre> <p>If :build_per_environment is set to <code class=\"inline\">true</code> (the default), it will create a new build per environment:</p> <pre data-language=\"elixir\"><code class=\"elixir\">Mix.env\n#=&gt; :dev\nMix.Project.build_path\n#=&gt; \"/path/to/project/_build/dev\"</code></pre>    <h3 class=\"detail-header function\" id=\"build_structure/2\">  <span class=\"signature\">build_structure(config \\\\ config(), opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">build_structure(<a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>, <a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: :ok</code></pre>    <p>Builds the project structure for the current application.</p> <h4>Options</h4> <ul> <li>\n<code class=\"inline\">:symlink_ebin</code> - symlink ebin instead of copying it </li> </ul>    <h3 class=\"detail-header function\" id=\"compile/2\">  <span class=\"signature\">compile(args, config \\\\ config())</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">compile([term], <a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: term</code></pre>    <p>Compiles the given project.</p> <p>It will run the compile task unless the project is in build embedded mode, which may fail as an explicit command to <code class=\"inline\">mix compile</code> is required.</p>    <h3 class=\"detail-header function\" id=\"compile_path/1\">  <span class=\"signature\">compile_path(config \\\\ config())</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">compile_path(<a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: <a href=\"../elixir/path#t:t/0\">Path.t</a></code></pre>    <p>Returns the paths this project compiles to.</p> <p>The returned path will be expanded.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Mix.Project.compile_path\n#=&gt; \"/path/to/project/_build/shared/lib/app/ebin\"</code></pre>    <h3 class=\"detail-header function\" id=\"config/0\">  <span class=\"signature\">config()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">config :: <a href=\"../elixir/keyword#t:t/0\">Keyword.t</a></code></pre>    <p>Returns the project configuration.</p> <p>If there is no project defined, it still returns a keyword list with default values. This allows many Mix tasks to work without the need for an underlying project.</p> <p>Note this configuration is cached once the project is pushed into the stack. Calling it multiple times won’t cause it to be recomputed.</p> <p>Do not use <a href=\"mix.project#config/0\"><code class=\"inline\">Mix.Project.config/0</code></a> to rely on runtime configuration. Use it only to configure aspects of your project (like compilation directories) and not your application runtime.</p>    <h3 class=\"detail-header function\" id=\"config_files/0\">  <span class=\"signature\">config_files()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">config_files :: [<a href=\"../elixir/path#t:t/0\">Path.t</a>]</code></pre>    <p>Returns a list of project configuration files for this project.</p> <p>This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change.</p> <p>By default it includes the mix.exs file, the lock manifest and all config files in the <code class=\"inline\">config</code> directory.</p>    <h3 class=\"detail-header function\" id=\"consolidation_path/1\">  <span class=\"signature\">consolidation_path(config \\\\ config())</span>  </h3>  <p>The path where protocol consolidations are stored.</p>    <h3 class=\"detail-header function\" id=\"deps_path/1\">  <span class=\"signature\">deps_path(config \\\\ config())</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">deps_path(<a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: <a href=\"../elixir/path#t:t/0\">Path.t</a></code></pre>    <p>Returns the path to store dependencies for this project.</p> <p>The returned path will be expanded.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Mix.Project.deps_path\n#=&gt; \"/path/to/project/deps\"</code></pre>    <h3 class=\"detail-header function\" id=\"deps_paths/0\">  <span class=\"signature\">deps_paths()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">deps_paths :: %{optional(atom) =&gt; <a href=\"../elixir/path#t:t/0\">Path.t</a>}</code></pre>    <p>Returns the full path of all dependencies as a map.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Mix.Project.deps_paths\n#=&gt; %{foo: \"deps/foo\", bar: \"custom/path/dep\"}</code></pre>    <h3 class=\"detail-header function\" id=\"ensure_structure/2\">  <span class=\"signature\">ensure_structure(config \\\\ config(), opts \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">ensure_structure(<a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>, <a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: :ok</code></pre>    <p>Ensures the project structure exists.</p> <p>In case it does exist, it is a no-op. Otherwise, it is built.</p>    <h3 class=\"detail-header function\" id=\"get/0\">  <span class=\"signature\">get()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get :: module | nil</code></pre>    <p>Retrieves the current project if there is one.</p> <p>Otherwise <code class=\"inline\">nil</code> is returned. It may happen in cases there is no mixfile in the current directory.</p> <p>If you expect a project to be defined, i.e. it is a requirement of the current task, you should call <a href=\"#get!/0\"><code class=\"inline\">get!/0</code></a> instead.</p>    <h3 class=\"detail-header function\" id=\"get!/0\">  <span class=\"signature\">get!()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get! :: module | no_return</code></pre>    <p>Same as <a href=\"#get/0\"><code class=\"inline\">get/0</code></a>, but raises an exception if there is no current project.</p> <p>This is usually called by tasks that need additional functions on the project to be defined. Since such tasks usually depend on a project being defined, this function raises <a href=\"mix.noprojecterror\"><code class=\"inline\">Mix.NoProjectError</code></a> in case no project is available.</p>    <h3 class=\"detail-header function\" id=\"in_project/4\">  <span class=\"signature\">in_project(app, path, post_config \\\\ [], fun)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">in_project(atom, <a href=\"../elixir/path#t:t/0\">Path.t</a>, <a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>, (module -&gt; result)) :: result when result: term</code></pre>    <p>Runs the given <code class=\"inline\">fun</code> inside the given project.</p> <p>This function changes the current working directory and loads the project at the given directory onto the project stack.</p> <p>A <code class=\"inline\">post_config</code> can be passed that will be merged into the project configuration.</p> <p><code class=\"inline\">fun</code> is called with the <code class=\"inline\">Mixfile</code> of the given project as its argument. The return value of this function is the return value of <code class=\"inline\">fun</code>.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Mix.Project.in_project :my_app, \"/path/to/my_app\", fn mixfile -&gt;\n  \"Mixfile is: #{inspect mixfile}\"\nend\n#=&gt; \"Mixfile is: MyApp.Mixfile\"</code></pre>    <h3 class=\"detail-header function\" id=\"load_paths/1\">  <span class=\"signature\">load_paths(config \\\\ config())</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">load_paths(<a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: [<a href=\"../elixir/path#t:t/0\">Path.t</a>]</code></pre>    <p>Returns all load paths for this project.</p>    <h3 class=\"detail-header function\" id=\"manifest_path/1\">  <span class=\"signature\">manifest_path(config \\\\ config())</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">manifest_path(<a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: <a href=\"../elixir/path#t:t/0\">Path.t</a></code></pre>    <p>The path to store manifests.</p> <p>By default they are stored in the app path inside the build directory. Umbrella applications have the manifest path set to the root of the build directory. Directories may be changed in future releases.</p> <p>The returned path will be expanded.</p> <h4>Examples</h4> <pre data-language=\"elixir\"><code class=\"elixir\">Mix.Project.manifest_path\n#=&gt; \"/path/to/project/_build/shared/lib/app\"</code></pre>    <h3 class=\"detail-header function\" id=\"umbrella?/1\">  <span class=\"signature\">umbrella?(config \\\\ config())</span>  </h3>  <p>Returns <code class=\"inline\">true</code> if project is an umbrella project.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/mix/Mix.Project.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/mix/Mix.Project.html</a>\n  </p>\n</div>\n","mix/mix.task":"<h1>  Mix.Task <small>behaviour</small>  </h1>  <p>A simple module that provides conveniences for creating, loading and manipulating tasks.</p> <p>A Mix task can be defined by simply using <a href=\"mix.task#content\"><code class=\"inline\">Mix.Task</code></a> in a module starting with <code class=\"inline\">Mix.Tasks.</code> and defining the <code class=\"inline\">run/1</code> function:</p> <pre data-language=\"elixir\"><code class=\"elixir\">defmodule Mix.Tasks.Hello do\n  use Mix.Task\n\n  def run(_args) do\n    Mix.shell.info \"hello\"\n  end\nend</code></pre> <p>The <code class=\"inline\">run/1</code> function will receive all arguments passed to the command line.</p> <h2 id=\"module-attributes\" class=\"section-heading\">  Attributes </h2> <p>There are a few attributes available in Mix tasks to configure them in Mix:</p> <ul> <li>\n<code class=\"inline\">@shortdoc</code> - makes the task public with a short description that appears on <code class=\"inline\">mix help</code> </li> <li>\n<code class=\"inline\">@recursive</code> - run the task recursively in umbrella projects </li> <li>\n<code class=\"inline\">@preferred_cli_env</code> - recommends environment to run task. It is used in absence of mix project recommendation, or explicit MIX_ENV. </li> </ul> <h2 id=\"module-documentation\" class=\"section-heading\">  Documentation </h2> <p>Users can read the documentation for public Mix tasks by doing <code class=\"inline\">mix help my_task</code>. The documentation that will be shown is the <code class=\"inline\">@moduledoc</code> of the task’s module.</p>   <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Types </h2>\n<dl class=\"summary-types summary\">   <dt class=\"summary-signature\"> <a href=\"#t:task_module/0\">task_module()</a> </dt>   <dt class=\"summary-signature\"> <a href=\"#t:task_name/0\">task_name()</a> </dt>  </dl> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#alias?/1\">alias?(task)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if an alias called <code class=\"inline\">task</code> exists</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#all_modules/0\">all_modules()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns all loaded task modules</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#clear/0\">clear()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Clears all invoked tasks, allowing them to be reinvoked</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get/1\">get(task)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a task name and returns the task module if found</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#get!/1\">get!(task)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Receives a task name and retrieves the task module</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#load_all/0\">load_all()</a> </dt> <dd class=\"summary-synopsis\">\n<p>Loads all tasks in all code paths</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#load_tasks/1\">load_tasks(dirs)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Loads all tasks in the given <code class=\"inline\">paths</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#moduledoc/1\">moduledoc(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the moduledoc for the given task <code class=\"inline\">module</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#preferred_cli_env/1\">preferred_cli_env(task)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets preferred cli environment for the task</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#recursive/1\">recursive(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Checks if the task should be run recursively for all sub-apps in umbrella projects</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#reenable/1\">reenable(task)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reenables a given task so it can be executed again down the stack</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#rerun/2\">rerun(task, args \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Reruns <code class=\"inline\">task</code> with the given arguments</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#run/2\">run(task, args \\\\ [])</a> </dt> <dd class=\"summary-synopsis\">\n<p>Runs a <code class=\"inline\">task</code> with the given <code class=\"inline\">args</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#shortdoc/1\">shortdoc(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Gets the shortdoc for the given task <code class=\"inline\">module</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#task?/1\">task?(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns <code class=\"inline\">true</code> if given module is a task</p> </dd>   <dt class=\"summary-signature\"> <a href=\"#task_name/1\">task_name(module)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Returns the task name for the given <code class=\"inline\">module</code></p> </dd>  </dl> <h2> Callbacks </h2>\n<dl class=\"summary-callbacks summary\">   <dt class=\"summary-signature\"> <a href=\"#c:run/1\">run(list)</a> </dt> <dd class=\"summary-synopsis\">\n<p>A task needs to implement <code class=\"inline\">run</code> which receives a list of command line args</p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"types\">  Types </h1>  <div id=\"t:task_module/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:task_module/0\">task_module</a> :: atom</code></pre> </div> <div id=\"t:task_name/0\" class=\"type-detail\"> <pre data-language=\"elixir\"><code class=\"elixir\"><a href=\"#t:task_name/0\">task_name</a> :: <a href=\"../elixir/string#t:t/0\">String.t</a> | atom</code></pre> </div>    <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"alias?/1\">  <span class=\"signature\">alias?(task)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">alias?(<a href=\"#t:task_name/0\">task_name</a>) :: boolean</code></pre>    <p>Checks if an alias called <code class=\"inline\">task</code> exists.</p> <p>For more information about task aliasing, take a look at the “Aliasing” section in the docs for <a href=\"mix\"><code class=\"inline\">Mix</code></a>.</p>    <h3 class=\"detail-header function\" id=\"all_modules/0\">  <span class=\"signature\">all_modules()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">all_modules :: [<a href=\"#t:task_module/0\">task_module</a>]</code></pre>    <p>Returns all loaded task modules.</p> <p>Modules that are not yet loaded won’t show up. Check <a href=\"#load_all/0\"><code class=\"inline\">load_all/0</code></a> if you want to preload all tasks.</p>    <h3 class=\"detail-header function\" id=\"clear/0\">  <span class=\"signature\">clear()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">clear :: :ok</code></pre>    <p>Clears all invoked tasks, allowing them to be reinvoked.</p> <p>This operation is not recursive.</p>    <h3 class=\"detail-header function\" id=\"get/1\">  <span class=\"signature\">get(task)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get(<a href=\"#t:task_name/0\">task_name</a>) :: <a href=\"#t:task_module/0\">task_module</a> | nil</code></pre>    <p>Receives a task name and returns the task module if found.</p> <p>Otherwise returns <code class=\"inline\">nil</code> in case the module exists but it isn’t a task or cannot be found.</p>    <h3 class=\"detail-header function\" id=\"get!/1\">  <span class=\"signature\">get!(task)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">get!(<a href=\"#t:task_name/0\">task_name</a>) :: <a href=\"#t:task_module/0\">task_module</a> | no_return</code></pre>    <p>Receives a task name and retrieves the task module.</p> <h4>Exceptions</h4> <ul> <li>\n<a href=\"mix.notaskerror\"><code class=\"inline\">Mix.NoTaskError</code></a> - raised if the task could not be found </li> <li>\n<a href=\"mix.invalidtaskerror\"><code class=\"inline\">Mix.InvalidTaskError</code></a> - raised if the task is not a valid <a href=\"mix.task#content\"><code class=\"inline\">Mix.Task</code></a> </li> </ul>    <h3 class=\"detail-header function\" id=\"load_all/0\">  <span class=\"signature\">load_all()</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">load_all :: [<a href=\"#t:task_module/0\">task_module</a>]</code></pre>    <p>Loads all tasks in all code paths.</p>    <h3 class=\"detail-header function\" id=\"load_tasks/1\">  <span class=\"signature\">load_tasks(dirs)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">load_tasks([<a href=\"../elixir/list.chars#t:t/0\">List.Chars.t</a>]) :: [<a href=\"#t:task_module/0\">task_module</a>]</code></pre>    <p>Loads all tasks in the given <code class=\"inline\">paths</code>.</p>    <h3 class=\"detail-header function\" id=\"moduledoc/1\">  <span class=\"signature\">moduledoc(module)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">moduledoc(<a href=\"#t:task_module/0\">task_module</a>) :: <a href=\"../elixir/string#t:t/0\">String.t</a> | nil</code></pre>    <p>Gets the moduledoc for the given task <code class=\"inline\">module</code>.</p> <p>Returns the moduledoc or <code class=\"inline\">nil</code>.</p>    <h3 class=\"detail-header function\" id=\"preferred_cli_env/1\">  <span class=\"signature\">preferred_cli_env(task)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">preferred_cli_env(<a href=\"#t:task_name/0\">task_name</a>) :: atom | nil</code></pre>    <p>Gets preferred cli environment for the task.</p> <p>Returns environment (for example, <code class=\"inline\">:test</code>, or <code class=\"inline\">:prod</code>), or <code class=\"inline\">nil</code>.</p>    <h3 class=\"detail-header function\" id=\"recursive/1\">  <span class=\"signature\">recursive(module)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">recursive(<a href=\"#t:task_module/0\">task_module</a>) :: boolean</code></pre>    <p>Checks if the task should be run recursively for all sub-apps in umbrella projects.</p> <p>Returns <code class=\"inline\">true</code> or <code class=\"inline\">false</code>.</p>    <h3 class=\"detail-header function\" id=\"reenable/1\">  <span class=\"signature\">reenable(task)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">reenable(<a href=\"#t:task_name/0\">task_name</a>) :: :ok</code></pre>    <p>Reenables a given task so it can be executed again down the stack.</p> <p>Both alias and the regular stack are reenabled when this function is called.</p> <p>If an umbrella project reenables a task, it is reenabled for all children projects.</p>    <h3 class=\"detail-header function\" id=\"rerun/2\">  <span class=\"signature\">rerun(task, args \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">rerun(<a href=\"#t:task_name/0\">task_name</a>, [any]) :: any</code></pre>    <p>Reruns <code class=\"inline\">task</code> with the given arguments.</p> <p>This function reruns the given task; to do that, it first re-enables the task and then regularly runs it.</p>    <h3 class=\"detail-header function\" id=\"run/2\">  <span class=\"signature\">run(task, args \\\\ [])</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">run(<a href=\"#t:task_name/0\">task_name</a>, [any]) :: any</code></pre>    <p>Runs a <code class=\"inline\">task</code> with the given <code class=\"inline\">args</code>.</p> <p>If the task was not yet invoked, it runs the task and returns the result.</p> <p>If there is an alias with the same name, the alias will be invoked instead of a task.</p> <p>If the task or alias were already invoked, it does not run them again and simply aborts with <code class=\"inline\">:noop</code>.</p> <p>It may raise an exception if an alias or a task can’t be found or the task is invalid. Check <a href=\"#get!/1\"><code class=\"inline\">get!/1</code></a> for more information.</p>    <h3 class=\"detail-header function\" id=\"shortdoc/1\">  <span class=\"signature\">shortdoc(module)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">shortdoc(<a href=\"#t:task_module/0\">task_module</a>) :: <a href=\"../elixir/string#t:t/0\">String.t</a> | nil</code></pre>    <p>Gets the shortdoc for the given task <code class=\"inline\">module</code>.</p> <p>Returns the shortdoc or <code class=\"inline\">nil</code>.</p>    <h3 class=\"detail-header function\" id=\"task?/1\">  <span class=\"signature\">task?(module)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">task?(<a href=\"#t:task_module/0\">task_module</a>) :: boolean</code></pre>    <p>Returns <code class=\"inline\">true</code> if given module is a task.</p>    <h3 class=\"detail-header function\" id=\"task_name/1\">  <span class=\"signature\">task_name(module)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">task_name(<a href=\"#t:task_module/0\">task_module</a>) :: <a href=\"#t:task_name/0\">task_name</a></code></pre>    <p>Returns the task name for the given <code class=\"inline\">module</code>.</p>     <h1 class=\"section-heading\" id=\"callbacks\">  Callbacks </h1>  <h3 class=\"detail-header callback\" id=\"c:run/1\">  <span class=\"signature\">run(list)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">run([binary]) :: any</code></pre>    <p>A task needs to implement <code class=\"inline\">run</code> which receives a list of command line args.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/mix/Mix.Task.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/mix/Mix.Task.html</a>\n  </p>\n</div>\n","mix/mix.noprojecterror":"<h1>  Mix.NoProjectError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"../elixir/string#t:t/0\">String.t</a>) :: <a href=\"../elixir/exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: <a href=\"../elixir/exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"../elixir/exception#t:t/0\">Exception.t</a>) :: <a href=\"../elixir/string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/mix/Mix.NoProjectError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/mix/Mix.NoProjectError.html</a>\n  </p>\n</div>\n","mix/mix.notaskerror":"<h1>  Mix.NoTaskError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"../elixir/string#t:t/0\">String.t</a>) :: <a href=\"../elixir/exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: <a href=\"../elixir/exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"../elixir/exception#t:t/0\">Exception.t</a>) :: <a href=\"../elixir/string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/mix/Mix.NoTaskError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/mix/Mix.NoTaskError.html</a>\n  </p>\n</div>\n","mix/mix.invalidtaskerror":"<h1>  Mix.InvalidTaskError <small>exception</small>  </h1>  <h1 class=\"section-heading\" id=\"summary\">  Summary </h1> <h2> Functions </h2>\n<dl class=\"summary-functions summary\">   <dt class=\"summary-signature\"> <a href=\"#exception/1\">exception(msg)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code></p> </dd>   <dt class=\"summary-signature\"> <a href=\"#message/1\">message(exception)</a> </dt> <dd class=\"summary-synopsis\">\n<p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code></p> </dd>  </dl>   <h1 class=\"section-heading\" id=\"functions\">  Functions </h1>  <h3 class=\"detail-header function\" id=\"exception/1\">  <span class=\"signature\">exception(msg)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"../elixir/string#t:t/0\">String.t</a>) :: <a href=\"../elixir/exception#t:t/0\">Exception.t</a></code></pre> <pre data-language=\"elixir\"><code class=\"elixir\">exception(<a href=\"../elixir/keyword#t:t/0\">Keyword.t</a>) :: <a href=\"../elixir/exception#t:t/0\">Exception.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.exception/1</code>.</p>    <h3 class=\"detail-header function\" id=\"message/1\">  <span class=\"signature\">message(exception)</span>  </h3>  <h4 class=\"specs-title\">Specs</h4>  <pre data-language=\"elixir\"><code class=\"elixir\">message(<a href=\"../elixir/exception#t:t/0\">Exception.t</a>) :: <a href=\"../elixir/string#t:t/0\">String.t</a></code></pre>    <p>Callback implementation for <code class=\"inline\">c:Exception.message/1</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012&ndash;2016 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"http://elixir-lang.org/docs/stable/mix/Mix.InvalidTaskError.html\" class=\"_attribution-link\">http://elixir-lang.org/docs/stable/mix/Mix.InvalidTaskError.html</a>\n  </p>\n</div>\n"}