{"index":"<h1>Go Programming Language</h1>    <ul id=\"manual-nav\">\n<li><a href=\"#subrepo\">Sub-repositories</a></li>\n<li><a href=\"#community\">Community</a></li>\n</ul> <h2 id=\"stdlib\">Standard library</h2> <img class=\"gopher\" src=\"https://golang.org/doc/gopher/pkg.png\"> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th>  </tr>  <tr> <td class=\"pkg-name\"> <a href=\"archive/tar/index\">tar</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"archive/zip/index\">zip</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"bufio/index\">bufio</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"builtin/index\">builtin</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"bytes/index\">bytes</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"compress/index\">compress</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"compress/bzip2/index\">bzip2</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"compress/flate/index\">flate</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"compress/gzip/index\">gzip</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"compress/lzw/index\">lzw</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"compress/zlib/index\">zlib</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"container/index\">container</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"container/heap/index\">heap</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"container/list/index\">list</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"container/ring/index\">ring</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"context/index\">context</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/index\">crypto</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/aes/index\">aes</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/cipher/index\">cipher</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/des/index\">des</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/dsa/index\">dsa</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/ecdsa/index\">ecdsa</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/elliptic/index\">elliptic</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/hmac/index\">hmac</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/md5/index\">md5</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/rand/index\">rand</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/rc4/index\">rc4</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/rsa/index\">rsa</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/sha1/index\">sha1</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/sha256/index\">sha256</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/sha512/index\">sha512</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/subtle/index\">subtle</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/tls/index\">tls</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/x509/index\">x509</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"crypto/x509/pkix/index\">pkix</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"database/index\">database</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"database/sql/index\">sql</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"database/sql/driver/index\">driver</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"debug/index\">debug</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"debug/dwarf/index\">dwarf</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"debug/elf/index\">elf</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"debug/gosym/index\">gosym</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"debug/macho/index\">macho</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"debug/pe/index\">pe</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"debug/plan9obj/index\">plan9obj</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"encoding/index\">encoding</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"encoding/ascii85/index\">ascii85</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"encoding/asn1/index\">asn1</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"encoding/base32/index\">base32</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"encoding/base64/index\">base64</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"encoding/binary/index\">binary</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"encoding/csv/index\">csv</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"encoding/gob/index\">gob</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"encoding/hex/index\">hex</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"encoding/json/index\">json</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"encoding/pem/index\">pem</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"encoding/xml/index\">xml</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"errors/index\">errors</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"expvar/index\">expvar</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"flag/index\">flag</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"fmt/index\">fmt</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"go/index\">go</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"go/ast/index\">ast</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"go/build/index\">build</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"go/constant/index\">constant</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"go/doc/index\">doc</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"go/format/index\">format</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"go/importer/index\">importer</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"go/parser/index\">parser</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"go/printer/index\">printer</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"go/scanner/index\">scanner</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"go/token/index\">token</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"go/types/index\">types</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"hash/index\">hash</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"hash/adler32/index\">adler32</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"hash/crc32/index\">crc32</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"hash/crc64/index\">crc64</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"hash/fnv/index\">fnv</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"html/index\">html</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"html/template/index\">template</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"image/index\">image</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"image/color/index\">color</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"image/color/palette/index\">palette</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"image/draw/index\">draw</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"image/gif/index\">gif</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"image/jpeg/index\">jpeg</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"image/png/index\">png</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"index/index\">index</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"index/suffixarray/index\">suffixarray</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"io/index\">io</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"io/ioutil/index\">ioutil</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"log/index\">log</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"log/syslog/index\">syslog</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"math/index\">math</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"math/big/index\">big</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"math/cmplx/index\">cmplx</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"math/rand/index\">rand</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"mime/index\">mime</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"mime/multipart/index\">multipart</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"mime/quotedprintable/index\">quotedprintable</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/index\">net</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/http/index\">http</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/http/cgi/index\">cgi</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/http/cookiejar/index\">cookiejar</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/http/fcgi/index\">fcgi</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/http/httptest/index\">httptest</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/http/httptrace/index\">httptrace</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/http/httputil/index\">httputil</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/http/pprof/index\">pprof</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/mail/index\">mail</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/rpc/index\">rpc</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/rpc/jsonrpc/index\">jsonrpc</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/smtp/index\">smtp</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/textproto/index\">textproto</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"net/url/index\">url</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"os/index\">os</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"os/exec/index\">exec</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"os/signal/index\">signal</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"os/user/index\">user</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"path/index\">path</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"path/filepath/index\">filepath</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"reflect/index\">reflect</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"regexp/index\">regexp</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"regexp/syntax/index\">syntax</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"runtime/index\">runtime</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"runtime/cgo/index\">cgo</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"runtime/debug/index\">debug</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"runtime/msan/index\">msan</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"runtime/pprof/index\">pprof</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"runtime/race/index\">race</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"runtime/trace/index\">trace</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"sort/index\">sort</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"strconv/index\">strconv</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"strings/index\">strings</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"sync/index\">sync</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"sync/atomic/index\">atomic</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"syscall/index\">syscall</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"testing/index\">testing</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"testing/iotest/index\">iotest</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"testing/quick/index\">quick</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"text/index\">text</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"text/scanner/index\">scanner</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"text/tabwriter/index\">tabwriter</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"text/template/index\">template</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"text/template/parse/index\">parse</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"time/index\">time</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"unicode/index\">unicode</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"unicode/utf16/index\">utf16</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"unicode/utf8/index\">utf8</a> </td>  </tr> <tr> <td class=\"pkg-name\"> <a href=\"unsafe/index\">unsafe</a> </td>  </tr> </table> </div> <h2 id=\"other\">Other packages</h2> <h3 id=\"subrepo\">Sub-repositories</h3> <p> These packages are part of the Go Project but outside the main Go tree. They are developed under looser <a href=\"https://golang.org/doc/go1compat\">compatibility requirements</a> than the Go core. Install them with \"<a href=\"https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies\">go get</a>\". </p> <ul> <li>\n<a href=\"https://godoc.org/golang.org/x/benchmarks\">benchmarks</a> — benchmarks to measure Go as it is developed.</li> <li>\n<a href=\"https://godoc.org/golang.org/x/blog\">blog</a> — <a href=\"https://blog.golang.org\">blog.golang.org</a>'s implementation.</li> <li>\n<a href=\"https://godoc.org/golang.org/x/build\">build</a> — <a href=\"https://build.golang.org\">build.golang.org</a>'s implementation.</li> <li>\n<a href=\"https://godoc.org/golang.org/x/crypto\">crypto</a> — additional cryptography packages.</li> <li>\n<a href=\"https://godoc.org/golang.org/x/debug\">debug</a> — an experimental debugger for Go.</li> <li>\n<a href=\"https://godoc.org/golang.org/x/image\">image</a> — additional imaging packages.</li> <li>\n<a href=\"https://godoc.org/golang.org/x/mobile\">mobile</a> — experimental support for Go on mobile platforms.</li> <li>\n<a href=\"https://godoc.org/golang.org/x/net\">net</a> — additional networking packages.</li> <li>\n<a href=\"https://godoc.org/golang.org/x/sys\">sys</a> — packages for making system calls.</li> <li>\n<a href=\"https://godoc.org/golang.org/x/text\">text</a> — packages for working with text.</li> <li>\n<a href=\"https://godoc.org/golang.org/x/tools\">tools</a> — godoc, goimports, gorename, and other tools.</li> <li>\n<a href=\"https://godoc.org/golang.org/x/tour\">tour</a> — <a href=\"https://tour.golang.org\">tour.golang.org</a>'s implementation.</li> <li>\n<a href=\"https://godoc.org/golang.org/x/exp\">exp</a> — experimental and deprecated packages (handle with care; may change without warning).</li> </ul> <h3 id=\"community\">Community</h3> <p> These services can help you find Open Source packages provided by the community. </p> <ul> <li>\n<a href=\"https://godoc.org\">GoDoc</a> - a package index and search engine.</li> <li>\n<a href=\"http://go-search.org\">Go Search</a> - a code search engine.</li> <li>\n<a href=\"https://golang.org/wiki/Projects\">Projects at the Go Wiki</a> - a curated list of Go projects.</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg//\" class=\"_attribution-link\">https://golang.org/pkg//</a>\n  </p>\n</div>\n","archive/index":"<h1>Directory /src/archive</h1>    <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"tar/index\">tar</a> </td> <td class=\"pkg-synopsis\"> Package tar implements access to tar archives. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"zip/index\">zip</a> </td> <td class=\"pkg-synopsis\"> Package zip provides support for reading and writing ZIP archives. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/archive/\" class=\"_attribution-link\">https://golang.org/pkg/archive/</a>\n  </p>\n</div>\n","crypto/des/index":"<h1>Package des</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/des\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package des implements the Data Encryption Standard (DES) and the Triple Data Encryption Algorithm (TDEA) as defined in U.S. Federal Information Processing Standards Publication 46-3. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#NewCipher\">func NewCipher(key []byte) (cipher.Block, error)</a></li>\n<li><a href=\"#NewTripleDESCipher\">func NewTripleDESCipher(key []byte) (cipher.Block, error)</a></li>\n<li><a href=\"#KeySizeError\">type KeySizeError</a></li>\n<li> <a href=\"#KeySizeError.Error\">func (k KeySizeError) Error() string</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_NewTripleDESCipher\">NewTripleDESCipher</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/des/block.go\">block.go</a> <a href=\"https://golang.org/src/crypto/des/cipher.go\">cipher.go</a> <a href=\"https://golang.org/src/crypto/des/const.go\">const.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const BlockSize = 8</pre> <p> The DES block size in bytes. </p> <h2 id=\"NewCipher\">func NewCipher  </h2> <pre data-language=\"go\">func NewCipher(key []byte) (cipher.Block, error)</pre> <p> NewCipher creates and returns a new cipher.Block. </p> <h2 id=\"NewTripleDESCipher\">func NewTripleDESCipher  </h2> <pre data-language=\"go\">func NewTripleDESCipher(key []byte) (cipher.Block, error)</pre> <p> NewTripleDESCipher creates and returns a new cipher.Block. </p> <div id=\"example_NewTripleDESCipher\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/des\"\n)\n\nfunc main() {\n\t// NewTripleDESCipher can also be used when EDE2 is required by\n\t// duplicating the first 8 bytes of the 16-byte key.\n\tede2Key := []byte(\"example key 1234\")\n\n\tvar tripleDESKey []byte\n\ttripleDESKey = append(tripleDESKey, ede2Key[:16]...)\n\ttripleDESKey = append(tripleDESKey, ede2Key[:8]...)\n\n\t_, err := des.NewTripleDESCipher(tripleDESKey)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// See crypto/cipher for how to use a cipher.Block for encryption and\n\t// decryption.\n}\n</pre> </div> </div> <h2 id=\"KeySizeError\">type KeySizeError  </h2> <pre data-language=\"go\">type KeySizeError int</pre> <h3 id=\"KeySizeError.Error\">func (KeySizeError) <a href=\"https://golang.org/src/crypto/des/cipher.go?s=289:325#L7\">Error</a>  </h3> <pre data-language=\"go\">func (k KeySizeError) Error() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/des/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/des/</a>\n  </p>\n</div>\n","compress/index":"<h1>Directory /src/compress</h1>    <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"bzip2/index\">bzip2</a> </td> <td class=\"pkg-synopsis\"> Package bzip2 implements bzip2 decompression. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"flate/index\">flate</a> </td> <td class=\"pkg-synopsis\"> Package flate implements the DEFLATE compressed data format, described in RFC 1951. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"gzip/index\">gzip</a> </td> <td class=\"pkg-synopsis\"> Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"lzw/index\">lzw</a> </td> <td class=\"pkg-synopsis\"> Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, ``A Technique for High-Performance Data Compression'', Computer, 17(6) (June 1984), pp 8-19. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"zlib/index\">zlib</a> </td> <td class=\"pkg-synopsis\"> Package zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/compress/\" class=\"_attribution-link\">https://golang.org/pkg/compress/</a>\n  </p>\n</div>\n","container/index":"<h1>Directory /src/container</h1>    <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"heap/index\">heap</a> </td> <td class=\"pkg-synopsis\"> Package heap provides heap operations for any type that implements heap.Interface. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"list/index\">list</a> </td> <td class=\"pkg-synopsis\"> Package list implements a doubly linked list. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"ring/index\">ring</a> </td> <td class=\"pkg-synopsis\"> Package ring implements operations on circular lists. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/container/\" class=\"_attribution-link\">https://golang.org/pkg/container/</a>\n  </p>\n</div>\n","archive/tar/index":"<h1>Package tar</h1>     <ul id=\"short-nav\">\n<li><code>import \"archive/tar\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package tar implements access to tar archives. It aims to cover most of the variations, including those produced by GNU and BSD tars. </p> <p> References: </p> <pre data-language=\"go\">http://www.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=5\nhttp://www.gnu.org/software/tar/manual/html_node/Standard.html\nhttp://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html\n</pre> </div> </div> <div id=\"example_\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Create a buffer to write our archive to.\n\tbuf := new(bytes.Buffer)\n\n\t// Create a new tar archive.\n\ttw := tar.NewWriter(buf)\n\n\t// Add some files to the archive.\n\tvar files = []struct {\n\t\tName, Body string\n\t}{\n\t\t{\"readme.txt\", \"This archive contains some text files.\"},\n\t\t{\"gopher.txt\", \"Gopher names:\\nGeorge\\nGeoffrey\\nGonzo\"},\n\t\t{\"todo.txt\", \"Get animal handling license.\"},\n\t}\n\tfor _, file := range files {\n\t\thdr := &amp;tar.Header{\n\t\t\tName: file.Name,\n\t\t\tMode: 0600,\n\t\t\tSize: int64(len(file.Body)),\n\t\t}\n\t\tif err := tw.WriteHeader(hdr); err != nil {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tif _, err := tw.Write([]byte(file.Body)); err != nil {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t}\n\t// Make sure to check the error on Close.\n\tif err := tw.Close(); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\t// Open the tar archive for reading.\n\tr := bytes.NewReader(buf.Bytes())\n\ttr := tar.NewReader(r)\n\n\t// Iterate through the files in the archive.\n\tfor {\n\t\thdr, err := tr.Next()\n\t\tif err == io.EOF {\n\t\t\t// end of tar archive\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tfmt.Printf(\"Contents of %s:\\n\", hdr.Name)\n\t\tif _, err := io.Copy(os.Stdout, tr); err != nil {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tfmt.Println()\n\t}\n\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Header\">type Header</a></li>\n<li> <a href=\"#FileInfoHeader\">func FileInfoHeader(fi os.FileInfo, link string) (*Header, error)</a>\n</li>\n<li> <a href=\"#Header.FileInfo\">func (h *Header) FileInfo() os.FileInfo</a>\n</li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li> <a href=\"#NewReader\">func NewReader(r io.Reader) *Reader</a>\n</li>\n<li> <a href=\"#Reader.Next\">func (tr *Reader) Next() (*Header, error)</a>\n</li>\n<li> <a href=\"#Reader.Read\">func (tr *Reader) Read(b []byte) (n int, err error)</a>\n</li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#NewWriter\">func NewWriter(w io.Writer) *Writer</a>\n</li>\n<li> <a href=\"#Writer.Close\">func (tw *Writer) Close() error</a>\n</li>\n<li> <a href=\"#Writer.Flush\">func (tw *Writer) Flush() error</a>\n</li>\n<li> <a href=\"#Writer.Write\">func (tw *Writer) Write(b []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#Writer.WriteHeader\">func (tw *Writer) WriteHeader(hdr *Header) error</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_\">Package</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/archive/tar/common.go\">common.go</a> <a href=\"https://golang.org/src/archive/tar/format.go\">format.go</a> <a href=\"https://golang.org/src/archive/tar/reader.go\">reader.go</a> <a href=\"https://golang.org/src/archive/tar/stat_atim.go\">stat_atim.go</a> <a href=\"https://golang.org/src/archive/tar/stat_unix.go\">stat_unix.go</a> <a href=\"https://golang.org/src/archive/tar/writer.go\">writer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        TypeReg           = '0'    // regular file\n        TypeRegA          = '\\x00' // regular file\n        TypeLink          = '1'    // hard link\n        TypeSymlink       = '2'    // symbolic link\n        TypeChar          = '3'    // character device node\n        TypeBlock         = '4'    // block device node\n        TypeDir           = '5'    // directory\n        TypeFifo          = '6'    // fifo node\n        TypeCont          = '7'    // reserved\n        TypeXHeader       = 'x'    // extended header\n        TypeXGlobalHeader = 'g'    // global extended header\n        TypeGNULongName   = 'L'    // Next file has a long name\n        TypeGNULongLink   = 'K'    // Next file symlinks to a file w/ a long name\n        TypeGNUSparse     = 'S'    // sparse file\n)</pre> <p> Header type flags. </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        ErrWriteTooLong    = errors.New(\"archive/tar: write too long\")\n        ErrFieldTooLong    = errors.New(\"archive/tar: header field too long\")\n        ErrWriteAfterClose = errors.New(\"archive/tar: write after close\")\n)</pre> <pre data-language=\"go\">var (\n        ErrHeader = errors.New(\"archive/tar: invalid tar header\")\n)</pre> <h2 id=\"Header\">type Header  </h2> <pre data-language=\"go\">type Header struct {\n        Name       string    // name of header file entry\n        Mode       int64     // permission and mode bits\n        Uid        int       // user id of owner\n        Gid        int       // group id of owner\n        Size       int64     // length in bytes\n        ModTime    time.Time // modified time\n        Typeflag   byte      // type of header entry\n        Linkname   string    // target name of link\n        Uname      string    // user name of owner\n        Gname      string    // group name of owner\n        Devmajor   int64     // major number of character or block device\n        Devminor   int64     // minor number of character or block device\n        AccessTime time.Time // access time\n        ChangeTime time.Time // status change time\n        Xattrs     map[string]string\n}</pre> <p> A Header represents a single header in a tar archive. Some fields may not be populated. </p> <h3 id=\"FileInfoHeader\">func <a href=\"https://golang.org/src/archive/tar/common.go?s=5495:5560#L186\">FileInfoHeader</a>  </h3> <pre data-language=\"go\">func FileInfoHeader(fi os.FileInfo, link string) (*Header, error)</pre> <p> FileInfoHeader creates a partially-populated Header from fi. If fi describes a symlink, FileInfoHeader records link as the link target. If fi describes a directory, a slash is appended to the name. Because os.FileInfo's Name method returns only the base name of the file it describes, it may be necessary to modify the Name field of the returned header to provide the full path name of the file. </p> <h3 id=\"Header.FileInfo\">func (*Header) <a href=\"https://golang.org/src/archive/tar/common.go?s=2161:2200#L53\">FileInfo</a>  </h3> <pre data-language=\"go\">func (h *Header) FileInfo() os.FileInfo</pre> <p> FileInfo returns an os.FileInfo for the Header. </p> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Reader provides sequential access to the contents of a tar archive. A tar archive consists of a sequence of files. The Next method advances to the next file in the archive (including the first), and then it can be treated as an io.Reader to access the file's data. </p> <h3 id=\"NewReader\">func <a href=\"https://golang.org/src/archive/tar/reader.go?s=3187:3222#L92\">NewReader</a>  </h3> <pre data-language=\"go\">func NewReader(r io.Reader) *Reader</pre> <p> NewReader creates a new Reader reading from r. </p> <h3 id=\"Reader.Next\">func (*Reader) <a href=\"https://golang.org/src/archive/tar/reader.go?s=3354:3395#L97\">Next</a>  </h3> <pre data-language=\"go\">func (tr *Reader) Next() (*Header, error)</pre> <p> Next advances to the next entry in the tar archive. </p> <p> io.EOF is returned at the end of the input. </p> <h3 id=\"Reader.Read\">func (*Reader) <a href=\"https://golang.org/src/archive/tar/reader.go?s=24320:24371#L810\">Read</a>  </h3> <pre data-language=\"go\">func (tr *Reader) Read(b []byte) (n int, err error)</pre> <p> Read reads from the current entry in the tar archive. It returns 0, io.EOF when it reaches the end of that entry, until Next is called to advance to the next entry. </p> <p> Calling Read on special types like TypeLink, TypeSymLink, TypeChar, TypeBlock, TypeDir, and TypeFifo returns 0, io.EOF regardless of what the Header.Size claims. </p> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Writer provides sequential writing of a tar archive in POSIX.1 format. A tar archive consists of a sequence of files. Call WriteHeader to begin a new file, and then call Write to supply that file's data, writing at most hdr.Size bytes in total. </p> <h3 id=\"NewWriter\">func <a href=\"https://golang.org/src/archive/tar/writer.go?s=1525:1560#L40\">NewWriter</a>  </h3> <pre data-language=\"go\">func NewWriter(w io.Writer) *Writer</pre> <p> NewWriter creates a new Writer writing to w. </p> <h3 id=\"Writer.Close\">func (*Writer) <a href=\"https://golang.org/src/archive/tar/writer.go?s=11037:11068#L374\">Close</a>  </h3> <pre data-language=\"go\">func (tw *Writer) Close() error</pre> <p> Close closes the tar archive, flushing any unwritten data to the underlying writer. </p> <h3 id=\"Writer.Flush\">func (*Writer) <a href=\"https://golang.org/src/archive/tar/writer.go?s=1642:1673#L43\">Flush</a>  </h3> <pre data-language=\"go\">func (tw *Writer) Flush() error</pre> <p> Flush finishes writing the current file (optional). </p> <h3 id=\"Writer.Write\">func (*Writer) <a href=\"https://golang.org/src/archive/tar/writer.go?s=10616:10668#L352\">Write</a>  </h3> <pre data-language=\"go\">func (tw *Writer) Write(b []byte) (n int, err error)</pre> <p> Write writes to the current entry in the tar archive. Write returns the error ErrWriteTooLong if more than hdr.Size bytes are written after WriteHeader. </p> <h3 id=\"Writer.WriteHeader\">func (*Writer) <a href=\"https://golang.org/src/archive/tar/writer.go?s=3817:3865#L123\">WriteHeader</a>  </h3> <pre data-language=\"go\">func (tw *Writer) WriteHeader(hdr *Header) error</pre> <p> WriteHeader writes hdr and prepares to accept the file's contents. WriteHeader calls Flush if it is not the first header. Calling after a Close will return ErrWriteAfterClose. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/archive/tar/\" class=\"_attribution-link\">https://golang.org/pkg/archive/tar/</a>\n  </p>\n</div>\n","container/heap/index":"<h1>Package heap</h1>     <ul id=\"short-nav\">\n<li><code>import \"container/heap\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree. </p> <p> The minimum element in the tree is the root, at index 0. </p> <p> A heap is a common way to implement a priority queue. To build a priority queue, implement the Heap interface with the (negative) priority as the ordering for the Less method, so Push adds items while Pop removes the highest-priority item from the queue. The Examples include such an implementation; the file example_pq_test.go has the complete source. </p> </div> </div> <div id=\"example__intHeap\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (IntHeap)</h2> <p>This example inserts several ints into an IntHeap, checks the minimum, and removes them in order of priority. </p> <pre class=\"play\">// This example demonstrates an integer heap built using the heap interface.\npackage main\n\nimport (\n\t\"container/heap\"\n\t\"fmt\"\n)\n\n// An IntHeap is a min-heap of ints.\ntype IntHeap []int\n\nfunc (h IntHeap) Len() int           { return len(h) }\nfunc (h IntHeap) Less(i, j int) bool { return h[i] &lt; h[j] }\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *IntHeap) Push(x interface{}) {\n\t// Push and Pop use pointer receivers because they modify the slice's length,\n\t// not just its contents.\n\t*h = append(*h, x.(int))\n}\n\nfunc (h *IntHeap) Pop() interface{} {\n\told := *h\n\tn := len(old)\n\tx := old[n-1]\n\t*h = old[0 : n-1]\n\treturn x\n}\n\n// This example inserts several ints into an IntHeap, checks the minimum,\n// and removes them in order of priority.\nfunc main() {\n\th := &amp;IntHeap{2, 1, 5}\n\theap.Init(h)\n\theap.Push(h, 3)\n\tfmt.Printf(\"minimum: %d\\n\", (*h)[0])\n\tfor h.Len() &gt; 0 {\n\t\tfmt.Printf(\"%d \", heap.Pop(h))\n\t}\n}\n</pre> </div> </div> <div id=\"example__priorityQueue\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (PriorityQueue)</h2> <p>This example creates a PriorityQueue with some items, adds and manipulates an item, and then removes the items in priority order. </p> <pre class=\"play\">// This example demonstrates a priority queue built using the heap interface.\npackage main\n\nimport (\n\t\"container/heap\"\n\t\"fmt\"\n)\n\n// An Item is something we manage in a priority queue.\ntype Item struct {\n\tvalue    string // The value of the item; arbitrary.\n\tpriority int    // The priority of the item in the queue.\n\t// The index is needed by update and is maintained by the heap.Interface methods.\n\tindex int // The index of the item in the heap.\n}\n\n// A PriorityQueue implements heap.Interface and holds Items.\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n\t// We want Pop to give us the highest, not lowest, priority so we use greater than here.\n\treturn pq[i].priority &gt; pq[j].priority\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n\tpq[i].index = i\n\tpq[j].index = j\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n\tn := len(*pq)\n\titem := x.(*Item)\n\titem.index = n\n\t*pq = append(*pq, item)\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\titem := old[n-1]\n\titem.index = -1 // for safety\n\t*pq = old[0 : n-1]\n\treturn item\n}\n\n// update modifies the priority and value of an Item in the queue.\nfunc (pq *PriorityQueue) update(item *Item, value string, priority int) {\n\titem.value = value\n\titem.priority = priority\n\theap.Fix(pq, item.index)\n}\n\n// This example creates a PriorityQueue with some items, adds and manipulates an item,\n// and then removes the items in priority order.\nfunc main() {\n\t// Some items and their priorities.\n\titems := map[string]int{\n\t\t\"banana\": 3, \"apple\": 2, \"pear\": 4,\n\t}\n\n\t// Create a priority queue, put the items in it, and\n\t// establish the priority queue (heap) invariants.\n\tpq := make(PriorityQueue, len(items))\n\ti := 0\n\tfor value, priority := range items {\n\t\tpq[i] = &amp;Item{\n\t\t\tvalue:    value,\n\t\t\tpriority: priority,\n\t\t\tindex:    i,\n\t\t}\n\t\ti++\n\t}\n\theap.Init(&amp;pq)\n\n\t// Insert a new item and then modify its priority.\n\titem := &amp;Item{\n\t\tvalue:    \"orange\",\n\t\tpriority: 1,\n\t}\n\theap.Push(&amp;pq, item)\n\tpq.update(item, item.value, 5)\n\n\t// Take the items out; they arrive in decreasing priority order.\n\tfor pq.Len() &gt; 0 {\n\t\titem := heap.Pop(&amp;pq).(*Item)\n\t\tfmt.Printf(\"%.2d:%s \", item.priority, item.value)\n\t}\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Fix\">func Fix(h Interface, i int)</a></li>\n<li><a href=\"#Init\">func Init(h Interface)</a></li>\n<li><a href=\"#Pop\">func Pop(h Interface) interface{}</a></li>\n<li><a href=\"#Push\">func Push(h Interface, x interface{})</a></li>\n<li><a href=\"#Remove\">func Remove(h Interface, i int) interface{}</a></li>\n<li><a href=\"#Interface\">type Interface</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example__intHeap\">Package (IntHeap)</a></dd> <dd><a class=\"exampleLink\" href=\"#example__priorityQueue\">Package (PriorityQueue)</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/container/heap/heap.go\">heap.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Fix\">func Fix  </h2> <pre data-language=\"go\">func Fix(h Interface, i int)</pre> <p> Fix re-establishes the heap ordering after the element at index i has changed its value. Changing the value of the element at index i and then calling Fix is equivalent to, but less expensive than, calling Remove(h, i) followed by a Push of the new value. The complexity is O(log(n)) where n = h.Len(). </p> <h2 id=\"Init\">func Init  </h2> <pre data-language=\"go\">func Init(h Interface)</pre> <p> A heap must be initialized before any of the heap operations can be used. Init is idempotent with respect to the heap invariants and may be called whenever the heap invariants may have been invalidated. Its complexity is O(n) where n = h.Len(). </p> <h2 id=\"Pop\">func Pop  </h2> <pre data-language=\"go\">func Pop(h Interface) interface{}</pre> <p> Pop removes the minimum element (according to Less) from the heap and returns it. The complexity is O(log(n)) where n = h.Len(). It is equivalent to Remove(h, 0). </p> <h2 id=\"Push\">func Push  </h2> <pre data-language=\"go\">func Push(h Interface, x interface{})</pre> <p> Push pushes the element x onto the heap. The complexity is O(log(n)) where n = h.Len(). </p> <h2 id=\"Remove\">func Remove  </h2> <pre data-language=\"go\">func Remove(h Interface, i int) interface{}</pre> <p> Remove removes the element at index i from the heap. The complexity is O(log(n)) where n = h.Len(). </p> <h2 id=\"Interface\">type Interface  </h2> <pre data-language=\"go\">type Interface interface {\n        sort.Interface\n        Push(x interface{}) // add x as element Len()\n        Pop() interface{}   // remove and return element Len() - 1.\n}</pre> <p> Any type that implements heap.Interface may be used as a min-heap with the following invariants (established after Init has been called or if the data is empty or sorted): </p> <pre data-language=\"go\">!h.Less(j, i) for 0 &lt;= i &lt; h.Len() and 2*i+1 &lt;= j &lt;= 2*i+2 and j &lt; h.Len()\n</pre> <p> Note that Push and Pop in this interface are for package heap's implementation to call. To add and remove things from the heap, use heap.Push and heap.Pop. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/container/heap/\" class=\"_attribution-link\">https://golang.org/pkg/container/heap/</a>\n  </p>\n</div>\n","archive/zip/index":"<h1>Package zip</h1>     <ul id=\"short-nav\">\n<li><code>import \"archive/zip\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package zip provides support for reading and writing ZIP archives. </p> <p> See: <a href=\"https://www.pkware.com/documents/casestudies/APPNOTE.TXT\">https://www.pkware.com/documents/casestudies/APPNOTE.TXT</a> </p> <p> This package does not support disk spanning. </p> <p> A note about ZIP64: </p> <p> To be backwards compatible the FileHeader has both 32 and 64 bit Size fields. The 64 bit fields will always contain the correct value and for normal archives both fields will be the same. For files requiring the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit fields must be used instead. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#RegisterCompressor\">func RegisterCompressor(method uint16, comp Compressor)</a></li>\n<li><a href=\"#RegisterDecompressor\">func RegisterDecompressor(method uint16, dcomp Decompressor)</a></li>\n<li><a href=\"#Compressor\">type Compressor</a></li>\n<li><a href=\"#Decompressor\">type Decompressor</a></li>\n<li><a href=\"#File\">type File</a></li>\n<li> <a href=\"#File.DataOffset\">func (f *File) DataOffset() (offset int64, err error)</a>\n</li>\n<li> <a href=\"#File.Open\">func (f *File) Open() (io.ReadCloser, error)</a>\n</li>\n<li><a href=\"#FileHeader\">type FileHeader</a></li>\n<li> <a href=\"#FileInfoHeader\">func FileInfoHeader(fi os.FileInfo) (*FileHeader, error)</a>\n</li>\n<li> <a href=\"#FileHeader.FileInfo\">func (h *FileHeader) FileInfo() os.FileInfo</a>\n</li>\n<li> <a href=\"#FileHeader.ModTime\">func (h *FileHeader) ModTime() time.Time</a>\n</li>\n<li> <a href=\"#FileHeader.Mode\">func (h *FileHeader) Mode() (mode os.FileMode)</a>\n</li>\n<li> <a href=\"#FileHeader.SetModTime\">func (h *FileHeader) SetModTime(t time.Time)</a>\n</li>\n<li> <a href=\"#FileHeader.SetMode\">func (h *FileHeader) SetMode(mode os.FileMode)</a>\n</li>\n<li><a href=\"#ReadCloser\">type ReadCloser</a></li>\n<li> <a href=\"#OpenReader\">func OpenReader(name string) (*ReadCloser, error)</a>\n</li>\n<li> <a href=\"#ReadCloser.Close\">func (rc *ReadCloser) Close() error</a>\n</li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li> <a href=\"#NewReader\">func NewReader(r io.ReaderAt, size int64) (*Reader, error)</a>\n</li>\n<li> <a href=\"#Reader.RegisterDecompressor\">func (z *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</a>\n</li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#NewWriter\">func NewWriter(w io.Writer) *Writer</a>\n</li>\n<li> <a href=\"#Writer.Close\">func (w *Writer) Close() error</a>\n</li>\n<li> <a href=\"#Writer.Create\">func (w *Writer) Create(name string) (io.Writer, error)</a>\n</li>\n<li> <a href=\"#Writer.CreateHeader\">func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)</a>\n</li>\n<li> <a href=\"#Writer.Flush\">func (w *Writer) Flush() error</a>\n</li>\n<li> <a href=\"#Writer.RegisterCompressor\">func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</a>\n</li>\n<li> <a href=\"#Writer.SetOffset\">func (w *Writer) SetOffset(n int64)</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Reader\">Reader</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Writer\">Writer</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Writer_RegisterCompressor\">Writer.RegisterCompressor</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/archive/zip/reader.go\">reader.go</a> <a href=\"https://golang.org/src/archive/zip/register.go\">register.go</a> <a href=\"https://golang.org/src/archive/zip/struct.go\">struct.go</a> <a href=\"https://golang.org/src/archive/zip/writer.go\">writer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        Store   uint16 = 0\n        Deflate uint16 = 8\n)</pre> <p> Compression methods. </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        ErrFormat    = errors.New(\"zip: not a valid zip file\")\n        ErrAlgorithm = errors.New(\"zip: unsupported compression algorithm\")\n        ErrChecksum  = errors.New(\"zip: checksum error\")\n)</pre> <h2 id=\"RegisterCompressor\">func RegisterCompressor  </h2> <pre data-language=\"go\">func RegisterCompressor(method uint16, comp Compressor)</pre> <p> RegisterCompressor registers custom compressors for a specified method ID. The common methods Store and Deflate are built in. </p> <h2 id=\"RegisterDecompressor\">func RegisterDecompressor  </h2> <pre data-language=\"go\">func RegisterDecompressor(method uint16, dcomp Decompressor)</pre> <p> RegisterDecompressor allows custom decompressors for a specified method ID. The common methods Store and Deflate are built in. </p> <h2 id=\"Compressor\">type Compressor  </h2> <pre data-language=\"go\">type Compressor func(w io.Writer) (io.WriteCloser, error)</pre> <p> A Compressor returns a new compressing writer, writing to w. The WriteCloser's Close method must be used to flush pending data to w. The Compressor itself must be safe to invoke from multiple goroutines simultaneously, but each returned writer will be used only by one goroutine at a time. </p> <h2 id=\"Decompressor\">type Decompressor  </h2> <pre data-language=\"go\">type Decompressor func(r io.Reader) io.ReadCloser</pre> <p> A Decompressor returns a new decompressing reader, reading from r. The ReadCloser's Close method must be used to release associated resources. The Decompressor itself must be safe to invoke from multiple goroutines simultaneously, but each returned reader will be used only by one goroutine at a time. </p> <h2 id=\"File\">type File  </h2> <pre data-language=\"go\">type File struct {\n        FileHeader\n        // contains filtered or unexported fields\n}</pre> <h3 id=\"File.DataOffset\">func (*File) <a href=\"https://golang.org/src/archive/zip/reader.go?s=3638:3691#L136\">DataOffset</a>  </h3> <pre data-language=\"go\">func (f *File) DataOffset() (offset int64, err error)</pre> <p> DataOffset returns the offset of the file's possibly-compressed data, relative to the beginning of the zip file. </p> <p> Most callers should instead use Open, which transparently decompresses data and verifies checksums. </p> <h3 id=\"File.Open\">func (*File) <a href=\"https://golang.org/src/archive/zip/reader.go?s=3924:3968#L146\">Open</a>  </h3> <pre data-language=\"go\">func (f *File) Open() (io.ReadCloser, error)</pre> <p> Open returns a ReadCloser that provides access to the File's contents. Multiple files may be read concurrently. </p> <h2 id=\"FileHeader\">type FileHeader  </h2> <pre data-language=\"go\">type FileHeader struct {\n        // Name is the name of the file.\n        // It must be a relative path: it must not start with a drive\n        // letter (e.g. C:) or leading slash, and only forward slashes\n        // are allowed.\n        Name string\n\n        CreatorVersion     uint16\n        ReaderVersion      uint16\n        Flags              uint16\n        Method             uint16\n        ModifiedTime       uint16 // MS-DOS time\n        ModifiedDate       uint16 // MS-DOS date\n        CRC32              uint32\n        CompressedSize     uint32 // Deprecated: Use CompressedSize64 instead.\n        UncompressedSize   uint32 // Deprecated: Use UncompressedSize64 instead.\n        CompressedSize64   uint64\n        UncompressedSize64 uint64\n        Extra              []byte\n        ExternalAttrs      uint32 // Meaning depends on CreatorVersion\n        Comment            string\n}</pre> <p> FileHeader describes a file within a zip file. See the zip spec for details. </p> <h3 id=\"FileInfoHeader\">func <a href=\"https://golang.org/src/archive/zip/struct.go?s=3826:3882#L110\">FileInfoHeader</a>  </h3> <pre data-language=\"go\">func FileInfoHeader(fi os.FileInfo) (*FileHeader, error)</pre> <p> FileInfoHeader creates a partially-populated FileHeader from an os.FileInfo. Because os.FileInfo's Name method returns only the base name of the file it describes, it may be necessary to modify the Name field of the returned header to provide the full path name of the file. </p> <h3 id=\"FileHeader.FileInfo\">func (*FileHeader) <a href=\"https://golang.org/src/archive/zip/struct.go?s=2862:2905#L84\">FileInfo</a>  </h3> <pre data-language=\"go\">func (h *FileHeader) FileInfo() os.FileInfo</pre> <p> FileInfo returns an os.FileInfo for the FileHeader. </p> <h3 id=\"FileHeader.ModTime\">func (*FileHeader) <a href=\"https://golang.org/src/archive/zip/struct.go?s=5515:5555#L169\">ModTime</a>  </h3> <pre data-language=\"go\">func (h *FileHeader) ModTime() time.Time</pre> <p> ModTime returns the modification time in UTC. The resolution is 2s. </p> <h3 id=\"FileHeader.Mode\">func (*FileHeader) <a href=\"https://golang.org/src/archive/zip/struct.go?s=6274:6320#L199\">Mode</a>  </h3> <pre data-language=\"go\">func (h *FileHeader) Mode() (mode os.FileMode)</pre> <p> Mode returns the permission and mode bits for the FileHeader. </p> <h3 id=\"FileHeader.SetModTime\">func (*FileHeader) <a href=\"https://golang.org/src/archive/zip/struct.go?s=5728:5772#L175\">SetModTime</a>  </h3> <pre data-language=\"go\">func (h *FileHeader) SetModTime(t time.Time)</pre> <p> SetModTime sets the ModifiedTime and ModifiedDate fields to the given time in UTC. The resolution is 2s. </p> <h3 id=\"FileHeader.SetMode\">func (*FileHeader) <a href=\"https://golang.org/src/archive/zip/struct.go?s=6695:6741#L213\">SetMode</a>  </h3> <pre data-language=\"go\">func (h *FileHeader) SetMode(mode os.FileMode)</pre> <p> SetMode changes the permission and mode bits for the FileHeader. </p> <h2 id=\"ReadCloser\">type ReadCloser  </h2> <pre data-language=\"go\">type ReadCloser struct {\n        Reader\n        // contains filtered or unexported fields\n}</pre> <h3 id=\"OpenReader\">func <a href=\"https://golang.org/src/archive/zip/reader.go?s=903:952#L39\">OpenReader</a>  </h3> <pre data-language=\"go\">func OpenReader(name string) (*ReadCloser, error)</pre> <p> OpenReader will open the Zip file specified by name and return a ReadCloser. </p> <h3 id=\"ReadCloser.Close\">func (*ReadCloser) <a href=\"https://golang.org/src/archive/zip/reader.go?s=3348:3383#L127\">Close</a>  </h3> <pre data-language=\"go\">func (rc *ReadCloser) Close() error</pre> <p> Close closes the Zip file, rendering it unusable for I/O. </p> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader struct {\n        File    []*File\n        Comment string\n        // contains filtered or unexported fields\n}</pre> <div id=\"example_Reader\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// Open a zip archive for reading.\n    r, err := zip.OpenReader(\"testdata/readme.zip\")\n    if err != nil {\n            log.Fatal(err)\n    }\n    defer r.Close()\n\n    // Iterate through the files in the archive,\n    // printing some of their contents.\n    for _, f := range r.File {\n            fmt.Printf(\"Contents of %s:\\n\", f.Name)\n            rc, err := f.Open()\n            if err != nil {\n                    log.Fatal(err)\n            }\n            _, err = io.CopyN(os.Stdout, rc, 68)\n            if err != nil {\n                    log.Fatal(err)\n            }\n            rc.Close()\n            fmt.Println()\n    }\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">Contents of README:\nThis is the source code repository for the Go programming language.\n</pre> </div> </div> <h3 id=\"NewReader\">func <a href=\"https://golang.org/src/archive/zip/reader.go?s=1320:1378#L60\">NewReader</a>  </h3> <pre data-language=\"go\">func NewReader(r io.ReaderAt, size int64) (*Reader, error)</pre> <p> NewReader returns a new Reader reading from r, which is assumed to have the given size in bytes. </p> <h3 id=\"Reader.RegisterDecompressor\">func (*Reader) <a href=\"https://golang.org/src/archive/zip/reader.go?s=2930:3002#L111\">RegisterDecompressor</a>  </h3> <pre data-language=\"go\">func (z *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</pre> <p> RegisterDecompressor registers or overrides a custom decompressor for a specific method ID. If a decompressor for a given method is not found, Reader will default to looking up the decompressor at the package level. </p> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer struct {\n        // contains filtered or unexported fields\n}</pre> <p> Writer implements a zip file writer. </p> <div id=\"example_Writer\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    // Create a buffer to write our archive to.\n    buf := new(bytes.Buffer)\n\n    // Create a new zip archive.\n    w := zip.NewWriter(buf)\n\n    // Add some files to the archive.\n    var files = []struct {\n            Name, Body string\n    }{\n            {\"readme.txt\", \"This archive contains some text files.\"},\n            {\"gopher.txt\", \"Gopher names:\\nGeorge\\nGeoffrey\\nGonzo\"},\n            {\"todo.txt\", \"Get animal handling licence.\\nWrite more examples.\"},\n    }\n    for _, file := range files {\n            f, err := w.Create(file.Name)\n            if err != nil {\n                    log.Fatal(err)\n            }\n            _, err = f.Write([]byte(file.Body))\n            if err != nil {\n                    log.Fatal(err)\n            }\n    }\n\n    // Make sure to check the error on Close.\n    err := w.Close()\n    if err != nil {\n            log.Fatal(err)\n    }\n</pre> </div> </div> <h3 id=\"NewWriter\">func <a href=\"https://golang.org/src/archive/zip/writer.go?s=594:629#L23\">NewWriter</a>  </h3> <pre data-language=\"go\">func NewWriter(w io.Writer) *Writer</pre> <p> NewWriter returns a new Writer writing a zip file to w. </p> <h3 id=\"Writer.Close\">func (*Writer) <a href=\"https://golang.org/src/archive/zip/writer.go?s=1414:1444#L46\">Close</a>  </h3> <pre data-language=\"go\">func (w *Writer) Close() error</pre> <p> Close finishes writing the zip file by writing the central directory. It does not (and cannot) close the underlying writer. </p> <h3 id=\"Writer.Create\">func (*Writer) <a href=\"https://golang.org/src/archive/zip/writer.go?s=5854:5909#L177\">Create</a>  </h3> <pre data-language=\"go\">func (w *Writer) Create(name string) (io.Writer, error)</pre> <p> Create adds a file to the zip file using the provided name. It returns a Writer to which the file contents should be written. The name must be a relative path: it must not start with a drive letter (e.g. C:) or leading slash, and only forward slashes are allowed. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close. </p> <h3 id=\"Writer.CreateHeader\">func (*Writer) <a href=\"https://golang.org/src/archive/zip/writer.go?s=6376:6440#L192\">CreateHeader</a>  </h3> <pre data-language=\"go\">func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)</pre> <p> CreateHeader adds a file to the zip file using the provided FileHeader for the file metadata. It returns a Writer to which the file contents should be written. </p> <p> The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close. The provided FileHeader fh must not be modified after a call to CreateHeader. </p> <h3 id=\"Writer.Flush\">func (*Writer) <a href=\"https://golang.org/src/archive/zip/writer.go?s=1209:1239#L40\">Flush</a>  </h3> <pre data-language=\"go\">func (w *Writer) Flush() error</pre> <p> Flush flushes any buffered data to the underlying writer. Calling Flush is not normally necessary; calling Close is sufficient. </p> <h3 id=\"Writer.RegisterCompressor\">func (*Writer) <a href=\"https://golang.org/src/archive/zip/writer.go?s=8307:8374#L266\">RegisterCompressor</a>  </h3> <pre data-language=\"go\">func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</pre> <p> RegisterCompressor registers or overrides a custom compressor for a specific method ID. If a compressor for a given method is not found, Writer will default to looking up the compressor at the package level. </p> <div id=\"example_Writer_RegisterCompressor\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"compress/flate\"\n\t\"io\"\n)\n\nfunc main() {\n\t// Override the default Deflate compressor with a higher compression level.\n\n\t// Create a buffer to write our archive to.\n\tbuf := new(bytes.Buffer)\n\n\t// Create a new zip archive.\n\tw := zip.NewWriter(buf)\n\n\t// Register a custom Deflate compressor.\n\tw.RegisterCompressor(zip.Deflate, func(out io.Writer) (io.WriteCloser, error) {\n\t\treturn flate.NewWriter(out, flate.BestCompression)\n\t})\n\n\t// Proceed to add files to w.\n}\n</pre> </div> </div> <h3 id=\"Writer.SetOffset\">func (*Writer) <a href=\"https://golang.org/src/archive/zip/writer.go?s=937:972#L31\">SetOffset</a>  </h3> <pre data-language=\"go\">func (w *Writer) SetOffset(n int64)</pre> <p> SetOffset sets the offset of the beginning of the zip data within the underlying writer. It should be used when the zip data is appended to an existing file, such as a binary executable. It must be called before any data is written. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/archive/zip/\" class=\"_attribution-link\">https://golang.org/pkg/archive/zip/</a>\n  </p>\n</div>\n","context/index":"<h1>Package context</h1>     <ul id=\"short-nav\">\n<li><code>import \"context\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package context defines the Context type, which carries deadlines, cancelation signals, and other request-scoped values across API boundaries and between processes. </p> <p> Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context. The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. When a Context is canceled, all Contexts derived from it are also canceled. </p> <p> The WithCancel, WithDeadline, and WithTimeout functions take a Context (the parent) and return a derived Context (the child) and a CancelFunc. Calling the CancelFunc cancels the child and its children, removes the parent's reference to the child, and stops any associated timers. Failing to call the CancelFunc leaks the child and its children until the parent is canceled or the timer fires. The go vet tool checks that CancelFuncs are used on all control-flow paths. </p> <p> Programs that use Contexts should follow these rules to keep interfaces consistent across packages and enable static analysis tools to check context propagation: </p> <p> Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx: </p> <pre data-language=\"go\">func DoSomething(ctx context.Context, arg Arg) error {\n\t// ... use ctx ...\n}\n</pre> <p> Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use. </p> <p> Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions. </p> <p> The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines. </p> <p> See <a href=\"https://blog.golang.org/context\">https://blog.golang.org/context</a> for example code for a server that uses Contexts. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#CancelFunc\">type CancelFunc</a></li>\n<li><a href=\"#Context\">type Context</a></li>\n<li> <a href=\"#Background\">func Background() Context</a>\n</li>\n<li> <a href=\"#TODO\">func TODO() Context</a>\n</li>\n<li> <a href=\"#WithCancel\">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</a>\n</li>\n<li> <a href=\"#WithDeadline\">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</a>\n</li>\n<li> <a href=\"#WithTimeout\">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</a>\n</li>\n<li> <a href=\"#WithValue\">func WithValue(parent Context, key, val interface{}) Context</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_WithTimeout\">WithTimeout</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/context/context.go\">context.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var Canceled = errors.New(\"context canceled\")</pre> <p> Canceled is the error returned by Context.Err when the context is canceled. </p> <pre data-language=\"go\">var DeadlineExceeded error = deadlineExceededError{}</pre> <p> DeadlineExceeded is the error returned by Context.Err when the context's deadline passes. </p> <h2 id=\"CancelFunc\">type CancelFunc  </h2> <pre data-language=\"go\">type CancelFunc func()</pre> <p> A CancelFunc tells an operation to abandon its work. A CancelFunc does not wait for the work to stop. After the first call, subsequent calls to a CancelFunc do nothing. </p> <h2 id=\"Context\">type Context  </h2> <pre data-language=\"go\">type Context interface {\n        // Deadline returns the time when work done on behalf of this context\n        // should be canceled. Deadline returns ok==false when no deadline is\n        // set. Successive calls to Deadline return the same results.\n        Deadline() (deadline time.Time, ok bool)\n\n        // Done returns a channel that's closed when work done on behalf of this\n        // context should be canceled. Done may return nil if this context can\n        // never be canceled. Successive calls to Done return the same value.\n        //\n        // WithCancel arranges for Done to be closed when cancel is called;\n        // WithDeadline arranges for Done to be closed when the deadline\n        // expires; WithTimeout arranges for Done to be closed when the timeout\n        // elapses.\n        //\n        // Done is provided for use in select statements:\n        //\n        //  // Stream generates values with DoSomething and sends them to out\n        //  // until DoSomething returns an error or ctx.Done is closed.\n        //  func Stream(ctx context.Context, out chan&lt;- Value) error {\n        //  \tfor {\n        //  \t\tv, err := DoSomething(ctx)\n        //  \t\tif err != nil {\n        //  \t\t\treturn err\n        //  \t\t}\n        //  \t\tselect {\n        //  \t\tcase &lt;-ctx.Done():\n        //  \t\t\treturn ctx.Err()\n        //  \t\tcase out &lt;- v:\n        //  \t\t}\n        //  \t}\n        //  }\n        //\n        // See https://blog.golang.org/pipelines for more examples of how to use\n        // a Done channel for cancelation.\n        Done() &lt;-chan struct{}\n\n        // Err returns a non-nil error value after Done is closed. Err returns\n        // Canceled if the context was canceled or DeadlineExceeded if the\n        // context's deadline passed. No other values for Err are defined.\n        // After Done is closed, successive calls to Err return the same value.\n        Err() error\n\n        // Value returns the value associated with this context for key, or nil\n        // if no value is associated with key. Successive calls to Value with\n        // the same key returns the same result.\n        //\n        // Use context values only for request-scoped data that transits\n        // processes and API boundaries, not for passing optional parameters to\n        // functions.\n        //\n        // A key identifies a specific value in a Context. Functions that wish\n        // to store values in Context typically allocate a key in a global\n        // variable then use that key as the argument to context.WithValue and\n        // Context.Value. A key can be any type that supports equality;\n        // packages should define keys as an unexported type to avoid\n        // collisions.\n        //\n        // Packages that define a Context key should provide type-safe accessors\n        // for the values stored using that key:\n        //\n        // \t// Package user defines a User type that's stored in Contexts.\n        // \tpackage user\n        //\n        // \timport \"context\"\n        //\n        // \t// User is the type of value stored in the Contexts.\n        // \ttype User struct {...}\n        //\n        // \t// key is an unexported type for keys defined in this package.\n        // \t// This prevents collisions with keys defined in other packages.\n        // \ttype key int\n        //\n        // \t// userKey is the key for user.User values in Contexts. It is\n        // \t// unexported; clients use user.NewContext and user.FromContext\n        // \t// instead of using this key directly.\n        // \tvar userKey key = 0\n        //\n        // \t// NewContext returns a new Context that carries value u.\n        // \tfunc NewContext(ctx context.Context, u *User) context.Context {\n        // \t\treturn context.WithValue(ctx, userKey, u)\n        // \t}\n        //\n        // \t// FromContext returns the User value stored in ctx, if any.\n        // \tfunc FromContext(ctx context.Context) (*User, bool) {\n        // \t\tu, ok := ctx.Value(userKey).(*User)\n        // \t\treturn u, ok\n        // \t}\n        Value(key interface{}) interface{}\n}</pre> <p> A Context carries a deadline, a cancelation signal, and other values across API boundaries. </p> <p> Context's methods may be called by multiple goroutines simultaneously. </p> <h3 id=\"Background\">func <a href=\"https://golang.org/src/context/context.go?s=7222:7247#L195\">Background</a>  </h3> <pre data-language=\"go\">func Background() Context</pre> <p> Background returns a non-nil, empty Context. It is never canceled, has no values, and has no deadline. It is typically used by the main function, initialization, and tests, and as the top-level Context for incoming requests. </p> <h3 id=\"TODO\">func <a href=\"https://golang.org/src/context/context.go?s=7628:7647#L204\">TODO</a>  </h3> <pre data-language=\"go\">func TODO() Context</pre> <p> TODO returns a non-nil, empty Context. Code should use context.TODO when it's unclear which Context to use or it is not yet available (because the surrounding function has not yet been extended to accept a Context parameter). TODO is recognized by static analysis tools that determine whether Contexts are propagated correctly in a program. </p> <h3 id=\"WithCancel\">func <a href=\"https://golang.org/src/context/context.go?s=8264:8328#L219\">WithCancel</a>  </h3> <pre data-language=\"go\">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</pre> <p> WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first. </p> <p> Canceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete. </p> <h3 id=\"WithDeadline\">func <a href=\"https://golang.org/src/context/context.go?s=11899:11974#L359\">WithDeadline</a>  </h3> <pre data-language=\"go\">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</pre> <p> WithDeadline returns a copy of the parent context with the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned context's Done channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first. </p> <p> Canceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete. </p> <h3 id=\"WithTimeout\">func <a href=\"https://golang.org/src/context/context.go?s=13917:13994#L426\">WithTimeout</a>  </h3> <pre data-language=\"go\">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</pre> <p> WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)). </p> <p> Canceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete: </p> <pre data-language=\"go\">func slowOperationWithTimeout(ctx context.Context) (Result, error) {\n\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n\treturn slowOperation(ctx)\n}\n</pre> <div id=\"example_WithTimeout\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Pass a context with a timeout to tell a blocking function that it\n\t// should abandon its work after the timeout elapses.\n\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\n\tselect {\n\tcase &lt;-time.After(1 * time.Second):\n\t\tfmt.Println(\"overslept\")\n\tcase &lt;-ctx.Done():\n\t\tfmt.Println(ctx.Err()) // prints \"context deadline exceeded\"\n\t}\n\n\t// Even though ctx should have expired already, it is good\n\t// practice to call its cancelation function in any case.\n\t// Failure to do so may keep the context and its parent alive\n\t// longer than necessary.\n\tcancel()\n\n}\n</pre> </div> </div> <h3 id=\"WithValue\">func <a href=\"https://golang.org/src/context/context.go?s=14326:14386#L437\">WithValue</a>  </h3> <pre data-language=\"go\">func WithValue(parent Context, key, val interface{}) Context</pre> <p> WithValue returns a copy of parent in which the value associated with key is val. </p> <p> Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions. </p> <p> The provided key must be comparable. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/context/\" class=\"_attribution-link\">https://golang.org/pkg/context/</a>\n  </p>\n</div>\n","crypto/dsa/index":"<h1>Package dsa</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/dsa\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#GenerateKey\">func GenerateKey(priv *PrivateKey, rand io.Reader) error</a></li>\n<li><a href=\"#GenerateParameters\">func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes) error</a></li>\n<li><a href=\"#Sign\">func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)</a></li>\n<li><a href=\"#Verify\">func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool</a></li>\n<li><a href=\"#ParameterSizes\">type ParameterSizes</a></li>\n<li><a href=\"#Parameters\">type Parameters</a></li>\n<li><a href=\"#PrivateKey\">type PrivateKey</a></li>\n<li><a href=\"#PublicKey\">type PublicKey</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/dsa/dsa.go\">dsa.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrInvalidPublicKey = errors.New(\"crypto/dsa: invalid public key\")</pre> <p> ErrInvalidPublicKey results when a public key is not usable by this code. FIPS is quite strict about the format of DSA keys, but other code may be less so. Thus, when using keys which may have been generated by other code, this error must be handled. </p> <h2 id=\"GenerateKey\">func GenerateKey  </h2> <pre data-language=\"go\">func GenerateKey(priv *PrivateKey, rand io.Reader) error</pre> <p> GenerateKey generates a public&amp;private key pair. The Parameters of the PrivateKey must already be valid (see GenerateParameters). </p> <h2 id=\"GenerateParameters\">func GenerateParameters  </h2> <pre data-language=\"go\">func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes) error</pre> <p> GenerateParameters puts a random, valid set of DSA parameters into params. This function can take many seconds, even on fast machines. </p> <h2 id=\"Sign\">func Sign  </h2> <pre data-language=\"go\">func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)</pre> <p> Sign signs an arbitrary length hash (which should be the result of hashing a larger message) using the private key, priv. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand. </p> <p> Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated to the byte-length of the subgroup. This function does not perform that truncation itself. </p> <h2 id=\"Verify\">func Verify  </h2> <pre data-language=\"go\">func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool</pre> <p> Verify verifies the signature in r, s of hash using the public key, pub. It reports whether the signature is valid. </p> <p> Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated to the byte-length of the subgroup. This function does not perform that truncation itself. </p> <h2 id=\"ParameterSizes\">type ParameterSizes  </h2> <pre data-language=\"go\">type ParameterSizes int</pre> <p> ParameterSizes is a enumeration of the acceptable bit lengths of the primes in a set of DSA parameters. See FIPS 186-3, section 4.2. </p> <pre data-language=\"go\">const (\n        L1024N160 ParameterSizes = iota\n        L2048N224\n        L2048N256\n        L3072N256\n)</pre> <h2 id=\"Parameters\">type Parameters  </h2> <pre data-language=\"go\">type Parameters struct {\n        P, Q, G *big.Int\n}</pre> <p> Parameters represents the domain parameters for a key. These parameters can be shared across many keys. The bit length of Q must be a multiple of 8. </p> <h2 id=\"PrivateKey\">type PrivateKey  </h2> <pre data-language=\"go\">type PrivateKey struct {\n        PublicKey\n        X *big.Int\n}</pre> <p> PrivateKey represents a DSA private key. </p> <h2 id=\"PublicKey\">type PublicKey  </h2> <pre data-language=\"go\">type PublicKey struct {\n        Parameters\n        Y *big.Int\n}</pre> <p> PublicKey represents a DSA public key. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/dsa/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/dsa/</a>\n  </p>\n</div>\n","crypto/ecdsa/index":"<h1>Package ecdsa</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/ecdsa\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as defined in FIPS 186-3. </p> <p> This implementation derives the nonce from an AES-CTR CSPRNG keyed by ChopMD(256, SHA2-512(priv.D || entropy || hash)). The CSPRNG key is IRO by a result of Coron; the AES-CTR stream is IRO under standard assumptions. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Sign\">func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)</a></li>\n<li><a href=\"#Verify\">func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool</a></li>\n<li><a href=\"#PrivateKey\">type PrivateKey</a></li>\n<li> <a href=\"#GenerateKey\">func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)</a>\n</li>\n<li> <a href=\"#PrivateKey.Public\">func (priv *PrivateKey) Public() crypto.PublicKey</a>\n</li>\n<li> <a href=\"#PrivateKey.Sign\">func (priv *PrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) ([]byte, error)</a>\n</li>\n<li><a href=\"#PublicKey\">type PublicKey</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/ecdsa/ecdsa.go\">ecdsa.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Sign\">func Sign  </h2> <pre data-language=\"go\">func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)</pre> <p> Sign signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand. </p> <h2 id=\"Verify\">func Verify  </h2> <pre data-language=\"go\">func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool</pre> <p> Verify verifies the signature in r, s of hash using the public key, pub. Its return value records whether the signature is valid. </p> <h2 id=\"PrivateKey\">type PrivateKey  </h2> <pre data-language=\"go\">type PrivateKey struct {\n        PublicKey\n        D *big.Int\n}</pre> <p> PrivateKey represents a ECDSA private key. </p> <h3 id=\"GenerateKey\">func <a href=\"https://golang.org/src/crypto/ecdsa/ecdsa.go?s=2616:2687#L90\">GenerateKey</a>  </h3> <pre data-language=\"go\">func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)</pre> <p> GenerateKey generates a public and private key pair. </p> <h3 id=\"PrivateKey.Public\">func (*PrivateKey) <a href=\"https://golang.org/src/crypto/ecdsa/ecdsa.go?s=1542:1591#L53\">Public</a>  </h3> <pre data-language=\"go\">func (priv *PrivateKey) Public() crypto.PublicKey</pre> <p> Public returns the public key corresponding to priv. </p> <h3 id=\"PrivateKey.Sign\">func (*PrivateKey) <a href=\"https://golang.org/src/crypto/ecdsa/ecdsa.go?s=1863:1959#L61\">Sign</a>  </h3> <pre data-language=\"go\">func (priv *PrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) ([]byte, error)</pre> <p> Sign signs msg with priv, reading randomness from rand. This method is intended to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign function in this package directly. </p> <h2 id=\"PublicKey\">type PublicKey  </h2> <pre data-language=\"go\">type PublicKey struct {\n        elliptic.Curve\n        X, Y *big.Int\n}</pre> <p> PublicKey represents an ECDSA public key. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/ecdsa/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/ecdsa/</a>\n  </p>\n</div>\n","compress/bzip2/index":"<h1>Package bzip2</h1>     <ul id=\"short-nav\">\n<li><code>import \"compress/bzip2\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package bzip2 implements bzip2 decompression. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#NewReader\">func NewReader(r io.Reader) io.Reader</a></li>\n<li><a href=\"#StructuralError\">type StructuralError</a></li>\n<li> <a href=\"#StructuralError.Error\">func (s StructuralError) Error() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/compress/bzip2/bit_reader.go\">bit_reader.go</a> <a href=\"https://golang.org/src/compress/bzip2/bzip2.go\">bzip2.go</a> <a href=\"https://golang.org/src/compress/bzip2/huffman.go\">huffman.go</a> <a href=\"https://golang.org/src/compress/bzip2/move_to_front.go\">move_to_front.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"NewReader\">func NewReader  </h2> <pre data-language=\"go\">func NewReader(r io.Reader) io.Reader</pre> <p> NewReader returns an io.Reader which decompresses bzip2 data from r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. </p> <h2 id=\"StructuralError\">type StructuralError  </h2> <pre data-language=\"go\">type StructuralError string</pre> <p> A StructuralError is returned when the bzip2 data is found to be syntactically invalid. </p> <h3 id=\"StructuralError.Error\">func (StructuralError) <a href=\"https://golang.org/src/compress/bzip2/bzip2.go?s=594:633#L9\">Error</a>  </h3> <pre data-language=\"go\">func (s StructuralError) Error() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/compress/bzip2/\" class=\"_attribution-link\">https://golang.org/pkg/compress/bzip2/</a>\n  </p>\n</div>\n","compress/zlib/index":"<h1>Package zlib</h1>     <ul id=\"short-nav\">\n<li><code>import \"compress/zlib\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950. </p> <p> The implementation provides filters that uncompress during reading and compress during writing. For example, to write compressed data to a buffer: </p> <pre data-language=\"go\">var b bytes.Buffer\nw := zlib.NewWriter(&amp;b)\nw.Write([]byte(\"hello, world\\n\"))\nw.Close()\n</pre> <p> and to read that data back: </p> <pre data-language=\"go\">r, err := zlib.NewReader(&amp;b)\nio.Copy(os.Stdout, r)\nr.Close()\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#NewReader\">func NewReader(r io.Reader) (io.ReadCloser, error)</a></li>\n<li><a href=\"#NewReaderDict\">func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)</a></li>\n<li><a href=\"#Resetter\">type Resetter</a></li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#NewWriter\">func NewWriter(w io.Writer) *Writer</a>\n</li>\n<li> <a href=\"#NewWriterLevel\">func NewWriterLevel(w io.Writer, level int) (*Writer, error)</a>\n</li>\n<li> <a href=\"#NewWriterLevelDict\">func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)</a>\n</li>\n<li> <a href=\"#Writer.Close\">func (z *Writer) Close() error</a>\n</li>\n<li> <a href=\"#Writer.Flush\">func (z *Writer) Flush() error</a>\n</li>\n<li> <a href=\"#Writer.Reset\">func (z *Writer) Reset(w io.Writer)</a>\n</li>\n<li> <a href=\"#Writer.Write\">func (z *Writer) Write(p []byte) (n int, err error)</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_NewReader\">NewReader</a></dd> <dd><a class=\"exampleLink\" href=\"#example_NewWriter\">NewWriter</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/compress/zlib/reader.go\">reader.go</a> <a href=\"https://golang.org/src/compress/zlib/writer.go\">writer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        NoCompression      = flate.NoCompression\n        BestSpeed          = flate.BestSpeed\n        BestCompression    = flate.BestCompression\n        DefaultCompression = flate.DefaultCompression\n)</pre> <p> These constants are copied from the flate package, so that code that imports \"compress/zlib\" does not also have to import \"compress/flate\". </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        // ErrChecksum is returned when reading ZLIB data that has an invalid checksum.\n        ErrChecksum = errors.New(\"zlib: invalid checksum\")\n        // ErrDictionary is returned when reading ZLIB data that has an invalid dictionary.\n        ErrDictionary = errors.New(\"zlib: invalid dictionary\")\n        // ErrHeader is returned when reading ZLIB data that has an invalid header.\n        ErrHeader = errors.New(\"zlib: invalid header\")\n)</pre> <h2 id=\"NewReader\">func NewReader  </h2> <pre data-language=\"go\">func NewReader(r io.Reader) (io.ReadCloser, error)</pre> <p> NewReader creates a new ReadCloser. Reads from the returned ReadCloser read and decompress data from r. If r does not implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when done. </p> <p> The ReadCloser returned by NewReader also implements Resetter. </p> <div id=\"example_NewReader\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"compress/zlib\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\tbuff := []byte{120, 156, 202, 72, 205, 201, 201, 215, 81, 40, 207,\n\t\t47, 202, 73, 225, 2, 4, 0, 0, 255, 255, 33, 231, 4, 147}\n\tb := bytes.NewReader(buff)\n\n\tr, err := zlib.NewReader(b)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tio.Copy(os.Stdout, r)\n\n\tr.Close()\n}\n</pre> </div> </div> <h2 id=\"NewReaderDict\">func NewReaderDict  </h2> <pre data-language=\"go\">func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)</pre> <p> NewReaderDict is like NewReader but uses a preset dictionary. NewReaderDict ignores the dictionary if the compressed data does not refer to it. If the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary. </p> <p> The ReadCloser returned by NewReaderDict also implements Resetter. </p> <h2 id=\"Resetter\">type Resetter  </h2> <pre data-language=\"go\">type Resetter interface {\n        // Reset discards any buffered data and resets the Resetter as if it was\n        // newly initialized with the given reader.\n        Reset(r io.Reader, dict []byte) error\n}</pre> <p> Resetter resets a ReadCloser returned by NewReader or NewReaderDict to to switch to a new underlying Reader. This permits reusing a ReadCloser instead of allocating a new one. </p> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Writer takes data written to it and writes the compressed form of that data to an underlying writer (see NewWriter). </p> <h3 id=\"NewWriter\">func <a href=\"https://golang.org/src/compress/zlib/writer.go?s=1128:1163#L32\">NewWriter</a>  </h3> <pre data-language=\"go\">func NewWriter(w io.Writer) *Writer</pre> <p> NewWriter creates a new Writer. Writes to the returned Writer are compressed and written to w. </p> <p> It is the caller's responsibility to call Close on the WriteCloser when done. Writes may be buffered and not flushed until Close. </p> <div id=\"example_NewWriter\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"compress/zlib\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar b bytes.Buffer\n\n\tw := zlib.NewWriter(&amp;b)\n\tw.Write([]byte(\"hello, world\\n\"))\n\tw.Close()\n\tfmt.Println(b.Bytes())\n}\n</pre> </div> </div> <h3 id=\"NewWriterLevel\">func <a href=\"https://golang.org/src/compress/zlib/writer.go?s=1550:1610#L43\">NewWriterLevel</a>  </h3> <pre data-language=\"go\">func NewWriterLevel(w io.Writer, level int) (*Writer, error)</pre> <p> NewWriterLevel is like NewWriter but specifies the compression level instead of assuming DefaultCompression. </p> <p> The compression level can be DefaultCompression, NoCompression, or any integer value between BestSpeed and BestCompression inclusive. The error returned will be nil if the level is valid. </p> <h3 id=\"NewWriterLevelDict\">func <a href=\"https://golang.org/src/compress/zlib/writer.go?s=1859:1936#L52\">NewWriterLevelDict</a>  </h3> <pre data-language=\"go\">func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)</pre> <p> NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to compress with. </p> <p> The dictionary may be nil. If not, its contents should not be modified until the Writer is closed. </p> <h3 id=\"Writer.Close\">func (*Writer) <a href=\"https://golang.org/src/compress/zlib/writer.go?s=4991:5021#L169\">Close</a>  </h3> <pre data-language=\"go\">func (z *Writer) Close() error</pre> <p> Close closes the Writer, flushing any unwritten data to the underlying io.Writer, but does not close the underlying io.Writer. </p> <h3 id=\"Writer.Flush\">func (*Writer) <a href=\"https://golang.org/src/compress/zlib/writer.go?s=4691:4721#L156\">Flush</a>  </h3> <pre data-language=\"go\">func (z *Writer) Flush() error</pre> <p> Flush flushes the Writer to its underlying io.Writer. </p> <h3 id=\"Writer.Reset\">func (*Writer) <a href=\"https://golang.org/src/compress/zlib/writer.go?s=2309:2344#L66\">Reset</a>  </h3> <pre data-language=\"go\">func (z *Writer) Reset(w io.Writer)</pre> <p> Reset clears the state of the Writer z such that it is equivalent to its initial state from NewWriterLevel or NewWriterLevelDict, but instead writing to w. </p> <h3 id=\"Writer.Write\">func (*Writer) <a href=\"https://golang.org/src/compress/zlib/writer.go?s=4348:4399#L136\">Write</a>  </h3> <pre data-language=\"go\">func (z *Writer) Write(p []byte) (n int, err error)</pre> <p> Write writes a compressed form of p to the underlying io.Writer. The compressed bytes are not necessarily flushed until the Writer is closed or explicitly flushed. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/compress/zlib/\" class=\"_attribution-link\">https://golang.org/pkg/compress/zlib/</a>\n  </p>\n</div>\n","container/list/index":"<h1>Package list</h1>     <ul id=\"short-nav\">\n<li><code>import \"container/list\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package list implements a doubly linked list. </p> <p> To iterate over a list (where l is a *List): </p> <pre data-language=\"go\">for e := l.Front(); e != nil; e = e.Next() {\n\t// do something with e.Value\n}\n</pre> </div> </div> <div id=\"example_\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"container/list\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t// Create a new list and put some numbers in it.\n\tl := list.New()\n\te4 := l.PushBack(4)\n\te1 := l.PushFront(1)\n\tl.InsertBefore(3, e4)\n\tl.InsertAfter(2, e1)\n\n\t// Iterate through list and print its contents.\n\tfor e := l.Front(); e != nil; e = e.Next() {\n\t\tfmt.Println(e.Value)\n\t}\n\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Element\">type Element</a></li>\n<li> <a href=\"#Element.Next\">func (e *Element) Next() *Element</a>\n</li>\n<li> <a href=\"#Element.Prev\">func (e *Element) Prev() *Element</a>\n</li>\n<li><a href=\"#List\">type List</a></li>\n<li> <a href=\"#New\">func New() *List</a>\n</li>\n<li> <a href=\"#List.Back\">func (l *List) Back() *Element</a>\n</li>\n<li> <a href=\"#List.Front\">func (l *List) Front() *Element</a>\n</li>\n<li> <a href=\"#List.Init\">func (l *List) Init() *List</a>\n</li>\n<li> <a href=\"#List.InsertAfter\">func (l *List) InsertAfter(v interface{}, mark *Element) *Element</a>\n</li>\n<li> <a href=\"#List.InsertBefore\">func (l *List) InsertBefore(v interface{}, mark *Element) *Element</a>\n</li>\n<li> <a href=\"#List.Len\">func (l *List) Len() int</a>\n</li>\n<li> <a href=\"#List.MoveAfter\">func (l *List) MoveAfter(e, mark *Element)</a>\n</li>\n<li> <a href=\"#List.MoveBefore\">func (l *List) MoveBefore(e, mark *Element)</a>\n</li>\n<li> <a href=\"#List.MoveToBack\">func (l *List) MoveToBack(e *Element)</a>\n</li>\n<li> <a href=\"#List.MoveToFront\">func (l *List) MoveToFront(e *Element)</a>\n</li>\n<li> <a href=\"#List.PushBack\">func (l *List) PushBack(v interface{}) *Element</a>\n</li>\n<li> <a href=\"#List.PushBackList\">func (l *List) PushBackList(other *List)</a>\n</li>\n<li> <a href=\"#List.PushFront\">func (l *List) PushFront(v interface{}) *Element</a>\n</li>\n<li> <a href=\"#List.PushFrontList\">func (l *List) PushFrontList(other *List)</a>\n</li>\n<li> <a href=\"#List.Remove\">func (l *List) Remove(e *Element) interface{}</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_\">Package</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/container/list/list.go\">list.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Element\">type Element  </h2> <pre data-language=\"go\">type Element struct {\n\n        // The value stored with this element.\n        Value interface{}\n        // contains filtered or unexported fields\n}</pre> <p> Element is an element of a linked list. </p> <h3 id=\"Element.Next\">func (*Element) <a href=\"https://golang.org/src/container/list/list.go?s=922:955#L21\">Next</a>  </h3> <pre data-language=\"go\">func (e *Element) Next() *Element</pre> <p> Next returns the next list element or nil. </p> <h3 id=\"Element.Prev\">func (*Element) <a href=\"https://golang.org/src/container/list/list.go?s=1091:1124#L29\">Prev</a>  </h3> <pre data-language=\"go\">func (e *Element) Prev() *Element</pre> <p> Prev returns the previous list element or nil. </p> <h2 id=\"List\">type List  </h2> <pre data-language=\"go\">type List struct {\n        // contains filtered or unexported fields\n}</pre> <p> List represents a doubly linked list. The zero value for List is an empty list ready to use. </p> <h3 id=\"New\">func <a href=\"https://golang.org/src/container/list/list.go?s=1662:1678#L52\">New</a>  </h3> <pre data-language=\"go\">func New() *List</pre> <p> New returns an initialized list. </p> <h3 id=\"List.Back\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=2021:2051#L67\">Back</a>  </h3> <pre data-language=\"go\">func (l *List) Back() *Element</pre> <p> Back returns the last element of list l or nil. </p> <h3 id=\"List.Front\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=1880:1911#L59\">Front</a>  </h3> <pre data-language=\"go\">func (l *List) Front() *Element</pre> <p> Front returns the first element of list l or nil. </p> <h3 id=\"List.Init\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=1526:1553#L44\">Init</a>  </h3> <pre data-language=\"go\">func (l *List) Init() *List</pre> <p> Init initializes or clears list l. </p> <h3 id=\"List.InsertAfter\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=4116:4181#L144\">InsertAfter</a>  </h3> <pre data-language=\"go\">func (l *List) InsertAfter(v interface{}, mark *Element) *Element</pre> <p> InsertAfter inserts a new element e with value v immediately after mark and returns e. If mark is not an element of l, the list is not modified. </p> <h3 id=\"List.InsertBefore\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=3763:3829#L134\">InsertBefore</a>  </h3> <pre data-language=\"go\">func (l *List) InsertBefore(v interface{}, mark *Element) *Element</pre> <p> InsertBefore inserts a new element e with value v immediately before mark and returns e. If mark is not an element of l, the list is not modified. </p> <h3 id=\"List.Len\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=1784:1808#L56\">Len</a>  </h3> <pre data-language=\"go\">func (l *List) Len() int</pre> <p> Len returns the number of elements of list l. The complexity is O(1). </p> <h3 id=\"List.MoveAfter\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=5333:5375#L183\">MoveAfter</a>  </h3> <pre data-language=\"go\">func (l *List) MoveAfter(e, mark *Element)</pre> <p> MoveAfter moves element e to its new position after mark. If e or mark is not an element of l, or e == mark, the list is not modified. </p> <h3 id=\"List.MoveBefore\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=5048:5091#L174\">MoveBefore</a>  </h3> <pre data-language=\"go\">func (l *List) MoveBefore(e, mark *Element)</pre> <p> MoveBefore moves element e to its new position before mark. If e or mark is not an element of l, or e == mark, the list is not modified. </p> <h3 id=\"List.MoveToBack\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=4719:4756#L164\">MoveToBack</a>  </h3> <pre data-language=\"go\">func (l *List) MoveToBack(e *Element)</pre> <p> MoveToBack moves element e to the back of list l. If e is not an element of l, the list is not modified. </p> <h3 id=\"List.MoveToFront\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=4425:4463#L154\">MoveToFront</a>  </h3> <pre data-language=\"go\">func (l *List) MoveToFront(e *Element)</pre> <p> MoveToFront moves element e to the front of list l. If e is not an element of l, the list is not modified. </p> <h3 id=\"List.PushBack\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=3505:3552#L127\">PushBack</a>  </h3> <pre data-language=\"go\">func (l *List) PushBack(v interface{}) *Element</pre> <p> PushBack inserts a new element e with value v at the back of list l and returns e. </p> <h3 id=\"List.PushBackList\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=5584:5624#L192\">PushBackList</a>  </h3> <pre data-language=\"go\">func (l *List) PushBackList(other *List)</pre> <p> PushBackList inserts a copy of an other list at the back of list l. The lists l and other may be the same. </p> <h3 id=\"List.PushFront\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=3317:3365#L121\">PushFront</a>  </h3> <pre data-language=\"go\">func (l *List) PushFront(v interface{}) *Element</pre> <p> PushFront inserts a new element e with value v at the front of list l and returns e. </p> <h3 id=\"List.PushFrontList\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=5871:5912#L201\">PushFrontList</a>  </h3> <pre data-language=\"go\">func (l *List) PushFrontList(other *List)</pre> <p> PushFrontList inserts a copy of an other list at the front of list l. The lists l and other may be the same. </p> <h3 id=\"List.Remove\">func (*List) <a href=\"https://golang.org/src/container/list/list.go?s=2989:3034#L111\">Remove</a>  </h3> <pre data-language=\"go\">func (l *List) Remove(e *Element) interface{}</pre> <p> Remove removes e from l if e is an element of list l. It returns the element value e.Value. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/container/list/\" class=\"_attribution-link\">https://golang.org/pkg/container/list/</a>\n  </p>\n</div>\n","crypto/aes/index":"<h1>Package aes</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/aes\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package aes implements AES encryption (formerly Rijndael), as defined in U.S. Federal Information Processing Standards Publication 197. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#NewCipher\">func NewCipher(key []byte) (cipher.Block, error)</a></li>\n<li><a href=\"#KeySizeError\">type KeySizeError</a></li>\n<li> <a href=\"#KeySizeError.Error\">func (k KeySizeError) Error() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/aes/aes_gcm.go\">aes_gcm.go</a> <a href=\"https://golang.org/src/crypto/aes/block.go\">block.go</a> <a href=\"https://golang.org/src/crypto/aes/cipher.go\">cipher.go</a> <a href=\"https://golang.org/src/crypto/aes/cipher_amd64.go\">cipher_amd64.go</a> <a href=\"https://golang.org/src/crypto/aes/const.go\">const.go</a> <a href=\"https://golang.org/src/crypto/aes/modes.go\">modes.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const BlockSize = 16</pre> <p> The AES block size in bytes. </p> <h2 id=\"NewCipher\">func NewCipher  </h2> <pre data-language=\"go\">func NewCipher(key []byte) (cipher.Block, error)</pre> <p> NewCipher creates and returns a new cipher.Block. The key argument should be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256. </p> <h2 id=\"KeySizeError\">type KeySizeError  </h2> <pre data-language=\"go\">type KeySizeError int</pre> <h3 id=\"KeySizeError.Error\">func (KeySizeError) <a href=\"https://golang.org/src/crypto/aes/cipher.go?s=414:450#L13\">Error</a>  </h3> <pre data-language=\"go\">func (k KeySizeError) Error() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/aes/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/aes/</a>\n  </p>\n</div>\n","crypto/hmac/index":"<h1>Package hmac</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/hmac\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198. An HMAC is a cryptographic hash that uses a key to sign a message. The receiver verifies the hash by recomputing it using the same key. </p> <p> Receivers should be careful to use Equal to compare MACs in order to avoid timing side-channels: </p> <pre data-language=\"go\">// CheckMAC reports whether messageMAC is a valid HMAC tag for message.\nfunc CheckMAC(message, messageMAC, key []byte) bool {\n\tmac := hmac.New(sha256.New, key)\n\tmac.Write(message)\n\texpectedMAC := mac.Sum(nil)\n\treturn hmac.Equal(messageMAC, expectedMAC)\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Equal\">func Equal(mac1, mac2 []byte) bool</a></li>\n<li><a href=\"#New\">func New(h func() hash.Hash, key []byte) hash.Hash</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/hmac/hmac.go\">hmac.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Equal\">func Equal  </h2> <pre data-language=\"go\">func Equal(mac1, mac2 []byte) bool</pre> <p> Equal compares two MACs for equality without leaking timing information. </p> <h2 id=\"New\">func New  </h2> <pre data-language=\"go\">func New(h func() hash.Hash, key []byte) hash.Hash</pre> <p> New returns a new HMAC hash using the given hash.Hash type and key. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/hmac/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/hmac/</a>\n  </p>\n</div>\n","compress/gzip/index":"<h1>Package gzip</h1>     <ul id=\"short-nav\">\n<li><code>import \"compress/gzip\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Header\">type Header</a></li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li> <a href=\"#NewReader\">func NewReader(r io.Reader) (*Reader, error)</a>\n</li>\n<li> <a href=\"#Reader.Close\">func (z *Reader) Close() error</a>\n</li>\n<li> <a href=\"#Reader.Multistream\">func (z *Reader) Multistream(ok bool)</a>\n</li>\n<li> <a href=\"#Reader.Read\">func (z *Reader) Read(p []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#Reader.Reset\">func (z *Reader) Reset(r io.Reader) error</a>\n</li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#NewWriter\">func NewWriter(w io.Writer) *Writer</a>\n</li>\n<li> <a href=\"#NewWriterLevel\">func NewWriterLevel(w io.Writer, level int) (*Writer, error)</a>\n</li>\n<li> <a href=\"#Writer.Close\">func (z *Writer) Close() error</a>\n</li>\n<li> <a href=\"#Writer.Flush\">func (z *Writer) Flush() error</a>\n</li>\n<li> <a href=\"#Writer.Reset\">func (z *Writer) Reset(w io.Writer)</a>\n</li>\n<li> <a href=\"#Writer.Write\">func (z *Writer) Write(p []byte) (int, error)</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/compress/gzip/gunzip.go\">gunzip.go</a> <a href=\"https://golang.org/src/compress/gzip/gzip.go\">gzip.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        NoCompression      = flate.NoCompression\n        BestSpeed          = flate.BestSpeed\n        BestCompression    = flate.BestCompression\n        DefaultCompression = flate.DefaultCompression\n)</pre> <p> These constants are copied from the flate package, so that code that imports \"compress/gzip\" does not also have to import \"compress/flate\". </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        // ErrChecksum is returned when reading GZIP data that has an invalid checksum.\n        ErrChecksum = errors.New(\"gzip: invalid checksum\")\n        // ErrHeader is returned when reading GZIP data that has an invalid header.\n        ErrHeader = errors.New(\"gzip: invalid header\")\n)</pre> <h2 id=\"Header\">type Header  </h2> <pre data-language=\"go\">type Header struct {\n        Comment string    // comment\n        Extra   []byte    // \"extra data\"\n        ModTime time.Time // modification time\n        Name    string    // file name\n        OS      byte      // operating system type\n}</pre> <p> The gzip file stores a header giving metadata about the compressed file. That header is exposed as the fields of the Writer and Reader structs. </p> <p> Strings must be UTF-8 encoded and may only contain Unicode code points U+0001 through U+00FF, due to limitations of the GZIP file format. </p> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader struct {\n        Header // valid after NewReader or Reader.Reset\n        // contains filtered or unexported fields\n}</pre> <p> A Reader is an io.Reader that can be read to retrieve uncompressed data from a gzip-format compressed file. </p> <p> In general, a gzip file can be a concatenation of gzip files, each with its own header. Reads from the Reader return the concatenation of the uncompressed data of each. Only the first header is recorded in the Reader fields. </p> <p> Gzip files store a length and checksum of the uncompressed data. The Reader will return a ErrChecksum when Read reaches the end of the uncompressed data if it does not have the expected length or checksum. Clients should treat data returned by Read as tentative until they receive the io.EOF marking the end of the data. </p> <h3 id=\"NewReader\">func <a href=\"https://golang.org/src/compress/gzip/gunzip.go?s=2830:2874#L82\">NewReader</a>  </h3> <pre data-language=\"go\">func NewReader(r io.Reader) (*Reader, error)</pre> <p> NewReader creates a new Reader reading the given reader. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. </p> <p> It is the caller's responsibility to call Close on the Reader when done. </p> <p> The Reader.Header fields will be valid in the Reader returned. </p> <h3 id=\"Reader.Close\">func (*Reader) <a href=\"https://golang.org/src/compress/gzip/gunzip.go?s=8349:8379#L277\">Close</a>  </h3> <pre data-language=\"go\">func (z *Reader) Close() error</pre> <p> Close closes the Reader. It does not close the underlying io.Reader. In order for the GZIP checksum to be verified, the reader must be fully consumed until the io.EOF. </p> <h3 id=\"Reader.Multistream\">func (*Reader) <a href=\"https://golang.org/src/compress/gzip/gunzip.go?s=4441:4478#L123\">Multistream</a>  </h3> <pre data-language=\"go\">func (z *Reader) Multistream(ok bool)</pre> <p> Multistream controls whether the reader supports multistream files. </p> <p> If enabled (the default), the Reader expects the input to be a sequence of individually gzipped data streams, each with its own header and trailer, ending at EOF. The effect is that the concatenation of a sequence of gzipped files is treated as equivalent to the gzip of the concatenation of the sequence. This is standard behavior for gzip readers. </p> <p> Calling Multistream(false) disables this behavior; disabling the behavior can be useful when reading file formats that distinguish individual gzip data streams or mix gzip data streams with other data streams. In this mode, when the Reader reaches the end of the data stream, Read returns io.EOF. If the underlying reader implements io.ByteReader, it will be left positioned just after the gzip stream. To start the next stream, call z.Reset(r) followed by z.Multistream(false). If there is no next stream, z.Reset(r) will return io.EOF. </p> <h3 id=\"Reader.Read\">func (*Reader) <a href=\"https://golang.org/src/compress/gzip/gunzip.go?s=7286:7336#L231\">Read</a>  </h3> <pre data-language=\"go\">func (z *Reader) Read(p []byte) (n int, err error)</pre> <h3 id=\"Reader.Reset\">func (*Reader) <a href=\"https://golang.org/src/compress/gzip/gunzip.go?s=3183:3224#L93\">Reset</a>  </h3> <pre data-language=\"go\">func (z *Reader) Reset(r io.Reader) error</pre> <p> Reset discards the Reader z's state and makes it equivalent to the result of its original state from NewReader, but reading from r instead. This permits reusing a Reader rather than allocating a new one. </p> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer struct {\n        Header // written at first call to Write, Flush, or Close\n        // contains filtered or unexported fields\n}</pre> <p> A Writer is an io.WriteCloser. Writes to a Writer are compressed and written to w. </p> <h3 id=\"NewWriter\">func <a href=\"https://golang.org/src/compress/gzip/gzip.go?s=1368:1403#L37\">NewWriter</a>  </h3> <pre data-language=\"go\">func NewWriter(w io.Writer) *Writer</pre> <p> NewWriter returns a new Writer. Writes to the returned writer are compressed and written to w. </p> <p> It is the caller's responsibility to call Close on the WriteCloser when done. Writes may be buffered and not flushed until Close. </p> <p> Callers that wish to set the fields in Writer.Header must do so before the first call to Write, Flush, or Close. </p> <h3 id=\"NewWriterLevel\">func <a href=\"https://golang.org/src/compress/gzip/gzip.go?s=1781:1841#L48\">NewWriterLevel</a>  </h3> <pre data-language=\"go\">func NewWriterLevel(w io.Writer, level int) (*Writer, error)</pre> <p> NewWriterLevel is like NewWriter but specifies the compression level instead of assuming DefaultCompression. </p> <p> The compression level can be DefaultCompression, NoCompression, or any integer value between BestSpeed and BestCompression inclusive. The error returned will be nil if the level is valid. </p> <h3 id=\"Writer.Close\">func (*Writer) <a href=\"https://golang.org/src/compress/gzip/gzip.go?s=5806:5836#L216\">Close</a>  </h3> <pre data-language=\"go\">func (z *Writer) Close() error</pre> <p> Close closes the Writer, flushing any unwritten data to the underlying io.Writer, but does not close the underlying io.Writer. </p> <h3 id=\"Writer.Flush\">func (*Writer) <a href=\"https://golang.org/src/compress/gzip/gzip.go?s=5446:5476#L197\">Flush</a>  </h3> <pre data-language=\"go\">func (z *Writer) Flush() error</pre> <p> Flush flushes any pending compressed data to the underlying writer. </p> <p> It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. If the underlying writer returns an error, Flush returns that error. </p> <p> In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH. </p> <h3 id=\"Writer.Reset\">func (*Writer) <a href=\"https://golang.org/src/compress/gzip/gzip.go?s=2519:2554#L76\">Reset</a>  </h3> <pre data-language=\"go\">func (z *Writer) Reset(w io.Writer)</pre> <p> Reset discards the Writer z's state and makes it equivalent to the result of its original state from NewWriter or NewWriterLevel, but writing to w instead. This permits reusing a Writer rather than allocating a new one. </p> <h3 id=\"Writer.Write\">func (*Writer) <a href=\"https://golang.org/src/compress/gzip/gzip.go?s=3814:3859#L127\">Write</a>  </h3> <pre data-language=\"go\">func (z *Writer) Write(p []byte) (int, error)</pre> <p> Write writes a compressed form of p to the underlying io.Writer. The compressed bytes are not necessarily flushed until the Writer is closed. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/compress/gzip/\" class=\"_attribution-link\">https://golang.org/pkg/compress/gzip/</a>\n  </p>\n</div>\n","builtin/index":"<h1>Package builtin</h1>     <ul id=\"short-nav\">\n<li><code>import \"builtin\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package builtin provides documentation for Go's predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language's special identifiers. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#append\">func append(slice []Type, elems ...Type) []Type</a></li>\n<li><a href=\"#cap\">func cap(v Type) int</a></li>\n<li><a href=\"#close\">func close(c chan&lt;- Type)</a></li>\n<li><a href=\"#complex\">func complex(r, i FloatType) ComplexType</a></li>\n<li><a href=\"#copy\">func copy(dst, src []Type) int</a></li>\n<li><a href=\"#delete\">func delete(m map[Type]Type1, key Type)</a></li>\n<li><a href=\"#imag\">func imag(c ComplexType) FloatType</a></li>\n<li><a href=\"#len\">func len(v Type) int</a></li>\n<li><a href=\"#make\">func make(Type, size IntegerType) Type</a></li>\n<li><a href=\"#new\">func new(Type) *Type</a></li>\n<li><a href=\"#panic\">func panic(v interface{})</a></li>\n<li><a href=\"#print\">func print(args ...Type)</a></li>\n<li><a href=\"#println\">func println(args ...Type)</a></li>\n<li><a href=\"#real\">func real(c ComplexType) FloatType</a></li>\n<li><a href=\"#recover\">func recover() interface{}</a></li>\n<li><a href=\"#ComplexType\">type ComplexType</a></li>\n<li><a href=\"#FloatType\">type FloatType</a></li>\n<li><a href=\"#IntegerType\">type IntegerType</a></li>\n<li><a href=\"#Type\">type Type</a></li>\n<li><a href=\"#Type1\">type Type1</a></li>\n<li><a href=\"#bool\">type bool</a></li>\n<li><a href=\"#byte\">type byte</a></li>\n<li><a href=\"#complex128\">type complex128</a></li>\n<li><a href=\"#complex64\">type complex64</a></li>\n<li><a href=\"#error\">type error</a></li>\n<li><a href=\"#float32\">type float32</a></li>\n<li><a href=\"#float64\">type float64</a></li>\n<li><a href=\"#int\">type int</a></li>\n<li><a href=\"#int16\">type int16</a></li>\n<li><a href=\"#int32\">type int32</a></li>\n<li><a href=\"#int64\">type int64</a></li>\n<li><a href=\"#int8\">type int8</a></li>\n<li><a href=\"#rune\">type rune</a></li>\n<li><a href=\"#string\">type string</a></li>\n<li><a href=\"#uint\">type uint</a></li>\n<li><a href=\"#uint16\">type uint16</a></li>\n<li><a href=\"#uint32\">type uint32</a></li>\n<li><a href=\"#uint64\">type uint64</a></li>\n<li><a href=\"#uint8\">type uint8</a></li>\n<li><a href=\"#uintptr\">type uintptr</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/builtin/builtin.go\">builtin.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        true  = 0 == 0 // Untyped bool.\n        false = 0 != 0 // Untyped bool.\n)</pre> <p> true and false are the two untyped boolean values. </p> <pre data-language=\"go\">const iota = 0 // Untyped int.\n</pre> <p> iota is a predeclared identifier representing the untyped integer ordinal number of the current const specification in a (usually parenthesized) const declaration. It is zero-indexed. </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var nil Type // Type must be a pointer, channel, func, interface, map, or slice type\n</pre> <p> nil is a predeclared identifier representing the zero value for a pointer, channel, func, interface, map, or slice type. </p> <h2 id=\"append\">func append  </h2> <pre data-language=\"go\">func append(slice []Type, elems ...Type) []Type</pre> <p> The append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself: </p> <pre data-language=\"go\">slice = append(slice, elem1, elem2)\nslice = append(slice, anotherSlice...)\n</pre> <p> As a special case, it is legal to append a string to a byte slice, like this: </p> <pre data-language=\"go\">slice = append([]byte(\"hello \"), \"world\"...)\n</pre> <h2 id=\"cap\">func cap  </h2> <pre data-language=\"go\">func cap(v Type) int</pre> <p> The cap built-in function returns the capacity of v, according to its type: </p> <pre data-language=\"go\">Array: the number of elements in v (same as len(v)).\nPointer to array: the number of elements in *v (same as len(v)).\nSlice: the maximum length the slice can reach when resliced;\nif v is nil, cap(v) is zero.\nChannel: the channel buffer capacity, in units of elements;\nif v is nil, cap(v) is zero.\n</pre> <h2 id=\"close\">func close  </h2> <pre data-language=\"go\">func close(c chan&lt;- Type)</pre> <p> The close built-in function closes a channel, which must be either bidirectional or send-only. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element. The form </p> <pre data-language=\"go\">x, ok := &lt;-c\n</pre> <p> will also set ok to false for a closed channel. </p> <h2 id=\"complex\">func complex  </h2> <pre data-language=\"go\">func complex(r, i FloatType) ComplexType</pre> <p> The complex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64). </p> <h2 id=\"copy\">func copy  </h2> <pre data-language=\"go\">func copy(dst, src []Type) int</pre> <p> The copy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst). </p> <h2 id=\"delete\">func delete  </h2> <pre data-language=\"go\">func delete(m map[Type]Type1, key Type)</pre> <p> The delete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op. </p> <h2 id=\"imag\">func imag  </h2> <pre data-language=\"go\">func imag(c ComplexType) FloatType</pre> <p> The imag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c. </p> <h2 id=\"len\">func len  </h2> <pre data-language=\"go\">func len(v Type) int</pre> <p> The len built-in function returns the length of v, according to its type: </p> <pre data-language=\"go\">Array: the number of elements in v.\nPointer to array: the number of elements in *v (even if v is nil).\nSlice, or map: the number of elements in v; if v is nil, len(v) is zero.\nString: the number of bytes in v.\nChannel: the number of elements queued (unread) in the channel buffer;\nif v is nil, len(v) is zero.\n</pre> <h2 id=\"make\">func make  </h2> <pre data-language=\"go\">func make(Type, size IntegerType) Type</pre> <p> The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type: </p> <pre data-language=\"go\">Slice: The size specifies the length. The capacity of the slice is\nequal to its length. A second integer argument may be provided to\nspecify a different capacity; it must be no smaller than the\nlength, so make([]int, 0, 10) allocates a slice of length 0 and\ncapacity 10.\nMap: An initial allocation is made according to the size but the\nresulting map has length 0. The size may be omitted, in which case\na small starting size is allocated.\nChannel: The channel's buffer is initialized with the specified\nbuffer capacity. If zero, or the size is omitted, the channel is\nunbuffered.\n</pre> <h2 id=\"new\">func new  </h2> <pre data-language=\"go\">func new(Type) *Type</pre> <p> The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type. </p> <h2 id=\"panic\">func panic  </h2> <pre data-language=\"go\">func panic(v interface{})</pre> <p> The panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated and the error condition is reported, including the value of the argument to panic. This termination sequence is called panicking and can be controlled by the built-in function recover. </p> <h2 id=\"print\">func print  </h2> <pre data-language=\"go\">func print(args ...Type)</pre> <p> The print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language. </p> <h2 id=\"println\">func println  </h2> <pre data-language=\"go\">func println(args ...Type)</pre> <p> The println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language. </p> <h2 id=\"real\">func real  </h2> <pre data-language=\"go\">func real(c ComplexType) FloatType</pre> <p> The real built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c. </p> <h2 id=\"recover\">func recover  </h2> <pre data-language=\"go\">func recover() interface{}</pre> <p> The recover built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, or if the argument supplied to panic was nil, recover returns nil. Thus the return value from recover reports whether the goroutine is panicking. </p> <h2 id=\"ComplexType\">type ComplexType  </h2> <pre data-language=\"go\">type ComplexType complex64</pre> <p> ComplexType is here for the purposes of documentation only. It is a stand-in for either complex type: complex64 or complex128. </p> <h2 id=\"FloatType\">type FloatType  </h2> <pre data-language=\"go\">type FloatType float32</pre> <p> FloatType is here for the purposes of documentation only. It is a stand-in for either float type: float32 or float64. </p> <h2 id=\"IntegerType\">type IntegerType  </h2> <pre data-language=\"go\">type IntegerType int</pre> <p> IntegerType is here for the purposes of documentation only. It is a stand-in for any integer type: int, uint, int8 etc. </p> <h2 id=\"Type\">type Type  </h2> <pre data-language=\"go\">type Type int</pre> <p> Type is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation. </p> <h2 id=\"Type1\">type Type1  </h2> <pre data-language=\"go\">type Type1 int</pre> <p> Type1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation. </p> <h2 id=\"bool\">type bool  </h2> <pre data-language=\"go\">type bool bool</pre> <p> bool is the set of boolean values, true and false. </p> <h2 id=\"byte\">type byte  </h2> <pre data-language=\"go\">type byte byte</pre> <p> byte is an alias for uint8 and is equivalent to uint8 in all ways. It is used, by convention, to distinguish byte values from 8-bit unsigned integer values. </p> <h2 id=\"complex128\">type complex128  </h2> <pre data-language=\"go\">type complex128 complex128</pre> <p> complex128 is the set of all complex numbers with float64 real and imaginary parts. </p> <h2 id=\"complex64\">type complex64  </h2> <pre data-language=\"go\">type complex64 complex64</pre> <p> complex64 is the set of all complex numbers with float32 real and imaginary parts. </p> <h2 id=\"error\">type error  </h2> <pre data-language=\"go\">type error interface {\n        Error() string\n}</pre> <p> The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error. </p> <h2 id=\"float32\">type float32  </h2> <pre data-language=\"go\">type float32 float32</pre> <p> float32 is the set of all IEEE-754 32-bit floating-point numbers. </p> <h2 id=\"float64\">type float64  </h2> <pre data-language=\"go\">type float64 float64</pre> <p> float64 is the set of all IEEE-754 64-bit floating-point numbers. </p> <h2 id=\"int\">type int  </h2> <pre data-language=\"go\">type int int</pre> <p> int is a signed integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, int32. </p> <h2 id=\"int16\">type int16  </h2> <pre data-language=\"go\">type int16 int16</pre> <p> int16 is the set of all signed 16-bit integers. Range: -32768 through 32767. </p> <h2 id=\"int32\">type int32  </h2> <pre data-language=\"go\">type int32 int32</pre> <p> int32 is the set of all signed 32-bit integers. Range: -2147483648 through 2147483647. </p> <h2 id=\"int64\">type int64  </h2> <pre data-language=\"go\">type int64 int64</pre> <p> int64 is the set of all signed 64-bit integers. Range: -9223372036854775808 through 9223372036854775807. </p> <h2 id=\"int8\">type int8  </h2> <pre data-language=\"go\">type int8 int8</pre> <p> int8 is the set of all signed 8-bit integers. Range: -128 through 127. </p> <h2 id=\"rune\">type rune  </h2> <pre data-language=\"go\">type rune rune</pre> <p> rune is an alias for int32 and is equivalent to int32 in all ways. It is used, by convention, to distinguish character values from integer values. </p> <h2 id=\"string\">type string  </h2> <pre data-language=\"go\">type string string</pre> <p> string is the set of all strings of 8-bit bytes, conventionally but not necessarily representing UTF-8-encoded text. A string may be empty, but not nil. Values of string type are immutable. </p> <h2 id=\"uint\">type uint  </h2> <pre data-language=\"go\">type uint uint</pre> <p> uint is an unsigned integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, uint32. </p> <h2 id=\"uint16\">type uint16  </h2> <pre data-language=\"go\">type uint16 uint16</pre> <p> uint16 is the set of all unsigned 16-bit integers. Range: 0 through 65535. </p> <h2 id=\"uint32\">type uint32  </h2> <pre data-language=\"go\">type uint32 uint32</pre> <p> uint32 is the set of all unsigned 32-bit integers. Range: 0 through 4294967295. </p> <h2 id=\"uint64\">type uint64  </h2> <pre data-language=\"go\">type uint64 uint64</pre> <p> uint64 is the set of all unsigned 64-bit integers. Range: 0 through 18446744073709551615. </p> <h2 id=\"uint8\">type uint8  </h2> <pre data-language=\"go\">type uint8 uint8</pre> <p> uint8 is the set of all unsigned 8-bit integers. Range: 0 through 255. </p> <h2 id=\"uintptr\">type uintptr  </h2> <pre data-language=\"go\">type uintptr uintptr</pre> <p> uintptr is an integer type that is large enough to hold the bit pattern of any pointer. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/builtin/\" class=\"_attribution-link\">https://golang.org/pkg/builtin/</a>\n  </p>\n</div>\n","compress/lzw/index":"<h1>Package lzw</h1>     <ul id=\"short-nav\">\n<li><code>import \"compress/lzw\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, “A Technique for High-Performance Data Compression”, Computer, 17(6) (June 1984), pp 8-19. </p> <p> In particular, it implements LZW as used by the GIF and PDF file formats, which means variable-width codes up to 12 bits and the first two non-literal codes are a clear code and an EOF code. </p> <p> The TIFF file format uses a similar but incompatible version of the LZW algorithm. See the golang.org/x/image/tiff/lzw package for an implementation. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#NewReader\">func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser</a></li>\n<li><a href=\"#NewWriter\">func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser</a></li>\n<li><a href=\"#Order\">type Order</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/compress/lzw/reader.go\">reader.go</a> <a href=\"https://golang.org/src/compress/lzw/writer.go\">writer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"NewReader\">func NewReader  </h2> <pre data-language=\"go\">func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser</pre> <p> NewReader creates a new io.ReadCloser. Reads from the returned io.ReadCloser read and decompress data from r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. It must equal the litWidth used during compression. </p> <h2 id=\"NewWriter\">func NewWriter  </h2> <pre data-language=\"go\">func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser</pre> <p> NewWriter creates a new io.WriteCloser. Writes to the returned io.WriteCloser are compressed and written to w. It is the caller's responsibility to call Close on the WriteCloser when finished writing. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. Input bytes must be less than 1&lt;&lt;litWidth. </p> <h2 id=\"Order\">type Order  </h2> <pre data-language=\"go\">type Order int</pre> <p> Order specifies the bit ordering in an LZW data stream. </p> <pre data-language=\"go\">const (\n        // LSB means Least Significant Bits first, as used in the GIF file format.\n        LSB Order = iota\n        // MSB means Most Significant Bits first, as used in the TIFF and PDF\n        // file formats.\n        MSB\n)</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/compress/lzw/\" class=\"_attribution-link\">https://golang.org/pkg/compress/lzw/</a>\n  </p>\n</div>\n","crypto/elliptic/index":"<h1>Package elliptic</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/elliptic\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package elliptic implements several standard elliptic curves over prime fields. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#GenerateKey\">func GenerateKey(curve Curve, rand io.Reader) (priv []byte, x, y *big.Int, err error)</a></li>\n<li><a href=\"#Marshal\">func Marshal(curve Curve, x, y *big.Int) []byte</a></li>\n<li><a href=\"#Unmarshal\">func Unmarshal(curve Curve, data []byte) (x, y *big.Int)</a></li>\n<li><a href=\"#Curve\">type Curve</a></li>\n<li> <a href=\"#P224\">func P224() Curve</a>\n</li>\n<li> <a href=\"#P256\">func P256() Curve</a>\n</li>\n<li> <a href=\"#P384\">func P384() Curve</a>\n</li>\n<li> <a href=\"#P521\">func P521() Curve</a>\n</li>\n<li><a href=\"#CurveParams\">type CurveParams</a></li>\n<li> <a href=\"#CurveParams.Add\">func (curve *CurveParams) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int)</a>\n</li>\n<li> <a href=\"#CurveParams.Double\">func (curve *CurveParams) Double(x1, y1 *big.Int) (*big.Int, *big.Int)</a>\n</li>\n<li> <a href=\"#CurveParams.IsOnCurve\">func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool</a>\n</li>\n<li> <a href=\"#CurveParams.Params\">func (curve *CurveParams) Params() *CurveParams</a>\n</li>\n<li> <a href=\"#CurveParams.ScalarBaseMult\">func (curve *CurveParams) ScalarBaseMult(k []byte) (*big.Int, *big.Int)</a>\n</li>\n<li> <a href=\"#CurveParams.ScalarMult\">func (curve *CurveParams) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int)</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/elliptic/elliptic.go\">elliptic.go</a> <a href=\"https://golang.org/src/crypto/elliptic/p224.go\">p224.go</a> <a href=\"https://golang.org/src/crypto/elliptic/p256_amd64.go\">p256_amd64.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"GenerateKey\">func GenerateKey  </h2> <pre data-language=\"go\">func GenerateKey(curve Curve, rand io.Reader) (priv []byte, x, y *big.Int, err error)</pre> <p> GenerateKey returns a public/private key pair. The private key is generated using the given reader, which must return random data. </p> <h2 id=\"Marshal\">func Marshal  </h2> <pre data-language=\"go\">func Marshal(curve Curve, x, y *big.Int) []byte</pre> <p> Marshal converts a point into the form specified in section 4.3.6 of ANSI X9.62. </p> <h2 id=\"Unmarshal\">func Unmarshal  </h2> <pre data-language=\"go\">func Unmarshal(curve Curve, data []byte) (x, y *big.Int)</pre> <p> Unmarshal converts a point, serialized by Marshal, into an x, y pair. It is an error if the point is not on the curve. On error, x = nil. </p> <h2 id=\"Curve\">type Curve  </h2> <pre data-language=\"go\">type Curve interface {\n        // Params returns the parameters for the curve.\n        Params() *CurveParams\n        // IsOnCurve reports whether the given (x,y) lies on the curve.\n        IsOnCurve(x, y *big.Int) bool\n        // Add returns the sum of (x1,y1) and (x2,y2)\n        Add(x1, y1, x2, y2 *big.Int) (x, y *big.Int)\n        // Double returns 2*(x,y)\n        Double(x1, y1 *big.Int) (x, y *big.Int)\n        // ScalarMult returns k*(Bx,By) where k is a number in big-endian form.\n        ScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int)\n        // ScalarBaseMult returns k*G, where G is the base point of the group\n        // and k is an integer in big-endian form.\n        ScalarBaseMult(k []byte) (x, y *big.Int)\n}</pre> <p> A Curve represents a short-form Weierstrass curve with a=-3. See <a href=\"http://www.hyperelliptic.org/EFD/g1p/auto-shortw.html\">http://www.hyperelliptic.org/EFD/g1p/auto-shortw.html</a> </p> <h3 id=\"P224\">func <a href=\"https://golang.org/src/crypto/elliptic/p224.go?s=1290:1307#L29\">P224</a>  </h3> <pre data-language=\"go\">func P224() Curve</pre> <p> P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2) </p> <h3 id=\"P256\">func <a href=\"https://golang.org/src/crypto/elliptic/elliptic.go?s=11132:11149#L360\">P256</a>  </h3> <pre data-language=\"go\">func P256() Curve</pre> <p> P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3) </p> <h3 id=\"P384\">func <a href=\"https://golang.org/src/crypto/elliptic/elliptic.go?s=11269:11286#L366\">P384</a>  </h3> <pre data-language=\"go\">func P384() Curve</pre> <p> P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4) </p> <h3 id=\"P521\">func <a href=\"https://golang.org/src/crypto/elliptic/elliptic.go?s=11406:11423#L372\">P521</a>  </h3> <pre data-language=\"go\">func P521() Curve</pre> <p> P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5) </p> <h2 id=\"CurveParams\">type CurveParams  </h2> <pre data-language=\"go\">type CurveParams struct {\n        P       *big.Int // the order of the underlying field\n        N       *big.Int // the order of the base point\n        B       *big.Int // the constant of the curve equation\n        Gx, Gy  *big.Int // (x,y) of the base point\n        BitSize int      // the size of the underlying field\n        Name    string   // the canonical name of the curve\n}</pre> <p> CurveParams contains the parameters of an elliptic curve and also provides a generic, non-constant time implementation of Curve. </p> <h3 id=\"CurveParams.Add\">func (*CurveParams) <a href=\"https://golang.org/src/crypto/elliptic/elliptic.go?s=3249:3324#L92\">Add</a>  </h3> <pre data-language=\"go\">func (curve *CurveParams) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int)</pre> <h3 id=\"CurveParams.Double\">func (*CurveParams) <a href=\"https://golang.org/src/crypto/elliptic/elliptic.go?s=5095:5165#L176\">Double</a>  </h3> <pre data-language=\"go\">func (curve *CurveParams) Double(x1, y1 *big.Int) (*big.Int, *big.Int)</pre> <h3 id=\"CurveParams.IsOnCurve\">func (*CurveParams) <a href=\"https://golang.org/src/crypto/elliptic/elliptic.go?s=2054:2109#L45\">IsOnCurve</a>  </h3> <pre data-language=\"go\">func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool</pre> <h3 id=\"CurveParams.Params\">func (*CurveParams) <a href=\"https://golang.org/src/crypto/elliptic/elliptic.go?s=1987:2034#L41\">Params</a>  </h3> <pre data-language=\"go\">func (curve *CurveParams) Params() *CurveParams</pre> <h3 id=\"CurveParams.ScalarBaseMult\">func (*CurveParams) <a href=\"https://golang.org/src/crypto/elliptic/elliptic.go?s=7043:7114#L258\">ScalarBaseMult</a>  </h3> <pre data-language=\"go\">func (curve *CurveParams) ScalarBaseMult(k []byte) (*big.Int, *big.Int)</pre> <h3 id=\"CurveParams.ScalarMult\">func (*CurveParams) <a href=\"https://golang.org/src/crypto/elliptic/elliptic.go?s=6608:6692#L241\">ScalarMult</a>  </h3> <pre data-language=\"go\">func (curve *CurveParams) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int)</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/elliptic/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/elliptic/</a>\n  </p>\n</div>\n","crypto/md5/index":"<h1>Package md5</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/md5\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package md5 implements the MD5 hash algorithm as defined in RFC 1321. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#New\">func New() hash.Hash</a></li>\n<li><a href=\"#Sum\">func Sum(data []byte) [Size]byte</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_New\">New</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Sum\">Sum</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/md5/md5.go\">md5.go</a> <a href=\"https://golang.org/src/crypto/md5/md5block.go\">md5block.go</a> <a href=\"https://golang.org/src/crypto/md5/md5block_decl.go\">md5block_decl.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const BlockSize = 64</pre> <p> The blocksize of MD5 in bytes. </p> <pre data-language=\"go\">const Size = 16</pre> <p> The size of an MD5 checksum in bytes. </p> <h2 id=\"New\">func New  </h2> <pre data-language=\"go\">func New() hash.Hash</pre> <p> New returns a new hash.Hash computing the MD5 checksum. </p> <div id=\"example_New\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/md5\"\n\t\"fmt\"\n\t\"io\"\n)\n\nfunc main() {\n\th := md5.New()\n\tio.WriteString(h, \"The fog is getting thicker!\")\n\tio.WriteString(h, \"And Leon's getting laaarger!\")\n\tfmt.Printf(\"%x\", h.Sum(nil))\n}\n</pre> </div> </div> <h2 id=\"Sum\">func Sum  </h2> <pre data-language=\"go\">func Sum(data []byte) [Size]byte</pre> <p> Sum returns the MD5 checksum of the data. </p> <div id=\"example_Sum\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/md5\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tdata := []byte(\"These pretzels are making me thirsty.\")\n\tfmt.Printf(\"%x\", md5.Sum(data))\n}\n</pre> </div> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/md5/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/md5/</a>\n  </p>\n</div>\n","container/ring/index":"<h1>Package ring</h1>     <ul id=\"short-nav\">\n<li><code>import \"container/ring\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package ring implements operations on circular lists. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Ring\">type Ring</a></li>\n<li> <a href=\"#New\">func New(n int) *Ring</a>\n</li>\n<li> <a href=\"#Ring.Do\">func (r *Ring) Do(f func(interface{}))</a>\n</li>\n<li> <a href=\"#Ring.Len\">func (r *Ring) Len() int</a>\n</li>\n<li> <a href=\"#Ring.Link\">func (r *Ring) Link(s *Ring) *Ring</a>\n</li>\n<li> <a href=\"#Ring.Move\">func (r *Ring) Move(n int) *Ring</a>\n</li>\n<li> <a href=\"#Ring.Next\">func (r *Ring) Next() *Ring</a>\n</li>\n<li> <a href=\"#Ring.Prev\">func (r *Ring) Prev() *Ring</a>\n</li>\n<li> <a href=\"#Ring.Unlink\">func (r *Ring) Unlink(n int) *Ring</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/container/ring/ring.go\">ring.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Ring\">type Ring  </h2> <pre data-language=\"go\">type Ring struct {\n        Value interface{} // for use by client; untouched by this library\n        // contains filtered or unexported fields\n}</pre> <p> A Ring is an element of a circular list, or ring. Rings do not have a beginning or end; a pointer to any ring element serves as reference to the entire ring. Empty rings are represented as nil Ring pointers. The zero value for a Ring is a one-element ring with a nil Value. </p> <h3 id=\"New\">func <a href=\"https://golang.org/src/container/ring/ring.go?s=1389:1410#L52\">New</a>  </h3> <pre data-language=\"go\">func New(n int) *Ring</pre> <p> New creates a ring of n elements. </p> <h3 id=\"Ring.Do\">func (*Ring) <a href=\"https://golang.org/src/container/ring/ring.go?s=3118:3156#L124\">Do</a>  </h3> <pre data-language=\"go\">func (r *Ring) Do(f func(interface{}))</pre> <p> Do calls function f on each element of the ring, in forward order. The behavior of Do is undefined if f changes *r. </p> <h3 id=\"Ring.Len\">func (*Ring) <a href=\"https://golang.org/src/container/ring/ring.go?s=2869:2893#L111\">Len</a>  </h3> <pre data-language=\"go\">func (r *Ring) Len() int</pre> <p> Len computes the number of elements in ring r. It executes in time proportional to the number of elements. </p> <h3 id=\"Ring.Link\">func (*Ring) <a href=\"https://golang.org/src/container/ring/ring.go?s=2221:2255#L83\">Link</a>  </h3> <pre data-language=\"go\">func (r *Ring) Link(s *Ring) *Ring</pre> <p> Link connects ring r with ring s such that r.Next() becomes s and returns the original value for r.Next(). r must not be empty. </p> <p> If r and s point to the same ring, linking them removes the elements between r and s from the ring. The removed elements form a subring and the result is a reference to that subring (if no elements were removed, the result is still the original value for r.Next(), and not nil). </p> <p> If r and s point to different rings, linking them creates a single ring with the elements of s inserted after r. The result points to the element following the last element of s after insertion. </p> <h3 id=\"Ring.Move\">func (*Ring) <a href=\"https://golang.org/src/container/ring/ring.go?s=1146:1178#L34\">Move</a>  </h3> <pre data-language=\"go\">func (r *Ring) Move(n int) *Ring</pre> <p> Move moves n % r.Len() elements backward (n &lt; 0) or forward (n &gt;= 0) in the ring and returns that ring element. r must not be empty. </p> <h3 id=\"Ring.Next\">func (*Ring) <a href=\"https://golang.org/src/container/ring/ring.go?s=762:789#L16\">Next</a>  </h3> <pre data-language=\"go\">func (r *Ring) Next() *Ring</pre> <p> Next returns the next ring element. r must not be empty. </p> <h3 id=\"Ring.Prev\">func (*Ring) <a href=\"https://golang.org/src/container/ring/ring.go?s=915:942#L24\">Prev</a>  </h3> <pre data-language=\"go\">func (r *Ring) Prev() *Ring</pre> <p> Prev returns the previous ring element. r must not be empty. </p> <h3 id=\"Ring.Unlink\">func (*Ring) <a href=\"https://golang.org/src/container/ring/ring.go?s=2654:2688#L101\">Unlink</a>  </h3> <pre data-language=\"go\">func (r *Ring) Unlink(n int) *Ring</pre> <p> Unlink removes n % r.Len() elements from the ring r, starting at r.Next(). If n % r.Len() == 0, r remains unchanged. The result is the removed subring. r must not be empty. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/container/ring/\" class=\"_attribution-link\">https://golang.org/pkg/container/ring/</a>\n  </p>\n</div>\n","crypto/index":"<h1>Package crypto</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package crypto collects common cryptographic constants. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#RegisterHash\">func RegisterHash(h Hash, f func() hash.Hash)</a></li>\n<li><a href=\"#Decrypter\">type Decrypter</a></li>\n<li><a href=\"#DecrypterOpts\">type DecrypterOpts</a></li>\n<li><a href=\"#Hash\">type Hash</a></li>\n<li> <a href=\"#Hash.Available\">func (h Hash) Available() bool</a>\n</li>\n<li> <a href=\"#Hash.HashFunc\">func (h Hash) HashFunc() Hash</a>\n</li>\n<li> <a href=\"#Hash.New\">func (h Hash) New() hash.Hash</a>\n</li>\n<li> <a href=\"#Hash.Size\">func (h Hash) Size() int</a>\n</li>\n<li><a href=\"#PrivateKey\">type PrivateKey</a></li>\n<li><a href=\"#PublicKey\">type PublicKey</a></li>\n<li><a href=\"#Signer\">type Signer</a></li>\n<li><a href=\"#SignerOpts\">type SignerOpts</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/crypto.go\">crypto.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"RegisterHash\">func RegisterHash  </h2> <pre data-language=\"go\">func RegisterHash(h Hash, f func() hash.Hash)</pre> <p> RegisterHash registers a function that returns a new instance of the given hash function. This is intended to be called from the init function in packages that implement hash functions. </p> <h2 id=\"Decrypter\">type Decrypter  </h2> <pre data-language=\"go\">type Decrypter interface {\n        // Public returns the public key corresponding to the opaque,\n        // private key.\n        Public() PublicKey\n\n        // Decrypt decrypts msg. The opts argument should be appropriate for\n        // the primitive used. See the documentation in each implementation for\n        // details.\n        Decrypt(rand io.Reader, msg []byte, opts DecrypterOpts) (plaintext []byte, err error)\n}</pre> <p> Decrypter is an interface for an opaque private key that can be used for asymmetric decryption operations. An example would be an RSA key kept in a hardware module. </p> <h2 id=\"DecrypterOpts\">type DecrypterOpts  </h2> <pre data-language=\"go\">type DecrypterOpts interface{}</pre> <h2 id=\"Hash\">type Hash  </h2> <pre data-language=\"go\">type Hash uint</pre> <p> Hash identifies a cryptographic hash function that is implemented in another package. </p> <pre data-language=\"go\">const (\n        MD4        Hash = 1 + iota // import golang.org/x/crypto/md4\n        MD5                        // import crypto/md5\n        SHA1                       // import crypto/sha1\n        SHA224                     // import crypto/sha256\n        SHA256                     // import crypto/sha256\n        SHA384                     // import crypto/sha512\n        SHA512                     // import crypto/sha512\n        MD5SHA1                    // no implementation; MD5+SHA1 used for TLS RSA\n        RIPEMD160                  // import golang.org/x/crypto/ripemd160\n        SHA3_224                   // import golang.org/x/crypto/sha3\n        SHA3_256                   // import golang.org/x/crypto/sha3\n        SHA3_384                   // import golang.org/x/crypto/sha3\n        SHA3_512                   // import golang.org/x/crypto/sha3\n        SHA512_224                 // import crypto/sha512\n        SHA512_256                 // import crypto/sha512\n\n)</pre> <h3 id=\"Hash.Available\">func (Hash) <a href=\"https://golang.org/src/crypto/crypto.go?s=2457:2487#L75\">Available</a>  </h3> <pre data-language=\"go\">func (h Hash) Available() bool</pre> <p> Available reports whether the given hash function is linked into the binary. </p> <h3 id=\"Hash.HashFunc\">func (Hash) <a href=\"https://golang.org/src/crypto/crypto.go?s=458:487#L9\">HashFunc</a>  </h3> <pre data-language=\"go\">func (h Hash) HashFunc() Hash</pre> <p> HashFunc simply returns the value of h so that Hash implements SignerOpts. </p> <h3 id=\"Hash.New\">func (Hash) <a href=\"https://golang.org/src/crypto/crypto.go?s=2174:2203#L64\">New</a>  </h3> <pre data-language=\"go\">func (h Hash) New() hash.Hash</pre> <p> New returns a new hash.Hash calculating the given hash function. New panics if the hash function is not linked into the binary. </p> <h3 id=\"Hash.Size\">func (Hash) <a href=\"https://golang.org/src/crypto/crypto.go?s=1855:1879#L53\">Size</a>  </h3> <pre data-language=\"go\">func (h Hash) Size() int</pre> <p> Size returns the length, in bytes, of a digest resulting from the given hash function. It doesn't require that the hash function in question be linked into the program. </p> <h2 id=\"PrivateKey\">type PrivateKey  </h2> <pre data-language=\"go\">type PrivateKey interface{}</pre> <p> PrivateKey represents a private key using an unspecified algorithm. </p> <h2 id=\"PublicKey\">type PublicKey  </h2> <pre data-language=\"go\">type PublicKey interface{}</pre> <p> PublicKey represents a public key using an unspecified algorithm. </p> <h2 id=\"Signer\">type Signer  </h2> <pre data-language=\"go\">type Signer interface {\n        // Public returns the public key corresponding to the opaque,\n        // private key.\n        Public() PublicKey\n\n        // Sign signs digest with the private key, possibly using entropy from\n        // rand. For an RSA key, the resulting signature should be either a\n        // PKCS#1 v1.5 or PSS signature (as indicated by opts). For an (EC)DSA\n        // key, it should be a DER-serialised, ASN.1 signature structure.\n        //\n        // Hash implements the SignerOpts interface and, in most cases, one can\n        // simply pass in the hash function used as opts. Sign may also attempt\n        // to type assert opts to other types in order to obtain algorithm\n        // specific values. See the documentation in each package for details.\n        //\n        // Note that when a signature of a hash of a larger message is needed,\n        // the caller is responsible for hashing the larger message and passing\n        // the hash (as digest) and the hash function (as opts) to Sign.\n        Sign(rand io.Reader, digest []byte, opts SignerOpts) (signature []byte, err error)\n}</pre> <p> Signer is an interface for an opaque private key that can be used for signing operations. For example, an RSA key kept in a hardware module. </p> <h2 id=\"SignerOpts\">type SignerOpts  </h2> <pre data-language=\"go\">type SignerOpts interface {\n        // HashFunc returns an identifier for the hash function used to produce\n        // the message passed to Signer.Sign, or else zero to indicate that no\n        // hashing was done.\n        HashFunc() Hash\n}</pre> <p> SignerOpts contains options for signing with a Signer. </p> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"aes/index\">aes</a> </td> <td class=\"pkg-synopsis\"> Package aes implements AES encryption (formerly Rijndael), as defined in U.S. Federal Information Processing Standards Publication 197. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"cipher/index\">cipher</a> </td> <td class=\"pkg-synopsis\"> Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"des/index\">des</a> </td> <td class=\"pkg-synopsis\"> Package des implements the Data Encryption Standard (DES) and the Triple Data Encryption Algorithm (TDEA) as defined in U.S. Federal Information Processing Standards Publication 46-3. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"dsa/index\">dsa</a> </td> <td class=\"pkg-synopsis\"> Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"ecdsa/index\">ecdsa</a> </td> <td class=\"pkg-synopsis\"> Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as defined in FIPS 186-3. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"elliptic/index\">elliptic</a> </td> <td class=\"pkg-synopsis\"> Package elliptic implements several standard elliptic curves over prime fields. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"hmac/index\">hmac</a> </td> <td class=\"pkg-synopsis\"> Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"md5/index\">md5</a> </td> <td class=\"pkg-synopsis\"> Package md5 implements the MD5 hash algorithm as defined in RFC 1321. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"rand/index\">rand</a> </td> <td class=\"pkg-synopsis\"> Package rand implements a cryptographically secure pseudorandom number generator. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"rc4/index\">rc4</a> </td> <td class=\"pkg-synopsis\"> Package rc4 implements RC4 encryption, as defined in Bruce Schneier's Applied Cryptography. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"rsa/index\">rsa</a> </td> <td class=\"pkg-synopsis\"> Package rsa implements RSA encryption as specified in PKCS#1. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"sha1/index\">sha1</a> </td> <td class=\"pkg-synopsis\"> Package sha1 implements the SHA1 hash algorithm as defined in RFC 3174. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"sha256/index\">sha256</a> </td> <td class=\"pkg-synopsis\"> Package sha256 implements the SHA224 and SHA256 hash algorithms as defined in FIPS 180-4. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"sha512/index\">sha512</a> </td> <td class=\"pkg-synopsis\"> Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256 hash algorithms as defined in FIPS 180-4. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"subtle/index\">subtle</a> </td> <td class=\"pkg-synopsis\"> Package subtle implements functions that are often useful in cryptographic code but require careful thought to use correctly. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"tls/index\">tls</a> </td> <td class=\"pkg-synopsis\"> Package tls partially implements TLS 1.2, as specified in RFC 5246. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"x509/index\">x509</a> </td> <td class=\"pkg-synopsis\"> Package x509 parses X.509-encoded keys and certificates. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"x509/pkix/index\">pkix</a> </td> <td class=\"pkg-synopsis\"> Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/</a>\n  </p>\n</div>\n","crypto/rand/index":"<h1>Package rand</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/rand\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package rand implements a cryptographically secure pseudorandom number generator. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Int\">func Int(rand io.Reader, max *big.Int) (n *big.Int, err error)</a></li>\n<li><a href=\"#Prime\">func Prime(rand io.Reader, bits int) (p *big.Int, err error)</a></li>\n<li><a href=\"#Read\">func Read(b []byte) (n int, err error)</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Read\">Read</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/rand/eagain.go\">eagain.go</a> <a href=\"https://golang.org/src/crypto/rand/rand.go\">rand.go</a> <a href=\"https://golang.org/src/crypto/rand/rand_linux.go\">rand_linux.go</a> <a href=\"https://golang.org/src/crypto/rand/rand_unix.go\">rand_unix.go</a> <a href=\"https://golang.org/src/crypto/rand/util.go\">util.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var Reader io.Reader</pre> <p> Reader is a global, shared instance of a cryptographically strong pseudo-random generator. </p> <p> On Linux, Reader uses getrandom(2) if available, /dev/urandom otherwise. On OpenBSD, Reader uses getentropy(2). On other Unix-like systems, Reader reads from /dev/urandom. On Windows systems, Reader uses the CryptGenRandom API. </p> <h2 id=\"Int\">func Int  </h2> <pre data-language=\"go\">func Int(rand io.Reader, max *big.Int) (n *big.Int, err error)</pre> <p> Int returns a uniform random value in [0, max). It panics if max &lt;= 0. </p> <h2 id=\"Prime\">func Prime  </h2> <pre data-language=\"go\">func Prime(rand io.Reader, bits int) (p *big.Int, err error)</pre> <p> Prime returns a number, p, of the given size, such that p is prime with high probability. Prime will return error for any error returned by rand.Read or if bits &lt; 2. </p> <h2 id=\"Read\">func Read  </h2> <pre data-language=\"go\">func Read(b []byte) (n int, err error)</pre> <p> Read is a helper function that calls Reader.Read using io.ReadFull. On return, n == len(b) if and only if err == nil. </p> <div id=\"example_Read\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>This example reads 10 cryptographically secure pseudorandom numbers from rand.Reader and writes them to a byte slice. </p> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tc := 10\n\tb := make([]byte, c)\n\t_, err := rand.Read(b)\n\tif err != nil {\n\t\tfmt.Println(\"error:\", err)\n\t\treturn\n\t}\n\t// The slice should now contain random bytes instead of only zeroes.\n\tfmt.Println(bytes.Equal(b, make([]byte, c)))\n\n}\n</pre> </div> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/rand/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/rand/</a>\n  </p>\n</div>\n","database/index":"<h1>Directory /src/database</h1>    <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"sql/index\">sql</a> </td> <td class=\"pkg-synopsis\"> Package sql provides a generic interface around SQL (or SQL-like) databases. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"sql/driver/index\">driver</a> </td> <td class=\"pkg-synopsis\"> Package driver defines interfaces to be implemented by database drivers as used by package sql. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/database/\" class=\"_attribution-link\">https://golang.org/pkg/database/</a>\n  </p>\n</div>\n","crypto/rc4/index":"<h1>Package rc4</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/rc4\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package rc4 implements RC4 encryption, as defined in Bruce Schneier's Applied Cryptography. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Cipher\">type Cipher</a></li>\n<li> <a href=\"#NewCipher\">func NewCipher(key []byte) (*Cipher, error)</a>\n</li>\n<li> <a href=\"#Cipher.Reset\">func (c *Cipher) Reset()</a>\n</li>\n<li> <a href=\"#Cipher.XORKeyStream\">func (c *Cipher) XORKeyStream(dst, src []byte)</a>\n</li>\n<li><a href=\"#KeySizeError\">type KeySizeError</a></li>\n<li> <a href=\"#KeySizeError.Error\">func (k KeySizeError) Error() string</a>\n</li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/rc4/rc4.go\">rc4.go</a> <a href=\"https://golang.org/src/crypto/rc4/rc4_asm.go\">rc4_asm.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Cipher\">type Cipher  </h2> <pre data-language=\"go\">type Cipher struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Cipher is an instance of RC4 using a particular key. </p> <h3 id=\"NewCipher\">func <a href=\"https://golang.org/src/crypto/rc4/rc4.go?s=768:811#L18\">NewCipher</a>  </h3> <pre data-language=\"go\">func NewCipher(key []byte) (*Cipher, error)</pre> <p> NewCipher creates and returns a new Cipher. The key argument should be the RC4 key, at least 1 byte and at most 256 bytes. </p> <h3 id=\"Cipher.Reset\">func (*Cipher) <a href=\"https://golang.org/src/crypto/rc4/rc4.go?s=1173:1197#L37\">Reset</a>  </h3> <pre data-language=\"go\">func (c *Cipher) Reset()</pre> <p> Reset zeros the key data so that it will no longer appear in the process's memory. </p> <h3 id=\"Cipher.XORKeyStream\">func (*Cipher) <a href=\"https://golang.org/src/crypto/rc4/rc4_asm.go?s=433:479#L3\">XORKeyStream</a>  </h3> <pre data-language=\"go\">func (c *Cipher) XORKeyStream(dst, src []byte)</pre> <p> XORKeyStream sets dst to the result of XORing src with the key stream. Dst and src may be the same slice but otherwise should not overlap. </p> <h2 id=\"KeySizeError\">type KeySizeError  </h2> <pre data-language=\"go\">type KeySizeError int</pre> <h3 id=\"KeySizeError.Error\">func (KeySizeError) <a href=\"https://golang.org/src/crypto/rc4/rc4.go?s=534:570#L12\">Error</a>  </h3> <pre data-language=\"go\">func (k KeySizeError) Error() string</pre> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/crypto/rc4/rc4.go?s=271:379#L1\" style=\"float: left;\">☞</a> <p> RC4 is in common use but has design weaknesses that make it a poor choice for new protocols. </p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/rc4/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/rc4/</a>\n  </p>\n</div>\n","crypto/sha1/index":"<h1>Package sha1</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/sha1\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package sha1 implements the SHA1 hash algorithm as defined in RFC 3174. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#New\">func New() hash.Hash</a></li>\n<li><a href=\"#Sum\">func Sum(data []byte) [Size]byte</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_New\">New</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Sum\">Sum</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/sha1/sha1.go\">sha1.go</a> <a href=\"https://golang.org/src/crypto/sha1/sha1block.go\">sha1block.go</a> <a href=\"https://golang.org/src/crypto/sha1/sha1block_amd64.go\">sha1block_amd64.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const BlockSize = 64</pre> <p> The blocksize of SHA1 in bytes. </p> <pre data-language=\"go\">const Size = 20</pre> <p> The size of a SHA1 checksum in bytes. </p> <h2 id=\"New\">func New  </h2> <pre data-language=\"go\">func New() hash.Hash</pre> <p> New returns a new hash.Hash computing the SHA1 checksum. </p> <div id=\"example_New\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/sha1\"\n\t\"fmt\"\n\t\"io\"\n)\n\nfunc main() {\n\th := sha1.New()\n\tio.WriteString(h, \"His money is twice tainted:\")\n\tio.WriteString(h, \" 'taint yours and 'taint mine.\")\n\tfmt.Printf(\"% x\", h.Sum(nil))\n}\n</pre> </div> </div> <h2 id=\"Sum\">func Sum  </h2> <pre data-language=\"go\">func Sum(data []byte) [Size]byte</pre> <p> Sum returns the SHA1 checksum of the data. </p> <div id=\"example_Sum\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/sha1\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tdata := []byte(\"This page intentionally left blank.\")\n\tfmt.Printf(\"% x\", sha1.Sum(data))\n}\n</pre> </div> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/sha1/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/sha1/</a>\n  </p>\n</div>\n","debug/index":"<h1>Directory /src/debug</h1>    <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"dwarf/index\">dwarf</a> </td> <td class=\"pkg-synopsis\"> Package dwarf provides access to DWARF debugging information loaded from executable files, as defined in the DWARF 2.0 Standard at http://dwarfstd.org/doc/dwarf-2.0.0.pdf </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"elf/index\">elf</a> </td> <td class=\"pkg-synopsis\"> Package elf implements access to ELF object files. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"gosym/index\">gosym</a> </td> <td class=\"pkg-synopsis\"> Package gosym implements access to the Go symbol and line number tables embedded in Go binaries generated by the gc compilers. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"macho/index\">macho</a> </td> <td class=\"pkg-synopsis\"> Package macho implements access to Mach-O object files. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"pe/index\">pe</a> </td> <td class=\"pkg-synopsis\"> Package pe implements access to PE (Microsoft Windows Portable Executable) files. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"plan9obj/index\">plan9obj</a> </td> <td class=\"pkg-synopsis\"> Package plan9obj implements access to Plan 9 a.out object files. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/debug/\" class=\"_attribution-link\">https://golang.org/pkg/debug/</a>\n  </p>\n</div>\n","crypto/sha256/index":"<h1>Package sha256</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/sha256\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package sha256 implements the SHA224 and SHA256 hash algorithms as defined in FIPS 180-4. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#New\">func New() hash.Hash</a></li>\n<li><a href=\"#New224\">func New224() hash.Hash</a></li>\n<li><a href=\"#Sum224\">func Sum224(data []byte) (sum224 [Size224]byte)</a></li>\n<li><a href=\"#Sum256\">func Sum256(data []byte) [Size]byte</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/sha256/sha256.go\">sha256.go</a> <a href=\"https://golang.org/src/crypto/sha256/sha256block.go\">sha256block.go</a> <a href=\"https://golang.org/src/crypto/sha256/sha256block_decl.go\">sha256block_decl.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const BlockSize = 64</pre> <p> The blocksize of SHA256 and SHA224 in bytes. </p> <pre data-language=\"go\">const Size = 32</pre> <p> The size of a SHA256 checksum in bytes. </p> <pre data-language=\"go\">const Size224 = 28</pre> <p> The size of a SHA224 checksum in bytes. </p> <h2 id=\"New\">func New  </h2> <pre data-language=\"go\">func New() hash.Hash</pre> <p> New returns a new hash.Hash computing the SHA256 checksum. </p> <h2 id=\"New224\">func New224  </h2> <pre data-language=\"go\">func New224() hash.Hash</pre> <p> New224 returns a new hash.Hash computing the SHA224 checksum. </p> <h2 id=\"Sum224\">func Sum224  </h2> <pre data-language=\"go\">func Sum224(data []byte) (sum224 [Size224]byte)</pre> <p> Sum224 returns the SHA224 checksum of the data. </p> <h2 id=\"Sum256\">func Sum256  </h2> <pre data-language=\"go\">func Sum256(data []byte) [Size]byte</pre> <p> Sum256 returns the SHA256 checksum of the data. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/sha256/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/sha256/</a>\n  </p>\n</div>\n","crypto/subtle/index":"<h1>Package subtle</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/subtle\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package subtle implements functions that are often useful in cryptographic code but require careful thought to use correctly. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#ConstantTimeByteEq\">func ConstantTimeByteEq(x, y uint8) int</a></li>\n<li><a href=\"#ConstantTimeCompare\">func ConstantTimeCompare(x, y []byte) int</a></li>\n<li><a href=\"#ConstantTimeCopy\">func ConstantTimeCopy(v int, x, y []byte)</a></li>\n<li><a href=\"#ConstantTimeEq\">func ConstantTimeEq(x, y int32) int</a></li>\n<li><a href=\"#ConstantTimeLessOrEq\">func ConstantTimeLessOrEq(x, y int) int</a></li>\n<li><a href=\"#ConstantTimeSelect\">func ConstantTimeSelect(v, x, y int) int</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/subtle/constant_time.go\">constant_time.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"ConstantTimeByteEq\">func ConstantTimeByteEq  </h2> <pre data-language=\"go\">func ConstantTimeByteEq(x, y uint8) int</pre> <p> ConstantTimeByteEq returns 1 if x == y and 0 otherwise. </p> <h2 id=\"ConstantTimeCompare\">func ConstantTimeCompare  </h2> <pre data-language=\"go\">func ConstantTimeCompare(x, y []byte) int</pre> <p> ConstantTimeCompare returns 1 if and only if the two slices, x and y, have equal contents. The time taken is a function of the length of the slices and is independent of the contents. </p> <h2 id=\"ConstantTimeCopy\">func ConstantTimeCopy  </h2> <pre data-language=\"go\">func ConstantTimeCopy(v int, x, y []byte)</pre> <p> ConstantTimeCopy copies the contents of y into x (a slice of equal length) if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v takes any other value. </p> <h2 id=\"ConstantTimeEq\">func ConstantTimeEq  </h2> <pre data-language=\"go\">func ConstantTimeEq(x, y int32) int</pre> <p> ConstantTimeEq returns 1 if x == y and 0 otherwise. </p> <h2 id=\"ConstantTimeLessOrEq\">func ConstantTimeLessOrEq  </h2> <pre data-language=\"go\">func ConstantTimeLessOrEq(x, y int) int</pre> <p> ConstantTimeLessOrEq returns 1 if x &lt;= y and 0 otherwise. Its behavior is undefined if x or y are negative or &gt; 2**31 - 1. </p> <h2 id=\"ConstantTimeSelect\">func ConstantTimeSelect  </h2> <pre data-language=\"go\">func ConstantTimeSelect(v, x, y int) int</pre> <p> ConstantTimeSelect returns x if v is 1 and y if v is 0. Its behavior is undefined if v takes any other value. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/subtle/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/subtle/</a>\n  </p>\n</div>\n","compress/flate/index":"<h1>Package flate</h1>     <ul id=\"short-nav\">\n<li><code>import \"compress/flate\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package flate implements the DEFLATE compressed data format, described in RFC 1951. The gzip and zlib packages implement access to DEFLATE-based file formats. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#NewReader\">func NewReader(r io.Reader) io.ReadCloser</a></li>\n<li><a href=\"#NewReaderDict\">func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser</a></li>\n<li><a href=\"#CorruptInputError\">type CorruptInputError</a></li>\n<li> <a href=\"#CorruptInputError.Error\">func (e CorruptInputError) Error() string</a>\n</li>\n<li><a href=\"#InternalError\">type InternalError</a></li>\n<li> <a href=\"#InternalError.Error\">func (e InternalError) Error() string</a>\n</li>\n<li><a href=\"#ReadError\">type ReadError</a></li>\n<li> <a href=\"#ReadError.Error\">func (e *ReadError) Error() string</a>\n</li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li><a href=\"#Resetter\">type Resetter</a></li>\n<li><a href=\"#WriteError\">type WriteError</a></li>\n<li> <a href=\"#WriteError.Error\">func (e *WriteError) Error() string</a>\n</li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#NewWriter\">func NewWriter(w io.Writer, level int) (*Writer, error)</a>\n</li>\n<li> <a href=\"#NewWriterDict\">func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)</a>\n</li>\n<li> <a href=\"#Writer.Close\">func (w *Writer) Close() error</a>\n</li>\n<li> <a href=\"#Writer.Flush\">func (w *Writer) Flush() error</a>\n</li>\n<li> <a href=\"#Writer.Reset\">func (w *Writer) Reset(dst io.Writer)</a>\n</li>\n<li> <a href=\"#Writer.Write\">func (w *Writer) Write(data []byte) (n int, err error)</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/compress/flate/deflate.go\">deflate.go</a> <a href=\"https://golang.org/src/compress/flate/deflatefast.go\">deflatefast.go</a> <a href=\"https://golang.org/src/compress/flate/dict_decoder.go\">dict_decoder.go</a> <a href=\"https://golang.org/src/compress/flate/huffman_bit_writer.go\">huffman_bit_writer.go</a> <a href=\"https://golang.org/src/compress/flate/huffman_code.go\">huffman_code.go</a> <a href=\"https://golang.org/src/compress/flate/inflate.go\">inflate.go</a> <a href=\"https://golang.org/src/compress/flate/reverse_bits.go\">reverse_bits.go</a> <a href=\"https://golang.org/src/compress/flate/token.go\">token.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        NoCompression      = 0\n        BestSpeed          = 1\n        BestCompression    = 9\n        DefaultCompression = -1\n\n        // HuffmanOnly disables Lempel-Ziv match searching and only performs Huffman\n        // entropy encoding. This mode is useful in compressing data that has\n        // already been compressed with an LZ style algorithm (e.g. Snappy or LZ4)\n        // that lacks an entropy encoder. Compression gains are achieved when\n        // certain bytes in the input stream occur more frequently than others.\n        //\n        // Note that HuffmanOnly produces a compressed output that is\n        // RFC 1951 compliant. That is, any valid DEFLATE decompressor will\n        // continue to be able to decompress this output.\n        HuffmanOnly = -2\n)</pre> <h2 id=\"NewReader\">func NewReader  </h2> <pre data-language=\"go\">func NewReader(r io.Reader) io.ReadCloser</pre> <p> NewReader returns a new ReadCloser that can be used to read the uncompressed version of r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading. </p> <p> The ReadCloser returned by NewReader also implements Resetter. </p> <h2 id=\"NewReaderDict\">func NewReaderDict  </h2> <pre data-language=\"go\">func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser</pre> <p> NewReaderDict is like NewReader but initializes the reader with a preset dictionary. The returned Reader behaves as if the uncompressed data stream started with the given dictionary, which has already been read. NewReaderDict is typically used to read data compressed by NewWriterDict. </p> <p> The ReadCloser returned by NewReader also implements Resetter. </p> <h2 id=\"CorruptInputError\">type CorruptInputError  </h2> <pre data-language=\"go\">type CorruptInputError int64</pre> <p> A CorruptInputError reports the presence of corrupt input at a given offset. </p> <h3 id=\"CorruptInputError.Error\">func (CorruptInputError) <a href=\"https://golang.org/src/compress/flate/inflate.go?s=974:1015#L24\">Error</a>  </h3> <pre data-language=\"go\">func (e CorruptInputError) Error() string</pre> <h2 id=\"InternalError\">type InternalError  </h2> <pre data-language=\"go\">type InternalError string</pre> <p> An InternalError reports an error in the flate code itself. </p> <h3 id=\"InternalError.Error\">func (InternalError) <a href=\"https://golang.org/src/compress/flate/inflate.go?s=1191:1228#L31\">Error</a>  </h3> <pre data-language=\"go\">func (e InternalError) Error() string</pre> <h2 id=\"ReadError\">type ReadError  </h2> <pre data-language=\"go\">type ReadError struct {\n        Offset int64 // byte offset where error occurred\n        Err    error // error returned by underlying Read\n}</pre> <p> A ReadError reports an error encountered while reading input. </p> <p> Deprecated: No longer returned. </p> <h3 id=\"ReadError.Error\">func (*ReadError) <a href=\"https://golang.org/src/compress/flate/inflate.go?s=1510:1544#L41\">Error</a>  </h3> <pre data-language=\"go\">func (e *ReadError) Error() string</pre> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader interface {\n        io.Reader\n        io.ByteReader\n}</pre> <p> The actual read interface needed by NewReader. If the passed in io.Reader does not also have ReadByte, the NewReader will introduce its own buffering. </p> <h2 id=\"Resetter\">type Resetter  </h2> <pre data-language=\"go\">type Resetter interface {\n        // Reset discards any buffered data and resets the Resetter as if it was\n        // newly initialized with the given reader.\n        Reset(r io.Reader, dict []byte) error\n}</pre> <p> Resetter resets a ReadCloser returned by NewReader or NewReaderDict to to switch to a new underlying Reader. This permits reusing a ReadCloser instead of allocating a new one. </p> <h2 id=\"WriteError\">type WriteError  </h2> <pre data-language=\"go\">type WriteError struct {\n        Offset int64 // byte offset where error occurred\n        Err    error // error returned by underlying Write\n}</pre> <p> A WriteError reports an error encountered while writing output. </p> <p> Deprecated: No longer returned. </p> <h3 id=\"WriteError.Error\">func (*WriteError) <a href=\"https://golang.org/src/compress/flate/inflate.go?s=1881:1916#L53\">Error</a>  </h3> <pre data-language=\"go\">func (e *WriteError) Error() string</pre> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Writer takes data written to it and writes the compressed form of that data to an underlying writer (see NewWriter). </p> <h3 id=\"NewWriter\">func <a href=\"https://golang.org/src/compress/flate/deflate.go?s=18136:18191#L649\">NewWriter</a>  </h3> <pre data-language=\"go\">func NewWriter(w io.Writer, level int) (*Writer, error)</pre> <p> NewWriter returns a new Writer compressing data at the given level. Following zlib, levels range from 1 (BestSpeed) to 9 (BestCompression); higher levels typically run slower but compress more. Level 0 (NoCompression) does not attempt any compression; it only adds the necessary DEFLATE framing. Level -1 (DefaultCompression) uses the default compression level. Level -2 (HuffmanOnly) will use Huffman compression only, giving a very fast compression for all types of input, but sacrificing considerable compression efficiency. </p> <p> If level is in the range [-2, 9] then the error returned will be nil. Otherwise the error returned will be non-nil. </p> <h3 id=\"NewWriterDict\">func <a href=\"https://golang.org/src/compress/flate/deflate.go?s=18623:18695#L663\">NewWriterDict</a>  </h3> <pre data-language=\"go\">func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)</pre> <p> NewWriterDict is like NewWriter but initializes the new Writer with a preset dictionary. The returned Writer behaves as if the dictionary had been written to it without producing any compressed output. The compressed data written to w can only be decompressed by a Reader initialized with the same dictionary. </p> <h3 id=\"Writer.Close\">func (*Writer) <a href=\"https://golang.org/src/compress/flate/deflate.go?s=20005:20035#L709\">Close</a>  </h3> <pre data-language=\"go\">func (w *Writer) Close() error</pre> <p> Close flushes and closes the writer. </p> <h3 id=\"Writer.Flush\">func (*Writer) <a href=\"https://golang.org/src/compress/flate/deflate.go?s=19824:19854#L702\">Flush</a>  </h3> <pre data-language=\"go\">func (w *Writer) Flush() error</pre> <p> Flush flushes any pending compressed data to the underlying writer. It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. If the underlying writer returns an error, Flush returns that error. </p> <p> In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH. </p> <h3 id=\"Writer.Reset\">func (*Writer) <a href=\"https://golang.org/src/compress/flate/deflate.go?s=20218:20255#L716\">Reset</a>  </h3> <pre data-language=\"go\">func (w *Writer) Reset(dst io.Writer)</pre> <p> Reset discards the writer's state and makes it equivalent to the result of NewWriter or NewWriterDict called with dst and w's level and dictionary. </p> <h3 id=\"Writer.Write\">func (*Writer) <a href=\"https://golang.org/src/compress/flate/deflate.go?s=19325:19379#L691\">Write</a>  </h3> <pre data-language=\"go\">func (w *Writer) Write(data []byte) (n int, err error)</pre> <p> Write writes data to w, which will eventually write the compressed form of data to its underlying writer. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/compress/flate/\" class=\"_attribution-link\">https://golang.org/pkg/compress/flate/</a>\n  </p>\n</div>\n","crypto/sha512/index":"<h1>Package sha512</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/sha512\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256 hash algorithms as defined in FIPS 180-4. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#New\">func New() hash.Hash</a></li>\n<li><a href=\"#New384\">func New384() hash.Hash</a></li>\n<li><a href=\"#New512_224\">func New512_224() hash.Hash</a></li>\n<li><a href=\"#New512_256\">func New512_256() hash.Hash</a></li>\n<li><a href=\"#Sum384\">func Sum384(data []byte) (sum384 [Size384]byte)</a></li>\n<li><a href=\"#Sum512\">func Sum512(data []byte) [Size]byte</a></li>\n<li><a href=\"#Sum512_224\">func Sum512_224(data []byte) (sum224 [Size224]byte)</a></li>\n<li><a href=\"#Sum512_256\">func Sum512_256(data []byte) (sum256 [Size256]byte)</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/sha512/sha512.go\">sha512.go</a> <a href=\"https://golang.org/src/crypto/sha512/sha512block.go\">sha512block.go</a> <a href=\"https://golang.org/src/crypto/sha512/sha512block_decl.go\">sha512block_decl.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        // Size is the size, in bytes, of a SHA-512 checksum.\n        Size = 64\n\n        // Size224 is the size, in bytes, of a SHA-512/224 checksum.\n        Size224 = 28\n\n        // Size256 is the size, in bytes, of a SHA-512/256 checksum.\n        Size256 = 32\n\n        // Size384 is the size, in bytes, of a SHA-384 checksum.\n        Size384 = 48\n\n        // BlockSize is the block size, in bytes, of the SHA-512/224,\n        // SHA-512/256, SHA-384 and SHA-512 hash functions.\n        BlockSize = 128\n)</pre> <h2 id=\"New\">func New  </h2> <pre data-language=\"go\">func New() hash.Hash</pre> <p> New returns a new hash.Hash computing the SHA-512 checksum. </p> <h2 id=\"New384\">func New384  </h2> <pre data-language=\"go\">func New384() hash.Hash</pre> <p> New384 returns a new hash.Hash computing the SHA-384 checksum. </p> <h2 id=\"New512_224\">func New512_224  </h2> <pre data-language=\"go\">func New512_224() hash.Hash</pre> <p> New512_224 returns a new hash.Hash computing the SHA-512/224 checksum. </p> <h2 id=\"New512_256\">func New512_256  </h2> <pre data-language=\"go\">func New512_256() hash.Hash</pre> <p> New512_256 returns a new hash.Hash computing the SHA-512/256 checksum. </p> <h2 id=\"Sum384\">func Sum384  </h2> <pre data-language=\"go\">func Sum384(data []byte) (sum384 [Size384]byte)</pre> <p> Sum384 returns the SHA384 checksum of the data. </p> <h2 id=\"Sum512\">func Sum512  </h2> <pre data-language=\"go\">func Sum512(data []byte) [Size]byte</pre> <p> Sum512 returns the SHA512 checksum of the data. </p> <h2 id=\"Sum512_224\">func Sum512_224  </h2> <pre data-language=\"go\">func Sum512_224(data []byte) (sum224 [Size224]byte)</pre> <p> Sum512_224 returns the Sum512/224 checksum of the data. </p> <h2 id=\"Sum512_256\">func Sum512_256  </h2> <pre data-language=\"go\">func Sum512_256(data []byte) (sum256 [Size256]byte)</pre> <p> Sum512_256 returns the Sum512/256 checksum of the data. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/sha512/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/sha512/</a>\n  </p>\n</div>\n","crypto/x509/pkix/index":"<h1>Package pkix</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/x509/pkix\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#AlgorithmIdentifier\">type AlgorithmIdentifier</a></li>\n<li><a href=\"#AttributeTypeAndValue\">type AttributeTypeAndValue</a></li>\n<li><a href=\"#AttributeTypeAndValueSET\">type AttributeTypeAndValueSET</a></li>\n<li><a href=\"#CertificateList\">type CertificateList</a></li>\n<li> <a href=\"#CertificateList.HasExpired\">func (certList *CertificateList) HasExpired(now time.Time) bool</a>\n</li>\n<li><a href=\"#Extension\">type Extension</a></li>\n<li><a href=\"#Name\">type Name</a></li>\n<li> <a href=\"#Name.FillFromRDNSequence\">func (n *Name) FillFromRDNSequence(rdns *RDNSequence)</a>\n</li>\n<li> <a href=\"#Name.ToRDNSequence\">func (n Name) ToRDNSequence() (ret RDNSequence)</a>\n</li>\n<li><a href=\"#RDNSequence\">type RDNSequence</a></li>\n<li><a href=\"#RelativeDistinguishedNameSET\">type RelativeDistinguishedNameSET</a></li>\n<li><a href=\"#RevokedCertificate\">type RevokedCertificate</a></li>\n<li><a href=\"#TBSCertificateList\">type TBSCertificateList</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/x509/pkix/pkix.go\">pkix.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"AlgorithmIdentifier\">type AlgorithmIdentifier  </h2> <pre data-language=\"go\">type AlgorithmIdentifier struct {\n        Algorithm  asn1.ObjectIdentifier\n        Parameters asn1.RawValue `asn1:\"optional\"`\n}</pre> <p> AlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC 5280, section 4.1.1.2. </p> <h2 id=\"AttributeTypeAndValue\">type AttributeTypeAndValue  </h2> <pre data-language=\"go\">type AttributeTypeAndValue struct {\n        Type  asn1.ObjectIdentifier\n        Value interface{}\n}</pre> <p> AttributeTypeAndValue mirrors the ASN.1 structure of the same name in <a href=\"http://tools.ietf.org/html/rfc5280#section-4.1.2.4\">http://tools.ietf.org/html/rfc5280#section-4.1.2.4</a> </p> <h2 id=\"AttributeTypeAndValueSET\">type AttributeTypeAndValueSET  </h2> <pre data-language=\"go\">type AttributeTypeAndValueSET struct {\n        Type  asn1.ObjectIdentifier\n        Value [][]AttributeTypeAndValue `asn1:\"set\"`\n}</pre> <p> AttributeTypeAndValueSET represents a set of ASN.1 sequences of AttributeTypeAndValue sequences from RFC 2986 (PKCS #10). </p> <h2 id=\"CertificateList\">type CertificateList  </h2> <pre data-language=\"go\">type CertificateList struct {\n        TBSCertList        TBSCertificateList\n        SignatureAlgorithm AlgorithmIdentifier\n        SignatureValue     asn1.BitString\n}</pre> <p> CertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1. Use Certificate.CheckCRLSignature to verify the signature. </p> <h3 id=\"CertificateList.HasExpired\">func (*CertificateList) <a href=\"https://golang.org/src/crypto/x509/pkix/pkix.go?s=5185:5248#L162\">HasExpired</a>  </h3> <pre data-language=\"go\">func (certList *CertificateList) HasExpired(now time.Time) bool</pre> <p> HasExpired reports whether now is past the expiry time of certList. </p> <h2 id=\"Extension\">type Extension  </h2> <pre data-language=\"go\">type Extension struct {\n        Id       asn1.ObjectIdentifier\n        Critical bool `asn1:\"optional\"`\n        Value    []byte\n}</pre> <p> Extension represents the ASN.1 structure of the same name. See RFC 5280, section 4.2. </p> <h2 id=\"Name\">type Name  </h2> <pre data-language=\"go\">type Name struct {\n        Country, Organization, OrganizationalUnit []string\n        Locality, Province                        []string\n        StreetAddress, PostalCode                 []string\n        SerialNumber, CommonName                  string\n\n        Names      []AttributeTypeAndValue\n        ExtraNames []AttributeTypeAndValue\n}</pre> <p> Name represents an X.509 distinguished name. This only includes the common elements of a DN. When parsing, all elements are stored in Names and non-standard elements can be extracted from there. When marshaling, elements in ExtraNames are appended and override other values with the same OID. </p> <h3 id=\"Name.FillFromRDNSequence\">func (*Name) <a href=\"https://golang.org/src/crypto/x509/pkix/pkix.go?s=1953:2006#L52\">FillFromRDNSequence</a>  </h3> <pre data-language=\"go\">func (n *Name) FillFromRDNSequence(rdns *RDNSequence)</pre> <h3 id=\"Name.ToRDNSequence\">func (Name) <a href=\"https://golang.org/src/crypto/x509/pkix/pkix.go?s=3790:3837#L120\">ToRDNSequence</a>  </h3> <pre data-language=\"go\">func (n Name) ToRDNSequence() (ret RDNSequence)</pre> <h2 id=\"RDNSequence\">type RDNSequence  </h2> <pre data-language=\"go\">type RDNSequence []RelativeDistinguishedNameSET</pre> <h2 id=\"RelativeDistinguishedNameSET\">type RelativeDistinguishedNameSET  </h2> <pre data-language=\"go\">type RelativeDistinguishedNameSET []AttributeTypeAndValue</pre> <h2 id=\"RevokedCertificate\">type RevokedCertificate  </h2> <pre data-language=\"go\">type RevokedCertificate struct {\n        SerialNumber   *big.Int\n        RevocationTime time.Time\n        Extensions     []Extension `asn1:\"optional\"`\n}</pre> <p> RevokedCertificate represents the ASN.1 structure of the same name. See RFC 5280, section 5.1. </p> <h2 id=\"TBSCertificateList\">type TBSCertificateList  </h2> <pre data-language=\"go\">type TBSCertificateList struct {\n        Raw                 asn1.RawContent\n        Version             int `asn1:\"optional,default:0\"`\n        Signature           AlgorithmIdentifier\n        Issuer              RDNSequence\n        ThisUpdate          time.Time\n        NextUpdate          time.Time            `asn1:\"optional\"`\n        RevokedCertificates []RevokedCertificate `asn1:\"optional\"`\n        Extensions          []Extension          `asn1:\"tag:0,optional,explicit\"`\n}</pre> <p> TBSCertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/x509/pkix/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/x509/pkix/</a>\n  </p>\n</div>\n","bufio/index":"<h1>Package bufio</h1>     <ul id=\"short-nav\">\n<li><code>import \"bufio\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#ScanBytes\">func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)</a></li>\n<li><a href=\"#ScanLines\">func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)</a></li>\n<li><a href=\"#ScanRunes\">func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)</a></li>\n<li><a href=\"#ScanWords\">func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)</a></li>\n<li><a href=\"#ReadWriter\">type ReadWriter</a></li>\n<li> <a href=\"#NewReadWriter\">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</a>\n</li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li> <a href=\"#NewReader\">func NewReader(rd io.Reader) *Reader</a>\n</li>\n<li> <a href=\"#NewReaderSize\">func NewReaderSize(rd io.Reader, size int) *Reader</a>\n</li>\n<li> <a href=\"#Reader.Buffered\">func (b *Reader) Buffered() int</a>\n</li>\n<li> <a href=\"#Reader.Discard\">func (b *Reader) Discard(n int) (discarded int, err error)</a>\n</li>\n<li> <a href=\"#Reader.Peek\">func (b *Reader) Peek(n int) ([]byte, error)</a>\n</li>\n<li> <a href=\"#Reader.Read\">func (b *Reader) Read(p []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#Reader.ReadByte\">func (b *Reader) ReadByte() (byte, error)</a>\n</li>\n<li> <a href=\"#Reader.ReadBytes\">func (b *Reader) ReadBytes(delim byte) ([]byte, error)</a>\n</li>\n<li> <a href=\"#Reader.ReadLine\">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</a>\n</li>\n<li> <a href=\"#Reader.ReadRune\">func (b *Reader) ReadRune() (r rune, size int, err error)</a>\n</li>\n<li> <a href=\"#Reader.ReadSlice\">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</a>\n</li>\n<li> <a href=\"#Reader.ReadString\">func (b *Reader) ReadString(delim byte) (string, error)</a>\n</li>\n<li> <a href=\"#Reader.Reset\">func (b *Reader) Reset(r io.Reader)</a>\n</li>\n<li> <a href=\"#Reader.UnreadByte\">func (b *Reader) UnreadByte() error</a>\n</li>\n<li> <a href=\"#Reader.UnreadRune\">func (b *Reader) UnreadRune() error</a>\n</li>\n<li> <a href=\"#Reader.WriteTo\">func (b *Reader) WriteTo(w io.Writer) (n int64, err error)</a>\n</li>\n<li><a href=\"#Scanner\">type Scanner</a></li>\n<li> <a href=\"#NewScanner\">func NewScanner(r io.Reader) *Scanner</a>\n</li>\n<li> <a href=\"#Scanner.Buffer\">func (s *Scanner) Buffer(buf []byte, max int)</a>\n</li>\n<li> <a href=\"#Scanner.Bytes\">func (s *Scanner) Bytes() []byte</a>\n</li>\n<li> <a href=\"#Scanner.Err\">func (s *Scanner) Err() error</a>\n</li>\n<li> <a href=\"#Scanner.Scan\">func (s *Scanner) Scan() bool</a>\n</li>\n<li> <a href=\"#Scanner.Split\">func (s *Scanner) Split(split SplitFunc)</a>\n</li>\n<li> <a href=\"#Scanner.Text\">func (s *Scanner) Text() string</a>\n</li>\n<li><a href=\"#SplitFunc\">type SplitFunc</a></li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#NewWriter\">func NewWriter(w io.Writer) *Writer</a>\n</li>\n<li> <a href=\"#NewWriterSize\">func NewWriterSize(w io.Writer, size int) *Writer</a>\n</li>\n<li> <a href=\"#Writer.Available\">func (b *Writer) Available() int</a>\n</li>\n<li> <a href=\"#Writer.Buffered\">func (b *Writer) Buffered() int</a>\n</li>\n<li> <a href=\"#Writer.Flush\">func (b *Writer) Flush() error</a>\n</li>\n<li> <a href=\"#Writer.ReadFrom\">func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)</a>\n</li>\n<li> <a href=\"#Writer.Reset\">func (b *Writer) Reset(w io.Writer)</a>\n</li>\n<li> <a href=\"#Writer.Write\">func (b *Writer) Write(p []byte) (nn int, err error)</a>\n</li>\n<li> <a href=\"#Writer.WriteByte\">func (b *Writer) WriteByte(c byte) error</a>\n</li>\n<li> <a href=\"#Writer.WriteRune\">func (b *Writer) WriteRune(r rune) (size int, err error)</a>\n</li>\n<li> <a href=\"#Writer.WriteString\">func (b *Writer) WriteString(s string) (int, error)</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Scanner_custom\">Scanner (Custom)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Scanner_emptyFinalToken\">Scanner (EmptyFinalToken)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Scanner_lines\">Scanner (Lines)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Scanner_words\">Scanner (Words)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Writer\">Writer</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/bufio/bufio.go\">bufio.go</a> <a href=\"https://golang.org/src/bufio/scan.go\">scan.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        // MaxScanTokenSize is the maximum size used to buffer a token\n        // unless the user provides an explicit buffer with Scan.Buffer.\n        // The actual maximum token size may be smaller as the buffer\n        // may need to include, for instance, a newline.\n        MaxScanTokenSize = 64 * 1024\n)</pre> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        ErrInvalidUnreadByte = errors.New(\"bufio: invalid use of UnreadByte\")\n        ErrInvalidUnreadRune = errors.New(\"bufio: invalid use of UnreadRune\")\n        ErrBufferFull        = errors.New(\"bufio: buffer full\")\n        ErrNegativeCount     = errors.New(\"bufio: negative count\")\n)</pre> <pre data-language=\"go\">var (\n        ErrTooLong         = errors.New(\"bufio.Scanner: token too long\")\n        ErrNegativeAdvance = errors.New(\"bufio.Scanner: SplitFunc returns negative advance count\")\n        ErrAdvanceTooFar   = errors.New(\"bufio.Scanner: SplitFunc returns advance count beyond input\")\n)</pre> <p> Errors returned by Scanner. </p> <pre data-language=\"go\">var ErrFinalToken = errors.New(\"final token\")</pre> <p> ErrFinalToken is a special sentinel error value. It is intended to be returned by a Split function to indicate that the token being delivered with the error is the last token and scanning should stop after this one. After ErrFinalToken is received by Scan, scanning stops with no error. The value is useful to stop processing early or when it is necessary to deliver a final empty token. One could achieve the same behavior with a custom error value but providing one here is tidier. See the emptyFinalToken example for a use of this value. </p> <h2 id=\"ScanBytes\">func ScanBytes  </h2> <pre data-language=\"go\">func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)</pre> <p> ScanBytes is a split function for a Scanner that returns each byte as a token. </p> <h2 id=\"ScanLines\">func ScanLines  </h2> <pre data-language=\"go\">func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)</pre> <p> ScanLines is a split function for a Scanner that returns each line of text, stripped of any trailing end-of-line marker. The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline. In regular expression notation, it is `\\r?\\n`. The last non-empty line of input will be returned even if it has no newline. </p> <h2 id=\"ScanRunes\">func ScanRunes  </h2> <pre data-language=\"go\">func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)</pre> <p> ScanRunes is a split function for a Scanner that returns each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\". Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors. </p> <h2 id=\"ScanWords\">func ScanWords  </h2> <pre data-language=\"go\">func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)</pre> <p> ScanWords is a split function for a Scanner that returns each space-separated word of text, with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace. </p> <h2 id=\"ReadWriter\">type ReadWriter  </h2> <pre data-language=\"go\">type ReadWriter struct {\n        *Reader\n        *Writer\n}</pre> <p> ReadWriter stores pointers to a Reader and a Writer. It implements io.ReadWriter. </p> <h3 id=\"NewReadWriter\">func <a href=\"https://golang.org/src/bufio/bufio.go?s=17588:17640#L719\">NewReadWriter</a>  </h3> <pre data-language=\"go\">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</pre> <p> NewReadWriter allocates a new ReadWriter that dispatches to r and w. </p> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader struct {\n        // contains filtered or unexported fields\n}</pre> <p> Reader implements buffering for an io.Reader object. </p> <h3 id=\"NewReader\">func <a href=\"https://golang.org/src/bufio/bufio.go?s=1648:1684#L51\">NewReader</a>  </h3> <pre data-language=\"go\">func NewReader(rd io.Reader) *Reader</pre> <p> NewReader returns a new Reader whose buffer has the default size. </p> <h3 id=\"NewReaderSize\">func <a href=\"https://golang.org/src/bufio/bufio.go?s=1305:1355#L36\">NewReaderSize</a>  </h3> <pre data-language=\"go\">func NewReaderSize(rd io.Reader, size int) *Reader</pre> <p> NewReaderSize returns a new Reader whose buffer has at least the specified size. If the argument io.Reader is already a Reader with large enough size, it returns the underlying Reader. </p> <h3 id=\"Reader.Buffered\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=7039:7070#L283\">Buffered</a>  </h3> <pre data-language=\"go\">func (b *Reader) Buffered() int</pre> <p> Buffered returns the number of bytes that can be read from the current buffer. </p> <h3 id=\"Reader.Discard\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=3794:3852#L144\">Discard</a>  </h3> <pre data-language=\"go\">func (b *Reader) Discard(n int) (discarded int, err error)</pre> <p> Discard skips the next n bytes, returning the number of bytes discarded. </p> <p> If Discard skips fewer than n bytes, it also returns an error. If 0 &lt;= n &lt;= b.Buffered(), Discard is guaranteed to succeed without reading from the underlying io.Reader. </p> <h3 id=\"Reader.Peek\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=3036:3080#L113\">Peek</a>  </h3> <pre data-language=\"go\">func (b *Reader) Peek(n int) ([]byte, error)</pre> <p> Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call. If Peek returns fewer than n bytes, it also returns an error explaining why the read is short. The error is ErrBufferFull if n is larger than b's buffer size. </p> <h3 id=\"Reader.Read\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=4439:4489#L177\">Read</a>  </h3> <pre data-language=\"go\">func (b *Reader) Read(p []byte) (n int, err error)</pre> <p> Read reads data into p. It returns the number of bytes read into p. The bytes are taken from at most one Read on the underlying Reader, hence n may be less than len(p). At EOF, the count will be zero and err will be io.EOF. </p> <h3 id=\"Reader.ReadByte\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=5195:5236#L215\">ReadByte</a>  </h3> <pre data-language=\"go\">func (b *Reader) ReadByte() (byte, error)</pre> <p> ReadByte reads and returns a single byte. If no byte is available, returns an error. </p> <h3 id=\"Reader.ReadBytes\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=10494:10548#L390\">ReadBytes</a>  </h3> <pre data-language=\"go\">func (b *Reader) ReadBytes(delim byte) ([]byte, error)</pre> <p> ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient. </p> <h3 id=\"Reader.ReadLine\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=9301:9368#L348\">ReadLine</a>  </h3> <pre data-language=\"go\">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</pre> <p> ReadLine is a low-level line-reading primitive. Most callers should use ReadBytes('\\n') or ReadString('\\n') instead or use a Scanner. </p> <p> ReadLine tries to return a single line, not including the end-of-line bytes. If the line was too long for the buffer then isPrefix is set and the beginning of the line is returned. The rest of the line will be returned from future calls. isPrefix will be false when returning the last fragment of the line. The returned buffer is only valid until the next call to ReadLine. ReadLine either returns a non-nil line or it returns an error, never both. </p> <p> The text returned from ReadLine does not include the line end (\"\\r\\n\" or \"\\n\"). No indication or error is given if the input ends without a final line end. Calling UnreadByte after ReadLine will always unread the last byte read (possibly a character belonging to the line end) even if that byte is not part of the line returned by ReadLine. </p> <h3 id=\"Reader.ReadRune\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=6027:6084#L250\">ReadRune</a>  </h3> <pre data-language=\"go\">func (b *Reader) ReadRune() (r rune, size int, err error)</pre> <p> ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If the encoded rune is invalid, it consumes one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1. </p> <h3 id=\"Reader.ReadSlice\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=7720:7783#L295\">ReadSlice</a>  </h3> <pre data-language=\"go\">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</pre> <p> ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error ErrBufferFull if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use ReadBytes or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim. </p> <h3 id=\"Reader.ReadString\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=11701:11756#L437\">ReadString</a>  </h3> <pre data-language=\"go\">func (b *Reader) ReadString(delim byte) (string, error)</pre> <p> ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient. </p> <h3 id=\"Reader.Reset\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=1839:1874#L57\">Reset</a>  </h3> <pre data-language=\"go\">func (b *Reader) Reset(r io.Reader)</pre> <p> Reset discards any buffered data, resets all state, and switches the buffered reader to read from r. </p> <h3 id=\"Reader.UnreadByte\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=5508:5543#L230\">UnreadByte</a>  </h3> <pre data-language=\"go\">func (b *Reader) UnreadByte() error</pre> <p> UnreadByte unreads the last byte. Only the most recently read byte can be unread. </p> <h3 id=\"Reader.UnreadRune\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=6761:6796#L272\">UnreadRune</a>  </h3> <pre data-language=\"go\">func (b *Reader) UnreadRune() error</pre> <p> UnreadRune unreads the last rune. If the most recent read operation on the buffer was not a ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.) </p> <h3 id=\"Reader.WriteTo\">func (*Reader) <a href=\"https://golang.org/src/bufio/bufio.go?s=11858:11916#L443\">WriteTo</a>  </h3> <pre data-language=\"go\">func (b *Reader) WriteTo(w io.Writer) (n int64, err error)</pre> <p> WriteTo implements io.WriterTo. </p> <h2 id=\"Scanner\">type Scanner  </h2> <pre data-language=\"go\">type Scanner struct {\n        // contains filtered or unexported fields\n}</pre> <p> Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the Scan method will step through the 'tokens' of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type SplitFunc; the default split function breaks the input into lines with line termination stripped. Split functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function. </p> <p> Scanning stops unrecoverably at EOF, the first I/O error, or a token too large to fit in the buffer. When a scan stops, the reader may have advanced arbitrarily far past the last token. Programs that need more control over error handling or large tokens, or must run sequential scans on a reader, should use bufio.Reader instead. </p> <div id=\"example_Scanner_custom\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Custom)</h2> <p>Use a Scanner with a custom split function (built by wrapping ScanWords) to validate 32-bit decimal input. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// An artificial input source.\n    const input = \"1234 5678 1234567901234567890\"\n    scanner := bufio.NewScanner(strings.NewReader(input))\n    // Create a custom split function by wrapping the existing ScanWords function.\n    split := func(data []byte, atEOF bool) (advance int, token []byte, err error) {\n            advance, token, err = bufio.ScanWords(data, atEOF)\n            if err == nil &amp;&amp; token != nil {\n                    _, err = strconv.ParseInt(string(token), 10, 32)\n            }\n            return\n    }\n    // Set the split function for the scanning operation.\n    scanner.Split(split)\n    // Validate the input\n    for scanner.Scan() {\n            fmt.Printf(\"%s\\n\", scanner.Text())\n    }\n\n    if err := scanner.Err(); err != nil {\n            fmt.Printf(\"Invalid input: %s\", err)\n    }\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">1234\n5678\nInvalid input: strconv.ParseInt: parsing \"1234567901234567890\": value out of range\n</pre> </div> </div> <div id=\"example_Scanner_emptyFinalToken\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (EmptyFinalToken)</h2> <p>Use a Scanner with a custom split function to parse a comma-separated list with an empty final value. </p> <pre class=\"play\">package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Comma-separated list; last entry is empty.\n\tconst input = \"1,2,3,4,\"\n\tscanner := bufio.NewScanner(strings.NewReader(input))\n\t// Define a split function that separates on commas.\n\tonComma := func(data []byte, atEOF bool) (advance int, token []byte, err error) {\n\t\tfor i := 0; i &lt; len(data); i++ {\n\t\t\tif data[i] == ',' {\n\t\t\t\treturn i + 1, data[:i], nil\n\t\t\t}\n\t\t}\n\t\t// There is one final token to be delivered, which may be the empty string.\n\t\t// Returning bufio.ErrFinalToken here tells Scan there are no more tokens after this\n\t\t// but does not trigger an error to be returned from Scan itself.\n\t\treturn 0, data, bufio.ErrFinalToken\n\t}\n\tscanner.Split(onComma)\n\t// Scan.\n\tfor scanner.Scan() {\n\t\tfmt.Printf(\"%q \", scanner.Text())\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"reading input:\", err)\n\t}\n}\n</pre> </div> </div> <div id=\"example_Scanner_lines\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Lines)</h2> <p>The simplest use of a Scanner, to read standard input as a set of lines. </p> <pre class=\"play\">package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tfor scanner.Scan() {\n\t\tfmt.Println(scanner.Text()) // Println will add back the final '\\n'\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"reading standard input:\", err)\n\t}\n}\n</pre> </div> </div> <div id=\"example_Scanner_words\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Words)</h2> <p>Use a Scanner to implement a simple word-count utility by scanning the input as a sequence of space-delimited tokens. </p> <pre class=\"play\">package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// An artificial input source.\n\tconst input = \"Now is the winter of our discontent,\\nMade glorious summer by this sun of York.\\n\"\n\tscanner := bufio.NewScanner(strings.NewReader(input))\n\t// Set the split function for the scanning operation.\n\tscanner.Split(bufio.ScanWords)\n\t// Count the words.\n\tcount := 0\n\tfor scanner.Scan() {\n\t\tcount++\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"reading input:\", err)\n\t}\n\tfmt.Printf(\"%d\\n\", count)\n}\n</pre> </div> </div> <h3 id=\"NewScanner\">func <a href=\"https://golang.org/src/bufio/scan.go?s=3594:3631#L71\">NewScanner</a>  </h3> <pre data-language=\"go\">func NewScanner(r io.Reader) *Scanner</pre> <p> NewScanner returns a new Scanner to read from r. The split function defaults to ScanLines. </p> <h3 id=\"Scanner.Buffer\">func (*Scanner) <a href=\"https://golang.org/src/bufio/scan.go?s=8759:8804#L247\">Buffer</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Buffer(buf []byte, max int)</pre> <p> Buffer sets the initial buffer to use when scanning and the maximum size of buffer that may be allocated during scanning. The maximum token size is the larger of max and cap(buf). If max &lt;= cap(buf), Scan will use this buffer only and do no allocation. </p> <p> By default, Scan uses an internal buffer and sets the maximum token size to MaxScanTokenSize. </p> <p> Buffer panics if it is called after scanning has started. </p> <h3 id=\"Scanner.Bytes\">func (*Scanner) <a href=\"https://golang.org/src/bufio/scan.go?s=4092:4124#L90\">Bytes</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Bytes() []byte</pre> <p> Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation. </p> <h3 id=\"Scanner.Err\">func (*Scanner) <a href=\"https://golang.org/src/bufio/scan.go?s=3814:3843#L80\">Err</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Err() error</pre> <p> Err returns the first non-EOF error that was encountered by the Scanner. </p> <h3 id=\"Scanner.Scan\">func (*Scanner) <a href=\"https://golang.org/src/bufio/scan.go?s=5433:5462#L118\">Scan</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Scan() bool</pre> <p> Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. It returns false when the scan stops, either by reaching the end of the input or an error. After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil. Scan panics if the split function returns 100 empty tokens without advancing the input. This is a common error mode for scanners. </p> <h3 id=\"Scanner.Split\">func (*Scanner) <a href=\"https://golang.org/src/bufio/scan.go?s=9072:9112#L259\">Split</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Split(split SplitFunc)</pre> <p> Split sets the split function for the Scanner. The default split function is ScanLines. </p> <p> Split panics if it is called after scanning has started. </p> <h3 id=\"Scanner.Text\">func (*Scanner) <a href=\"https://golang.org/src/bufio/scan.go?s=4262:4293#L96\">Text</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Text() string</pre> <p> Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes. </p> <h2 id=\"SplitFunc\">type SplitFunc  </h2> <pre data-language=\"go\">type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)</pre> <p> SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the Reader has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, plus an error, if any. If the data does not yet hold a complete token, for instance if it has no newline while scanning lines, SplitFunc can return (0, nil, nil) to signal the Scanner to read more data into the slice and try again with a longer slice starting at the same point in the input. </p> <p> If the returned error is non-nil, scanning stops and the error is returned to the client. </p> <p> The function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text. </p> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer struct {\n        // contains filtered or unexported fields\n}</pre> <p> Writer implements buffering for an io.Writer object. If an error occurs writing to a Writer, no more data will be accepted and all subsequent writes will return the error. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer. </p> <div id=\"example_Writer\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tw := bufio.NewWriter(os.Stdout)\n\tfmt.Fprint(w, \"Hello, \")\n\tfmt.Fprint(w, \"world!\")\n\tw.Flush() // Don't forget to flush!\n}\n</pre> </div> </div> <h3 id=\"NewWriter\">func <a href=\"https://golang.org/src/bufio/bufio.go?s=13695:13730#L528\">NewWriter</a>  </h3> <pre data-language=\"go\">func NewWriter(w io.Writer) *Writer</pre> <p> NewWriter returns a new Writer whose buffer has the default size. </p> <h3 id=\"NewWriterSize\">func <a href=\"https://golang.org/src/bufio/bufio.go?s=13376:13425#L512\">NewWriterSize</a>  </h3> <pre data-language=\"go\">func NewWriterSize(w io.Writer, size int) *Writer</pre> <p> NewWriterSize returns a new Writer whose buffer has at least the specified size. If the argument io.Writer is already a Writer with large enough size, it returns the underlying Writer. </p> <h3 id=\"Writer.Available\">func (*Writer) <a href=\"https://golang.org/src/bufio/bufio.go?s=14489:14521#L570\">Available</a>  </h3> <pre data-language=\"go\">func (b *Writer) Available() int</pre> <p> Available returns how many bytes are unused in the buffer. </p> <h3 id=\"Writer.Buffered\">func (*Writer) <a href=\"https://golang.org/src/bufio/bufio.go?s=14639:14670#L573\">Buffered</a>  </h3> <pre data-language=\"go\">func (b *Writer) Buffered() int</pre> <p> Buffered returns the number of bytes that have been written into the current buffer. </p> <h3 id=\"Writer.Flush\">func (*Writer) <a href=\"https://golang.org/src/bufio/bufio.go?s=14020:14050#L541\">Flush</a>  </h3> <pre data-language=\"go\">func (b *Writer) Flush() error</pre> <p> Flush writes any buffered data to the underlying io.Writer. </p> <h3 id=\"Writer.ReadFrom\">func (*Writer) <a href=\"https://golang.org/src/bufio/bufio.go?s=16642:16701#L668\">ReadFrom</a>  </h3> <pre data-language=\"go\">func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)</pre> <p> ReadFrom implements io.ReaderFrom. </p> <h3 id=\"Writer.Reset\">func (*Writer) <a href=\"https://golang.org/src/bufio/bufio.go?s=13884:13919#L534\">Reset</a>  </h3> <pre data-language=\"go\">func (b *Writer) Reset(w io.Writer)</pre> <p> Reset discards any unflushed buffered data, clears any error, and resets b to write its output to w. </p> <h3 id=\"Writer.Write\">func (*Writer) <a href=\"https://golang.org/src/bufio/bufio.go?s=14863:14915#L579\">Write</a>  </h3> <pre data-language=\"go\">func (b *Writer) Write(p []byte) (nn int, err error)</pre> <p> Write writes the contents of p into the buffer. It returns the number of bytes written. If nn &lt; len(p), it also returns an error explaining why the write is short. </p> <h3 id=\"Writer.WriteByte\">func (*Writer) <a href=\"https://golang.org/src/bufio/bufio.go?s=15339:15379#L604\">WriteByte</a>  </h3> <pre data-language=\"go\">func (b *Writer) WriteByte(c byte) error</pre> <p> WriteByte writes a single byte. </p> <h3 id=\"Writer.WriteRune\">func (*Writer) <a href=\"https://golang.org/src/bufio/bufio.go?s=15625:15681#L618\">WriteRune</a>  </h3> <pre data-language=\"go\">func (b *Writer) WriteRune(r rune) (size int, err error)</pre> <p> WriteRune writes a single Unicode code point, returning the number of bytes written and any error. </p> <h3 id=\"Writer.WriteString\">func (*Writer) <a href=\"https://golang.org/src/bufio/bufio.go?s=16313:16364#L649\">WriteString</a>  </h3> <pre data-language=\"go\">func (b *Writer) WriteString(s string) (int, error)</pre> <p> WriteString writes a string. It returns the number of bytes written. If the count is less than len(s), it also returns an error explaining why the write is short. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/bufio/\" class=\"_attribution-link\">https://golang.org/pkg/bufio/</a>\n  </p>\n</div>\n","encoding/ascii85/index":"<h1>Package ascii85</h1>     <ul id=\"short-nav\">\n<li><code>import \"encoding/ascii85\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package ascii85 implements the ascii85 data encoding as used in the btoa tool and Adobe's PostScript and PDF document formats. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Decode\">func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err error)</a></li>\n<li><a href=\"#Encode\">func Encode(dst, src []byte) int</a></li>\n<li><a href=\"#MaxEncodedLen\">func MaxEncodedLen(n int) int</a></li>\n<li><a href=\"#NewDecoder\">func NewDecoder(r io.Reader) io.Reader</a></li>\n<li><a href=\"#NewEncoder\">func NewEncoder(w io.Writer) io.WriteCloser</a></li>\n<li><a href=\"#CorruptInputError\">type CorruptInputError</a></li>\n<li> <a href=\"#CorruptInputError.Error\">func (e CorruptInputError) Error() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/encoding/ascii85/ascii85.go\">ascii85.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Decode\">func Decode  </h2> <pre data-language=\"go\">func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err error)</pre> <p> Decode decodes src into dst, returning both the number of bytes written to dst and the number consumed from src. If src contains invalid ascii85 data, Decode will return the number of bytes successfully written and a CorruptInputError. Decode ignores space and control characters in src. Often, ascii85-encoded data is wrapped in &lt;~ and ~&gt; symbols. Decode expects these to have been stripped by the caller. </p> <p> If flush is true, Decode assumes that src represents the end of the input stream and processes it completely rather than wait for the completion of another 32-bit block. </p> <p> NewDecoder wraps an io.Reader interface around Decode. </p> <h2 id=\"Encode\">func Encode  </h2> <pre data-language=\"go\">func Encode(dst, src []byte) int</pre> <p> Encode encodes src into at most MaxEncodedLen(len(src)) bytes of dst, returning the actual number of bytes written. </p> <p> The encoding handles 4-byte chunks, using a special encoding for the last fragment, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead. </p> <p> Often, ascii85-encoded data is wrapped in &lt;~ and ~&gt; symbols. Encode does not add these. </p> <h2 id=\"MaxEncodedLen\">func MaxEncodedLen  </h2> <pre data-language=\"go\">func MaxEncodedLen(n int) int</pre> <p> MaxEncodedLen returns the maximum length of an encoding of n source bytes. </p> <h2 id=\"NewDecoder\">func NewDecoder  </h2> <pre data-language=\"go\">func NewDecoder(r io.Reader) io.Reader</pre> <p> NewDecoder constructs a new ascii85 stream decoder. </p> <h2 id=\"NewEncoder\">func NewEncoder  </h2> <pre data-language=\"go\">func NewEncoder(w io.Writer) io.WriteCloser</pre> <p> NewEncoder returns a new ascii85 stream encoder. Data written to the returned writer will be encoded and then written to w. Ascii85 encodings operate in 32-bit blocks; when finished writing, the caller must Close the returned encoder to flush any trailing partial block. </p> <h2 id=\"CorruptInputError\">type CorruptInputError  </h2> <pre data-language=\"go\">type CorruptInputError int64</pre> <h3 id=\"CorruptInputError.Error\">func (CorruptInputError) <a href=\"https://golang.org/src/encoding/ascii85/ascii85.go?s=3610:3651#L161\">Error</a>  </h3> <pre data-language=\"go\">func (e CorruptInputError) Error() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/encoding/ascii85/\" class=\"_attribution-link\">https://golang.org/pkg/encoding/ascii85/</a>\n  </p>\n</div>\n","crypto/cipher/index":"<h1>Package cipher</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/cipher\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations. See <a href=\"http://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html\">http://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html</a> and NIST Special Publication 800-38A. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#AEAD\">type AEAD</a></li>\n<li> <a href=\"#NewGCM\">func NewGCM(cipher Block) (AEAD, error)</a>\n</li>\n<li> <a href=\"#NewGCMWithNonceSize\">func NewGCMWithNonceSize(cipher Block, size int) (AEAD, error)</a>\n</li>\n<li><a href=\"#Block\">type Block</a></li>\n<li><a href=\"#BlockMode\">type BlockMode</a></li>\n<li> <a href=\"#NewCBCDecrypter\">func NewCBCDecrypter(b Block, iv []byte) BlockMode</a>\n</li>\n<li> <a href=\"#NewCBCEncrypter\">func NewCBCEncrypter(b Block, iv []byte) BlockMode</a>\n</li>\n<li><a href=\"#Stream\">type Stream</a></li>\n<li> <a href=\"#NewCFBDecrypter\">func NewCFBDecrypter(block Block, iv []byte) Stream</a>\n</li>\n<li> <a href=\"#NewCFBEncrypter\">func NewCFBEncrypter(block Block, iv []byte) Stream</a>\n</li>\n<li> <a href=\"#NewCTR\">func NewCTR(block Block, iv []byte) Stream</a>\n</li>\n<li> <a href=\"#NewOFB\">func NewOFB(b Block, iv []byte) Stream</a>\n</li>\n<li><a href=\"#StreamReader\">type StreamReader</a></li>\n<li> <a href=\"#StreamReader.Read\">func (r StreamReader) Read(dst []byte) (n int, err error)</a>\n</li>\n<li><a href=\"#StreamWriter\">type StreamWriter</a></li>\n<li> <a href=\"#StreamWriter.Close\">func (w StreamWriter) Close() error</a>\n</li>\n<li> <a href=\"#StreamWriter.Write\">func (w StreamWriter) Write(src []byte) (n int, err error)</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_NewCBCDecrypter\">NewCBCDecrypter</a></dd> <dd><a class=\"exampleLink\" href=\"#example_NewCBCEncrypter\">NewCBCEncrypter</a></dd> <dd><a class=\"exampleLink\" href=\"#example_NewCFBDecrypter\">NewCFBDecrypter</a></dd> <dd><a class=\"exampleLink\" href=\"#example_NewCFBEncrypter\">NewCFBEncrypter</a></dd> <dd><a class=\"exampleLink\" href=\"#example_NewCTR\">NewCTR</a></dd> <dd><a class=\"exampleLink\" href=\"#example_NewOFB\">NewOFB</a></dd> <dd><a class=\"exampleLink\" href=\"#example_StreamReader\">StreamReader</a></dd> <dd><a class=\"exampleLink\" href=\"#example_StreamWriter\">StreamWriter</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/cipher/cbc.go\">cbc.go</a> <a href=\"https://golang.org/src/crypto/cipher/cfb.go\">cfb.go</a> <a href=\"https://golang.org/src/crypto/cipher/cipher.go\">cipher.go</a> <a href=\"https://golang.org/src/crypto/cipher/ctr.go\">ctr.go</a> <a href=\"https://golang.org/src/crypto/cipher/gcm.go\">gcm.go</a> <a href=\"https://golang.org/src/crypto/cipher/io.go\">io.go</a> <a href=\"https://golang.org/src/crypto/cipher/ofb.go\">ofb.go</a> <a href=\"https://golang.org/src/crypto/cipher/xor.go\">xor.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"AEAD\">type AEAD  </h2> <pre data-language=\"go\">type AEAD interface {\n        // NonceSize returns the size of the nonce that must be passed to Seal\n        // and Open.\n        NonceSize() int\n\n        // Overhead returns the maximum difference between the lengths of a\n        // plaintext and its ciphertext.\n        Overhead() int\n\n        // Seal encrypts and authenticates plaintext, authenticates the\n        // additional data and appends the result to dst, returning the updated\n        // slice. The nonce must be NonceSize() bytes long and unique for all\n        // time, for a given key.\n        //\n        // The plaintext and dst may alias exactly or not at all. To reuse\n        // plaintext's storage for the encrypted output, use plaintext[:0] as dst.\n        Seal(dst, nonce, plaintext, additionalData []byte) []byte\n\n        // Open decrypts and authenticates ciphertext, authenticates the\n        // additional data and, if successful, appends the resulting plaintext\n        // to dst, returning the updated slice. The nonce must be NonceSize()\n        // bytes long and both it and the additional data must match the\n        // value passed to Seal.\n        //\n        // The ciphertext and dst may alias exactly or not at all. To reuse\n        // ciphertext's storage for the decrypted output, use ciphertext[:0] as dst.\n        //\n        // Even if the function fails, the contents of dst, up to its capacity,\n        // may be overwritten.\n        Open(dst, nonce, ciphertext, additionalData []byte) ([]byte, error)\n}</pre> <p> AEAD is a cipher mode providing authenticated encryption with associated data. For a description of the methodology, see </p> <pre data-language=\"go\">https://en.wikipedia.org/wiki/Authenticated_encryption\n</pre> <h3 id=\"NewGCM\">func <a href=\"https://golang.org/src/crypto/cipher/gcm.go?s=2973:3012#L67\">NewGCM</a>  </h3> <pre data-language=\"go\">func NewGCM(cipher Block) (AEAD, error)</pre> <p> NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode with the standard nonce length. </p> <h3 id=\"NewGCMWithNonceSize\">func <a href=\"https://golang.org/src/crypto/cipher/gcm.go?s=3429:3491#L77\">NewGCMWithNonceSize</a>  </h3> <pre data-language=\"go\">func NewGCMWithNonceSize(cipher Block, size int) (AEAD, error)</pre> <p> NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which accepts nonces of the given length. </p> <p> Only use this function if you require compatibility with an existing cryptosystem that uses non-standard nonce lengths. All other users should use NewGCM, which is faster and more resistant to misuse. </p> <h2 id=\"Block\">type Block  </h2> <pre data-language=\"go\">type Block interface {\n        // BlockSize returns the cipher's block size.\n        BlockSize() int\n\n        // Encrypt encrypts the first block in src into dst.\n        // Dst and src may point at the same memory.\n        Encrypt(dst, src []byte)\n\n        // Decrypt decrypts the first block in src into dst.\n        // Dst and src may point at the same memory.\n        Decrypt(dst, src []byte)\n}</pre> <p> A Block represents an implementation of block cipher using a given key. It provides the capability to encrypt or decrypt individual blocks. The mode implementations extend that capability to streams of blocks. </p> <h2 id=\"BlockMode\">type BlockMode  </h2> <pre data-language=\"go\">type BlockMode interface {\n        // BlockSize returns the mode's block size.\n        BlockSize() int\n\n        // CryptBlocks encrypts or decrypts a number of blocks. The length of\n        // src must be a multiple of the block size. Dst and src may point to\n        // the same memory.\n        CryptBlocks(dst, src []byte)\n}</pre> <p> A BlockMode represents a block cipher running in a block-based mode (CBC, ECB etc). </p> <h3 id=\"NewCBCDecrypter\">func <a href=\"https://golang.org/src/crypto/cipher/cbc.go?s=2776:2826#L90\">NewCBCDecrypter</a>  </h3> <pre data-language=\"go\">func NewCBCDecrypter(b Block, iv []byte) BlockMode</pre> <p> NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size and must match the iv used to encrypt the data. </p> <div id=\"example_NewCBCDecrypter\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tkey := []byte(\"example key 1234\")\n\tciphertext, _ := hex.DecodeString(\"f363f3ccdcb12bb883abf484ba77d9cd7d32b5baecb3d4b1b3e0e4beffdb3ded\")\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// The IV needs to be unique, but not secure. Therefore it's common to\n\t// include it at the beginning of the ciphertext.\n\tif len(ciphertext) &lt; aes.BlockSize {\n\t\tpanic(\"ciphertext too short\")\n\t}\n\tiv := ciphertext[:aes.BlockSize]\n\tciphertext = ciphertext[aes.BlockSize:]\n\n\t// CBC mode always works in whole blocks.\n\tif len(ciphertext)%aes.BlockSize != 0 {\n\t\tpanic(\"ciphertext is not a multiple of the block size\")\n\t}\n\n\tmode := cipher.NewCBCDecrypter(block, iv)\n\n\t// CryptBlocks can work in-place if the two arguments are the same.\n\tmode.CryptBlocks(ciphertext, ciphertext)\n\n\t// If the original plaintext lengths are not a multiple of the block\n\t// size, padding would have to be added when encrypting, which would be\n\t// removed at this point. For an example, see\n\t// https://tools.ietf.org/html/rfc5246#section-6.2.3.2. However, it's\n\t// critical to note that ciphertexts must be authenticated (i.e. by\n\t// using crypto/hmac) before being decrypted in order to avoid creating\n\t// a padding oracle.\n\n\tfmt.Printf(\"%s\\n\", ciphertext)\n}\n</pre> </div> </div> <h3 id=\"NewCBCEncrypter\">func <a href=\"https://golang.org/src/crypto/cipher/cbc.go?s=1152:1202#L33\">NewCBCEncrypter</a>  </h3> <pre data-language=\"go\">func NewCBCEncrypter(b Block, iv []byte) BlockMode</pre> <p> NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size. </p> <div id=\"example_NewCBCEncrypter\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n)\n\nfunc main() {\n\tkey := []byte(\"example key 1234\")\n\tplaintext := []byte(\"exampleplaintext\")\n\n\t// CBC mode works on blocks so plaintexts may need to be padded to the\n\t// next whole block. For an example of such padding, see\n\t// https://tools.ietf.org/html/rfc5246#section-6.2.3.2. Here we'll\n\t// assume that the plaintext is already of the correct length.\n\tif len(plaintext)%aes.BlockSize != 0 {\n\t\tpanic(\"plaintext is not a multiple of the block size\")\n\t}\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// The IV needs to be unique, but not secure. Therefore it's common to\n\t// include it at the beginning of the ciphertext.\n\tciphertext := make([]byte, aes.BlockSize+len(plaintext))\n\tiv := ciphertext[:aes.BlockSize]\n\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n\t\tpanic(err)\n\t}\n\n\tmode := cipher.NewCBCEncrypter(block, iv)\n\tmode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)\n\n\t// It's important to remember that ciphertexts must be authenticated\n\t// (i.e. by using crypto/hmac) as well as being encrypted in order to\n\t// be secure.\n\n\tfmt.Printf(\"%x\\n\", ciphertext)\n}\n</pre> </div> </div> <h2 id=\"Stream\">type Stream  </h2> <pre data-language=\"go\">type Stream interface {\n        // XORKeyStream XORs each byte in the given slice with a byte from the\n        // cipher's key stream. Dst and src may point to the same memory.\n        // If len(dst) &lt; len(src), XORKeyStream should panic. It is acceptable\n        // to pass a dst bigger than src, and in that case, XORKeyStream will\n        // only update dst[:len(src)] and will not touch the rest of dst.\n        XORKeyStream(dst, src []byte)\n}</pre> <p> A Stream represents a stream cipher. </p> <h3 id=\"NewCFBDecrypter\">func <a href=\"https://golang.org/src/crypto/cipher/cfb.go?s=1265:1316#L42\">NewCFBDecrypter</a>  </h3> <pre data-language=\"go\">func NewCFBDecrypter(block Block, iv []byte) Stream</pre> <p> NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode, using the given Block. The iv must be the same length as the Block's block size. </p> <div id=\"example_NewCFBDecrypter\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tkey := []byte(\"example key 1234\")\n\tciphertext, _ := hex.DecodeString(\"22277966616d9bc47177bd02603d08c9a67d5380d0fe8cf3b44438dff7b9\")\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// The IV needs to be unique, but not secure. Therefore it's common to\n\t// include it at the beginning of the ciphertext.\n\tif len(ciphertext) &lt; aes.BlockSize {\n\t\tpanic(\"ciphertext too short\")\n\t}\n\tiv := ciphertext[:aes.BlockSize]\n\tciphertext = ciphertext[aes.BlockSize:]\n\n\tstream := cipher.NewCFBDecrypter(block, iv)\n\n\t// XORKeyStream can work in-place if the two arguments are the same.\n\tstream.XORKeyStream(ciphertext, ciphertext)\n\tfmt.Printf(\"%s\", ciphertext)\n}\n</pre> </div> </div> <h3 id=\"NewCFBEncrypter\">func <a href=\"https://golang.org/src/crypto/cipher/cfb.go?s=1010:1061#L35\">NewCFBEncrypter</a>  </h3> <pre data-language=\"go\">func NewCFBEncrypter(block Block, iv []byte) Stream</pre> <p> NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode, using the given Block. The iv must be the same length as the Block's block size. </p> <div id=\"example_NewCFBEncrypter\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"io\"\n)\n\nfunc main() {\n\tkey := []byte(\"example key 1234\")\n\tplaintext := []byte(\"some plaintext\")\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// The IV needs to be unique, but not secure. Therefore it's common to\n\t// include it at the beginning of the ciphertext.\n\tciphertext := make([]byte, aes.BlockSize+len(plaintext))\n\tiv := ciphertext[:aes.BlockSize]\n\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n\t\tpanic(err)\n\t}\n\n\tstream := cipher.NewCFBEncrypter(block, iv)\n\tstream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)\n\n\t// It's important to remember that ciphertexts must be authenticated\n\t// (i.e. by using crypto/hmac) as well as being encrypted in order to\n\t// be secure.\n}\n</pre> </div> </div> <h3 id=\"NewCTR\">func <a href=\"https://golang.org/src/crypto/cipher/ctr.go?s=922:964#L23\">NewCTR</a>  </h3> <pre data-language=\"go\">func NewCTR(block Block, iv []byte) Stream</pre> <p> NewCTR returns a Stream which encrypts/decrypts using the given Block in counter mode. The length of iv must be the same as the Block's block size. </p> <div id=\"example_NewCTR\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n)\n\nfunc main() {\n\tkey := []byte(\"example key 1234\")\n\tplaintext := []byte(\"some plaintext\")\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// The IV needs to be unique, but not secure. Therefore it's common to\n\t// include it at the beginning of the ciphertext.\n\tciphertext := make([]byte, aes.BlockSize+len(plaintext))\n\tiv := ciphertext[:aes.BlockSize]\n\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n\t\tpanic(err)\n\t}\n\n\tstream := cipher.NewCTR(block, iv)\n\tstream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)\n\n\t// It's important to remember that ciphertexts must be authenticated\n\t// (i.e. by using crypto/hmac) as well as being encrypted in order to\n\t// be secure.\n\n\t// CTR mode is the same for both encryption and decryption, so we can\n\t// also decrypt that ciphertext with NewCTR.\n\n\tplaintext2 := make([]byte, len(plaintext))\n\tstream = cipher.NewCTR(block, iv)\n\tstream.XORKeyStream(plaintext2, ciphertext[aes.BlockSize:])\n\n\tfmt.Printf(\"%s\\n\", plaintext2)\n}\n</pre> </div> </div> <h3 id=\"NewOFB\">func <a href=\"https://golang.org/src/crypto/cipher/ofb.go?s=469:507#L9\">NewOFB</a>  </h3> <pre data-language=\"go\">func NewOFB(b Block, iv []byte) Stream</pre> <p> NewOFB returns a Stream that encrypts or decrypts using the block cipher b in output feedback mode. The initialization vector iv's length must be equal to b's block size. </p> <div id=\"example_NewOFB\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n)\n\nfunc main() {\n\tkey := []byte(\"example key 1234\")\n\tplaintext := []byte(\"some plaintext\")\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// The IV needs to be unique, but not secure. Therefore it's common to\n\t// include it at the beginning of the ciphertext.\n\tciphertext := make([]byte, aes.BlockSize+len(plaintext))\n\tiv := ciphertext[:aes.BlockSize]\n\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n\t\tpanic(err)\n\t}\n\n\tstream := cipher.NewOFB(block, iv)\n\tstream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)\n\n\t// It's important to remember that ciphertexts must be authenticated\n\t// (i.e. by using crypto/hmac) as well as being encrypted in order to\n\t// be secure.\n\n\t// OFB mode is the same for both encryption and decryption, so we can\n\t// also decrypt that ciphertext with NewOFB.\n\n\tplaintext2 := make([]byte, len(plaintext))\n\tstream = cipher.NewOFB(block, iv)\n\tstream.XORKeyStream(plaintext2, ciphertext[aes.BlockSize:])\n\n\tfmt.Printf(\"%s\\n\", plaintext2)\n}\n</pre> </div> </div> <h2 id=\"StreamReader\">type StreamReader  </h2> <pre data-language=\"go\">type StreamReader struct {\n        S Stream\n        R io.Reader\n}</pre> <p> StreamReader wraps a Stream into an io.Reader. It calls XORKeyStream to process each slice of data which passes through. </p> <div id=\"example_StreamReader\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\tkey := []byte(\"example key 1234\")\n\n\tinFile, err := os.Open(\"encrypted-file\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer inFile.Close()\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// If the key is unique for each ciphertext, then it's ok to use a zero\n\t// IV.\n\tvar iv [aes.BlockSize]byte\n\tstream := cipher.NewOFB(block, iv[:])\n\n\toutFile, err := os.OpenFile(\"decrypted-file\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer outFile.Close()\n\n\treader := &amp;cipher.StreamReader{S: stream, R: inFile}\n\t// Copy the input file to the output file, decrypting as we go.\n\tif _, err := io.Copy(outFile, reader); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Note that this example is simplistic in that it omits any\n\t// authentication of the encrypted data. If you were actually to use\n\t// StreamReader in this manner, an attacker could flip arbitrary bits in\n\t// the output.\n}\n</pre> </div> </div> <h3 id=\"StreamReader.Read\">func (StreamReader) <a href=\"https://golang.org/src/crypto/cipher/io.go?s=479:536#L9\">Read</a>  </h3> <pre data-language=\"go\">func (r StreamReader) Read(dst []byte) (n int, err error)</pre> <h2 id=\"StreamWriter\">type StreamWriter  </h2> <pre data-language=\"go\">type StreamWriter struct {\n        S   Stream\n        W   io.Writer\n        Err error // unused\n}</pre> <p> StreamWriter wraps a Stream into an io.Writer. It calls XORKeyStream to process each slice of data which passes through. If any Write call returns short then the StreamWriter is out of sync and must be discarded. A StreamWriter has no internal buffering; Close does not need to be called to flush write data. </p> <div id=\"example_StreamWriter\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\tkey := []byte(\"example key 1234\")\n\n\tinFile, err := os.Open(\"plaintext-file\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer inFile.Close()\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// If the key is unique for each ciphertext, then it's ok to use a zero\n\t// IV.\n\tvar iv [aes.BlockSize]byte\n\tstream := cipher.NewOFB(block, iv[:])\n\n\toutFile, err := os.OpenFile(\"encrypted-file\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer outFile.Close()\n\n\twriter := &amp;cipher.StreamWriter{S: stream, W: outFile}\n\t// Copy the input file to the output file, encrypting as we go.\n\tif _, err := io.Copy(writer, inFile); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Note that this example is simplistic in that it omits any\n\t// authentication of the encrypted data. If you were actually to use\n\t// StreamReader in this manner, an attacker could flip arbitrary bits in\n\t// the decrypted result.\n}\n</pre> </div> </div> <h3 id=\"StreamWriter.Close\">func (StreamWriter) <a href=\"https://golang.org/src/crypto/cipher/io.go?s=1395:1430#L40\">Close</a>  </h3> <pre data-language=\"go\">func (w StreamWriter) Close() error</pre> <p> Close closes the underlying Writer and returns its Close return value, if the Writer is also an io.Closer. Otherwise it returns nil. </p> <h3 id=\"StreamWriter.Write\">func (StreamWriter) <a href=\"https://golang.org/src/crypto/cipher/io.go?s=1012:1070#L26\">Write</a>  </h3> <pre data-language=\"go\">func (w StreamWriter) Write(src []byte) (n int, err error)</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/cipher/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/cipher/</a>\n  </p>\n</div>\n","encoding/index":"<h1>Package encoding</h1>     <ul id=\"short-nav\">\n<li><code>import \"encoding\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package encoding defines interfaces shared by other packages that convert data to and from byte-level and textual representations. Packages that check for these interfaces include encoding/gob, encoding/json, and encoding/xml. As a result, implementing an interface once can make a type useful in multiple encodings. Standard types that implement these interfaces include time.Time and net.IP. The interfaces come in pairs that produce and consume encoded data. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#BinaryMarshaler\">type BinaryMarshaler</a></li>\n<li><a href=\"#BinaryUnmarshaler\">type BinaryUnmarshaler</a></li>\n<li><a href=\"#TextMarshaler\">type TextMarshaler</a></li>\n<li><a href=\"#TextUnmarshaler\">type TextUnmarshaler</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/encoding/encoding.go\">encoding.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"BinaryMarshaler\">type BinaryMarshaler  </h2> <pre data-language=\"go\">type BinaryMarshaler interface {\n        MarshalBinary() (data []byte, err error)\n}</pre> <p> BinaryMarshaler is the interface implemented by an object that can marshal itself into a binary form. </p> <p> MarshalBinary encodes the receiver into a binary form and returns the result. </p> <h2 id=\"BinaryUnmarshaler\">type BinaryUnmarshaler  </h2> <pre data-language=\"go\">type BinaryUnmarshaler interface {\n        UnmarshalBinary(data []byte) error\n}</pre> <p> BinaryUnmarshaler is the interface implemented by an object that can unmarshal a binary representation of itself. </p> <p> UnmarshalBinary must be able to decode the form generated by MarshalBinary. UnmarshalBinary must copy the data if it wishes to retain the data after returning. </p> <h2 id=\"TextMarshaler\">type TextMarshaler  </h2> <pre data-language=\"go\">type TextMarshaler interface {\n        MarshalText() (text []byte, err error)\n}</pre> <p> TextMarshaler is the interface implemented by an object that can marshal itself into a textual form. </p> <p> MarshalText encodes the receiver into UTF-8-encoded text and returns the result. </p> <h2 id=\"TextUnmarshaler\">type TextUnmarshaler  </h2> <pre data-language=\"go\">type TextUnmarshaler interface {\n        UnmarshalText(text []byte) error\n}</pre> <p> TextUnmarshaler is the interface implemented by an object that can unmarshal a textual representation of itself. </p> <p> UnmarshalText must be able to decode the form generated by MarshalText. UnmarshalText must copy the text if it wishes to retain the text after returning. </p> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"ascii85/index\">ascii85</a> </td> <td class=\"pkg-synopsis\"> Package ascii85 implements the ascii85 data encoding as used in the btoa tool and Adobe's PostScript and PDF document formats. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"asn1/index\">asn1</a> </td> <td class=\"pkg-synopsis\"> Package asn1 implements parsing of DER-encoded ASN.1 data structures, as defined in ITU-T Rec X.690. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"base32/index\">base32</a> </td> <td class=\"pkg-synopsis\"> Package base32 implements base32 encoding as specified by RFC 4648. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"base64/index\">base64</a> </td> <td class=\"pkg-synopsis\"> Package base64 implements base64 encoding as specified by RFC 4648. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"binary/index\">binary</a> </td> <td class=\"pkg-synopsis\"> Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"csv/index\">csv</a> </td> <td class=\"pkg-synopsis\"> Package csv reads and writes comma-separated values (CSV) files. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"gob/index\">gob</a> </td> <td class=\"pkg-synopsis\"> Package gob manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver). </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"hex/index\">hex</a> </td> <td class=\"pkg-synopsis\"> Package hex implements hexadecimal encoding and decoding. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"json/index\">json</a> </td> <td class=\"pkg-synopsis\"> Package json implements encoding and decoding of JSON as defined in RFC 4627. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"pem/index\">pem</a> </td> <td class=\"pkg-synopsis\"> Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"xml/index\">xml</a> </td> <td class=\"pkg-synopsis\"> Package xml implements a simple XML 1.0 parser that understands XML name spaces. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/encoding/\" class=\"_attribution-link\">https://golang.org/pkg/encoding/</a>\n  </p>\n</div>\n","database/sql/driver/index":"<h1>Package driver</h1>     <ul id=\"short-nav\">\n<li><code>import \"database/sql/driver\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package driver defines interfaces to be implemented by database drivers as used by package sql. </p> <p> Most code should use package sql. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#IsScanValue\">func IsScanValue(v interface{}) bool</a></li>\n<li><a href=\"#IsValue\">func IsValue(v interface{}) bool</a></li>\n<li><a href=\"#ColumnConverter\">type ColumnConverter</a></li>\n<li><a href=\"#Conn\">type Conn</a></li>\n<li><a href=\"#Driver\">type Driver</a></li>\n<li><a href=\"#Execer\">type Execer</a></li>\n<li><a href=\"#NotNull\">type NotNull</a></li>\n<li> <a href=\"#NotNull.ConvertValue\">func (n NotNull) ConvertValue(v interface{}) (Value, error)</a>\n</li>\n<li><a href=\"#Null\">type Null</a></li>\n<li> <a href=\"#Null.ConvertValue\">func (n Null) ConvertValue(v interface{}) (Value, error)</a>\n</li>\n<li><a href=\"#Queryer\">type Queryer</a></li>\n<li><a href=\"#Result\">type Result</a></li>\n<li><a href=\"#Rows\">type Rows</a></li>\n<li><a href=\"#RowsAffected\">type RowsAffected</a></li>\n<li> <a href=\"#RowsAffected.LastInsertId\">func (RowsAffected) LastInsertId() (int64, error)</a>\n</li>\n<li> <a href=\"#RowsAffected.RowsAffected\">func (v RowsAffected) RowsAffected() (int64, error)</a>\n</li>\n<li><a href=\"#Stmt\">type Stmt</a></li>\n<li><a href=\"#Tx\">type Tx</a></li>\n<li><a href=\"#Value\">type Value</a></li>\n<li><a href=\"#ValueConverter\">type ValueConverter</a></li>\n<li><a href=\"#Valuer\">type Valuer</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/database/sql/driver/driver.go\">driver.go</a> <a href=\"https://golang.org/src/database/sql/driver/types.go\">types.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var Bool boolType</pre> <p> Bool is a ValueConverter that converts input values to bools. </p> <p> The conversion rules are: </p> <pre data-language=\"go\">- booleans are returned unchanged\n- for integer types,\n     1 is true\n     0 is false,\n     other integers are an error\n- for strings and []byte, same rules as strconv.ParseBool\n- all other types are an error\n</pre> <pre data-language=\"go\">var DefaultParameterConverter defaultConverter</pre> <p> DefaultParameterConverter is the default implementation of ValueConverter that's used when a Stmt doesn't implement ColumnConverter. </p> <p> DefaultParameterConverter returns its argument directly if IsValue(arg). Otherwise, if the argument implements Valuer, its Value method is used to return a Value. As a fallback, the provided argument's underlying type is used to convert it to a Value: underlying integer types are converted to int64, floats to float64, and strings to []byte. If the argument is a nil pointer, ConvertValue returns a nil Value. If the argument is a non-nil pointer, it is dereferenced and ConvertValue is called recursively. Other types are an error. </p> <pre data-language=\"go\">var ErrBadConn = errors.New(\"driver: bad connection\")</pre> <p> ErrBadConn should be returned by a driver to signal to the sql package that a driver.Conn is in a bad state (such as the server having earlier closed the connection) and the sql package should retry on a new connection. </p> <p> To prevent duplicate operations, ErrBadConn should NOT be returned if there's a possibility that the database server might have performed the operation. Even if the server sends back an error, you shouldn't return ErrBadConn. </p> <pre data-language=\"go\">var ErrSkip = errors.New(\"driver: skip fast-path; continue as if unimplemented\")</pre> <p> ErrSkip may be returned by some optional interfaces' methods to indicate at runtime that the fast path is unavailable and the sql package should continue as if the optional interface was not implemented. ErrSkip is only supported where explicitly documented. </p> <pre data-language=\"go\">var Int32 int32Type</pre> <p> Int32 is a ValueConverter that converts input values to int64, respecting the limits of an int32 value. </p> <pre data-language=\"go\">var ResultNoRows noRows</pre> <p> ResultNoRows is a pre-defined Result for drivers to return when a DDL command (such as a CREATE TABLE) succeeds. It returns an error for both LastInsertId and RowsAffected. </p> <pre data-language=\"go\">var String stringType</pre> <p> String is a ValueConverter that converts its input to a string. If the value is already a string or []byte, it's unchanged. If the value is of another type, conversion to string is done with fmt.Sprintf(\"%v\", v). </p> <h2 id=\"IsScanValue\">func IsScanValue  </h2> <pre data-language=\"go\">func IsScanValue(v interface{}) bool</pre> <p> IsScanValue is equivalent to IsValue. It exists for compatibility. </p> <h2 id=\"IsValue\">func IsValue  </h2> <pre data-language=\"go\">func IsValue(v interface{}) bool</pre> <p> IsValue reports whether v is a valid Value parameter type. </p> <h2 id=\"ColumnConverter\">type ColumnConverter  </h2> <pre data-language=\"go\">type ColumnConverter interface {\n        // ColumnConverter returns a ValueConverter for the provided\n        // column index. If the type of a specific column isn't known\n        // or shouldn't be handled specially, DefaultValueConverter\n        // can be returned.\n        ColumnConverter(idx int) ValueConverter\n}</pre> <p> ColumnConverter may be optionally implemented by Stmt if the statement is aware of its own columns' types and can convert from any type to a driver Value. </p> <h2 id=\"Conn\">type Conn  </h2> <pre data-language=\"go\">type Conn interface {\n        // Prepare returns a prepared statement, bound to this connection.\n        Prepare(query string) (Stmt, error)\n\n        // Close invalidates and potentially stops any current\n        // prepared statements and transactions, marking this\n        // connection as no longer in use.\n        //\n        // Because the sql package maintains a free pool of\n        // connections and only calls Close when there's a surplus of\n        // idle connections, it shouldn't be necessary for drivers to\n        // do their own connection caching.\n        Close() error\n\n        // Begin starts and returns a new transaction.\n        Begin() (Tx, error)\n}</pre> <p> Conn is a connection to a database. It is not used concurrently by multiple goroutines. </p> <p> Conn is assumed to be stateful. </p> <h2 id=\"Driver\">type Driver  </h2> <pre data-language=\"go\">type Driver interface {\n        // Open returns a new connection to the database.\n        // The name is a string in a driver-specific format.\n        //\n        // Open may return a cached connection (one previously\n        // closed), but doing so is unnecessary; the sql package\n        // maintains a pool of idle connections for efficient re-use.\n        //\n        // The returned connection is only used by one goroutine at a\n        // time.\n        Open(name string) (Conn, error)\n}</pre> <p> Driver is the interface that must be implemented by a database driver. </p> <h2 id=\"Execer\">type Execer  </h2> <pre data-language=\"go\">type Execer interface {\n        Exec(query string, args []Value) (Result, error)\n}</pre> <p> Execer is an optional interface that may be implemented by a Conn. </p> <p> If a Conn does not implement Execer, the sql package's DB.Exec will first prepare a query, execute the statement, and then close the statement. </p> <p> Exec may return ErrSkip. </p> <h2 id=\"NotNull\">type NotNull  </h2> <pre data-language=\"go\">type NotNull struct {\n        Converter ValueConverter\n}</pre> <p> NotNull is a type that implements ValueConverter by disallowing nil values but otherwise delegating to another ValueConverter. </p> <h3 id=\"NotNull.ConvertValue\">func (NotNull) <a href=\"https://golang.org/src/database/sql/driver/types.go?s=4784:4843#L157\">ConvertValue</a>  </h3> <pre data-language=\"go\">func (n NotNull) ConvertValue(v interface{}) (Value, error)</pre> <h2 id=\"Null\">type Null  </h2> <pre data-language=\"go\">type Null struct {\n        Converter ValueConverter\n}</pre> <p> Null is a type that implements ValueConverter by allowing nil values but otherwise delegating to another ValueConverter. </p> <h3 id=\"Null.ConvertValue\">func (Null) <a href=\"https://golang.org/src/database/sql/driver/types.go?s=4466:4522#L144\">ConvertValue</a>  </h3> <pre data-language=\"go\">func (n Null) ConvertValue(v interface{}) (Value, error)</pre> <h2 id=\"Queryer\">type Queryer  </h2> <pre data-language=\"go\">type Queryer interface {\n        Query(query string, args []Value) (Rows, error)\n}</pre> <p> Queryer is an optional interface that may be implemented by a Conn. </p> <p> If a Conn does not implement Queryer, the sql package's DB.Query will first prepare a query, execute the statement, and then close the statement. </p> <p> Query may return ErrSkip. </p> <h2 id=\"Result\">type Result  </h2> <pre data-language=\"go\">type Result interface {\n        // LastInsertId returns the database's auto-generated ID\n        // after, for example, an INSERT into a table with primary\n        // key.\n        LastInsertId() (int64, error)\n\n        // RowsAffected returns the number of rows affected by the\n        // query.\n        RowsAffected() (int64, error)\n}</pre> <p> Result is the result of a query execution. </p> <h2 id=\"Rows\">type Rows  </h2> <pre data-language=\"go\">type Rows interface {\n        // Columns returns the names of the columns. The number of\n        // columns of the result is inferred from the length of the\n        // slice. If a particular column name isn't known, an empty\n        // string should be returned for that entry.\n        Columns() []string\n\n        // Close closes the rows iterator.\n        Close() error\n\n        // Next is called to populate the next row of data into\n        // the provided slice. The provided slice will be the same\n        // size as the Columns() are wide.\n        //\n        // Next should return io.EOF when there are no more rows.\n        Next(dest []Value) error\n}</pre> <p> Rows is an iterator over an executed query's results. </p> <h2 id=\"RowsAffected\">type RowsAffected  </h2> <pre data-language=\"go\">type RowsAffected int64</pre> <p> RowsAffected implements Result for an INSERT or UPDATE operation which mutates a number of rows. </p> <h3 id=\"RowsAffected.LastInsertId\">func (RowsAffected) <a href=\"https://golang.org/src/database/sql/driver/driver.go?s=5914:5963#L174\">LastInsertId</a>  </h3> <pre data-language=\"go\">func (RowsAffected) LastInsertId() (int64, error)</pre> <h3 id=\"RowsAffected.RowsAffected\">func (RowsAffected) <a href=\"https://golang.org/src/database/sql/driver/driver.go?s=6020:6071#L178\">RowsAffected</a>  </h3> <pre data-language=\"go\">func (v RowsAffected) RowsAffected() (int64, error)</pre> <h2 id=\"Stmt\">type Stmt  </h2> <pre data-language=\"go\">type Stmt interface {\n        // Close closes the statement.\n        //\n        // As of Go 1.1, a Stmt will not be closed if it's in use\n        // by any queries.\n        Close() error\n\n        // NumInput returns the number of placeholder parameters.\n        //\n        // If NumInput returns &gt;= 0, the sql package will sanity check\n        // argument counts from callers and return errors to the caller\n        // before the statement's Exec or Query methods are called.\n        //\n        // NumInput may also return -1, if the driver doesn't know\n        // its number of placeholders. In that case, the sql package\n        // will not sanity check Exec or Query argument counts.\n        NumInput() int\n\n        // Exec executes a query that doesn't return rows, such\n        // as an INSERT or UPDATE.\n        Exec(args []Value) (Result, error)\n\n        // Query executes a query that may return rows, such as a\n        // SELECT.\n        Query(args []Value) (Rows, error)\n}</pre> <p> Stmt is a prepared statement. It is bound to a Conn and not used by multiple goroutines concurrently. </p> <h2 id=\"Tx\">type Tx  </h2> <pre data-language=\"go\">type Tx interface {\n        Commit() error\n        Rollback() error\n}</pre> <p> Tx is a transaction. </p> <h2 id=\"Value\">type Value  </h2> <pre data-language=\"go\">type Value interface{}</pre> <p> Value is a value that drivers must be able to handle. It is either nil or an instance of one of these types: </p> <pre data-language=\"go\">int64\nfloat64\nbool\n[]byte\nstring\ntime.Time\n</pre> <h2 id=\"ValueConverter\">type ValueConverter  </h2> <pre data-language=\"go\">type ValueConverter interface {\n        // ConvertValue converts a value to a driver Value.\n        ConvertValue(v interface{}) (Value, error)\n}</pre> <p> ValueConverter is the interface providing the ConvertValue method. </p> <p> Various implementations of ValueConverter are provided by the driver package to provide consistent implementations of conversions between drivers. The ValueConverters have several uses: </p> <pre data-language=\"go\">* converting from the Value types as provided by the sql package\n  into a database table's specific column type and making sure it\n  fits, such as making sure a particular int64 fits in a\n  table's uint16 column.\n\n* converting a value as given from the database into one of the\n  driver Value types.\n\n* by the sql package, for converting from a driver's Value type\n  to a user's type in a scan.\n</pre> <h2 id=\"Valuer\">type Valuer  </h2> <pre data-language=\"go\">type Valuer interface {\n        // Value returns a driver Value.\n        Value() (Value, error)\n}</pre> <p> Valuer is the interface providing the Value method. </p> <p> Types implementing Valuer interface are able to convert themselves to a driver Value. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/database/sql/driver/\" class=\"_attribution-link\">https://golang.org/pkg/database/sql/driver/</a>\n  </p>\n</div>\n","encoding/asn1/index":"<h1>Package asn1</h1>     <ul id=\"short-nav\">\n<li><code>import \"encoding/asn1\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package asn1 implements parsing of DER-encoded ASN.1 data structures, as defined in ITU-T Rec X.690. </p> <p> See also “A Layman's Guide to a Subset of ASN.1, BER, and DER,” <a href=\"http://luca.ntop.org/Teaching/Appunti/asn1.html\">http://luca.ntop.org/Teaching/Appunti/asn1.html</a>. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#Marshal\">func Marshal(val interface{}) ([]byte, error)</a></li>\n<li><a href=\"#Unmarshal\">func Unmarshal(b []byte, val interface{}) (rest []byte, err error)</a></li>\n<li><a href=\"#UnmarshalWithParams\">func UnmarshalWithParams(b []byte, val interface{}, params string) (rest []byte, err error)</a></li>\n<li><a href=\"#BitString\">type BitString</a></li>\n<li> <a href=\"#BitString.At\">func (b BitString) At(i int) int</a>\n</li>\n<li> <a href=\"#BitString.RightAlign\">func (b BitString) RightAlign() []byte</a>\n</li>\n<li><a href=\"#Enumerated\">type Enumerated</a></li>\n<li><a href=\"#Flag\">type Flag</a></li>\n<li><a href=\"#ObjectIdentifier\">type ObjectIdentifier</a></li>\n<li> <a href=\"#ObjectIdentifier.Equal\">func (oi ObjectIdentifier) Equal(other ObjectIdentifier) bool</a>\n</li>\n<li> <a href=\"#ObjectIdentifier.String\">func (oi ObjectIdentifier) String() string</a>\n</li>\n<li><a href=\"#RawContent\">type RawContent</a></li>\n<li><a href=\"#RawValue\">type RawValue</a></li>\n<li><a href=\"#StructuralError\">type StructuralError</a></li>\n<li> <a href=\"#StructuralError.Error\">func (e StructuralError) Error() string</a>\n</li>\n<li><a href=\"#SyntaxError\">type SyntaxError</a></li>\n<li> <a href=\"#SyntaxError.Error\">func (e SyntaxError) Error() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/encoding/asn1/asn1.go\">asn1.go</a> <a href=\"https://golang.org/src/encoding/asn1/common.go\">common.go</a> <a href=\"https://golang.org/src/encoding/asn1/marshal.go\">marshal.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        TagBoolean         = 1\n        TagInteger         = 2\n        TagBitString       = 3\n        TagOctetString     = 4\n        TagOID             = 6\n        TagEnum            = 10\n        TagUTF8String      = 12\n        TagSequence        = 16\n        TagSet             = 17\n        TagPrintableString = 19\n        TagT61String       = 20\n        TagIA5String       = 22\n        TagUTCTime         = 23\n        TagGeneralizedTime = 24\n        TagGeneralString   = 27\n)</pre> <p> ASN.1 tags represent the type of the following object. </p> <pre data-language=\"go\">const (\n        ClassUniversal       = 0\n        ClassApplication     = 1\n        ClassContextSpecific = 2\n        ClassPrivate         = 3\n)</pre> <p> ASN.1 class types represent the namespace of the tag. </p> <h2 id=\"Marshal\">func Marshal  </h2> <pre data-language=\"go\">func Marshal(val interface{}) ([]byte, error)</pre> <p> Marshal returns the ASN.1 encoding of val. </p> <p> In addition to the struct tags recognised by Unmarshal, the following can be used: </p> <pre data-language=\"go\">ia5:\t\tcauses strings to be marshaled as ASN.1, IA5 strings\nomitempty:\tcauses empty slices to be skipped\nprintable:\tcauses strings to be marshaled as ASN.1, PrintableString strings.\nutf8:\t\tcauses strings to be marshaled as ASN.1, UTF8 strings\n</pre> <h2 id=\"Unmarshal\">func Unmarshal  </h2> <pre data-language=\"go\">func Unmarshal(b []byte, val interface{}) (rest []byte, err error)</pre> <p> Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names. </p> <p> An ASN.1 INTEGER can be written to an int, int32, int64, or *big.Int (from the math/big package). If the encoded value does not fit in the Go type, Unmarshal returns a parse error. </p> <p> An ASN.1 BIT STRING can be written to a BitString. </p> <p> An ASN.1 OCTET STRING can be written to a []byte. </p> <p> An ASN.1 OBJECT IDENTIFIER can be written to an ObjectIdentifier. </p> <p> An ASN.1 ENUMERATED can be written to an Enumerated. </p> <p> An ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time. </p> <p> An ASN.1 PrintableString or IA5String can be written to a string. </p> <p> Any of the above ASN.1 values can be written to an interface{}. The value stored in the interface has the corresponding Go type. For integers, that type is int64. </p> <p> An ASN.1 SEQUENCE OF x or SET OF x can be written to a slice if an x can be written to the slice's element type. </p> <p> An ASN.1 SEQUENCE or SET can be written to a struct if each of the elements in the sequence can be written to the corresponding element in the struct. </p> <p> The following tags on struct fields have special meaning to Unmarshal: </p> <pre data-language=\"go\">application\tspecifies that a APPLICATION tag is used\ndefault:x\tsets the default value for optional integer fields\nexplicit\tspecifies that an additional, explicit tag wraps the implicit one\noptional\tmarks the field as ASN.1 OPTIONAL\nset\t\tcauses a SET, rather than a SEQUENCE type to be expected\ntag:x\t\tspecifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\n</pre> <p> If the type of the first field of a structure is RawContent then the raw ASN1 contents of the struct will be stored in it. </p> <p> If the type name of a slice element ends with \"SET\" then it's treated as if the \"set\" tag was set on it. This can be used with nested slices where a struct tag cannot be given. </p> <p> Other ASN.1 types are not supported; if it encounters them, Unmarshal returns a parse error. </p> <h2 id=\"UnmarshalWithParams\">func UnmarshalWithParams  </h2> <pre data-language=\"go\">func UnmarshalWithParams(b []byte, val interface{}, params string) (rest []byte, err error)</pre> <p> UnmarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags. </p> <h2 id=\"BitString\">type BitString  </h2> <pre data-language=\"go\">type BitString struct {\n        Bytes     []byte // bits packed into bytes.\n        BitLength int    // length in bits.\n}</pre> <p> BitString is the structure to use when you want an ASN.1 BIT STRING type. A bit string is padded up to the nearest byte in memory and the number of valid bits is recorded. Padding bits will be zero. </p> <h3 id=\"BitString.At\">func (BitString) <a href=\"https://golang.org/src/encoding/asn1/asn1.go?s=4387:4419#L154\">At</a>  </h3> <pre data-language=\"go\">func (b BitString) At(i int) int</pre> <p> At returns the bit at the given index. If the index is out of range it returns false. </p> <h3 id=\"BitString.RightAlign\">func (BitString) <a href=\"https://golang.org/src/encoding/asn1/asn1.go?s=4659:4697#L165\">RightAlign</a>  </h3> <pre data-language=\"go\">func (b BitString) RightAlign() []byte</pre> <p> RightAlign returns a slice where the padding bits are at the beginning. The slice may share memory with the BitString. </p> <h2 id=\"Enumerated\">type Enumerated  </h2> <pre data-language=\"go\">type Enumerated int</pre> <p> An Enumerated is represented as a plain int. </p> <h2 id=\"Flag\">type Flag  </h2> <pre data-language=\"go\">type Flag bool</pre> <p> A Flag accepts any data and is set to true if present. </p> <h2 id=\"ObjectIdentifier\">type ObjectIdentifier  </h2> <pre data-language=\"go\">type ObjectIdentifier []int</pre> <p> An ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER. </p> <h3 id=\"ObjectIdentifier.Equal\">func (ObjectIdentifier) <a href=\"https://golang.org/src/encoding/asn1/asn1.go?s=5683:5744#L205\">Equal</a>  </h3> <pre data-language=\"go\">func (oi ObjectIdentifier) Equal(other ObjectIdentifier) bool</pre> <p> Equal reports whether oi and other represent the same identifier. </p> <h3 id=\"ObjectIdentifier.String\">func (ObjectIdentifier) <a href=\"https://golang.org/src/encoding/asn1/asn1.go?s=5890:5932#L218\">String</a>  </h3> <pre data-language=\"go\">func (oi ObjectIdentifier) String() string</pre> <h2 id=\"RawContent\">type RawContent  </h2> <pre data-language=\"go\">type RawContent []byte</pre> <p> RawContent is used to signal that the undecoded, DER data needs to be preserved for a struct. To use it, the first field of the struct must have this type. It's an error for any of the other fields to have this type. </p> <h2 id=\"RawValue\">type RawValue  </h2> <pre data-language=\"go\">type RawValue struct {\n        Class, Tag int\n        IsCompound bool\n        Bytes      []byte\n        FullBytes  []byte // includes the tag and length\n}</pre> <p> A RawValue represents an undecoded ASN.1 object. </p> <h2 id=\"StructuralError\">type StructuralError  </h2> <pre data-language=\"go\">type StructuralError struct {\n        Msg string\n}</pre> <p> A StructuralError suggests that the ASN.1 data is valid, but the Go type which is receiving it doesn't match. </p> <h3 id=\"StructuralError.Error\">func (StructuralError) <a href=\"https://golang.org/src/encoding/asn1/asn1.go?s=1214:1253#L28\">Error</a>  </h3> <pre data-language=\"go\">func (e StructuralError) Error() string</pre> <h2 id=\"SyntaxError\">type SyntaxError  </h2> <pre data-language=\"go\">type SyntaxError struct {\n        Msg string\n}</pre> <p> A SyntaxError suggests that the ASN.1 data is invalid. </p> <h3 id=\"SyntaxError.Error\">func (SyntaxError) <a href=\"https://golang.org/src/encoding/asn1/asn1.go?s=1399:1434#L35\">Error</a>  </h3> <pre data-language=\"go\">func (e SyntaxError) Error() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/encoding/asn1/\" class=\"_attribution-link\">https://golang.org/pkg/encoding/asn1/</a>\n  </p>\n</div>\n","bytes/index":"<h1>Package bytes</h1>     <ul id=\"short-nav\">\n<li><code>import \"bytes\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Compare\">func Compare(a, b []byte) int</a></li>\n<li><a href=\"#Contains\">func Contains(b, subslice []byte) bool</a></li>\n<li><a href=\"#ContainsAny\">func ContainsAny(b []byte, chars string) bool</a></li>\n<li><a href=\"#ContainsRune\">func ContainsRune(b []byte, r rune) bool</a></li>\n<li><a href=\"#Count\">func Count(s, sep []byte) int</a></li>\n<li><a href=\"#Equal\">func Equal(a, b []byte) bool</a></li>\n<li><a href=\"#EqualFold\">func EqualFold(s, t []byte) bool</a></li>\n<li><a href=\"#Fields\">func Fields(s []byte) [][]byte</a></li>\n<li><a href=\"#FieldsFunc\">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</a></li>\n<li><a href=\"#HasPrefix\">func HasPrefix(s, prefix []byte) bool</a></li>\n<li><a href=\"#HasSuffix\">func HasSuffix(s, suffix []byte) bool</a></li>\n<li><a href=\"#Index\">func Index(s, sep []byte) int</a></li>\n<li><a href=\"#IndexAny\">func IndexAny(s []byte, chars string) int</a></li>\n<li><a href=\"#IndexByte\">func IndexByte(s []byte, c byte) int</a></li>\n<li><a href=\"#IndexFunc\">func IndexFunc(s []byte, f func(r rune) bool) int</a></li>\n<li><a href=\"#IndexRune\">func IndexRune(s []byte, r rune) int</a></li>\n<li><a href=\"#Join\">func Join(s [][]byte, sep []byte) []byte</a></li>\n<li><a href=\"#LastIndex\">func LastIndex(s, sep []byte) int</a></li>\n<li><a href=\"#LastIndexAny\">func LastIndexAny(s []byte, chars string) int</a></li>\n<li><a href=\"#LastIndexByte\">func LastIndexByte(s []byte, c byte) int</a></li>\n<li><a href=\"#LastIndexFunc\">func LastIndexFunc(s []byte, f func(r rune) bool) int</a></li>\n<li><a href=\"#Map\">func Map(mapping func(r rune) rune, s []byte) []byte</a></li>\n<li><a href=\"#Repeat\">func Repeat(b []byte, count int) []byte</a></li>\n<li><a href=\"#Replace\">func Replace(s, old, new []byte, n int) []byte</a></li>\n<li><a href=\"#Runes\">func Runes(s []byte) []rune</a></li>\n<li><a href=\"#Split\">func Split(s, sep []byte) [][]byte</a></li>\n<li><a href=\"#SplitAfter\">func SplitAfter(s, sep []byte) [][]byte</a></li>\n<li><a href=\"#SplitAfterN\">func SplitAfterN(s, sep []byte, n int) [][]byte</a></li>\n<li><a href=\"#SplitN\">func SplitN(s, sep []byte, n int) [][]byte</a></li>\n<li><a href=\"#Title\">func Title(s []byte) []byte</a></li>\n<li><a href=\"#ToLower\">func ToLower(s []byte) []byte</a></li>\n<li><a href=\"#ToLowerSpecial\">func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte</a></li>\n<li><a href=\"#ToTitle\">func ToTitle(s []byte) []byte</a></li>\n<li><a href=\"#ToTitleSpecial\">func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte</a></li>\n<li><a href=\"#ToUpper\">func ToUpper(s []byte) []byte</a></li>\n<li><a href=\"#ToUpperSpecial\">func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte</a></li>\n<li><a href=\"#Trim\">func Trim(s []byte, cutset string) []byte</a></li>\n<li><a href=\"#TrimFunc\">func TrimFunc(s []byte, f func(r rune) bool) []byte</a></li>\n<li><a href=\"#TrimLeft\">func TrimLeft(s []byte, cutset string) []byte</a></li>\n<li><a href=\"#TrimLeftFunc\">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</a></li>\n<li><a href=\"#TrimPrefix\">func TrimPrefix(s, prefix []byte) []byte</a></li>\n<li><a href=\"#TrimRight\">func TrimRight(s []byte, cutset string) []byte</a></li>\n<li><a href=\"#TrimRightFunc\">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</a></li>\n<li><a href=\"#TrimSpace\">func TrimSpace(s []byte) []byte</a></li>\n<li><a href=\"#TrimSuffix\">func TrimSuffix(s, suffix []byte) []byte</a></li>\n<li><a href=\"#Buffer\">type Buffer</a></li>\n<li> <a href=\"#NewBuffer\">func NewBuffer(buf []byte) *Buffer</a>\n</li>\n<li> <a href=\"#NewBufferString\">func NewBufferString(s string) *Buffer</a>\n</li>\n<li> <a href=\"#Buffer.Bytes\">func (b *Buffer) Bytes() []byte</a>\n</li>\n<li> <a href=\"#Buffer.Cap\">func (b *Buffer) Cap() int</a>\n</li>\n<li> <a href=\"#Buffer.Grow\">func (b *Buffer) Grow(n int)</a>\n</li>\n<li> <a href=\"#Buffer.Len\">func (b *Buffer) Len() int</a>\n</li>\n<li> <a href=\"#Buffer.Next\">func (b *Buffer) Next(n int) []byte</a>\n</li>\n<li> <a href=\"#Buffer.Read\">func (b *Buffer) Read(p []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#Buffer.ReadByte\">func (b *Buffer) ReadByte() (byte, error)</a>\n</li>\n<li> <a href=\"#Buffer.ReadBytes\">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</a>\n</li>\n<li> <a href=\"#Buffer.ReadFrom\">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</a>\n</li>\n<li> <a href=\"#Buffer.ReadRune\">func (b *Buffer) ReadRune() (r rune, size int, err error)</a>\n</li>\n<li> <a href=\"#Buffer.ReadString\">func (b *Buffer) ReadString(delim byte) (line string, err error)</a>\n</li>\n<li> <a href=\"#Buffer.Reset\">func (b *Buffer) Reset()</a>\n</li>\n<li> <a href=\"#Buffer.String\">func (b *Buffer) String() string</a>\n</li>\n<li> <a href=\"#Buffer.Truncate\">func (b *Buffer) Truncate(n int)</a>\n</li>\n<li> <a href=\"#Buffer.UnreadByte\">func (b *Buffer) UnreadByte() error</a>\n</li>\n<li> <a href=\"#Buffer.UnreadRune\">func (b *Buffer) UnreadRune() error</a>\n</li>\n<li> <a href=\"#Buffer.Write\">func (b *Buffer) Write(p []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#Buffer.WriteByte\">func (b *Buffer) WriteByte(c byte) error</a>\n</li>\n<li> <a href=\"#Buffer.WriteRune\">func (b *Buffer) WriteRune(r rune) (n int, err error)</a>\n</li>\n<li> <a href=\"#Buffer.WriteString\">func (b *Buffer) WriteString(s string) (n int, err error)</a>\n</li>\n<li> <a href=\"#Buffer.WriteTo\">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</a>\n</li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li> <a href=\"#NewReader\">func NewReader(b []byte) *Reader</a>\n</li>\n<li> <a href=\"#Reader.Len\">func (r *Reader) Len() int</a>\n</li>\n<li> <a href=\"#Reader.Read\">func (r *Reader) Read(b []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#Reader.ReadAt\">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</a>\n</li>\n<li> <a href=\"#Reader.ReadByte\">func (r *Reader) ReadByte() (byte, error)</a>\n</li>\n<li> <a href=\"#Reader.ReadRune\">func (r *Reader) ReadRune() (ch rune, size int, err error)</a>\n</li>\n<li> <a href=\"#Reader.Reset\">func (r *Reader) Reset(b []byte)</a>\n</li>\n<li> <a href=\"#Reader.Seek\">func (r *Reader) Seek(offset int64, whence int) (int64, error)</a>\n</li>\n<li> <a href=\"#Reader.Size\">func (r *Reader) Size() int64</a>\n</li>\n<li> <a href=\"#Reader.UnreadByte\">func (r *Reader) UnreadByte() error</a>\n</li>\n<li> <a href=\"#Reader.UnreadRune\">func (r *Reader) UnreadRune() error</a>\n</li>\n<li> <a href=\"#Reader.WriteTo\">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</a>\n</li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Buffer\">Buffer</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Buffer_reader\">Buffer (Reader)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Compare\">Compare</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Compare_search\">Compare (Search)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_TrimPrefix\">TrimPrefix</a></dd> <dd><a class=\"exampleLink\" href=\"#example_TrimSuffix\">TrimSuffix</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/bytes/buffer.go\">buffer.go</a> <a href=\"https://golang.org/src/bytes/bytes.go\">bytes.go</a> <a href=\"https://golang.org/src/bytes/bytes_decl.go\">bytes_decl.go</a> <a href=\"https://golang.org/src/bytes/reader.go\">reader.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const MinRead = 512</pre> <p> MinRead is the minimum slice size passed to a Read call by Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond what is required to hold the contents of r, ReadFrom will not grow the underlying buffer. </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrTooLarge = errors.New(\"bytes.Buffer: too large\")</pre> <p> ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer. </p> <h2 id=\"Compare\">func Compare  </h2> <pre data-language=\"go\">func Compare(a, b []byte) int</pre> <p> Compare returns an integer comparing two byte slices lexicographically. The result will be 0 if a==b, -1 if a &lt; b, and +1 if a &gt; b. A nil argument is equivalent to an empty slice. </p> <div id=\"example_Compare\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n)\n\nfunc main() {\n\t// Interpret Compare's result by comparing it to zero.\n\tvar a, b []byte\n\tif bytes.Compare(a, b) &lt; 0 {\n\t\t// a less b\n\t}\n\tif bytes.Compare(a, b) &lt;= 0 {\n\t\t// a less or equal b\n\t}\n\tif bytes.Compare(a, b) &gt; 0 {\n\t\t// a greater b\n\t}\n\tif bytes.Compare(a, b) &gt;= 0 {\n\t\t// a greater or equal b\n\t}\n\n\t// Prefer Equal to Compare for equality comparisons.\n\tif bytes.Equal(a, b) {\n\t\t// a equal b\n\t}\n\tif !bytes.Equal(a, b) {\n\t\t// a not equal b\n\t}\n}\n</pre> </div> </div> <div id=\"example_Compare_search\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Search)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"sort\"\n)\n\nfunc main() {\n\t// Binary search to find a matching byte slice.\n\tvar needle []byte\n\tvar haystack [][]byte // Assume sorted\n\ti := sort.Search(len(haystack), func(i int) bool {\n\t\t// Return haystack[i] &gt;= needle.\n\t\treturn bytes.Compare(haystack[i], needle) &gt;= 0\n\t})\n\tif i &lt; len(haystack) &amp;&amp; bytes.Equal(haystack[i], needle) {\n\t\t// Found it!\n\t}\n}\n</pre> </div> </div> <h2 id=\"Contains\">func Contains  </h2> <pre data-language=\"go\">func Contains(b, subslice []byte) bool</pre> <p> Contains reports whether subslice is within b. </p> <h2 id=\"ContainsAny\">func ContainsAny  </h2> <pre data-language=\"go\">func ContainsAny(b []byte, chars string) bool</pre> <p> ContainsAny reports whether any of the UTF-8-encoded Unicode code points in chars are within b. </p> <h2 id=\"ContainsRune\">func ContainsRune  </h2> <pre data-language=\"go\">func ContainsRune(b []byte, r rune) bool</pre> <p> ContainsRune reports whether the Unicode code point r is within b. </p> <h2 id=\"Count\">func Count  </h2> <pre data-language=\"go\">func Count(s, sep []byte) int</pre> <p> Count counts the number of non-overlapping instances of sep in s. If sep is an empty slice, Count returns 1 + the number of Unicode code points in s. </p> <h2 id=\"Equal\">func Equal  </h2> <pre data-language=\"go\">func Equal(a, b []byte) bool</pre> <p> Equal returns a boolean reporting whether a and b are the same length and contain the same bytes. A nil argument is equivalent to an empty slice. </p> <h2 id=\"EqualFold\">func EqualFold  </h2> <pre data-language=\"go\">func EqualFold(s, t []byte) bool</pre> <p> EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under Unicode case-folding. </p> <h2 id=\"Fields\">func Fields  </h2> <pre data-language=\"go\">func Fields(s []byte) [][]byte</pre> <p> Fields splits the slice s around each instance of one or more consecutive white space characters, returning a slice of subslices of s or an empty list if s contains only white space. </p> <h2 id=\"FieldsFunc\">func FieldsFunc  </h2> <pre data-language=\"go\">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</pre> <p> FieldsFunc interprets s as a sequence of UTF-8-encoded Unicode code points. It splits the slice s at each run of code points c satisfying f(c) and returns a slice of subslices of s. If all code points in s satisfy f(c), or len(s) == 0, an empty slice is returned. FieldsFunc makes no guarantees about the order in which it calls f(c). If f does not return consistent results for a given c, FieldsFunc may crash. </p> <h2 id=\"HasPrefix\">func HasPrefix  </h2> <pre data-language=\"go\">func HasPrefix(s, prefix []byte) bool</pre> <p> HasPrefix tests whether the byte slice s begins with prefix. </p> <h2 id=\"HasSuffix\">func HasSuffix  </h2> <pre data-language=\"go\">func HasSuffix(s, suffix []byte) bool</pre> <p> HasSuffix tests whether the byte slice s ends with suffix. </p> <h2 id=\"Index\">func Index  </h2> <pre data-language=\"go\">func Index(s, sep []byte) int</pre> <p> Index returns the index of the first instance of sep in s, or -1 if sep is not present in s. </p> <h2 id=\"IndexAny\">func IndexAny  </h2> <pre data-language=\"go\">func IndexAny(s []byte, chars string) int</pre> <p> IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common. </p> <h2 id=\"IndexByte\">func IndexByte  </h2> <pre data-language=\"go\">func IndexByte(s []byte, c byte) int</pre> <p> IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s. </p> <h2 id=\"IndexFunc\">func IndexFunc  </h2> <pre data-language=\"go\">func IndexFunc(s []byte, f func(r rune) bool) int</pre> <p> IndexFunc interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do. </p> <h2 id=\"IndexRune\">func IndexRune  </h2> <pre data-language=\"go\">func IndexRune(s []byte, r rune) int</pre> <p> IndexRune interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s. </p> <h2 id=\"Join\">func Join  </h2> <pre data-language=\"go\">func Join(s [][]byte, sep []byte) []byte</pre> <p> Join concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice. </p> <h2 id=\"LastIndex\">func LastIndex  </h2> <pre data-language=\"go\">func LastIndex(s, sep []byte) int</pre> <p> LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s. </p> <h2 id=\"LastIndexAny\">func LastIndexAny  </h2> <pre data-language=\"go\">func LastIndexAny(s []byte, chars string) int</pre> <p> LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common. </p> <h2 id=\"LastIndexByte\">func LastIndexByte  </h2> <pre data-language=\"go\">func LastIndexByte(s []byte, c byte) int</pre> <p> LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s. </p> <h2 id=\"LastIndexFunc\">func LastIndexFunc  </h2> <pre data-language=\"go\">func LastIndexFunc(s []byte, f func(r rune) bool) int</pre> <p> LastIndexFunc interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do. </p> <h2 id=\"Map\">func Map  </h2> <pre data-language=\"go\">func Map(mapping func(r rune) rune, s []byte) []byte</pre> <p> Map returns a copy of the byte slice s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement. The characters in s and the output are interpreted as UTF-8-encoded Unicode code points. </p> <h2 id=\"Repeat\">func Repeat  </h2> <pre data-language=\"go\">func Repeat(b []byte, count int) []byte</pre> <p> Repeat returns a new byte slice consisting of count copies of b. </p> <h2 id=\"Replace\">func Replace  </h2> <pre data-language=\"go\">func Replace(s, old, new []byte, n int) []byte</pre> <p> Replace returns a copy of the slice s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. If n &lt; 0, there is no limit on the number of replacements. </p> <h2 id=\"Runes\">func Runes  </h2> <pre data-language=\"go\">func Runes(s []byte) []rune</pre> <p> Runes returns a slice of runes (Unicode code points) equivalent to s. </p> <h2 id=\"Split\">func Split  </h2> <pre data-language=\"go\">func Split(s, sep []byte) [][]byte</pre> <p> Split slices s into all subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1. </p> <h2 id=\"SplitAfter\">func SplitAfter  </h2> <pre data-language=\"go\">func SplitAfter(s, sep []byte) [][]byte</pre> <p> SplitAfter slices s into all subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1. </p> <h2 id=\"SplitAfterN\">func SplitAfterN  </h2> <pre data-language=\"go\">func SplitAfterN(s, sep []byte, n int) [][]byte</pre> <p> SplitAfterN slices s into subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of subslices to return: </p> <pre data-language=\"go\">n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder.\nn == 0: the result is nil (zero subslices)\nn &lt; 0: all subslices\n</pre> <h2 id=\"SplitN\">func SplitN  </h2> <pre data-language=\"go\">func SplitN(s, sep []byte, n int) [][]byte</pre> <p> SplitN slices s into subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of subslices to return: </p> <pre data-language=\"go\">n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder.\nn == 0: the result is nil (zero subslices)\nn &lt; 0: all subslices\n</pre> <h2 id=\"Title\">func Title  </h2> <pre data-language=\"go\">func Title(s []byte) []byte</pre> <p> Title returns a copy of s with all Unicode letters that begin words mapped to their title case. </p> <p> BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly. </p> <h2 id=\"ToLower\">func ToLower  </h2> <pre data-language=\"go\">func ToLower(s []byte) []byte</pre> <p> ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case. </p> <h2 id=\"ToLowerSpecial\">func ToLowerSpecial  </h2> <pre data-language=\"go\">func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte</pre> <p> ToLowerSpecial returns a copy of the byte slice s with all Unicode letters mapped to their lower case, giving priority to the special casing rules. </p> <h2 id=\"ToTitle\">func ToTitle  </h2> <pre data-language=\"go\">func ToTitle(s []byte) []byte</pre> <p> ToTitle returns a copy of the byte slice s with all Unicode letters mapped to their title case. </p> <h2 id=\"ToTitleSpecial\">func ToTitleSpecial  </h2> <pre data-language=\"go\">func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte</pre> <p> ToTitleSpecial returns a copy of the byte slice s with all Unicode letters mapped to their title case, giving priority to the special casing rules. </p> <h2 id=\"ToUpper\">func ToUpper  </h2> <pre data-language=\"go\">func ToUpper(s []byte) []byte</pre> <p> ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case. </p> <h2 id=\"ToUpperSpecial\">func ToUpperSpecial  </h2> <pre data-language=\"go\">func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte</pre> <p> ToUpperSpecial returns a copy of the byte slice s with all Unicode letters mapped to their upper case, giving priority to the special casing rules. </p> <h2 id=\"Trim\">func Trim  </h2> <pre data-language=\"go\">func Trim(s []byte, cutset string) []byte</pre> <p> Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded Unicode code points contained in cutset. </p> <h2 id=\"TrimFunc\">func TrimFunc  </h2> <pre data-language=\"go\">func TrimFunc(s []byte, f func(r rune) bool) []byte</pre> <p> TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded Unicode code points c that satisfy f(c). </p> <h2 id=\"TrimLeft\">func TrimLeft  </h2> <pre data-language=\"go\">func TrimLeft(s []byte, cutset string) []byte</pre> <p> TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded Unicode code points contained in cutset. </p> <h2 id=\"TrimLeftFunc\">func TrimLeftFunc  </h2> <pre data-language=\"go\">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</pre> <p> TrimLeftFunc returns a subslice of s by slicing off all leading UTF-8-encoded Unicode code points c that satisfy f(c). </p> <h2 id=\"TrimPrefix\">func TrimPrefix  </h2> <pre data-language=\"go\">func TrimPrefix(s, prefix []byte) []byte</pre> <p> TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged. </p> <div id=\"example_TrimPrefix\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar b = []byte(\"Goodbye,, world!\")\n\tb = bytes.TrimPrefix(b, []byte(\"Goodbye,\"))\n\tb = bytes.TrimPrefix(b, []byte(\"See ya,\"))\n\tfmt.Printf(\"Hello%s\", b)\n}\n</pre> </div> </div> <h2 id=\"TrimRight\">func TrimRight  </h2> <pre data-language=\"go\">func TrimRight(s []byte, cutset string) []byte</pre> <p> TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded Unicode code points that are contained in cutset. </p> <h2 id=\"TrimRightFunc\">func TrimRightFunc  </h2> <pre data-language=\"go\">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</pre> <p> TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8 encoded Unicode code points c that satisfy f(c). </p> <h2 id=\"TrimSpace\">func TrimSpace  </h2> <pre data-language=\"go\">func TrimSpace(s []byte) []byte</pre> <p> TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode. </p> <h2 id=\"TrimSuffix\">func TrimSuffix  </h2> <pre data-language=\"go\">func TrimSuffix(s, suffix []byte) []byte</pre> <p> TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged. </p> <div id=\"example_TrimSuffix\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar b = []byte(\"Hello, goodbye, etc!\")\n\tb = bytes.TrimSuffix(b, []byte(\"goodbye, etc!\"))\n\tb = bytes.TrimSuffix(b, []byte(\"gopher\"))\n\tb = append(b, bytes.TrimSuffix([]byte(\"world!\"), []byte(\"x!\"))...)\n\tos.Stdout.Write(b)\n}\n</pre> </div> </div> <h2 id=\"Buffer\">type Buffer  </h2> <pre data-language=\"go\">type Buffer struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Buffer is a variable-sized buffer of bytes with Read and Write methods. The zero value for Buffer is an empty buffer ready to use. </p> <div id=\"example_Buffer\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar b bytes.Buffer // A Buffer needs no initialization.\n\tb.Write([]byte(\"Hello \"))\n\tfmt.Fprintf(&amp;b, \"world!\")\n\tb.WriteTo(os.Stdout)\n}\n</pre> </div> </div> <div id=\"example_Buffer_reader\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Reader)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\t// A Buffer can turn a string or a []byte into an io.Reader.\n\tbuf := bytes.NewBufferString(\"R29waGVycyBydWxlIQ==\")\n\tdec := base64.NewDecoder(base64.StdEncoding, buf)\n\tio.Copy(os.Stdout, dec)\n}\n</pre> </div> </div> <h3 id=\"NewBuffer\">func <a href=\"https://golang.org/src/bytes/buffer.go?s=13116:13150#L399\">NewBuffer</a>  </h3> <pre data-language=\"go\">func NewBuffer(buf []byte) *Buffer</pre> <p> NewBuffer creates and initializes a new Buffer using buf as its initial contents. It is intended to prepare a Buffer to read existing data. It can also be used to size the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero. </p> <p> In most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer. </p> <h3 id=\"NewBufferString\">func <a href=\"https://golang.org/src/bytes/buffer.go?s=13458:13496#L407\">NewBufferString</a>  </h3> <pre data-language=\"go\">func NewBufferString(s string) *Buffer</pre> <p> NewBufferString creates and initializes a new Buffer using string s as its initial contents. It is intended to prepare a buffer to read an existing string. </p> <p> In most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer. </p> <h3 id=\"Buffer.Bytes\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=1716:1747#L34\">Bytes</a>  </h3> <pre data-language=\"go\">func (b *Buffer) Bytes() []byte</pre> <p> Bytes returns a slice of length b.Len() holding the unread portion of the buffer. The slice is valid for use only until the next buffer modification (that is, only until the next call to a method like Read, Write, Reset, or Truncate). The slice aliases the buffer content at least until the next buffer modification, so immediate changes to the slice will affect the result of future reads. </p> <h3 id=\"Buffer.Cap\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=2340:2366#L52\">Cap</a>  </h3> <pre data-language=\"go\">func (b *Buffer) Cap() int</pre> <p> Cap returns the capacity of the buffer's underlying byte slice, that is, the total space allocated for the buffer's data. </p> <h3 id=\"Buffer.Grow\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=4216:4244#L111\">Grow</a>  </h3> <pre data-language=\"go\">func (b *Buffer) Grow(n int)</pre> <p> Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with ErrTooLarge. </p> <h3 id=\"Buffer.Len\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=2154:2180#L48\">Len</a>  </h3> <pre data-language=\"go\">func (b *Buffer) Len() int</pre> <p> Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()). </p> <h3 id=\"Buffer.Next\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=9109:9144#L270\">Next</a>  </h3> <pre data-language=\"go\">func (b *Buffer) Next(n int) []byte</pre> <p> Next returns a slice containing the next n bytes from the buffer, advancing the buffer as if the bytes had been returned by Read. If there are fewer than n bytes in the buffer, Next returns the entire buffer. The slice is only valid until the next call to a read or write method. </p> <h3 id=\"Buffer.Read\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=8509:8559#L248\">Read</a>  </h3> <pre data-language=\"go\">func (b *Buffer) Read(p []byte) (n int, err error)</pre> <p> Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is io.EOF (unless len(p) is zero); otherwise it is nil. </p> <h3 id=\"Buffer.ReadByte\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=9419:9460#L286\">ReadByte</a>  </h3> <pre data-language=\"go\">func (b *Buffer) ReadByte() (byte, error)</pre> <p> ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error io.EOF. </p> <h3 id=\"Buffer.ReadBytes\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=11632:11695#L359\">ReadBytes</a>  </h3> <pre data-language=\"go\">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</pre> <p> ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. </p> <h3 id=\"Buffer.ReadFrom\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=5609:5668#L147\">ReadFrom</a>  </h3> <pre data-language=\"go\">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</pre> <p> ReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with ErrTooLarge. </p> <h3 id=\"Buffer.ReadRune\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=9912:9969#L304\">ReadRune</a>  </h3> <pre data-language=\"go\">func (b *Buffer) ReadRune() (r rune, size int, err error)</pre> <p> ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1. </p> <h3 id=\"Buffer.ReadString\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=12589:12653#L387\">ReadString</a>  </h3> <pre data-language=\"go\">func (b *Buffer) ReadString(delim byte) (line string, err error)</pre> <p> ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. </p> <h3 id=\"Buffer.Reset\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=2959:2983#L72\">Reset</a>  </h3> <pre data-language=\"go\">func (b *Buffer) Reset()</pre> <p> Reset resets the buffer to be empty, but it retains the underlying storage for use by future writes. Reset is the same as Truncate(0). </p> <h3 id=\"Buffer.String\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=1909:1941#L38\">String</a>  </h3> <pre data-language=\"go\">func (b *Buffer) String() string</pre> <p> String returns the contents of the unread portion of the buffer as a string. If the Buffer is a nil pointer, it returns \"&lt;nil&gt;\". </p> <h3 id=\"Buffer.Truncate\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=2584:2616#L57\">Truncate</a>  </h3> <pre data-language=\"go\">func (b *Buffer) Truncate(n int)</pre> <p> Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer. </p> <h3 id=\"Buffer.UnreadByte\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=11003:11038#L342\">UnreadByte</a>  </h3> <pre data-language=\"go\">func (b *Buffer) UnreadByte() error</pre> <p> UnreadByte unreads the last byte returned by the most recent read operation. If write has happened since the last read, UnreadByte returns an error. </p> <h3 id=\"Buffer.UnreadRune\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=10571:10606#L327\">UnreadRune</a>  </h3> <pre data-language=\"go\">func (b *Buffer) UnreadRune() error</pre> <p> UnreadRune unreads the last rune returned by ReadRune. If the most recent read or write operation on the buffer was not a ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.) </p> <h3 id=\"Buffer.Write\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=4558:4609#L122\">Write</a>  </h3> <pre data-language=\"go\">func (b *Buffer) Write(p []byte) (n int, err error)</pre> <p> Write appends the contents of p to the buffer, growing the buffer as needed. The return value n is the length of p; err is always nil. If the buffer becomes too large, Write will panic with ErrTooLarge. </p> <h3 id=\"Buffer.WriteByte\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=7662:7702#L223\">WriteByte</a>  </h3> <pre data-language=\"go\">func (b *Buffer) WriteByte(c byte) error</pre> <p> WriteByte appends the byte c to the buffer, growing the buffer as needed. The returned error is always nil, but is included to match bufio.Writer's WriteByte. If the buffer becomes too large, WriteByte will panic with ErrTooLarge. </p> <h3 id=\"Buffer.WriteRune\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=8063:8116#L234\">WriteRune</a>  </h3> <pre data-language=\"go\">func (b *Buffer) WriteRune(r rune) (n int, err error)</pre> <p> WriteRune appends the UTF-8 encoding of Unicode code point r to the buffer, returning its length and an error, which is always nil but is included to match bufio.Writer's WriteRune. The buffer is grown as needed; if it becomes too large, WriteRune will panic with ErrTooLarge. </p> <h3 id=\"Buffer.WriteString\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=4916:4973#L131\">WriteString</a>  </h3> <pre data-language=\"go\">func (b *Buffer) WriteString(s string) (n int, err error)</pre> <p> WriteString appends the contents of s to the buffer, growing the buffer as needed. The return value n is the length of s; err is always nil. If the buffer becomes too large, WriteString will panic with ErrTooLarge. </p> <h3 id=\"Buffer.WriteTo\">func (*Buffer) <a href=\"https://golang.org/src/bytes/buffer.go?s=6914:6972#L195\">WriteTo</a>  </h3> <pre data-language=\"go\">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</pre> <p> WriteTo writes data to w until the buffer is drained or an error occurs. The return value n is the number of bytes written; it always fits into an int, but it is int64 to match the io.WriterTo interface. Any error encountered during the write is also returned. </p> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Reader implements the io.Reader, io.ReaderAt, io.WriterTo, io.Seeker, io.ByteScanner, and io.RuneScanner interfaces by reading from a byte slice. Unlike a Buffer, a Reader is read-only and supports seeking. </p> <h3 id=\"NewReader\">func <a href=\"https://golang.org/src/bytes/reader.go?s=3360:3392#L140\">NewReader</a>  </h3> <pre data-language=\"go\">func NewReader(b []byte) *Reader</pre> <p> NewReader returns a new Reader reading from b. </p> <h3 id=\"Reader.Len\">func (*Reader) <a href=\"https://golang.org/src/bytes/reader.go?s=646:672#L15\">Len</a>  </h3> <pre data-language=\"go\">func (r *Reader) Len() int</pre> <p> Len returns the number of bytes of the unread portion of the slice. </p> <h3 id=\"Reader.Read\">func (*Reader) <a href=\"https://golang.org/src/bytes/reader.go?s=1039:1089#L28\">Read</a>  </h3> <pre data-language=\"go\">func (r *Reader) Read(b []byte) (n int, err error)</pre> <h3 id=\"Reader.ReadAt\">func (*Reader) <a href=\"https://golang.org/src/bytes/reader.go?s=1212:1275#L38\">ReadAt</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</pre> <h3 id=\"Reader.ReadByte\">func (*Reader) <a href=\"https://golang.org/src/bytes/reader.go?s=1521:1562#L53\">ReadByte</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadByte() (byte, error)</pre> <h3 id=\"Reader.ReadRune\">func (*Reader) <a href=\"https://golang.org/src/bytes/reader.go?s=1838:1896#L72\">ReadRune</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadRune() (ch rune, size int, err error)</pre> <h3 id=\"Reader.Reset\">func (*Reader) <a href=\"https://golang.org/src/bytes/reader.go?s=3250:3282#L137\">Reset</a>  </h3> <pre data-language=\"go\">func (r *Reader) Reset(b []byte)</pre> <p> Reset resets the Reader to be reading from b. </p> <h3 id=\"Reader.Seek\">func (*Reader) <a href=\"https://golang.org/src/bytes/reader.go?s=2386:2448#L97\">Seek</a>  </h3> <pre data-language=\"go\">func (r *Reader) Seek(offset int64, whence int) (int64, error)</pre> <p> Seek implements the io.Seeker interface. </p> <h3 id=\"Reader.Size\">func (*Reader) <a href=\"https://golang.org/src/bytes/reader.go?s=981:1010#L26\">Size</a>  </h3> <pre data-language=\"go\">func (r *Reader) Size() int64</pre> <p> Size returns the original length of the underlying byte slice. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method. </p> <h3 id=\"Reader.UnreadByte\">func (*Reader) <a href=\"https://golang.org/src/bytes/reader.go?s=1673:1708#L63\">UnreadByte</a>  </h3> <pre data-language=\"go\">func (r *Reader) UnreadByte() error</pre> <h3 id=\"Reader.UnreadRune\">func (*Reader) <a href=\"https://golang.org/src/bytes/reader.go?s=2139:2174#L87\">UnreadRune</a>  </h3> <pre data-language=\"go\">func (r *Reader) UnreadRune() error</pre> <h3 id=\"Reader.WriteTo\">func (*Reader) <a href=\"https://golang.org/src/bytes/reader.go?s=2862:2920#L118\">WriteTo</a>  </h3> <pre data-language=\"go\">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</pre> <p> WriteTo implements the io.WriterTo interface. </p> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/bytes/bytes.go?s=12411:12509#L456\" style=\"float: left;\">☞</a> <p> The rule Title uses for word boundaries does not handle Unicode punctuation properly. </p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/bytes/\" class=\"_attribution-link\">https://golang.org/pkg/bytes/</a>\n  </p>\n</div>\n","debug/gosym/index":"<h1>Package gosym</h1>     <ul id=\"short-nav\">\n<li><code>import \"debug/gosym\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package gosym implements access to the Go symbol and line number tables embedded in Go binaries generated by the gc compilers. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#DecodingError\">type DecodingError</a></li>\n<li> <a href=\"#DecodingError.Error\">func (e *DecodingError) Error() string</a>\n</li>\n<li><a href=\"#Func\">type Func</a></li>\n<li><a href=\"#LineTable\">type LineTable</a></li>\n<li> <a href=\"#NewLineTable\">func NewLineTable(data []byte, text uint64) *LineTable</a>\n</li>\n<li> <a href=\"#LineTable.LineToPC\">func (t *LineTable) LineToPC(line int, maxpc uint64) uint64</a>\n</li>\n<li> <a href=\"#LineTable.PCToLine\">func (t *LineTable) PCToLine(pc uint64) int</a>\n</li>\n<li><a href=\"#Obj\">type Obj</a></li>\n<li><a href=\"#Sym\">type Sym</a></li>\n<li> <a href=\"#Sym.BaseName\">func (s *Sym) BaseName() string</a>\n</li>\n<li> <a href=\"#Sym.PackageName\">func (s *Sym) PackageName() string</a>\n</li>\n<li> <a href=\"#Sym.ReceiverName\">func (s *Sym) ReceiverName() string</a>\n</li>\n<li> <a href=\"#Sym.Static\">func (s *Sym) Static() bool</a>\n</li>\n<li><a href=\"#Table\">type Table</a></li>\n<li> <a href=\"#NewTable\">func NewTable(symtab []byte, pcln *LineTable) (*Table, error)</a>\n</li>\n<li> <a href=\"#Table.LineToPC\">func (t *Table) LineToPC(file string, line int) (pc uint64, fn *Func, err error)</a>\n</li>\n<li> <a href=\"#Table.LookupFunc\">func (t *Table) LookupFunc(name string) *Func</a>\n</li>\n<li> <a href=\"#Table.LookupSym\">func (t *Table) LookupSym(name string) *Sym</a>\n</li>\n<li> <a href=\"#Table.PCToFunc\">func (t *Table) PCToFunc(pc uint64) *Func</a>\n</li>\n<li> <a href=\"#Table.PCToLine\">func (t *Table) PCToLine(pc uint64) (file string, line int, fn *Func)</a>\n</li>\n<li> <a href=\"#Table.SymByAddr\">func (t *Table) SymByAddr(addr uint64) *Sym</a>\n</li>\n<li><a href=\"#UnknownFileError\">type UnknownFileError</a></li>\n<li> <a href=\"#UnknownFileError.Error\">func (e UnknownFileError) Error() string</a>\n</li>\n<li><a href=\"#UnknownLineError\">type UnknownLineError</a></li>\n<li> <a href=\"#UnknownLineError.Error\">func (e *UnknownLineError) Error() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/debug/gosym/pclntab.go\">pclntab.go</a> <a href=\"https://golang.org/src/debug/gosym/symtab.go\">symtab.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"DecodingError\">type DecodingError  </h2> <pre data-language=\"go\">type DecodingError struct {\n        // contains filtered or unexported fields\n}</pre> <p> DecodingError represents an error during the decoding of the symbol table. </p> <h3 id=\"DecodingError.Error\">func (*DecodingError) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=15899:15937#L702\">Error</a>  </h3> <pre data-language=\"go\">func (e *DecodingError) Error() string</pre> <h2 id=\"Func\">type Func  </h2> <pre data-language=\"go\">type Func struct {\n        Entry uint64\n        *Sym\n        End       uint64\n        Params    []*Sym\n        Locals    []*Sym\n        FrameSize int\n        LineTable *LineTable\n        Obj       *Obj\n}</pre> <p> A Func collects information about a single function. </p> <h2 id=\"LineTable\">type LineTable  </h2> <pre data-language=\"go\">type LineTable struct {\n        Data []byte\n        PC   uint64\n        Line int\n        // contains filtered or unexported fields\n}</pre> <p> A LineTable is a data structure mapping program counters to line numbers. </p> <p> In Go 1.1 and earlier, each function (represented by a Func) had its own LineTable, and the line number corresponded to a numbering of all source lines in the program, across all files. That absolute line number would then have to be converted separately to a file name and line number within the file. </p> <p> In Go 1.2, the format of the data changed so that there is a single LineTable for the entire program, shared by all Funcs, and there are no absolute line numbers, just line numbers within specific files. </p> <p> For the most part, LineTable's methods should be treated as an internal detail of the package; callers should use the methods on Table instead. </p> <h3 id=\"NewLineTable\">func <a href=\"https://golang.org/src/debug/gosym/pclntab.go?s=3484:3538#L112\">NewLineTable</a>  </h3> <pre data-language=\"go\">func NewLineTable(data []byte, text uint64) *LineTable</pre> <p> NewLineTable returns a new PC/line table corresponding to the encoded data. Text must be the start address of the corresponding text segment. </p> <h3 id=\"LineTable.LineToPC\">func (*LineTable) <a href=\"https://golang.org/src/debug/gosym/pclntab.go?s=3074:3133#L96\">LineToPC</a>  </h3> <pre data-language=\"go\">func (t *LineTable) LineToPC(line int, maxpc uint64) uint64</pre> <p> LineToPC returns the program counter for the given line number, considering only program counters before maxpc. Callers should use Table's LineToPC method instead. </p> <h3 id=\"LineTable.PCToLine\">func (*LineTable) <a href=\"https://golang.org/src/debug/gosym/pclntab.go?s=2760:2803#L85\">PCToLine</a>  </h3> <pre data-language=\"go\">func (t *LineTable) PCToLine(pc uint64) int</pre> <p> PCToLine returns the line number for the given program counter. Callers should use Table's PCToLine method instead. </p> <h2 id=\"Obj\">type Obj  </h2> <pre data-language=\"go\">type Obj struct {\n        // Funcs is a list of functions in the Obj.\n        Funcs []Func\n\n        // In Go 1.1 and earlier, Paths is a list of symbols corresponding\n        // to the source file names that produced the Obj.\n        // In Go 1.2, Paths is nil.\n        // Use the keys of Table.Files to obtain a list of source files.\n        Paths []Sym // meta\n}</pre> <p> An Obj represents a collection of functions in a symbol table. </p> <p> The exact method of division of a binary into separate Objs is an internal detail of the symbol table format. </p> <p> In early versions of Go each source file became a different Obj. </p> <p> In Go 1 and Go 1.1, each package produced one Obj for all Go sources and one Obj per C source file. </p> <p> In Go 1.2, there is a single Obj for the entire program. </p> <h2 id=\"Sym\">type Sym  </h2> <pre data-language=\"go\">type Sym struct {\n        Value  uint64\n        Type   byte\n        Name   string\n        GoType uint64\n        // If this symbol is a function symbol, the corresponding Func\n        Func *Func\n}</pre> <p> A Sym represents a single symbol table entry. </p> <h3 id=\"Sym.BaseName\">func (*Sym) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=1816:1847#L60\">BaseName</a>  </h3> <pre data-language=\"go\">func (s *Sym) BaseName() string</pre> <p> BaseName returns the symbol name without the package or receiver name. </p> <h3 id=\"Sym.PackageName\">func (*Sym) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=1121:1155#L32\">PackageName</a>  </h3> <pre data-language=\"go\">func (s *Sym) PackageName() string</pre> <p> PackageName returns the package part of the symbol name, or the empty string if there is none. </p> <h3 id=\"Sym.ReceiverName\">func (*Sym) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=1443:1478#L46\">ReceiverName</a>  </h3> <pre data-language=\"go\">func (s *Sym) ReceiverName() string</pre> <p> ReceiverName returns the receiver type name of this symbol, or the empty string if there is none. </p> <h3 id=\"Sym.Static\">func (*Sym) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=966:993#L28\">Static</a>  </h3> <pre data-language=\"go\">func (s *Sym) Static() bool</pre> <p> Static reports whether this symbol is static (not visible outside its file). </p> <h2 id=\"Table\">type Table  </h2> <pre data-language=\"go\">type Table struct {\n        Syms  []Sym\n        Funcs []Func\n        Files map[string]*Obj // nil for Go 1.2 and later binaries\n        Objs  []Obj           // nil for Go 1.2 and later binaries\n        // contains filtered or unexported fields\n}</pre> <p> Table represents a Go symbol table. It stores all of the symbols decoded from the program and provides methods to translate between symbols, names, and addresses. </p> <h3 id=\"NewTable\">func <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=6712:6773#L272\">NewTable</a>  </h3> <pre data-language=\"go\">func NewTable(symtab []byte, pcln *LineTable) (*Table, error)</pre> <p> NewTable decodes the Go symbol table in data, returning an in-memory representation. </p> <h3 id=\"Table.LineToPC\">func (*Table) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=11855:11935#L507\">LineToPC</a>  </h3> <pre data-language=\"go\">func (t *Table) LineToPC(file string, line int) (pc uint64, fn *Func, err error)</pre> <p> LineToPC looks up the first program counter on the given line in the named file. It returns UnknownPathError or UnknownLineError if there is an error looking up this line. </p> <h3 id=\"Table.LookupFunc\">func (*Table) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=12916:12961#L553\">LookupFunc</a>  </h3> <pre data-language=\"go\">func (t *Table) LookupFunc(name string) *Func</pre> <p> LookupFunc returns the text, data, or bss symbol with the given name, or nil if no such symbol is found. </p> <h3 id=\"Table.LookupSym\">func (*Table) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=12554:12597#L537\">LookupSym</a>  </h3> <pre data-language=\"go\">func (t *Table) LookupSym(name string) *Sym</pre> <p> LookupSym returns the text, data, or bss symbol with the given name, or nil if no such symbol is found. </p> <h3 id=\"Table.PCToFunc\">func (*Table) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=10961:11002#L472\">PCToFunc</a>  </h3> <pre data-language=\"go\">func (t *Table) PCToFunc(pc uint64) *Func</pre> <p> PCToFunc returns the function containing the program counter pc, or nil if there is no such function. </p> <h3 id=\"Table.PCToLine\">func (*Table) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=11368:11437#L491\">PCToLine</a>  </h3> <pre data-language=\"go\">func (t *Table) PCToLine(pc uint64) (file string, line int, fn *Func)</pre> <p> PCToLine looks up line number information for a program counter. If there is no information, it returns fn == nil. </p> <h3 id=\"Table.SymByAddr\">func (*Table) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=13151:13194#L564\">SymByAddr</a>  </h3> <pre data-language=\"go\">func (t *Table) SymByAddr(addr uint64) *Sym</pre> <p> SymByAddr returns the text, data, or bss symbol starting at the given address. </p> <h2 id=\"UnknownFileError\">type UnknownFileError  </h2> <pre data-language=\"go\">type UnknownFileError string</pre> <p> UnknownFileError represents a failure to find the specific file in the symbol table. </p> <h3 id=\"UnknownFileError.Error\">func (UnknownFileError) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=15316:15356#L680\">Error</a>  </h3> <pre data-language=\"go\">func (e UnknownFileError) Error() string</pre> <h2 id=\"UnknownLineError\">type UnknownLineError  </h2> <pre data-language=\"go\">type UnknownLineError struct {\n        File string\n        Line int\n}</pre> <p> UnknownLineError represents a failure to map a line to a program counter, either because the line is beyond the bounds of the file or because there is no code on the given line. </p> <h3 id=\"UnknownLineError.Error\">func (*UnknownLineError) <a href=\"https://golang.org/src/debug/gosym/symtab.go?s=15642:15683#L690\">Error</a>  </h3> <pre data-language=\"go\">func (e *UnknownLineError) Error() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/debug/gosym/\" class=\"_attribution-link\">https://golang.org/pkg/debug/gosym/</a>\n  </p>\n</div>\n","debug/pe/index":"<h1>Package pe</h1>     <ul id=\"short-nav\">\n<li><code>import \"debug/pe\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package pe implements access to PE (Microsoft Windows Portable Executable) files. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#COFFSymbol\">type COFFSymbol</a></li>\n<li><a href=\"#DataDirectory\">type DataDirectory</a></li>\n<li><a href=\"#File\">type File</a></li>\n<li> <a href=\"#NewFile\">func NewFile(r io.ReaderAt) (*File, error)</a>\n</li>\n<li> <a href=\"#Open\">func Open(name string) (*File, error)</a>\n</li>\n<li> <a href=\"#File.Close\">func (f *File) Close() error</a>\n</li>\n<li> <a href=\"#File.DWARF\">func (f *File) DWARF() (*dwarf.Data, error)</a>\n</li>\n<li> <a href=\"#File.ImportedLibraries\">func (f *File) ImportedLibraries() ([]string, error)</a>\n</li>\n<li> <a href=\"#File.ImportedSymbols\">func (f *File) ImportedSymbols() ([]string, error)</a>\n</li>\n<li> <a href=\"#File.Section\">func (f *File) Section(name string) *Section</a>\n</li>\n<li><a href=\"#FileHeader\">type FileHeader</a></li>\n<li><a href=\"#FormatError\">type FormatError</a></li>\n<li> <a href=\"#FormatError.Error\">func (e *FormatError) Error() string</a>\n</li>\n<li><a href=\"#ImportDirectory\">type ImportDirectory</a></li>\n<li><a href=\"#OptionalHeader32\">type OptionalHeader32</a></li>\n<li><a href=\"#OptionalHeader64\">type OptionalHeader64</a></li>\n<li><a href=\"#Section\">type Section</a></li>\n<li> <a href=\"#Section.Data\">func (s *Section) Data() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Section.Open\">func (s *Section) Open() io.ReadSeeker</a>\n</li>\n<li><a href=\"#SectionHeader\">type SectionHeader</a></li>\n<li><a href=\"#SectionHeader32\">type SectionHeader32</a></li>\n<li><a href=\"#Symbol\">type Symbol</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/debug/pe/file.go\">file.go</a> <a href=\"https://golang.org/src/debug/pe/pe.go\">pe.go</a> <a href=\"https://golang.org/src/debug/pe/section.go\">section.go</a> <a href=\"https://golang.org/src/debug/pe/string.go\">string.go</a> <a href=\"https://golang.org/src/debug/pe/symbol.go\">symbol.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        IMAGE_FILE_MACHINE_UNKNOWN   = 0x0\n        IMAGE_FILE_MACHINE_AM33      = 0x1d3\n        IMAGE_FILE_MACHINE_AMD64     = 0x8664\n        IMAGE_FILE_MACHINE_ARM       = 0x1c0\n        IMAGE_FILE_MACHINE_EBC       = 0xebc\n        IMAGE_FILE_MACHINE_I386      = 0x14c\n        IMAGE_FILE_MACHINE_IA64      = 0x200\n        IMAGE_FILE_MACHINE_M32R      = 0x9041\n        IMAGE_FILE_MACHINE_MIPS16    = 0x266\n        IMAGE_FILE_MACHINE_MIPSFPU   = 0x366\n        IMAGE_FILE_MACHINE_MIPSFPU16 = 0x466\n        IMAGE_FILE_MACHINE_POWERPC   = 0x1f0\n        IMAGE_FILE_MACHINE_POWERPCFP = 0x1f1\n        IMAGE_FILE_MACHINE_R4000     = 0x166\n        IMAGE_FILE_MACHINE_SH3       = 0x1a2\n        IMAGE_FILE_MACHINE_SH3DSP    = 0x1a3\n        IMAGE_FILE_MACHINE_SH4       = 0x1a6\n        IMAGE_FILE_MACHINE_SH5       = 0x1a8\n        IMAGE_FILE_MACHINE_THUMB     = 0x1c2\n        IMAGE_FILE_MACHINE_WCEMIPSV2 = 0x169\n)</pre> <pre data-language=\"go\">const COFFSymbolSize = 18</pre> <h2 id=\"COFFSymbol\">type COFFSymbol  </h2> <pre data-language=\"go\">type COFFSymbol struct {\n        Name               [8]uint8\n        Value              uint32\n        SectionNumber      int16\n        Type               uint16\n        StorageClass       uint8\n        NumberOfAuxSymbols uint8\n}</pre> <p> COFFSymbol represents single COFF symbol table record. </p> <h2 id=\"DataDirectory\">type DataDirectory  </h2> <pre data-language=\"go\">type DataDirectory struct {\n        VirtualAddress uint32\n        Size           uint32\n}</pre> <h2 id=\"File\">type File  </h2> <pre data-language=\"go\">type File struct {\n        FileHeader\n        OptionalHeader interface{} // of type *OptionalHeader32 or *OptionalHeader64\n        Sections       []*Section\n        Symbols        []*Symbol // COFF symbols with auxiliary symbol records removed\n        // contains filtered or unexported fields\n}</pre> <p> A File represents an open PE file. </p> <h3 id=\"NewFile\">func <a href=\"https://golang.org/src/debug/pe/file.go?s=1599:1641#L53\">NewFile</a>  </h3> <pre data-language=\"go\">func NewFile(r io.ReaderAt) (*File, error)</pre> <p> NewFile creates a new File for accessing a PE binary in an underlying reader. </p> <h3 id=\"Open\">func <a href=\"https://golang.org/src/debug/pe/file.go?s=799:836#L19\">Open</a>  </h3> <pre data-language=\"go\">func Open(name string) (*File, error)</pre> <p> Open opens the named file using os.Open and prepares it for use as a PE binary. </p> <h3 id=\"File.Close\">func (*File) <a href=\"https://golang.org/src/debug/pe/file.go?s=1126:1154#L36\">Close</a>  </h3> <pre data-language=\"go\">func (f *File) Close() error</pre> <p> Close closes the File. If the File was created using NewFile directly instead of Open, Close has no effect. </p> <h3 id=\"File.DWARF\">func (*File) <a href=\"https://golang.org/src/debug/pe/file.go?s=5777:5820#L206\">DWARF</a>  </h3> <pre data-language=\"go\">func (f *File) DWARF() (*dwarf.Data, error)</pre> <h3 id=\"File.ImportedLibraries\">func (*File) <a href=\"https://golang.org/src/debug/pe/file.go?s=9064:9116#L320\">ImportedLibraries</a>  </h3> <pre data-language=\"go\">func (f *File) ImportedLibraries() ([]string, error)</pre> <p> ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time. </p> <h3 id=\"File.ImportedSymbols\">func (*File) <a href=\"https://golang.org/src/debug/pe/file.go?s=6949:6999#L248\">ImportedSymbols</a>  </h3> <pre data-language=\"go\">func (f *File) ImportedSymbols() ([]string, error)</pre> <p> ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols. </p> <h3 id=\"File.Section\">func (*File) <a href=\"https://golang.org/src/debug/pe/file.go?s=5642:5686#L197\">Section</a>  </h3> <pre data-language=\"go\">func (f *File) Section(name string) *Section</pre> <p> Section returns the first section with the given name, or nil if no such section exists. </p> <h2 id=\"FileHeader\">type FileHeader  </h2> <pre data-language=\"go\">type FileHeader struct {\n        Machine              uint16\n        NumberOfSections     uint16\n        TimeDateStamp        uint32\n        PointerToSymbolTable uint32\n        NumberOfSymbols      uint32\n        SizeOfOptionalHeader uint16\n        Characteristics      uint16\n}</pre> <h2 id=\"FormatError\">type FormatError  </h2> <pre data-language=\"go\">type FormatError struct {\n}</pre> <p> FormatError is unused. The type is retained for compatibility. </p> <h3 id=\"FormatError.Error\">func (*FormatError) <a href=\"https://golang.org/src/debug/pe/file.go?s=9312:9348#L331\">Error</a>  </h3> <pre data-language=\"go\">func (e *FormatError) Error() string</pre> <h2 id=\"ImportDirectory\">type ImportDirectory  </h2> <pre data-language=\"go\">type ImportDirectory struct {\n        OriginalFirstThunk uint32\n        TimeDateStamp      uint32\n        ForwarderChain     uint32\n        Name               uint32\n        FirstThunk         uint32\n        // contains filtered or unexported fields\n}</pre> <h2 id=\"OptionalHeader32\">type OptionalHeader32  </h2> <pre data-language=\"go\">type OptionalHeader32 struct {\n        Magic                       uint16\n        MajorLinkerVersion          uint8\n        MinorLinkerVersion          uint8\n        SizeOfCode                  uint32\n        SizeOfInitializedData       uint32\n        SizeOfUninitializedData     uint32\n        AddressOfEntryPoint         uint32\n        BaseOfCode                  uint32\n        BaseOfData                  uint32\n        ImageBase                   uint32\n        SectionAlignment            uint32\n        FileAlignment               uint32\n        MajorOperatingSystemVersion uint16\n        MinorOperatingSystemVersion uint16\n        MajorImageVersion           uint16\n        MinorImageVersion           uint16\n        MajorSubsystemVersion       uint16\n        MinorSubsystemVersion       uint16\n        Win32VersionValue           uint32\n        SizeOfImage                 uint32\n        SizeOfHeaders               uint32\n        CheckSum                    uint32\n        Subsystem                   uint16\n        DllCharacteristics          uint16\n        SizeOfStackReserve          uint32\n        SizeOfStackCommit           uint32\n        SizeOfHeapReserve           uint32\n        SizeOfHeapCommit            uint32\n        LoaderFlags                 uint32\n        NumberOfRvaAndSizes         uint32\n        DataDirectory               [16]DataDirectory\n}</pre> <h2 id=\"OptionalHeader64\">type OptionalHeader64  </h2> <pre data-language=\"go\">type OptionalHeader64 struct {\n        Magic                       uint16\n        MajorLinkerVersion          uint8\n        MinorLinkerVersion          uint8\n        SizeOfCode                  uint32\n        SizeOfInitializedData       uint32\n        SizeOfUninitializedData     uint32\n        AddressOfEntryPoint         uint32\n        BaseOfCode                  uint32\n        ImageBase                   uint64\n        SectionAlignment            uint32\n        FileAlignment               uint32\n        MajorOperatingSystemVersion uint16\n        MinorOperatingSystemVersion uint16\n        MajorImageVersion           uint16\n        MinorImageVersion           uint16\n        MajorSubsystemVersion       uint16\n        MinorSubsystemVersion       uint16\n        Win32VersionValue           uint32\n        SizeOfImage                 uint32\n        SizeOfHeaders               uint32\n        CheckSum                    uint32\n        Subsystem                   uint16\n        DllCharacteristics          uint16\n        SizeOfStackReserve          uint64\n        SizeOfStackCommit           uint64\n        SizeOfHeapReserve           uint64\n        SizeOfHeapCommit            uint64\n        LoaderFlags                 uint32\n        NumberOfRvaAndSizes         uint32\n        DataDirectory               [16]DataDirectory\n}</pre> <h2 id=\"Section\">type Section  </h2> <pre data-language=\"go\">type Section struct {\n        SectionHeader\n\n        // Embed ReaderAt for ReadAt method.\n        // Do not embed SectionReader directly\n        // to avoid having Read and Seek.\n        // If a client wants Read and Seek it must use\n        // Open() to avoid fighting over the seek offset\n        // with other clients.\n        io.ReaderAt\n        // contains filtered or unexported fields\n}</pre> <p> Section provides access to PE COFF section. </p> <h3 id=\"Section.Data\">func (*Section) <a href=\"https://golang.org/src/debug/pe/section.go?s=2642:2682#L89\">Data</a>  </h3> <pre data-language=\"go\">func (s *Section) Data() ([]byte, error)</pre> <p> Data reads and returns the contents of the PE section s. </p> <h3 id=\"Section.Open\">func (*Section) <a href=\"https://golang.org/src/debug/pe/section.go?s=2869:2907#L99\">Open</a>  </h3> <pre data-language=\"go\">func (s *Section) Open() io.ReadSeeker</pre> <p> Open returns a new ReadSeeker reading the PE section s. </p> <h2 id=\"SectionHeader\">type SectionHeader  </h2> <pre data-language=\"go\">type SectionHeader struct {\n        Name                 string\n        VirtualSize          uint32\n        VirtualAddress       uint32\n        Size                 uint32\n        Offset               uint32\n        PointerToRelocations uint32\n        PointerToLineNumbers uint32\n        NumberOfRelocations  uint16\n        NumberOfLineNumbers  uint16\n        Characteristics      uint32\n}</pre> <p> SectionHeader is similar to SectionHeader32 with Name field replaced by Go string. </p> <h2 id=\"SectionHeader32\">type SectionHeader32  </h2> <pre data-language=\"go\">type SectionHeader32 struct {\n        Name                 [8]uint8\n        VirtualSize          uint32\n        VirtualAddress       uint32\n        SizeOfRawData        uint32\n        PointerToRawData     uint32\n        PointerToRelocations uint32\n        PointerToLineNumbers uint32\n        NumberOfRelocations  uint16\n        NumberOfLineNumbers  uint16\n        Characteristics      uint32\n}</pre> <p> SectionHeader32 represents real PE COFF section header. </p> <h2 id=\"Symbol\">type Symbol  </h2> <pre data-language=\"go\">type Symbol struct {\n        Name          string\n        Value         uint32\n        SectionNumber int16\n        Type          uint16\n        StorageClass  uint8\n}</pre> <p> Symbol is similar to COFFSymbol with Name field replaced by Go string. Symbol also does not have NumberOfAuxSymbols. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/debug/pe/\" class=\"_attribution-link\">https://golang.org/pkg/debug/pe/</a>\n  </p>\n</div>\n","encoding/base32/index":"<h1>Package base32</h1>     <ul id=\"short-nav\">\n<li><code>import \"encoding/base32\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package base32 implements base32 encoding as specified by RFC 4648. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#NewDecoder\">func NewDecoder(enc *Encoding, r io.Reader) io.Reader</a></li>\n<li><a href=\"#NewEncoder\">func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser</a></li>\n<li><a href=\"#CorruptInputError\">type CorruptInputError</a></li>\n<li> <a href=\"#CorruptInputError.Error\">func (e CorruptInputError) Error() string</a>\n</li>\n<li><a href=\"#Encoding\">type Encoding</a></li>\n<li> <a href=\"#NewEncoding\">func NewEncoding(encoder string) *Encoding</a>\n</li>\n<li> <a href=\"#Encoding.Decode\">func (enc *Encoding) Decode(dst, src []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#Encoding.DecodeString\">func (enc *Encoding) DecodeString(s string) ([]byte, error)</a>\n</li>\n<li> <a href=\"#Encoding.DecodedLen\">func (enc *Encoding) DecodedLen(n int) int</a>\n</li>\n<li> <a href=\"#Encoding.Encode\">func (enc *Encoding) Encode(dst, src []byte)</a>\n</li>\n<li> <a href=\"#Encoding.EncodeToString\">func (enc *Encoding) EncodeToString(src []byte) string</a>\n</li>\n<li> <a href=\"#Encoding.EncodedLen\">func (enc *Encoding) EncodedLen(n int) int</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Encoding_DecodeString\">Encoding.DecodeString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Encoding_EncodeToString\">Encoding.EncodeToString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_NewEncoder\">NewEncoder</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/encoding/base32/base32.go\">base32.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var HexEncoding = NewEncoding(encodeHex)</pre> <p> HexEncoding is the “Extended Hex Alphabet” defined in RFC 4648. It is typically used in DNS. </p> <pre data-language=\"go\">var StdEncoding = NewEncoding(encodeStd)</pre> <p> StdEncoding is the standard base32 encoding, as defined in RFC 4648. </p> <h2 id=\"NewDecoder\">func NewDecoder  </h2> <pre data-language=\"go\">func NewDecoder(enc *Encoding, r io.Reader) io.Reader</pre> <p> NewDecoder constructs a new base32 stream decoder. </p> <h2 id=\"NewEncoder\">func NewEncoder  </h2> <pre data-language=\"go\">func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser</pre> <p> NewEncoder returns a new base32 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base32 encodings operate in 5-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks. </p> <div id=\"example_NewEncoder\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/base32\"\n\t\"os\"\n)\n\nfunc main() {\n\tinput := []byte(\"foo\\x00bar\")\n\tencoder := base32.NewEncoder(base32.StdEncoding, os.Stdout)\n\tencoder.Write(input)\n\t// Must close the encoder when finished to flush any partial blocks.\n\t// If you comment out the following line, the last partial block \"r\"\n\t// won't be encoded.\n\tencoder.Close()\n}\n</pre> </div> </div> <h2 id=\"CorruptInputError\">type CorruptInputError  </h2> <pre data-language=\"go\">type CorruptInputError int64</pre> <h3 id=\"CorruptInputError.Error\">func (CorruptInputError) <a href=\"https://golang.org/src/encoding/base32/base32.go?s=5117:5158#L220\">Error</a>  </h3> <pre data-language=\"go\">func (e CorruptInputError) Error() string</pre> <h2 id=\"Encoding\">type Encoding  </h2> <pre data-language=\"go\">type Encoding struct {\n        // contains filtered or unexported fields\n}</pre> <p> An Encoding is a radix 32 encoding/decoding scheme, defined by a 32-character alphabet. The most common is the \"base32\" encoding introduced for SASL GSSAPI and standardized in RFC 4648. The alternate \"base32hex\" encoding is used in DNSSEC. </p> <h3 id=\"NewEncoding\">func <a href=\"https://golang.org/src/encoding/base32/base32.go?s=845:887#L23\">NewEncoding</a>  </h3> <pre data-language=\"go\">func NewEncoding(encoder string) *Encoding</pre> <p> NewEncoding returns a new Encoding defined by the given alphabet, which must be a 32-byte string. </p> <h3 id=\"Encoding.Decode\">func (*Encoding) <a href=\"https://golang.org/src/encoding/base32/base32.go?s=7755:7818#L311\">Decode</a>  </h3> <pre data-language=\"go\">func (enc *Encoding) Decode(dst, src []byte) (n int, err error)</pre> <p> Decode decodes src using the encoding enc. It writes at most DecodedLen(len(src)) bytes to dst and returns the number of bytes written. If src contains invalid base32 data, it will return the number of bytes successfully written and CorruptInputError. New line characters (\\r and \\n) are ignored. </p> <h3 id=\"Encoding.DecodeString\">func (*Encoding) <a href=\"https://golang.org/src/encoding/base32/base32.go?s=7980:8039#L318\">DecodeString</a>  </h3> <pre data-language=\"go\">func (enc *Encoding) DecodeString(s string) ([]byte, error)</pre> <p> DecodeString returns the bytes represented by the base32 string s. </p> <div id=\"example_Encoding_DecodeString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/base32\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tstr := \"ONXW2ZJAMRQXIYJAO5UXI2BAAAQGC3TEEDX3XPY=\"\n\tdata, err := base32.StdEncoding.DecodeString(str)\n\tif err != nil {\n\t\tfmt.Println(\"error:\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%q\\n\", data)\n}\n</pre> </div> </div> <h3 id=\"Encoding.DecodedLen\">func (*Encoding) <a href=\"https://golang.org/src/encoding/base32/base32.go?s=10069:10111#L416\">DecodedLen</a>  </h3> <pre data-language=\"go\">func (enc *Encoding) DecodedLen(n int) int</pre> <p> DecodedLen returns the maximum length in bytes of the decoded data corresponding to n bytes of base32-encoded data. </p> <h3 id=\"Encoding.Encode\">func (*Encoding) <a href=\"https://golang.org/src/encoding/base32/base32.go?s=1737:1781#L60\">Encode</a>  </h3> <pre data-language=\"go\">func (enc *Encoding) Encode(dst, src []byte)</pre> <p> Encode encodes src using the encoding enc, writing EncodedLen(len(src)) bytes to dst. </p> <p> The encoding pads the output to a multiple of 8 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead. </p> <h3 id=\"Encoding.EncodeToString\">func (*Encoding) <a href=\"https://golang.org/src/encoding/base32/base32.go?s=3010:3064#L126\">EncodeToString</a>  </h3> <pre data-language=\"go\">func (enc *Encoding) EncodeToString(src []byte) string</pre> <p> EncodeToString returns the base32 encoding of src. </p> <div id=\"example_Encoding_EncodeToString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/base32\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tdata := []byte(\"any + old &amp; data\")\n\tstr := base32.StdEncoding.EncodeToString(data)\n\tfmt.Println(str)\n}\n</pre> </div> </div> <h3 id=\"Encoding.EncodedLen\">func (*Encoding) <a href=\"https://golang.org/src/encoding/base32/base32.go?s=4997:5039#L212\">EncodedLen</a>  </h3> <pre data-language=\"go\">func (enc *Encoding) EncodedLen(n int) int</pre> <p> EncodedLen returns the length in bytes of the base32 encoding of an input buffer of length n. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/encoding/base32/\" class=\"_attribution-link\">https://golang.org/pkg/encoding/base32/</a>\n  </p>\n</div>\n","encoding/binary/index":"<h1>Package binary</h1>     <ul id=\"short-nav\">\n<li><code>import \"encoding/binary\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints. </p> <p> Numbers are translated by reading and writing fixed-size values. A fixed-size value is either a fixed-size arithmetic type (int8, uint8, int16, float32, complex64, ...) or an array or struct containing only fixed-size values. </p> <p> The varint functions encode and decode single integer values using a variable-length encoding; smaller values require fewer bytes. For a specification, see <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">https://developers.google.com/protocol-buffers/docs/encoding</a>. </p> <p> This package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the encoding/gob package or protocol buffers. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#PutUvarint\">func PutUvarint(buf []byte, x uint64) int</a></li>\n<li><a href=\"#PutVarint\">func PutVarint(buf []byte, x int64) int</a></li>\n<li><a href=\"#Read\">func Read(r io.Reader, order ByteOrder, data interface{}) error</a></li>\n<li><a href=\"#ReadUvarint\">func ReadUvarint(r io.ByteReader) (uint64, error)</a></li>\n<li><a href=\"#ReadVarint\">func ReadVarint(r io.ByteReader) (int64, error)</a></li>\n<li><a href=\"#Size\">func Size(v interface{}) int</a></li>\n<li><a href=\"#Uvarint\">func Uvarint(buf []byte) (uint64, int)</a></li>\n<li><a href=\"#Varint\">func Varint(buf []byte) (int64, int)</a></li>\n<li><a href=\"#Write\">func Write(w io.Writer, order ByteOrder, data interface{}) error</a></li>\n<li><a href=\"#ByteOrder\">type ByteOrder</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Read\">Read</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Write\">Write</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Write_multi\">Write (Multi)</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/encoding/binary/binary.go\">binary.go</a> <a href=\"https://golang.org/src/encoding/binary/varint.go\">varint.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        MaxVarintLen16 = 3\n        MaxVarintLen32 = 5\n        MaxVarintLen64 = 10\n)</pre> <p> MaxVarintLenN is the maximum length of a varint-encoded N-bit integer. </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var BigEndian bigEndian</pre> <p> BigEndian is the big-endian implementation of ByteOrder. </p> <pre data-language=\"go\">var LittleEndian littleEndian</pre> <p> LittleEndian is the little-endian implementation of ByteOrder. </p> <h2 id=\"PutUvarint\">func PutUvarint  </h2> <pre data-language=\"go\">func PutUvarint(buf []byte, x uint64) int</pre> <p> PutUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic. </p> <h2 id=\"PutVarint\">func PutVarint  </h2> <pre data-language=\"go\">func PutVarint(buf []byte, x int64) int</pre> <p> PutVarint encodes an int64 into buf and returns the number of bytes written. If the buffer is too small, PutVarint will panic. </p> <h2 id=\"Read\">func Read  </h2> <pre data-language=\"go\">func Read(r io.Reader, order ByteOrder, data interface{}) error</pre> <p> Read reads structured binary data from r into data. Data must be a pointer to a fixed-size value or a slice of fixed-size values. Bytes read from r are decoded using the specified byte order and written to successive fields of the data. When reading into structs, the field data for fields with blank (_) field names is skipped; i.e., blank field names may be used for padding. When reading into a struct, all non-blank fields must be exported. </p> <p> The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, Read returns ErrUnexpectedEOF. </p> <div id=\"example_Read\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar pi float64\n\tb := []byte{0x18, 0x2d, 0x44, 0x54, 0xfb, 0x21, 0x09, 0x40}\n\tbuf := bytes.NewReader(b)\n\terr := binary.Read(buf, binary.LittleEndian, &amp;pi)\n\tif err != nil {\n\t\tfmt.Println(\"binary.Read failed:\", err)\n\t}\n\tfmt.Print(pi)\n}\n</pre> </div> </div> <h2 id=\"ReadUvarint\">func ReadUvarint  </h2> <pre data-language=\"go\">func ReadUvarint(r io.ByteReader) (uint64, error)</pre> <p> ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64. </p> <h2 id=\"ReadVarint\">func ReadVarint  </h2> <pre data-language=\"go\">func ReadVarint(r io.ByteReader) (int64, error)</pre> <p> ReadVarint reads an encoded signed integer from r and returns it as an int64. </p> <h2 id=\"Size\">func Size  </h2> <pre data-language=\"go\">func Size(v interface{}) int</pre> <p> Size returns how many bytes Write would generate to encode the value v, which must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. If v is neither of these, Size returns -1. </p> <h2 id=\"Uvarint\">func Uvarint  </h2> <pre data-language=\"go\">func Uvarint(buf []byte) (uint64, int)</pre> <p> Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (&gt; 0). If an error occurred, the value is 0 and the number of bytes n is &lt;= 0 meaning: </p> <pre data-language=\"go\">\tn == 0: buf too small\n\tn  &lt; 0: value larger than 64 bits (overflow)\n             and -n is the number of bytes read\n</pre> <h2 id=\"Varint\">func Varint  </h2> <pre data-language=\"go\">func Varint(buf []byte) (int64, int)</pre> <p> Varint decodes an int64 from buf and returns that value and the number of bytes read (&gt; 0). If an error occurred, the value is 0 and the number of bytes n is &lt;= 0 with the following meaning: </p> <pre data-language=\"go\">\tn == 0: buf too small\n\tn  &lt; 0: value larger than 64 bits (overflow)\n             and -n is the number of bytes read\n</pre> <h2 id=\"Write\">func Write  </h2> <pre data-language=\"go\">func Write(w io.Writer, order ByteOrder, data interface{}) error</pre> <p> Write writes the binary representation of data into w. Data must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. Bytes written to w are encoded using the specified byte order and read from successive fields of the data. When writing structs, zero values are written for fields with blank (_) field names. </p> <div id=\"example_Write\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tbuf := new(bytes.Buffer)\n\tvar pi float64 = math.Pi\n\terr := binary.Write(buf, binary.LittleEndian, pi)\n\tif err != nil {\n\t\tfmt.Println(\"binary.Write failed:\", err)\n\t}\n\tfmt.Printf(\"% x\", buf.Bytes())\n}\n</pre> </div> </div> <div id=\"example_Write_multi\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Multi)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tbuf := new(bytes.Buffer)\n\tvar data = []interface{}{\n\t\tuint16(61374),\n\t\tint8(-54),\n\t\tuint8(254),\n\t}\n\tfor _, v := range data {\n\t\terr := binary.Write(buf, binary.LittleEndian, v)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"binary.Write failed:\", err)\n\t\t}\n\t}\n\tfmt.Printf(\"%x\", buf.Bytes())\n}\n</pre> </div> </div> <h2 id=\"ByteOrder\">type ByteOrder  </h2> <pre data-language=\"go\">type ByteOrder interface {\n        Uint16([]byte) uint16\n        Uint32([]byte) uint32\n        Uint64([]byte) uint64\n        PutUint16([]byte, uint16)\n        PutUint32([]byte, uint32)\n        PutUint64([]byte, uint64)\n        String() string\n}</pre> <p> A ByteOrder specifies how to convert byte sequences into 16-, 32-, or 64-bit unsigned integers. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/encoding/binary/\" class=\"_attribution-link\">https://golang.org/pkg/encoding/binary/</a>\n  </p>\n</div>\n","crypto/rsa/index":"<h1>Package rsa</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/rsa\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package rsa implements RSA encryption as specified in PKCS#1. </p> <p> RSA is a single, fundamental operation that is used in this package to implement either public-key encryption or public-key signatures. </p> <p> The original specification for encryption and signatures with RSA is PKCS#1 and the terms \"RSA encryption\" and \"RSA signatures\" by default refer to PKCS#1 version 1.5. However, that specification has flaws and new designs should use version two, usually called by just OAEP and PSS, where possible. </p> <p> Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public-key primitive, the PrivateKey struct implements the Decrypter and Signer interfaces from the crypto package. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#DecryptOAEP\">func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)</a></li>\n<li><a href=\"#DecryptPKCS1v15\">func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) ([]byte, error)</a></li>\n<li><a href=\"#DecryptPKCS1v15SessionKey\">func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) error</a></li>\n<li><a href=\"#EncryptOAEP\">func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error)</a></li>\n<li><a href=\"#EncryptPKCS1v15\">func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) ([]byte, error)</a></li>\n<li><a href=\"#SignPKCS1v15\">func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) ([]byte, error)</a></li>\n<li><a href=\"#SignPSS\">func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions) ([]byte, error)</a></li>\n<li><a href=\"#VerifyPKCS1v15\">func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error</a></li>\n<li><a href=\"#VerifyPSS\">func VerifyPSS(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *PSSOptions) error</a></li>\n<li><a href=\"#CRTValue\">type CRTValue</a></li>\n<li><a href=\"#OAEPOptions\">type OAEPOptions</a></li>\n<li><a href=\"#PKCS1v15DecryptOptions\">type PKCS1v15DecryptOptions</a></li>\n<li><a href=\"#PSSOptions\">type PSSOptions</a></li>\n<li> <a href=\"#PSSOptions.HashFunc\">func (pssOpts *PSSOptions) HashFunc() crypto.Hash</a>\n</li>\n<li><a href=\"#PrecomputedValues\">type PrecomputedValues</a></li>\n<li><a href=\"#PrivateKey\">type PrivateKey</a></li>\n<li> <a href=\"#GenerateKey\">func GenerateKey(random io.Reader, bits int) (*PrivateKey, error)</a>\n</li>\n<li> <a href=\"#GenerateMultiPrimeKey\">func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey, error)</a>\n</li>\n<li> <a href=\"#PrivateKey.Decrypt\">func (priv *PrivateKey) Decrypt(rand io.Reader, ciphertext []byte, opts crypto.DecrypterOpts) (plaintext []byte, err error)</a>\n</li>\n<li> <a href=\"#PrivateKey.Precompute\">func (priv *PrivateKey) Precompute()</a>\n</li>\n<li> <a href=\"#PrivateKey.Public\">func (priv *PrivateKey) Public() crypto.PublicKey</a>\n</li>\n<li> <a href=\"#PrivateKey.Sign\">func (priv *PrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) ([]byte, error)</a>\n</li>\n<li> <a href=\"#PrivateKey.Validate\">func (priv *PrivateKey) Validate() error</a>\n</li>\n<li><a href=\"#PublicKey\">type PublicKey</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_DecryptOAEP\">DecryptOAEP</a></dd> <dd><a class=\"exampleLink\" href=\"#example_DecryptPKCS1v15SessionKey\">DecryptPKCS1v15SessionKey</a></dd> <dd><a class=\"exampleLink\" href=\"#example_EncryptOAEP\">EncryptOAEP</a></dd> <dd><a class=\"exampleLink\" href=\"#example_SignPKCS1v15\">SignPKCS1v15</a></dd> <dd><a class=\"exampleLink\" href=\"#example_VerifyPKCS1v15\">VerifyPKCS1v15</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/rsa/pkcs1v15.go\">pkcs1v15.go</a> <a href=\"https://golang.org/src/crypto/rsa/pss.go\">pss.go</a> <a href=\"https://golang.org/src/crypto/rsa/rsa.go\">rsa.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        // PSSSaltLengthAuto causes the salt in a PSS signature to be as large\n        // as possible when signing, and to be auto-detected when verifying.\n        PSSSaltLengthAuto = 0\n        // PSSSaltLengthEqualsHash causes the salt length to equal the length\n        // of the hash used in the signature.\n        PSSSaltLengthEqualsHash = -1\n)</pre> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrDecryption = errors.New(\"crypto/rsa: decryption error\")</pre> <p> ErrDecryption represents a failure to decrypt a message. It is deliberately vague to avoid adaptive attacks. </p> <pre data-language=\"go\">var ErrMessageTooLong = errors.New(\"crypto/rsa: message too long for RSA public key size\")</pre> <p> ErrMessageTooLong is returned when attempting to encrypt a message which is too large for the size of the public key. </p> <pre data-language=\"go\">var ErrVerification = errors.New(\"crypto/rsa: verification error\")</pre> <p> ErrVerification represents a failure to verify a signature. It is deliberately vague to avoid adaptive attacks. </p> <h2 id=\"DecryptOAEP\">func DecryptOAEP  </h2> <pre data-language=\"go\">func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)</pre> <p> OAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice. </p> <p> The random parameter, if not nil, is used to blind the private-key operation and avoid timing side-channel attacks. Blinding is purely internal to this function – the random data need not match that used when encrypting. </p> <p> The label parameter must match the value given when encrypting. See EncryptOAEP for details. </p> <div id=\"example_DecryptOAEP\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    ciphertext, _ := hex.DecodeString(\"4d1ee10e8f286390258c51a5e80802844c3e6358ad6690b7285218a7c7ed7fc3a4c7b950fbd04d4b0239cc060dcc7065ca6f84c1756deb71ca5685cadbb82be025e16449b905c568a19c088a1abfad54bf7ecc67a7df39943ec511091a34c0f2348d04e058fcff4d55644de3cd1d580791d4524b92f3e91695582e6e340a1c50b6c6d78e80b4e42c5b4d45e479b492de42bbd39cc642ebb80226bb5200020d501b24a37bcc2ec7f34e596b4fd6b063de4858dbf5a4e3dd18e262eda0ec2d19dbd8e890d672b63d368768360b20c0b6b8592a438fa275e5fa7f60bef0dd39673fd3989cc54d2cb80c08fcd19dacbc265ee1c6014616b0e04ea0328c2a04e73460\")\n    label := []byte(\"orders\")\n\n    // crypto/rand.Reader is a good source of entropy for blinding the RSA\n    // operation.\n    rng := rand.Reader\n\n    plaintext, err := DecryptOAEP(sha256.New(), rng, test2048Key, ciphertext, label)\n    if err != nil {\n            fmt.Fprintf(os.Stderr, \"Error from decryption: %s\\n\", err)\n            return\n    }\n\n    fmt.Printf(\"Plaintext: %s\\n\", string(plaintext))\n\n    // Remember that encryption only provides confidentiality. The\n    // ciphertext should be signed before authenticity is assumed and, even\n    // then, consider that messages might be reordered.\n</pre> </div> </div> <h2 id=\"DecryptPKCS1v15\">func DecryptPKCS1v15  </h2> <pre data-language=\"go\">func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) ([]byte, error)</pre> <p> DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5. If rand != nil, it uses RSA blinding to avoid timing side-channel attacks. </p> <p> Note that whether this function returns an error or not discloses secret information. If an attacker can cause this function to run repeatedly and learn whether each instance returned an error then they can decrypt and forge signatures as if they had the private key. See DecryptPKCS1v15SessionKey for a way of solving this problem. </p> <h2 id=\"DecryptPKCS1v15SessionKey\">func DecryptPKCS1v15SessionKey  </h2> <pre data-language=\"go\">func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) error</pre> <p> DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5. If rand != nil, it uses RSA blinding to avoid timing side-channel attacks. It returns an error if the ciphertext is the wrong length or if the ciphertext is greater than the public modulus. Otherwise, no error is returned. If the padding is valid, the resulting plaintext message is copied into key. Otherwise, key is unchanged. These alternatives occur in constant time. It is intended that the user of this function generate a random session key beforehand and continue the protocol with the resulting value. This will remove any possibility that an attacker can learn any information about the plaintext. See “Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS #1”, Daniel Bleichenbacher, Advances in Cryptology (Crypto '98). </p> <p> Note that if the session key is too small then it may be possible for an attacker to brute-force it. If they can do that then they can learn whether a random value was used (because it'll be different for the same ciphertext) and thus whether the padding was correct. This defeats the point of this function. Using at least a 16-byte key will protect against this attack. </p> <div id=\"example_DecryptPKCS1v15SessionKey\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>RSA is able to encrypt only a very limited amount of data. In order to encrypt reasonable amounts of data a hybrid scheme is commonly used: RSA is used to encrypt a key for a symmetric primitive like AES-GCM. Before encrypting, data is “padded” by embedding it in a known structure. This is done for a number of reasons, but the most obvious is to ensure that the value is large enough that the exponentiation is larger than the modulus. (Otherwise it could be decrypted with a square-root.) In these designs, when using PKCS#1 v1.5, it's vitally important to avoid disclosing whether the received RSA message was well-formed (that is, whether the result of decrypting is a correctly padded message) because this leaks secret information. DecryptPKCS1v15SessionKey is designed for this situation and copies the decrypted, symmetric key (if well-formed) in constant-time over a buffer that contains a random key. Thus, if the RSA result isn't well-formed, the implementation uses a random key in constant time. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    // crypto/rand.Reader is a good source of entropy for blinding the RSA\n    // operation.\n    rng := rand.Reader\n\n    // The hybrid scheme should use at least a 16-byte symmetric key. Here\n    // we read the random key that will be used if the RSA decryption isn't\n    // well-formed.\n    key := make([]byte, 32)\n    if _, err := io.ReadFull(rng, key); err != nil {\n            panic(\"RNG failure\")\n    }\n\n    rsaCiphertext, _ := hex.DecodeString(\"aabbccddeeff\")\n\n    if err := DecryptPKCS1v15SessionKey(rng, rsaPrivateKey, rsaCiphertext, key); err != nil {\n            // Any errors that result will be “public” – meaning that they\n            // can be determined without any secret information. (For\n            // instance, if the length of key is impossible given the RSA\n            // public key.)\n            fmt.Fprintf(os.Stderr, \"Error from RSA decryption: %s\\n\", err)\n            return\n    }\n\n    // Given the resulting key, a symmetric scheme can be used to decrypt a\n    // larger ciphertext.\n    block, err := aes.NewCipher(key)\n    if err != nil {\n            panic(\"aes.NewCipher failed: \" + err.Error())\n    }\n\n    // Since the key is random, using a fixed nonce is acceptable as the\n    // (key, nonce) pair will still be unique, as required.\n    var zeroNonce [12]byte\n    aead, err := cipher.NewGCM(block)\n    if err != nil {\n            panic(\"cipher.NewGCM failed: \" + err.Error())\n    }\n    ciphertext, _ := hex.DecodeString(\"00112233445566\")\n    plaintext, err := aead.Open(nil, zeroNonce[:], ciphertext, nil)\n    if err != nil {\n            // The RSA ciphertext was badly formed; the decryption will\n            // fail here because the AES-GCM key will be incorrect.\n            fmt.Fprintf(os.Stderr, \"Error decrypting: %s\\n\", err)\n            return\n    }\n\n    fmt.Printf(\"Plaintext: %s\\n\", string(plaintext))\n</pre> </div> </div> <h2 id=\"EncryptOAEP\">func EncryptOAEP  </h2> <pre data-language=\"go\">func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error)</pre> <p> EncryptOAEP encrypts the given message with RSA-OAEP. </p> <p> OAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice. </p> <p> The random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext. </p> <p> The label parameter may contain arbitrary data that will not be encrypted, but which gives important context to the message. For example, if a given public key is used to decrypt two types of messages then distinct label values could be used to ensure that a ciphertext for one purpose cannot be used for another by an attacker. If not required it can be empty. </p> <p> The message must be no longer than the length of the public modulus less twice the hash length plus 2. </p> <div id=\"example_EncryptOAEP\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    secretMessage := []byte(\"send reinforcements, we're going to advance\")\n    label := []byte(\"orders\")\n\n    // crypto/rand.Reader is a good source of entropy for randomizing the\n    // encryption function.\n    rng := rand.Reader\n\n    ciphertext, err := EncryptOAEP(sha256.New(), rng, &amp;test2048Key.PublicKey, secretMessage, label)\n    if err != nil {\n            fmt.Fprintf(os.Stderr, \"Error from encryption: %s\\n\", err)\n            return\n    }\n\n    // Since encryption is a randomized function, ciphertext will be\n    // different each time.\n    fmt.Printf(\"Ciphertext: %x\\n\", ciphertext)\n</pre> </div> </div> <h2 id=\"EncryptPKCS1v15\">func EncryptPKCS1v15  </h2> <pre data-language=\"go\">func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) ([]byte, error)</pre> <p> EncryptPKCS1v15 encrypts the given message with RSA and the padding scheme from PKCS#1 v1.5. The message must be no longer than the length of the public modulus minus 11 bytes. </p> <p> The rand parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext. </p> <p> WARNING: use of this function to encrypt plaintexts other than session keys is dangerous. Use RSA OAEP in new protocols. </p> <h2 id=\"SignPKCS1v15\">func SignPKCS1v15  </h2> <pre data-language=\"go\">func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) ([]byte, error)</pre> <p> SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5. Note that hashed must be the result of hashing the input message using the given hash function. If hash is zero, hashed is signed directly. This isn't advisable except for interoperability. </p> <p> If rand is not nil then RSA blinding will be used to avoid timing side-channel attacks. </p> <p> This function is deterministic. Thus, if the set of possible messages is small, an attacker may be able to build a map from messages to signatures and identify the signed messages. As ever, signatures provide authenticity, not confidentiality. </p> <div id=\"example_SignPKCS1v15\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    // crypto/rand.Reader is a good source of entropy for blinding the RSA\n    // operation.\n    rng := rand.Reader\n\n    message := []byte(\"message to be signed\")\n\n    // Only small messages can be signed directly; thus the hash of a\n    // message, rather than the message itself, is signed. This requires\n    // that the hash function be collision resistant. SHA-256 is the\n    // least-strong hash function that should be used for this at the time\n    // of writing (2016).\n    hashed := sha256.Sum256(message)\n\n    signature, err := SignPKCS1v15(rng, rsaPrivateKey, crypto.SHA256, hashed[:])\n    if err != nil {\n            fmt.Fprintf(os.Stderr, \"Error from signing: %s\\n\", err)\n            return\n    }\n\n    fmt.Printf(\"Signature: %x\\n\", signature)\n</pre> </div> </div> <h2 id=\"SignPSS\">func SignPSS  </h2> <pre data-language=\"go\">func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions) ([]byte, error)</pre> <p> SignPSS calculates the signature of hashed using RSASSA-PSS [1]. Note that hashed must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used. </p> <h2 id=\"VerifyPKCS1v15\">func VerifyPKCS1v15  </h2> <pre data-language=\"go\">func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error</pre> <p> VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability. </p> <div id=\"example_VerifyPKCS1v15\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    message := []byte(\"message to be signed\")\n    signature, _ := hex.DecodeString(\"ad2766728615cc7a746cc553916380ca7bfa4f8983b990913bc69eb0556539a350ff0f8fe65ddfd3ebe91fe1c299c2fac135bc8c61e26be44ee259f2f80c1530\")\n\n    // Only small messages can be signed directly; thus the hash of a\n    // message, rather than the message itself, is signed. This requires\n    // that the hash function be collision resistant. SHA-256 is the\n    // least-strong hash function that should be used for this at the time\n    // of writing (2016).\n    hashed := sha256.Sum256(message)\n\n    err := VerifyPKCS1v15(&amp;rsaPrivateKey.PublicKey, crypto.SHA256, hashed[:], signature)\n    if err != nil {\n            fmt.Fprintf(os.Stderr, \"Error from verification: %s\\n\", err)\n            return\n    }\n\n    // signature is a valid signature of message from the public key.\n</pre> </div> </div> <h2 id=\"VerifyPSS\">func VerifyPSS  </h2> <pre data-language=\"go\">func VerifyPSS(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *PSSOptions) error</pre> <p> VerifyPSS verifies a PSS signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. The opts argument may be nil, in which case sensible defaults are used. </p> <h2 id=\"CRTValue\">type CRTValue  </h2> <pre data-language=\"go\">type CRTValue struct {\n        Exp   *big.Int // D mod (prime-1).\n        Coeff *big.Int // R·Coeff ≡ 1 mod Prime.\n        R     *big.Int // product of primes prior to this (inc p and q).\n}</pre> <p> CRTValue contains the precomputed Chinese remainder theorem values. </p> <h2 id=\"OAEPOptions\">type OAEPOptions  </h2> <pre data-language=\"go\">type OAEPOptions struct {\n        // Hash is the hash function that will be used when generating the mask.\n        Hash crypto.Hash\n        // Label is an arbitrary byte string that must be equal to the value\n        // used when encrypting.\n        Label []byte\n}</pre> <p> OAEPOptions is an interface for passing options to OAEP decryption using the crypto.Decrypter interface. </p> <h2 id=\"PKCS1v15DecryptOptions\">type PKCS1v15DecryptOptions  </h2> <pre data-language=\"go\">type PKCS1v15DecryptOptions struct {\n        // SessionKeyLen is the length of the session key that is being\n        // decrypted. If not zero, then a padding error during decryption will\n        // cause a random plaintext of this length to be returned rather than\n        // an error. These alternatives happen in constant time.\n        SessionKeyLen int\n}</pre> <p> PKCS1v15DecrypterOpts is for passing options to PKCS#1 v1.5 decryption using the crypto.Decrypter interface. </p> <h2 id=\"PSSOptions\">type PSSOptions  </h2> <pre data-language=\"go\">type PSSOptions struct {\n        // SaltLength controls the length of the salt used in the PSS\n        // signature. It can either be a number of bytes, or one of the special\n        // PSSSaltLength constants.\n        SaltLength int\n\n        // Hash, if not zero, overrides the hash function passed to SignPSS.\n        // This is the only way to specify the hash function when using the\n        // crypto.Signer interface.\n        Hash crypto.Hash\n}</pre> <p> PSSOptions contains options for creating and verifying PSS signatures. </p> <h3 id=\"PSSOptions.HashFunc\">func (*PSSOptions) <a href=\"https://golang.org/src/crypto/rsa/pss.go?s=6515:6564#L224\">HashFunc</a>  </h3> <pre data-language=\"go\">func (pssOpts *PSSOptions) HashFunc() crypto.Hash</pre> <p> HashFunc returns pssOpts.Hash so that PSSOptions implements crypto.SignerOpts. </p> <h2 id=\"PrecomputedValues\">type PrecomputedValues  </h2> <pre data-language=\"go\">type PrecomputedValues struct {\n        Dp, Dq *big.Int // D mod (P-1) (or mod Q-1)\n        Qinv   *big.Int // Q^-1 mod P\n\n        // CRTValues is used for the 3rd and subsequent primes. Due to a\n        // historical accident, the CRT for the first two primes is handled\n        // differently in PKCS#1 and interoperability is sufficiently\n        // important that we mirror this.\n        CRTValues []CRTValue\n}</pre> <h2 id=\"PrivateKey\">type PrivateKey  </h2> <pre data-language=\"go\">type PrivateKey struct {\n        PublicKey            // public part.\n        D         *big.Int   // private exponent\n        Primes    []*big.Int // prime factors of N, has &gt;= 2 elements.\n\n        // Precomputed contains precomputed values that speed up private\n        // operations, if available.\n        Precomputed PrecomputedValues\n}</pre> <p> A PrivateKey represents an RSA key </p> <h3 id=\"GenerateKey\">func <a href=\"https://golang.org/src/crypto/rsa/rsa.go?s=6489:6554#L184\">GenerateKey</a>  </h3> <pre data-language=\"go\">func GenerateKey(random io.Reader, bits int) (*PrivateKey, error)</pre> <p> GenerateKey generates an RSA keypair of the given bit size using the random source random (for example, crypto/rand.Reader). </p> <h3 id=\"GenerateMultiPrimeKey\">func <a href=\"https://golang.org/src/crypto/rsa/rsa.go?s=7196:7284#L199\">GenerateMultiPrimeKey</a>  </h3> <pre data-language=\"go\">func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey, error)</pre> <p> GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit size and the given random source, as suggested in [1]. Although the public keys are compatible (actually, indistinguishable) from the 2-prime case, the private keys are not. Thus it may not be possible to export multi-prime private keys in certain formats or to subsequently import them into other code. </p> <p> Table 1 in [2] suggests maximum numbers of primes for a given size. </p> <p> [1] US patent 4405829 (1972, expired) [2] <a href=\"http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\">http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf</a> </p> <h3 id=\"PrivateKey.Decrypt\">func (*PrivateKey) <a href=\"https://golang.org/src/crypto/rsa/rsa.go?s=3688:3811#L98\">Decrypt</a>  </h3> <pre data-language=\"go\">func (priv *PrivateKey) Decrypt(rand io.Reader, ciphertext []byte, opts crypto.DecrypterOpts) (plaintext []byte, err error)</pre> <p> Decrypt decrypts ciphertext with priv. If opts is nil or of type *PKCS1v15DecryptOptions then PKCS#1 v1.5 decryption is performed. Otherwise opts must have type *OAEPOptions and OAEP decryption is done. </p> <h3 id=\"PrivateKey.Precompute\">func (*PrivateKey) <a href=\"https://golang.org/src/crypto/rsa/rsa.go?s=13166:13202#L421\">Precompute</a>  </h3> <pre data-language=\"go\">func (priv *PrivateKey) Precompute()</pre> <p> Precompute performs some calculations that speed up private key operations in the future. </p> <h3 id=\"PrivateKey.Public\">func (*PrivateKey) <a href=\"https://golang.org/src/crypto/rsa/rsa.go?s=2799:2848#L78\">Public</a>  </h3> <pre data-language=\"go\">func (priv *PrivateKey) Public() crypto.PublicKey</pre> <p> Public returns the public key corresponding to priv. </p> <h3 id=\"PrivateKey.Sign\">func (*PrivateKey) <a href=\"https://golang.org/src/crypto/rsa/rsa.go?s=3214:3310#L87\">Sign</a>  </h3> <pre data-language=\"go\">func (priv *PrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) ([]byte, error)</pre> <p> Sign signs msg with priv, reading randomness from rand. If opts is a *PSSOptions then the PSS algorithm will be used, otherwise PKCS#1 v1.5 will be used. This method is intended to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign* functions in this package. </p> <h3 id=\"PrivateKey.Validate\">func (*PrivateKey) <a href=\"https://golang.org/src/crypto/rsa/rsa.go?s=5224:5264#L146\">Validate</a>  </h3> <pre data-language=\"go\">func (priv *PrivateKey) Validate() error</pre> <p> Validate performs basic sanity checks on the key. It returns nil if the key is valid, or else an error describing a problem. </p> <h2 id=\"PublicKey\">type PublicKey  </h2> <pre data-language=\"go\">type PublicKey struct {\n        N *big.Int // modulus\n        E int      // public exponent\n}</pre> <p> A PublicKey represents the public part of an RSA key. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/rsa/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/rsa/</a>\n  </p>\n</div>\n","encoding/base64/index":"<h1>Package base64</h1>     <ul id=\"short-nav\">\n<li><code>import \"encoding/base64\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package base64 implements base64 encoding as specified by RFC 4648. </p> </div> </div> <div id=\"example_\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tmsg := \"Hello, 世界\"\n\tencoded := base64.StdEncoding.EncodeToString([]byte(msg))\n\tfmt.Println(encoded)\n\tdecoded, err := base64.StdEncoding.DecodeString(encoded)\n\tif err != nil {\n\t\tfmt.Println(\"decode error:\", err)\n\t\treturn\n\t}\n\tfmt.Println(string(decoded))\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#NewDecoder\">func NewDecoder(enc *Encoding, r io.Reader) io.Reader</a></li>\n<li><a href=\"#NewEncoder\">func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser</a></li>\n<li><a href=\"#CorruptInputError\">type CorruptInputError</a></li>\n<li> <a href=\"#CorruptInputError.Error\">func (e CorruptInputError) Error() string</a>\n</li>\n<li><a href=\"#Encoding\">type Encoding</a></li>\n<li> <a href=\"#NewEncoding\">func NewEncoding(encoder string) *Encoding</a>\n</li>\n<li> <a href=\"#Encoding.Decode\">func (enc *Encoding) Decode(dst, src []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#Encoding.DecodeString\">func (enc *Encoding) DecodeString(s string) ([]byte, error)</a>\n</li>\n<li> <a href=\"#Encoding.DecodedLen\">func (enc *Encoding) DecodedLen(n int) int</a>\n</li>\n<li> <a href=\"#Encoding.Encode\">func (enc *Encoding) Encode(dst, src []byte)</a>\n</li>\n<li> <a href=\"#Encoding.EncodeToString\">func (enc *Encoding) EncodeToString(src []byte) string</a>\n</li>\n<li> <a href=\"#Encoding.EncodedLen\">func (enc *Encoding) EncodedLen(n int) int</a>\n</li>\n<li> <a href=\"#Encoding.WithPadding\">func (enc Encoding) WithPadding(padding rune) *Encoding</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_\">Package</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Encoding_DecodeString\">Encoding.DecodeString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Encoding_EncodeToString\">Encoding.EncodeToString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_NewEncoder\">NewEncoder</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/encoding/base64/base64.go\">base64.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        StdPadding rune = '=' // Standard padding character\n        NoPadding  rune = -1  // No padding\n)</pre> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var RawStdEncoding = StdEncoding.WithPadding(NoPadding)</pre> <p> RawStdEncoding is the standard raw, unpadded base64 encoding, as defined in RFC 4648 section 3.2. This is the same as StdEncoding but omits padding characters. </p> <pre data-language=\"go\">var RawURLEncoding = URLEncoding.WithPadding(NoPadding)</pre> <p> RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names. This is the same as URLEncoding but omits padding characters. </p> <pre data-language=\"go\">var StdEncoding = NewEncoding(encodeStd)</pre> <p> StdEncoding is the standard base64 encoding, as defined in RFC 4648. </p> <pre data-language=\"go\">var URLEncoding = NewEncoding(encodeURL)</pre> <p> URLEncoding is the alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names. </p> <h2 id=\"NewDecoder\">func NewDecoder  </h2> <pre data-language=\"go\">func NewDecoder(enc *Encoding, r io.Reader) io.Reader</pre> <p> NewDecoder constructs a new base64 stream decoder. </p> <h2 id=\"NewEncoder\">func NewEncoder  </h2> <pre data-language=\"go\">func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser</pre> <p> NewEncoder returns a new base64 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base64 encodings operate in 4-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks. </p> <div id=\"example_NewEncoder\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/base64\"\n\t\"os\"\n)\n\nfunc main() {\n\tinput := []byte(\"foo\\x00bar\")\n\tencoder := base64.NewEncoder(base64.StdEncoding, os.Stdout)\n\tencoder.Write(input)\n\t// Must close the encoder when finished to flush any partial blocks.\n\t// If you comment out the following line, the last partial block \"r\"\n\t// won't be encoded.\n\tencoder.Close()\n}\n</pre> </div> </div> <h2 id=\"CorruptInputError\">type CorruptInputError  </h2> <pre data-language=\"go\">type CorruptInputError int64</pre> <h3 id=\"CorruptInputError.Error\">func (CorruptInputError) <a href=\"https://golang.org/src/encoding/base64/base64.go?s=6082:6123#L230\">Error</a>  </h3> <pre data-language=\"go\">func (e CorruptInputError) Error() string</pre> <h2 id=\"Encoding\">type Encoding  </h2> <pre data-language=\"go\">type Encoding struct {\n        // contains filtered or unexported fields\n}</pre> <p> An Encoding is a radix 64 encoding/decoding scheme, defined by a 64-character alphabet. The most common encoding is the \"base64\" encoding defined in RFC 4648 and used in MIME (RFC 2045) and PEM (RFC 1421). RFC 4648 also defines an alternate encoding, which is the standard encoding with - and _ substituted for + and /. </p> <h3 id=\"NewEncoding\">func <a href=\"https://golang.org/src/encoding/base64/base64.go?s=1220:1262#L30\">NewEncoding</a>  </h3> <pre data-language=\"go\">func NewEncoding(encoder string) *Encoding</pre> <p> NewEncoding returns a new padded Encoding defined by the given alphabet, which must be a 64-byte string. The resulting Encoding uses the default padding character ('='), which may be changed or disabled via WithPadding. </p> <h3 id=\"Encoding.Decode\">func (*Encoding) <a href=\"https://golang.org/src/encoding/base64/base64.go?s=8549:8612#L326\">Decode</a>  </h3> <pre data-language=\"go\">func (enc *Encoding) Decode(dst, src []byte) (n int, err error)</pre> <p> Decode decodes src using the encoding enc. It writes at most DecodedLen(len(src)) bytes to dst and returns the number of bytes written. If src contains invalid base64 data, it will return the number of bytes successfully written and CorruptInputError. New line characters (\\r and \\n) are ignored. </p> <h3 id=\"Encoding.DecodeString\">func (*Encoding) <a href=\"https://golang.org/src/encoding/base64/base64.go?s=8730:8789#L332\">DecodeString</a>  </h3> <pre data-language=\"go\">func (enc *Encoding) DecodeString(s string) ([]byte, error)</pre> <p> DecodeString returns the bytes represented by the base64 string s. </p> <div id=\"example_Encoding_DecodeString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tstr := \"c29tZSBkYXRhIHdpdGggACBhbmQg77u/\"\n\tdata, err := base64.StdEncoding.DecodeString(str)\n\tif err != nil {\n\t\tfmt.Println(\"error:\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%q\\n\", data)\n}\n</pre> </div> </div> <h3 id=\"Encoding.DecodedLen\">func (*Encoding) <a href=\"https://golang.org/src/encoding/base64/base64.go?s=11344:11386#L449\">DecodedLen</a>  </h3> <pre data-language=\"go\">func (enc *Encoding) DecodedLen(n int) int</pre> <p> DecodedLen returns the maximum length in bytes of the decoded data corresponding to n bytes of base64-encoded data. </p> <h3 id=\"Encoding.Encode\">func (*Encoding) <a href=\"https://golang.org/src/encoding/base64/base64.go?s=2844:2888#L83\">Encode</a>  </h3> <pre data-language=\"go\">func (enc *Encoding) Encode(dst, src []byte)</pre> <p> Encode encodes src using the encoding enc, writing EncodedLen(len(src)) bytes to dst. </p> <p> The encoding pads the output to a multiple of 4 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead. </p> <h3 id=\"Encoding.EncodeToString\">func (*Encoding) <a href=\"https://golang.org/src/encoding/base64/base64.go?s=3823:3877#L131\">EncodeToString</a>  </h3> <pre data-language=\"go\">func (enc *Encoding) EncodeToString(src []byte) string</pre> <p> EncodeToString returns the base64 encoding of src. </p> <div id=\"example_Encoding_EncodeToString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tdata := []byte(\"any + old &amp; data\")\n\tstr := base64.StdEncoding.EncodeToString(data)\n\tfmt.Println(str)\n}\n</pre> </div> </div> <h3 id=\"Encoding.EncodedLen\">func (*Encoding) <a href=\"https://golang.org/src/encoding/base64/base64.go?s=5825:5867#L217\">EncodedLen</a>  </h3> <pre data-language=\"go\">func (enc *Encoding) EncodedLen(n int) int</pre> <p> EncodedLen returns the length in bytes of the base64 encoding of an input buffer of length n. </p> <h3 id=\"Encoding.WithPadding\">func (Encoding) <a href=\"https://golang.org/src/encoding/base64/base64.go?s=1708:1763#L50\">WithPadding</a>  </h3> <pre data-language=\"go\">func (enc Encoding) WithPadding(padding rune) *Encoding</pre> <p> WithPadding creates a new encoding identical to enc except with a specified padding character, or NoPadding to disable padding. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/encoding/base64/\" class=\"_attribution-link\">https://golang.org/pkg/encoding/base64/</a>\n  </p>\n</div>\n","encoding/pem/index":"<h1>Package pem</h1>     <ul id=\"short-nav\">\n<li><code>import \"encoding/pem\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail. The most common use of PEM encoding today is in TLS keys and certificates. See RFC 1421. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Encode\">func Encode(out io.Writer, b *Block) error</a></li>\n<li><a href=\"#EncodeToMemory\">func EncodeToMemory(b *Block) []byte</a></li>\n<li><a href=\"#Block\">type Block</a></li>\n<li> <a href=\"#Decode\">func Decode(data []byte) (p *Block, rest []byte)</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/encoding/pem/pem.go\">pem.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Encode\">func Encode  </h2> <pre data-language=\"go\">func Encode(out io.Writer, b *Block) error</pre> <h2 id=\"EncodeToMemory\">func EncodeToMemory  </h2> <pre data-language=\"go\">func EncodeToMemory(b *Block) []byte</pre> <h2 id=\"Block\">type Block  </h2> <pre data-language=\"go\">type Block struct {\n        Type    string            // The type, taken from the preamble (i.e. \"RSA PRIVATE KEY\").\n        Headers map[string]string // Optional headers.\n        Bytes   []byte            // The decoded bytes of the contents. Typically a DER encoded ASN.1 structure.\n}</pre> <p> A Block represents a PEM encoded structure. </p> <p> The encoded form is: </p> <pre data-language=\"go\">-----BEGIN Type-----\nHeaders\nbase64-encoded Bytes\n-----END Type-----\n</pre> <p> where Headers is a possibly empty sequence of Key: Value lines. </p> <h3 id=\"Decode\">func <a href=\"https://golang.org/src/encoding/pem/pem.go?s=2203:2251#L68\">Decode</a>  </h3> <pre data-language=\"go\">func Decode(data []byte) (p *Block, rest []byte)</pre> <p> Decode will find the next PEM formatted block (certificate, private key etc) in the input. It returns that block and the remainder of the input. If no PEM data is found, p is nil and the whole of the input is returned in rest. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/encoding/pem/\" class=\"_attribution-link\">https://golang.org/pkg/encoding/pem/</a>\n  </p>\n</div>\n","encoding/hex/index":"<h1>Package hex</h1>     <ul id=\"short-nav\">\n<li><code>import \"encoding/hex\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package hex implements hexadecimal encoding and decoding. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Decode\">func Decode(dst, src []byte) (int, error)</a></li>\n<li><a href=\"#DecodeString\">func DecodeString(s string) ([]byte, error)</a></li>\n<li><a href=\"#DecodedLen\">func DecodedLen(x int) int</a></li>\n<li><a href=\"#Dump\">func Dump(data []byte) string</a></li>\n<li><a href=\"#Dumper\">func Dumper(w io.Writer) io.WriteCloser</a></li>\n<li><a href=\"#Encode\">func Encode(dst, src []byte) int</a></li>\n<li><a href=\"#EncodeToString\">func EncodeToString(src []byte) string</a></li>\n<li><a href=\"#EncodedLen\">func EncodedLen(n int) int</a></li>\n<li><a href=\"#InvalidByteError\">type InvalidByteError</a></li>\n<li> <a href=\"#InvalidByteError.Error\">func (e InvalidByteError) Error() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/encoding/hex/hex.go\">hex.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrLength = errors.New(\"encoding/hex: odd length hex string\")</pre> <p> ErrLength results from decoding an odd length slice. </p> <h2 id=\"Decode\">func Decode  </h2> <pre data-language=\"go\">func Decode(dst, src []byte) (int, error)</pre> <p> Decode decodes src into DecodedLen(len(src)) bytes, returning the actual number of bytes written to dst. </p> <p> If Decode encounters invalid input, it returns an error describing the failure. </p> <h2 id=\"DecodeString\">func DecodeString  </h2> <pre data-language=\"go\">func DecodeString(s string) ([]byte, error)</pre> <p> DecodeString returns the bytes represented by the hexadecimal string s. </p> <h2 id=\"DecodedLen\">func DecodedLen  </h2> <pre data-language=\"go\">func DecodedLen(x int) int</pre> <h2 id=\"Dump\">func Dump  </h2> <pre data-language=\"go\">func Dump(data []byte) string</pre> <p> Dump returns a string that contains a hex dump of the given data. The format of the hex dump matches the output of `hexdump -C` on the command line. </p> <h2 id=\"Dumper\">func Dumper  </h2> <pre data-language=\"go\">func Dumper(w io.Writer) io.WriteCloser</pre> <p> Dumper returns a WriteCloser that writes a hex dump of all written data to w. The format of the dump matches the output of `hexdump -C` on the command line. </p> <h2 id=\"Encode\">func Encode  </h2> <pre data-language=\"go\">func Encode(dst, src []byte) int</pre> <p> Encode encodes src into EncodedLen(len(src)) bytes of dst. As a convenience, it returns the number of bytes written to dst, but this value is always EncodedLen(len(src)). Encode implements hexadecimal encoding. </p> <h2 id=\"EncodeToString\">func EncodeToString  </h2> <pre data-language=\"go\">func EncodeToString(src []byte) string</pre> <p> EncodeToString returns the hexadecimal encoding of src. </p> <h2 id=\"EncodedLen\">func EncodedLen  </h2> <pre data-language=\"go\">func EncodedLen(n int) int</pre> <p> EncodedLen returns the length of an encoding of n source bytes. </p> <h2 id=\"InvalidByteError\">type InvalidByteError  </h2> <pre data-language=\"go\">type InvalidByteError byte</pre> <p> InvalidByteError values describe errors resulting from an invalid byte in a hex string. </p> <h3 id=\"InvalidByteError.Error\">func (InvalidByteError) <a href=\"https://golang.org/src/encoding/hex/hex.go?s=1040:1080#L29\">Error</a>  </h3> <pre data-language=\"go\">func (e InvalidByteError) Error() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/encoding/hex/\" class=\"_attribution-link\">https://golang.org/pkg/encoding/hex/</a>\n  </p>\n</div>\n","debug/plan9obj/index":"<h1>Package plan9obj</h1>     <ul id=\"short-nav\">\n<li><code>import \"debug/plan9obj\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package plan9obj implements access to Plan 9 a.out object files. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#File\">type File</a></li>\n<li> <a href=\"#NewFile\">func NewFile(r io.ReaderAt) (*File, error)</a>\n</li>\n<li> <a href=\"#Open\">func Open(name string) (*File, error)</a>\n</li>\n<li> <a href=\"#File.Close\">func (f *File) Close() error</a>\n</li>\n<li> <a href=\"#File.Section\">func (f *File) Section(name string) *Section</a>\n</li>\n<li> <a href=\"#File.Symbols\">func (f *File) Symbols() ([]Sym, error)</a>\n</li>\n<li><a href=\"#FileHeader\">type FileHeader</a></li>\n<li><a href=\"#Section\">type Section</a></li>\n<li> <a href=\"#Section.Data\">func (s *Section) Data() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Section.Open\">func (s *Section) Open() io.ReadSeeker</a>\n</li>\n<li><a href=\"#SectionHeader\">type SectionHeader</a></li>\n<li><a href=\"#Sym\">type Sym</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/debug/plan9obj/file.go\">file.go</a> <a href=\"https://golang.org/src/debug/plan9obj/plan9obj.go\">plan9obj.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        Magic64 = 0x8000 // 64-bit expanded header\n\n        Magic386   = (4*11+0)*11 + 7\n        MagicAMD64 = (4*26+0)*26 + 7 + Magic64\n        MagicARM   = (4*20+0)*20 + 7\n)</pre> <h2 id=\"File\">type File  </h2> <pre data-language=\"go\">type File struct {\n        FileHeader\n        Sections []*Section\n        // contains filtered or unexported fields\n}</pre> <p> A File represents an open Plan 9 a.out file. </p> <h3 id=\"NewFile\">func <a href=\"https://golang.org/src/debug/plan9obj/file.go?s=3073:3115#L125\">NewFile</a>  </h3> <pre data-language=\"go\">func NewFile(r io.ReaderAt) (*File, error)</pre> <p> NewFile creates a new File for accessing a Plan 9 binary in an underlying reader. The Plan 9 binary is expected to start at position 0 in the ReaderAt. </p> <h3 id=\"Open\">func <a href=\"https://golang.org/src/debug/plan9obj/file.go?s=2249:2286#L88\">Open</a>  </h3> <pre data-language=\"go\">func Open(name string) (*File, error)</pre> <p> Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary. </p> <h3 id=\"File.Close\">func (*File) <a href=\"https://golang.org/src/debug/plan9obj/file.go?s=2576:2604#L105\">Close</a>  </h3> <pre data-language=\"go\">func (f *File) Close() error</pre> <p> Close closes the File. If the File was created using NewFile directly instead of Open, Close has no effect. </p> <h3 id=\"File.Section\">func (*File) <a href=\"https://golang.org/src/debug/plan9obj/file.go?s=6729:6773#L311\">Section</a>  </h3> <pre data-language=\"go\">func (f *File) Section(name string) *Section</pre> <p> Section returns a section with the given name, or nil if no such section exists. </p> <h3 id=\"File.Symbols\">func (*File) <a href=\"https://golang.org/src/debug/plan9obj/file.go?s=6335:6374#L295\">Symbols</a>  </h3> <pre data-language=\"go\">func (f *File) Symbols() ([]Sym, error)</pre> <p> Symbols returns the symbol table for f. </p> <h2 id=\"FileHeader\">type FileHeader  </h2> <pre data-language=\"go\">type FileHeader struct {\n        Magic       uint32\n        Bss         uint32\n        Entry       uint64\n        PtrSize     int\n        LoadAddress uint64\n        HdrSize     uint64\n}</pre> <p> A FileHeader represents a Plan 9 a.out file header. </p> <h2 id=\"Section\">type Section  </h2> <pre data-language=\"go\">type Section struct {\n        SectionHeader\n\n        // Embed ReaderAt for ReadAt method.\n        // Do not embed SectionReader directly\n        // to avoid having Read and Seek.\n        // If a client wants Read and Seek it must use\n        // Open() to avoid fighting over the seek offset\n        // with other clients.\n        io.ReaderAt\n        // contains filtered or unexported fields\n}</pre> <p> A Section represents a single section in a Plan 9 a.out file. </p> <h3 id=\"Section.Data\">func (*Section) <a href=\"https://golang.org/src/debug/plan9obj/file.go?s=1307:1347#L47\">Data</a>  </h3> <pre data-language=\"go\">func (s *Section) Data() ([]byte, error)</pre> <p> Data reads and returns the contents of the Plan 9 a.out section. </p> <h3 id=\"Section.Open\">func (*Section) <a href=\"https://golang.org/src/debug/plan9obj/file.go?s=1542:1580#L57\">Open</a>  </h3> <pre data-language=\"go\">func (s *Section) Open() io.ReadSeeker</pre> <p> Open returns a new ReadSeeker reading the Plan 9 a.out section. </p> <h2 id=\"SectionHeader\">type SectionHeader  </h2> <pre data-language=\"go\">type SectionHeader struct {\n        Name   string\n        Size   uint32\n        Offset uint32\n}</pre> <p> A SectionHeader represents a single Plan 9 a.out section header. This structure doesn't exist on-disk, but eases navigation through the object file. </p> <h2 id=\"Sym\">type Sym  </h2> <pre data-language=\"go\">type Sym struct {\n        Value uint64\n        Type  rune\n        Name  string\n}</pre> <p> A Symbol represents an entry in a Plan 9 a.out symbol table section. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/debug/plan9obj/\" class=\"_attribution-link\">https://golang.org/pkg/debug/plan9obj/</a>\n  </p>\n</div>\n","errors/index":"<h1>Package errors</h1>     <ul id=\"short-nav\">\n<li><code>import \"errors\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package errors implements functions to manipulate errors. </p> </div> </div> <div id=\"example_\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// MyError is an error implementation that includes a time and message.\ntype MyError struct {\n\tWhen time.Time\n\tWhat string\n}\n\nfunc (e MyError) Error() string {\n\treturn fmt.Sprintf(\"%v: %v\", e.When, e.What)\n}\n\nfunc oops() error {\n\treturn MyError{\n\t\ttime.Date(1989, 3, 15, 22, 30, 0, 0, time.UTC),\n\t\t\"the file system has gone away\",\n\t}\n}\n\nfunc main() {\n\tif err := oops(); err != nil {\n\t\tfmt.Println(err)\n\t}\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\"><li><a href=\"#New\">func New(text string) error</a></li></ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_\">Package</a></dd> <dd><a class=\"exampleLink\" href=\"#example_New\">New</a></dd> <dd><a class=\"exampleLink\" href=\"#example_New_errorf\">New (Errorf)</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/errors/errors.go\">errors.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"New\">func New  </h2> <pre data-language=\"go\">func New(text string) error</pre> <p> New returns an error that formats as the given text. </p> <div id=\"example_New\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\terr := errors.New(\"emit macho dwarf: elf header corrupted\")\n\tif err != nil {\n\t\tfmt.Print(err)\n\t}\n}\n</pre> </div> </div> <div id=\"example_New_errorf\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Errorf)</h2> <p>The fmt package's Errorf function lets us use the package's formatting features to create descriptive error messages. </p> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tconst name, id = \"bimmler\", 17\n\terr := fmt.Errorf(\"user %q (id %d) not found\", name, id)\n\tif err != nil {\n\t\tfmt.Print(err)\n\t}\n}\n</pre> </div> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/errors/\" class=\"_attribution-link\">https://golang.org/pkg/errors/</a>\n  </p>\n</div>\n","debug/macho/index":"<h1>Package macho</h1>     <ul id=\"short-nav\">\n<li><code>import \"debug/macho\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package macho implements access to Mach-O object files. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Cpu\">type Cpu</a></li>\n<li> <a href=\"#Cpu.GoString\">func (i Cpu) GoString() string</a>\n</li>\n<li> <a href=\"#Cpu.String\">func (i Cpu) String() string</a>\n</li>\n<li><a href=\"#Dylib\">type Dylib</a></li>\n<li><a href=\"#DylibCmd\">type DylibCmd</a></li>\n<li><a href=\"#Dysymtab\">type Dysymtab</a></li>\n<li><a href=\"#DysymtabCmd\">type DysymtabCmd</a></li>\n<li><a href=\"#FatArch\">type FatArch</a></li>\n<li><a href=\"#FatArchHeader\">type FatArchHeader</a></li>\n<li><a href=\"#FatFile\">type FatFile</a></li>\n<li> <a href=\"#NewFatFile\">func NewFatFile(r io.ReaderAt) (*FatFile, error)</a>\n</li>\n<li> <a href=\"#OpenFat\">func OpenFat(name string) (*FatFile, error)</a>\n</li>\n<li> <a href=\"#FatFile.Close\">func (ff *FatFile) Close() error</a>\n</li>\n<li><a href=\"#File\">type File</a></li>\n<li> <a href=\"#NewFile\">func NewFile(r io.ReaderAt) (*File, error)</a>\n</li>\n<li> <a href=\"#Open\">func Open(name string) (*File, error)</a>\n</li>\n<li> <a href=\"#File.Close\">func (f *File) Close() error</a>\n</li>\n<li> <a href=\"#File.DWARF\">func (f *File) DWARF() (*dwarf.Data, error)</a>\n</li>\n<li> <a href=\"#File.ImportedLibraries\">func (f *File) ImportedLibraries() ([]string, error)</a>\n</li>\n<li> <a href=\"#File.ImportedSymbols\">func (f *File) ImportedSymbols() ([]string, error)</a>\n</li>\n<li> <a href=\"#File.Section\">func (f *File) Section(name string) *Section</a>\n</li>\n<li> <a href=\"#File.Segment\">func (f *File) Segment(name string) *Segment</a>\n</li>\n<li><a href=\"#FileHeader\">type FileHeader</a></li>\n<li><a href=\"#FormatError\">type FormatError</a></li>\n<li> <a href=\"#FormatError.Error\">func (e *FormatError) Error() string</a>\n</li>\n<li><a href=\"#Load\">type Load</a></li>\n<li><a href=\"#LoadBytes\">type LoadBytes</a></li>\n<li> <a href=\"#LoadBytes.Raw\">func (b LoadBytes) Raw() []byte</a>\n</li>\n<li><a href=\"#LoadCmd\">type LoadCmd</a></li>\n<li> <a href=\"#LoadCmd.GoString\">func (i LoadCmd) GoString() string</a>\n</li>\n<li> <a href=\"#LoadCmd.String\">func (i LoadCmd) String() string</a>\n</li>\n<li><a href=\"#Nlist32\">type Nlist32</a></li>\n<li><a href=\"#Nlist64\">type Nlist64</a></li>\n<li><a href=\"#Regs386\">type Regs386</a></li>\n<li><a href=\"#RegsAMD64\">type RegsAMD64</a></li>\n<li><a href=\"#Section\">type Section</a></li>\n<li> <a href=\"#Section.Data\">func (s *Section) Data() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Section.Open\">func (s *Section) Open() io.ReadSeeker</a>\n</li>\n<li><a href=\"#Section32\">type Section32</a></li>\n<li><a href=\"#Section64\">type Section64</a></li>\n<li><a href=\"#SectionHeader\">type SectionHeader</a></li>\n<li><a href=\"#Segment\">type Segment</a></li>\n<li> <a href=\"#Segment.Data\">func (s *Segment) Data() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Segment.Open\">func (s *Segment) Open() io.ReadSeeker</a>\n</li>\n<li><a href=\"#Segment32\">type Segment32</a></li>\n<li><a href=\"#Segment64\">type Segment64</a></li>\n<li><a href=\"#SegmentHeader\">type SegmentHeader</a></li>\n<li><a href=\"#Symbol\">type Symbol</a></li>\n<li><a href=\"#Symtab\">type Symtab</a></li>\n<li><a href=\"#SymtabCmd\">type SymtabCmd</a></li>\n<li><a href=\"#Thread\">type Thread</a></li>\n<li><a href=\"#Type\">type Type</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/debug/macho/fat.go\">fat.go</a> <a href=\"https://golang.org/src/debug/macho/file.go\">file.go</a> <a href=\"https://golang.org/src/debug/macho/macho.go\">macho.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        Magic32  uint32 = 0xfeedface\n        Magic64  uint32 = 0xfeedfacf\n        MagicFat uint32 = 0xcafebabe\n)</pre> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrNotFat = &amp;FormatError{0, \"not a fat Mach-O file\", nil}</pre> <p> ErrNotFat is returned from NewFatFile or OpenFat when the file is not a universal binary but may be a thin binary, based on its magic number. </p> <h2 id=\"Cpu\">type Cpu  </h2> <pre data-language=\"go\">type Cpu uint32</pre> <p> A Cpu is a Mach-O cpu type. </p> <pre data-language=\"go\">const (\n        Cpu386   Cpu = 7\n        CpuAmd64 Cpu = Cpu386 | cpuArch64\n        CpuArm   Cpu = 12\n        CpuPpc   Cpu = 18\n        CpuPpc64 Cpu = CpuPpc | cpuArch64\n)</pre> <h3 id=\"Cpu.GoString\">func (Cpu) <a href=\"https://golang.org/src/debug/macho/macho.go?s=1371:1401#L56\">GoString</a>  </h3> <pre data-language=\"go\">func (i Cpu) GoString() string</pre> <h3 id=\"Cpu.String\">func (Cpu) <a href=\"https://golang.org/src/debug/macho/macho.go?s=1288:1316#L55\">String</a>  </h3> <pre data-language=\"go\">func (i Cpu) String() string</pre> <h2 id=\"Dylib\">type Dylib  </h2> <pre data-language=\"go\">type Dylib struct {\n        LoadBytes\n        Name           string\n        Time           uint32\n        CurrentVersion uint32\n        CompatVersion  uint32\n}</pre> <p> A Dylib represents a Mach-O load dynamic library command. </p> <h2 id=\"DylibCmd\">type DylibCmd  </h2> <pre data-language=\"go\">type DylibCmd struct {\n        Cmd            LoadCmd\n        Len            uint32\n        Name           uint32\n        Time           uint32\n        CurrentVersion uint32\n        CompatVersion  uint32\n}</pre> <p> A DylibCmd is a Mach-O load dynamic library command. </p> <h2 id=\"Dysymtab\">type Dysymtab  </h2> <pre data-language=\"go\">type Dysymtab struct {\n        LoadBytes\n        DysymtabCmd\n        IndirectSyms []uint32 // indices into Symtab.Syms\n}</pre> <p> A Dysymtab represents a Mach-O dynamic symbol table command. </p> <h2 id=\"DysymtabCmd\">type DysymtabCmd  </h2> <pre data-language=\"go\">type DysymtabCmd struct {\n        Cmd            LoadCmd\n        Len            uint32\n        Ilocalsym      uint32\n        Nlocalsym      uint32\n        Iextdefsym     uint32\n        Nextdefsym     uint32\n        Iundefsym      uint32\n        Nundefsym      uint32\n        Tocoffset      uint32\n        Ntoc           uint32\n        Modtaboff      uint32\n        Nmodtab        uint32\n        Extrefsymoff   uint32\n        Nextrefsyms    uint32\n        Indirectsymoff uint32\n        Nindirectsyms  uint32\n        Extreloff      uint32\n        Nextrel        uint32\n        Locreloff      uint32\n        Nlocrel        uint32\n}</pre> <p> A DysymtabCmd is a Mach-O dynamic symbol table command. </p> <h2 id=\"FatArch\">type FatArch  </h2> <pre data-language=\"go\">type FatArch struct {\n        FatArchHeader\n        *File\n}</pre> <p> A FatArch is a Mach-O File inside a FatFile. </p> <h2 id=\"FatArchHeader\">type FatArchHeader  </h2> <pre data-language=\"go\">type FatArchHeader struct {\n        Cpu    Cpu\n        SubCpu uint32\n        Offset uint32\n        Size   uint32\n        Align  uint32\n}</pre> <p> A FatArchHeader represents a fat header for a specific image architecture. </p> <h2 id=\"FatFile\">type FatFile  </h2> <pre data-language=\"go\">type FatFile struct {\n        Magic  uint32\n        Arches []FatArch\n        // contains filtered or unexported fields\n}</pre> <p> A FatFile is a Mach-O universal binary that contains at least one architecture. </p> <h3 id=\"NewFatFile\">func <a href=\"https://golang.org/src/debug/macho/fat.go?s=1075:1123#L35\">NewFatFile</a>  </h3> <pre data-language=\"go\">func NewFatFile(r io.ReaderAt) (*FatFile, error)</pre> <p> NewFatFile creates a new FatFile for accessing all the Mach-O images in a universal binary. The Mach-O binary is expected to start at position 0 in the ReaderAt. </p> <h3 id=\"OpenFat\">func <a href=\"https://golang.org/src/debug/macho/fat.go?s=3687:3730#L115\">OpenFat</a>  </h3> <pre data-language=\"go\">func OpenFat(name string) (*FatFile, error)</pre> <p> OpenFat opens the named file using os.Open and prepares it for use as a Mach-O universal binary. </p> <h3 id=\"FatFile.Close\">func (*FatFile) <a href=\"https://golang.org/src/debug/macho/fat.go?s=3906:3938#L129\">Close</a>  </h3> <pre data-language=\"go\">func (ff *FatFile) Close() error</pre> <h2 id=\"File\">type File  </h2> <pre data-language=\"go\">type File struct {\n        FileHeader\n        ByteOrder binary.ByteOrder\n        Loads     []Load\n        Sections  []*Section\n\n        Symtab   *Symtab\n        Dysymtab *Dysymtab\n        // contains filtered or unexported fields\n}</pre> <p> A File represents an open Mach-O file. </p> <h3 id=\"NewFile\">func <a href=\"https://golang.org/src/debug/macho/file.go?s=4249:4291#L186\">NewFile</a>  </h3> <pre data-language=\"go\">func NewFile(r io.ReaderAt) (*File, error)</pre> <p> NewFile creates a new File for accessing a Mach-O binary in an underlying reader. The Mach-O binary is expected to start at position 0 in the ReaderAt. </p> <h3 id=\"Open\">func <a href=\"https://golang.org/src/debug/macho/file.go?s=3636:3673#L158\">Open</a>  </h3> <pre data-language=\"go\">func Open(name string) (*File, error)</pre> <p> Open opens the named file using os.Open and prepares it for use as a Mach-O binary. </p> <h3 id=\"File.Close\">func (*File) <a href=\"https://golang.org/src/debug/macho/file.go?s=3963:3991#L175\">Close</a>  </h3> <pre data-language=\"go\">func (f *File) Close() error</pre> <p> Close closes the File. If the File was created using NewFile directly instead of Open, Close has no effect. </p> <h3 id=\"File.DWARF\">func (*File) <a href=\"https://golang.org/src/debug/macho/file.go?s=11333:11376#L463\">DWARF</a>  </h3> <pre data-language=\"go\">func (f *File) DWARF() (*dwarf.Data, error)</pre> <p> DWARF returns the DWARF debug information for the Mach-O file. </p> <h3 id=\"File.ImportedLibraries\">func (*File) <a href=\"https://golang.org/src/debug/macho/file.go?s=12621:12673#L506\">ImportedLibraries</a>  </h3> <pre data-language=\"go\">func (f *File) ImportedLibraries() ([]string, error)</pre> <p> ImportedLibraries returns the paths of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time. </p> <h3 id=\"File.ImportedSymbols\">func (*File) <a href=\"https://golang.org/src/debug/macho/file.go?s=12129:12179#L489\">ImportedSymbols</a>  </h3> <pre data-language=\"go\">func (f *File) ImportedSymbols() ([]string, error)</pre> <p> ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. </p> <h3 id=\"File.Section\">func (*File) <a href=\"https://golang.org/src/debug/macho/file.go?s=11132:11176#L453\">Section</a>  </h3> <pre data-language=\"go\">func (f *File) Section(name string) *Section</pre> <p> Section returns the first section with the given name, or nil if no such section exists. </p> <h3 id=\"File.Segment\">func (*File) <a href=\"https://golang.org/src/debug/macho/file.go?s=10876:10920#L442\">Segment</a>  </h3> <pre data-language=\"go\">func (f *File) Segment(name string) *Segment</pre> <p> Segment returns the first Segment with the given name, or nil if no such segment exists. </p> <h2 id=\"FileHeader\">type FileHeader  </h2> <pre data-language=\"go\">type FileHeader struct {\n        Magic  uint32\n        Cpu    Cpu\n        SubCpu uint32\n        Type   Type\n        Ncmd   uint32\n        Cmdsz  uint32\n        Flags  uint32\n}</pre> <p> A FileHeader represents a Mach-O file header. </p> <h2 id=\"FormatError\">type FormatError  </h2> <pre data-language=\"go\">type FormatError struct {\n        // contains filtered or unexported fields\n}</pre> <p> FormatError is returned by some operations if the data does not have the correct format for an object file. </p> <h3 id=\"FormatError.Error\">func (*FormatError) <a href=\"https://golang.org/src/debug/macho/file.go?s=3369:3405#L148\">Error</a>  </h3> <pre data-language=\"go\">func (e *FormatError) Error() string</pre> <h2 id=\"Load\">type Load  </h2> <pre data-language=\"go\">type Load interface {\n        Raw() []byte\n}</pre> <p> A Load represents any Mach-O load command. </p> <h2 id=\"LoadBytes\">type LoadBytes  </h2> <pre data-language=\"go\">type LoadBytes []byte</pre> <p> A LoadBytes is the uninterpreted bytes of a Mach-O load command. </p> <h3 id=\"LoadBytes.Raw\">func (LoadBytes) <a href=\"https://golang.org/src/debug/macho/file.go?s=738:769#L30\">Raw</a>  </h3> <pre data-language=\"go\">func (b LoadBytes) Raw() []byte</pre> <h2 id=\"LoadCmd\">type LoadCmd  </h2> <pre data-language=\"go\">type LoadCmd uint32</pre> <p> A LoadCmd is a Mach-O load command. </p> <pre data-language=\"go\">const (\n        LoadCmdSegment    LoadCmd = 1\n        LoadCmdSymtab     LoadCmd = 2\n        LoadCmdThread     LoadCmd = 4\n        LoadCmdUnixThread LoadCmd = 5 // thread+stack\n        LoadCmdDysymtab   LoadCmd = 11\n        LoadCmdDylib      LoadCmd = 12\n        LoadCmdDylinker   LoadCmd = 15\n        LoadCmdSegment64  LoadCmd = 25\n)</pre> <h3 id=\"LoadCmd.GoString\">func (LoadCmd) <a href=\"https://golang.org/src/debug/macho/macho.go?s=2140:2174#L81\">GoString</a>  </h3> <pre data-language=\"go\">func (i LoadCmd) GoString() string</pre> <h3 id=\"LoadCmd.String\">func (LoadCmd) <a href=\"https://golang.org/src/debug/macho/macho.go?s=2053:2085#L80\">String</a>  </h3> <pre data-language=\"go\">func (i LoadCmd) String() string</pre> <h2 id=\"Nlist32\">type Nlist32  </h2> <pre data-language=\"go\">type Nlist32 struct {\n        Name  uint32\n        Type  uint8\n        Sect  uint8\n        Desc  uint16\n        Value uint32\n}</pre> <p> An Nlist32 is a Mach-O 32-bit symbol table entry. </p> <h2 id=\"Nlist64\">type Nlist64  </h2> <pre data-language=\"go\">type Nlist64 struct {\n        Name  uint32\n        Type  uint8\n        Sect  uint8\n        Desc  uint16\n        Value uint64\n}</pre> <p> An Nlist64 is a Mach-O 64-bit symbol table entry. </p> <h2 id=\"Regs386\">type Regs386  </h2> <pre data-language=\"go\">type Regs386 struct {\n        AX    uint32\n        BX    uint32\n        CX    uint32\n        DX    uint32\n        DI    uint32\n        SI    uint32\n        BP    uint32\n        SP    uint32\n        SS    uint32\n        FLAGS uint32\n        IP    uint32\n        CS    uint32\n        DS    uint32\n        ES    uint32\n        FS    uint32\n        GS    uint32\n}</pre> <p> Regs386 is the Mach-O 386 register structure. </p> <h2 id=\"RegsAMD64\">type RegsAMD64  </h2> <pre data-language=\"go\">type RegsAMD64 struct {\n        AX    uint64\n        BX    uint64\n        CX    uint64\n        DX    uint64\n        DI    uint64\n        SI    uint64\n        BP    uint64\n        SP    uint64\n        R8    uint64\n        R9    uint64\n        R10   uint64\n        R11   uint64\n        R12   uint64\n        R13   uint64\n        R14   uint64\n        R15   uint64\n        IP    uint64\n        FLAGS uint64\n        CS    uint64\n        FS    uint64\n        GS    uint64\n}</pre> <p> RegsAMD64 is the Mach-O AMD64 register structure. </p> <h2 id=\"Section\">type Section  </h2> <pre data-language=\"go\">type Section struct {\n        SectionHeader\n\n        // Embed ReaderAt for ReadAt method.\n        // Do not embed SectionReader directly\n        // to avoid having Read and Seek.\n        // If a client wants Read and Seek it must use\n        // Open() to avoid fighting over the seek offset\n        // with other clients.\n        io.ReaderAt\n        // contains filtered or unexported fields\n}</pre> <h3 id=\"Section.Data\">func (*Section) <a href=\"https://golang.org/src/debug/macho/file.go?s=2376:2416#L101\">Data</a>  </h3> <pre data-language=\"go\">func (s *Section) Data() ([]byte, error)</pre> <p> Data reads and returns the contents of the Mach-O section. </p> <h3 id=\"Section.Open\">func (*Section) <a href=\"https://golang.org/src/debug/macho/file.go?s=2605:2643#L111\">Open</a>  </h3> <pre data-language=\"go\">func (s *Section) Open() io.ReadSeeker</pre> <p> Open returns a new ReadSeeker reading the Mach-O section. </p> <h2 id=\"Section32\">type Section32  </h2> <pre data-language=\"go\">type Section32 struct {\n        Name     [16]byte\n        Seg      [16]byte\n        Addr     uint32\n        Size     uint32\n        Offset   uint32\n        Align    uint32\n        Reloff   uint32\n        Nreloc   uint32\n        Flags    uint32\n        Reserve1 uint32\n        Reserve2 uint32\n}</pre> <p> A Section32 is a 32-bit Mach-O section header. </p> <h2 id=\"Section64\">type Section64  </h2> <pre data-language=\"go\">type Section64 struct {\n        Name     [16]byte\n        Seg      [16]byte\n        Addr     uint64\n        Size     uint64\n        Offset   uint32\n        Align    uint32\n        Reloff   uint32\n        Nreloc   uint32\n        Flags    uint32\n        Reserve1 uint32\n        Reserve2 uint32\n        Reserve3 uint32\n}</pre> <p> A Section32 is a 64-bit Mach-O section header. </p> <h2 id=\"SectionHeader\">type SectionHeader  </h2> <pre data-language=\"go\">type SectionHeader struct {\n        Name   string\n        Seg    string\n        Addr   uint64\n        Size   uint64\n        Offset uint32\n        Align  uint32\n        Reloff uint32\n        Nreloc uint32\n        Flags  uint32\n}</pre> <h2 id=\"Segment\">type Segment  </h2> <pre data-language=\"go\">type Segment struct {\n        LoadBytes\n        SegmentHeader\n\n        // Embed ReaderAt for ReadAt method.\n        // Do not embed SectionReader directly\n        // to avoid having Read and Seek.\n        // If a client wants Read and Seek it must use\n        // Open() to avoid fighting over the seek offset\n        // with other clients.\n        io.ReaderAt\n        // contains filtered or unexported fields\n}</pre> <p> A Segment represents a Mach-O 32-bit or 64-bit load segment command. </p> <h3 id=\"Segment.Data\">func (*Segment) <a href=\"https://golang.org/src/debug/macho/file.go?s=1526:1566#L63\">Data</a>  </h3> <pre data-language=\"go\">func (s *Segment) Data() ([]byte, error)</pre> <p> Data reads and returns the contents of the segment. </p> <h3 id=\"Segment.Open\">func (*Segment) <a href=\"https://golang.org/src/debug/macho/file.go?s=1748:1786#L73\">Open</a>  </h3> <pre data-language=\"go\">func (s *Segment) Open() io.ReadSeeker</pre> <p> Open returns a new ReadSeeker reading the segment. </p> <h2 id=\"Segment32\">type Segment32  </h2> <pre data-language=\"go\">type Segment32 struct {\n        Cmd     LoadCmd\n        Len     uint32\n        Name    [16]byte\n        Addr    uint32\n        Memsz   uint32\n        Offset  uint32\n        Filesz  uint32\n        Maxprot uint32\n        Prot    uint32\n        Nsect   uint32\n        Flag    uint32\n}</pre> <p> A Segment32 is a 32-bit Mach-O segment load command. </p> <h2 id=\"Segment64\">type Segment64  </h2> <pre data-language=\"go\">type Segment64 struct {\n        Cmd     LoadCmd\n        Len     uint32\n        Name    [16]byte\n        Addr    uint64\n        Memsz   uint64\n        Offset  uint64\n        Filesz  uint64\n        Maxprot uint32\n        Prot    uint32\n        Nsect   uint32\n        Flag    uint32\n}</pre> <p> A Segment64 is a 64-bit Mach-O segment load command. </p> <h2 id=\"SegmentHeader\">type SegmentHeader  </h2> <pre data-language=\"go\">type SegmentHeader struct {\n        Cmd     LoadCmd\n        Len     uint32\n        Name    string\n        Addr    uint64\n        Memsz   uint64\n        Offset  uint64\n        Filesz  uint64\n        Maxprot uint32\n        Prot    uint32\n        Nsect   uint32\n        Flag    uint32\n}</pre> <p> A SegmentHeader is the header for a Mach-O 32-bit or 64-bit load segment command. </p> <h2 id=\"Symbol\">type Symbol  </h2> <pre data-language=\"go\">type Symbol struct {\n        Name  string\n        Type  uint8\n        Sect  uint8\n        Desc  uint16\n        Value uint64\n}</pre> <p> A Symbol is a Mach-O 32-bit or 64-bit symbol table entry. </p> <h2 id=\"Symtab\">type Symtab  </h2> <pre data-language=\"go\">type Symtab struct {\n        LoadBytes\n        SymtabCmd\n        Syms []Symbol\n}</pre> <p> A Symtab represents a Mach-O symbol table command. </p> <h2 id=\"SymtabCmd\">type SymtabCmd  </h2> <pre data-language=\"go\">type SymtabCmd struct {\n        Cmd     LoadCmd\n        Len     uint32\n        Symoff  uint32\n        Nsyms   uint32\n        Stroff  uint32\n        Strsize uint32\n}</pre> <p> A SymtabCmd is a Mach-O symbol table command. </p> <h2 id=\"Thread\">type Thread  </h2> <pre data-language=\"go\">type Thread struct {\n        Cmd  LoadCmd\n        Len  uint32\n        Type uint32\n        Data []uint32\n}</pre> <p> A Thread is a Mach-O thread state command. </p> <h2 id=\"Type\">type Type  </h2> <pre data-language=\"go\">type Type uint32</pre> <p> A Type is the Mach-O file type, e.g. an object file, executable, or dynamic library. </p> <pre data-language=\"go\">const (\n        TypeObj    Type = 1\n        TypeExec   Type = 2\n        TypeDylib  Type = 6\n        TypeBundle Type = 8\n)</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/debug/macho/\" class=\"_attribution-link\">https://golang.org/pkg/debug/macho/</a>\n  </p>\n</div>\n","expvar/index":"<h1>Package expvar</h1>     <ul id=\"short-nav\">\n<li><code>import \"expvar\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package expvar provides a standardized interface to public variables, such as operation counters in servers. It exposes these variables via HTTP at /debug/vars in JSON format. </p> <p> Operations to set or modify these public variables are atomic. </p> <p> In addition to adding the HTTP handler, this package registers the following variables: </p> <pre data-language=\"go\">cmdline   os.Args\nmemstats  runtime.Memstats\n</pre> <p> The package is sometimes only imported for the side effect of registering its HTTP handler and the above variables. To use it this way, link this package into your program: </p> <pre data-language=\"go\">import _ \"expvar\"\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Do\">func Do(f func(KeyValue))</a></li>\n<li><a href=\"#Publish\">func Publish(name string, v Var)</a></li>\n<li><a href=\"#Float\">type Float</a></li>\n<li> <a href=\"#NewFloat\">func NewFloat(name string) *Float</a>\n</li>\n<li> <a href=\"#Float.Add\">func (v *Float) Add(delta float64)</a>\n</li>\n<li> <a href=\"#Float.Set\">func (v *Float) Set(value float64)</a>\n</li>\n<li> <a href=\"#Float.String\">func (v *Float) String() string</a>\n</li>\n<li><a href=\"#Func\">type Func</a></li>\n<li> <a href=\"#Func.String\">func (f Func) String() string</a>\n</li>\n<li><a href=\"#Int\">type Int</a></li>\n<li> <a href=\"#NewInt\">func NewInt(name string) *Int</a>\n</li>\n<li> <a href=\"#Int.Add\">func (v *Int) Add(delta int64)</a>\n</li>\n<li> <a href=\"#Int.Set\">func (v *Int) Set(value int64)</a>\n</li>\n<li> <a href=\"#Int.String\">func (v *Int) String() string</a>\n</li>\n<li><a href=\"#KeyValue\">type KeyValue</a></li>\n<li><a href=\"#Map\">type Map</a></li>\n<li> <a href=\"#NewMap\">func NewMap(name string) *Map</a>\n</li>\n<li> <a href=\"#Map.Add\">func (v *Map) Add(key string, delta int64)</a>\n</li>\n<li> <a href=\"#Map.AddFloat\">func (v *Map) AddFloat(key string, delta float64)</a>\n</li>\n<li> <a href=\"#Map.Do\">func (v *Map) Do(f func(KeyValue))</a>\n</li>\n<li> <a href=\"#Map.Get\">func (v *Map) Get(key string) Var</a>\n</li>\n<li> <a href=\"#Map.Init\">func (v *Map) Init() *Map</a>\n</li>\n<li> <a href=\"#Map.Set\">func (v *Map) Set(key string, av Var)</a>\n</li>\n<li> <a href=\"#Map.String\">func (v *Map) String() string</a>\n</li>\n<li><a href=\"#String\">type String</a></li>\n<li> <a href=\"#NewString\">func NewString(name string) *String</a>\n</li>\n<li> <a href=\"#String.Set\">func (v *String) Set(value string)</a>\n</li>\n<li> <a href=\"#String.String\">func (v *String) String() string</a>\n</li>\n<li><a href=\"#Var\">type Var</a></li>\n<li> <a href=\"#Get\">func Get(name string) Var</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/expvar/expvar.go\">expvar.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Do\">func Do  </h2> <pre data-language=\"go\">func Do(f func(KeyValue))</pre> <p> Do calls f for each exported variable. The global variable map is locked during the iteration, but existing entries may be concurrently updated. </p> <h2 id=\"Publish\">func Publish  </h2> <pre data-language=\"go\">func Publish(name string, v Var)</pre> <p> Publish declares a named exported variable. This should be called from a package's init function when it creates its Vars. If the name is already registered then this will log.Panic. </p> <h2 id=\"Float\">type Float  </h2> <pre data-language=\"go\">type Float struct {\n        // contains filtered or unexported fields\n}</pre> <p> Float is a 64-bit float variable that satisfies the Var interface. </p> <h3 id=\"NewFloat\">func <a href=\"https://golang.org/src/expvar/expvar.go?s=5849:5882#L272\">NewFloat</a>  </h3> <pre data-language=\"go\">func NewFloat(name string) *Float</pre> <h3 id=\"Float.Add\">func (*Float) <a href=\"https://golang.org/src/expvar/expvar.go?s=1762:1796#L65\">Add</a>  </h3> <pre data-language=\"go\">func (v *Float) Add(delta float64)</pre> <p> Add adds delta to v. </p> <h3 id=\"Float.Set\">func (*Float) <a href=\"https://golang.org/src/expvar/expvar.go?s=2033:2067#L78\">Set</a>  </h3> <pre data-language=\"go\">func (v *Float) Set(value float64)</pre> <p> Set sets v to value. </p> <h3 id=\"Float.String\">func (*Float) <a href=\"https://golang.org/src/expvar/expvar.go?s=1610:1641#L59\">String</a>  </h3> <pre data-language=\"go\">func (v *Float) String() string</pre> <h2 id=\"Func\">type Func  </h2> <pre data-language=\"go\">type Func func() interface{}</pre> <p> Func implements Var by calling the function and formatting the returned value using JSON. </p> <h3 id=\"Func.String\">func (Func) <a href=\"https://golang.org/src/expvar/expvar.go?s=4888:4917#L230\">String</a>  </h3> <pre data-language=\"go\">func (f Func) String() string</pre> <h2 id=\"Int\">type Int  </h2> <pre data-language=\"go\">type Int struct {\n        // contains filtered or unexported fields\n}</pre> <p> Int is a 64-bit integer variable that satisfies the Var interface. </p> <h3 id=\"NewInt\">func <a href=\"https://golang.org/src/expvar/expvar.go?s=5771:5800#L266\">NewInt</a>  </h3> <pre data-language=\"go\">func NewInt(name string) *Int</pre> <h3 id=\"Int.Add\">func (*Int) <a href=\"https://golang.org/src/expvar/expvar.go?s=1373:1403#L46\">Add</a>  </h3> <pre data-language=\"go\">func (v *Int) Add(delta int64)</pre> <h3 id=\"Int.Set\">func (*Int) <a href=\"https://golang.org/src/expvar/expvar.go?s=1439:1469#L50\">Set</a>  </h3> <pre data-language=\"go\">func (v *Int) Set(value int64)</pre> <h3 id=\"Int.String\">func (*Int) <a href=\"https://golang.org/src/expvar/expvar.go?s=1284:1313#L42\">String</a>  </h3> <pre data-language=\"go\">func (v *Int) String() string</pre> <h2 id=\"KeyValue\">type KeyValue  </h2> <pre data-language=\"go\">type KeyValue struct {\n        Key   string\n        Value Var\n}</pre> <p> KeyValue represents a single entry in a Map. </p> <h2 id=\"Map\">type Map  </h2> <pre data-language=\"go\">type Map struct {\n        // contains filtered or unexported fields\n}</pre> <p> Map is a string-to-Var map variable that satisfies the Var interface. </p> <h3 id=\"NewMap\">func <a href=\"https://golang.org/src/expvar/expvar.go?s=5933:5962#L278\">NewMap</a>  </h3> <pre data-language=\"go\">func NewMap(name string) *Map</pre> <h3 id=\"Map.Add\">func (*Map) <a href=\"https://golang.org/src/expvar/expvar.go?s=3240:3282#L144\">Add</a>  </h3> <pre data-language=\"go\">func (v *Map) Add(key string, delta int64)</pre> <h3 id=\"Map.AddFloat\">func (*Map) <a href=\"https://golang.org/src/expvar/expvar.go?s=3665:3714#L167\">AddFloat</a>  </h3> <pre data-language=\"go\">func (v *Map) AddFloat(key string, delta float64)</pre> <p> AddFloat adds delta to the *Float value stored under the given map key. </p> <h3 id=\"Map.Do\">func (*Map) <a href=\"https://golang.org/src/expvar/expvar.go?s=4165:4199#L192\">Do</a>  </h3> <pre data-language=\"go\">func (v *Map) Do(f func(KeyValue))</pre> <p> Do calls f for each entry in the map. The map is locked during the iteration, but existing entries may be concurrently updated. </p> <h3 id=\"Map.Get\">func (*Map) <a href=\"https://golang.org/src/expvar/expvar.go?s=3040:3073#L131\">Get</a>  </h3> <pre data-language=\"go\">func (v *Map) Get(key string) Var</pre> <h3 id=\"Map.Init\">func (*Map) <a href=\"https://golang.org/src/expvar/expvar.go?s=2692:2717#L112\">Init</a>  </h3> <pre data-language=\"go\">func (v *Map) Init() *Map</pre> <h3 id=\"Map.Set\">func (*Map) <a href=\"https://golang.org/src/expvar/expvar.go?s=3132:3169#L137\">Set</a>  </h3> <pre data-language=\"go\">func (v *Map) Set(key string, av Var)</pre> <h3 id=\"Map.String\">func (*Map) <a href=\"https://golang.org/src/expvar/expvar.go?s=2382:2411#L95\">String</a>  </h3> <pre data-language=\"go\">func (v *Map) String() string</pre> <h2 id=\"String\">type String  </h2> <pre data-language=\"go\">type String struct {\n        // contains filtered or unexported fields\n}</pre> <p> String is a string variable, and satisfies the Var interface. </p> <h3 id=\"NewString\">func <a href=\"https://golang.org/src/expvar/expvar.go?s=6018:6053#L284\">NewString</a>  </h3> <pre data-language=\"go\">func NewString(name string) *String</pre> <h3 id=\"String.Set\">func (*String) <a href=\"https://golang.org/src/expvar/expvar.go?s=4675:4709#L220\">Set</a>  </h3> <pre data-language=\"go\">func (v *String) Set(value string)</pre> <h3 id=\"String.String\">func (*String) <a href=\"https://golang.org/src/expvar/expvar.go?s=4554:4586#L212\">String</a>  </h3> <pre data-language=\"go\">func (v *String) String() string</pre> <h2 id=\"Var\">type Var  </h2> <pre data-language=\"go\">type Var interface {\n        // String returns a valid JSON value for the variable.\n        // Types with String methods that do not return valid JSON\n        // (such as time.Time) must not be used as a Var.\n        String() string\n}</pre> <p> Var is an abstract type for all exported variables. </p> <h3 id=\"Get\">func <a href=\"https://golang.org/src/expvar/expvar.go?s=5620:5645#L258\">Get</a>  </h3> <pre data-language=\"go\">func Get(name string) Var</pre> <p> Get retrieves a named exported variable. It returns nil if the name has not been registered. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/expvar/\" class=\"_attribution-link\">https://golang.org/pkg/expvar/</a>\n  </p>\n</div>\n","go/index":"<h1>Directory /src/go</h1>    <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"ast/index\">ast</a> </td> <td class=\"pkg-synopsis\"> Package ast declares the types used to represent syntax trees for Go packages. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"build/index\">build</a> </td> <td class=\"pkg-synopsis\"> Package build gathers information about Go packages. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"constant/index\">constant</a> </td> <td class=\"pkg-synopsis\"> Package constant implements Values representing untyped Go constants and their corresponding operations. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"doc/index\">doc</a> </td> <td class=\"pkg-synopsis\"> Package doc extracts source code documentation from a Go AST. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"format/index\">format</a> </td> <td class=\"pkg-synopsis\"> Package format implements standard formatting of Go source. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"importer/index\">importer</a> </td> <td class=\"pkg-synopsis\"> Package importer provides access to export data importers. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"parser/index\">parser</a> </td> <td class=\"pkg-synopsis\"> Package parser implements a parser for Go source files. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"printer/index\">printer</a> </td> <td class=\"pkg-synopsis\"> Package printer implements printing of AST nodes. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"scanner/index\">scanner</a> </td> <td class=\"pkg-synopsis\"> Package scanner implements a scanner for Go source text. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"token/index\">token</a> </td> <td class=\"pkg-synopsis\"> Package token defines constants representing the lexical tokens of the Go programming language and basic operations on tokens (printing, predicates). </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"types/index\">types</a> </td> <td class=\"pkg-synopsis\"> Package types declares the data types and implements the algorithms for type-checking of Go packages. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/go/\" class=\"_attribution-link\">https://golang.org/pkg/go/</a>\n  </p>\n</div>\n","crypto/x509/index":"<h1>Package x509</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/x509\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package x509 parses X.509-encoded keys and certificates. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#CreateCertificate\">func CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv interface{}) (cert []byte, err error)</a></li>\n<li><a href=\"#CreateCertificateRequest\">func CreateCertificateRequest(rand io.Reader, template *CertificateRequest, priv interface{}) (csr []byte, err error)</a></li>\n<li><a href=\"#DecryptPEMBlock\">func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error)</a></li>\n<li><a href=\"#EncryptPEMBlock\">func EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error)</a></li>\n<li><a href=\"#IsEncryptedPEMBlock\">func IsEncryptedPEMBlock(b *pem.Block) bool</a></li>\n<li><a href=\"#MarshalECPrivateKey\">func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)</a></li>\n<li><a href=\"#MarshalPKCS1PrivateKey\">func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte</a></li>\n<li><a href=\"#MarshalPKIXPublicKey\">func MarshalPKIXPublicKey(pub interface{}) ([]byte, error)</a></li>\n<li><a href=\"#ParseCRL\">func ParseCRL(crlBytes []byte) (*pkix.CertificateList, error)</a></li>\n<li><a href=\"#ParseCertificates\">func ParseCertificates(asn1Data []byte) ([]*Certificate, error)</a></li>\n<li><a href=\"#ParseDERCRL\">func ParseDERCRL(derBytes []byte) (*pkix.CertificateList, error)</a></li>\n<li><a href=\"#ParseECPrivateKey\">func ParseECPrivateKey(der []byte) (*ecdsa.PrivateKey, error)</a></li>\n<li><a href=\"#ParsePKCS1PrivateKey\">func ParsePKCS1PrivateKey(der []byte) (*rsa.PrivateKey, error)</a></li>\n<li><a href=\"#ParsePKCS8PrivateKey\">func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error)</a></li>\n<li><a href=\"#ParsePKIXPublicKey\">func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error)</a></li>\n<li><a href=\"#CertPool\">type CertPool</a></li>\n<li> <a href=\"#NewCertPool\">func NewCertPool() *CertPool</a>\n</li>\n<li> <a href=\"#SystemCertPool\">func SystemCertPool() (*CertPool, error)</a>\n</li>\n<li> <a href=\"#CertPool.AddCert\">func (s *CertPool) AddCert(cert *Certificate)</a>\n</li>\n<li> <a href=\"#CertPool.AppendCertsFromPEM\">func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool)</a>\n</li>\n<li> <a href=\"#CertPool.Subjects\">func (s *CertPool) Subjects() [][]byte</a>\n</li>\n<li><a href=\"#Certificate\">type Certificate</a></li>\n<li> <a href=\"#ParseCertificate\">func ParseCertificate(asn1Data []byte) (*Certificate, error)</a>\n</li>\n<li> <a href=\"#Certificate.CheckCRLSignature\">func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) error</a>\n</li>\n<li> <a href=\"#Certificate.CheckSignature\">func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) error</a>\n</li>\n<li> <a href=\"#Certificate.CheckSignatureFrom\">func (c *Certificate) CheckSignatureFrom(parent *Certificate) error</a>\n</li>\n<li> <a href=\"#Certificate.CreateCRL\">func (c *Certificate) CreateCRL(rand io.Reader, priv interface{}, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)</a>\n</li>\n<li> <a href=\"#Certificate.Equal\">func (c *Certificate) Equal(other *Certificate) bool</a>\n</li>\n<li> <a href=\"#Certificate.Verify\">func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error)</a>\n</li>\n<li> <a href=\"#Certificate.VerifyHostname\">func (c *Certificate) VerifyHostname(h string) error</a>\n</li>\n<li><a href=\"#CertificateInvalidError\">type CertificateInvalidError</a></li>\n<li> <a href=\"#CertificateInvalidError.Error\">func (e CertificateInvalidError) Error() string</a>\n</li>\n<li><a href=\"#CertificateRequest\">type CertificateRequest</a></li>\n<li> <a href=\"#ParseCertificateRequest\">func ParseCertificateRequest(asn1Data []byte) (*CertificateRequest, error)</a>\n</li>\n<li> <a href=\"#CertificateRequest.CheckSignature\">func (c *CertificateRequest) CheckSignature() error</a>\n</li>\n<li><a href=\"#ConstraintViolationError\">type ConstraintViolationError</a></li>\n<li> <a href=\"#ConstraintViolationError.Error\">func (ConstraintViolationError) Error() string</a>\n</li>\n<li><a href=\"#ExtKeyUsage\">type ExtKeyUsage</a></li>\n<li><a href=\"#HostnameError\">type HostnameError</a></li>\n<li> <a href=\"#HostnameError.Error\">func (h HostnameError) Error() string</a>\n</li>\n<li><a href=\"#InsecureAlgorithmError\">type InsecureAlgorithmError</a></li>\n<li> <a href=\"#InsecureAlgorithmError.Error\">func (e InsecureAlgorithmError) Error() string</a>\n</li>\n<li><a href=\"#InvalidReason\">type InvalidReason</a></li>\n<li><a href=\"#KeyUsage\">type KeyUsage</a></li>\n<li><a href=\"#PEMCipher\">type PEMCipher</a></li>\n<li><a href=\"#PublicKeyAlgorithm\">type PublicKeyAlgorithm</a></li>\n<li><a href=\"#SignatureAlgorithm\">type SignatureAlgorithm</a></li>\n<li> <a href=\"#SignatureAlgorithm.String\">func (algo SignatureAlgorithm) String() string</a>\n</li>\n<li><a href=\"#SystemRootsError\">type SystemRootsError</a></li>\n<li> <a href=\"#SystemRootsError.Error\">func (se SystemRootsError) Error() string</a>\n</li>\n<li><a href=\"#UnhandledCriticalExtension\">type UnhandledCriticalExtension</a></li>\n<li> <a href=\"#UnhandledCriticalExtension.Error\">func (h UnhandledCriticalExtension) Error() string</a>\n</li>\n<li><a href=\"#UnknownAuthorityError\">type UnknownAuthorityError</a></li>\n<li> <a href=\"#UnknownAuthorityError.Error\">func (e UnknownAuthorityError) Error() string</a>\n</li>\n<li><a href=\"#VerifyOptions\">type VerifyOptions</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Certificate_Verify\">Certificate.Verify</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ParsePKIXPublicKey\">ParsePKIXPublicKey</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/x509/cert_pool.go\">cert_pool.go</a> <a href=\"https://golang.org/src/crypto/x509/pem_decrypt.go\">pem_decrypt.go</a> <a href=\"https://golang.org/src/crypto/x509/pkcs1.go\">pkcs1.go</a> <a href=\"https://golang.org/src/crypto/x509/pkcs8.go\">pkcs8.go</a> <a href=\"https://golang.org/src/crypto/x509/root.go\">root.go</a> <a href=\"https://golang.org/src/crypto/x509/root_linux.go\">root_linux.go</a> <a href=\"https://golang.org/src/crypto/x509/root_unix.go\">root_unix.go</a> <a href=\"https://golang.org/src/crypto/x509/sec1.go\">sec1.go</a> <a href=\"https://golang.org/src/crypto/x509/verify.go\">verify.go</a> <a href=\"https://golang.org/src/crypto/x509/x509.go\">x509.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrUnsupportedAlgorithm = errors.New(\"x509: cannot verify signature: algorithm unimplemented\")</pre> <p> ErrUnsupportedAlgorithm results from attempting to perform an operation that involves algorithms that are not currently implemented. </p> <pre data-language=\"go\">var IncorrectPasswordError = errors.New(\"x509: decryption password incorrect\")</pre> <p> IncorrectPasswordError is returned when an incorrect password is detected. </p> <h2 id=\"CreateCertificate\">func CreateCertificate  </h2> <pre data-language=\"go\">func CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv interface{}) (cert []byte, err error)</pre> <p> CreateCertificate creates a new certificate based on a template. The following members of template are used: SerialNumber, Subject, NotBefore, NotAfter, KeyUsage, ExtKeyUsage, UnknownExtKeyUsage, BasicConstraintsValid, IsCA, MaxPathLen, SubjectKeyId, DNSNames, PermittedDNSDomainsCritical, PermittedDNSDomains, SignatureAlgorithm. </p> <p> The certificate is signed by parent. If parent is equal to template then the certificate is self-signed. The parameter pub is the public key of the signee and priv is the private key of the signer. </p> <p> The returned slice is the certificate in DER encoding. </p> <p> All keys types that are implemented via crypto.Signer are supported (This includes *rsa.PublicKey and *ecdsa.PublicKey.) </p> <h2 id=\"CreateCertificateRequest\">func CreateCertificateRequest  </h2> <pre data-language=\"go\">func CreateCertificateRequest(rand io.Reader, template *CertificateRequest, priv interface{}) (csr []byte, err error)</pre> <p> CreateCertificateRequest creates a new certificate request based on a template. The following members of template are used: Subject, Attributes, SignatureAlgorithm, Extensions, DNSNames, EmailAddresses, and IPAddresses. The private key is the private key of the signer. </p> <p> The returned slice is the certificate request in DER encoding. </p> <p> All keys types that are implemented via crypto.Signer are supported (This includes *rsa.PublicKey and *ecdsa.PublicKey.) </p> <h2 id=\"DecryptPEMBlock\">func DecryptPEMBlock  </h2> <pre data-language=\"go\">func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error)</pre> <p> DecryptPEMBlock takes a password encrypted PEM block and the password used to encrypt it and returns a slice of decrypted DER encoded bytes. It inspects the DEK-Info header to determine the algorithm used for decryption. If no DEK-Info header is present, an error is returned. If an incorrect password is detected an IncorrectPasswordError is returned. Because of deficiencies in the encrypted-PEM format, it's not always possible to detect an incorrect password. In these cases no error will be returned but the decrypted DER bytes will be random noise. </p> <h2 id=\"EncryptPEMBlock\">func EncryptPEMBlock  </h2> <pre data-language=\"go\">func EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error)</pre> <p> EncryptPEMBlock returns a PEM block of the specified type holding the given DER-encoded data encrypted with the specified algorithm and password. </p> <h2 id=\"IsEncryptedPEMBlock\">func IsEncryptedPEMBlock  </h2> <pre data-language=\"go\">func IsEncryptedPEMBlock(b *pem.Block) bool</pre> <p> IsEncryptedPEMBlock returns if the PEM block is password encrypted. </p> <h2 id=\"MarshalECPrivateKey\">func MarshalECPrivateKey  </h2> <pre data-language=\"go\">func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)</pre> <p> MarshalECPrivateKey marshals an EC private key into ASN.1, DER format. </p> <h2 id=\"MarshalPKCS1PrivateKey\">func MarshalPKCS1PrivateKey  </h2> <pre data-language=\"go\">func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte</pre> <p> MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form. </p> <h2 id=\"MarshalPKIXPublicKey\">func MarshalPKIXPublicKey  </h2> <pre data-language=\"go\">func MarshalPKIXPublicKey(pub interface{}) ([]byte, error)</pre> <p> MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format. </p> <h2 id=\"ParseCRL\">func ParseCRL  </h2> <pre data-language=\"go\">func ParseCRL(crlBytes []byte) (*pkix.CertificateList, error)</pre> <p> ParseCRL parses a CRL from the given bytes. It's often the case that PEM encoded CRLs will appear where they should be DER encoded, so this function will transparently handle PEM encoding as long as there isn't any leading garbage. </p> <h2 id=\"ParseCertificates\">func ParseCertificates  </h2> <pre data-language=\"go\">func ParseCertificates(asn1Data []byte) ([]*Certificate, error)</pre> <p> ParseCertificates parses one or more certificates from the given ASN.1 DER data. The certificates must be concatenated with no intermediate padding. </p> <h2 id=\"ParseDERCRL\">func ParseDERCRL  </h2> <pre data-language=\"go\">func ParseDERCRL(derBytes []byte) (*pkix.CertificateList, error)</pre> <p> ParseDERCRL parses a DER encoded CRL from the given bytes. </p> <h2 id=\"ParseECPrivateKey\">func ParseECPrivateKey  </h2> <pre data-language=\"go\">func ParseECPrivateKey(der []byte) (*ecdsa.PrivateKey, error)</pre> <p> ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure. </p> <h2 id=\"ParsePKCS1PrivateKey\">func ParsePKCS1PrivateKey  </h2> <pre data-language=\"go\">func ParsePKCS1PrivateKey(der []byte) (*rsa.PrivateKey, error)</pre> <p> ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form. </p> <h2 id=\"ParsePKCS8PrivateKey\">func ParsePKCS8PrivateKey  </h2> <pre data-language=\"go\">func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error)</pre> <p> ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key. See RFC 5208. </p> <h2 id=\"ParsePKIXPublicKey\">func ParsePKIXPublicKey  </h2> <pre data-language=\"go\">func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error)</pre> <p> ParsePKIXPublicKey parses a DER encoded public key. These values are typically found in PEM blocks with \"BEGIN PUBLIC KEY\". </p> <p> Supported key types include RSA, DSA, and ECDSA. Unknown key types result in an error. </p> <p> On success, pub will be of type *rsa.PublicKey, *dsa.PublicKey, or *ecdsa.PublicKey. </p> <div id=\"example_ParsePKIXPublicKey\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/dsa\"\n\t\"crypto/ecdsa\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tconst pubPEM = `\n-----BEGIN PUBLIC KEY-----\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlRuRnThUjU8/prwYxbty\nWPT9pURI3lbsKMiB6Fn/VHOKE13p4D8xgOCADpdRagdT6n4etr9atzDKUSvpMtR3\nCP5noNc97WiNCggBjVWhs7szEe8ugyqF23XwpHQ6uV1LKH50m92MbOWfCtjU9p/x\nqhNpQQ1AZhqNy5Gevap5k8XzRmjSldNAFZMY7Yv3Gi+nyCwGwpVtBUwhuLzgNFK/\nyDtw2WcWmUU7NuC8Q6MWvPebxVtCfVp/iQU6q60yyt6aGOBkhAX0LpKAEhKidixY\nnP9PNVBvxgu3XZ4P36gZV6+ummKdBVnc3NqwBLu5+CcdRdusmHPHd5pHf4/38Z3/\n6qU2a/fPvWzceVTEgZ47QjFMTCTmCwNt29cvi7zZeQzjtwQgn4ipN9NibRH/Ax/q\nTbIzHfrJ1xa2RteWSdFjwtxi9C20HUkjXSeI4YlzQMH0fPX6KCE7aVePTOnB69I/\na9/q96DiXZajwlpq3wFctrs1oXqBp5DVrCIj8hU2wNgB7LtQ1mCtsYz//heai0K9\nPhE4X6hiE0YmeAZjR0uHl8M/5aW9xCoJ72+12kKpWAa0SFRWLy6FejNYCYpkupVJ\nyecLk/4L1W0l6jQQZnWErXZYe0PNFcmwGXy1Rep83kfBRNKRy5tvocalLlwXLdUk\nAIU+2GKjyT3iMuzZxxFxPFMCAwEAAQ==\n-----END PUBLIC KEY-----`\n\n\tblock, _ := pem.Decode([]byte(pubPEM))\n\tif block == nil {\n\t\tpanic(\"failed to parse PEM block containing the public key\")\n\t}\n\n\tpub, err := x509.ParsePKIXPublicKey(block.Bytes)\n\tif err != nil {\n\t\tpanic(\"failed to parse DER encoded public key: \" + err.Error())\n\t}\n\n\tswitch pub := pub.(type) {\n\tcase *rsa.PublicKey:\n\t\tfmt.Println(\"pub is of type RSA:\", pub)\n\tcase *dsa.PublicKey:\n\t\tfmt.Println(\"pub is of type DSA:\", pub)\n\tcase *ecdsa.PublicKey:\n\t\tfmt.Println(\"pub is of type ECDSA:\", pub)\n\tdefault:\n\t\tpanic(\"unknown type of public key\")\n\t}\n}\n</pre> </div> </div> <h2 id=\"CertPool\">type CertPool  </h2> <pre data-language=\"go\">type CertPool struct {\n        // contains filtered or unexported fields\n}</pre> <p> CertPool is a set of certificates. </p> <h3 id=\"NewCertPool\">func <a href=\"https://golang.org/src/crypto/x509/cert_pool.go?s=430:458#L11\">NewCertPool</a>  </h3> <pre data-language=\"go\">func NewCertPool() *CertPool</pre> <p> NewCertPool returns a new, empty CertPool. </p> <h3 id=\"SystemCertPool\">func <a href=\"https://golang.org/src/crypto/x509/cert_pool.go?s=730:770#L22\">SystemCertPool</a>  </h3> <pre data-language=\"go\">func SystemCertPool() (*CertPool, error)</pre> <p> SystemCertPool returns a copy of the system cert pool. </p> <p> Any mutations to the returned pool are not written to disk and do not affect any other pool. </p> <h3 id=\"CertPool.AddCert\">func (*CertPool) <a href=\"https://golang.org/src/crypto/x509/cert_pool.go?s=1728:1773#L58\">AddCert</a>  </h3> <pre data-language=\"go\">func (s *CertPool) AddCert(cert *Certificate)</pre> <p> AddCert adds a certificate to a pool. </p> <h3 id=\"CertPool.AppendCertsFromPEM\">func (*CertPool) <a href=\"https://golang.org/src/crypto/x509/cert_pool.go?s=2558:2622#L87\">AppendCertsFromPEM</a>  </h3> <pre data-language=\"go\">func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool)</pre> <p> AppendCertsFromPEM attempts to parse a series of PEM encoded certificates. It appends any certificates found to s and reports whether any certificates were successfully parsed. </p> <p> On many Linux systems, /etc/ssl/cert.pem will contain the system wide set of root CAs in a format suitable for this function. </p> <h3 id=\"CertPool.Subjects\">func (*CertPool) <a href=\"https://golang.org/src/crypto/x509/cert_pool.go?s=3049:3087#L112\">Subjects</a>  </h3> <pre data-language=\"go\">func (s *CertPool) Subjects() [][]byte</pre> <p> Subjects returns a list of the DER-encoded subjects of all of the certificates in the pool. </p> <h2 id=\"Certificate\">type Certificate  </h2> <pre data-language=\"go\">type Certificate struct {\n        Raw                     []byte // Complete ASN.1 DER content (certificate, signature algorithm and signature).\n        RawTBSCertificate       []byte // Certificate part of raw ASN.1 DER content.\n        RawSubjectPublicKeyInfo []byte // DER encoded SubjectPublicKeyInfo.\n        RawSubject              []byte // DER encoded Subject\n        RawIssuer               []byte // DER encoded Issuer\n\n        Signature          []byte\n        SignatureAlgorithm SignatureAlgorithm\n\n        PublicKeyAlgorithm PublicKeyAlgorithm\n        PublicKey          interface{}\n\n        Version             int\n        SerialNumber        *big.Int\n        Issuer              pkix.Name\n        Subject             pkix.Name\n        NotBefore, NotAfter time.Time // Validity bounds.\n        KeyUsage            KeyUsage\n\n        // Extensions contains raw X.509 extensions. When parsing certificates,\n        // this can be used to extract non-critical extensions that are not\n        // parsed by this package. When marshaling certificates, the Extensions\n        // field is ignored, see ExtraExtensions.\n        Extensions []pkix.Extension\n\n        // ExtraExtensions contains extensions to be copied, raw, into any\n        // marshaled certificates. Values override any extensions that would\n        // otherwise be produced based on the other fields. The ExtraExtensions\n        // field is not populated when parsing certificates, see Extensions.\n        ExtraExtensions []pkix.Extension\n\n        // UnhandledCriticalExtensions contains a list of extension IDs that\n        // were not (fully) processed when parsing. Verify will fail if this\n        // slice is non-empty, unless verification is delegated to an OS\n        // library which understands all the critical extensions.\n        //\n        // Users can access these extensions using Extensions and can remove\n        // elements from this slice if they believe that they have been\n        // handled.\n        UnhandledCriticalExtensions []asn1.ObjectIdentifier\n\n        ExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.\n        UnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package.\n\n        BasicConstraintsValid bool // if true then the next two fields are valid.\n        IsCA                  bool\n        MaxPathLen            int\n        // MaxPathLenZero indicates that BasicConstraintsValid==true and\n        // MaxPathLen==0 should be interpreted as an actual maximum path length\n        // of zero. Otherwise, that combination is interpreted as MaxPathLen\n        // not being set.\n        MaxPathLenZero bool\n\n        SubjectKeyId   []byte\n        AuthorityKeyId []byte\n\n        // RFC 5280, 4.2.2.1 (Authority Information Access)\n        OCSPServer            []string\n        IssuingCertificateURL []string\n\n        // Subject Alternate Name values\n        DNSNames       []string\n        EmailAddresses []string\n        IPAddresses    []net.IP\n\n        // Name constraints\n        PermittedDNSDomainsCritical bool // if true then the name constraints are marked critical.\n        PermittedDNSDomains         []string\n\n        // CRL Distribution Points\n        CRLDistributionPoints []string\n\n        PolicyIdentifiers []asn1.ObjectIdentifier\n}</pre> <p> A Certificate represents an X.509 certificate. </p> <h3 id=\"ParseCertificate\">func <a href=\"https://golang.org/src/crypto/x509/x509.go?s=38458:38518#L1181\">ParseCertificate</a>  </h3> <pre data-language=\"go\">func ParseCertificate(asn1Data []byte) (*Certificate, error)</pre> <p> ParseCertificate parses a single certificate from the given ASN.1 DER data. </p> <h3 id=\"Certificate.CheckCRLSignature\">func (*Certificate) <a href=\"https://golang.org/src/crypto/x509/x509.go?s=24869:24941#L730\">CheckCRLSignature</a>  </h3> <pre data-language=\"go\">func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) error</pre> <p> CheckCRLSignature checks that the signature in crl is from c. </p> <h3 id=\"Certificate.CheckSignature\">func (*Certificate) <a href=\"https://golang.org/src/crypto/x509/x509.go?s=22717:22810#L662\">CheckSignature</a>  </h3> <pre data-language=\"go\">func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) error</pre> <p> CheckSignature verifies that signature is a valid signature over signed from c's public key. </p> <h3 id=\"Certificate.CheckSignatureFrom\">func (*Certificate) <a href=\"https://golang.org/src/crypto/x509/x509.go?s=21655:21722#L634\">CheckSignatureFrom</a>  </h3> <pre data-language=\"go\">func (c *Certificate) CheckSignatureFrom(parent *Certificate) error</pre> <p> CheckSignatureFrom verifies that the signature on c is a valid signature from parent. </p> <h3 id=\"Certificate.CreateCRL\">func (*Certificate) <a href=\"https://golang.org/src/crypto/x509/x509.go?s=52634:52791#L1670\">CreateCRL</a>  </h3> <pre data-language=\"go\">func (c *Certificate) CreateCRL(rand io.Reader, priv interface{}, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)</pre> <p> CreateCRL returns a DER encoded CRL, signed by this Certificate, that contains the given list of revoked certificates. </p> <h3 id=\"Certificate.Equal\">func (*Certificate) <a href=\"https://golang.org/src/crypto/x509/x509.go?s=19183:19235#L579\">Equal</a>  </h3> <pre data-language=\"go\">func (c *Certificate) Equal(other *Certificate) bool</pre> <h3 id=\"Certificate.Verify\">func (*Certificate) <a href=\"https://golang.org/src/crypto/x509/verify.go?s=7402:7487#L213\">Verify</a>  </h3> <pre data-language=\"go\">func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error)</pre> <p> Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots. </p> <p> If opts.Roots is nil and system roots are unavailable the returned error will be of type SystemRootsError. </p> <p> WARNING: this doesn't do any revocation checking. </p> <div id=\"example_Certificate_Verify\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n)\n\nfunc main() {\n\t// Verifying with a custom list of root certificates.\n\n\tconst rootPEM = `\n-----BEGIN CERTIFICATE-----\nMIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT\nMRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i\nYWwgQ0EwHhcNMTMwNDA1MTUxNTU1WhcNMTUwNDA0MTUxNTU1WjBJMQswCQYDVQQG\nEwJVUzETMBEGA1UEChMKR29vZ2xlIEluYzElMCMGA1UEAxMcR29vZ2xlIEludGVy\nbmV0IEF1dGhvcml0eSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\nAJwqBHdc2FCROgajguDYUEi8iT/xGXAaiEZ+4I/F8YnOIe5a/mENtzJEiaB0C1NP\nVaTOgmKV7utZX8bhBYASxF6UP7xbSDj0U/ck5vuR6RXEz/RTDfRK/J9U3n2+oGtv\nh8DQUB8oMANA2ghzUWx//zo8pzcGjr1LEQTrfSTe5vn8MXH7lNVg8y5Kr0LSy+rE\nahqyzFPdFUuLH8gZYR/Nnag+YyuENWllhMgZxUYi+FOVvuOAShDGKuy6lyARxzmZ\nEASg8GF6lSWMTlJ14rbtCMoU/M4iarNOz0YDl5cDfsCx3nuvRTPPuj5xt970JSXC\nDTWJnZ37DhF5iR43xa+OcmkCAwEAAaOB+zCB+DAfBgNVHSMEGDAWgBTAephojYn7\nqwVkDBF9qn1luMrMTjAdBgNVHQ4EFgQUSt0GFhu89mi1dvWBtrtiGrpagS8wEgYD\nVR0TAQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAQYwOgYDVR0fBDMwMTAvoC2g\nK4YpaHR0cDovL2NybC5nZW90cnVzdC5jb20vY3Jscy9ndGdsb2JhbC5jcmwwPQYI\nKwYBBQUHAQEEMTAvMC0GCCsGAQUFBzABhiFodHRwOi8vZ3RnbG9iYWwtb2NzcC5n\nZW90cnVzdC5jb20wFwYDVR0gBBAwDjAMBgorBgEEAdZ5AgUBMA0GCSqGSIb3DQEB\nBQUAA4IBAQA21waAESetKhSbOHezI6B1WLuxfoNCunLaHtiONgaX4PCVOzf9G0JY\n/iLIa704XtE7JW4S615ndkZAkNoUyHgN7ZVm2o6Gb4ChulYylYbc3GrKBIxbf/a/\nzG+FA1jDaFETzf3I93k9mTXwVqO94FntT0QJo544evZG0R0SnU++0ED8Vf4GXjza\nHFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto\nWHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6\nyuGnBXj8ytqU0CwIPX4WecigUCAkVDNx\n-----END CERTIFICATE-----`\n\n\tconst certPEM = `\n-----BEGIN CERTIFICATE-----\nMIIDujCCAqKgAwIBAgIIE31FZVaPXTUwDQYJKoZIhvcNAQEFBQAwSTELMAkGA1UE\nBhMCVVMxEzARBgNVBAoTCkdvb2dsZSBJbmMxJTAjBgNVBAMTHEdvb2dsZSBJbnRl\ncm5ldCBBdXRob3JpdHkgRzIwHhcNMTQwMTI5MTMyNzQzWhcNMTQwNTI5MDAwMDAw\nWjBpMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwN\nTW91bnRhaW4gVmlldzETMBEGA1UECgwKR29vZ2xlIEluYzEYMBYGA1UEAwwPbWFp\nbC5nb29nbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEfRrObuSW5T7q\n5CnSEqefEmtH4CCv6+5EckuriNr1CjfVvqzwfAhopXkLrq45EQm8vkmf7W96XJhC\n7ZM0dYi1/qOCAU8wggFLMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAa\nBgNVHREEEzARgg9tYWlsLmdvb2dsZS5jb20wCwYDVR0PBAQDAgeAMGgGCCsGAQUF\nBwEBBFwwWjArBggrBgEFBQcwAoYfaHR0cDovL3BraS5nb29nbGUuY29tL0dJQUcy\nLmNydDArBggrBgEFBQcwAYYfaHR0cDovL2NsaWVudHMxLmdvb2dsZS5jb20vb2Nz\ncDAdBgNVHQ4EFgQUiJxtimAuTfwb+aUtBn5UYKreKvMwDAYDVR0TAQH/BAIwADAf\nBgNVHSMEGDAWgBRK3QYWG7z2aLV29YG2u2IaulqBLzAXBgNVHSAEEDAOMAwGCisG\nAQQB1nkCBQEwMAYDVR0fBCkwJzAloCOgIYYfaHR0cDovL3BraS5nb29nbGUuY29t\nL0dJQUcyLmNybDANBgkqhkiG9w0BAQUFAAOCAQEAH6RYHxHdcGpMpFE3oxDoFnP+\ngtuBCHan2yE2GRbJ2Cw8Lw0MmuKqHlf9RSeYfd3BXeKkj1qO6TVKwCh+0HdZk283\nTZZyzmEOyclm3UGFYe82P/iDFt+CeQ3NpmBg+GoaVCuWAARJN/KfglbLyyYygcQq\n0SgeDh8dRKUiaW3HQSoYvTvdTuqzwK4CXsr3b5/dAOY8uMuG/IAR3FgwTbZ1dtoW\nRvOTa8hYiU6A475WuZKyEHcwnGYe57u2I2KbMgcKjPniocj4QzgYsVAVKW3IwaOh\nyE+vPxsiUkvQHdO2fojCkY8jg70jxM+gu59tPDNbw3Uh/2Ij310FgTHsnGQMyA==\n-----END CERTIFICATE-----`\n\n\t// First, create the set of root certificates. For this example we only\n\t// have one. It's also possible to omit this in order to use the\n\t// default root set of the current operating system.\n\troots := x509.NewCertPool()\n\tok := roots.AppendCertsFromPEM([]byte(rootPEM))\n\tif !ok {\n\t\tpanic(\"failed to parse root certificate\")\n\t}\n\n\tblock, _ := pem.Decode([]byte(certPEM))\n\tif block == nil {\n\t\tpanic(\"failed to parse certificate PEM\")\n\t}\n\tcert, err := x509.ParseCertificate(block.Bytes)\n\tif err != nil {\n\t\tpanic(\"failed to parse certificate: \" + err.Error())\n\t}\n\n\topts := x509.VerifyOptions{\n\t\tDNSName: \"mail.google.com\",\n\t\tRoots:   roots,\n\t}\n\n\tif _, err := cert.Verify(opts); err != nil {\n\t\tpanic(\"failed to verify certificate: \" + err.Error())\n\t}\n}\n</pre> </div> </div> <h3 id=\"Certificate.VerifyHostname\">func (*Certificate) <a href=\"https://golang.org/src/crypto/x509/verify.go?s=12104:12156#L404\">VerifyHostname</a>  </h3> <pre data-language=\"go\">func (c *Certificate) VerifyHostname(h string) error</pre> <p> VerifyHostname returns nil if c is a valid certificate for the named host. Otherwise it returns an error describing the mismatch. </p> <h2 id=\"CertificateInvalidError\">type CertificateInvalidError  </h2> <pre data-language=\"go\">type CertificateInvalidError struct {\n        Cert   *Certificate\n        Reason InvalidReason\n}</pre> <p> CertificateInvalidError results when an odd error occurs. Users of this library probably want to handle all these errors uniformly. </p> <h3 id=\"CertificateInvalidError.Error\">func (CertificateInvalidError) <a href=\"https://golang.org/src/crypto/x509/verify.go?s=1214:1261#L35\">Error</a>  </h3> <pre data-language=\"go\">func (e CertificateInvalidError) Error() string</pre> <h2 id=\"CertificateRequest\">type CertificateRequest  </h2> <pre data-language=\"go\">type CertificateRequest struct {\n        Raw                      []byte // Complete ASN.1 DER content (CSR, signature algorithm and signature).\n        RawTBSCertificateRequest []byte // Certificate request info part of raw ASN.1 DER content.\n        RawSubjectPublicKeyInfo  []byte // DER encoded SubjectPublicKeyInfo.\n        RawSubject               []byte // DER encoded Subject.\n\n        Version            int\n        Signature          []byte\n        SignatureAlgorithm SignatureAlgorithm\n\n        PublicKeyAlgorithm PublicKeyAlgorithm\n        PublicKey          interface{}\n\n        Subject pkix.Name\n\n        // Attributes is the dried husk of a bug and shouldn't be used.\n        Attributes []pkix.AttributeTypeAndValueSET\n\n        // Extensions contains raw X.509 extensions. When parsing CSRs, this\n        // can be used to extract extensions that are not parsed by this\n        // package.\n        Extensions []pkix.Extension\n\n        // ExtraExtensions contains extensions to be copied, raw, into any\n        // marshaled CSR. Values override any extensions that would otherwise\n        // be produced based on the other fields but are overridden by any\n        // extensions specified in Attributes.\n        //\n        // The ExtraExtensions field is not populated when parsing CSRs, see\n        // Extensions.\n        ExtraExtensions []pkix.Extension\n\n        // Subject Alternate Name values.\n        DNSNames       []string\n        EmailAddresses []string\n        IPAddresses    []net.IP\n}</pre> <p> CertificateRequest represents a PKCS #10, certificate signature request. </p> <h3 id=\"ParseCertificateRequest\">func <a href=\"https://golang.org/src/crypto/x509/x509.go?s=62534:62608#L2007\">ParseCertificateRequest</a>  </h3> <pre data-language=\"go\">func ParseCertificateRequest(asn1Data []byte) (*CertificateRequest, error)</pre> <p> ParseCertificateRequest parses a single certificate request from the given ASN.1 DER data. </p> <h3 id=\"CertificateRequest.CheckSignature\">func (*CertificateRequest) <a href=\"https://golang.org/src/crypto/x509/x509.go?s=64306:64357#L2068\">CheckSignature</a>  </h3> <pre data-language=\"go\">func (c *CertificateRequest) CheckSignature() error</pre> <p> CheckSignature reports whether the signature on c is valid. </p> <h2 id=\"ConstraintViolationError\">type ConstraintViolationError  </h2> <pre data-language=\"go\">type ConstraintViolationError struct{}</pre> <p> ConstraintViolationError results when a requested usage is not permitted by a certificate. For example: checking a signature when the public key isn't a certificate signing key. </p> <h3 id=\"ConstraintViolationError.Error\">func (ConstraintViolationError) <a href=\"https://golang.org/src/crypto/x509/x509.go?s=19040:19086#L575\">Error</a>  </h3> <pre data-language=\"go\">func (ConstraintViolationError) Error() string</pre> <h2 id=\"ExtKeyUsage\">type ExtKeyUsage  </h2> <pre data-language=\"go\">type ExtKeyUsage int</pre> <p> ExtKeyUsage represents an extended set of actions that are valid for a given key. Each of the ExtKeyUsage* constants define a unique action. </p> <pre data-language=\"go\">const (\n        ExtKeyUsageAny ExtKeyUsage = iota\n        ExtKeyUsageServerAuth\n        ExtKeyUsageClientAuth\n        ExtKeyUsageCodeSigning\n        ExtKeyUsageEmailProtection\n        ExtKeyUsageIPSECEndSystem\n        ExtKeyUsageIPSECTunnel\n        ExtKeyUsageIPSECUser\n        ExtKeyUsageTimeStamping\n        ExtKeyUsageOCSPSigning\n        ExtKeyUsageMicrosoftServerGatedCrypto\n        ExtKeyUsageNetscapeServerGatedCrypto\n)</pre> <h2 id=\"HostnameError\">type HostnameError  </h2> <pre data-language=\"go\">type HostnameError struct {\n        Certificate *Certificate\n        Host        string\n}</pre> <p> HostnameError results when the set of authorized names doesn't match the requested name. </p> <h3 id=\"HostnameError.Error\">func (HostnameError) <a href=\"https://golang.org/src/crypto/x509/verify.go?s=1980:2017#L58\">Error</a>  </h3> <pre data-language=\"go\">func (h HostnameError) Error() string</pre> <h2 id=\"InsecureAlgorithmError\">type InsecureAlgorithmError  </h2> <pre data-language=\"go\">type InsecureAlgorithmError SignatureAlgorithm</pre> <p> An InsecureAlgorithmError </p> <h3 id=\"InsecureAlgorithmError.Error\">func (InsecureAlgorithmError) <a href=\"https://golang.org/src/crypto/x509/x509.go?s=18662:18708#L566\">Error</a>  </h3> <pre data-language=\"go\">func (e InsecureAlgorithmError) Error() string</pre> <h2 id=\"InvalidReason\">type InvalidReason  </h2> <pre data-language=\"go\">type InvalidReason int</pre> <pre data-language=\"go\">const (\n        // NotAuthorizedToSign results when a certificate is signed by another\n        // which isn't marked as a CA certificate.\n        NotAuthorizedToSign InvalidReason = iota\n        // Expired results when a certificate has expired, based on the time\n        // given in the VerifyOptions.\n        Expired\n        // CANotAuthorizedForThisName results when an intermediate or root\n        // certificate has a name constraint which doesn't include the name\n        // being checked.\n        CANotAuthorizedForThisName\n        // TooManyIntermediates results when a path length constraint is\n        // violated.\n        TooManyIntermediates\n        // IncompatibleUsage results when the certificate's key usage indicates\n        // that it may only be used for a different purpose.\n        IncompatibleUsage\n)</pre> <h2 id=\"KeyUsage\">type KeyUsage  </h2> <pre data-language=\"go\">type KeyUsage int</pre> <p> KeyUsage represents the set of actions that are valid for a given key. It's a bitmap of the KeyUsage* constants. </p> <pre data-language=\"go\">const (\n        KeyUsageDigitalSignature KeyUsage = 1 &lt;&lt; iota\n        KeyUsageContentCommitment\n        KeyUsageKeyEncipherment\n        KeyUsageDataEncipherment\n        KeyUsageKeyAgreement\n        KeyUsageCertSign\n        KeyUsageCRLSign\n        KeyUsageEncipherOnly\n        KeyUsageDecipherOnly\n)</pre> <h2 id=\"PEMCipher\">type PEMCipher  </h2> <pre data-language=\"go\">type PEMCipher int</pre> <pre data-language=\"go\">const (\n        PEMCipherDES PEMCipher\n        PEMCipher3DES\n        PEMCipherAES128\n        PEMCipherAES192\n        PEMCipherAES256\n)</pre> <p> Possible values for the EncryptPEMBlock encryption algorithm. </p> <h2 id=\"PublicKeyAlgorithm\">type PublicKeyAlgorithm  </h2> <pre data-language=\"go\">type PublicKeyAlgorithm int</pre> <pre data-language=\"go\">const (\n        UnknownPublicKeyAlgorithm PublicKeyAlgorithm = iota\n        RSA\n        DSA\n        ECDSA\n)</pre> <h2 id=\"SignatureAlgorithm\">type SignatureAlgorithm  </h2> <pre data-language=\"go\">type SignatureAlgorithm int</pre> <pre data-language=\"go\">const (\n        UnknownSignatureAlgorithm SignatureAlgorithm = iota\n        MD2WithRSA\n        MD5WithRSA\n        SHA1WithRSA\n        SHA256WithRSA\n        SHA384WithRSA\n        SHA512WithRSA\n        DSAWithSHA1\n        DSAWithSHA256\n        ECDSAWithSHA1\n        ECDSAWithSHA256\n        ECDSAWithSHA384\n        ECDSAWithSHA512\n)</pre> <h3 id=\"SignatureAlgorithm.String\">func (SignatureAlgorithm) <a href=\"https://golang.org/src/crypto/x509/x509.go?s=5100:5146#L189\">String</a>  </h3> <pre data-language=\"go\">func (algo SignatureAlgorithm) String() string</pre> <h2 id=\"SystemRootsError\">type SystemRootsError  </h2> <pre data-language=\"go\">type SystemRootsError struct {\n        Err error\n}</pre> <p> SystemRootsError results when we fail to load the system root certificates. </p> <h3 id=\"SystemRootsError.Error\">func (SystemRootsError) <a href=\"https://golang.org/src/crypto/x509/verify.go?s=3593:3634#L114\">Error</a>  </h3> <pre data-language=\"go\">func (se SystemRootsError) Error() string</pre> <h2 id=\"UnhandledCriticalExtension\">type UnhandledCriticalExtension  </h2> <pre data-language=\"go\">type UnhandledCriticalExtension struct{}</pre> <h3 id=\"UnhandledCriticalExtension.Error\">func (UnhandledCriticalExtension) <a href=\"https://golang.org/src/crypto/x509/x509.go?s=25146:25196#L737\">Error</a>  </h3> <pre data-language=\"go\">func (h UnhandledCriticalExtension) Error() string</pre> <h2 id=\"UnknownAuthorityError\">type UnknownAuthorityError  </h2> <pre data-language=\"go\">type UnknownAuthorityError struct {\n        // contains filtered or unexported fields\n}</pre> <p> UnknownAuthorityError results when the certificate issuer is unknown </p> <h3 id=\"UnknownAuthorityError.Error\">func (UnknownAuthorityError) <a href=\"https://golang.org/src/crypto/x509/verify.go?s=2964:3009#L94\">Error</a>  </h3> <pre data-language=\"go\">func (e UnknownAuthorityError) Error() string</pre> <h2 id=\"VerifyOptions\">type VerifyOptions  </h2> <pre data-language=\"go\">type VerifyOptions struct {\n        DNSName       string\n        Intermediates *CertPool\n        Roots         *CertPool // if nil, the system roots are used\n        CurrentTime   time.Time // if zero, the current time is used\n        // KeyUsage specifies which Extended Key Usage values are acceptable.\n        // An empty list means ExtKeyUsageServerAuth. Key usage is considered a\n        // constraint down the chain which mirrors Windows CryptoAPI behaviour,\n        // but not the spec. To accept any key usage, include ExtKeyUsageAny.\n        KeyUsages []ExtKeyUsage\n}</pre> <p> VerifyOptions contains parameters for Certificate.Verify. It's a structure because other PKIX verification APIs have ended up needing many options. </p> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"pkix/index\">pkix</a> </td> <td class=\"pkg-synopsis\"> Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/x509/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/x509/</a>\n  </p>\n</div>\n","go/format/index":"<h1>Package format</h1>     <ul id=\"short-nav\">\n<li><code>import \"go/format\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package format implements standard formatting of Go source. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Node\">func Node(dst io.Writer, fset *token.FileSet, node interface{}) error</a></li>\n<li><a href=\"#Source\">func Source(src []byte) ([]byte, error)</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/go/format/format.go\">format.go</a> <a href=\"https://golang.org/src/go/format/internal.go\">internal.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Node\">func Node  </h2> <pre data-language=\"go\">func Node(dst io.Writer, fset *token.FileSet, node interface{}) error</pre> <p> Node formats node in canonical gofmt style and writes the result to dst. </p> <p> The node type must be *ast.File, *printer.CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt. Node does not modify node. Imports are not sorted for nodes representing partial source files (i.e., if the node is not an *ast.File or a *printer.CommentedNode not wrapping an *ast.File). </p> <p> The function may return early (before the entire result is written) and return a formatting error, for instance due to an incorrect AST. </p> <h2 id=\"Source\">func Source  </h2> <pre data-language=\"go\">func Source(src []byte) ([]byte, error)</pre> <p> Source formats src in canonical gofmt style and returns the result or an (I/O or syntax) error. src is expected to be a syntactically correct Go source file, or a list of Go declarations or statements. </p> <p> If src is a partial source file, the leading and trailing space of src is applied to the result (such that it has the same leading and trailing space as src), and the result is indented by the same amount as the first line of src containing code. Imports are not sorted for partial source files. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/go/format/\" class=\"_attribution-link\">https://golang.org/pkg/go/format/</a>\n  </p>\n</div>\n","go/importer/index":"<h1>Package importer</h1>     <ul id=\"short-nav\">\n<li><code>import \"go/importer\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package importer provides access to export data importers. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Default\">func Default() types.Importer</a></li>\n<li><a href=\"#For\">func For(compiler string, lookup Lookup) types.Importer</a></li>\n<li><a href=\"#Lookup\">type Lookup</a></li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/go/importer/importer.go\">importer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Default\">func Default  </h2> <pre data-language=\"go\">func Default() types.Importer</pre> <p> Default returns an Importer for the compiler that built the running binary. If available, the result implements types.ImporterFrom. </p> <h2 id=\"For\">func For  </h2> <pre data-language=\"go\">func For(compiler string, lookup Lookup) types.Importer</pre> <p> For returns an Importer for the given compiler and lookup interface, or nil. Supported compilers are \"gc\", and \"gccgo\". If lookup is nil, the default package lookup mechanism for the given compiler is used. BUG(issue13847): For does not support non-nil lookup functions. </p> <h2 id=\"Lookup\">type Lookup  </h2> <pre data-language=\"go\">type Lookup func(path string) (io.ReadCloser, error)</pre> <p> A Lookup function returns a reader to access package data for a given import path, or an error if no matching package is found. </p> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/go/importer/importer.go?s=740:806#L13\" style=\"float: left;\">☞</a> <p> For does not support non-nil lookup functions. </p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/go/importer/\" class=\"_attribution-link\">https://golang.org/pkg/go/importer/</a>\n  </p>\n</div>\n","go/doc/index":"<h1>Package doc</h1>     <ul id=\"short-nav\">\n<li><code>import \"go/doc\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package doc extracts source code documentation from a Go AST. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Examples\">func Examples(files ...*ast.File) []*Example</a></li>\n<li><a href=\"#Synopsis\">func Synopsis(s string) string</a></li>\n<li><a href=\"#ToHTML\">func ToHTML(w io.Writer, text string, words map[string]string)</a></li>\n<li><a href=\"#ToText\">func ToText(w io.Writer, text string, indent, preIndent string, width int)</a></li>\n<li><a href=\"#Example\">type Example</a></li>\n<li><a href=\"#Filter\">type Filter</a></li>\n<li><a href=\"#Func\">type Func</a></li>\n<li><a href=\"#Mode\">type Mode</a></li>\n<li><a href=\"#Note\">type Note</a></li>\n<li><a href=\"#Package\">type Package</a></li>\n<li> <a href=\"#New\">func New(pkg *ast.Package, importPath string, mode Mode) *Package</a>\n</li>\n<li> <a href=\"#Package.Filter\">func (p *Package) Filter(f Filter)</a>\n</li>\n<li><a href=\"#Type\">type Type</a></li>\n<li><a href=\"#Value\">type Value</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/go/doc/comment.go\">comment.go</a> <a href=\"https://golang.org/src/go/doc/doc.go\">doc.go</a> <a href=\"https://golang.org/src/go/doc/example.go\">example.go</a> <a href=\"https://golang.org/src/go/doc/exports.go\">exports.go</a> <a href=\"https://golang.org/src/go/doc/filter.go\">filter.go</a> <a href=\"https://golang.org/src/go/doc/reader.go\">reader.go</a> <a href=\"https://golang.org/src/go/doc/synopsis.go\">synopsis.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var IllegalPrefixes = []string{\n        \"copyright\",\n        \"all rights\",\n        \"author\",\n}</pre> <h2 id=\"Examples\">func Examples  </h2> <pre data-language=\"go\">func Examples(files ...*ast.File) []*Example</pre> <p> Examples returns the examples found in the files, sorted by Name field. The Order fields record the order in which the examples were encountered. </p> <p> Playable Examples must be in a package whose name ends in \"_test\". An Example is \"playable\" (the Play field is non-nil) in either of these circumstances: </p> <pre data-language=\"go\">- The example function is self-contained: the function references only\n  identifiers from other packages (or predeclared identifiers, such as\n  \"int\") and the test file does not include a dot import.\n- The entire test file is the example: the file contains exactly one\n  example function, zero test or benchmark functions, and at least one\n  top-level function, type, variable, or constant declaration other\n  than the example function.\n</pre> <h2 id=\"Synopsis\">func Synopsis  </h2> <pre data-language=\"go\">func Synopsis(s string) string</pre> <p> Synopsis returns a cleaned version of the first sentence in s. That sentence ends after the first period followed by space and not preceded by exactly one uppercase letter. The result string has no \\n, \\r, or \\t characters and uses only single spaces between words. If s starts with any of the IllegalPrefixes, the result is the empty string. </p> <h2 id=\"ToHTML\">func ToHTML  </h2> <pre data-language=\"go\">func ToHTML(w io.Writer, text string, words map[string]string)</pre> <p> ToHTML converts comment text to formatted HTML. The comment was prepared by DocReader, so it is known not to have leading, trailing blank lines nor to have trailing spaces at the end of lines. The comment markers have already been removed. </p> <p> Each span of unindented non-blank lines is converted into a single paragraph. There is one exception to the rule: a span that consists of a single line, is followed by another paragraph span, begins with a capital letter, and contains no punctuation is formatted as a heading. </p> <p> A span of indented lines is converted into a &lt;pre&gt; block, with the common indent prefix removed. </p> <p> URLs in the comment text are converted into links; if the URL also appears in the words map, the link is taken from the map (if the corresponding map value is the empty string, the URL is not converted into a link). </p> <p> Go identifiers that appear in the words map are italicized; if the corresponding map value is not the empty string, it is considered a URL and the word is converted into a link. </p> <h2 id=\"ToText\">func ToText  </h2> <pre data-language=\"go\">func ToText(w io.Writer, text string, indent, preIndent string, width int)</pre> <p> ToText prepares comment text for presentation in textual output. It wraps paragraphs of text to width or fewer Unicode code points and then prefixes each line with the indent. In preformatted sections (such as program text), it prefixes each non-blank line with preIndent. </p> <h2 id=\"Example\">type Example  </h2> <pre data-language=\"go\">type Example struct {\n        Name        string // name of the item being exemplified\n        Doc         string // example function doc string\n        Code        ast.Node\n        Play        *ast.File // a whole program version of the example\n        Comments    []*ast.CommentGroup\n        Output      string // expected output\n        Unordered   bool\n        EmptyOutput bool // expect empty output\n        Order       int  // original source code order\n}</pre> <p> An Example represents an example function found in a source files. </p> <h2 id=\"Filter\">type Filter  </h2> <pre data-language=\"go\">type Filter func(string) bool</pre> <h2 id=\"Func\">type Func  </h2> <pre data-language=\"go\">type Func struct {\n        Doc  string\n        Name string\n        Decl *ast.FuncDecl\n\n        // methods\n        // (for functions, these fields have the respective zero value)\n        Recv  string // actual   receiver \"T\" or \"*T\"\n        Orig  string // original receiver \"T\" or \"*T\"\n        Level int    // embedding level; 0 means not embedded\n}</pre> <p> Func is the documentation for a func declaration. </p> <h2 id=\"Mode\">type Mode  </h2> <pre data-language=\"go\">type Mode int</pre> <p> Mode values control the operation of New. </p> <pre data-language=\"go\">const (\n        // extract documentation for all package-level declarations,\n        // not just exported ones\n        AllDecls Mode = 1 &lt;&lt; iota\n\n        // show all embedded methods, not just the ones of\n        // invisible (unexported) anonymous fields\n        AllMethods\n)</pre> <h2 id=\"Note\">type Note  </h2> <pre data-language=\"go\">type Note struct {\n        Pos, End token.Pos // position range of the comment containing the marker\n        UID      string    // uid found with the marker\n        Body     string    // note body text\n}</pre> <p> A Note represents a marked comment starting with \"MARKER(uid): note body\". Any note with a marker of 2 or more upper case [A-Z] letters and a uid of at least one character is recognized. The \":\" following the uid is optional. Notes are collected in the Package.Notes map indexed by the notes marker. </p> <h2 id=\"Package\">type Package  </h2> <pre data-language=\"go\">type Package struct {\n        Doc        string\n        Name       string\n        ImportPath string\n        Imports    []string\n        Filenames  []string\n        Notes      map[string][]*Note\n\n        // Deprecated: For backward compatibility Bugs is still populated,\n        // but all new code should use Notes instead.\n        Bugs []string\n\n        // declarations\n        Consts []*Value\n        Types  []*Type\n        Vars   []*Value\n        Funcs  []*Func\n}</pre> <p> Package is the documentation for an entire package. </p> <h3 id=\"New\">func <a href=\"https://golang.org/src/go/doc/doc.go?s=2620:2685#L84\">New</a>  </h3> <pre data-language=\"go\">func New(pkg *ast.Package, importPath string, mode Mode) *Package</pre> <p> New computes the package documentation for the given package AST. New takes ownership of the AST pkg and may edit or overwrite it. </p> <h3 id=\"Package.Filter\">func (*Package) <a href=\"https://golang.org/src/go/doc/filter.go?s=1932:1966#L89\">Filter</a>  </h3> <pre data-language=\"go\">func (p *Package) Filter(f Filter)</pre> <p> Filter eliminates documentation for names that don't pass through the filter f. TODO(gri): Recognize \"Type.Method\" as a name. </p> <h2 id=\"Type\">type Type  </h2> <pre data-language=\"go\">type Type struct {\n        Doc  string\n        Name string\n        Decl *ast.GenDecl\n\n        // associated declarations\n        Consts  []*Value // sorted list of constants of (mostly) this type\n        Vars    []*Value // sorted list of variables of (mostly) this type\n        Funcs   []*Func  // sorted list of functions returning this type\n        Methods []*Func  // sorted list of methods (including embedded ones) of this type\n}</pre> <p> Type is the documentation for a type declaration. </p> <h2 id=\"Value\">type Value  </h2> <pre data-language=\"go\">type Value struct {\n        Doc   string\n        Names []string // var or const names in declaration order\n        Decl  *ast.GenDecl\n        // contains filtered or unexported fields\n}</pre> <p> Value is the documentation for a (possibly grouped) var or const declaration. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/go/doc/\" class=\"_attribution-link\">https://golang.org/pkg/go/doc/</a>\n  </p>\n</div>\n","encoding/csv/index":"<h1>Package csv</h1>     <ul id=\"short-nav\">\n<li><code>import \"encoding/csv\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package csv reads and writes comma-separated values (CSV) files. There are many kinds of CSV files; this package supports the format described in RFC 4180. </p> <p> A csv file contains zero or more records of one or more fields per record. Each record is separated by the newline character. The final record may optionally be followed by a newline character. </p> <pre data-language=\"go\">field1,field2,field3\n</pre> <p> White space is considered part of a field. </p> <p> Carriage returns before newline characters are silently removed. </p> <p> Blank lines are ignored. A line with only whitespace characters (excluding the ending newline character) is not considered a blank line. </p> <p> Fields which start and stop with the quote character \" are called quoted-fields. The beginning and ending quote are not part of the field. </p> <p> The source: </p> <pre data-language=\"go\">normal string,\"quoted-field\"\n</pre> <p> results in the fields </p> <pre data-language=\"go\">{`normal string`, `quoted-field`}\n</pre> <p> Within a quoted-field a quote character followed by a second quote character is considered a single quote. </p> <pre data-language=\"go\">\"the \"\"word\"\" is true\",\"a \"\"quoted-field\"\"\"\n</pre> <p> results in </p> <pre data-language=\"go\">{`the \"word\" is true`, `a \"quoted-field\"`}\n</pre> <p> Newlines and commas may be included in a quoted-field </p> <pre data-language=\"go\">\"Multi-line\nfield\",\"comma is ,\"\n</pre> <p> results in </p> <pre data-language=\"go\">{`Multi-line\nfield`, `comma is ,`}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#ParseError\">type ParseError</a></li>\n<li> <a href=\"#ParseError.Error\">func (e *ParseError) Error() string</a>\n</li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li> <a href=\"#NewReader\">func NewReader(r io.Reader) *Reader</a>\n</li>\n<li> <a href=\"#Reader.Read\">func (r *Reader) Read() (record []string, err error)</a>\n</li>\n<li> <a href=\"#Reader.ReadAll\">func (r *Reader) ReadAll() (records [][]string, err error)</a>\n</li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#NewWriter\">func NewWriter(w io.Writer) *Writer</a>\n</li>\n<li> <a href=\"#Writer.Error\">func (w *Writer) Error() error</a>\n</li>\n<li> <a href=\"#Writer.Flush\">func (w *Writer) Flush()</a>\n</li>\n<li> <a href=\"#Writer.Write\">func (w *Writer) Write(record []string) error</a>\n</li>\n<li> <a href=\"#Writer.WriteAll\">func (w *Writer) WriteAll(records [][]string) error</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Reader\">Reader</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Reader_ReadAll\">Reader.ReadAll</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Reader_options\">Reader (Options)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Writer\">Writer</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Writer_WriteAll\">Writer.WriteAll</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/encoding/csv/reader.go\">reader.go</a> <a href=\"https://golang.org/src/encoding/csv/writer.go\">writer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        ErrTrailingComma = errors.New(\"extra delimiter at end of line\") // no longer used\n        ErrBareQuote     = errors.New(\"bare \\\" in non-quoted-field\")\n        ErrQuote         = errors.New(\"extraneous \\\" in field\")\n        ErrFieldCount    = errors.New(\"wrong number of fields in line\")\n)</pre> <p> These are the errors that can be returned in ParseError.Error </p> <h2 id=\"ParseError\">type ParseError  </h2> <pre data-language=\"go\">type ParseError struct {\n        Line   int   // Line where the error occurred\n        Column int   // Column (rune index) where the error occurred\n        Err    error // The actual error\n}</pre> <p> A ParseError is returned for parsing errors. The first line is 1. The first column is 0. </p> <h3 id=\"ParseError.Error\">func (*ParseError) <a href=\"https://golang.org/src/encoding/csv/reader.go?s=1834:1869#L61\">Error</a>  </h3> <pre data-language=\"go\">func (e *ParseError) Error() string</pre> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader struct {\n        // Comma is the field delimiter.\n        // It is set to comma (',') by NewReader.\n        Comma rune\n        // Comment, if not 0, is the comment character. Lines beginning with the\n        // Comment character without preceding whitespace are ignored.\n        // With leading whitespace the Comment character becomes part of the\n        // field, even if TrimLeadingSpace is true.\n        Comment rune\n        // FieldsPerRecord is the number of expected fields per record.\n        // If FieldsPerRecord is positive, Read requires each record to\n        // have the given number of fields. If FieldsPerRecord is 0, Read sets it to\n        // the number of fields in the first record, so that future records must\n        // have the same field count. If FieldsPerRecord is negative, no check is\n        // made and records may have a variable number of fields.\n        FieldsPerRecord int\n        // If LazyQuotes is true, a quote may appear in an unquoted field and a\n        // non-doubled quote may appear in a quoted field.\n        LazyQuotes    bool\n        TrailingComma bool // ignored; here for backwards compatibility\n        // If TrimLeadingSpace is true, leading white space in a field is ignored.\n        // This is done even if the field delimiter, Comma, is white space.\n        TrimLeadingSpace bool\n        // contains filtered or unexported fields\n}</pre> <p> A Reader reads records from a CSV-encoded file. </p> <p> As returned by NewReader, a Reader expects input conforming to RFC 4180. The exported fields can be changed to customize the details before the first call to Read or ReadAll. </p> <div id=\"example_Reader\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tin := `first_name,last_name,username\n\"Rob\",\"Pike\",rob\nKen,Thompson,ken\n\"Robert\",\"Griesemer\",\"gri\"\n`\n\tr := csv.NewReader(strings.NewReader(in))\n\n\tfor {\n\t\trecord, err := r.Read()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tfmt.Println(record)\n\t}\n}\n</pre> </div> </div> <div id=\"example_Reader_options\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Options)</h2> <p>This example shows how csv.Reader can be configured to handle other types of CSV files. </p> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tin := `first_name;last_name;username\n\"Rob\";\"Pike\";rob\n# lines beginning with a # character are ignored\nKen;Thompson;ken\n\"Robert\";\"Griesemer\";\"gri\"\n`\n\tr := csv.NewReader(strings.NewReader(in))\n\tr.Comma = ';'\n\tr.Comment = '#'\n\n\trecords, err := r.ReadAll()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Print(records)\n}\n</pre> </div> </div> <h3 id=\"NewReader\">func <a href=\"https://golang.org/src/encoding/csv/reader.go?s=3847:3882#L111\">NewReader</a>  </h3> <pre data-language=\"go\">func NewReader(r io.Reader) *Reader</pre> <p> NewReader returns a new Reader that reads from r. </p> <h3 id=\"Reader.Read\">func (*Reader) <a href=\"https://golang.org/src/encoding/csv/reader.go?s=4231:4283#L129\">Read</a>  </h3> <pre data-language=\"go\">func (r *Reader) Read() (record []string, err error)</pre> <p> Read reads one record from r. The record is a slice of strings with each string representing one field. </p> <h3 id=\"Reader.ReadAll\">func (*Reader) <a href=\"https://golang.org/src/encoding/csv/reader.go?s=4916:4974#L156\">ReadAll</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadAll() (records [][]string, err error)</pre> <p> ReadAll reads all the remaining records from r. Each record is a slice of fields. A successful call returns err == nil, not err == io.EOF. Because ReadAll is defined to read until EOF, it does not treat end of file as an error to be reported. </p> <div id=\"example_Reader_ReadAll\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tin := `first_name,last_name,username\n\"Rob\",\"Pike\",rob\nKen,Thompson,ken\n\"Robert\",\"Griesemer\",\"gri\"\n`\n\tr := csv.NewReader(strings.NewReader(in))\n\n\trecords, err := r.ReadAll()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Print(records)\n}\n</pre> </div> </div> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer struct {\n        Comma   rune // Field delimiter (set to ',' by NewWriter)\n        UseCRLF bool // True to use \\r\\n as the line terminator\n        // contains filtered or unexported fields\n}</pre> <p> A Writer writes records to a CSV encoded file. </p> <p> As returned by NewWriter, a Writer writes records terminated by a newline and uses ',' as the field delimiter. The exported fields can be changed to customize the details before the first call to Write or WriteAll. </p> <p> Comma is the field delimiter. </p> <p> If UseCRLF is true, the Writer ends each record with \\r\\n instead of \\n. </p> <div id=\"example_Writer\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/csv\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\trecords := [][]string{\n\t\t{\"first_name\", \"last_name\", \"username\"},\n\t\t{\"Rob\", \"Pike\", \"rob\"},\n\t\t{\"Ken\", \"Thompson\", \"ken\"},\n\t\t{\"Robert\", \"Griesemer\", \"gri\"},\n\t}\n\n\tw := csv.NewWriter(os.Stdout)\n\n\tfor _, record := range records {\n\t\tif err := w.Write(record); err != nil {\n\t\t\tlog.Fatalln(\"error writing record to csv:\", err)\n\t\t}\n\t}\n\n\t// Write any buffered data to the underlying writer (standard output).\n\tw.Flush()\n\n\tif err := w.Error(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n</pre> </div> </div> <h3 id=\"NewWriter\">func <a href=\"https://golang.org/src/encoding/csv/writer.go?s=845:880#L21\">NewWriter</a>  </h3> <pre data-language=\"go\">func NewWriter(w io.Writer) *Writer</pre> <p> NewWriter returns a new Writer that writes to w. </p> <h3 id=\"Writer.Error\">func (*Writer) <a href=\"https://golang.org/src/encoding/csv/writer.go?s=2392:2422#L93\">Error</a>  </h3> <pre data-language=\"go\">func (w *Writer) Error() error</pre> <p> Error reports any error that has occurred during a previous Write or Flush. </p> <h3 id=\"Writer.Flush\">func (*Writer) <a href=\"https://golang.org/src/encoding/csv/writer.go?s=2270:2294#L88\">Flush</a>  </h3> <pre data-language=\"go\">func (w *Writer) Flush()</pre> <p> Flush writes any buffered data to the underlying io.Writer. To check if an error occurred during the Flush, call Error. </p> <h3 id=\"Writer.Write\">func (*Writer) <a href=\"https://golang.org/src/encoding/csv/writer.go?s=1093:1138#L30\">Write</a>  </h3> <pre data-language=\"go\">func (w *Writer) Write(record []string) error</pre> <p> Writer writes a single CSV record to w along with any necessary quoting. A record is a slice of strings with each string being one field. </p> <h3 id=\"Writer.WriteAll\">func (*Writer) <a href=\"https://golang.org/src/encoding/csv/writer.go?s=2545:2596#L99\">WriteAll</a>  </h3> <pre data-language=\"go\">func (w *Writer) WriteAll(records [][]string) error</pre> <p> WriteAll writes multiple CSV records to w using Write and then calls Flush. </p> <div id=\"example_Writer_WriteAll\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/csv\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\trecords := [][]string{\n\t\t{\"first_name\", \"last_name\", \"username\"},\n\t\t{\"Rob\", \"Pike\", \"rob\"},\n\t\t{\"Ken\", \"Thompson\", \"ken\"},\n\t\t{\"Robert\", \"Griesemer\", \"gri\"},\n\t}\n\n\tw := csv.NewWriter(os.Stdout)\n\tw.WriteAll(records) // calls Flush internally\n\n\tif err := w.Error(); err != nil {\n\t\tlog.Fatalln(\"error writing csv:\", err)\n\t}\n}\n</pre> </div> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/encoding/csv/\" class=\"_attribution-link\">https://golang.org/pkg/encoding/csv/</a>\n  </p>\n</div>\n","go/printer/index":"<h1>Package printer</h1>     <ul id=\"short-nav\">\n<li><code>import \"go/printer\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package printer implements printing of AST nodes. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Fprint\">func Fprint(output io.Writer, fset *token.FileSet, node interface{}) error</a></li>\n<li><a href=\"#CommentedNode\">type CommentedNode</a></li>\n<li><a href=\"#Config\">type Config</a></li>\n<li> <a href=\"#Config.Fprint\">func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{}) error</a>\n</li>\n<li><a href=\"#Mode\">type Mode</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Fprint\">Fprint</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/go/printer/nodes.go\">nodes.go</a> <a href=\"https://golang.org/src/go/printer/printer.go\">printer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Fprint\">func Fprint  </h2> <pre data-language=\"go\">func Fprint(output io.Writer, fset *token.FileSet, node interface{}) error</pre> <p> Fprint \"pretty-prints\" an AST node to output. It calls Config.Fprint with default settings. </p> <div id=\"example_Fprint\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// Parse source file and extract the AST without comments for\n    // this function, with position information referring to the\n    // file set fset.\n    funcAST, fset := parseFunc(\"example_test.go\", \"ExampleFprint\")\n\n    // Print the function body into buffer buf.\n    // The file set is provided to the printer so that it knows\n    // about the original source formatting and can add additional\n    // line breaks where they were present in the source.\n    var buf bytes.Buffer\n    printer.Fprint(&amp;buf, fset, funcAST.Body)\n\n    // Remove braces {} enclosing the function body, unindent,\n    // and trim leading and trailing white space.\n    s := buf.String()\n    s = s[1 : len(s)-1]\n    s = strings.TrimSpace(strings.Replace(s, \"\\n\\t\", \"\\n\", -1))\n\n    // Print the cleaned-up body text to stdout.\n    fmt.Println(s)\n\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">funcAST, fset := parseFunc(\"example_test.go\", \"ExampleFprint\")\n\nvar buf bytes.Buffer\nprinter.Fprint(&amp;buf, fset, funcAST.Body)\n\ns := buf.String()\ns = s[1 : len(s)-1]\ns = strings.TrimSpace(strings.Replace(s, \"\\n\\t\", \"\\n\", -1))\n\nfmt.Println(s)\n</pre> </div> </div> <h2 id=\"CommentedNode\">type CommentedNode  </h2> <pre data-language=\"go\">type CommentedNode struct {\n        Node     interface{} // *ast.File, or ast.Expr, ast.Decl, ast.Spec, or ast.Stmt\n        Comments []*ast.CommentGroup\n}</pre> <p> A CommentedNode bundles an AST node and corresponding comments. It may be provided as argument to any of the Fprint functions. </p> <h2 id=\"Config\">type Config  </h2> <pre data-language=\"go\">type Config struct {\n        Mode     Mode // default: 0\n        Tabwidth int  // default: 8\n        Indent   int  // default: 0 (all code is indented at least by this much)\n}</pre> <p> A Config node controls the output of Fprint. </p> <h3 id=\"Config.Fprint\">func (*Config) <a href=\"https://golang.org/src/go/printer/printer.go?s=37342:37430#L1279\">Fprint</a>  </h3> <pre data-language=\"go\">func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{}) error</pre> <p> Fprint \"pretty-prints\" an AST node to output for a given configuration cfg. Position information is interpreted relative to the file set fset. The node type must be *ast.File, *CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt. </p> <h2 id=\"Mode\">type Mode  </h2> <pre data-language=\"go\">type Mode uint</pre> <p> A Mode value is a set of flags (or 0). They control printing. </p> <pre data-language=\"go\">const (\n        RawFormat Mode = 1 &lt;&lt; iota // do not use a tabwriter; if set, UseSpaces is ignored\n        TabIndent                  // use tabs for indentation independent of UseSpaces\n        UseSpaces                  // use spaces instead of tabs for alignment\n        SourcePos                  // emit //line comments to preserve original source positions\n)</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/go/printer/\" class=\"_attribution-link\">https://golang.org/pkg/go/printer/</a>\n  </p>\n</div>\n","debug/dwarf/index":"<h1>Package dwarf</h1>     <ul id=\"short-nav\">\n<li><code>import \"debug/dwarf\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package dwarf provides access to DWARF debugging information loaded from executable files, as defined in the DWARF 2.0 Standard at <a href=\"http://dwarfstd.org/doc/dwarf-2.0.0.pdf\">http://dwarfstd.org/doc/dwarf-2.0.0.pdf</a> </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#AddrType\">type AddrType</a></li>\n<li><a href=\"#ArrayType\">type ArrayType</a></li>\n<li> <a href=\"#ArrayType.Size\">func (t *ArrayType) Size() int64</a>\n</li>\n<li> <a href=\"#ArrayType.String\">func (t *ArrayType) String() string</a>\n</li>\n<li><a href=\"#Attr\">type Attr</a></li>\n<li> <a href=\"#Attr.GoString\">func (a Attr) GoString() string</a>\n</li>\n<li> <a href=\"#Attr.String\">func (a Attr) String() string</a>\n</li>\n<li><a href=\"#BasicType\">type BasicType</a></li>\n<li> <a href=\"#BasicType.Basic\">func (b *BasicType) Basic() *BasicType</a>\n</li>\n<li> <a href=\"#BasicType.String\">func (t *BasicType) String() string</a>\n</li>\n<li><a href=\"#BoolType\">type BoolType</a></li>\n<li><a href=\"#CharType\">type CharType</a></li>\n<li><a href=\"#Class\">type Class</a></li>\n<li> <a href=\"#Class.GoString\">func (i Class) GoString() string</a>\n</li>\n<li> <a href=\"#Class.String\">func (i Class) String() string</a>\n</li>\n<li><a href=\"#CommonType\">type CommonType</a></li>\n<li> <a href=\"#CommonType.Common\">func (c *CommonType) Common() *CommonType</a>\n</li>\n<li> <a href=\"#CommonType.Size\">func (c *CommonType) Size() int64</a>\n</li>\n<li><a href=\"#ComplexType\">type ComplexType</a></li>\n<li><a href=\"#Data\">type Data</a></li>\n<li> <a href=\"#New\">func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Data, error)</a>\n</li>\n<li> <a href=\"#Data.AddTypes\">func (d *Data) AddTypes(name string, types []byte) error</a>\n</li>\n<li> <a href=\"#Data.LineReader\">func (d *Data) LineReader(cu *Entry) (*LineReader, error)</a>\n</li>\n<li> <a href=\"#Data.Ranges\">func (d *Data) Ranges(e *Entry) ([][2]uint64, error)</a>\n</li>\n<li> <a href=\"#Data.Reader\">func (d *Data) Reader() *Reader</a>\n</li>\n<li> <a href=\"#Data.Type\">func (d *Data) Type(off Offset) (Type, error)</a>\n</li>\n<li><a href=\"#DecodeError\">type DecodeError</a></li>\n<li> <a href=\"#DecodeError.Error\">func (e DecodeError) Error() string</a>\n</li>\n<li><a href=\"#DotDotDotType\">type DotDotDotType</a></li>\n<li> <a href=\"#DotDotDotType.String\">func (t *DotDotDotType) String() string</a>\n</li>\n<li><a href=\"#Entry\">type Entry</a></li>\n<li> <a href=\"#Entry.AttrField\">func (e *Entry) AttrField(a Attr) *Field</a>\n</li>\n<li> <a href=\"#Entry.Val\">func (e *Entry) Val(a Attr) interface{}</a>\n</li>\n<li><a href=\"#EnumType\">type EnumType</a></li>\n<li> <a href=\"#EnumType.String\">func (t *EnumType) String() string</a>\n</li>\n<li><a href=\"#EnumValue\">type EnumValue</a></li>\n<li><a href=\"#Field\">type Field</a></li>\n<li><a href=\"#FloatType\">type FloatType</a></li>\n<li><a href=\"#FuncType\">type FuncType</a></li>\n<li> <a href=\"#FuncType.String\">func (t *FuncType) String() string</a>\n</li>\n<li><a href=\"#IntType\">type IntType</a></li>\n<li><a href=\"#LineEntry\">type LineEntry</a></li>\n<li><a href=\"#LineFile\">type LineFile</a></li>\n<li><a href=\"#LineReader\">type LineReader</a></li>\n<li> <a href=\"#LineReader.Next\">func (r *LineReader) Next(entry *LineEntry) error</a>\n</li>\n<li> <a href=\"#LineReader.Reset\">func (r *LineReader) Reset()</a>\n</li>\n<li> <a href=\"#LineReader.Seek\">func (r *LineReader) Seek(pos LineReaderPos)</a>\n</li>\n<li> <a href=\"#LineReader.SeekPC\">func (r *LineReader) SeekPC(pc uint64, entry *LineEntry) error</a>\n</li>\n<li> <a href=\"#LineReader.Tell\">func (r *LineReader) Tell() LineReaderPos</a>\n</li>\n<li><a href=\"#LineReaderPos\">type LineReaderPos</a></li>\n<li><a href=\"#Offset\">type Offset</a></li>\n<li><a href=\"#PtrType\">type PtrType</a></li>\n<li> <a href=\"#PtrType.String\">func (t *PtrType) String() string</a>\n</li>\n<li><a href=\"#QualType\">type QualType</a></li>\n<li> <a href=\"#QualType.Size\">func (t *QualType) Size() int64</a>\n</li>\n<li> <a href=\"#QualType.String\">func (t *QualType) String() string</a>\n</li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li> <a href=\"#Reader.AddressSize\">func (r *Reader) AddressSize() int</a>\n</li>\n<li> <a href=\"#Reader.Next\">func (r *Reader) Next() (*Entry, error)</a>\n</li>\n<li> <a href=\"#Reader.Seek\">func (r *Reader) Seek(off Offset)</a>\n</li>\n<li> <a href=\"#Reader.SeekPC\">func (r *Reader) SeekPC(pc uint64) (*Entry, error)</a>\n</li>\n<li> <a href=\"#Reader.SkipChildren\">func (r *Reader) SkipChildren()</a>\n</li>\n<li><a href=\"#StructField\">type StructField</a></li>\n<li><a href=\"#StructType\">type StructType</a></li>\n<li> <a href=\"#StructType.Defn\">func (t *StructType) Defn() string</a>\n</li>\n<li> <a href=\"#StructType.String\">func (t *StructType) String() string</a>\n</li>\n<li><a href=\"#Tag\">type Tag</a></li>\n<li> <a href=\"#Tag.GoString\">func (t Tag) GoString() string</a>\n</li>\n<li> <a href=\"#Tag.String\">func (t Tag) String() string</a>\n</li>\n<li><a href=\"#Type\">type Type</a></li>\n<li><a href=\"#TypedefType\">type TypedefType</a></li>\n<li> <a href=\"#TypedefType.Size\">func (t *TypedefType) Size() int64</a>\n</li>\n<li> <a href=\"#TypedefType.String\">func (t *TypedefType) String() string</a>\n</li>\n<li><a href=\"#UcharType\">type UcharType</a></li>\n<li><a href=\"#UintType\">type UintType</a></li>\n<li><a href=\"#UnspecifiedType\">type UnspecifiedType</a></li>\n<li><a href=\"#VoidType\">type VoidType</a></li>\n<li> <a href=\"#VoidType.String\">func (t *VoidType) String() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/debug/dwarf/buf.go\">buf.go</a> <a href=\"https://golang.org/src/debug/dwarf/class_string.go\">class_string.go</a> <a href=\"https://golang.org/src/debug/dwarf/const.go\">const.go</a> <a href=\"https://golang.org/src/debug/dwarf/entry.go\">entry.go</a> <a href=\"https://golang.org/src/debug/dwarf/line.go\">line.go</a> <a href=\"https://golang.org/src/debug/dwarf/open.go\">open.go</a> <a href=\"https://golang.org/src/debug/dwarf/type.go\">type.go</a> <a href=\"https://golang.org/src/debug/dwarf/typeunit.go\">typeunit.go</a> <a href=\"https://golang.org/src/debug/dwarf/unit.go\">unit.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrUnknownPC = errors.New(\"ErrUnknownPC\")</pre> <p> ErrUnknownPC is the error returned by LineReader.ScanPC when the seek PC is not covered by any entry in the line table. </p> <h2 id=\"AddrType\">type AddrType  </h2> <pre data-language=\"go\">type AddrType struct {\n        BasicType\n}</pre> <p> An AddrType represents a machine address type. </p> <h2 id=\"ArrayType\">type ArrayType  </h2> <pre data-language=\"go\">type ArrayType struct {\n        CommonType\n        Type          Type\n        StrideBitSize int64 // if &gt; 0, number of bits to hold each element\n        Count         int64 // if == -1, an incomplete array, like char x[].\n}</pre> <p> An ArrayType represents a fixed size array type. </p> <h3 id=\"ArrayType.Size\">func (*ArrayType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=2726:2758#L111\">Size</a>  </h3> <pre data-language=\"go\">func (t *ArrayType) Size() int64</pre> <h3 id=\"ArrayType.String\">func (*ArrayType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=2616:2651#L107\">String</a>  </h3> <pre data-language=\"go\">func (t *ArrayType) String() string</pre> <h2 id=\"Attr\">type Attr  </h2> <pre data-language=\"go\">type Attr uint32</pre> <p> An Attr identifies the attribute type in a DWARF Entry's Field. </p> <pre data-language=\"go\">const (\n        AttrSibling        Attr = 0x01\n        AttrLocation       Attr = 0x02\n        AttrName           Attr = 0x03\n        AttrOrdering       Attr = 0x09\n        AttrByteSize       Attr = 0x0B\n        AttrBitOffset      Attr = 0x0C\n        AttrBitSize        Attr = 0x0D\n        AttrStmtList       Attr = 0x10\n        AttrLowpc          Attr = 0x11\n        AttrHighpc         Attr = 0x12\n        AttrLanguage       Attr = 0x13\n        AttrDiscr          Attr = 0x15\n        AttrDiscrValue     Attr = 0x16\n        AttrVisibility     Attr = 0x17\n        AttrImport         Attr = 0x18\n        AttrStringLength   Attr = 0x19\n        AttrCommonRef      Attr = 0x1A\n        AttrCompDir        Attr = 0x1B\n        AttrConstValue     Attr = 0x1C\n        AttrContainingType Attr = 0x1D\n        AttrDefaultValue   Attr = 0x1E\n        AttrInline         Attr = 0x20\n        AttrIsOptional     Attr = 0x21\n        AttrLowerBound     Attr = 0x22\n        AttrProducer       Attr = 0x25\n        AttrPrototyped     Attr = 0x27\n        AttrReturnAddr     Attr = 0x2A\n        AttrStartScope     Attr = 0x2C\n        AttrStrideSize     Attr = 0x2E\n        AttrUpperBound     Attr = 0x2F\n        AttrAbstractOrigin Attr = 0x31\n        AttrAccessibility  Attr = 0x32\n        AttrAddrClass      Attr = 0x33\n        AttrArtificial     Attr = 0x34\n        AttrBaseTypes      Attr = 0x35\n        AttrCalling        Attr = 0x36\n        AttrCount          Attr = 0x37\n        AttrDataMemberLoc  Attr = 0x38\n        AttrDeclColumn     Attr = 0x39\n        AttrDeclFile       Attr = 0x3A\n        AttrDeclLine       Attr = 0x3B\n        AttrDeclaration    Attr = 0x3C\n        AttrDiscrList      Attr = 0x3D\n        AttrEncoding       Attr = 0x3E\n        AttrExternal       Attr = 0x3F\n        AttrFrameBase      Attr = 0x40\n        AttrFriend         Attr = 0x41\n        AttrIdentifierCase Attr = 0x42\n        AttrMacroInfo      Attr = 0x43\n        AttrNamelistItem   Attr = 0x44\n        AttrPriority       Attr = 0x45\n        AttrSegment        Attr = 0x46\n        AttrSpecification  Attr = 0x47\n        AttrStaticLink     Attr = 0x48\n        AttrType           Attr = 0x49\n        AttrUseLocation    Attr = 0x4A\n        AttrVarParam       Attr = 0x4B\n        AttrVirtuality     Attr = 0x4C\n        AttrVtableElemLoc  Attr = 0x4D\n        AttrAllocated      Attr = 0x4E\n        AttrAssociated     Attr = 0x4F\n        AttrDataLocation   Attr = 0x50\n        AttrStride         Attr = 0x51\n        AttrEntrypc        Attr = 0x52\n        AttrUseUTF8        Attr = 0x53\n        AttrExtension      Attr = 0x54\n        AttrRanges         Attr = 0x55\n        AttrTrampoline     Attr = 0x56\n        AttrCallColumn     Attr = 0x57\n        AttrCallFile       Attr = 0x58\n        AttrCallLine       Attr = 0x59\n        AttrDescription    Attr = 0x5A\n)</pre> <h3 id=\"Attr.GoString\">func (Attr) <a href=\"https://golang.org/src/debug/dwarf/const.go?s=5233:5264#L164\">GoString</a>  </h3> <pre data-language=\"go\">func (a Attr) GoString() string</pre> <h3 id=\"Attr.String\">func (Attr) <a href=\"https://golang.org/src/debug/dwarf/const.go?s=5085:5114#L154\">String</a>  </h3> <pre data-language=\"go\">func (a Attr) String() string</pre> <h2 id=\"BasicType\">type BasicType  </h2> <pre data-language=\"go\">type BasicType struct {\n        CommonType\n        BitSize   int64\n        BitOffset int64\n}</pre> <p> A BasicType holds fields common to all basic types. </p> <h3 id=\"BasicType.Basic\">func (*BasicType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=1081:1119#L32\">Basic</a>  </h3> <pre data-language=\"go\">func (b *BasicType) Basic() *BasicType</pre> <h3 id=\"BasicType.String\">func (*BasicType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=1134:1169#L34\">String</a>  </h3> <pre data-language=\"go\">func (t *BasicType) String() string</pre> <h2 id=\"BoolType\">type BoolType  </h2> <pre data-language=\"go\">type BoolType struct {\n        BasicType\n}</pre> <p> A BoolType represents a boolean type. </p> <h2 id=\"CharType\">type CharType  </h2> <pre data-language=\"go\">type CharType struct {\n        BasicType\n}</pre> <p> A CharType represents a signed character type. </p> <h2 id=\"Class\">type Class  </h2> <pre data-language=\"go\">type Class int</pre> <p> A Class is the DWARF 4 class of an attribute value. </p> <p> In general, a given attribute's value may take on one of several possible classes defined by DWARF, each of which leads to a slightly different interpretation of the attribute. </p> <p> DWARF version 4 distinguishes attribute value classes more finely than previous versions of DWARF. The reader will disambiguate coarser classes from earlier versions of DWARF into the appropriate DWARF 4 class. For example, DWARF 2 uses \"constant\" for constants as well as all types of section offsets, but the reader will canonicalize attributes in DWARF 2 files that refer to section offsets to one of the Class*Ptr classes, even though these classes were only defined in DWARF 3. </p> <pre data-language=\"go\">const (\n        // ClassUnknown represents values of unknown DWARF class.\n        ClassUnknown Class = iota\n\n        // ClassAddress represents values of type uint64 that are\n        // addresses on the target machine.\n        ClassAddress\n\n        // ClassBlock represents values of type []byte whose\n        // interpretation depends on the attribute.\n        ClassBlock\n\n        // ClassConstant represents values of type int64 that are\n        // constants. The interpretation of this constant depends on\n        // the attribute.\n        ClassConstant\n\n        // ClassExprLoc represents values of type []byte that contain\n        // an encoded DWARF expression or location description.\n        ClassExprLoc\n\n        // ClassFlag represents values of type bool.\n        ClassFlag\n\n        // ClassLinePtr represents values that are an int64 offset\n        // into the \"line\" section.\n        ClassLinePtr\n\n        // ClassLocListPtr represents values that are an int64 offset\n        // into the \"loclist\" section.\n        ClassLocListPtr\n\n        // ClassMacPtr represents values that are an int64 offset into\n        // the \"mac\" section.\n        ClassMacPtr\n\n        // ClassMacPtr represents values that are an int64 offset into\n        // the \"rangelist\" section.\n        ClassRangeListPtr\n\n        // ClassReference represents values that are an Offset offset\n        // of an Entry in the info section (for use with Reader.Seek).\n        // The DWARF specification combines ClassReference and\n        // ClassReferenceSig into class \"reference\".\n        ClassReference\n\n        // ClassReferenceSig represents values that are a uint64 type\n        // signature referencing a type Entry.\n        ClassReferenceSig\n\n        // ClassString represents values that are strings. If the\n        // compilation unit specifies the AttrUseUTF8 flag (strongly\n        // recommended), the string value will be encoded in UTF-8.\n        // Otherwise, the encoding is unspecified.\n        ClassString\n\n        // ClassReferenceAlt represents values of type int64 that are\n        // an offset into the DWARF \"info\" section of an alternate\n        // object file.\n        ClassReferenceAlt\n\n        // ClassStringAlt represents values of type int64 that are an\n        // offset into the DWARF string section of an alternate object\n        // file.\n        ClassStringAlt\n)</pre> <h3 id=\"Class.GoString\">func (Class) <a href=\"https://golang.org/src/debug/dwarf/entry.go?s=9466:9498#L321\">GoString</a>  </h3> <pre data-language=\"go\">func (i Class) GoString() string</pre> <h3 id=\"Class.String\">func (Class) <a href=\"https://golang.org/src/debug/dwarf/class_string.go?s=401:431#L1\">String</a>  </h3> <pre data-language=\"go\">func (i Class) String() string</pre> <h2 id=\"CommonType\">type CommonType  </h2> <pre data-language=\"go\">type CommonType struct {\n        ByteSize int64  // size of value of this type, in bytes\n        Name     string // name that can be used to refer to type\n}</pre> <p> A CommonType holds fields common to multiple types. If a field is not known or not applicable for a given type, the zero value is used. </p> <h3 id=\"CommonType.Common\">func (*CommonType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=824:865#L19\">Common</a>  </h3> <pre data-language=\"go\">func (c *CommonType) Common() *CommonType</pre> <h3 id=\"CommonType.Size\">func (*CommonType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=880:913#L21\">Size</a>  </h3> <pre data-language=\"go\">func (c *CommonType) Size() int64</pre> <h2 id=\"ComplexType\">type ComplexType  </h2> <pre data-language=\"go\">type ComplexType struct {\n        BasicType\n}</pre> <p> A ComplexType represents a complex floating point type. </p> <h2 id=\"Data\">type Data  </h2> <pre data-language=\"go\">type Data struct {\n        // contains filtered or unexported fields\n}</pre> <p> Data represents the DWARF debugging information loaded from an executable file (for example, an ELF or Mach-O executable). </p> <h3 id=\"New\">func <a href=\"https://golang.org/src/debug/dwarf/open.go?s=1289:1378#L31\">New</a>  </h3> <pre data-language=\"go\">func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Data, error)</pre> <p> New returns a new Data object initialized from the given parameters. Rather than calling this function directly, clients should typically use the DWARF method of the File type of the appropriate package debug/elf, debug/macho, or debug/pe. </p> <p> The []byte arguments are the data from the corresponding debug section in the object file; for example, for an ELF object, abbrev is the contents of the \".debug_abbrev\" section. </p> <h3 id=\"Data.AddTypes\">func (*Data) <a href=\"https://golang.org/src/debug/dwarf/open.go?s=2571:2627#L75\">AddTypes</a>  </h3> <pre data-language=\"go\">func (d *Data) AddTypes(name string, types []byte) error</pre> <p> AddTypes will add one .debug_types section to the DWARF data. A typical object with DWARF version 4 debug info will have multiple .debug_types sections. The name is used for error reporting only, and serves to distinguish one .debug_types section from another. </p> <h3 id=\"Data.LineReader\">func (*Data) <a href=\"https://golang.org/src/debug/dwarf/line.go?s=4440:4497#L127\">LineReader</a>  </h3> <pre data-language=\"go\">func (d *Data) LineReader(cu *Entry) (*LineReader, error)</pre> <p> LineReader returns a new reader for the line table of compilation unit cu, which must be an Entry with tag TagCompileUnit. </p> <p> If this compilation unit has no line table, it returns nil, nil. </p> <h3 id=\"Data.Ranges\">func (*Data) <a href=\"https://golang.org/src/debug/dwarf/entry.go?s=18373:18425#L674\">Ranges</a>  </h3> <pre data-language=\"go\">func (d *Data) Ranges(e *Entry) ([][2]uint64, error)</pre> <p> Ranges returns the PC ranges covered by e, a slice of [low,high) pairs. Only some entry types, such as TagCompileUnit or TagSubprogram, have PC ranges; for others, this will return nil with no error. </p> <h3 id=\"Data.Reader\">func (*Data) <a href=\"https://golang.org/src/debug/dwarf/entry.go?s=14278:14309#L514\">Reader</a>  </h3> <pre data-language=\"go\">func (d *Data) Reader() *Reader</pre> <p> Reader returns a new Reader for Data. The reader is positioned at byte offset 0 in the DWARF “info” section. </p> <h3 id=\"Data.Type\">func (*Data) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=5920:5965#L267\">Type</a>  </h3> <pre data-language=\"go\">func (d *Data) Type(off Offset) (Type, error)</pre> <p> Type reads the type at off in the DWARF “info” section. </p> <h2 id=\"DecodeError\">type DecodeError  </h2> <pre data-language=\"go\">type DecodeError struct {\n        Name   string\n        Offset Offset\n        Err    string\n}</pre> <h3 id=\"DecodeError.Error\">func (DecodeError) <a href=\"https://golang.org/src/debug/dwarf/buf.go?s=3426:3461#L180\">Error</a>  </h3> <pre data-language=\"go\">func (e DecodeError) Error() string</pre> <h2 id=\"DotDotDotType\">type DotDotDotType  </h2> <pre data-language=\"go\">type DotDotDotType struct {\n        CommonType\n}</pre> <p> A DotDotDotType represents the variadic ... function parameter. </p> <h3 id=\"DotDotDotType.String\">func (*DotDotDotType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=5288:5327#L242\">String</a>  </h3> <pre data-language=\"go\">func (t *DotDotDotType) String() string</pre> <h2 id=\"Entry\">type Entry  </h2> <pre data-language=\"go\">type Entry struct {\n        Offset   Offset // offset of Entry in DWARF info\n        Tag      Tag    // tag (kind of Entry)\n        Children bool   // whether Entry is followed by children\n        Field    []Field\n}</pre> <p> An entry is a sequence of attribute/value pairs. </p> <h3 id=\"Entry.AttrField\">func (*Entry) <a href=\"https://golang.org/src/debug/dwarf/entry.go?s=10036:10076#L341\">AttrField</a>  </h3> <pre data-language=\"go\">func (e *Entry) AttrField(a Attr) *Field</pre> <p> AttrField returns the Field associated with attribute Attr in Entry, or nil if there is no such attribute. </p> <h3 id=\"Entry.Val\">func (*Entry) <a href=\"https://golang.org/src/debug/dwarf/entry.go?s=9812:9851#L332\">Val</a>  </h3> <pre data-language=\"go\">func (e *Entry) Val(a Attr) interface{}</pre> <p> Val returns the value associated with attribute Attr in Entry, or nil if there is no such attribute. </p> <p> A common idiom is to merge the check for nil return with the check that the value has the expected dynamic type, as in: </p> <pre data-language=\"go\">v, ok := e.Val(AttrSibling).(int64)\n</pre> <h2 id=\"EnumType\">type EnumType  </h2> <pre data-language=\"go\">type EnumType struct {\n        CommonType\n        EnumName string\n        Val      []*EnumValue\n}</pre> <p> An EnumType represents an enumerated type. The only indication of its native integer type is its ByteSize (inside CommonType). </p> <h3 id=\"EnumType.String\">func (*EnumType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=4595:4629#L199\">String</a>  </h3> <pre data-language=\"go\">func (t *EnumType) String() string</pre> <h2 id=\"EnumValue\">type EnumValue  </h2> <pre data-language=\"go\">type EnumValue struct {\n        Name string\n        Val  int64\n}</pre> <p> An EnumValue represents a single enumeration value. </p> <h2 id=\"Field\">type Field  </h2> <pre data-language=\"go\">type Field struct {\n        Attr  Attr\n        Val   interface{}\n        Class Class\n}</pre> <p> A Field is a single attribute/value pair in an Entry. </p> <p> A value can be one of several \"attribute classes\" defined by DWARF. The Go types corresponding to each class are: </p> <pre data-language=\"go\">DWARF class       Go type        Class\n-----------       -------        -----\naddress           uint64         ClassAddress\nblock             []byte         ClassBlock\nconstant          int64          ClassConstant\nflag              bool           ClassFlag\nreference\n  to info         dwarf.Offset   ClassReference\n  to type unit    uint64         ClassReferenceSig\nstring            string         ClassString\nexprloc           []byte         ClassExprLoc\nlineptr           int64          ClassLinePtr\nloclistptr        int64          ClassLocListPtr\nmacptr            int64          ClassMacPtr\nrangelistptr      int64          ClassRangeListPtr\n</pre> <p> For unrecognized or vendor-defined attributes, Class may be ClassUnknown. </p> <h2 id=\"FloatType\">type FloatType  </h2> <pre data-language=\"go\">type FloatType struct {\n        BasicType\n}</pre> <p> A FloatType represents a floating point type. </p> <h2 id=\"FuncType\">type FuncType  </h2> <pre data-language=\"go\">type FuncType struct {\n        CommonType\n        ReturnType Type\n        ParamType  []Type\n}</pre> <p> A FuncType represents a function type. </p> <h3 id=\"FuncType.String\">func (*FuncType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=4956:4990#L222\">String</a>  </h3> <pre data-language=\"go\">func (t *FuncType) String() string</pre> <h2 id=\"IntType\">type IntType  </h2> <pre data-language=\"go\">type IntType struct {\n        BasicType\n}</pre> <p> An IntType represents a signed integer type. </p> <h2 id=\"LineEntry\">type LineEntry  </h2> <pre data-language=\"go\">type LineEntry struct {\n        // Address is the program-counter value of a machine\n        // instruction generated by the compiler. This LineEntry\n        // applies to each instruction from Address to just before the\n        // Address of the next LineEntry.\n        Address uint64\n\n        // OpIndex is the index of an operation within a VLIW\n        // instruction. The index of the first operation is 0. For\n        // non-VLIW architectures, it will always be 0. Address and\n        // OpIndex together form an operation pointer that can\n        // reference any individual operation within the instruction\n        // stream.\n        OpIndex int\n\n        // File is the source file corresponding to these\n        // instructions.\n        File *LineFile\n\n        // Line is the source code line number corresponding to these\n        // instructions. Lines are numbered beginning at 1. It may be\n        // 0 if these instructions cannot be attributed to any source\n        // line.\n        Line int\n\n        // Column is the column number within the source line of these\n        // instructions. Columns are numbered beginning at 1. It may\n        // be 0 to indicate the \"left edge\" of the line.\n        Column int\n\n        // IsStmt indicates that Address is a recommended breakpoint\n        // location, such as the beginning of a line, statement, or a\n        // distinct subpart of a statement.\n        IsStmt bool\n\n        // BasicBlock indicates that Address is the beginning of a\n        // basic block.\n        BasicBlock bool\n\n        // PrologueEnd indicates that Address is one (of possibly\n        // many) PCs where execution should be suspended for a\n        // breakpoint on entry to the containing function.\n        //\n        // Added in DWARF 3.\n        PrologueEnd bool\n\n        // EpilogueBegin indicates that Address is one (of possibly\n        // many) PCs where execution should be suspended for a\n        // breakpoint on exit from this function.\n        //\n        // Added in DWARF 3.\n        EpilogueBegin bool\n\n        // ISA is the instruction set architecture for these\n        // instructions. Possible ISA values should be defined by the\n        // applicable ABI specification.\n        //\n        // Added in DWARF 3.\n        ISA int\n\n        // Discriminator is an arbitrary integer indicating the block\n        // to which these instructions belong. It serves to\n        // distinguish among multiple blocks that may all have with\n        // the same source file, line, and column. Where only one\n        // block exists for a given source position, it should be 0.\n        //\n        // Added in DWARF 3.\n        Discriminator int\n\n        // EndSequence indicates that Address is the first byte after\n        // the end of a sequence of target machine instructions. If it\n        // is set, only this and the Address field are meaningful. A\n        // line number table may contain information for multiple\n        // potentially disjoint instruction sequences. The last entry\n        // in a line table should always have EndSequence set.\n        EndSequence bool\n}</pre> <p> A LineEntry is a row in a DWARF line table. </p> <h2 id=\"LineFile\">type LineFile  </h2> <pre data-language=\"go\">type LineFile struct {\n        Name   string\n        Mtime  uint64 // Implementation defined modification time, or 0 if unknown\n        Length int    // File length, or 0 if unknown\n}</pre> <p> A LineFile is a source file referenced by a DWARF line table entry. </p> <h2 id=\"LineReader\">type LineReader  </h2> <pre data-language=\"go\">type LineReader struct {\n        // contains filtered or unexported fields\n}</pre> <p> A LineReader reads a sequence of LineEntry structures from a DWARF \"line\" section for a single compilation unit. LineEntries occur in order of increasing PC and each LineEntry gives metadata for the instructions from that LineEntry's PC to just before the next LineEntry's PC. The last entry will have its EndSequence field set. </p> <h3 id=\"LineReader.Next\">func (*LineReader) <a href=\"https://golang.org/src/debug/dwarf/line.go?s=9605:9654#L305\">Next</a>  </h3> <pre data-language=\"go\">func (r *LineReader) Next(entry *LineEntry) error</pre> <p> Next sets *entry to the next row in this line table and moves to the next row. If there are no more entries and the line table is properly terminated, it returns io.EOF. </p> <p> Rows are always in order of increasing entry.Address, but entry.Line may go forward or backward. </p> <h3 id=\"LineReader.Reset\">func (*LineReader) <a href=\"https://golang.org/src/debug/dwarf/line.go?s=14197:14225#L492\">Reset</a>  </h3> <pre data-language=\"go\">func (r *LineReader) Reset()</pre> <p> Reset repositions the line table reader at the beginning of the line table. </p> <h3 id=\"LineReader.Seek\">func (*LineReader) <a href=\"https://golang.org/src/debug/dwarf/line.go?s=13895:13939#L482\">Seek</a>  </h3> <pre data-language=\"go\">func (r *LineReader) Seek(pos LineReaderPos)</pre> <p> Seek restores the line table reader to a position returned by Tell. </p> <p> The argument pos must have been returned by a call to Tell on this line table. </p> <h3 id=\"LineReader.SeekPC\">func (*LineReader) <a href=\"https://golang.org/src/debug/dwarf/line.go?s=15756:15818#L541\">SeekPC</a>  </h3> <pre data-language=\"go\">func (r *LineReader) SeekPC(pc uint64, entry *LineEntry) error</pre> <p> SeekPC sets *entry to the LineEntry that includes pc and positions the reader on the next entry in the line table. If necessary, this will seek backwards to find pc. </p> <p> If pc is not covered by any entry in this line table, SeekPC returns ErrUnknownPC. In this case, *entry and the final seek position are unspecified. </p> <p> Note that DWARF line tables only permit sequential, forward scans. Hence, in the worst case, this takes time linear in the size of the line table. If the caller wishes to do repeated fast PC lookups, it should build an appropriate index of the line table. </p> <h3 id=\"LineReader.Tell\">func (*LineReader) <a href=\"https://golang.org/src/debug/dwarf/line.go?s=13614:13655#L474\">Tell</a>  </h3> <pre data-language=\"go\">func (r *LineReader) Tell() LineReaderPos</pre> <p> Tell returns the current position in the line table. </p> <h2 id=\"LineReaderPos\">type LineReaderPos  </h2> <pre data-language=\"go\">type LineReaderPos struct {\n        // contains filtered or unexported fields\n}</pre> <p> A LineReaderPos represents a position in a line table. </p> <h2 id=\"Offset\">type Offset  </h2> <pre data-language=\"go\">type Offset uint32</pre> <p> An Offset represents the location of an Entry within the DWARF info. (See Reader.Seek.) </p> <h2 id=\"PtrType\">type PtrType  </h2> <pre data-language=\"go\">type PtrType struct {\n        CommonType\n        Type Type\n}</pre> <p> A PtrType represents a pointer type. </p> <h3 id=\"PtrType.String\">func (*PtrType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=3052:3085#L131\">String</a>  </h3> <pre data-language=\"go\">func (t *PtrType) String() string</pre> <h2 id=\"QualType\">type QualType  </h2> <pre data-language=\"go\">type QualType struct {\n        CommonType\n        Qual string\n        Type Type\n}</pre> <p> A QualType represents a type that has the C/C++ \"const\", \"restrict\", or \"volatile\" qualifier. </p> <h3 id=\"QualType.Size\">func (*QualType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=2309:2340#L97\">Size</a>  </h3> <pre data-language=\"go\">func (t *QualType) Size() int64</pre> <h3 id=\"QualType.String\">func (*QualType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=2231:2265#L95\">String</a>  </h3> <pre data-language=\"go\">func (t *QualType) String() string</pre> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Reader allows reading Entry structures from a DWARF “info” section. The Entry structures are arranged in a tree. The Reader's Next function return successive entries from a pre-order traversal of the tree. If an entry has children, its Children field will be true, and the children follow, terminated by an Entry with Tag 0. </p> <h3 id=\"Reader.AddressSize\">func (*Reader) <a href=\"https://golang.org/src/debug/dwarf/entry.go?s=14446:14480#L522\">AddressSize</a>  </h3> <pre data-language=\"go\">func (r *Reader) AddressSize() int</pre> <p> AddressSize returns the size in bytes of addresses in the current compilation unit. </p> <h3 id=\"Reader.Next\">func (*Reader) <a href=\"https://golang.org/src/debug/dwarf/entry.go?s=15541:15580#L565\">Next</a>  </h3> <pre data-language=\"go\">func (r *Reader) Next() (*Entry, error)</pre> <p> Next reads the next entry from the encoded entry stream. It returns nil, nil when it reaches the end of the section. It returns an error if the current offset is invalid or the data at the offset cannot be decoded as a valid Entry. </p> <h3 id=\"Reader.Seek\">func (*Reader) <a href=\"https://golang.org/src/debug/dwarf/entry.go?s=14640:14673#L528\">Seek</a>  </h3> <pre data-language=\"go\">func (r *Reader) Seek(off Offset)</pre> <p> Seek positions the Reader at offset off in the encoded entry stream. Offset 0 can be used to denote the first entry. </p> <h3 id=\"Reader.SeekPC\">func (*Reader) <a href=\"https://golang.org/src/debug/dwarf/entry.go?s=17618:17668#L642\">SeekPC</a>  </h3> <pre data-language=\"go\">func (r *Reader) SeekPC(pc uint64) (*Entry, error)</pre> <p> SeekPC returns the Entry for the compilation unit that includes pc, and positions the reader to read the children of that unit. If pc is not covered by any unit, SeekPC returns ErrUnknownPC and the position of the reader is undefined. </p> <p> Because compilation units can describe multiple regions of the executable, in the worst case SeekPC must search through all the ranges in all the compilation units. Each call to SeekPC starts the search at the compilation unit of the last call, so in general looking up a series of PCs will be faster if they are sorted. If the caller wishes to do repeated fast PC lookups, it should build an appropriate index using the Ranges method. </p> <h3 id=\"Reader.SkipChildren\">func (*Reader) <a href=\"https://golang.org/src/debug/dwarf/entry.go?s=16177:16208#L593\">SkipChildren</a>  </h3> <pre data-language=\"go\">func (r *Reader) SkipChildren()</pre> <p> SkipChildren skips over the child entries associated with the last Entry returned by Next. If that Entry did not have children or Next has not been called, SkipChildren is a no-op. </p> <h2 id=\"StructField\">type StructField  </h2> <pre data-language=\"go\">type StructField struct {\n        Name       string\n        Type       Type\n        ByteOffset int64\n        ByteSize   int64\n        BitOffset  int64 // within the ByteSize bytes at ByteOffset\n        BitSize    int64 // zero if not a bit field\n}</pre> <p> A StructField represents a field in a struct, union, or C++ class type. </p> <h2 id=\"StructType\">type StructType  </h2> <pre data-language=\"go\">type StructType struct {\n        CommonType\n        StructName string\n        Kind       string // \"struct\", \"union\", or \"class\".\n        Field      []*StructField\n        Incomplete bool // if true, struct, union, class is declared but not defined\n}</pre> <p> A StructType represents a struct, union, or C++ class type. </p> <h3 id=\"StructType.Defn\">func (*StructType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=3806:3840#L159\">Defn</a>  </h3> <pre data-language=\"go\">func (t *StructType) Defn() string</pre> <h3 id=\"StructType.String\">func (*StructType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=3682:3718#L152\">String</a>  </h3> <pre data-language=\"go\">func (t *StructType) String() string</pre> <h2 id=\"Tag\">type Tag  </h2> <pre data-language=\"go\">type Tag uint32</pre> <p> A Tag is the classification (the type) of an Entry. </p> <pre data-language=\"go\">const (\n        TagArrayType              Tag = 0x01\n        TagClassType              Tag = 0x02\n        TagEntryPoint             Tag = 0x03\n        TagEnumerationType        Tag = 0x04\n        TagFormalParameter        Tag = 0x05\n        TagImportedDeclaration    Tag = 0x08\n        TagLabel                  Tag = 0x0A\n        TagLexDwarfBlock          Tag = 0x0B\n        TagMember                 Tag = 0x0D\n        TagPointerType            Tag = 0x0F\n        TagReferenceType          Tag = 0x10\n        TagCompileUnit            Tag = 0x11\n        TagStringType             Tag = 0x12\n        TagStructType             Tag = 0x13\n        TagSubroutineType         Tag = 0x15\n        TagTypedef                Tag = 0x16\n        TagUnionType              Tag = 0x17\n        TagUnspecifiedParameters  Tag = 0x18\n        TagVariant                Tag = 0x19\n        TagCommonDwarfBlock       Tag = 0x1A\n        TagCommonInclusion        Tag = 0x1B\n        TagInheritance            Tag = 0x1C\n        TagInlinedSubroutine      Tag = 0x1D\n        TagModule                 Tag = 0x1E\n        TagPtrToMemberType        Tag = 0x1F\n        TagSetType                Tag = 0x20\n        TagSubrangeType           Tag = 0x21\n        TagWithStmt               Tag = 0x22\n        TagAccessDeclaration      Tag = 0x23\n        TagBaseType               Tag = 0x24\n        TagCatchDwarfBlock        Tag = 0x25\n        TagConstType              Tag = 0x26\n        TagConstant               Tag = 0x27\n        TagEnumerator             Tag = 0x28\n        TagFileType               Tag = 0x29\n        TagFriend                 Tag = 0x2A\n        TagNamelist               Tag = 0x2B\n        TagNamelistItem           Tag = 0x2C\n        TagPackedType             Tag = 0x2D\n        TagSubprogram             Tag = 0x2E\n        TagTemplateTypeParameter  Tag = 0x2F\n        TagTemplateValueParameter Tag = 0x30\n        TagThrownType             Tag = 0x31\n        TagTryDwarfBlock          Tag = 0x32\n        TagVariantPart            Tag = 0x33\n        TagVariable               Tag = 0x34\n        TagVolatileType           Tag = 0x35\n        // The following are new in DWARF 3.\n        TagDwarfProcedure  Tag = 0x36\n        TagRestrictType    Tag = 0x37\n        TagInterfaceType   Tag = 0x38\n        TagNamespace       Tag = 0x39\n        TagImportedModule  Tag = 0x3A\n        TagUnspecifiedType Tag = 0x3B\n        TagPartialUnit     Tag = 0x3C\n        TagImportedUnit    Tag = 0x3D\n        TagMutableType     Tag = 0x3E // Later removed from DWARF.\n        TagCondition       Tag = 0x3F\n        TagSharedType      Tag = 0x40\n        // The following are new in DWARF 4.\n        TagTypeUnit            Tag = 0x41\n        TagRvalueReferenceType Tag = 0x42\n        TagTemplateAlias       Tag = 0x43\n)</pre> <h3 id=\"Tag.GoString\">func (Tag) <a href=\"https://golang.org/src/debug/dwarf/const.go?s=11765:11795#L354\">GoString</a>  </h3> <pre data-language=\"go\">func (t Tag) GoString() string</pre> <h3 id=\"Tag.String\">func (Tag) <a href=\"https://golang.org/src/debug/dwarf/const.go?s=11620:11648#L344\">String</a>  </h3> <pre data-language=\"go\">func (t Tag) String() string</pre> <h2 id=\"Type\">type Type  </h2> <pre data-language=\"go\">type Type interface {\n        Common() *CommonType\n        String() string\n        Size() int64\n}</pre> <p> A Type conventionally represents a pointer to any of the specific Type structures (CharType, StructType, etc.). </p> <h2 id=\"TypedefType\">type TypedefType  </h2> <pre data-language=\"go\">type TypedefType struct {\n        CommonType\n        Type Type\n}</pre> <p> A TypedefType represents a named type. </p> <h3 id=\"TypedefType.Size\">func (*TypedefType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=5497:5531#L252\">Size</a>  </h3> <pre data-language=\"go\">func (t *TypedefType) Size() int64</pre> <h3 id=\"TypedefType.String\">func (*TypedefType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=5440:5477#L250\">String</a>  </h3> <pre data-language=\"go\">func (t *TypedefType) String() string</pre> <h2 id=\"UcharType\">type UcharType  </h2> <pre data-language=\"go\">type UcharType struct {\n        BasicType\n}</pre> <p> A UcharType represents an unsigned character type. </p> <h2 id=\"UintType\">type UintType  </h2> <pre data-language=\"go\">type UintType struct {\n        BasicType\n}</pre> <p> A UintType represents an unsigned integer type. </p> <h2 id=\"UnspecifiedType\">type UnspecifiedType  </h2> <pre data-language=\"go\">type UnspecifiedType struct {\n        BasicType\n}</pre> <p> An UnspecifiedType represents an implicit, unknown, ambiguous or nonexistent type. </p> <h2 id=\"VoidType\">type VoidType  </h2> <pre data-language=\"go\">type VoidType struct {\n        CommonType\n}</pre> <p> A VoidType represents the C void type. </p> <h3 id=\"VoidType.String\">func (*VoidType) <a href=\"https://golang.org/src/debug/dwarf/type.go?s=2910:2944#L123\">String</a>  </h3> <pre data-language=\"go\">func (t *VoidType) String() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/debug/dwarf/\" class=\"_attribution-link\">https://golang.org/pkg/debug/dwarf/</a>\n  </p>\n</div>\n","go/constant/index":"<h1>Package constant</h1>     <ul id=\"short-nav\">\n<li><code>import \"go/constant\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package constant implements Values representing untyped Go constants and their corresponding operations. </p> <p> A special Unknown value may be used when a value is unknown due to an error. Operations on unknown values produce unknown values unless specified otherwise. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#BitLen\">func BitLen(x Value) int</a></li>\n<li><a href=\"#BoolVal\">func BoolVal(x Value) bool</a></li>\n<li><a href=\"#Bytes\">func Bytes(x Value) []byte</a></li>\n<li><a href=\"#Compare\">func Compare(x Value, op token.Token, y Value) bool</a></li>\n<li><a href=\"#Float32Val\">func Float32Val(x Value) (float32, bool)</a></li>\n<li><a href=\"#Float64Val\">func Float64Val(x Value) (float64, bool)</a></li>\n<li><a href=\"#Int64Val\">func Int64Val(x Value) (int64, bool)</a></li>\n<li><a href=\"#Sign\">func Sign(x Value) int</a></li>\n<li><a href=\"#StringVal\">func StringVal(x Value) string</a></li>\n<li><a href=\"#Uint64Val\">func Uint64Val(x Value) (uint64, bool)</a></li>\n<li><a href=\"#Kind\">type Kind</a></li>\n<li><a href=\"#Value\">type Value</a></li>\n<li> <a href=\"#BinaryOp\">func BinaryOp(x Value, op token.Token, y Value) Value</a>\n</li>\n<li> <a href=\"#Denom\">func Denom(x Value) Value</a>\n</li>\n<li> <a href=\"#Imag\">func Imag(x Value) Value</a>\n</li>\n<li> <a href=\"#MakeBool\">func MakeBool(b bool) Value</a>\n</li>\n<li> <a href=\"#MakeFloat64\">func MakeFloat64(x float64) Value</a>\n</li>\n<li> <a href=\"#MakeFromBytes\">func MakeFromBytes(bytes []byte) Value</a>\n</li>\n<li> <a href=\"#MakeFromLiteral\">func MakeFromLiteral(lit string, tok token.Token, zero uint) Value</a>\n</li>\n<li> <a href=\"#MakeImag\">func MakeImag(x Value) Value</a>\n</li>\n<li> <a href=\"#MakeInt64\">func MakeInt64(x int64) Value</a>\n</li>\n<li> <a href=\"#MakeString\">func MakeString(s string) Value</a>\n</li>\n<li> <a href=\"#MakeUint64\">func MakeUint64(x uint64) Value</a>\n</li>\n<li> <a href=\"#MakeUnknown\">func MakeUnknown() Value</a>\n</li>\n<li> <a href=\"#Num\">func Num(x Value) Value</a>\n</li>\n<li> <a href=\"#Real\">func Real(x Value) Value</a>\n</li>\n<li> <a href=\"#Shift\">func Shift(x Value, op token.Token, s uint) Value</a>\n</li>\n<li> <a href=\"#ToComplex\">func ToComplex(x Value) Value</a>\n</li>\n<li> <a href=\"#ToFloat\">func ToFloat(x Value) Value</a>\n</li>\n<li> <a href=\"#ToInt\">func ToInt(x Value) Value</a>\n</li>\n<li> <a href=\"#UnaryOp\">func UnaryOp(op token.Token, y Value, prec uint) Value</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/go/constant/value.go\">value.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"BitLen\">func BitLen  </h2> <pre data-language=\"go\">func BitLen(x Value) int</pre> <p> BitLen returns the number of bits required to represent the absolute value x in binary representation; x must be an Int or an Unknown. If x is Unknown, the result is 0. </p> <h2 id=\"BoolVal\">func BoolVal  </h2> <pre data-language=\"go\">func BoolVal(x Value) bool</pre> <p> BoolVal returns the Go boolean value of x, which must be a Bool or an Unknown. If x is Unknown, the result is false. </p> <h2 id=\"Bytes\">func Bytes  </h2> <pre data-language=\"go\">func Bytes(x Value) []byte</pre> <p> Bytes returns the bytes for the absolute value of x in little- endian binary representation; x must be an Int. </p> <h2 id=\"Compare\">func Compare  </h2> <pre data-language=\"go\">func Compare(x Value, op token.Token, y Value) bool</pre> <p> Compare returns the result of the comparison x op y. The comparison must be defined for the operands. If one of the operands is Unknown, the result is false. </p> <h2 id=\"Float32Val\">func Float32Val  </h2> <pre data-language=\"go\">func Float32Val(x Value) (float32, bool)</pre> <p> Float32Val is like Float64Val but for float32 instead of float64. </p> <h2 id=\"Float64Val\">func Float64Val  </h2> <pre data-language=\"go\">func Float64Val(x Value) (float64, bool)</pre> <p> Float64Val returns the nearest Go float64 value of x and whether the result is exact; x must be numeric or an Unknown, but not Complex. For values too small (too close to 0) to represent as float64, Float64Val silently underflows to 0. The result sign always matches the sign of x, even for 0. If x is Unknown, the result is (0, false). </p> <h2 id=\"Int64Val\">func Int64Val  </h2> <pre data-language=\"go\">func Int64Val(x Value) (int64, bool)</pre> <p> Int64Val returns the Go int64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false). </p> <h2 id=\"Sign\">func Sign  </h2> <pre data-language=\"go\">func Sign(x Value) int</pre> <p> Sign returns -1, 0, or 1 depending on whether x &lt; 0, x == 0, or x &gt; 0; x must be numeric or Unknown. For complex values x, the sign is 0 if x == 0, otherwise it is != 0. If x is Unknown, the result is 1. </p> <h2 id=\"StringVal\">func StringVal  </h2> <pre data-language=\"go\">func StringVal(x Value) string</pre> <p> StringVal returns the Go string value of x, which must be a String or an Unknown. If x is Unknown, the result is \"\". </p> <h2 id=\"Uint64Val\">func Uint64Val  </h2> <pre data-language=\"go\">func Uint64Val(x Value) (uint64, bool)</pre> <p> Uint64Val returns the Go uint64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false). </p> <h2 id=\"Kind\">type Kind  </h2> <pre data-language=\"go\">type Kind int</pre> <p> Kind specifies the kind of value represented by a Value. </p> <pre data-language=\"go\">const (\n        // unknown values\n        Unknown Kind = iota\n\n        // non-numeric values\n        Bool\n        String\n\n        // numeric values\n        Int\n        Float\n        Complex\n)</pre> <h2 id=\"Value\">type Value  </h2> <pre data-language=\"go\">type Value interface {\n        // Kind returns the value kind.\n        Kind() Kind\n\n        // String returns a short, human-readable form of the value.\n        // For numeric values, the result may be an approximation;\n        // for String values the result may be a shortened string.\n        // Use ExactString for a string representing a value exactly.\n        String() string\n\n        // ExactString returns an exact, printable form of the value.\n        ExactString() string\n        // contains filtered or unexported methods\n}</pre> <p> A Value represents the value of a Go constant. </p> <h3 id=\"BinaryOp\">func <a href=\"https://golang.org/src/go/constant/value.go?s=23587:23640#L932\">BinaryOp</a>  </h3> <pre data-language=\"go\">func BinaryOp(x Value, op token.Token, y Value) Value</pre> <p> BinaryOp returns the result of the binary expression x op y. The operation must be defined for the operands. If one of the operands is Unknown, the result is Unknown. To force integer division of Int operands, use op == token.QUO_ASSIGN instead of token.QUO; the result is guaranteed to be Int in this case. Division by zero leads to a run-time panic. </p> <h3 id=\"Denom\">func <a href=\"https://golang.org/src/go/constant/value.go?s=16308:16333#L601\">Denom</a>  </h3> <pre data-language=\"go\">func Denom(x Value) Value</pre> <p> Denom returns the denominator of x; x must be Int, Float, or Unknown. If x is Unknown, or if it is too large or small to represent as a fraction, the result is Unknown. Otherwise the result is an Int &gt;= 1. </p> <h3 id=\"Imag\">func <a href=\"https://golang.org/src/go/constant/value.go?s=17456:17480#L649\">Imag</a>  </h3> <pre data-language=\"go\">func Imag(x Value) Value</pre> <p> Imag returns the imaginary part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown. </p> <h3 id=\"MakeBool\">func <a href=\"https://golang.org/src/go/constant/value.go?s=7949:7976#L270\">MakeBool</a>  </h3> <pre data-language=\"go\">func MakeBool(b bool) Value</pre> <p> MakeBool returns the Bool value for b. </p> <h3 id=\"MakeFloat64\">func <a href=\"https://golang.org/src/go/constant/value.go?s=8459:8492#L288\">MakeFloat64</a>  </h3> <pre data-language=\"go\">func MakeFloat64(x float64) Value</pre> <p> MakeFloat64 returns the Float value for x. If x is not finite, the result is an Unknown. </p> <h3 id=\"MakeFromBytes\">func <a href=\"https://golang.org/src/go/constant/value.go?s=15076:15114#L547\">MakeFromBytes</a>  </h3> <pre data-language=\"go\">func MakeFromBytes(bytes []byte) Value</pre> <p> MakeFromBytes returns the Int value given the bytes of its little-endian binary representation. An empty byte slice argument represents 0. </p> <h3 id=\"MakeFromLiteral\">func <a href=\"https://golang.org/src/go/constant/value.go?s=8998:9064#L304\">MakeFromLiteral</a>  </h3> <pre data-language=\"go\">func MakeFromLiteral(lit string, tok token.Token, zero uint) Value</pre> <p> MakeFromLiteral returns the corresponding integer, floating-point, imaginary, character, or string value for a Go literal string. The tok value must be one of token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING. The final argument must be zero. If the literal string syntax is invalid, the result is an Unknown. </p> <h3 id=\"MakeImag\">func <a href=\"https://golang.org/src/go/constant/value.go?s=16782:16810#L623\">MakeImag</a>  </h3> <pre data-language=\"go\">func MakeImag(x Value) Value</pre> <p> MakeImag returns the Complex value x*i; x must be Int, Float, or Unknown. If x is Unknown, the result is Unknown. </p> <h3 id=\"MakeInt64\">func <a href=\"https://golang.org/src/go/constant/value.go?s=8145:8174#L276\">MakeInt64</a>  </h3> <pre data-language=\"go\">func MakeInt64(x int64) Value</pre> <p> MakeInt64 returns the Int value for x. </p> <h3 id=\"MakeString\">func <a href=\"https://golang.org/src/go/constant/value.go?s=8046:8077#L273\">MakeString</a>  </h3> <pre data-language=\"go\">func MakeString(s string) Value</pre> <p> MakeString returns the String value for s. </p> <h3 id=\"MakeUint64\">func <a href=\"https://golang.org/src/go/constant/value.go?s=8242:8273#L279\">MakeUint64</a>  </h3> <pre data-language=\"go\">func MakeUint64(x uint64) Value</pre> <p> MakeUint64 returns the Int value for x. </p> <h3 id=\"MakeUnknown\">func <a href=\"https://golang.org/src/go/constant/value.go?s=7857:7881#L267\">MakeUnknown</a>  </h3> <pre data-language=\"go\">func MakeUnknown() Value</pre> <p> MakeUnknown returns the Unknown value. </p> <h3 id=\"Num\">func <a href=\"https://golang.org/src/go/constant/value.go?s=15758:15781#L579\">Num</a>  </h3> <pre data-language=\"go\">func Num(x Value) Value</pre> <p> Num returns the numerator of x; x must be Int, Float, or Unknown. If x is Unknown, or if it is too large or small to represent as a fraction, the result is Unknown. Otherwise the result is an Int with the same sign as x. </p> <h3 id=\"Real\">func <a href=\"https://golang.org/src/go/constant/value.go?s=17124:17148#L636\">Real</a>  </h3> <pre data-language=\"go\">func Real(x Value) Value</pre> <p> Real returns the real part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown. </p> <h3 id=\"Shift\">func <a href=\"https://golang.org/src/go/constant/value.go?s=27063:27112#L1112\">Shift</a>  </h3> <pre data-language=\"go\">func Shift(x Value, op token.Token, s uint) Value</pre> <p> Shift returns the result of the shift expression x op s with op == token.SHL or token.SHR (&lt;&lt; or &gt;&gt;). x must be an Int or an Unknown. If x is Unknown, the result is x. </p> <h3 id=\"ToComplex\">func <a href=\"https://golang.org/src/go/constant/value.go?s=19563:19592#L740\">ToComplex</a>  </h3> <pre data-language=\"go\">func ToComplex(x Value) Value</pre> <p> ToComplex converts x to a Complex value if x is representable as a Complex. Otherwise it returns an Unknown. </p> <h3 id=\"ToFloat\">func <a href=\"https://golang.org/src/go/constant/value.go?s=19129:19156#L721\">ToFloat</a>  </h3> <pre data-language=\"go\">func ToFloat(x Value) Value</pre> <p> ToFloat converts x to a Float value if x is representable as a Float. Otherwise it returns an Unknown. </p> <h3 id=\"ToInt\">func <a href=\"https://golang.org/src/go/constant/value.go?s=17898:17923#L667\">ToInt</a>  </h3> <pre data-language=\"go\">func ToInt(x Value) Value</pre> <p> ToInt converts x to an Int value if x is representable as an Int. Otherwise it returns an Unknown. </p> <h3 id=\"UnaryOp\">func <a href=\"https://golang.org/src/go/constant/value.go?s=20431:20485#L776\">UnaryOp</a>  </h3> <pre data-language=\"go\">func UnaryOp(op token.Token, y Value, prec uint) Value</pre> <p> UnaryOp returns the result of the unary expression op y. The operation must be defined for the operand. If prec &gt; 0 it specifies the ^ (xor) result size in bits. If y is Unknown, the result is Unknown. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/go/constant/\" class=\"_attribution-link\">https://golang.org/pkg/go/constant/</a>\n  </p>\n</div>\n","database/sql/index":"<h1>Package sql</h1>     <ul id=\"short-nav\">\n<li><code>import \"database/sql\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package sql provides a generic interface around SQL (or SQL-like) databases. </p> <p> The sql package must be used in conjunction with a database driver. See <a href=\"https://golang.org/s/sqldrivers\">https://golang.org/s/sqldrivers</a> for a list of drivers. </p> <p> For more usage examples, see the wiki page at <a href=\"https://golang.org/s/sqlwiki\">https://golang.org/s/sqlwiki</a>. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Drivers\">func Drivers() []string</a></li>\n<li><a href=\"#Register\">func Register(name string, driver driver.Driver)</a></li>\n<li><a href=\"#DB\">type DB</a></li>\n<li> <a href=\"#Open\">func Open(driverName, dataSourceName string) (*DB, error)</a>\n</li>\n<li> <a href=\"#DB.Begin\">func (db *DB) Begin() (*Tx, error)</a>\n</li>\n<li> <a href=\"#DB.Close\">func (db *DB) Close() error</a>\n</li>\n<li> <a href=\"#DB.Driver\">func (db *DB) Driver() driver.Driver</a>\n</li>\n<li> <a href=\"#DB.Exec\">func (db *DB) Exec(query string, args ...interface{}) (Result, error)</a>\n</li>\n<li> <a href=\"#DB.Ping\">func (db *DB) Ping() error</a>\n</li>\n<li> <a href=\"#DB.Prepare\">func (db *DB) Prepare(query string) (*Stmt, error)</a>\n</li>\n<li> <a href=\"#DB.Query\">func (db *DB) Query(query string, args ...interface{}) (*Rows, error)</a>\n</li>\n<li> <a href=\"#DB.QueryRow\">func (db *DB) QueryRow(query string, args ...interface{}) *Row</a>\n</li>\n<li> <a href=\"#DB.SetConnMaxLifetime\">func (db *DB) SetConnMaxLifetime(d time.Duration)</a>\n</li>\n<li> <a href=\"#DB.SetMaxIdleConns\">func (db *DB) SetMaxIdleConns(n int)</a>\n</li>\n<li> <a href=\"#DB.SetMaxOpenConns\">func (db *DB) SetMaxOpenConns(n int)</a>\n</li>\n<li> <a href=\"#DB.Stats\">func (db *DB) Stats() DBStats</a>\n</li>\n<li><a href=\"#DBStats\">type DBStats</a></li>\n<li><a href=\"#NullBool\">type NullBool</a></li>\n<li> <a href=\"#NullBool.Scan\">func (n *NullBool) Scan(value interface{}) error</a>\n</li>\n<li> <a href=\"#NullBool.Value\">func (n NullBool) Value() (driver.Value, error)</a>\n</li>\n<li><a href=\"#NullFloat64\">type NullFloat64</a></li>\n<li> <a href=\"#NullFloat64.Scan\">func (n *NullFloat64) Scan(value interface{}) error</a>\n</li>\n<li> <a href=\"#NullFloat64.Value\">func (n NullFloat64) Value() (driver.Value, error)</a>\n</li>\n<li><a href=\"#NullInt64\">type NullInt64</a></li>\n<li> <a href=\"#NullInt64.Scan\">func (n *NullInt64) Scan(value interface{}) error</a>\n</li>\n<li> <a href=\"#NullInt64.Value\">func (n NullInt64) Value() (driver.Value, error)</a>\n</li>\n<li><a href=\"#NullString\">type NullString</a></li>\n<li> <a href=\"#NullString.Scan\">func (ns *NullString) Scan(value interface{}) error</a>\n</li>\n<li> <a href=\"#NullString.Value\">func (ns NullString) Value() (driver.Value, error)</a>\n</li>\n<li><a href=\"#RawBytes\">type RawBytes</a></li>\n<li><a href=\"#Result\">type Result</a></li>\n<li><a href=\"#Row\">type Row</a></li>\n<li> <a href=\"#Row.Scan\">func (r *Row) Scan(dest ...interface{}) error</a>\n</li>\n<li><a href=\"#Rows\">type Rows</a></li>\n<li> <a href=\"#Rows.Close\">func (rs *Rows) Close() error</a>\n</li>\n<li> <a href=\"#Rows.Columns\">func (rs *Rows) Columns() ([]string, error)</a>\n</li>\n<li> <a href=\"#Rows.Err\">func (rs *Rows) Err() error</a>\n</li>\n<li> <a href=\"#Rows.Next\">func (rs *Rows) Next() bool</a>\n</li>\n<li> <a href=\"#Rows.Scan\">func (rs *Rows) Scan(dest ...interface{}) error</a>\n</li>\n<li><a href=\"#Scanner\">type Scanner</a></li>\n<li><a href=\"#Stmt\">type Stmt</a></li>\n<li> <a href=\"#Stmt.Close\">func (s *Stmt) Close() error</a>\n</li>\n<li> <a href=\"#Stmt.Exec\">func (s *Stmt) Exec(args ...interface{}) (Result, error)</a>\n</li>\n<li> <a href=\"#Stmt.Query\">func (s *Stmt) Query(args ...interface{}) (*Rows, error)</a>\n</li>\n<li> <a href=\"#Stmt.QueryRow\">func (s *Stmt) QueryRow(args ...interface{}) *Row</a>\n</li>\n<li><a href=\"#Tx\">type Tx</a></li>\n<li> <a href=\"#Tx.Commit\">func (tx *Tx) Commit() error</a>\n</li>\n<li> <a href=\"#Tx.Exec\">func (tx *Tx) Exec(query string, args ...interface{}) (Result, error)</a>\n</li>\n<li> <a href=\"#Tx.Prepare\">func (tx *Tx) Prepare(query string) (*Stmt, error)</a>\n</li>\n<li> <a href=\"#Tx.Query\">func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error)</a>\n</li>\n<li> <a href=\"#Tx.QueryRow\">func (tx *Tx) QueryRow(query string, args ...interface{}) *Row</a>\n</li>\n<li> <a href=\"#Tx.Rollback\">func (tx *Tx) Rollback() error</a>\n</li>\n<li> <a href=\"#Tx.Stmt\">func (tx *Tx) Stmt(stmt *Stmt) *Stmt</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_DB_Query\">DB.Query</a></dd> <dd><a class=\"exampleLink\" href=\"#example_DB_QueryRow\">DB.QueryRow</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/database/sql/convert.go\">convert.go</a> <a href=\"https://golang.org/src/database/sql/sql.go\">sql.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrNoRows = errors.New(\"sql: no rows in result set\")</pre> <p> ErrNoRows is returned by Scan when QueryRow doesn't return a row. In such a case, QueryRow returns a placeholder *Row value that defers this error until a Scan. </p> <pre data-language=\"go\">var ErrTxDone = errors.New(\"sql: Transaction has already been committed or rolled back\")</pre> <h2 id=\"Drivers\">func Drivers  </h2> <pre data-language=\"go\">func Drivers() []string</pre> <p> Drivers returns a sorted list of the names of the registered drivers. </p> <h2 id=\"Register\">func Register  </h2> <pre data-language=\"go\">func Register(name string, driver driver.Driver)</pre> <p> Register makes a database driver available by the provided name. If Register is called twice with the same name or if driver is nil, it panics. </p> <h2 id=\"DB\">type DB  </h2> <pre data-language=\"go\">type DB struct {\n        // contains filtered or unexported fields\n}</pre> <p> DB is a database handle representing a pool of zero or more underlying connections. It's safe for concurrent use by multiple goroutines. </p> <p> The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. If the database has a concept of per-connection state, such state can only be reliably observed within a transaction. Once DB.Begin is called, the returned Tx is bound to a single connection. Once Commit or Rollback is called on the transaction, that transaction's connection is returned to DB's idle connection pool. The pool size can be controlled with SetMaxIdleConns. </p> <h3 id=\"Open\">func <a href=\"https://golang.org/src/database/sql/sql.go?s=13548:13605#L470\">Open</a>  </h3> <pre data-language=\"go\">func Open(driverName, dataSourceName string) (*DB, error)</pre> <p> Open opens a database specified by its database driver name and a driver-specific data source name, usually consisting of at least a database name and connection information. </p> <p> Most users will open a database via a driver-specific connection helper function that returns a *DB. No database drivers are included in the Go standard library. See <a href=\"https://golang.org/s/sqldrivers\">https://golang.org/s/sqldrivers</a> for a list of third-party drivers. </p> <p> Open may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call Ping. </p> <p> The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a DB. </p> <h3 id=\"DB.Begin\">func (*DB) <a href=\"https://golang.org/src/database/sql/sql.go?s=30060:30094#L1139\">Begin</a>  </h3> <pre data-language=\"go\">func (db *DB) Begin() (*Tx, error)</pre> <p> Begin starts a transaction. The isolation level is dependent on the driver. </p> <h3 id=\"DB.Close\">func (*DB) <a href=\"https://golang.org/src/database/sql/sql.go?s=14542:14569#L505\">Close</a>  </h3> <pre data-language=\"go\">func (db *DB) Close() error</pre> <p> Close closes the database, releasing any open resources. </p> <p> It is rare to Close a DB, as the DB handle is meant to be long-lived and shared between many goroutines. </p> <h3 id=\"DB.Driver\">func (*DB) <a href=\"https://golang.org/src/database/sql/sql.go?s=30697:30733#L1174\">Driver</a>  </h3> <pre data-language=\"go\">func (db *DB) Driver() driver.Driver</pre> <p> Driver returns the database's underlying driver. </p> <h3 id=\"DB.Exec\">func (*DB) <a href=\"https://golang.org/src/database/sql/sql.go?s=26644:26713#L996\">Exec</a>  </h3> <pre data-language=\"go\">func (db *DB) Exec(query string, args ...interface{}) (Result, error)</pre> <p> Exec executes a query without returning any rows. The args are for any placeholder parameters in the query. </p> <h3 id=\"DB.Ping\">func (*DB) <a href=\"https://golang.org/src/database/sql/sql.go?s=14097:14123#L489\">Ping</a>  </h3> <pre data-language=\"go\">func (db *DB) Ping() error</pre> <p> Ping verifies a connection to the database is still alive, establishing a connection if necessary. </p> <h3 id=\"DB.Prepare\">func (*DB) <a href=\"https://golang.org/src/database/sql/sql.go?s=25372:25422#L950\">Prepare</a>  </h3> <pre data-language=\"go\">func (db *DB) Prepare(query string) (*Stmt, error)</pre> <p> Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed. </p> <h3 id=\"DB.Query\">func (*DB) <a href=\"https://golang.org/src/database/sql/sql.go?s=27841:27910#L1048\">Query</a>  </h3> <pre data-language=\"go\">func (db *DB) Query(query string, args ...interface{}) (*Rows, error)</pre> <p> Query executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query. </p> <div id=\"example_DB_Query\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    age := 27\n    rows, err := db.Query(\"SELECT name FROM users WHERE age=?\", age)\n    if err != nil {\n            log.Fatal(err)\n    }\n    defer rows.Close()\n    for rows.Next() {\n            var name string\n            if err := rows.Scan(&amp;name); err != nil {\n                    log.Fatal(err)\n            }\n            fmt.Printf(\"%s is %d\\n\", name, age)\n    }\n    if err := rows.Err(); err != nil {\n            log.Fatal(err)\n    }\n</pre> </div> </div> <h3 id=\"DB.QueryRow\">func (*DB) <a href=\"https://golang.org/src/database/sql/sql.go?s=29836:29898#L1132\">QueryRow</a>  </h3> <pre data-language=\"go\">func (db *DB) QueryRow(query string, args ...interface{}) *Row</pre> <p> QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until Row's Scan method is called. </p> <div id=\"example_DB_QueryRow\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    id := 123\n    var username string\n    err := db.QueryRow(\"SELECT username FROM users WHERE id=?\", id).Scan(&amp;username)\n    switch {\n    case err == sql.ErrNoRows:\n            log.Printf(\"No user with that ID.\")\n    case err != nil:\n            log.Fatal(err)\n    default:\n            fmt.Printf(\"Username is %s\\n\", username)\n    }\n</pre> </div> </div> <h3 id=\"DB.SetConnMaxLifetime\">func (*DB) <a href=\"https://golang.org/src/database/sql/sql.go?s=16956:17005#L608\">SetConnMaxLifetime</a>  </h3> <pre data-language=\"go\">func (db *DB) SetConnMaxLifetime(d time.Duration)</pre> <p> SetConnMaxLifetime sets the maximum amount of time a connection may be reused. </p> <p> Expired connections may be closed lazily before reuse. </p> <p> If d &lt;= 0, connections are reused forever. </p> <h3 id=\"DB.SetMaxIdleConns\">func (*DB) <a href=\"https://golang.org/src/database/sql/sql.go?s=15640:15676#L557\">SetMaxIdleConns</a>  </h3> <pre data-language=\"go\">func (db *DB) SetMaxIdleConns(n int)</pre> <p> SetMaxIdleConns sets the maximum number of connections in the idle connection pool. </p> <p> If MaxOpenConns is greater than 0 but less than the new MaxIdleConns then the new MaxIdleConns will be reduced to match the MaxOpenConns limit </p> <p> If n &lt;= 0, no idle connections are retained. </p> <h3 id=\"DB.SetMaxOpenConns\">func (*DB) <a href=\"https://golang.org/src/database/sql/sql.go?s=16528:16564#L590\">SetMaxOpenConns</a>  </h3> <pre data-language=\"go\">func (db *DB) SetMaxOpenConns(n int)</pre> <p> SetMaxOpenConns sets the maximum number of open connections to the database. </p> <p> If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than MaxIdleConns, then MaxIdleConns will be reduced to match the new MaxOpenConns limit </p> <p> If n &lt;= 0, then there is no limit on the number of open connections. The default is 0 (unlimited). </p> <h3 id=\"DB.Stats\">func (*DB) <a href=\"https://golang.org/src/database/sql/sql.go?s=18605:18634#L688\">Stats</a>  </h3> <pre data-language=\"go\">func (db *DB) Stats() DBStats</pre> <p> Stats returns database statistics. </p> <h2 id=\"DBStats\">type DBStats  </h2> <pre data-language=\"go\">type DBStats struct {\n        // OpenConnections is the number of open connections to the database.\n        OpenConnections int\n}</pre> <p> DBStats contains database statistics. </p> <h2 id=\"NullBool\">type NullBool  </h2> <pre data-language=\"go\">type NullBool struct {\n        Bool  bool\n        Valid bool // Valid is true if Bool is not NULL\n}</pre> <p> NullBool represents a bool that may be null. NullBool implements the Scanner interface so it can be used as a scan destination, similar to NullString. </p> <h3 id=\"NullBool.Scan\">func (*NullBool) <a href=\"https://golang.org/src/database/sql/sql.go?s=4184:4232#L161\">Scan</a>  </h3> <pre data-language=\"go\">func (n *NullBool) Scan(value interface{}) error</pre> <p> Scan implements the Scanner interface. </p> <h3 id=\"NullBool.Value\">func (NullBool) <a href=\"https://golang.org/src/database/sql/sql.go?s=4409:4456#L171\">Value</a>  </h3> <pre data-language=\"go\">func (n NullBool) Value() (driver.Value, error)</pre> <p> Value implements the driver Valuer interface. </p> <h2 id=\"NullFloat64\">type NullFloat64  </h2> <pre data-language=\"go\">type NullFloat64 struct {\n        Float64 float64\n        Valid   bool // Valid is true if Float64 is not NULL\n}</pre> <p> NullFloat64 represents a float64 that may be null. NullFloat64 implements the Scanner interface so it can be used as a scan destination, similar to NullString. </p> <h3 id=\"NullFloat64.Scan\">func (*NullFloat64) <a href=\"https://golang.org/src/database/sql/sql.go?s=3550:3601#L135\">Scan</a>  </h3> <pre data-language=\"go\">func (n *NullFloat64) Scan(value interface{}) error</pre> <p> Scan implements the Scanner interface. </p> <h3 id=\"NullFloat64.Value\">func (NullFloat64) <a href=\"https://golang.org/src/database/sql/sql.go?s=3780:3830#L145\">Value</a>  </h3> <pre data-language=\"go\">func (n NullFloat64) Value() (driver.Value, error)</pre> <p> Value implements the driver Valuer interface. </p> <h2 id=\"NullInt64\">type NullInt64  </h2> <pre data-language=\"go\">type NullInt64 struct {\n        Int64 int64\n        Valid bool // Valid is true if Int64 is not NULL\n}</pre> <p> NullInt64 represents an int64 that may be null. NullInt64 implements the Scanner interface so it can be used as a scan destination, similar to NullString. </p> <h3 id=\"NullInt64.Scan\">func (*NullInt64) <a href=\"https://golang.org/src/database/sql/sql.go?s=2904:2953#L109\">Scan</a>  </h3> <pre data-language=\"go\">func (n *NullInt64) Scan(value interface{}) error</pre> <p> Scan implements the Scanner interface. </p> <h3 id=\"NullInt64.Value\">func (NullInt64) <a href=\"https://golang.org/src/database/sql/sql.go?s=3128:3176#L119\">Value</a>  </h3> <pre data-language=\"go\">func (n NullInt64) Value() (driver.Value, error)</pre> <p> Value implements the driver Valuer interface. </p> <h2 id=\"NullString\">type NullString  </h2> <pre data-language=\"go\">type NullString struct {\n        String string\n        Valid  bool // Valid is true if String is not NULL\n}</pre> <p> NullString represents a string that may be null. NullString implements the Scanner interface so it can be used as a scan destination: </p> <pre data-language=\"go\">var s NullString\nerr := db.QueryRow(\"SELECT name FROM foo WHERE id=?\", id).Scan(&amp;s)\n...\nif s.Valid {\n   // use s.String\n} else {\n   // NULL value\n}\n</pre> <h3 id=\"NullString.Scan\">func (*NullString) <a href=\"https://golang.org/src/database/sql/sql.go?s=2259:2310#L83\">Scan</a>  </h3> <pre data-language=\"go\">func (ns *NullString) Scan(value interface{}) error</pre> <p> Scan implements the Scanner interface. </p> <h3 id=\"NullString.Value\">func (NullString) <a href=\"https://golang.org/src/database/sql/sql.go?s=2492:2542#L93\">Value</a>  </h3> <pre data-language=\"go\">func (ns NullString) Value() (driver.Value, error)</pre> <p> Value implements the driver Valuer interface. </p> <h2 id=\"RawBytes\">type RawBytes  </h2> <pre data-language=\"go\">type RawBytes []byte</pre> <p> RawBytes is a byte slice that holds a reference to memory owned by the database itself. After a Scan into a RawBytes, the slice is only valid until the next call to Next, Scan, or Close. </p> <h2 id=\"Result\">type Result  </h2> <pre data-language=\"go\">type Result interface {\n        // LastInsertId returns the integer generated by the database\n        // in response to a command. Typically this will be from an\n        // \"auto increment\" column when inserting a new row. Not all\n        // databases support this feature, and the syntax of such\n        // statements varies.\n        LastInsertId() (int64, error)\n\n        // RowsAffected returns the number of rows affected by an\n        // update, insert, or delete. Not every database or database\n        // driver may support this.\n        RowsAffected() (int64, error)\n}</pre> <p> A Result summarizes an executed SQL command. </p> <h2 id=\"Row\">type Row  </h2> <pre data-language=\"go\">type Row struct {\n        // contains filtered or unexported fields\n}</pre> <p> Row is the result of calling QueryRow to select a single row. </p> <h3 id=\"Row.Scan\">func (*Row) <a href=\"https://golang.org/src/database/sql/sql.go?s=49543:49588#L1881\">Scan</a>  </h3> <pre data-language=\"go\">func (r *Row) Scan(dest ...interface{}) error</pre> <p> Scan copies the columns from the matched row into the values pointed at by dest. See the documentation on Rows.Scan for details. If more than one row matches the query, Scan uses the first row and discards the rest. If no row matches the query, Scan returns ErrNoRows. </p> <h2 id=\"Rows\">type Rows  </h2> <pre data-language=\"go\">type Rows struct {\n        // contains filtered or unexported fields\n}</pre> <p> Rows is the result of a query. Its cursor starts before the first row of the result set. Use Next to advance through the rows: </p> <pre data-language=\"go\">rows, err := db.Query(\"SELECT ...\")\n...\ndefer rows.Close()\nfor rows.Next() {\n    var id int\n    var name string\n    err = rows.Scan(&amp;id, &amp;name)\n    ...\n}\nerr = rows.Err() // get any error encountered during iteration\n...\n</pre> <h3 id=\"Rows.Close\">func (*Rows) <a href=\"https://golang.org/src/database/sql/sql.go?s=48825:48854#L1853\">Close</a>  </h3> <pre data-language=\"go\">func (rs *Rows) Close() error</pre> <p> Close closes the Rows, preventing further enumeration. If Next returns false, the Rows are closed automatically and it will suffice to check the result of Err. Close is idempotent and does not affect the result of Err. </p> <h3 id=\"Rows.Columns\">func (*Rows) <a href=\"https://golang.org/src/database/sql/sql.go?s=45463:45506#L1768\">Columns</a>  </h3> <pre data-language=\"go\">func (rs *Rows) Columns() ([]string, error)</pre> <p> Columns returns the column names. Columns returns an error if the rows are closed, or if the rows are from QueryRow and there was a deferred error. </p> <h3 id=\"Rows.Err\">func (*Rows) <a href=\"https://golang.org/src/database/sql/sql.go?s=45211:45238#L1758\">Err</a>  </h3> <pre data-language=\"go\">func (rs *Rows) Err() error</pre> <p> Err returns the error, if any, that was encountered during iteration. Err may be called after an explicit or implicit Close. </p> <h3 id=\"Rows.Next\">func (*Rows) <a href=\"https://golang.org/src/database/sql/sql.go?s=44814:44841#L1741\">Next</a>  </h3> <pre data-language=\"go\">func (rs *Rows) Next() bool</pre> <p> Next prepares the next result row for reading with the Scan method. It returns true on success, or false if there is no next result row or an error happened while preparing it. Err should be consulted to distinguish between the two cases. </p> <p> Every call to Scan, even the first one, must be preceded by a call to Next. </p> <h3 id=\"Rows.Scan\">func (*Rows) <a href=\"https://golang.org/src/database/sql/sql.go?s=48029:48076#L1829\">Scan</a>  </h3> <pre data-language=\"go\">func (rs *Rows) Scan(dest ...interface{}) error</pre> <p> Scan copies the columns in the current row into the values pointed at by dest. The number of values in dest must be the same as the number of columns in Rows. </p> <p> Scan converts columns read from the database into the following common Go types and special types provided by the sql package: </p> <pre data-language=\"go\">*string\n*[]byte\n*int, *int8, *int16, *int32, *int64\n*uint, *uint8, *uint16, *uint32, *uint64\n*bool\n*float32, *float64\n*interface{}\n*RawBytes\nany type implementing Scanner (see Scanner docs)\n</pre> <p> In the most simple case, if the type of the value from the source column is an integer, bool or string type T and dest is of type *T, Scan simply assigns the value through the pointer. </p> <p> Scan also converts between string and numeric types, as long as no information would be lost. While Scan stringifies all numbers scanned from numeric database columns into *string, scans into numeric types are checked for overflow. For example, a float64 with value 300 or a string with value \"300\" can scan into a uint16, but not into a uint8, though float64(255) or \"255\" can scan into a uint8. One exception is that scans of some float64 numbers to strings may lose information when stringifying. In general, scan floating point columns into *float64. </p> <p> If a dest argument has type *[]byte, Scan saves in that argument a copy of the corresponding data. The copy is owned by the caller and can be modified and held indefinitely. The copy can be avoided by using an argument of type *RawBytes instead; see the documentation for RawBytes for restrictions on its use. </p> <p> If an argument has type *interface{}, Scan copies the value provided by the underlying driver without conversion. When scanning from a source value of type []byte to *interface{}, a copy of the slice is made and the caller owns the result. </p> <p> Source values of type time.Time may be scanned into values of type *time.Time, *interface{}, *string, or *[]byte. When converting to the latter two, time.Format3339Nano is used. </p> <p> Source values of type bool may be scanned into types *bool, *interface{}, *string, *[]byte, or *RawBytes. </p> <p> For scanning into *bool, the source may be true, false, 1, 0, or string inputs parseable by strconv.ParseBool. </p> <h2 id=\"Scanner\">type Scanner  </h2> <pre data-language=\"go\">type Scanner interface {\n        // Scan assigns a value from a database driver.\n        //\n        // The src value will be of one of the following types:\n        //\n        //    int64\n        //    float64\n        //    bool\n        //    []byte\n        //    string\n        //    time.Time\n        //    nil - for NULL values\n        //\n        // An error should be returned if the value cannot be stored\n        // without loss of information.\n        Scan(src interface{}) error\n}</pre> <p> Scanner is an interface used by Scan. </p> <h2 id=\"Stmt\">type Stmt  </h2> <pre data-language=\"go\">type Stmt struct {\n        // contains filtered or unexported fields\n}</pre> <p> Stmt is a prepared statement. A Stmt is safe for concurrent use by multiple goroutines. </p> <h3 id=\"Stmt.Close\">func (*Stmt) <a href=\"https://golang.org/src/database/sql/sql.go?s=43176:43204#L1673\">Close</a>  </h3> <pre data-language=\"go\">func (s *Stmt) Close() error</pre> <p> Close closes the statement. </p> <h3 id=\"Stmt.Exec\">func (*Stmt) <a href=\"https://golang.org/src/database/sql/sql.go?s=37789:37845#L1447\">Exec</a>  </h3> <pre data-language=\"go\">func (s *Stmt) Exec(args ...interface{}) (Result, error)</pre> <p> Exec executes a prepared statement with the given arguments and returns a Result summarizing the effect of the statement. </p> <h3 id=\"Stmt.Query\">func (*Stmt) <a href=\"https://golang.org/src/database/sql/sql.go?s=41070:41126#L1588\">Query</a>  </h3> <pre data-language=\"go\">func (s *Stmt) Query(args ...interface{}) (*Rows, error)</pre> <p> Query executes a prepared query statement with the given arguments and returns the query results as a *Rows. </p> <h3 id=\"Stmt.QueryRow\">func (*Stmt) <a href=\"https://golang.org/src/database/sql/sql.go?s=42990:43039#L1664\">QueryRow</a>  </h3> <pre data-language=\"go\">func (s *Stmt) QueryRow(args ...interface{}) *Row</pre> <p> QueryRow executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest. </p> <p> Example usage: </p> <pre data-language=\"go\">var name string\nerr := nameByUseridStmt.QueryRow(id).Scan(&amp;name)\n</pre> <h2 id=\"Tx\">type Tx  </h2> <pre data-language=\"go\">type Tx struct {\n        // contains filtered or unexported fields\n}</pre> <p> Tx is an in-progress database transaction. </p> <p> A transaction must end with a call to Commit or Rollback. </p> <p> After a call to Commit or Rollback, all operations on the transaction fail with ErrTxDone. </p> <p> The statements prepared for a transaction by calling the transaction's Prepare or Stmt methods are closed by the call to Commit or Rollback. </p> <h3 id=\"Tx.Commit\">func (*Tx) <a href=\"https://golang.org/src/database/sql/sql.go?s=32174:32202#L1238\">Commit</a>  </h3> <pre data-language=\"go\">func (tx *Tx) Commit() error</pre> <p> Commit commits the transaction. </p> <h3 id=\"Tx.Exec\">func (*Tx) <a href=\"https://golang.org/src/database/sql/sql.go?s=35397:35466#L1360\">Exec</a>  </h3> <pre data-language=\"go\">func (tx *Tx) Exec(query string, args ...interface{}) (Result, error)</pre> <p> Exec executes a query that doesn't return rows. For example: an INSERT and UPDATE. </p> <h3 id=\"Tx.Prepare\">func (*Tx) <a href=\"https://golang.org/src/database/sql/sql.go?s=32920:32970#L1273\">Prepare</a>  </h3> <pre data-language=\"go\">func (tx *Tx) Prepare(query string) (*Stmt, error)</pre> <p> Prepare creates a prepared statement for use within a transaction. </p> <p> The returned statement operates within the transaction and can no longer be used once the transaction has been committed or rolled back. </p> <p> To use an existing prepared statement on this transaction, see Tx.Stmt. </p> <h3 id=\"Tx.Query\">func (*Tx) <a href=\"https://golang.org/src/database/sql/sql.go?s=36106:36175#L1394\">Query</a>  </h3> <pre data-language=\"go\">func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error)</pre> <p> Query executes a query that returns rows, typically a SELECT. </p> <h3 id=\"Tx.QueryRow\">func (*Tx) <a href=\"https://golang.org/src/database/sql/sql.go?s=36505:36567#L1406\">QueryRow</a>  </h3> <pre data-language=\"go\">func (tx *Tx) QueryRow(query string, args ...interface{}) *Row</pre> <p> QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until Row's Scan method is called. </p> <h3 id=\"Tx.Rollback\">func (*Tx) <a href=\"https://golang.org/src/database/sql/sql.go?s=32416:32446#L1253\">Rollback</a>  </h3> <pre data-language=\"go\">func (tx *Tx) Rollback() error</pre> <p> Rollback aborts the transaction. </p> <h3 id=\"Tx.Stmt\">func (*Tx) <a href=\"https://golang.org/src/database/sql/sql.go?s=34547:34583#L1326\">Stmt</a>  </h3> <pre data-language=\"go\">func (tx *Tx) Stmt(stmt *Stmt) *Stmt</pre> <p> Stmt returns a transaction-specific prepared statement from an existing statement. </p> <p> Example: </p> <pre data-language=\"go\">updateMoney, err := db.Prepare(\"UPDATE balance SET money=money+? WHERE id=?\")\n...\ntx, err := db.Begin()\n...\nres, err := tx.Stmt(updateMoney).Exec(123.45, 98293203)\n</pre> <p> The returned statement operates within the transaction and can no longer be used once the transaction has been committed or rolled back. </p> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"driver/index\">driver</a> </td> <td class=\"pkg-synopsis\"> Package driver defines interfaces to be implemented by database drivers as used by package sql. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/database/sql/\" class=\"_attribution-link\">https://golang.org/pkg/database/sql/</a>\n  </p>\n</div>\n","go/parser/index":"<h1>Package parser</h1>     <ul id=\"short-nav\">\n<li><code>import \"go/parser\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package parser implements a parser for Go source files. Input may be provided in a variety of forms (see the various Parse* functions); the output is an abstract syntax tree (AST) representing the Go source. The parser is invoked through one of the Parse* functions. </p> <p> The parser accepts a larger language than is syntactically permitted by the Go spec, for simplicity, and for improved robustness in the presence of syntax errors. For instance, in method declarations, the receiver is treated like an ordinary parameter list and thus may contain multiple entries where the spec permits exactly one. Consequently, the corresponding field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#ParseDir\">func ParseDir(fset *token.FileSet, path string, filter func(os.FileInfo) bool, mode Mode) (pkgs map[string]*ast.Package, first error)</a></li>\n<li><a href=\"#ParseExpr\">func ParseExpr(x string) (ast.Expr, error)</a></li>\n<li><a href=\"#ParseExprFrom\">func ParseExprFrom(fset *token.FileSet, filename string, src interface{}, mode Mode) (ast.Expr, error)</a></li>\n<li><a href=\"#ParseFile\">func ParseFile(fset *token.FileSet, filename string, src interface{}, mode Mode) (f *ast.File, err error)</a></li>\n<li><a href=\"#Mode\">type Mode</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_ParseFile\">ParseFile</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/go/parser/interface.go\">interface.go</a> <a href=\"https://golang.org/src/go/parser/parser.go\">parser.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"ParseDir\">func ParseDir  </h2> <pre data-language=\"go\">func ParseDir(fset *token.FileSet, path string, filter func(os.FileInfo) bool, mode Mode) (pkgs map[string]*ast.Package, first error)</pre> <p> ParseDir calls ParseFile for all files with names ending in \".go\" in the directory specified by path and returns a map of package name -&gt; package AST with all the packages found. </p> <p> If filter != nil, only the files with os.FileInfo entries passing through the filter (and ending in \".go\") are considered. The mode bits are passed to ParseFile unchanged. Position information is recorded in fset, which must not be nil. </p> <p> If the directory couldn't be read, a nil map and the respective error are returned. If a parse error occurred, a non-nil but incomplete map and the first error encountered are returned. </p> <h2 id=\"ParseExpr\">func ParseExpr  </h2> <pre data-language=\"go\">func ParseExpr(x string) (ast.Expr, error)</pre> <p> ParseExpr is a convenience function for obtaining the AST of an expression x. The position information recorded in the AST is undefined. The filename used in error messages is the empty string. </p> <h2 id=\"ParseExprFrom\">func ParseExprFrom  </h2> <pre data-language=\"go\">func ParseExprFrom(fset *token.FileSet, filename string, src interface{}, mode Mode) (ast.Expr, error)</pre> <p> ParseExprFrom is a convenience function for parsing an expression. The arguments have the same meaning as for Parse, but the source must be a valid Go (type or value) expression. Specifically, fset must not be nil. </p> <h2 id=\"ParseFile\">func ParseFile  </h2> <pre data-language=\"go\">func ParseFile(fset *token.FileSet, filename string, src interface{}, mode Mode) (f *ast.File, err error)</pre> <p> ParseFile parses the source code of a single Go source file and returns the corresponding ast.File node. The source code may be provided via the filename of the source file, or via the src parameter. </p> <p> If src != nil, ParseFile parses the source from src and the filename is only used when recording position information. The type of the argument for the src parameter must be string, []byte, or io.Reader. If src == nil, ParseFile parses the file specified by filename. </p> <p> The mode parameter controls the amount of source text parsed and other optional parser functionality. Position information is recorded in the file set fset, which must not be nil. </p> <p> If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with ast.Bad* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by file position. </p> <div id=\"example_ParseFile\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"go/parser\"\n\t\"go/token\"\n)\n\nfunc main() {\n\tfset := token.NewFileSet() // positions are relative to fset\n\n\t// Parse the file containing this very example\n\t// but stop after processing the imports.\n\tf, err := parser.ParseFile(fset, \"example_test.go\", nil, parser.ImportsOnly)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// Print the imports from the file's AST.\n\tfor _, s := range f.Imports {\n\t\tfmt.Println(s.Path.Value)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"Mode\">type Mode  </h2> <pre data-language=\"go\">type Mode uint</pre> <p> A Mode value is a set of flags (or 0). They control the amount of source code parsed and other optional parser functionality. </p> <pre data-language=\"go\">const (\n        PackageClauseOnly Mode             = 1 &lt;&lt; iota // stop parsing after package clause\n        ImportsOnly                                    // stop parsing after import declarations\n        ParseComments                                  // parse comments and add them to AST\n        Trace                                          // print a trace of parsed productions\n        DeclarationErrors                              // report declaration errors\n        SpuriousErrors                                 // same as AllErrors, for backward-compatibility\n        AllErrors         = SpuriousErrors             // report all errors (not just the first 10 on different lines)\n)</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/go/parser/\" class=\"_attribution-link\">https://golang.org/pkg/go/parser/</a>\n  </p>\n</div>\n","hash/adler32/index":"<h1>Package adler32</h1>     <ul id=\"short-nav\">\n<li><code>import \"hash/adler32\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package adler32 implements the Adler-32 checksum. </p> <p> It is defined in RFC 1950: </p> <pre data-language=\"go\">Adler-32 is composed of two sums accumulated per byte: s1 is\nthe sum of all bytes, s2 is the sum of all s1 values. Both sums\nare done modulo 65521. s1 is initialized to 1, s2 to zero.  The\nAdler-32 checksum is stored as s2*65536 + s1 in most-\nsignificant-byte first (network) order.\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#Checksum\">func Checksum(data []byte) uint32</a></li>\n<li><a href=\"#New\">func New() hash.Hash32</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/hash/adler32/adler32.go\">adler32.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const Size = 4</pre> <p> The size of an Adler-32 checksum in bytes. </p> <h2 id=\"Checksum\">func Checksum  </h2> <pre data-language=\"go\">func Checksum(data []byte) uint32</pre> <p> Checksum returns the Adler-32 checksum of data. </p> <h2 id=\"New\">func New  </h2> <pre data-language=\"go\">func New() hash.Hash32</pre> <p> New returns a new hash.Hash32 computing the Adler-32 checksum. Its Sum method will lay the value out in big-endian byte order. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/hash/adler32/\" class=\"_attribution-link\">https://golang.org/pkg/hash/adler32/</a>\n  </p>\n</div>\n","go/scanner/index":"<h1>Package scanner</h1>     <ul id=\"short-nav\">\n<li><code>import \"go/scanner\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package scanner implements a scanner for Go source text. It takes a []byte as source which can then be tokenized through repeated calls to the Scan method. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#PrintError\">func PrintError(w io.Writer, err error)</a></li>\n<li><a href=\"#Error\">type Error</a></li>\n<li> <a href=\"#Error.Error\">func (e Error) Error() string</a>\n</li>\n<li><a href=\"#ErrorHandler\">type ErrorHandler</a></li>\n<li><a href=\"#ErrorList\">type ErrorList</a></li>\n<li> <a href=\"#ErrorList.Add\">func (p *ErrorList) Add(pos token.Position, msg string)</a>\n</li>\n<li> <a href=\"#ErrorList.Err\">func (p ErrorList) Err() error</a>\n</li>\n<li> <a href=\"#ErrorList.Error\">func (p ErrorList) Error() string</a>\n</li>\n<li> <a href=\"#ErrorList.Len\">func (p ErrorList) Len() int</a>\n</li>\n<li> <a href=\"#ErrorList.Less\">func (p ErrorList) Less(i, j int) bool</a>\n</li>\n<li> <a href=\"#ErrorList.RemoveMultiples\">func (p *ErrorList) RemoveMultiples()</a>\n</li>\n<li> <a href=\"#ErrorList.Reset\">func (p *ErrorList) Reset()</a>\n</li>\n<li> <a href=\"#ErrorList.Sort\">func (p ErrorList) Sort()</a>\n</li>\n<li> <a href=\"#ErrorList.Swap\">func (p ErrorList) Swap(i, j int)</a>\n</li>\n<li><a href=\"#Mode\">type Mode</a></li>\n<li><a href=\"#Scanner\">type Scanner</a></li>\n<li> <a href=\"#Scanner.Init\">func (s *Scanner) Init(file *token.File, src []byte, err ErrorHandler, mode Mode)</a>\n</li>\n<li> <a href=\"#Scanner.Scan\">func (s *Scanner) Scan() (pos token.Pos, tok token.Token, lit string)</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Scanner_Scan\">Scanner.Scan</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/go/scanner/errors.go\">errors.go</a> <a href=\"https://golang.org/src/go/scanner/scanner.go\">scanner.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"PrintError\">func PrintError  </h2> <pre data-language=\"go\">func PrintError(w io.Writer, err error)</pre> <p> PrintError is a utility function that prints a list of errors to w, one error per line, if the err parameter is an ErrorList. Otherwise it prints the err string. </p> <h2 id=\"Error\">type Error  </h2> <pre data-language=\"go\">type Error struct {\n        Pos token.Position\n        Msg string\n}</pre> <p> In an ErrorList, an error is represented by an *Error. The position Pos, if valid, points to the beginning of the offending token, and the error condition is described by Msg. </p> <h3 id=\"Error.Error\">func (Error) <a href=\"https://golang.org/src/go/scanner/errors.go?s=509:538#L15\">Error</a>  </h3> <pre data-language=\"go\">func (e Error) Error() string</pre> <p> Error implements the error interface. </p> <h2 id=\"ErrorHandler\">type ErrorHandler  </h2> <pre data-language=\"go\">type ErrorHandler func(pos token.Position, msg string)</pre> <p> An ErrorHandler may be provided to Scanner.Init. If a syntax error is encountered and a handler was installed, the handler is called with a position and an error message. The position points to the beginning of the offending token. </p> <h2 id=\"ErrorList\">type ErrorList  </h2> <pre data-language=\"go\">type ErrorList []*Error</pre> <p> ErrorList is a list of *Errors. The zero value for an ErrorList is an empty ErrorList ready to use. </p> <h3 id=\"ErrorList.Add\">func (*ErrorList) <a href=\"https://golang.org/src/go/scanner/errors.go?s=954:1009#L30\">Add</a>  </h3> <pre data-language=\"go\">func (p *ErrorList) Add(pos token.Position, msg string)</pre> <p> Add adds an Error with given position and error message to an ErrorList. </p> <h3 id=\"ErrorList.Err\">func (ErrorList) <a href=\"https://golang.org/src/go/scanner/errors.go?s=2638:2668#L95\">Err</a>  </h3> <pre data-language=\"go\">func (p ErrorList) Err() error</pre> <p> Err returns an error equivalent to this error list. If the list is empty, Err returns nil. </p> <h3 id=\"ErrorList.Error\">func (ErrorList) <a href=\"https://golang.org/src/go/scanner/errors.go?s=2358:2391#L83\">Error</a>  </h3> <pre data-language=\"go\">func (p ErrorList) Error() string</pre> <p> An ErrorList implements the error interface. </p> <h3 id=\"ErrorList.Len\">func (ErrorList) <a href=\"https://golang.org/src/go/scanner/errors.go?s=1185:1213#L38\">Len</a>  </h3> <pre data-language=\"go\">func (p ErrorList) Len() int</pre> <p> ErrorList implements the sort Interface. </p> <h3 id=\"ErrorList.Less\">func (ErrorList) <a href=\"https://golang.org/src/go/scanner/errors.go?s=1300:1338#L41\">Less</a>  </h3> <pre data-language=\"go\">func (p ErrorList) Less(i, j int) bool</pre> <h3 id=\"ErrorList.RemoveMultiples\">func (*ErrorList) <a href=\"https://golang.org/src/go/scanner/errors.go?s=2019:2056#L68\">RemoveMultiples</a>  </h3> <pre data-language=\"go\">func (p *ErrorList) RemoveMultiples()</pre> <p> RemoveMultiples sorts an ErrorList and removes all but the first error per line. </p> <h3 id=\"ErrorList.Reset\">func (*ErrorList) <a href=\"https://golang.org/src/go/scanner/errors.go?s=1093:1120#L35\">Reset</a>  </h3> <pre data-language=\"go\">func (p *ErrorList) Reset()</pre> <p> Reset resets an ErrorList to no errors. </p> <h3 id=\"ErrorList.Sort\">func (ErrorList) <a href=\"https://golang.org/src/go/scanner/errors.go?s=1890:1915#L63\">Sort</a>  </h3> <pre data-language=\"go\">func (p ErrorList) Sort()</pre> <p> Sort sorts an ErrorList. *Error entries are sorted by position, other errors are sorted by error message, and before any *Error entry. </p> <h3 id=\"ErrorList.Swap\">func (ErrorList) <a href=\"https://golang.org/src/go/scanner/errors.go?s=1237:1270#L39\">Swap</a>  </h3> <pre data-language=\"go\">func (p ErrorList) Swap(i, j int)</pre> <h2 id=\"Mode\">type Mode  </h2> <pre data-language=\"go\">type Mode uint</pre> <p> A mode value is a set of flags (or 0). They control scanner behavior. </p> <pre data-language=\"go\">const (\n        ScanComments Mode = 1 &lt;&lt; iota // return comments as COMMENT tokens\n\n)</pre> <h2 id=\"Scanner\">type Scanner  </h2> <pre data-language=\"go\">type Scanner struct {\n\n        // public state - ok to modify\n        ErrorCount int // number of errors encountered\n        // contains filtered or unexported fields\n}</pre> <p> A Scanner holds the scanner's internal state while processing a given text. It can be allocated as part of another data structure but must be initialized via Init before use. </p> <h3 id=\"Scanner.Init\">func (*Scanner) <a href=\"https://golang.org/src/go/scanner/scanner.go?s=3427:3508#L103\">Init</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Init(file *token.File, src []byte, err ErrorHandler, mode Mode)</pre> <p> Init prepares the scanner s to tokenize the text src by setting the scanner at the beginning of src. The scanner uses the file set file for position information and it adds line information for each line. It is ok to re-use the same file when re-scanning the same file as line information which is already present is ignored. Init causes a panic if the file size does not match the src size. </p> <p> Calls to Scan will invoke the error handler err if they encounter a syntax error and err is not nil. Also, for each error encountered, the Scanner field ErrorCount is incremented by one. The mode parameter determines how comments are handled. </p> <p> Note that Init may call err if there is an error in the first character of the file. </p> <h3 id=\"Scanner.Scan\">func (*Scanner) <a href=\"https://golang.org/src/go/scanner/scanner.go?s=13688:13757#L588\">Scan</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Scan() (pos token.Pos, tok token.Token, lit string)</pre> <p> Scan scans the next token and returns the token position, the token, and its literal string if applicable. The source end is indicated by token.EOF. </p> <p> If the returned token is a literal (token.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING) or token.COMMENT, the literal string has the corresponding value. </p> <p> If the returned token is a keyword, the literal string is the keyword. </p> <p> If the returned token is token.SEMICOLON, the corresponding literal string is \";\" if the semicolon was present in the source, and \"\\n\" if the semicolon was inserted because of a newline or at EOF. </p> <p> If the returned token is token.ILLEGAL, the literal string is the offending character. </p> <p> In all other cases, Scan returns an empty literal string. </p> <p> For more tolerant parsing, Scan will return a valid token if possible even if a syntax error was encountered. Thus, even if the resulting token sequence contains no illegal tokens, a client may not assume that no error occurred. Instead it must check the scanner's ErrorCount or the number of calls of the error handler, if there was one installed. </p> <p> Scan adds line information to the file added to the file set with Init. Token positions are relative to that file and thus relative to the file set. </p> <div id=\"example_Scanner_Scan\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"go/scanner\"\n\t\"go/token\"\n)\n\nfunc main() {\n\t// src is the input that we want to tokenize.\n\tsrc := []byte(\"cos(x) + 1i*sin(x) // Euler\")\n\n\t// Initialize the scanner.\n\tvar s scanner.Scanner\n\tfset := token.NewFileSet()                      // positions are relative to fset\n\tfile := fset.AddFile(\"\", fset.Base(), len(src)) // register input \"file\"\n\ts.Init(file, src, nil /* no error handler */, scanner.ScanComments)\n\n\t// Repeated calls to Scan yield the token sequence found in the input.\n\tfor {\n\t\tpos, tok, lit := s.Scan()\n\t\tif tok == token.EOF {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"%s\\t%s\\t%q\\n\", fset.Position(pos), tok, lit)\n\t}\n\n}\n</pre> </div> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/go/scanner/\" class=\"_attribution-link\">https://golang.org/pkg/go/scanner/</a>\n  </p>\n</div>\n","hash/index":"<h1>Package hash</h1>     <ul id=\"short-nav\">\n<li><code>import \"hash\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package hash provides interfaces for hash functions. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Hash\">type Hash</a></li>\n<li><a href=\"#Hash32\">type Hash32</a></li>\n<li><a href=\"#Hash64\">type Hash64</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/hash/hash.go\">hash.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Hash\">type Hash  </h2> <pre data-language=\"go\">type Hash interface {\n        // Write (via the embedded io.Writer interface) adds more data to the running hash.\n        // It never returns an error.\n        io.Writer\n\n        // Sum appends the current hash to b and returns the resulting slice.\n        // It does not change the underlying hash state.\n        Sum(b []byte) []byte\n\n        // Reset resets the Hash to its initial state.\n        Reset()\n\n        // Size returns the number of bytes Sum will return.\n        Size() int\n\n        // BlockSize returns the hash's underlying block size.\n        // The Write method must be able to accept any amount\n        // of data, but it may operate more efficiently if all writes\n        // are a multiple of the block size.\n        BlockSize() int\n}</pre> <p> Hash is the common interface implemented by all hash functions. </p> <h2 id=\"Hash32\">type Hash32  </h2> <pre data-language=\"go\">type Hash32 interface {\n        Hash\n        Sum32() uint32\n}</pre> <p> Hash32 is the common interface implemented by all 32-bit hash functions. </p> <h2 id=\"Hash64\">type Hash64  </h2> <pre data-language=\"go\">type Hash64 interface {\n        Hash\n        Sum64() uint64\n}</pre> <p> Hash64 is the common interface implemented by all 64-bit hash functions. </p> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"adler32/index\">adler32</a> </td> <td class=\"pkg-synopsis\"> Package adler32 implements the Adler-32 checksum. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"crc32/index\">crc32</a> </td> <td class=\"pkg-synopsis\"> Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"crc64/index\">crc64</a> </td> <td class=\"pkg-synopsis\"> Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"fnv/index\">fnv</a> </td> <td class=\"pkg-synopsis\"> Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/hash/\" class=\"_attribution-link\">https://golang.org/pkg/hash/</a>\n  </p>\n</div>\n","crypto/tls/index":"<h1>Package tls</h1>     <ul id=\"short-nav\">\n<li><code>import \"crypto/tls\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package tls partially implements TLS 1.2, as specified in RFC 5246. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#Listen\">func Listen(network, laddr string, config *Config) (net.Listener, error)</a></li>\n<li><a href=\"#NewListener\">func NewListener(inner net.Listener, config *Config) net.Listener</a></li>\n<li><a href=\"#Certificate\">type Certificate</a></li>\n<li> <a href=\"#LoadX509KeyPair\">func LoadX509KeyPair(certFile, keyFile string) (Certificate, error)</a>\n</li>\n<li> <a href=\"#X509KeyPair\">func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)</a>\n</li>\n<li><a href=\"#ClientAuthType\">type ClientAuthType</a></li>\n<li><a href=\"#ClientHelloInfo\">type ClientHelloInfo</a></li>\n<li><a href=\"#ClientSessionCache\">type ClientSessionCache</a></li>\n<li> <a href=\"#NewLRUClientSessionCache\">func NewLRUClientSessionCache(capacity int) ClientSessionCache</a>\n</li>\n<li><a href=\"#ClientSessionState\">type ClientSessionState</a></li>\n<li><a href=\"#Config\">type Config</a></li>\n<li> <a href=\"#Config.BuildNameToCertificate\">func (c *Config) BuildNameToCertificate()</a>\n</li>\n<li> <a href=\"#Config.SetSessionTicketKeys\">func (c *Config) SetSessionTicketKeys(keys [][32]byte)</a>\n</li>\n<li><a href=\"#Conn\">type Conn</a></li>\n<li> <a href=\"#Client\">func Client(conn net.Conn, config *Config) *Conn</a>\n</li>\n<li> <a href=\"#Dial\">func Dial(network, addr string, config *Config) (*Conn, error)</a>\n</li>\n<li> <a href=\"#DialWithDialer\">func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)</a>\n</li>\n<li> <a href=\"#Server\">func Server(conn net.Conn, config *Config) *Conn</a>\n</li>\n<li> <a href=\"#Conn.Close\">func (c *Conn) Close() error</a>\n</li>\n<li> <a href=\"#Conn.ConnectionState\">func (c *Conn) ConnectionState() ConnectionState</a>\n</li>\n<li> <a href=\"#Conn.Handshake\">func (c *Conn) Handshake() error</a>\n</li>\n<li> <a href=\"#Conn.LocalAddr\">func (c *Conn) LocalAddr() net.Addr</a>\n</li>\n<li> <a href=\"#Conn.OCSPResponse\">func (c *Conn) OCSPResponse() []byte</a>\n</li>\n<li> <a href=\"#Conn.Read\">func (c *Conn) Read(b []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#Conn.RemoteAddr\">func (c *Conn) RemoteAddr() net.Addr</a>\n</li>\n<li> <a href=\"#Conn.SetDeadline\">func (c *Conn) SetDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#Conn.SetReadDeadline\">func (c *Conn) SetReadDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#Conn.SetWriteDeadline\">func (c *Conn) SetWriteDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#Conn.VerifyHostname\">func (c *Conn) VerifyHostname(host string) error</a>\n</li>\n<li> <a href=\"#Conn.Write\">func (c *Conn) Write(b []byte) (int, error)</a>\n</li>\n<li><a href=\"#ConnectionState\">type ConnectionState</a></li>\n<li><a href=\"#CurveID\">type CurveID</a></li>\n<li><a href=\"#RecordHeaderError\">type RecordHeaderError</a></li>\n<li> <a href=\"#RecordHeaderError.Error\">func (e RecordHeaderError) Error() string</a>\n</li>\n<li><a href=\"#RenegotiationSupport\">type RenegotiationSupport</a></li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Dial\">Dial</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/crypto/tls/alert.go\">alert.go</a> <a href=\"https://golang.org/src/crypto/tls/cipher_suites.go\">cipher_suites.go</a> <a href=\"https://golang.org/src/crypto/tls/common.go\">common.go</a> <a href=\"https://golang.org/src/crypto/tls/conn.go\">conn.go</a> <a href=\"https://golang.org/src/crypto/tls/handshake_client.go\">handshake_client.go</a> <a href=\"https://golang.org/src/crypto/tls/handshake_messages.go\">handshake_messages.go</a> <a href=\"https://golang.org/src/crypto/tls/handshake_server.go\">handshake_server.go</a> <a href=\"https://golang.org/src/crypto/tls/key_agreement.go\">key_agreement.go</a> <a href=\"https://golang.org/src/crypto/tls/prf.go\">prf.go</a> <a href=\"https://golang.org/src/crypto/tls/ticket.go\">ticket.go</a> <a href=\"https://golang.org/src/crypto/tls/tls.go\">tls.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        TLS_RSA_WITH_RC4_128_SHA                uint16 = 0x0005\n        TLS_RSA_WITH_3DES_EDE_CBC_SHA           uint16 = 0x000a\n        TLS_RSA_WITH_AES_128_CBC_SHA            uint16 = 0x002f\n        TLS_RSA_WITH_AES_256_CBC_SHA            uint16 = 0x0035\n        TLS_RSA_WITH_AES_128_GCM_SHA256         uint16 = 0x009c\n        TLS_RSA_WITH_AES_256_GCM_SHA384         uint16 = 0x009d\n        TLS_ECDHE_ECDSA_WITH_RC4_128_SHA        uint16 = 0xc007\n        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    uint16 = 0xc009\n        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    uint16 = 0xc00a\n        TLS_ECDHE_RSA_WITH_RC4_128_SHA          uint16 = 0xc011\n        TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     uint16 = 0xc012\n        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      uint16 = 0xc013\n        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      uint16 = 0xc014\n        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   uint16 = 0xc02f\n        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xc02b\n        TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   uint16 = 0xc030\n        TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 uint16 = 0xc02c\n\n        // TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator\n        // that the client is doing version fallback. See\n        // https://tools.ietf.org/html/rfc7507.\n        TLS_FALLBACK_SCSV uint16 = 0x5600\n)</pre> <p> A list of cipher suite IDs that are, or have been, implemented by this package. </p> <p> Taken from <a href=\"http://www.iana.org/assignments/tls-parameters/tls-parameters.xml\">http://www.iana.org/assignments/tls-parameters/tls-parameters.xml</a> </p> <pre data-language=\"go\">const (\n        VersionSSL30 = 0x0300\n        VersionTLS10 = 0x0301\n        VersionTLS11 = 0x0302\n        VersionTLS12 = 0x0303\n)</pre> <h2 id=\"Listen\">func Listen  </h2> <pre data-language=\"go\">func Listen(network, laddr string, config *Config) (net.Listener, error)</pre> <p> Listen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. </p> <h2 id=\"NewListener\">func NewListener  </h2> <pre data-language=\"go\">func NewListener(inner net.Listener, config *Config) net.Listener</pre> <p> NewListener creates a Listener which accepts connections from an inner Listener and wraps each connection with Server. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. </p> <h2 id=\"Certificate\">type Certificate  </h2> <pre data-language=\"go\">type Certificate struct {\n        Certificate [][]byte\n        // PrivateKey contains the private key corresponding to the public key\n        // in Leaf. For a server, this must implement crypto.Signer and/or\n        // crypto.Decrypter, with an RSA or ECDSA PublicKey. For a client\n        // (performing client authentication), this must be a crypto.Signer\n        // with an RSA or ECDSA PublicKey.\n        PrivateKey crypto.PrivateKey\n        // OCSPStaple contains an optional OCSP response which will be served\n        // to clients that request it.\n        OCSPStaple []byte\n        // SignedCertificateTimestamps contains an optional list of Signed\n        // Certificate Timestamps which will be served to clients that request it.\n        SignedCertificateTimestamps [][]byte\n        // Leaf is the parsed form of the leaf certificate, which may be\n        // initialized using x509.ParseCertificate to reduce per-handshake\n        // processing for TLS clients doing client authentication. If nil, the\n        // leaf certificate will be parsed as needed.\n        Leaf *x509.Certificate\n}</pre> <p> A Certificate is a chain of one or more certificates, leaf first. </p> <h3 id=\"LoadX509KeyPair\">func <a href=\"https://golang.org/src/crypto/tls/tls.go?s=5382:5449#L168\">LoadX509KeyPair</a>  </h3> <pre data-language=\"go\">func LoadX509KeyPair(certFile, keyFile string) (Certificate, error)</pre> <p> LoadX509KeyPair reads and parses a public/private key pair from a pair of files. The files must contain PEM encoded data. The certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained. </p> <h3 id=\"X509KeyPair\">func <a href=\"https://golang.org/src/crypto/tls/tls.go?s=5890:5961#L183\">X509KeyPair</a>  </h3> <pre data-language=\"go\">func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)</pre> <p> X509KeyPair parses a public/private key pair from a pair of PEM encoded data. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained. </p> <h2 id=\"ClientAuthType\">type ClientAuthType  </h2> <pre data-language=\"go\">type ClientAuthType int</pre> <p> ClientAuthType declares the policy the server will follow for TLS Client Authentication. </p> <pre data-language=\"go\">const (\n        NoClientCert ClientAuthType = iota\n        RequestClientCert\n        RequireAnyClientCert\n        VerifyClientCertIfGiven\n        RequireAndVerifyClientCert\n)</pre> <h2 id=\"ClientHelloInfo\">type ClientHelloInfo  </h2> <pre data-language=\"go\">type ClientHelloInfo struct {\n        // CipherSuites lists the CipherSuites supported by the client (e.g.\n        // TLS_RSA_WITH_RC4_128_SHA).\n        CipherSuites []uint16\n\n        // ServerName indicates the name of the server requested by the client\n        // in order to support virtual hosting. ServerName is only set if the\n        // client is using SNI (see\n        // http://tools.ietf.org/html/rfc4366#section-3.1).\n        ServerName string\n\n        // SupportedCurves lists the elliptic curves supported by the client.\n        // SupportedCurves is set only if the Supported Elliptic Curves\n        // Extension is being used (see\n        // http://tools.ietf.org/html/rfc4492#section-5.1.1).\n        SupportedCurves []CurveID\n\n        // SupportedPoints lists the point formats supported by the client.\n        // SupportedPoints is set only if the Supported Point Formats Extension\n        // is being used (see\n        // http://tools.ietf.org/html/rfc4492#section-5.1.2).\n        SupportedPoints []uint8\n}</pre> <p> ClientHelloInfo contains information from a ClientHello message in order to guide certificate selection in the GetCertificate callback. </p> <h2 id=\"ClientSessionCache\">type ClientSessionCache  </h2> <pre data-language=\"go\">type ClientSessionCache interface {\n        // Get searches for a ClientSessionState associated with the given key.\n        // On return, ok is true if one was found.\n        Get(sessionKey string) (session *ClientSessionState, ok bool)\n\n        // Put adds the ClientSessionState to the cache with the given key.\n        Put(sessionKey string, cs *ClientSessionState)\n}</pre> <p> ClientSessionCache is a cache of ClientSessionState objects that can be used by a client to resume a TLS session with a given server. ClientSessionCache implementations should expect to be called concurrently from different goroutines. </p> <h3 id=\"NewLRUClientSessionCache\">func <a href=\"https://golang.org/src/crypto/tls/common.go?s=22996:23058#L665\">NewLRUClientSessionCache</a>  </h3> <pre data-language=\"go\">func NewLRUClientSessionCache(capacity int) ClientSessionCache</pre> <p> NewLRUClientSessionCache returns a ClientSessionCache with the given capacity that uses an LRU strategy. If capacity is &lt; 1, a default capacity is used instead. </p> <h2 id=\"ClientSessionState\">type ClientSessionState  </h2> <pre data-language=\"go\">type ClientSessionState struct {\n        // contains filtered or unexported fields\n}</pre> <p> ClientSessionState contains the state needed by clients to resume TLS sessions. </p> <h2 id=\"Config\">type Config  </h2> <pre data-language=\"go\">type Config struct {\n        // Rand provides the source of entropy for nonces and RSA blinding.\n        // If Rand is nil, TLS uses the cryptographic random reader in package\n        // crypto/rand.\n        // The Reader must be safe for use by multiple goroutines.\n        Rand io.Reader\n\n        // Time returns the current time as the number of seconds since the epoch.\n        // If Time is nil, TLS uses time.Now.\n        Time func() time.Time\n\n        // Certificates contains one or more certificate chains\n        // to present to the other side of the connection.\n        // Server configurations must include at least one certificate\n        // or else set GetCertificate.\n        Certificates []Certificate\n\n        // NameToCertificate maps from a certificate name to an element of\n        // Certificates. Note that a certificate name can be of the form\n        // '*.example.com' and so doesn't have to be a domain name as such.\n        // See Config.BuildNameToCertificate\n        // The nil value causes the first element of Certificates to be used\n        // for all connections.\n        NameToCertificate map[string]*Certificate\n\n        // GetCertificate returns a Certificate based on the given\n        // ClientHelloInfo. It will only be called if the client supplies SNI\n        // information or if Certificates is empty.\n        //\n        // If GetCertificate is nil or returns nil, then the certificate is\n        // retrieved from NameToCertificate. If NameToCertificate is nil, the\n        // first element of Certificates will be used.\n        GetCertificate func(clientHello *ClientHelloInfo) (*Certificate, error)\n\n        // RootCAs defines the set of root certificate authorities\n        // that clients use when verifying server certificates.\n        // If RootCAs is nil, TLS uses the host's root CA set.\n        RootCAs *x509.CertPool\n\n        // NextProtos is a list of supported, application level protocols.\n        NextProtos []string\n\n        // ServerName is used to verify the hostname on the returned\n        // certificates unless InsecureSkipVerify is given. It is also included\n        // in the client's handshake to support virtual hosting unless it is\n        // an IP address.\n        ServerName string\n\n        // ClientAuth determines the server's policy for\n        // TLS Client Authentication. The default is NoClientCert.\n        ClientAuth ClientAuthType\n\n        // ClientCAs defines the set of root certificate authorities\n        // that servers use if required to verify a client certificate\n        // by the policy in ClientAuth.\n        ClientCAs *x509.CertPool\n\n        // InsecureSkipVerify controls whether a client verifies the\n        // server's certificate chain and host name.\n        // If InsecureSkipVerify is true, TLS accepts any certificate\n        // presented by the server and any host name in that certificate.\n        // In this mode, TLS is susceptible to man-in-the-middle attacks.\n        // This should be used only for testing.\n        InsecureSkipVerify bool\n\n        // CipherSuites is a list of supported cipher suites. If CipherSuites\n        // is nil, TLS uses a list of suites supported by the implementation.\n        CipherSuites []uint16\n\n        // PreferServerCipherSuites controls whether the server selects the\n        // client's most preferred ciphersuite, or the server's most preferred\n        // ciphersuite. If true then the server's preference, as expressed in\n        // the order of elements in CipherSuites, is used.\n        PreferServerCipherSuites bool\n\n        // SessionTicketsDisabled may be set to true to disable session ticket\n        // (resumption) support.\n        SessionTicketsDisabled bool\n\n        // SessionTicketKey is used by TLS servers to provide session\n        // resumption. See RFC 5077. If zero, it will be filled with\n        // random data before the first server handshake.\n        //\n        // If multiple servers are terminating connections for the same host\n        // they should all have the same SessionTicketKey. If the\n        // SessionTicketKey leaks, previously recorded and future TLS\n        // connections using that key are compromised.\n        SessionTicketKey [32]byte\n\n        // SessionCache is a cache of ClientSessionState entries for TLS session\n        // resumption.\n        ClientSessionCache ClientSessionCache\n\n        // MinVersion contains the minimum SSL/TLS version that is acceptable.\n        // If zero, then TLS 1.0 is taken as the minimum.\n        MinVersion uint16\n\n        // MaxVersion contains the maximum SSL/TLS version that is acceptable.\n        // If zero, then the maximum version supported by this package is used,\n        // which is currently TLS 1.2.\n        MaxVersion uint16\n\n        // CurvePreferences contains the elliptic curves that will be used in\n        // an ECDHE handshake, in preference order. If empty, the default will\n        // be used.\n        CurvePreferences []CurveID\n\n        // DynamicRecordSizingDisabled disables adaptive sizing of TLS records.\n        // When true, the largest possible TLS record size is always used. When\n        // false, the size of TLS records may be adjusted in an attempt to\n        // improve latency.\n        DynamicRecordSizingDisabled bool\n\n        // Renegotiation controls what types of renegotiation are supported.\n        // The default, none, is correct for the vast majority of applications.\n        Renegotiation RenegotiationSupport\n        // contains filtered or unexported fields\n}</pre> <p> A Config structure is used to configure a TLS client or server. After one has been passed to a TLS function it must not be modified. A Config may be reused; the tls package will also not modify it. </p> <h3 id=\"Config.BuildNameToCertificate\">func (*Config) <a href=\"https://golang.org/src/crypto/tls/common.go?s=20954:20995#L603\">BuildNameToCertificate</a>  </h3> <pre data-language=\"go\">func (c *Config) BuildNameToCertificate()</pre> <p> BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate from the CommonName and SubjectAlternateName fields of each of the leaf certificates. </p> <h3 id=\"Config.SetSessionTicketKeys\">func (*Config) <a href=\"https://golang.org/src/crypto/tls/common.go?s=18093:18147#L479\">SetSessionTicketKeys</a>  </h3> <pre data-language=\"go\">func (c *Config) SetSessionTicketKeys(keys [][32]byte)</pre> <p> SetSessionTicketKeys updates the session ticket keys for a server. The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty. </p> <h2 id=\"Conn\">type Conn  </h2> <pre data-language=\"go\">type Conn struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Conn represents a secured connection. It implements the net.Conn interface. </p> <h3 id=\"Client\">func <a href=\"https://golang.org/src/crypto/tls/tls.go?s=1129:1177#L29\">Client</a>  </h3> <pre data-language=\"go\">func Client(conn net.Conn, config *Config) *Conn</pre> <p> Client returns a new TLS client side connection using conn as the underlying transport. The config cannot be nil: users must set either ServerName or InsecureSkipVerify in the config. </p> <h3 id=\"Dial\">func <a href=\"https://golang.org/src/crypto/tls/tls.go?s=4884:4946#L159\">Dial</a>  </h3> <pre data-language=\"go\">func Dial(network, addr string, config *Config) (*Conn, error)</pre> <p> Dial connects to the given network address using net.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Dial interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults. </p> <div id=\"example_Dial\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n)\n\nfunc main() {\n\t// Connecting with a custom root-certificate set.\n\n\tconst rootPEM = `\n-----BEGIN CERTIFICATE-----\nMIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT\nMRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i\nYWwgQ0EwHhcNMTMwNDA1MTUxNTU1WhcNMTUwNDA0MTUxNTU1WjBJMQswCQYDVQQG\nEwJVUzETMBEGA1UEChMKR29vZ2xlIEluYzElMCMGA1UEAxMcR29vZ2xlIEludGVy\nbmV0IEF1dGhvcml0eSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\nAJwqBHdc2FCROgajguDYUEi8iT/xGXAaiEZ+4I/F8YnOIe5a/mENtzJEiaB0C1NP\nVaTOgmKV7utZX8bhBYASxF6UP7xbSDj0U/ck5vuR6RXEz/RTDfRK/J9U3n2+oGtv\nh8DQUB8oMANA2ghzUWx//zo8pzcGjr1LEQTrfSTe5vn8MXH7lNVg8y5Kr0LSy+rE\nahqyzFPdFUuLH8gZYR/Nnag+YyuENWllhMgZxUYi+FOVvuOAShDGKuy6lyARxzmZ\nEASg8GF6lSWMTlJ14rbtCMoU/M4iarNOz0YDl5cDfsCx3nuvRTPPuj5xt970JSXC\nDTWJnZ37DhF5iR43xa+OcmkCAwEAAaOB+zCB+DAfBgNVHSMEGDAWgBTAephojYn7\nqwVkDBF9qn1luMrMTjAdBgNVHQ4EFgQUSt0GFhu89mi1dvWBtrtiGrpagS8wEgYD\nVR0TAQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAQYwOgYDVR0fBDMwMTAvoC2g\nK4YpaHR0cDovL2NybC5nZW90cnVzdC5jb20vY3Jscy9ndGdsb2JhbC5jcmwwPQYI\nKwYBBQUHAQEEMTAvMC0GCCsGAQUFBzABhiFodHRwOi8vZ3RnbG9iYWwtb2NzcC5n\nZW90cnVzdC5jb20wFwYDVR0gBBAwDjAMBgorBgEEAdZ5AgUBMA0GCSqGSIb3DQEB\nBQUAA4IBAQA21waAESetKhSbOHezI6B1WLuxfoNCunLaHtiONgaX4PCVOzf9G0JY\n/iLIa704XtE7JW4S615ndkZAkNoUyHgN7ZVm2o6Gb4ChulYylYbc3GrKBIxbf/a/\nzG+FA1jDaFETzf3I93k9mTXwVqO94FntT0QJo544evZG0R0SnU++0ED8Vf4GXjza\nHFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto\nWHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6\nyuGnBXj8ytqU0CwIPX4WecigUCAkVDNx\n-----END CERTIFICATE-----`\n\n\t// First, create the set of root certificates. For this example we only\n\t// have one. It's also possible to omit this in order to use the\n\t// default root set of the current operating system.\n\troots := x509.NewCertPool()\n\tok := roots.AppendCertsFromPEM([]byte(rootPEM))\n\tif !ok {\n\t\tpanic(\"failed to parse root certificate\")\n\t}\n\n\tconn, err := tls.Dial(\"tcp\", \"mail.google.com:443\", &amp;tls.Config{\n\t\tRootCAs: roots,\n\t})\n\tif err != nil {\n\t\tpanic(\"failed to connect: \" + err.Error())\n\t}\n\tconn.Close()\n}\n</pre> </div> </div> <h3 id=\"DialWithDialer\">func <a href=\"https://golang.org/src/crypto/tls/tls.go?s=3226:3318#L88\">DialWithDialer</a>  </h3> <pre data-language=\"go\">func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)</pre> <p> DialWithDialer connects to the given network address using dialer.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Any timeout or deadline given in the dialer apply to connection and TLS handshake as a whole. </p> <p> DialWithDialer interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults. </p> <h3 id=\"Server\">func <a href=\"https://golang.org/src/crypto/tls/tls.go?s=837:885#L21\">Server</a>  </h3> <pre data-language=\"go\">func Server(conn net.Conn, config *Config) *Conn</pre> <p> Server returns a new TLS server side connection using conn as the underlying transport. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. </p> <h3 id=\"Conn.Close\">func (*Conn) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=33259:33287#L1149\">Close</a>  </h3> <pre data-language=\"go\">func (c *Conn) Close() error</pre> <p> Close closes the connection. </p> <h3 id=\"Conn.ConnectionState\">func (*Conn) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=35528:35576#L1233\">ConnectionState</a>  </h3> <pre data-language=\"go\">func (c *Conn) ConnectionState() ConnectionState</pre> <p> ConnectionState returns basic TLS details about the connection. </p> <h3 id=\"Conn.Handshake\">func (*Conn) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=34334:34366#L1189\">Handshake</a>  </h3> <pre data-language=\"go\">func (c *Conn) Handshake() error</pre> <p> Handshake runs the client or server handshake protocol if it has not yet been run. Most uses of this package need not call Handshake explicitly: the first Read or Write will call it automatically. </p> <h3 id=\"Conn.LocalAddr\">func (*Conn) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=3381:3416#L89\">LocalAddr</a>  </h3> <pre data-language=\"go\">func (c *Conn) LocalAddr() net.Addr</pre> <p> LocalAddr returns the local network address. </p> <h3 id=\"Conn.OCSPResponse\">func (*Conn) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=36442:36478#L1264\">OCSPResponse</a>  </h3> <pre data-language=\"go\">func (c *Conn) OCSPResponse() []byte</pre> <p> OCSPResponse returns the stapled OCSP response from the TLS server, if any. (Only valid for client connections.) </p> <h3 id=\"Conn.Read\">func (*Conn) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=31236:31284#L1081\">Read</a>  </h3> <pre data-language=\"go\">func (c *Conn) Read(b []byte) (n int, err error)</pre> <p> Read can be made to time out and return a net.Error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline. </p> <h3 id=\"Conn.RemoteAddr\">func (*Conn) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=3499:3535#L94\">RemoteAddr</a>  </h3> <pre data-language=\"go\">func (c *Conn) RemoteAddr() net.Addr</pre> <p> RemoteAddr returns the remote network address. </p> <h3 id=\"Conn.SetDeadline\">func (*Conn) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=3819:3864#L101\">SetDeadline</a>  </h3> <pre data-language=\"go\">func (c *Conn) SetDeadline(t time.Time) error</pre> <p> SetDeadline sets the read and write deadlines associated with the connection. A zero value for t means Read and Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error. </p> <h3 id=\"Conn.SetReadDeadline\">func (*Conn) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=4024:4073#L107\">SetReadDeadline</a>  </h3> <pre data-language=\"go\">func (c *Conn) SetReadDeadline(t time.Time) error</pre> <p> SetReadDeadline sets the read deadline on the underlying connection. A zero value for t means Read will not time out. </p> <h3 id=\"Conn.SetWriteDeadline\">func (*Conn) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=4347:4397#L114\">SetWriteDeadline</a>  </h3> <pre data-language=\"go\">func (c *Conn) SetWriteDeadline(t time.Time) error</pre> <p> SetWriteDeadline sets the write deadline on the underlying connection. A zero value for t means Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error. </p> <h3 id=\"Conn.VerifyHostname\">func (*Conn) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=36737:36785#L1274\">VerifyHostname</a>  </h3> <pre data-language=\"go\">func (c *Conn) VerifyHostname(host string) error</pre> <p> VerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem. </p> <h3 id=\"Conn.Write\">func (*Conn) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=28880:28923#L985\">Write</a>  </h3> <pre data-language=\"go\">func (c *Conn) Write(b []byte) (int, error)</pre> <p> Write writes data to the connection. </p> <h2 id=\"ConnectionState\">type ConnectionState  </h2> <pre data-language=\"go\">type ConnectionState struct {\n        Version                     uint16                // TLS version used by the connection (e.g. VersionTLS12)\n        HandshakeComplete           bool                  // TLS handshake is complete\n        DidResume                   bool                  // connection resumes a previous TLS connection\n        CipherSuite                 uint16                // cipher suite in use (TLS_RSA_WITH_RC4_128_SHA, ...)\n        NegotiatedProtocol          string                // negotiated next protocol (from Config.NextProtos)\n        NegotiatedProtocolIsMutual  bool                  // negotiated protocol was advertised by server\n        ServerName                  string                // server name requested by client, if any (server side only)\n        PeerCertificates            []*x509.Certificate   // certificate chain presented by remote peer\n        VerifiedChains              [][]*x509.Certificate // verified chains built from PeerCertificates\n        SignedCertificateTimestamps [][]byte              // SCTs from the server, if any\n        OCSPResponse                []byte                // stapled OCSP response from server, if any\n\n        // TLSUnique contains the \"tls-unique\" channel binding value (see RFC\n        // 5929, section 3). For resumed sessions this value will be nil\n        // because resumption does not include enough context (see\n        // https://secure-resumption.com/#channelbindings). This will change in\n        // future versions of Go once the TLS master-secret fix has been\n        // standardized and implemented.\n        TLSUnique []byte\n}</pre> <p> ConnectionState records basic TLS details about the connection. </p> <h2 id=\"CurveID\">type CurveID  </h2> <pre data-language=\"go\">type CurveID uint16</pre> <p> CurveID is the type of a TLS identifier for an elliptic curve. See <a href=\"http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8\">http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8</a> </p> <pre data-language=\"go\">const (\n        CurveP256 CurveID = 23\n        CurveP384 CurveID = 24\n        CurveP521 CurveID = 25\n)</pre> <h2 id=\"RecordHeaderError\">type RecordHeaderError  </h2> <pre data-language=\"go\">type RecordHeaderError struct {\n        // Msg contains a human readable string that describes the error.\n        Msg string\n        // RecordHeader contains the five bytes of TLS record header that\n        // triggered the error.\n        RecordHeader [5]byte\n}</pre> <p> RecordHeaderError results when a TLS record header is invalid. </p> <h3 id=\"RecordHeaderError.Error\">func (RecordHeaderError) <a href=\"https://golang.org/src/crypto/tls/conn.go?s=15659:15700#L526\">Error</a>  </h3> <pre data-language=\"go\">func (e RecordHeaderError) Error() string</pre> <h2 id=\"RenegotiationSupport\">type RenegotiationSupport  </h2> <pre data-language=\"go\">type RenegotiationSupport int</pre> <p> RenegotiationSupport enumerates the different levels of support for TLS renegotiation. TLS renegotiation is the act of performing subsequent handshakes on a connection after the first. This significantly complicates the state machine and has been the source of numerous, subtle security issues. Initiating a renegotiation is not supported, but support for accepting renegotiation requests may be enabled. </p> <p> Even when enabled, the server may not change its identity between handshakes (i.e. the leaf certificate must be the same). Additionally, concurrent handshake and application data flow is not permitted so renegotiation can only be used with protocols that synchronise with the renegotiation, such as HTTPS. </p> <pre data-language=\"go\">const (\n        // RenegotiateNever disables renegotiation.\n        RenegotiateNever RenegotiationSupport = iota\n\n        // RenegotiateOnceAsClient allows a remote server to request\n        // renegotiation once per connection.\n        RenegotiateOnceAsClient\n\n        // RenegotiateFreelyAsClient allows a remote server to repeatedly\n        // request renegotiation.\n        RenegotiateFreelyAsClient\n)</pre> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/crypto/tls/tls.go?s=244:485#L1\" style=\"float: left;\">☞</a> <p> The crypto/tls package does not implement countermeasures against Lucky13 attacks on CBC-mode encryption. See <a href=\"http://www.isg.rhul.ac.uk/tls/TLStiming.pdf\">http://www.isg.rhul.ac.uk/tls/TLStiming.pdf</a> and <a href=\"https://www.imperialviolet.org/2013/02/04/luckythirteen.html\">https://www.imperialviolet.org/2013/02/04/luckythirteen.html</a>. </p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/crypto/tls/\" class=\"_attribution-link\">https://golang.org/pkg/crypto/tls/</a>\n  </p>\n</div>\n","encoding/json/index":"<h1>Package json</h1>     <ul id=\"short-nav\">\n<li><code>import \"encoding/json\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package json implements encoding and decoding of JSON as defined in RFC 4627. The mapping between JSON and Go values is described in the documentation for the Marshal and Unmarshal functions. </p> <p> See \"JSON and Go\" for an introduction to this package: <a href=\"https://golang.org/doc/articles/json_and_go.html\">https://golang.org/doc/articles/json_and_go.html</a> </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Compact\">func Compact(dst *bytes.Buffer, src []byte) error</a></li>\n<li><a href=\"#HTMLEscape\">func HTMLEscape(dst *bytes.Buffer, src []byte)</a></li>\n<li><a href=\"#Indent\">func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error</a></li>\n<li><a href=\"#Marshal\">func Marshal(v interface{}) ([]byte, error)</a></li>\n<li><a href=\"#MarshalIndent\">func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</a></li>\n<li><a href=\"#Unmarshal\">func Unmarshal(data []byte, v interface{}) error</a></li>\n<li><a href=\"#Decoder\">type Decoder</a></li>\n<li> <a href=\"#NewDecoder\">func NewDecoder(r io.Reader) *Decoder</a>\n</li>\n<li> <a href=\"#Decoder.Buffered\">func (dec *Decoder) Buffered() io.Reader</a>\n</li>\n<li> <a href=\"#Decoder.Decode\">func (dec *Decoder) Decode(v interface{}) error</a>\n</li>\n<li> <a href=\"#Decoder.More\">func (dec *Decoder) More() bool</a>\n</li>\n<li> <a href=\"#Decoder.Token\">func (dec *Decoder) Token() (Token, error)</a>\n</li>\n<li> <a href=\"#Decoder.UseNumber\">func (dec *Decoder) UseNumber()</a>\n</li>\n<li><a href=\"#Delim\">type Delim</a></li>\n<li> <a href=\"#Delim.String\">func (d Delim) String() string</a>\n</li>\n<li><a href=\"#Encoder\">type Encoder</a></li>\n<li> <a href=\"#NewEncoder\">func NewEncoder(w io.Writer) *Encoder</a>\n</li>\n<li> <a href=\"#Encoder.Encode\">func (enc *Encoder) Encode(v interface{}) error</a>\n</li>\n<li> <a href=\"#Encoder.SetEscapeHTML\">func (enc *Encoder) SetEscapeHTML(on bool)</a>\n</li>\n<li> <a href=\"#Encoder.SetIndent\">func (enc *Encoder) SetIndent(prefix, indent string)</a>\n</li>\n<li><a href=\"#InvalidUTF8Error\">type InvalidUTF8Error</a></li>\n<li> <a href=\"#InvalidUTF8Error.Error\">func (e *InvalidUTF8Error) Error() string</a>\n</li>\n<li><a href=\"#InvalidUnmarshalError\">type InvalidUnmarshalError</a></li>\n<li> <a href=\"#InvalidUnmarshalError.Error\">func (e *InvalidUnmarshalError) Error() string</a>\n</li>\n<li><a href=\"#Marshaler\">type Marshaler</a></li>\n<li><a href=\"#MarshalerError\">type MarshalerError</a></li>\n<li> <a href=\"#MarshalerError.Error\">func (e *MarshalerError) Error() string</a>\n</li>\n<li><a href=\"#Number\">type Number</a></li>\n<li> <a href=\"#Number.Float64\">func (n Number) Float64() (float64, error)</a>\n</li>\n<li> <a href=\"#Number.Int64\">func (n Number) Int64() (int64, error)</a>\n</li>\n<li> <a href=\"#Number.String\">func (n Number) String() string</a>\n</li>\n<li><a href=\"#RawMessage\">type RawMessage</a></li>\n<li> <a href=\"#RawMessage.MarshalJSON\">func (m *RawMessage) MarshalJSON() ([]byte, error)</a>\n</li>\n<li> <a href=\"#RawMessage.UnmarshalJSON\">func (m *RawMessage) UnmarshalJSON(data []byte) error</a>\n</li>\n<li><a href=\"#SyntaxError\">type SyntaxError</a></li>\n<li> <a href=\"#SyntaxError.Error\">func (e *SyntaxError) Error() string</a>\n</li>\n<li><a href=\"#Token\">type Token</a></li>\n<li><a href=\"#UnmarshalFieldError\">type UnmarshalFieldError</a></li>\n<li> <a href=\"#UnmarshalFieldError.Error\">func (e *UnmarshalFieldError) Error() string</a>\n</li>\n<li><a href=\"#UnmarshalTypeError\">type UnmarshalTypeError</a></li>\n<li> <a href=\"#UnmarshalTypeError.Error\">func (e *UnmarshalTypeError) Error() string</a>\n</li>\n<li><a href=\"#Unmarshaler\">type Unmarshaler</a></li>\n<li><a href=\"#UnsupportedTypeError\">type UnsupportedTypeError</a></li>\n<li> <a href=\"#UnsupportedTypeError.Error\">func (e *UnsupportedTypeError) Error() string</a>\n</li>\n<li><a href=\"#UnsupportedValueError\">type UnsupportedValueError</a></li>\n<li> <a href=\"#UnsupportedValueError.Error\">func (e *UnsupportedValueError) Error() string</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Decoder\">Decoder</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Decoder_Decode_stream\">Decoder.Decode (Stream)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Decoder_Token\">Decoder.Token</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Indent\">Indent</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Marshal\">Marshal</a></dd> <dd><a class=\"exampleLink\" href=\"#example_RawMessage\">RawMessage</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Unmarshal\">Unmarshal</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/encoding/json/decode.go\">decode.go</a> <a href=\"https://golang.org/src/encoding/json/encode.go\">encode.go</a> <a href=\"https://golang.org/src/encoding/json/fold.go\">fold.go</a> <a href=\"https://golang.org/src/encoding/json/indent.go\">indent.go</a> <a href=\"https://golang.org/src/encoding/json/scanner.go\">scanner.go</a> <a href=\"https://golang.org/src/encoding/json/stream.go\">stream.go</a> <a href=\"https://golang.org/src/encoding/json/tags.go\">tags.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Compact\">func Compact  </h2> <pre data-language=\"go\">func Compact(dst *bytes.Buffer, src []byte) error</pre> <p> Compact appends to dst the JSON-encoded src with insignificant space characters elided. </p> <h2 id=\"HTMLEscape\">func HTMLEscape  </h2> <pre data-language=\"go\">func HTMLEscape(dst *bytes.Buffer, src []byte)</pre> <p> HTMLEscape appends to dst the JSON-encoded src with &lt;, &gt;, &amp;, U+2028 and U+2029 characters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029 so that the JSON will be safe to embed inside HTML &lt;script&gt; tags. For historical reasons, web browsers don't honor standard HTML escaping within &lt;script&gt; tags, so an alternative JSON encoding must be used. </p> <h2 id=\"Indent\">func Indent  </h2> <pre data-language=\"go\">func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error</pre> <p> Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst. </p> <div id=\"example_Indent\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\ttype Road struct {\n\t\tName   string\n\t\tNumber int\n\t}\n\troads := []Road{\n\t\t{\"Diamond Fork\", 29},\n\t\t{\"Sheep Creek\", 51},\n\t}\n\n\tb, err := json.Marshal(roads)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tvar out bytes.Buffer\n\tjson.Indent(&amp;out, b, \"=\", \"\\t\")\n\tout.WriteTo(os.Stdout)\n}\n</pre> </div> </div> <h2 id=\"Marshal\">func Marshal  </h2> <pre data-language=\"go\">func Marshal(v interface{}) ([]byte, error)</pre> <p> Marshal returns the JSON encoding of v. </p> <p> Marshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON. </p> <p> Otherwise, Marshal uses the following type-dependent default encodings: </p> <p> Boolean values encode as JSON booleans. </p> <p> Floating point, integer, and Number values encode as JSON numbers. </p> <p> String values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. The angle brackets \"&lt;\" and \"&gt;\" are escaped to \"\\u003c\" and \"\\u003e\" to keep some browsers from misinterpreting JSON output as HTML. Ampersand \"&amp;\" is also escaped to \"\\u0026\" for the same reason. This escaping can be disabled using an Encoder with DisableHTMLEscaping. </p> <p> Array and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value. </p> <p> Struct values encode as JSON objects. Each exported struct field becomes a member of the object unless </p> <pre data-language=\"go\">- the field's tag is \"-\", or\n- the field is empty and its tag specifies the \"omitempty\" option.\n</pre> <p> The empty values are false, 0, any nil pointer or interface value, and any array, slice, map, or string of length zero. The object's default key string is the struct field name but can be specified in the struct field's tag value. The \"json\" key in the struct field's tag value is the key name, followed by an optional comma and options. Examples: </p> <pre data-language=\"go\">// Field is ignored by this package.\nField int `json:\"-\"`\n\n// Field appears in JSON as key \"myName\".\nField int `json:\"myName\"`\n\n// Field appears in JSON as key \"myName\" and\n// the field is omitted from the object if its value is empty,\n// as defined above.\nField int `json:\"myName,omitempty\"`\n\n// Field appears in JSON as key \"Field\" (the default), but\n// the field is skipped if empty.\n// Note the leading comma.\nField int `json:\",omitempty\"`\n</pre> <p> The \"string\" option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs: </p> <pre data-language=\"go\">Int64String int64 `json:\",string\"`\n</pre> <p> The key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma. </p> <p> Anonymous struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph. An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous. An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous. </p> <p> The Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply: </p> <p> 1) Of those fields, if any are JSON-tagged, only tagged fields are considered, even if there are multiple untagged fields that would otherwise conflict. 2) If there is exactly one field (tagged or not according to the first rule), that is selected. 3) Otherwise there are multiple fields, and all are ignored; no error occurs. </p> <p> Handling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of \"-\". </p> <p> Map values encode as JSON objects. The map's key type must either be a string, an integer type, or implement encoding.TextMarshaler. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above: </p> <pre data-language=\"go\">- string keys are used directly\n- encoding.TextMarshalers are marshaled\n- integer keys are converted to strings\n</pre> <p> Pointer values encode as the value pointed to. A nil pointer encodes as the null JSON value. </p> <p> Interface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value. </p> <p> Channel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an UnsupportedTypeError. </p> <p> JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an infinite recursion. </p> <div id=\"example_Marshal\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\ttype ColorGroup struct {\n\t\tID     int\n\t\tName   string\n\t\tColors []string\n\t}\n\tgroup := ColorGroup{\n\t\tID:     1,\n\t\tName:   \"Reds\",\n\t\tColors: []string{\"Crimson\", \"Red\", \"Ruby\", \"Maroon\"},\n\t}\n\tb, err := json.Marshal(group)\n\tif err != nil {\n\t\tfmt.Println(\"error:\", err)\n\t}\n\tos.Stdout.Write(b)\n}\n</pre> </div> </div> <h2 id=\"MarshalIndent\">func MarshalIndent  </h2> <pre data-language=\"go\">func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</pre> <p> MarshalIndent is like Marshal but applies Indent to format the output. </p> <h2 id=\"Unmarshal\">func Unmarshal  </h2> <pre data-language=\"go\">func Unmarshal(data []byte, v interface{}) error</pre> <p> Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. </p> <p> Unmarshal uses the inverse of the encodings that Marshal uses, allocating maps, slices, and pointers as necessary, with the following additional rules: </p> <p> To unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to. </p> <p> To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match. Unmarshal will only set exported fields of the struct. </p> <p> To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value: </p> <pre data-language=\"go\">bool, for JSON booleans\nfloat64, for JSON numbers\nstring, for JSON strings\n[]interface{}, for JSON arrays\nmap[string]interface{}, for JSON objects\nnil for JSON null\n</pre> <p> To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice. </p> <p> To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values. </p> <p> To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key- value pairs from the JSON object into the map. The map's key type must either be a string, an integer, or implement encoding.TextUnmarshaler. </p> <p> If a JSON value is not appropriate for a given target type, or if a JSON number overflows the target type, Unmarshal skips that field and completes the unmarshaling as best it can. If no more serious errors are encountered, Unmarshal returns an UnmarshalTypeError describing the earliest such error. </p> <p> The JSON null value unmarshals into an interface, map, pointer, or slice by setting that Go value to nil. Because null is often used in JSON to mean “not present,” unmarshaling a JSON null into any other Go type has no effect on the value and produces no error. </p> <p> When unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate pairs are not treated as an error. Instead, they are replaced by the Unicode replacement character U+FFFD. </p> <div id=\"example_Unmarshal\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar jsonBlob = []byte(`[\n\t\t{\"Name\": \"Platypus\", \"Order\": \"Monotremata\"},\n\t\t{\"Name\": \"Quoll\",    \"Order\": \"Dasyuromorphia\"}\n\t]`)\n\ttype Animal struct {\n\t\tName  string\n\t\tOrder string\n\t}\n\tvar animals []Animal\n\terr := json.Unmarshal(jsonBlob, &amp;animals)\n\tif err != nil {\n\t\tfmt.Println(\"error:\", err)\n\t}\n\tfmt.Printf(\"%+v\", animals)\n}\n</pre> </div> </div> <h2 id=\"Decoder\">type Decoder  </h2> <pre data-language=\"go\">type Decoder struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Decoder reads and decodes JSON values from an input stream. </p> <div id=\"example_Decoder\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>This example uses a Decoder to decode a stream of distinct JSON values. </p> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tconst jsonStream = `\n\t\t{\"Name\": \"Ed\", \"Text\": \"Knock knock.\"}\n\t\t{\"Name\": \"Sam\", \"Text\": \"Who's there?\"}\n\t\t{\"Name\": \"Ed\", \"Text\": \"Go fmt.\"}\n\t\t{\"Name\": \"Sam\", \"Text\": \"Go fmt who?\"}\n\t\t{\"Name\": \"Ed\", \"Text\": \"Go fmt yourself!\"}\n\t`\n\ttype Message struct {\n\t\tName, Text string\n\t}\n\tdec := json.NewDecoder(strings.NewReader(jsonStream))\n\tfor {\n\t\tvar m Message\n\t\tif err := dec.Decode(&amp;m); err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Printf(\"%s: %s\\n\", m.Name, m.Text)\n\t}\n}\n</pre> </div> </div> <h3 id=\"NewDecoder\">func <a href=\"https://golang.org/src/encoding/json/stream.go?s=620:657#L20\">NewDecoder</a>  </h3> <pre data-language=\"go\">func NewDecoder(r io.Reader) *Decoder</pre> <p> NewDecoder returns a new decoder that reads from r. </p> <p> The decoder introduces its own buffering and may read data from r beyond the JSON values requested. </p> <h3 id=\"Decoder.Buffered\">func (*Decoder) <a href=\"https://golang.org/src/encoding/json/stream.go?s=1864:1904#L67\">Buffered</a>  </h3> <pre data-language=\"go\">func (dec *Decoder) Buffered() io.Reader</pre> <p> Buffered returns a reader of the data remaining in the Decoder's buffer. The reader is valid until the next call to Decode. </p> <h3 id=\"Decoder.Decode\">func (*Decoder) <a href=\"https://golang.org/src/encoding/json/stream.go?s=1069:1116#L33\">Decode</a>  </h3> <pre data-language=\"go\">func (dec *Decoder) Decode(v interface{}) error</pre> <p> Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v. </p> <p> See the documentation for Unmarshal for details about the conversion of JSON into a Go value. </p> <div id=\"example_Decoder_Decode_stream\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Stream)</h2> <p>This example uses a Decoder to decode a streaming array of JSON objects. </p> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tconst jsonStream = `\n\t\t[\n\t\t\t{\"Name\": \"Ed\", \"Text\": \"Knock knock.\"},\n\t\t\t{\"Name\": \"Sam\", \"Text\": \"Who's there?\"},\n\t\t\t{\"Name\": \"Ed\", \"Text\": \"Go fmt.\"},\n\t\t\t{\"Name\": \"Sam\", \"Text\": \"Go fmt who?\"},\n\t\t\t{\"Name\": \"Ed\", \"Text\": \"Go fmt yourself!\"}\n\t\t]\n\t`\n\ttype Message struct {\n\t\tName, Text string\n\t}\n\tdec := json.NewDecoder(strings.NewReader(jsonStream))\n\n\t// read open bracket\n\tt, err := dec.Token()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"%T: %v\\n\", t, t)\n\n\t// while the array contains values\n\tfor dec.More() {\n\t\tvar m Message\n\t\t// decode an array value (Message)\n\t\terr := dec.Decode(&amp;m)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tfmt.Printf(\"%v: %v\\n\", m.Name, m.Text)\n\t}\n\n\t// read closing bracket\n\tt, err = dec.Token()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"%T: %v\\n\", t, t)\n\n}\n</pre> </div> </div> <h3 id=\"Decoder.More\">func (*Decoder) <a href=\"https://golang.org/src/encoding/json/stream.go?s=11884:11915#L467\">More</a>  </h3> <pre data-language=\"go\">func (dec *Decoder) More() bool</pre> <p> More reports whether there is another element in the current array or object being parsed. </p> <h3 id=\"Decoder.Token\">func (*Decoder) <a href=\"https://golang.org/src/encoding/json/stream.go?s=8898:8940#L344\">Token</a>  </h3> <pre data-language=\"go\">func (dec *Decoder) Token() (Token, error)</pre> <p> Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF. </p> <p> Token guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error. </p> <p> The input stream consists of basic JSON values—bool, string, number, and null—along with delimiters [ ] { } of type Delim to mark the start and end of arrays and objects. Commas and colons are elided. </p> <div id=\"example_Decoder_Token\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>This example uses a Decoder to decode a stream of distinct JSON values. </p> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tconst jsonStream = `\n\t\t{\"Message\": \"Hello\", \"Array\": [1, 2, 3], \"Null\": null, \"Number\": 1.234}\n\t`\n\tdec := json.NewDecoder(strings.NewReader(jsonStream))\n\tfor {\n\t\tt, err := dec.Token()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Printf(\"%T: %v\", t, t)\n\t\tif dec.More() {\n\t\t\tfmt.Printf(\" (more)\")\n\t\t}\n\t\tfmt.Printf(\"\\n\")\n\t}\n}\n</pre> </div> </div> <h3 id=\"Decoder.UseNumber\">func (*Decoder) <a href=\"https://golang.org/src/encoding/json/stream.go?s=800:831#L26\">UseNumber</a>  </h3> <pre data-language=\"go\">func (dec *Decoder) UseNumber()</pre> <p> UseNumber causes the Decoder to unmarshal a number into an interface{} as a Number instead of as a float64. </p> <h2 id=\"Delim\">type Delim  </h2> <pre data-language=\"go\">type Delim rune</pre> <p> A Delim is a JSON array or object delimiter, one of [ ] { or }. </p> <h3 id=\"Delim.String\">func (Delim) <a href=\"https://golang.org/src/encoding/json/stream.go?s=8320:8350#L329\">String</a>  </h3> <pre data-language=\"go\">func (d Delim) String() string</pre> <h2 id=\"Encoder\">type Encoder  </h2> <pre data-language=\"go\">type Encoder struct {\n        // contains filtered or unexported fields\n}</pre> <p> An Encoder writes JSON values to an output stream. </p> <h3 id=\"NewEncoder\">func <a href=\"https://golang.org/src/encoding/json/stream.go?s=4115:4152#L169\">NewEncoder</a>  </h3> <pre data-language=\"go\">func NewEncoder(w io.Writer) *Encoder</pre> <p> NewEncoder returns a new encoder that writes to w. </p> <h3 id=\"Encoder.Encode\">func (*Encoder) <a href=\"https://golang.org/src/encoding/json/stream.go?s=4388:4435#L178\">Encode</a>  </h3> <pre data-language=\"go\">func (enc *Encoder) Encode(v interface{}) error</pre> <p> Encode writes the JSON encoding of v to the stream, followed by a newline character. </p> <p> See the documentation for Marshal for details about the conversion of Go values to JSON. </p> <h3 id=\"Encoder.SetEscapeHTML\">func (*Encoder) <a href=\"https://golang.org/src/encoding/json/stream.go?s=5990:6032#L230\">SetEscapeHTML</a>  </h3> <pre data-language=\"go\">func (enc *Encoder) SetEscapeHTML(on bool)</pre> <p> SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings. The default behavior is to escape &amp;, &lt;, and &gt; to \\u0026, \\u003c, and \\u003e to avoid certain safety problems that can arise when embedding JSON in HTML. </p> <p> In non-HTML settings where the escaping interferes with the readability of the output, SetEscapeHTML(false) disables this behavior. </p> <h3 id=\"Encoder.SetIndent\">func (*Encoder) <a href=\"https://golang.org/src/encoding/json/stream.go?s=5467:5519#L218\">SetIndent</a>  </h3> <pre data-language=\"go\">func (enc *Encoder) SetIndent(prefix, indent string)</pre> <p> SetIndent instructs the encoder to format each subsequent encoded value as if indented by the package-level function Indent(dst, src, prefix, indent). Calling SetIndent(\"\", \"\") disables indentation. </p> <h2 id=\"InvalidUTF8Error\">type InvalidUTF8Error  </h2> <pre data-language=\"go\">type InvalidUTF8Error struct {\n        S string // the whole string value that caused the error\n}</pre> <p> Before Go 1.2, an InvalidUTF8Error was returned by Marshal when attempting to encode a string value with invalid UTF-8 sequences. As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by replacing invalid bytes with the Unicode replacement rune U+FFFD. This error is no longer generated but is kept for backwards compatibility with programs that might mention it. </p> <h3 id=\"InvalidUTF8Error.Error\">func (*InvalidUTF8Error) <a href=\"https://golang.org/src/encoding/json/encode.go?s=8590:8631#L226\">Error</a>  </h3> <pre data-language=\"go\">func (e *InvalidUTF8Error) Error() string</pre> <h2 id=\"InvalidUnmarshalError\">type InvalidUnmarshalError  </h2> <pre data-language=\"go\">type InvalidUnmarshalError struct {\n        Type reflect.Type\n}</pre> <p> An InvalidUnmarshalError describes an invalid argument passed to Unmarshal. (The argument to Unmarshal must be a non-nil pointer.) </p> <h3 id=\"InvalidUnmarshalError.Error\">func (*InvalidUnmarshalError) <a href=\"https://golang.org/src/encoding/json/decode.go?s=5172:5218#L130\">Error</a>  </h3> <pre data-language=\"go\">func (e *InvalidUnmarshalError) Error() string</pre> <h2 id=\"Marshaler\">type Marshaler  </h2> <pre data-language=\"go\">type Marshaler interface {\n        MarshalJSON() ([]byte, error)\n}</pre> <p> Marshaler is the interface implemented by types that can marshal themselves into valid JSON. </p> <h2 id=\"MarshalerError\">type MarshalerError  </h2> <pre data-language=\"go\">type MarshalerError struct {\n        Type reflect.Type\n        Err  error\n}</pre> <h3 id=\"MarshalerError.Error\">func (*MarshalerError) <a href=\"https://golang.org/src/encoding/json/encode.go?s=8763:8802#L235\">Error</a>  </h3> <pre data-language=\"go\">func (e *MarshalerError) Error() string</pre> <h2 id=\"Number\">type Number  </h2> <pre data-language=\"go\">type Number string</pre> <p> A Number represents a JSON number literal. </p> <h3 id=\"Number.Float64\">func (Number) <a href=\"https://golang.org/src/encoding/json/decode.go?s=6144:6186#L170\">Float64</a>  </h3> <pre data-language=\"go\">func (n Number) Float64() (float64, error)</pre> <p> Float64 returns the number as a float64. </p> <h3 id=\"Number.Int64\">func (Number) <a href=\"https://golang.org/src/encoding/json/decode.go?s=6275:6313#L175\">Int64</a>  </h3> <pre data-language=\"go\">func (n Number) Int64() (int64, error)</pre> <p> Int64 returns the number as an int64. </p> <h3 id=\"Number.String\">func (Number) <a href=\"https://golang.org/src/encoding/json/decode.go?s=6046:6077#L167\">String</a>  </h3> <pre data-language=\"go\">func (n Number) String() string</pre> <p> String returns the literal text of the number. </p> <h2 id=\"RawMessage\">type RawMessage  </h2> <pre data-language=\"go\">type RawMessage []byte</pre> <p> RawMessage is a raw encoded JSON value. It implements Marshaler and Unmarshaler and can be used to delay JSON decoding or precompute a JSON encoding. </p> <div id=\"example_RawMessage\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>This example uses RawMessage to delay parsing part of a JSON message. </p> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n)\n\nfunc main() {\n\ttype Color struct {\n\t\tSpace string\n\t\tPoint json.RawMessage // delay parsing until we know the color space\n\t}\n\ttype RGB struct {\n\t\tR uint8\n\t\tG uint8\n\t\tB uint8\n\t}\n\ttype YCbCr struct {\n\t\tY  uint8\n\t\tCb int8\n\t\tCr int8\n\t}\n\n\tvar j = []byte(`[\n\t\t{\"Space\": \"YCbCr\", \"Point\": {\"Y\": 255, \"Cb\": 0, \"Cr\": -10}},\n\t\t{\"Space\": \"RGB\",   \"Point\": {\"R\": 98, \"G\": 218, \"B\": 255}}\n\t]`)\n\tvar colors []Color\n\terr := json.Unmarshal(j, &amp;colors)\n\tif err != nil {\n\t\tlog.Fatalln(\"error:\", err)\n\t}\n\n\tfor _, c := range colors {\n\t\tvar dst interface{}\n\t\tswitch c.Space {\n\t\tcase \"RGB\":\n\t\t\tdst = new(RGB)\n\t\tcase \"YCbCr\":\n\t\t\tdst = new(YCbCr)\n\t\t}\n\t\terr := json.Unmarshal(c.Point, dst)\n\t\tif err != nil {\n\t\t\tlog.Fatalln(\"error:\", err)\n\t\t}\n\t\tfmt.Println(c.Space, dst)\n\t}\n}\n</pre> </div> </div> <h3 id=\"RawMessage.MarshalJSON\">func (*RawMessage) <a href=\"https://golang.org/src/encoding/json/stream.go?s=6295:6345#L240\">MarshalJSON</a>  </h3> <pre data-language=\"go\">func (m *RawMessage) MarshalJSON() ([]byte, error)</pre> <p> MarshalJSON returns *m as the JSON encoding of m. </p> <h3 id=\"RawMessage.UnmarshalJSON\">func (*RawMessage) <a href=\"https://golang.org/src/encoding/json/stream.go?s=6411:6464#L245\">UnmarshalJSON</a>  </h3> <pre data-language=\"go\">func (m *RawMessage) UnmarshalJSON(data []byte) error</pre> <p> UnmarshalJSON sets *m to a copy of data. </p> <h2 id=\"SyntaxError\">type SyntaxError  </h2> <pre data-language=\"go\">type SyntaxError struct {\n        Offset int64 // error occurred after reading Offset bytes\n        // contains filtered or unexported fields\n}</pre> <p> A SyntaxError is a description of a JSON syntax error. </p> <h3 id=\"SyntaxError.Error\">func (*SyntaxError) <a href=\"https://golang.org/src/encoding/json/scanner.go?s=2060:2096#L59\">Error</a>  </h3> <pre data-language=\"go\">func (e *SyntaxError) Error() string</pre> <h2 id=\"Token\">type Token  </h2> <pre data-language=\"go\">type Token interface{}</pre> <p> A Token holds a value of one of these types: </p> <pre data-language=\"go\">Delim, for the four JSON delimiters [ ] { }\nbool, for JSON booleans\nfloat64, for JSON numbers\nNumber, for JSON numbers\nstring, for JSON string literals\nnil, for JSON null\n</pre> <h2 id=\"UnmarshalFieldError\">type UnmarshalFieldError  </h2> <pre data-language=\"go\">type UnmarshalFieldError struct {\n        Key   string\n        Type  reflect.Type\n        Field reflect.StructField\n}</pre> <p> An UnmarshalFieldError describes a JSON object key that led to an unexported (and therefore unwritable) struct field. (No longer used; kept for compatibility.) </p> <h3 id=\"UnmarshalFieldError.Error\">func (*UnmarshalFieldError) <a href=\"https://golang.org/src/encoding/json/decode.go?s=4784:4828#L120\">Error</a>  </h3> <pre data-language=\"go\">func (e *UnmarshalFieldError) Error() string</pre> <h2 id=\"UnmarshalTypeError\">type UnmarshalTypeError  </h2> <pre data-language=\"go\">type UnmarshalTypeError struct {\n        Value  string       // description of JSON value - \"bool\", \"array\", \"number -5\"\n        Type   reflect.Type // type of Go value it could not be assigned to\n        Offset int64        // error occurred after reading Offset bytes\n}</pre> <p> An UnmarshalTypeError describes a JSON value that was not appropriate for a value of a specific Go type. </p> <h3 id=\"UnmarshalTypeError.Error\">func (*UnmarshalTypeError) <a href=\"https://golang.org/src/encoding/json/decode.go?s=4378:4421#L107\">Error</a>  </h3> <pre data-language=\"go\">func (e *UnmarshalTypeError) Error() string</pre> <h2 id=\"Unmarshaler\">type Unmarshaler  </h2> <pre data-language=\"go\">type Unmarshaler interface {\n        UnmarshalJSON([]byte) error\n}</pre> <p> Unmarshaler is the interface implemented by types that can unmarshal a JSON description of themselves. The input can be assumed to be a valid encoding of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning. </p> <h2 id=\"UnsupportedTypeError\">type UnsupportedTypeError  </h2> <pre data-language=\"go\">type UnsupportedTypeError struct {\n        Type reflect.Type\n}</pre> <p> An UnsupportedTypeError is returned by Marshal when attempting to encode an unsupported value type. </p> <h3 id=\"UnsupportedTypeError.Error\">func (*UnsupportedTypeError) <a href=\"https://golang.org/src/encoding/json/encode.go?s=7832:7877#L203\">Error</a>  </h3> <pre data-language=\"go\">func (e *UnsupportedTypeError) Error() string</pre> <h2 id=\"UnsupportedValueError\">type UnsupportedValueError  </h2> <pre data-language=\"go\">type UnsupportedValueError struct {\n        Value reflect.Value\n        Str   string\n}</pre> <h3 id=\"UnsupportedValueError.Error\">func (*UnsupportedValueError) <a href=\"https://golang.org/src/encoding/json/encode.go?s=8010:8056#L212\">Error</a>  </h3> <pre data-language=\"go\">func (e *UnsupportedValueError) Error() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/encoding/json/\" class=\"_attribution-link\">https://golang.org/pkg/encoding/json/</a>\n  </p>\n</div>\n","encoding/xml/index":"<h1>Package xml</h1>     <ul id=\"short-nav\">\n<li><code>import \"encoding/xml\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package xml implements a simple XML 1.0 parser that understands XML name spaces. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Escape\">func Escape(w io.Writer, s []byte)</a></li>\n<li><a href=\"#EscapeText\">func EscapeText(w io.Writer, s []byte) error</a></li>\n<li><a href=\"#Marshal\">func Marshal(v interface{}) ([]byte, error)</a></li>\n<li><a href=\"#MarshalIndent\">func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</a></li>\n<li><a href=\"#Unmarshal\">func Unmarshal(data []byte, v interface{}) error</a></li>\n<li><a href=\"#Attr\">type Attr</a></li>\n<li><a href=\"#CharData\">type CharData</a></li>\n<li> <a href=\"#CharData.Copy\">func (c CharData) Copy() CharData</a>\n</li>\n<li><a href=\"#Comment\">type Comment</a></li>\n<li> <a href=\"#Comment.Copy\">func (c Comment) Copy() Comment</a>\n</li>\n<li><a href=\"#Decoder\">type Decoder</a></li>\n<li> <a href=\"#NewDecoder\">func NewDecoder(r io.Reader) *Decoder</a>\n</li>\n<li> <a href=\"#Decoder.Decode\">func (d *Decoder) Decode(v interface{}) error</a>\n</li>\n<li> <a href=\"#Decoder.DecodeElement\">func (d *Decoder) DecodeElement(v interface{}, start *StartElement) error</a>\n</li>\n<li> <a href=\"#Decoder.InputOffset\">func (d *Decoder) InputOffset() int64</a>\n</li>\n<li> <a href=\"#Decoder.RawToken\">func (d *Decoder) RawToken() (Token, error)</a>\n</li>\n<li> <a href=\"#Decoder.Skip\">func (d *Decoder) Skip() error</a>\n</li>\n<li> <a href=\"#Decoder.Token\">func (d *Decoder) Token() (Token, error)</a>\n</li>\n<li><a href=\"#Directive\">type Directive</a></li>\n<li> <a href=\"#Directive.Copy\">func (d Directive) Copy() Directive</a>\n</li>\n<li><a href=\"#Encoder\">type Encoder</a></li>\n<li> <a href=\"#NewEncoder\">func NewEncoder(w io.Writer) *Encoder</a>\n</li>\n<li> <a href=\"#Encoder.Encode\">func (enc *Encoder) Encode(v interface{}) error</a>\n</li>\n<li> <a href=\"#Encoder.EncodeElement\">func (enc *Encoder) EncodeElement(v interface{}, start StartElement) error</a>\n</li>\n<li> <a href=\"#Encoder.EncodeToken\">func (enc *Encoder) EncodeToken(t Token) error</a>\n</li>\n<li> <a href=\"#Encoder.Flush\">func (enc *Encoder) Flush() error</a>\n</li>\n<li> <a href=\"#Encoder.Indent\">func (enc *Encoder) Indent(prefix, indent string)</a>\n</li>\n<li><a href=\"#EndElement\">type EndElement</a></li>\n<li><a href=\"#Marshaler\">type Marshaler</a></li>\n<li><a href=\"#MarshalerAttr\">type MarshalerAttr</a></li>\n<li><a href=\"#Name\">type Name</a></li>\n<li><a href=\"#ProcInst\">type ProcInst</a></li>\n<li> <a href=\"#ProcInst.Copy\">func (p ProcInst) Copy() ProcInst</a>\n</li>\n<li><a href=\"#StartElement\">type StartElement</a></li>\n<li> <a href=\"#StartElement.Copy\">func (e StartElement) Copy() StartElement</a>\n</li>\n<li> <a href=\"#StartElement.End\">func (e StartElement) End() EndElement</a>\n</li>\n<li><a href=\"#SyntaxError\">type SyntaxError</a></li>\n<li> <a href=\"#SyntaxError.Error\">func (e *SyntaxError) Error() string</a>\n</li>\n<li><a href=\"#TagPathError\">type TagPathError</a></li>\n<li> <a href=\"#TagPathError.Error\">func (e *TagPathError) Error() string</a>\n</li>\n<li><a href=\"#Token\">type Token</a></li>\n<li> <a href=\"#CopyToken\">func CopyToken(t Token) Token</a>\n</li>\n<li><a href=\"#UnmarshalError\">type UnmarshalError</a></li>\n<li> <a href=\"#UnmarshalError.Error\">func (e UnmarshalError) Error() string</a>\n</li>\n<li><a href=\"#Unmarshaler\">type Unmarshaler</a></li>\n<li><a href=\"#UnmarshalerAttr\">type UnmarshalerAttr</a></li>\n<li><a href=\"#UnsupportedTypeError\">type UnsupportedTypeError</a></li>\n<li> <a href=\"#UnsupportedTypeError.Error\">func (e *UnsupportedTypeError) Error() string</a>\n</li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Encoder\">Encoder</a></dd> <dd><a class=\"exampleLink\" href=\"#example_MarshalIndent\">MarshalIndent</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Unmarshal\">Unmarshal</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/encoding/xml/marshal.go\">marshal.go</a> <a href=\"https://golang.org/src/encoding/xml/read.go\">read.go</a> <a href=\"https://golang.org/src/encoding/xml/typeinfo.go\">typeinfo.go</a> <a href=\"https://golang.org/src/encoding/xml/xml.go\">xml.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        // A generic XML header suitable for use with the output of Marshal.\n        // This is not automatically added to any output of this package,\n        // it is provided as a convenience.\n        Header = `&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;` + \"\\n\"\n)</pre> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var HTMLAutoClose = htmlAutoClose</pre> <p> HTMLAutoClose is the set of HTML elements that should be considered to close automatically. </p> <pre data-language=\"go\">var HTMLEntity = htmlEntity</pre> <p> HTMLEntity is an entity map containing translations for the standard HTML entity characters. </p> <h2 id=\"Escape\">func Escape  </h2> <pre data-language=\"go\">func Escape(w io.Writer, s []byte)</pre> <p> Escape is like EscapeText but omits the error return value. It is provided for backwards compatibility with Go 1.0. Code targeting Go 1.1 or later should use EscapeText. </p> <h2 id=\"EscapeText\">func EscapeText  </h2> <pre data-language=\"go\">func EscapeText(w io.Writer, s []byte) error</pre> <p> EscapeText writes to w the properly escaped XML equivalent of the plain text data s. </p> <h2 id=\"Marshal\">func Marshal  </h2> <pre data-language=\"go\">func Marshal(v interface{}) ([]byte, error)</pre> <p> Marshal returns the XML encoding of v. </p> <p> Marshal handles an array or slice by marshalling each of the elements. Marshal handles a pointer by marshalling the value it points at or, if the pointer is nil, by writing nothing. Marshal handles an interface value by marshalling the value it contains or, if the interface value is nil, by writing nothing. Marshal handles all other data by writing one or more XML elements containing the data. </p> <p> The name for the XML elements is taken from, in order of preference: </p> <pre data-language=\"go\">- the tag on the XMLName field, if the data is a struct\n- the value of the XMLName field of type Name\n- the tag of the struct field used to obtain the data\n- the name of the struct field used to obtain the data\n- the name of the marshalled type\n</pre> <p> The XML element for a struct contains marshalled elements for each of the exported fields of the struct, with these exceptions: </p> <pre data-language=\"go\">- the XMLName field, described above, is omitted.\n- a field with tag \"-\" is omitted.\n- a field with tag \"name,attr\" becomes an attribute with\n  the given name in the XML element.\n- a field with tag \",attr\" becomes an attribute with the\n  field name in the XML element.\n- a field with tag \",chardata\" is written as character data,\n  not as an XML element.\n- a field with tag \",cdata\" is written as character data\n  wrapped in one or more &lt;![CDATA[ ... ]]&gt; tags, not as an XML element.\n- a field with tag \",innerxml\" is written verbatim, not subject\n  to the usual marshalling procedure.\n- a field with tag \",comment\" is written as an XML comment, not\n  subject to the usual marshalling procedure. It must not contain\n  the \"--\" string within it.\n- a field with a tag including the \"omitempty\" option is omitted\n  if the field value is empty. The empty values are false, 0, any\n  nil pointer or interface value, and any array, slice, map, or\n  string of length zero.\n- an anonymous struct field is handled as if the fields of its\n  value were part of the outer struct.\n</pre> <p> If a field uses a tag \"a&gt;b&gt;c\", then the element c will be nested inside parent elements a and b. Fields that appear next to each other that name the same parent will be enclosed in one XML element. </p> <p> See MarshalIndent for an example. </p> <p> Marshal will return an error if asked to marshal a channel, function, or map. </p> <h2 id=\"MarshalIndent\">func MarshalIndent  </h2> <pre data-language=\"go\">func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</pre> <p> MarshalIndent works like Marshal, but each XML element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth. </p> <div id=\"example_MarshalIndent\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\ttype Address struct {\n\t\tCity, State string\n\t}\n\ttype Person struct {\n\t\tXMLName   xml.Name `xml:\"person\"`\n\t\tId        int      `xml:\"id,attr\"`\n\t\tFirstName string   `xml:\"name&gt;first\"`\n\t\tLastName  string   `xml:\"name&gt;last\"`\n\t\tAge       int      `xml:\"age\"`\n\t\tHeight    float32  `xml:\"height,omitempty\"`\n\t\tMarried   bool\n\t\tAddress\n\t\tComment string `xml:\",comment\"`\n\t}\n\n\tv := &amp;Person{Id: 13, FirstName: \"John\", LastName: \"Doe\", Age: 42}\n\tv.Comment = \" Need more details. \"\n\tv.Address = Address{\"Hanga Roa\", \"Easter Island\"}\n\n\toutput, err := xml.MarshalIndent(v, \"  \", \"    \")\n\tif err != nil {\n\t\tfmt.Printf(\"error: %v\\n\", err)\n\t}\n\n\tos.Stdout.Write(output)\n}\n</pre> </div> </div> <h2 id=\"Unmarshal\">func Unmarshal  </h2> <pre data-language=\"go\">func Unmarshal(data []byte, v interface{}) error</pre> <p> Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded. </p> <p> Because Unmarshal uses the reflect package, it can only assign to exported (upper case) fields. Unmarshal uses a case-sensitive comparison to match XML element names to tag values and struct field names. </p> <p> Unmarshal maps an XML element to a struct using the following rules. In the rules, the tag of a field refers to the value associated with the key 'xml' in the struct field's tag (see the example above). </p> <pre data-language=\"go\">* If the struct has a field of type []byte or string with tag\n   \",innerxml\", Unmarshal accumulates the raw XML nested inside the\n   element in that field. The rest of the rules still apply.\n\n* If the struct has a field named XMLName of type Name,\n   Unmarshal records the element name in that field.\n\n* If the XMLName field has an associated tag of the form\n   \"name\" or \"namespace-URL name\", the XML element must have\n   the given name (and, optionally, name space) or else Unmarshal\n   returns an error.\n\n* If the XML element has an attribute whose name matches a\n   struct field name with an associated tag containing \",attr\" or\n   the explicit name in a struct field tag of the form \"name,attr\",\n   Unmarshal records the attribute value in that field.\n\n* If the XML element contains character data, that data is\n   accumulated in the first struct field that has tag \",chardata\".\n   The struct field may have type []byte or string.\n   If there is no such field, the character data is discarded.\n\n* If the XML element contains comments, they are accumulated in\n   the first struct field that has tag \",comment\".  The struct\n   field may have type []byte or string. If there is no such\n   field, the comments are discarded.\n\n* If the XML element contains a sub-element whose name matches\n   the prefix of a tag formatted as \"a\" or \"a&gt;b&gt;c\", unmarshal\n   will descend into the XML structure looking for elements with the\n   given names, and will map the innermost elements to that struct\n   field. A tag starting with \"&gt;\" is equivalent to one starting\n   with the field name followed by \"&gt;\".\n\n* If the XML element contains a sub-element whose name matches\n   a struct field's XMLName tag and the struct field has no\n   explicit name tag as per the previous rule, unmarshal maps\n   the sub-element to that struct field.\n\n* If the XML element contains a sub-element whose name matches a\n   field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal\n   maps the sub-element to that struct field.\n\n* If the XML element contains a sub-element that hasn't matched any\n   of the above rules and the struct has a field with tag \",any\",\n   unmarshal maps the sub-element to that struct field.\n\n* An anonymous struct field is handled as if the fields of its\n   value were part of the outer struct.\n\n* A struct field with tag \"-\" is never unmarshalled into.\n</pre> <p> Unmarshal maps an XML element to a string or []byte by saving the concatenation of that element's character data in the string or []byte. The saved []byte is never nil. </p> <p> Unmarshal maps an attribute value to a string or []byte by saving the value in the string or slice. </p> <p> Unmarshal maps an XML element to a slice by extending the length of the slice and mapping the element to the newly created value. </p> <p> Unmarshal maps an XML element or attribute value to a bool by setting it to the boolean value represented by the string. </p> <p> Unmarshal maps an XML element or attribute value to an integer or floating-point field by setting the field to the result of interpreting the string value in decimal. There is no check for overflow. </p> <p> Unmarshal maps an XML element to a Name by recording the element name. </p> <p> Unmarshal maps an XML element to a pointer by setting the pointer to a freshly allocated value and then mapping the element to that value. </p> <div id=\"example_Unmarshal\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>This example demonstrates unmarshaling an XML excerpt into a value with some preset fields. Note that the Phone field isn't modified and that the XML &lt;Company&gt; element is ignored. Also, the Groups field is assigned considering the element path provided in its tag. </p> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n)\n\nfunc main() {\n\ttype Email struct {\n\t\tWhere string `xml:\"where,attr\"`\n\t\tAddr  string\n\t}\n\ttype Address struct {\n\t\tCity, State string\n\t}\n\ttype Result struct {\n\t\tXMLName xml.Name `xml:\"Person\"`\n\t\tName    string   `xml:\"FullName\"`\n\t\tPhone   string\n\t\tEmail   []Email\n\t\tGroups  []string `xml:\"Group&gt;Value\"`\n\t\tAddress\n\t}\n\tv := Result{Name: \"none\", Phone: \"none\"}\n\n\tdata := `\n\t\t&lt;Person&gt;\n\t\t\t&lt;FullName&gt;Grace R. Emlin&lt;/FullName&gt;\n\t\t\t&lt;Company&gt;Example Inc.&lt;/Company&gt;\n\t\t\t&lt;Email where=\"home\"&gt;\n\t\t\t\t&lt;Addr&gt;gre@example.com&lt;/Addr&gt;\n\t\t\t&lt;/Email&gt;\n\t\t\t&lt;Email where='work'&gt;\n\t\t\t\t&lt;Addr&gt;gre@work.com&lt;/Addr&gt;\n\t\t\t&lt;/Email&gt;\n\t\t\t&lt;Group&gt;\n\t\t\t\t&lt;Value&gt;Friends&lt;/Value&gt;\n\t\t\t\t&lt;Value&gt;Squash&lt;/Value&gt;\n\t\t\t&lt;/Group&gt;\n\t\t\t&lt;City&gt;Hanga Roa&lt;/City&gt;\n\t\t\t&lt;State&gt;Easter Island&lt;/State&gt;\n\t\t&lt;/Person&gt;\n\t`\n\terr := xml.Unmarshal([]byte(data), &amp;v)\n\tif err != nil {\n\t\tfmt.Printf(\"error: %v\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"XMLName: %#v\\n\", v.XMLName)\n\tfmt.Printf(\"Name: %q\\n\", v.Name)\n\tfmt.Printf(\"Phone: %q\\n\", v.Phone)\n\tfmt.Printf(\"Email: %v\\n\", v.Email)\n\tfmt.Printf(\"Groups: %v\\n\", v.Groups)\n\tfmt.Printf(\"Address: %v\\n\", v.Address)\n}\n</pre> </div> </div> <h2 id=\"Attr\">type Attr  </h2> <pre data-language=\"go\">type Attr struct {\n        Name  Name\n        Value string\n}</pre> <p> An Attr represents an attribute in an XML element (Name=Value). </p> <h2 id=\"CharData\">type CharData  </h2> <pre data-language=\"go\">type CharData []byte</pre> <p> A CharData represents XML character data (raw text), in which XML escape sequences have been replaced by the characters they represent. </p> <h3 id=\"CharData.Copy\">func (CharData) <a href=\"https://golang.org/src/encoding/xml/xml.go?s=2030:2063#L81\">Copy</a>  </h3> <pre data-language=\"go\">func (c CharData) Copy() CharData</pre> <h2 id=\"Comment\">type Comment  </h2> <pre data-language=\"go\">type Comment []byte</pre> <p> A Comment represents an XML comment of the form &lt;!--comment--&gt;. The bytes do not include the &lt;!-- and --&gt; comment markers. </p> <h3 id=\"Comment.Copy\">func (Comment) <a href=\"https://golang.org/src/encoding/xml/xml.go?s=2248:2279#L87\">Copy</a>  </h3> <pre data-language=\"go\">func (c Comment) Copy() Comment</pre> <h2 id=\"Decoder\">type Decoder  </h2> <pre data-language=\"go\">type Decoder struct {\n        // Strict defaults to true, enforcing the requirements\n        // of the XML specification.\n        // If set to false, the parser allows input containing common\n        // mistakes:\n        //\t* If an element is missing an end tag, the parser invents\n        //\t  end tags as necessary to keep the return values from Token\n        //\t  properly balanced.\n        //\t* In attribute values and character data, unknown or malformed\n        //\t  character entities (sequences beginning with &amp;) are left alone.\n        //\n        // Setting:\n        //\n        //\td.Strict = false;\n        //\td.AutoClose = HTMLAutoClose;\n        //\td.Entity = HTMLEntity\n        //\n        // creates a parser that can handle typical HTML.\n        //\n        // Strict mode does not enforce the requirements of the XML name spaces TR.\n        // In particular it does not reject name space tags using undefined prefixes.\n        // Such tags are recorded with the unknown prefix as the name space URL.\n        Strict bool\n\n        // When Strict == false, AutoClose indicates a set of elements to\n        // consider closed immediately after they are opened, regardless\n        // of whether an end element is present.\n        AutoClose []string\n\n        // Entity can be used to map non-standard entity names to string replacements.\n        // The parser behaves as if these standard mappings are present in the map,\n        // regardless of the actual map content:\n        //\n        //\t\"lt\": \"&lt;\",\n        //\t\"gt\": \"&gt;\",\n        //\t\"amp\": \"&amp;\",\n        //\t\"apos\": \"'\",\n        //\t\"quot\": `\"`,\n        Entity map[string]string\n\n        // CharsetReader, if non-nil, defines a function to generate\n        // charset-conversion readers, converting from the provided\n        // non-UTF-8 charset into UTF-8. If CharsetReader is nil or\n        // returns an error, parsing stops with an error. One of the\n        // the CharsetReader's result values must be non-nil.\n        CharsetReader func(charset string, input io.Reader) (io.Reader, error)\n\n        // DefaultSpace sets the default name space used for unadorned tags,\n        // as if the entire XML stream were wrapped in an element containing\n        // the attribute xmlns=\"DefaultSpace\".\n        DefaultSpace string\n        // contains filtered or unexported fields\n}</pre> <p> A Decoder represents an XML parser reading a particular input stream. The parser assumes that its input is encoded in UTF-8. </p> <h3 id=\"NewDecoder\">func <a href=\"https://golang.org/src/encoding/xml/xml.go?s=5592:5629#L196\">NewDecoder</a>  </h3> <pre data-language=\"go\">func NewDecoder(r io.Reader) *Decoder</pre> <p> NewDecoder creates a new XML parser reading from r. If r does not implement io.ByteReader, NewDecoder will do its own buffering. </p> <h3 id=\"Decoder.Decode\">func (*Decoder) <a href=\"https://golang.org/src/encoding/xml/read.go?s=5013:5058#L110\">Decode</a>  </h3> <pre data-language=\"go\">func (d *Decoder) Decode(v interface{}) error</pre> <p> Decode works like Unmarshal, except it reads the decoder stream to find the start element. </p> <h3 id=\"Decoder.DecodeElement\">func (*Decoder) <a href=\"https://golang.org/src/encoding/xml/read.go?s=5333:5406#L118\">DecodeElement</a>  </h3> <pre data-language=\"go\">func (d *Decoder) DecodeElement(v interface{}, start *StartElement) error</pre> <p> DecodeElement works like Unmarshal except that it takes a pointer to the start XML element to decode into v. It is useful when a client reads some raw XML tokens itself but also wants to defer to Unmarshal for some elements. </p> <h3 id=\"Decoder.InputOffset\">func (*Decoder) <a href=\"https://golang.org/src/encoding/xml/xml.go?s=21053:21090#L879\">InputOffset</a>  </h3> <pre data-language=\"go\">func (d *Decoder) InputOffset() int64</pre> <p> InputOffset returns the input stream byte offset of the current decoder position. The offset gives the location of the end of the most recently returned token and the beginning of the next token. </p> <h3 id=\"Decoder.RawToken\">func (*Decoder) <a href=\"https://golang.org/src/encoding/xml/xml.go?s=13066:13109#L488\">RawToken</a>  </h3> <pre data-language=\"go\">func (d *Decoder) RawToken() (Token, error)</pre> <p> RawToken is like Token but does not verify that start and end elements match and does not translate name space prefixes to their corresponding URLs. </p> <h3 id=\"Decoder.Skip\">func (*Decoder) <a href=\"https://golang.org/src/encoding/xml/read.go?s=20022:20052#L667\">Skip</a>  </h3> <pre data-language=\"go\">func (d *Decoder) Skip() error</pre> <p> Skip reads tokens until it has consumed the end element matching the most recent start element already consumed. It recurs if it encounters a start element, so it can be used to skip nested structures. It returns nil if it finds an end element matching the start element; otherwise it returns an error describing the problem. </p> <h3 id=\"Decoder.Token\">func (*Decoder) <a href=\"https://golang.org/src/encoding/xml/xml.go?s=6817:6857#L230\">Token</a>  </h3> <pre data-language=\"go\">func (d *Decoder) Token() (Token, error)</pre> <p> Token returns the next XML token in the input stream. At the end of the input stream, Token returns nil, io.EOF. </p> <p> Slices of bytes in the returned token data refer to the parser's internal buffer and remain valid only until the next call to Token. To acquire a copy of the bytes, call CopyToken or the token's Copy method. </p> <p> Token expands self-closing elements such as &lt;br/&gt; into separate start and end elements returned by successive calls. </p> <p> Token guarantees that the StartElement and EndElement tokens it returns are properly nested and matched: if Token encounters an unexpected end element or EOF before all expected end elements, it will return an error. </p> <p> Token implements XML name spaces as described by <a href=\"http://www.w3.org/TR/REC-xml-names/\">http://www.w3.org/TR/REC-xml-names/</a>. Each of the Name structures contained in the Token has the Space set to the URL identifying its name space when known. If Token encounters an unrecognized name space prefix, it uses the prefix as the Space rather than report an error. </p> <h2 id=\"Directive\">type Directive  </h2> <pre data-language=\"go\">type Directive []byte</pre> <p> A Directive represents an XML directive of the form &lt;!text&gt;. The bytes do not include the &lt;! and &gt; markers. </p> <h3 id=\"Directive.Copy\">func (Directive) <a href=\"https://golang.org/src/encoding/xml/xml.go?s=2665:2700#L104\">Copy</a>  </h3> <pre data-language=\"go\">func (d Directive) Copy() Directive</pre> <h2 id=\"Encoder\">type Encoder  </h2> <pre data-language=\"go\">type Encoder struct {\n        // contains filtered or unexported fields\n}</pre> <p> An Encoder writes XML data to an output stream. </p> <div id=\"example_Encoder\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\ttype Address struct {\n\t\tCity, State string\n\t}\n\ttype Person struct {\n\t\tXMLName   xml.Name `xml:\"person\"`\n\t\tId        int      `xml:\"id,attr\"`\n\t\tFirstName string   `xml:\"name&gt;first\"`\n\t\tLastName  string   `xml:\"name&gt;last\"`\n\t\tAge       int      `xml:\"age\"`\n\t\tHeight    float32  `xml:\"height,omitempty\"`\n\t\tMarried   bool\n\t\tAddress\n\t\tComment string `xml:\",comment\"`\n\t}\n\n\tv := &amp;Person{Id: 13, FirstName: \"John\", LastName: \"Doe\", Age: 42}\n\tv.Comment = \" Need more details. \"\n\tv.Address = Address{\"Hanga Roa\", \"Easter Island\"}\n\n\tenc := xml.NewEncoder(os.Stdout)\n\tenc.Indent(\"  \", \"    \")\n\tif err := enc.Encode(v); err != nil {\n\t\tfmt.Printf(\"error: %v\\n\", err)\n\t}\n\n}\n</pre> </div> </div> <h3 id=\"NewEncoder\">func <a href=\"https://golang.org/src/encoding/xml/marshal.go?s=5236:5273#L124\">NewEncoder</a>  </h3> <pre data-language=\"go\">func NewEncoder(w io.Writer) *Encoder</pre> <p> NewEncoder returns a new encoder that writes to w. </p> <h3 id=\"Encoder.Encode\">func (*Encoder) <a href=\"https://golang.org/src/encoding/xml/marshal.go?s=5858:5905#L144\">Encode</a>  </h3> <pre data-language=\"go\">func (enc *Encoder) Encode(v interface{}) error</pre> <p> Encode writes the XML encoding of v to the stream. </p> <p> See the documentation for Marshal for details about the conversion of Go values to XML. </p> <p> Encode calls Flush before returning. </p> <h3 id=\"Encoder.EncodeElement\">func (*Encoder) <a href=\"https://golang.org/src/encoding/xml/marshal.go?s=6284:6358#L159\">EncodeElement</a>  </h3> <pre data-language=\"go\">func (enc *Encoder) EncodeElement(v interface{}, start StartElement) error</pre> <p> EncodeElement writes the XML encoding of v to the stream, using start as the outermost tag in the encoding. </p> <p> See the documentation for Marshal for details about the conversion of Go values to XML. </p> <p> EncodeElement calls Flush before returning. </p> <h3 id=\"Encoder.EncodeToken\">func (*Encoder) <a href=\"https://golang.org/src/encoding/xml/marshal.go?s=7266:7312#L185\">EncodeToken</a>  </h3> <pre data-language=\"go\">func (enc *Encoder) EncodeToken(t Token) error</pre> <p> EncodeToken writes the given XML token to the stream. It returns an error if StartElement and EndElement tokens are not properly matched. </p> <p> EncodeToken does not call Flush, because usually it is part of a larger operation such as Encode or EncodeElement (or a custom Marshaler's MarshalXML invoked during those), and those will call Flush when finished. Callers that create an Encoder and then invoke EncodeToken directly, without using Encode or EncodeElement, need to call Flush when finished to ensure that the XML is written to the underlying writer. </p> <p> EncodeToken allows writing a ProcInst with Target set to \"xml\" only as the first token in the stream. </p> <h3 id=\"Encoder.Flush\">func (*Encoder) <a href=\"https://golang.org/src/encoding/xml/marshal.go?s=9818:9851#L282\">Flush</a>  </h3> <pre data-language=\"go\">func (enc *Encoder) Flush() error</pre> <p> Flush flushes any buffered XML to the underlying writer. See the EncodeToken documentation for details about when it is necessary. </p> <h3 id=\"Encoder.Indent\">func (*Encoder) <a href=\"https://golang.org/src/encoding/xml/marshal.go?s=5563:5612#L133\">Indent</a>  </h3> <pre data-language=\"go\">func (enc *Encoder) Indent(prefix, indent string)</pre> <p> Indent sets the encoder to generate XML in which each element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth. </p> <h2 id=\"EndElement\">type EndElement  </h2> <pre data-language=\"go\">type EndElement struct {\n        Name Name\n}</pre> <p> An EndElement represents an XML end element. </p> <h2 id=\"Marshaler\">type Marshaler  </h2> <pre data-language=\"go\">type Marshaler interface {\n        MarshalXML(e *Encoder, start StartElement) error\n}</pre> <p> Marshaler is the interface implemented by objects that can marshal themselves into valid XML elements. </p> <p> MarshalXML encodes the receiver as zero or more XML elements. By convention, arrays or slices are typically encoded as a sequence of elements, one per entry. Using start as the element tag is not required, but doing so will enable Unmarshal to match the XML elements to the correct struct field. One common implementation strategy is to construct a separate value with a layout corresponding to the desired XML and then to encode it using e.EncodeElement. Another common strategy is to use repeated calls to e.EncodeToken to generate the XML output one token at a time. The sequence of encoded tokens must make up zero or more valid XML elements. </p> <h2 id=\"MarshalerAttr\">type MarshalerAttr  </h2> <pre data-language=\"go\">type MarshalerAttr interface {\n        MarshalXMLAttr(name Name) (Attr, error)\n}</pre> <p> MarshalerAttr is the interface implemented by objects that can marshal themselves into valid XML attributes. </p> <p> MarshalXMLAttr returns an XML attribute with the encoded value of the receiver. Using name as the attribute name is not required, but doing so will enable Unmarshal to match the attribute to the correct struct field. If MarshalXMLAttr returns the zero attribute Attr{}, no attribute will be generated in the output. MarshalXMLAttr is used only for struct fields with the \"attr\" option in the field tag. </p> <h2 id=\"Name\">type Name  </h2> <pre data-language=\"go\">type Name struct {\n        Space, Local string\n}</pre> <p> A Name represents an XML name (Local) annotated with a name space identifier (Space). In tokens returned by Decoder.Token, the Space identifier is given as a canonical URL, not the short prefix used in the document being parsed. </p> <h2 id=\"ProcInst\">type ProcInst  </h2> <pre data-language=\"go\">type ProcInst struct {\n        Target string\n        Inst   []byte\n}</pre> <p> A ProcInst represents an XML processing instruction of the form &lt;?target inst?&gt; </p> <h3 id=\"ProcInst.Copy\">func (ProcInst) <a href=\"https://golang.org/src/encoding/xml/xml.go?s=2452:2485#L95\">Copy</a>  </h3> <pre data-language=\"go\">func (p ProcInst) Copy() ProcInst</pre> <h2 id=\"StartElement\">type StartElement  </h2> <pre data-language=\"go\">type StartElement struct {\n        Name Name\n        Attr []Attr\n}</pre> <p> A StartElement represents an XML start element. </p> <h3 id=\"StartElement.Copy\">func (StartElement) <a href=\"https://golang.org/src/encoding/xml/xml.go?s=1437:1478#L53\">Copy</a>  </h3> <pre data-language=\"go\">func (e StartElement) Copy() StartElement</pre> <h3 id=\"StartElement.End\">func (StartElement) <a href=\"https://golang.org/src/encoding/xml/xml.go?s=1617:1655#L61\">End</a>  </h3> <pre data-language=\"go\">func (e StartElement) End() EndElement</pre> <p> End returns the corresponding XML end element. </p> <h2 id=\"SyntaxError\">type SyntaxError  </h2> <pre data-language=\"go\">type SyntaxError struct {\n        Msg  string\n        Line int\n}</pre> <p> A SyntaxError represents a syntax error in the XML input stream. </p> <h3 id=\"SyntaxError.Error\">func (*SyntaxError) <a href=\"https://golang.org/src/encoding/xml/xml.go?s=659:695#L24\">Error</a>  </h3> <pre data-language=\"go\">func (e *SyntaxError) Error() string</pre> <h2 id=\"TagPathError\">type TagPathError  </h2> <pre data-language=\"go\">type TagPathError struct {\n        Struct       reflect.Type\n        Field1, Tag1 string\n        Field2, Tag2 string\n}</pre> <p> A TagPathError represents an error in the unmarshalling process caused by the use of field tags with conflicting paths. </p> <h3 id=\"TagPathError.Error\">func (*TagPathError) <a href=\"https://golang.org/src/encoding/xml/typeinfo.go?s=8905:8942#L335\">Error</a>  </h3> <pre data-language=\"go\">func (e *TagPathError) Error() string</pre> <h2 id=\"Token\">type Token  </h2> <pre data-language=\"go\">type Token interface{}</pre> <p> A Token is an interface holding one of the token types: StartElement, EndElement, CharData, Comment, ProcInst, or Directive. </p> <h3 id=\"CopyToken\">func <a href=\"https://golang.org/src/encoding/xml/xml.go?s=2776:2805#L107\">CopyToken</a>  </h3> <pre data-language=\"go\">func CopyToken(t Token) Token</pre> <p> CopyToken returns a copy of a Token. </p> <h2 id=\"UnmarshalError\">type UnmarshalError  </h2> <pre data-language=\"go\">type UnmarshalError string</pre> <p> An UnmarshalError represents an error in the unmarshalling process. </p> <h3 id=\"UnmarshalError.Error\">func (UnmarshalError) <a href=\"https://golang.org/src/encoding/xml/read.go?s=5667:5705#L129\">Error</a>  </h3> <pre data-language=\"go\">func (e UnmarshalError) Error() string</pre> <h2 id=\"Unmarshaler\">type Unmarshaler  </h2> <pre data-language=\"go\">type Unmarshaler interface {\n        UnmarshalXML(d *Decoder, start StartElement) error\n}</pre> <p> Unmarshaler is the interface implemented by objects that can unmarshal an XML element description of themselves. </p> <p> UnmarshalXML decodes a single XML element beginning with the given start element. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXML must consume exactly one XML element. One common implementation strategy is to unmarshal into a separate value with a layout matching the expected XML using d.DecodeElement, and then to copy the data from that value into the receiver. Another common strategy is to use d.Token to process the XML object one token at a time. UnmarshalXML may not use d.RawToken. </p> <h2 id=\"UnmarshalerAttr\">type UnmarshalerAttr  </h2> <pre data-language=\"go\">type UnmarshalerAttr interface {\n        UnmarshalXMLAttr(attr Attr) error\n}</pre> <p> UnmarshalerAttr is the interface implemented by objects that can unmarshal an XML attribute description of themselves. </p> <p> UnmarshalXMLAttr decodes a single XML attribute. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXMLAttr is used only for struct fields with the \"attr\" option in the field tag. </p> <h2 id=\"UnsupportedTypeError\">type UnsupportedTypeError  </h2> <pre data-language=\"go\">type UnsupportedTypeError struct {\n        Type reflect.Type\n}</pre> <p> A MarshalXMLError is returned when Marshal encounters a type that cannot be converted into XML. </p> <h3 id=\"UnsupportedTypeError.Error\">func (*UnsupportedTypeError) <a href=\"https://golang.org/src/encoding/xml/marshal.go?s=27671:27716#L976\">Error</a>  </h3> <pre data-language=\"go\">func (e *UnsupportedTypeError) Error() string</pre> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/encoding/xml/read.go?s=256:578#L7\" style=\"float: left;\">☞</a> <p> Mapping between XML elements and data structures is inherently flawed: an XML element is an order-dependent collection of anonymous values, while a data structure is an order-independent collection of named values. See package json for a textual representation more suitable to data structures. </p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/encoding/xml/\" class=\"_attribution-link\">https://golang.org/pkg/encoding/xml/</a>\n  </p>\n</div>\n","go/build/index":"<h1>Package build</h1>     <ul id=\"short-nav\">\n<li><code>import \"go/build\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package build gathers information about Go packages. </p> <h3 id=\"hdr-Go_Path\">Go Path</h3> <p> The Go path is a list of directory trees containing Go source code. It is consulted to resolve imports that cannot be found in the standard Go tree. The default path is the value of the GOPATH environment variable, interpreted as a path list appropriate to the operating system (on Unix, the variable is a colon-separated string; on Windows, a semicolon-separated string; on Plan 9, a list). </p> <p> Each directory listed in the Go path must have a prescribed structure: </p> <p> The src/ directory holds source code. The path below 'src' determines the import path or executable name. </p> <p> The pkg/ directory holds installed package objects. As in the Go tree, each target operating system and architecture pair has its own subdirectory of pkg (pkg/GOOS_GOARCH). </p> <p> If DIR is a directory listed in the Go path, a package with source in DIR/src/foo/bar can be imported as \"foo/bar\" and has its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\" (or, for gccgo, \"DIR/pkg/gccgo/foo/libbar.a\"). </p> <p> The bin/ directory holds compiled commands. Each command is named for its source directory, but only using the final element, not the entire path. That is, the command with source in DIR/src/foo/quux is installed into DIR/bin/quux, not DIR/bin/foo/quux. The foo/ is stripped so that you can add DIR/bin to your PATH to get at the installed commands. </p> <p> Here's an example directory layout: </p> <pre data-language=\"go\">GOPATH=/home/user/gocode\n\n/home/user/gocode/\n    src/\n        foo/\n            bar/               (go code in package bar)\n                x.go\n            quux/              (go code in package main)\n                y.go\n    bin/\n        quux                   (installed command)\n    pkg/\n        linux_amd64/\n            foo/\n                bar.a          (installed package object)\n</pre> <h3 id=\"hdr-Build_Constraints\">Build Constraints</h3> <p> A build constraint, also known as a build tag, is a line comment that begins </p> <pre data-language=\"go\">// +build\n</pre> <p> that lists the conditions under which a file should be included in the package. Constraints may appear in any kind of source file (not just Go), but they must appear near the top of the file, preceded only by blank lines and other line comments. These rules mean that in Go files a build constraint must appear before the package clause. </p> <p> To distinguish build constraints from package documentation, a series of build constraints must be followed by a blank line. </p> <p> A build constraint is evaluated as the OR of space-separated options; each option evaluates as the AND of its comma-separated terms; and each term is an alphanumeric word or, preceded by !, its negation. That is, the build constraint: </p> <pre data-language=\"go\">// +build linux,386 darwin,!cgo\n</pre> <p> corresponds to the boolean formula: </p> <pre data-language=\"go\">(linux AND 386) OR (darwin AND (NOT cgo))\n</pre> <p> A file may have multiple build constraints. The overall constraint is the AND of the individual constraints. That is, the build constraints: </p> <pre data-language=\"go\">// +build linux darwin\n// +build 386\n</pre> <p> corresponds to the boolean formula: </p> <pre data-language=\"go\">(linux OR darwin) AND 386\n</pre> <p> During a particular build, the following words are satisfied: </p> <pre data-language=\"go\">- the target operating system, as spelled by runtime.GOOS\n- the target architecture, as spelled by runtime.GOARCH\n- the compiler being used, either \"gc\" or \"gccgo\"\n- \"cgo\", if ctxt.CgoEnabled is true\n- \"go1.1\", from Go version 1.1 onward\n- \"go1.2\", from Go version 1.2 onward\n- \"go1.3\", from Go version 1.3 onward\n- \"go1.4\", from Go version 1.4 onward\n- \"go1.5\", from Go version 1.5 onward\n- \"go1.6\", from Go version 1.6 onward\n- \"go1.7\", from Go version 1.7 onward\n- any additional words listed in ctxt.BuildTags\n</pre> <p> If a file's name, after stripping the extension and a possible _test suffix, matches any of the following patterns: </p> <pre data-language=\"go\">*_GOOS\n*_GOARCH\n*_GOOS_GOARCH\n</pre> <p> (example: source_windows_amd64.go) where GOOS and GOARCH represent any known operating system and architecture values respectively, then the file is considered to have an implicit build constraint requiring those terms (in addition to any explicit constraints in the file). </p> <p> To keep a file from being considered for the build: </p> <pre data-language=\"go\">// +build ignore\n</pre> <p> (any other unsatisfied word will work as well, but “ignore” is conventional.) </p> <p> To build a file only when using cgo, and only on Linux and OS X: </p> <pre data-language=\"go\">// +build linux,cgo darwin,cgo\n</pre> <p> Such a file is usually paired with another file implementing the default functionality for other systems, which in this case would carry the constraint: </p> <pre data-language=\"go\">// +build !linux,!darwin !cgo\n</pre> <p> Naming a file dns_windows.go will cause it to be included only when building the package for Windows; similarly, math_386.s will be included only when building the package for 32-bit x86. </p> <p> Using GOOS=android matches build tags and files as for GOOS=linux in addition to android tags and files. </p> <h3 id=\"hdr-Binary_Only_Packages\">Binary-Only Packages</h3> <p> It is possible to distribute packages in binary form without including the source code used for compiling the package. To do this, the package must be distributed with a source file not excluded by build constraints and containing a \"//go:binary-only-package\" comment. Like a build constraint, this comment must appear near the top of the file, preceded only by blank lines and other line comments and with a blank line following the comment, to separate it from the package documentation. Unlike build constraints, this comment is only recognized in non-test Go source files. </p> <p> The minimal source code for a binary-only package is therefore: </p> <pre data-language=\"go\">//go:binary-only-package\n\npackage mypkg\n</pre> <p> The source code may include additional Go code. That code is never compiled but will be processed by tools like godoc and might be useful as end-user documentation. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#ArchChar\">func ArchChar(goarch string) (string, error)</a></li>\n<li><a href=\"#IsLocalImport\">func IsLocalImport(path string) bool</a></li>\n<li><a href=\"#Context\">type Context</a></li>\n<li> <a href=\"#Context.Import\">func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Package, error)</a>\n</li>\n<li> <a href=\"#Context.ImportDir\">func (ctxt *Context) ImportDir(dir string, mode ImportMode) (*Package, error)</a>\n</li>\n<li> <a href=\"#Context.MatchFile\">func (ctxt *Context) MatchFile(dir, name string) (match bool, err error)</a>\n</li>\n<li> <a href=\"#Context.SrcDirs\">func (ctxt *Context) SrcDirs() []string</a>\n</li>\n<li><a href=\"#ImportMode\">type ImportMode</a></li>\n<li><a href=\"#MultiplePackageError\">type MultiplePackageError</a></li>\n<li> <a href=\"#MultiplePackageError.Error\">func (e *MultiplePackageError) Error() string</a>\n</li>\n<li><a href=\"#NoGoError\">type NoGoError</a></li>\n<li> <a href=\"#NoGoError.Error\">func (e *NoGoError) Error() string</a>\n</li>\n<li><a href=\"#Package\">type Package</a></li>\n<li> <a href=\"#Import\">func Import(path, srcDir string, mode ImportMode) (*Package, error)</a>\n</li>\n<li> <a href=\"#ImportDir\">func ImportDir(dir string, mode ImportMode) (*Package, error)</a>\n</li>\n<li> <a href=\"#Package.IsCommand\">func (p *Package) IsCommand() bool</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/go/build/build.go\">build.go</a> <a href=\"https://golang.org/src/go/build/doc.go\">doc.go</a> <a href=\"https://golang.org/src/go/build/read.go\">read.go</a> <a href=\"https://golang.org/src/go/build/syslist.go\">syslist.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ToolDir = filepath.Join(runtime.GOROOT(), \"pkg/tool/\"+runtime.GOOS+\"_\"+runtime.GOARCH)</pre> <p> ToolDir is the directory containing build tools. </p> <h2 id=\"ArchChar\">func ArchChar  </h2> <pre data-language=\"go\">func ArchChar(goarch string) (string, error)</pre> <p> ArchChar returns \"?\" and an error. In earlier versions of Go, the returned string was used to derive the compiler and linker tool names, the default object file suffix, and the default linker output name. As of Go 1.5, those strings no longer vary by architecture; they are compile, link, .o, and a.out, respectively. </p> <h2 id=\"IsLocalImport\">func IsLocalImport  </h2> <pre data-language=\"go\">func IsLocalImport(path string) bool</pre> <p> IsLocalImport reports whether the import path is a local import path, like \".\", \"..\", \"./foo\", or \"../foo\". </p> <h2 id=\"Context\">type Context  </h2> <pre data-language=\"go\">type Context struct {\n        GOARCH      string // target architecture\n        GOOS        string // target operating system\n        GOROOT      string // Go root\n        GOPATH      string // Go path\n        CgoEnabled  bool   // whether cgo can be used\n        UseAllFiles bool   // use files regardless of +build lines, file names\n        Compiler    string // compiler to assume when computing target paths\n\n        // The build and release tags specify build constraints\n        // that should be considered satisfied when processing +build lines.\n        // Clients creating a new context may customize BuildTags, which\n        // defaults to empty, but it is usually an error to customize ReleaseTags,\n        // which defaults to the list of Go releases the current release is compatible with.\n        // In addition to the BuildTags and ReleaseTags, build constraints\n        // consider the values of GOARCH and GOOS as satisfied tags.\n        BuildTags   []string\n        ReleaseTags []string\n\n        // The install suffix specifies a suffix to use in the name of the installation\n        // directory. By default it is empty, but custom builds that need to keep\n        // their outputs separate can set InstallSuffix to do so. For example, when\n        // using the race detector, the go command uses InstallSuffix = \"race\", so\n        // that on a Linux/386 system, packages are written to a directory named\n        // \"linux_386_race\" instead of the usual \"linux_386\".\n        InstallSuffix string\n\n        // JoinPath joins the sequence of path fragments into a single path.\n        // If JoinPath is nil, Import uses filepath.Join.\n        JoinPath func(elem ...string) string\n\n        // SplitPathList splits the path list into a slice of individual paths.\n        // If SplitPathList is nil, Import uses filepath.SplitList.\n        SplitPathList func(list string) []string\n\n        // IsAbsPath reports whether path is an absolute path.\n        // If IsAbsPath is nil, Import uses filepath.IsAbs.\n        IsAbsPath func(path string) bool\n\n        // IsDir reports whether the path names a directory.\n        // If IsDir is nil, Import calls os.Stat and uses the result's IsDir method.\n        IsDir func(path string) bool\n\n        // HasSubdir reports whether dir is a subdirectory of\n        // (perhaps multiple levels below) root.\n        // If so, HasSubdir sets rel to a slash-separated path that\n        // can be joined to root to produce a path equivalent to dir.\n        // If HasSubdir is nil, Import uses an implementation built on\n        // filepath.EvalSymlinks.\n        HasSubdir func(root, dir string) (rel string, ok bool)\n\n        // ReadDir returns a slice of os.FileInfo, sorted by Name,\n        // describing the content of the named directory.\n        // If ReadDir is nil, Import uses ioutil.ReadDir.\n        ReadDir func(dir string) ([]os.FileInfo, error)\n\n        // OpenFile opens a file (not a directory) for reading.\n        // If OpenFile is nil, Import uses os.Open.\n        OpenFile func(path string) (io.ReadCloser, error)\n}</pre> <p> A Context specifies the supporting context for a build. </p> <pre data-language=\"go\">var Default Context = defaultContext()</pre> <p> Default is the default Context for builds. It uses the GOARCH, GOOS, GOROOT, and GOPATH environment variables if set, or else the compiled code's GOARCH, GOOS, and GOROOT. </p> <h3 id=\"Context.Import\">func (*Context) <a href=\"https://golang.org/src/go/build/build.go?s=15867:15957#L447\">Import</a>  </h3> <pre data-language=\"go\">func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Package, error)</pre> <p> Import returns details about the Go package named by the import path, interpreting local import paths relative to the srcDir directory. If the path is a local import path naming a package that can be imported using a standard import path, the returned package will set p.ImportPath to that path. </p> <p> In the directory containing the package, .go, .c, .h, and .s files are considered part of the package except for: </p> <pre data-language=\"go\">- .go files in package documentation\n- files starting with _ or . (likely editor temporary files)\n- files with build constraints not satisfied by the context\n</pre> <p> If an error occurs, Import returns a non-nil error and a non-nil *Package containing partial information. </p> <h3 id=\"Context.ImportDir\">func (*Context) <a href=\"https://golang.org/src/go/build/build.go?s=14030:14107#L395\">ImportDir</a>  </h3> <pre data-language=\"go\">func (ctxt *Context) ImportDir(dir string, mode ImportMode) (*Package, error)</pre> <p> ImportDir is like Import but processes the Go package found in the named directory. </p> <h3 id=\"Context.MatchFile\">func (*Context) <a href=\"https://golang.org/src/go/build/build.go?s=30119:30191#L993\">MatchFile</a>  </h3> <pre data-language=\"go\">func (ctxt *Context) MatchFile(dir, name string) (match bool, err error)</pre> <p> MatchFile reports whether the file with the given name in the given directory matches the context and would be included in a Package created by ImportDir of that directory. </p> <p> MatchFile considers the name of the file and may use ctxt.OpenFile to read some or all of the file's content. </p> <h3 id=\"Context.SrcDirs\">func (*Context) <a href=\"https://golang.org/src/go/build/build.go?s=7464:7503#L227\">SrcDirs</a>  </h3> <pre data-language=\"go\">func (ctxt *Context) SrcDirs() []string</pre> <p> SrcDirs returns a list of package source root directories. It draws from the current Go root and Go path but omits directories that do not exist. </p> <h2 id=\"ImportMode\">type ImportMode  </h2> <pre data-language=\"go\">type ImportMode uint</pre> <p> An ImportMode controls the behavior of the Import method. </p> <pre data-language=\"go\">const (\n        // If FindOnly is set, Import stops after locating the directory\n        // that should contain the sources for a package. It does not\n        // read any files in the directory.\n        FindOnly ImportMode = 1 &lt;&lt; iota\n\n        // If AllowBinary is set, Import can be satisfied by a compiled\n        // package object without corresponding sources.\n        //\n        // Deprecated:\n        // The supported way to create a compiled-only package is to\n        // write source code containing a //go:binary-only-package comment at\n        // the top of the file. Such a package will be recognized\n        // regardless of this flag setting (because it has source code)\n        // and will have BinaryOnly set to true in the returned Package.\n        AllowBinary\n\n        // If ImportComment is set, parse import comments on package statements.\n        // Import returns an error if it finds a comment it cannot understand\n        // or finds conflicting comments in multiple source files.\n        // See golang.org/s/go14customimport for more information.\n        ImportComment\n\n        // By default, Import searches vendor directories\n        // that apply in the given source directory before searching\n        // the GOROOT and GOPATH roots.\n        // If an Import finds and returns a package using a vendor\n        // directory, the resulting ImportPath is the complete path\n        // to the package, including the path elements leading up\n        // to and including \"vendor\".\n        // For example, if Import(\"y\", \"x/subdir\", 0) finds\n        // \"x/vendor/y\", the returned package's ImportPath is \"x/vendor/y\",\n        // not plain \"y\".\n        // See golang.org/s/go15vendor for more information.\n        //\n        // Setting IgnoreVendor ignores vendor directories.\n        IgnoreVendor\n)</pre> <h2 id=\"MultiplePackageError\">type MultiplePackageError  </h2> <pre data-language=\"go\">type MultiplePackageError struct {\n        Dir      string   // directory containing files\n        Packages []string // package names found\n        Files    []string // corresponding files: Files[i] declares package Packages[i]\n}</pre> <p> MultiplePackageError describes a directory containing multiple buildable Go source files for multiple packages. </p> <h3 id=\"MultiplePackageError.Error\">func (*MultiplePackageError) <a href=\"https://golang.org/src/go/build/build.go?s=14793:14838#L418\">Error</a>  </h3> <pre data-language=\"go\">func (e *MultiplePackageError) Error() string</pre> <h2 id=\"NoGoError\">type NoGoError  </h2> <pre data-language=\"go\">type NoGoError struct {\n        Dir string\n}</pre> <p> NoGoError is the error used by Import to describe a directory containing no buildable Go source files. (It may still contain test files, files hidden by build tags, and so on.) </p> <h3 id=\"NoGoError.Error\">func (*NoGoError) <a href=\"https://golang.org/src/go/build/build.go?s=14374:14408#L406\">Error</a>  </h3> <pre data-language=\"go\">func (e *NoGoError) Error() string</pre> <h2 id=\"Package\">type Package  </h2> <pre data-language=\"go\">type Package struct {\n        Dir           string   // directory containing package sources\n        Name          string   // package name\n        ImportComment string   // path in import comment on package statement\n        Doc           string   // documentation synopsis\n        ImportPath    string   // import path of package (\"\" if unknown)\n        Root          string   // root of Go tree where this package lives\n        SrcRoot       string   // package source root directory (\"\" if unknown)\n        PkgRoot       string   // package install root directory (\"\" if unknown)\n        PkgTargetRoot string   // architecture dependent install root directory (\"\" if unknown)\n        BinDir        string   // command install directory (\"\" if unknown)\n        Goroot        bool     // package found in Go root\n        PkgObj        string   // installed .a file\n        AllTags       []string // tags that can influence file selection in this directory\n        ConflictDir   string   // this directory shadows Dir in $GOPATH\n        BinaryOnly    bool     // cannot be rebuilt from source (has //go:binary-only-package comment)\n\n        // Source files\n        GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n        CgoFiles       []string // .go source files that import \"C\"\n        IgnoredGoFiles []string // .go source files ignored for this build\n        InvalidGoFiles []string // .go source files with detected problems (parse error, wrong package name, and so on)\n        CFiles         []string // .c source files\n        CXXFiles       []string // .cc, .cpp and .cxx source files\n        MFiles         []string // .m (Objective-C) source files\n        HFiles         []string // .h, .hh, .hpp and .hxx source files\n        FFiles         []string // .f, .F, .for and .f90 Fortran source files\n        SFiles         []string // .s source files\n        SwigFiles      []string // .swig files\n        SwigCXXFiles   []string // .swigcxx files\n        SysoFiles      []string // .syso system object files to add to archive\n\n        // Cgo directives\n        CgoCFLAGS    []string // Cgo CFLAGS directives\n        CgoCPPFLAGS  []string // Cgo CPPFLAGS directives\n        CgoCXXFLAGS  []string // Cgo CXXFLAGS directives\n        CgoFFLAGS    []string // Cgo FFLAGS directives\n        CgoLDFLAGS   []string // Cgo LDFLAGS directives\n        CgoPkgConfig []string // Cgo pkg-config directives\n\n        // Dependency information\n        Imports   []string                    // imports from GoFiles, CgoFiles\n        ImportPos map[string][]token.Position // line information for Imports\n\n        // Test information\n        TestGoFiles    []string                    // _test.go files in package\n        TestImports    []string                    // imports from TestGoFiles\n        TestImportPos  map[string][]token.Position // line information for TestImports\n        XTestGoFiles   []string                    // _test.go files outside package\n        XTestImports   []string                    // imports from XTestGoFiles\n        XTestImportPos map[string][]token.Position // line information for XTestImports\n}</pre> <p> A Package describes the Go package found in a directory. </p> <h3 id=\"Import\">func <a href=\"https://golang.org/src/go/build/build.go?s=32403:32470#L1074\">Import</a>  </h3> <pre data-language=\"go\">func Import(path, srcDir string, mode ImportMode) (*Package, error)</pre> <p> Import is shorthand for Default.Import. </p> <h3 id=\"ImportDir\">func <a href=\"https://golang.org/src/go/build/build.go?s=32568:32629#L1079\">ImportDir</a>  </h3> <pre data-language=\"go\">func ImportDir(dir string, mode ImportMode) (*Package, error)</pre> <p> ImportDir is shorthand for Default.ImportDir. </p> <h3 id=\"Package.IsCommand\">func (*Package) <a href=\"https://golang.org/src/go/build/build.go?s=13875:13909#L389\">IsCommand</a>  </h3> <pre data-language=\"go\">func (p *Package) IsCommand() bool</pre> <p> IsCommand reports whether the package is considered a command to be installed (not just a library). Packages named \"main\" are treated as commands. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/go/build/\" class=\"_attribution-link\">https://golang.org/pkg/go/build/</a>\n  </p>\n</div>\n","hash/crc64/index":"<h1>Package crc64</h1>     <ul id=\"short-nav\">\n<li><code>import \"hash/crc64\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum. See <a href=\"http://en.wikipedia.org/wiki/Cyclic_redundancy_check\">http://en.wikipedia.org/wiki/Cyclic_redundancy_check</a> for information. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#Checksum\">func Checksum(data []byte, tab *Table) uint64</a></li>\n<li><a href=\"#New\">func New(tab *Table) hash.Hash64</a></li>\n<li><a href=\"#Update\">func Update(crc uint64, tab *Table, p []byte) uint64</a></li>\n<li><a href=\"#Table\">type Table</a></li>\n<li> <a href=\"#MakeTable\">func MakeTable(poly uint64) *Table</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/hash/crc64/crc64.go\">crc64.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        // The ISO polynomial, defined in ISO 3309 and used in HDLC.\n        ISO = 0xD800000000000000\n\n        // The ECMA polynomial, defined in ECMA 182.\n        ECMA = 0xC96C5795D7870F42\n)</pre> <p> Predefined polynomials. </p> <pre data-language=\"go\">const Size = 8</pre> <p> The size of a CRC-64 checksum in bytes. </p> <h2 id=\"Checksum\">func Checksum  </h2> <pre data-language=\"go\">func Checksum(data []byte, tab *Table) uint64</pre> <p> Checksum returns the CRC-64 checksum of data using the polynomial represented by the Table. </p> <h2 id=\"New\">func New  </h2> <pre data-language=\"go\">func New(tab *Table) hash.Hash64</pre> <p> New creates a new hash.Hash64 computing the CRC-64 checksum using the polynomial represented by the Table. Its Sum method will lay the value out in big-endian byte order. </p> <h2 id=\"Update\">func Update  </h2> <pre data-language=\"go\">func Update(crc uint64, tab *Table, p []byte) uint64</pre> <p> Update returns the result of adding the bytes in p to the crc. </p> <h2 id=\"Table\">type Table  </h2> <pre data-language=\"go\">type Table [256]uint64</pre> <p> Table is a 256-word table representing the polynomial for efficient processing. </p> <h3 id=\"MakeTable\">func <a href=\"https://golang.org/src/hash/crc64/crc64.go?s=969:1003#L24\">MakeTable</a>  </h3> <pre data-language=\"go\">func MakeTable(poly uint64) *Table</pre> <p> MakeTable returns a Table constructed from the specified polynomial. The contents of this Table must not be modified. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/hash/crc64/\" class=\"_attribution-link\">https://golang.org/pkg/hash/crc64/</a>\n  </p>\n</div>\n","hash/fnv/index":"<h1>Package fnv</h1>     <ul id=\"short-nav\">\n<li><code>import \"hash/fnv\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo. See <a href=\"https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function\">https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function</a>. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#New32\">func New32() hash.Hash32</a></li>\n<li><a href=\"#New32a\">func New32a() hash.Hash32</a></li>\n<li><a href=\"#New64\">func New64() hash.Hash64</a></li>\n<li><a href=\"#New64a\">func New64a() hash.Hash64</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/hash/fnv/fnv.go\">fnv.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"New32\">func New32  </h2> <pre data-language=\"go\">func New32() hash.Hash32</pre> <p> New32 returns a new 32-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order. </p> <h2 id=\"New32a\">func New32a  </h2> <pre data-language=\"go\">func New32a() hash.Hash32</pre> <p> New32a returns a new 32-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order. </p> <h2 id=\"New64\">func New64  </h2> <pre data-language=\"go\">func New64() hash.Hash64</pre> <p> New64 returns a new 64-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order. </p> <h2 id=\"New64a\">func New64a  </h2> <pre data-language=\"go\">func New64a() hash.Hash64</pre> <p> New64a returns a new 64-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/hash/fnv/\" class=\"_attribution-link\">https://golang.org/pkg/hash/fnv/</a>\n  </p>\n</div>\n","html/index":"<h1>Package html</h1>     <ul id=\"short-nav\">\n<li><code>import \"html\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package html provides functions for escaping and unescaping HTML text. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#EscapeString\">func EscapeString(s string) string</a></li>\n<li><a href=\"#UnescapeString\">func UnescapeString(s string) string</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_EscapeString\">EscapeString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_UnescapeString\">UnescapeString</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/html/entity.go\">entity.go</a> <a href=\"https://golang.org/src/html/escape.go\">escape.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"EscapeString\">func EscapeString  </h2> <pre data-language=\"go\">func EscapeString(s string) string</pre> <p> EscapeString escapes special characters like \"&lt;\" to become \"&amp;lt;\". It escapes only five such characters: &lt;, &gt;, &amp;, ' and \". UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true. </p> <div id=\"example_EscapeString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"html\"\n)\n\nfunc main() {\n\tconst s = `\"Fran &amp; Freddie's Diner\" &lt;tasty@example.com&gt;`\n\tfmt.Println(html.EscapeString(s))\n}\n</pre> </div> </div> <h2 id=\"UnescapeString\">func UnescapeString  </h2> <pre data-language=\"go\">func UnescapeString(s string) string</pre> <p> UnescapeString unescapes entities like \"&amp;lt;\" to become \"&lt;\". It unescapes a larger range of entities than EscapeString escapes. For example, \"&amp;aacute;\" unescapes to \"á\", as does \"&amp;#225;\" and \"&amp;#xE1;\". UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true. </p> <div id=\"example_UnescapeString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"html\"\n)\n\nfunc main() {\n\tconst s = `&amp;quot;Fran &amp;amp; Freddie&amp;#39;s Diner&amp;quot; &amp;lt;tasty@example.com&amp;gt;`\n\tfmt.Println(html.UnescapeString(s))\n}\n</pre> </div> </div> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"template/index\">template</a> </td> <td class=\"pkg-synopsis\"> Package template (html/template) implements data-driven templates for generating HTML output safe against code injection. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/html/\" class=\"_attribution-link\">https://golang.org/pkg/html/</a>\n  </p>\n</div>\n","fmt/index":"<h1>Package fmt</h1>     <ul id=\"short-nav\">\n<li><code>import \"fmt\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package fmt implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler. </p> <h3 id=\"hdr-Printing\">Printing</h3> <p> The verbs: </p> <p> General: </p> <pre data-language=\"go\">%v\tthe value in a default format\n\twhen printing structs, the plus flag (%+v) adds field names\n%#v\ta Go-syntax representation of the value\n%T\ta Go-syntax representation of the type of the value\n%%\ta literal percent sign; consumes no value\n</pre> <p> Boolean: </p> <pre data-language=\"go\">%t\tthe word true or false\n</pre> <p> Integer: </p> <pre data-language=\"go\">%b\tbase 2\n%c\tthe character represented by the corresponding Unicode code point\n%d\tbase 10\n%o\tbase 8\n%q\ta single-quoted character literal safely escaped with Go syntax.\n%x\tbase 16, with lower-case letters for a-f\n%X\tbase 16, with upper-case letters for A-F\n%U\tUnicode format: U+1234; same as \"U+%04X\"\n</pre> <p> Floating-point and complex constituents: </p> <pre data-language=\"go\">%b\tdecimalless scientific notation with exponent a power of two,\n\tin the manner of strconv.FormatFloat with the 'b' format,\n\te.g. -123456p-78\n%e\tscientific notation, e.g. -1.234456e+78\n%E\tscientific notation, e.g. -1.234456E+78\n%f\tdecimal point but no exponent, e.g. 123.456\n%F\tsynonym for %f\n%g\t%e for large exponents, %f otherwise\n%G\t%E for large exponents, %F otherwise\n</pre> <p> String and slice of bytes (treated equivalently with these verbs): </p> <pre data-language=\"go\">%s\tthe uninterpreted bytes of the string or slice\n%q\ta double-quoted string safely escaped with Go syntax\n%x\tbase 16, lower-case, two characters per byte\n%X\tbase 16, upper-case, two characters per byte\n</pre> <p> Pointer: </p> <pre data-language=\"go\">%p\tbase 16 notation, with leading 0x\n</pre> <p> There is no 'u' flag. Integers are printed unsigned if they have unsigned type. Similarly, there is no need to specify the size of the operand (int8, int64). </p> <p> The default format for %v is: </p> <pre data-language=\"go\">bool:                    %t\nint, int8 etc.:          %d\nuint, uint8 etc.:        %d, %x if printed with %#v\nfloat32, complex64, etc: %g\nstring:                  %s\nchan:                    %p\npointer:                 %p\n</pre> <p> For compound objects, the elements are printed using these rules, recursively, laid out like this: </p> <pre data-language=\"go\">struct:             {field0 field1 ...}\narray, slice:       [elem0 elem1 ...]\nmaps:               map[key1:value1 key2:value2]\npointer to above:   &amp;{}, &amp;[], &amp;map[]\n</pre> <p> Width is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples: </p> <pre data-language=\"go\">%f     default width, default precision\n%9f    width 9, default precision\n%.2f   default width, precision 2\n%9.2f  width 9, precision 2\n%9.f   width 9, precision 0\n</pre> <p> Width and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand, which must be of type int. </p> <p> For most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary. </p> <p> For strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes. </p> <p> For floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the total number of significant digits. For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e and %f is 6; for %g it is the smallest number of digits necessary to identify the value uniquely. </p> <p> For complex numbers, the width and precision apply to the two components independently and the result is parenthesized, so %f applied to 1.2+3.4i produces (1.200000+3.400000i). </p> <p> Other flags: </p> <pre data-language=\"go\">+\talways print a sign for numeric values;\n\tguarantee ASCII-only output for %q (%+q)\n-\tpad with spaces on the right rather than the left (left-justify the field)\n#\talternate format: add leading 0 for octal (%#o), 0x for hex (%#x);\n\t0X for hex (%#X); suppress 0x for %p (%#p);\n\tfor %q, print a raw (backquoted) string if strconv.CanBackquote\n\treturns true;\n\twrite e.g. U+0078 'x' if the character is printable for %U (%#U).\n' '\t(space) leave a space for elided sign in numbers (% d);\n\tput spaces between bytes printing strings or slices in hex (% x, % X)\n0\tpad with leading zeros rather than spaces;\n\tfor numbers, this moves the padding after the sign\n</pre> <p> Flags are ignored by verbs that do not expect them. For example there is no alternate decimal format, so %#d and %d behave identically. </p> <p> For each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand. Another variant Println inserts blanks between operands and appends a newline. </p> <p> Regardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus: </p> <pre data-language=\"go\">var i interface{} = 23\nfmt.Printf(\"%v\\n\", i)\n</pre> <p> will print 23. </p> <p> Except when printed using the verbs %T and %p, special formatting considerations apply for operands that implement certain interfaces. In order of application: </p> <p> 1. If the operand is a reflect.Value, the operand is replaced by the concrete value that it holds, and printing continues with the next rule. </p> <p> 2. If an operand implements the Formatter interface, it will be invoked. Formatter provides fine control of formatting. </p> <p> 3. If the %v verb is used with the # flag (%#v) and the operand implements the GoStringer interface, that will be invoked. </p> <p> If the format (which is implicitly %v for Println etc.) is valid for a string (%s %q %v %x %X), the following two rules apply: </p> <p> 4. If an operand implements the error interface, the Error method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any). </p> <p> 5. If an operand implements method String() string, that method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any). </p> <p> For compound operands such as slices and structs, the format applies to the elements of each operand, recursively, not to the operand as a whole. Thus %q will quote each element of a slice of strings, and %6.2f will control formatting for each element of a floating-point array. </p> <p> However, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item. </p> <p> To avoid recursion in cases such as </p> <pre data-language=\"go\">type X string\nfunc (x X) String() string { return Sprintf(\"&lt;%s&gt;\", x) }\n</pre> <p> convert the value before recurring: </p> <pre data-language=\"go\">func (x X) String() string { return Sprintf(\"&lt;%s&gt;\", string(x)) }\n</pre> <p> Infinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them. </p> <p> Explicit argument indexes: </p> <p> In Printf, Sprintf, and Fprintf, the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation [n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '*' for a width or precision selects the argument index holding the value. After processing a bracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed. </p> <p> For example, </p> <pre data-language=\"go\">fmt.Sprintf(\"%[2]d %[1]d\\n\", 11, 22)\n</pre> <p> will yield \"22 11\", while </p> <pre data-language=\"go\">fmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6),\n</pre> <p> equivalent to </p> <pre data-language=\"go\">fmt.Sprintf(\"%6.2f\", 12.0),\n</pre> <p> will yield \" 12.00\". Because an explicit index affects subsequent verbs, this notation can be used to print the same values multiple times by resetting the index for the first argument to be repeated: </p> <pre data-language=\"go\">fmt.Sprintf(\"%d %d %#[1]x %#x\", 16, 17)\n</pre> <p> will yield \"16 17 0x10 0x11\". </p> <p> Format errors: </p> <p> If an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples: </p> <pre data-language=\"go\">Wrong type or unknown verb: %!verb(type=value)\n\tPrintf(\"%d\", hi):          %!d(string=hi)\nToo many arguments: %!(EXTRA type=value)\n\tPrintf(\"hi\", \"guys\"):      hi%!(EXTRA string=guys)\nToo few arguments: %!verb(MISSING)\n\tPrintf(\"hi%d\"):            hi%!d(MISSING)\nNon-int for width or precision: %!(BADWIDTH) or %!(BADPREC)\n\tPrintf(\"%*s\", 4.5, \"hi\"):  %!(BADWIDTH)hi\n\tPrintf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi\nInvalid or invalid use of argument index: %!(BADINDEX)\n\tPrintf(\"%*[2]d\", 7):       %!d(BADINDEX)\n\tPrintf(\"%.[2]d\", 7):       %!d(BADINDEX)\n</pre> <p> All errors begin with the string \"%!\" followed sometimes by a single character (the verb) and end with a parenthesized description. </p> <p> If an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package. For example, if a String method calls panic(\"bad\"), the resulting formatted message will look like </p> <pre data-language=\"go\">%!s(PANIC=bad)\n</pre> <p> The %!s just shows the print verb in use when the failure occurred. If the panic is caused by a nil receiver to an Error or String method, however, the output is the undecorated string, \"&lt;nil&gt;\". </p> <h3 id=\"hdr-Scanning\">Scanning</h3> <p> An analogous set of functions scans formatted text to yield values. Scan, Scanf and Scanln read from os.Stdin; Fscan, Fscanf and Fscanln read from a specified io.Reader; Sscan, Sscanf and Sscanln read from an argument string. </p> <p> Scan, Fscan, Sscan treat newlines in the input as spaces. </p> <p> Scanln, Fscanln and Sscanln stop scanning at a newline and require that the items be followed by a newline or EOF. </p> <p> Scanf, Fscanf and Sscanf require that (after skipping spaces) newlines in the format are matched by newlines in the input and vice versa. This behavior differs from the corresponding routines in C, which uniformly treat newlines as spaces. </p> <p> When scanning with Scanf, Fscanf, and Sscanf, all non-empty runs of space characters (except newline) are equivalent to a single space in both the format and the input. With that proviso, text in the format string must match the input text; scanning stops if it does not, with the return value of the function indicating the number of arguments scanned. </p> <p> Scanf, Fscanf, and Sscanf parse the arguments according to a format string, analogous to that of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. </p> <p> The formats behave analogously to those of Printf with the following exceptions: </p> <pre data-language=\"go\">%p is not implemented\n%T is not implemented\n%e %E %f %F %g %G are all equivalent and scan any floating point or complex value\n%s and %v on strings scan a space-delimited token\nFlags # and + are not implemented.\n</pre> <p> The familiar base-setting prefixes 0 (octal) and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb. </p> <p> Width is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example, </p> <pre data-language=\"go\">Sscanf(\" 1234567 \", \"%5s%d\", &amp;s, &amp;i)\n</pre> <p> will set s to \"12345\" and i to 67 while </p> <pre data-language=\"go\">Sscanf(\" 12 34 567 \", \"%5s%d\", &amp;s, &amp;i)\n</pre> <p> will set s to \"12\" and i to 34. </p> <p> In all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\\r\\n means the same as \\n). </p> <p> In all the scanning functions, if an operand implements method Scan (that is, it implements the Scanner interface) that method will be used to scan the text for that operand. Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned. </p> <p> All arguments to be scanned must be either pointers to basic types or implementations of the Scanner interface. </p> <p> Note: Fscan etc. can read one character (rune) past the input they return, which means that a loop calling a scan routine may skip some of the input. This is usually a problem only when there is no space between input values. If the reader provided to Fscan implements ReadRune, that method will be used to read characters. If the reader also implements UnreadRune, that method will be used to save the character and successive calls will not lose data. To attach ReadRune and UnreadRune methods to a reader without that capability, use bufio.NewReader. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Errorf\">func Errorf(format string, a ...interface{}) error</a></li>\n<li><a href=\"#Fprint\">func Fprint(w io.Writer, a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Fprintf\">func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Fprintln\">func Fprintln(w io.Writer, a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Fscan\">func Fscan(r io.Reader, a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Fscanf\">func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Fscanln\">func Fscanln(r io.Reader, a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Print\">func Print(a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Printf\">func Printf(format string, a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Println\">func Println(a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Scan\">func Scan(a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Scanf\">func Scanf(format string, a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Scanln\">func Scanln(a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Sprint\">func Sprint(a ...interface{}) string</a></li>\n<li><a href=\"#Sprintf\">func Sprintf(format string, a ...interface{}) string</a></li>\n<li><a href=\"#Sprintln\">func Sprintln(a ...interface{}) string</a></li>\n<li><a href=\"#Sscan\">func Sscan(str string, a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Sscanf\">func Sscanf(str string, format string, a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Sscanln\">func Sscanln(str string, a ...interface{}) (n int, err error)</a></li>\n<li><a href=\"#Formatter\">type Formatter</a></li>\n<li><a href=\"#GoStringer\">type GoStringer</a></li>\n<li><a href=\"#ScanState\">type ScanState</a></li>\n<li><a href=\"#Scanner\">type Scanner</a></li>\n<li><a href=\"#State\">type State</a></li>\n<li><a href=\"#Stringer\">type Stringer</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/fmt/doc.go\">doc.go</a> <a href=\"https://golang.org/src/fmt/format.go\">format.go</a> <a href=\"https://golang.org/src/fmt/print.go\">print.go</a> <a href=\"https://golang.org/src/fmt/scan.go\">scan.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Errorf\">func Errorf  </h2> <pre data-language=\"go\">func Errorf(format string, a ...interface{}) error</pre> <p> Errorf formats according to a format specifier and returns the string as a value that satisfies error. </p> <h2 id=\"Fprint\">func Fprint  </h2> <pre data-language=\"go\">func Fprint(w io.Writer, a ...interface{}) (n int, err error)</pre> <p> Fprint formats using the default formats for its operands and writes to w. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered. </p> <h2 id=\"Fprintf\">func Fprintf  </h2> <pre data-language=\"go\">func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)</pre> <p> Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered. </p> <h2 id=\"Fprintln\">func Fprintln  </h2> <pre data-language=\"go\">func Fprintln(w io.Writer, a ...interface{}) (n int, err error)</pre> <p> Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered. </p> <h2 id=\"Fscan\">func Fscan  </h2> <pre data-language=\"go\">func Fscan(r io.Reader, a ...interface{}) (n int, err error)</pre> <p> Fscan scans text read from r, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. </p> <h2 id=\"Fscanf\">func Fscanf  </h2> <pre data-language=\"go\">func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)</pre> <p> Fscanf scans text read from r, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format. </p> <h2 id=\"Fscanln\">func Fscanln  </h2> <pre data-language=\"go\">func Fscanln(r io.Reader, a ...interface{}) (n int, err error)</pre> <p> Fscanln is similar to Fscan, but stops scanning at a newline and after the final item there must be a newline or EOF. </p> <h2 id=\"Print\">func Print  </h2> <pre data-language=\"go\">func Print(a ...interface{}) (n int, err error)</pre> <p> Print formats using the default formats for its operands and writes to standard output. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered. </p> <h2 id=\"Printf\">func Printf  </h2> <pre data-language=\"go\">func Printf(format string, a ...interface{}) (n int, err error)</pre> <p> Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered. </p> <h2 id=\"Println\">func Println  </h2> <pre data-language=\"go\">func Println(a ...interface{}) (n int, err error)</pre> <p> Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered. </p> <h2 id=\"Scan\">func Scan  </h2> <pre data-language=\"go\">func Scan(a ...interface{}) (n int, err error)</pre> <p> Scan scans text read from standard input, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. </p> <h2 id=\"Scanf\">func Scanf  </h2> <pre data-language=\"go\">func Scanf(format string, a ...interface{}) (n int, err error)</pre> <p> Scanf scans text read from standard input, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. Newlines in the input must match newlines in the format. The one exception: the verb %c always scans the next rune in the input, even if it is a space (or tab etc.) or newline. </p> <h2 id=\"Scanln\">func Scanln  </h2> <pre data-language=\"go\">func Scanln(a ...interface{}) (n int, err error)</pre> <p> Scanln is similar to Scan, but stops scanning at a newline and after the final item there must be a newline or EOF. </p> <h2 id=\"Sprint\">func Sprint  </h2> <pre data-language=\"go\">func Sprint(a ...interface{}) string</pre> <p> Sprint formats using the default formats for its operands and returns the resulting string. Spaces are added between operands when neither is a string. </p> <h2 id=\"Sprintf\">func Sprintf  </h2> <pre data-language=\"go\">func Sprintf(format string, a ...interface{}) string</pre> <p> Sprintf formats according to a format specifier and returns the resulting string. </p> <h2 id=\"Sprintln\">func Sprintln  </h2> <pre data-language=\"go\">func Sprintln(a ...interface{}) string</pre> <p> Sprintln formats using the default formats for its operands and returns the resulting string. Spaces are always added between operands and a newline is appended. </p> <h2 id=\"Sscan\">func Sscan  </h2> <pre data-language=\"go\">func Sscan(str string, a ...interface{}) (n int, err error)</pre> <p> Sscan scans the argument string, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. </p> <h2 id=\"Sscanf\">func Sscanf  </h2> <pre data-language=\"go\">func Sscanf(str string, format string, a ...interface{}) (n int, err error)</pre> <p> Sscanf scans the argument string, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format. </p> <h2 id=\"Sscanln\">func Sscanln  </h2> <pre data-language=\"go\">func Sscanln(str string, a ...interface{}) (n int, err error)</pre> <p> Sscanln is similar to Sscan, but stops scanning at a newline and after the final item there must be a newline or EOF. </p> <h2 id=\"Formatter\">type Formatter  </h2> <pre data-language=\"go\">type Formatter interface {\n        Format(f State, c rune)\n}</pre> <p> Formatter is the interface implemented by values with a custom formatter. The implementation of Format may call Sprint(f) or Fprint(f) etc. to generate its output. </p> <h2 id=\"GoStringer\">type GoStringer  </h2> <pre data-language=\"go\">type GoStringer interface {\n        GoString() string\n}</pre> <p> GoStringer is implemented by any value that has a GoString method, which defines the Go syntax for that value. The GoString method is used to print values passed as an operand to a %#v format. </p> <h2 id=\"ScanState\">type ScanState  </h2> <pre data-language=\"go\">type ScanState interface {\n        // ReadRune reads the next rune (Unicode code point) from the input.\n        // If invoked during Scanln, Fscanln, or Sscanln, ReadRune() will\n        // return EOF after returning the first '\\n' or when reading beyond\n        // the specified width.\n        ReadRune() (r rune, size int, err error)\n        // UnreadRune causes the next call to ReadRune to return the same rune.\n        UnreadRune() error\n        // SkipSpace skips space in the input. Newlines are treated appropriately\n        // for the operation being performed; see the package documentation\n        // for more information.\n        SkipSpace()\n        // Token skips space in the input if skipSpace is true, then returns the\n        // run of Unicode code points c satisfying f(c).  If f is nil,\n        // !unicode.IsSpace(c) is used; that is, the token will hold non-space\n        // characters. Newlines are treated appropriately for the operation being\n        // performed; see the package documentation for more information.\n        // The returned slice points to shared data that may be overwritten\n        // by the next call to Token, a call to a Scan function using the ScanState\n        // as input, or when the calling Scan method returns.\n        Token(skipSpace bool, f func(rune) bool) (token []byte, err error)\n        // Width returns the value of the width option and whether it has been set.\n        // The unit is Unicode code points.\n        Width() (wid int, ok bool)\n        // Because ReadRune is implemented by the interface, Read should never be\n        // called by the scanning routines and a valid implementation of\n        // ScanState may choose always to return an error from Read.\n        Read(buf []byte) (n int, err error)\n}</pre> <p> ScanState represents the scanner state passed to custom scanners. Scanners may do rune-at-a-time scanning or ask the ScanState to discover the next space-delimited token. </p> <h2 id=\"Scanner\">type Scanner  </h2> <pre data-language=\"go\">type Scanner interface {\n        Scan(state ScanState, verb rune) error\n}</pre> <p> Scanner is implemented by any value that has a Scan method, which scans the input for the representation of a value and stores the result in the receiver, which must be a pointer to be useful. The Scan method is called for any argument to Scan, Scanf, or Scanln that implements it. </p> <h2 id=\"State\">type State  </h2> <pre data-language=\"go\">type State interface {\n        // Write is the function to call to emit formatted output to be printed.\n        Write(b []byte) (n int, err error)\n        // Width returns the value of the width option and whether it has been set.\n        Width() (wid int, ok bool)\n        // Precision returns the value of the precision option and whether it has been set.\n        Precision() (prec int, ok bool)\n\n        // Flag reports whether the flag c, a character, has been set.\n        Flag(c int) bool\n}</pre> <p> State represents the printer state passed to custom formatters. It provides access to the io.Writer interface plus information about the flags and options for the operand's format specifier. </p> <h2 id=\"Stringer\">type Stringer  </h2> <pre data-language=\"go\">type Stringer interface {\n        String() string\n}</pre> <p> Stringer is implemented by any value that has a String method, which defines the “native” format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/fmt/\" class=\"_attribution-link\">https://golang.org/pkg/fmt/</a>\n  </p>\n</div>\n","hash/crc32/index":"<h1>Package crc32</h1>     <ul id=\"short-nav\">\n<li><code>import \"hash/crc32\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum. See <a href=\"http://en.wikipedia.org/wiki/Cyclic_redundancy_check\">http://en.wikipedia.org/wiki/Cyclic_redundancy_check</a> for information. </p> <p> Polynomials are represented in LSB-first form also known as reversed representation. </p> <p> See <a href=\"http://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials\">http://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials</a> for information. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Checksum\">func Checksum(data []byte, tab *Table) uint32</a></li>\n<li><a href=\"#ChecksumIEEE\">func ChecksumIEEE(data []byte) uint32</a></li>\n<li><a href=\"#New\">func New(tab *Table) hash.Hash32</a></li>\n<li><a href=\"#NewIEEE\">func NewIEEE() hash.Hash32</a></li>\n<li><a href=\"#Update\">func Update(crc uint32, tab *Table, p []byte) uint32</a></li>\n<li><a href=\"#Table\">type Table</a></li>\n<li> <a href=\"#MakeTable\">func MakeTable(poly uint32) *Table</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_MakeTable\">MakeTable</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/hash/crc32/crc32.go\">crc32.go</a> <a href=\"https://golang.org/src/hash/crc32/crc32_amd64.go\">crc32_amd64.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        // IEEE is by far and away the most common CRC-32 polynomial.\n        // Used by ethernet (IEEE 802.3), v.42, fddi, gzip, zip, png, ...\n        IEEE = 0xedb88320\n\n        // Castagnoli's polynomial, used in iSCSI.\n        // Has better error detection characteristics than IEEE.\n        // http://dx.doi.org/10.1109/26.231911\n        Castagnoli = 0x82f63b78\n\n        // Koopman's polynomial.\n        // Also has better error detection characteristics than IEEE.\n        // http://dx.doi.org/10.1109/DSN.2002.1028931\n        Koopman = 0xeb31d82e\n)</pre> <p> Predefined polynomials. </p> <pre data-language=\"go\">const Size = 4</pre> <p> The size of a CRC-32 checksum in bytes. </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var IEEETable = makeTable(IEEE)</pre> <p> IEEETable is the table for the IEEE polynomial. </p> <h2 id=\"Checksum\">func Checksum  </h2> <pre data-language=\"go\">func Checksum(data []byte, tab *Table) uint32</pre> <p> Checksum returns the CRC-32 checksum of data using the polynomial represented by the Table. </p> <h2 id=\"ChecksumIEEE\">func ChecksumIEEE  </h2> <pre data-language=\"go\">func ChecksumIEEE(data []byte) uint32</pre> <p> ChecksumIEEE returns the CRC-32 checksum of data using the IEEE polynomial. </p> <h2 id=\"New\">func New  </h2> <pre data-language=\"go\">func New(tab *Table) hash.Hash32</pre> <p> New creates a new hash.Hash32 computing the CRC-32 checksum using the polynomial represented by the Table. Its Sum method will lay the value out in big-endian byte order. </p> <h2 id=\"NewIEEE\">func NewIEEE  </h2> <pre data-language=\"go\">func NewIEEE() hash.Hash32</pre> <p> NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using the IEEE polynomial. Its Sum method will lay the value out in big-endian byte order. </p> <h2 id=\"Update\">func Update  </h2> <pre data-language=\"go\">func Update(crc uint32, tab *Table, p []byte) uint32</pre> <p> Update returns the result of adding the bytes in p to the crc. </p> <h2 id=\"Table\">type Table  </h2> <pre data-language=\"go\">type Table [256]uint32</pre> <p> Table is a 256-word table representing the polynomial for efficient processing. </p> <h3 id=\"MakeTable\">func <a href=\"https://golang.org/src/hash/crc32/crc32.go?s=2201:2235#L61\">MakeTable</a>  </h3> <pre data-language=\"go\">func MakeTable(poly uint32) *Table</pre> <p> MakeTable returns a Table constructed from the specified polynomial. The contents of this Table must not be modified. </p> <div id=\"example_MakeTable\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"hash/crc32\"\n)\n\nfunc main() {\n\t// In this package, the CRC polynomial is represented in reversed notation,\n\t// or LSB-first representation.\n\t//\n\t// LSB-first representation is a hexadecimal number with n bits, in which the\n\t// most significant bit represents the coefficient of x⁰ and the least significant\n\t// bit represents the coefficient of xⁿ⁻¹ (the coefficient for xⁿ is implicit).\n\t//\n\t// For example, CRC32-Q, as defined by the following polynomial,\n\t//\tx³²+ x³¹+ x²⁴+ x²²+ x¹⁶+ x¹⁴+ x⁸+ x⁷+ x⁵+ x³+ x¹+ x⁰\n\t// has the reversed notation 0b11010101100000101000001010000001, so the value\n\t// that should be passed to MakeTable is 0xD5828281.\n\tcrc32q := crc32.MakeTable(0xD5828281)\n\tfmt.Printf(\"%08x\\n\", crc32.Checksum([]byte(\"Hello world\"), crc32q))\n}\n</pre> </div> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/hash/crc32/\" class=\"_attribution-link\">https://golang.org/pkg/hash/crc32/</a>\n  </p>\n</div>\n","index/index":"<h1>Directory /src/index</h1>    <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"suffixarray/index\">suffixarray</a> </td> <td class=\"pkg-synopsis\"> Package suffixarray implements substring search in logarithmic time using an in-memory suffix array. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/index/\" class=\"_attribution-link\">https://golang.org/pkg/index/</a>\n  </p>\n</div>\n","encoding/gob/index":"<h1>Package gob</h1>     <ul id=\"short-nav\">\n<li><code>import \"encoding/gob\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package gob manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver). A typical use is transporting arguments and results of remote procedure calls (RPCs) such as those provided by package \"net/rpc\". </p> <p> The implementation compiles a custom codec for each data type in the stream and is most efficient when a single Encoder is used to transmit a stream of values, amortizing the cost of compilation. </p> <h3 id=\"hdr-Basics\">Basics</h3> <p> A stream of gobs is self-describing. Each data item in the stream is preceded by a specification of its type, expressed in terms of a small set of predefined types. Pointers are not transmitted, but the things they point to are transmitted; that is, the values are flattened. Nil pointers are not permitted, as they have no value. Recursive types work fine, but recursive values (data with cycles) are problematic. This may change. </p> <p> To use gobs, create an Encoder and present it with a series of data items as values or addresses that can be dereferenced to values. The Encoder makes sure all type information is sent before it is needed. At the receive side, a Decoder retrieves values from the encoded stream and unpacks them into local variables. </p> <h3 id=\"hdr-Types_and_Values\">Types and Values</h3> <p> The source and destination values/types need not correspond exactly. For structs, fields (identified by name) that are in the source but absent from the receiving variable will be ignored. Fields that are in the receiving variable but missing from the transmitted type or value will be ignored in the destination. If a field with the same name is present in both, their types must be compatible. Both the receiver and transmitter will do all necessary indirection and dereferencing to convert between gobs and actual Go values. For instance, a gob type that is schematically, </p> <pre data-language=\"go\">struct { A, B int }\n</pre> <p> can be sent from or received into any of these Go types: </p> <pre data-language=\"go\">struct { A, B int }\t// the same\n*struct { A, B int }\t// extra indirection of the struct\nstruct { *A, **B int }\t// extra indirection of the fields\nstruct { A, B int64 }\t// different concrete value type; see below\n</pre> <p> It may also be received into any of these: </p> <pre data-language=\"go\">struct { A, B int }\t// the same\nstruct { B, A int }\t// ordering doesn't matter; matching is by name\nstruct { A, B, C int }\t// extra field (C) ignored\nstruct { B int }\t// missing field (A) ignored; data will be dropped\nstruct { B, C int }\t// missing field (A) ignored; extra field (C) ignored.\n</pre> <p> Attempting to receive into these types will draw a decode error: </p> <pre data-language=\"go\">struct { A int; B uint }\t// change of signedness for B\nstruct { A int; B float }\t// change of type for B\nstruct { }\t\t\t// no field names in common\nstruct { C, D int }\t\t// no field names in common\n</pre> <p> Integers are transmitted two ways: arbitrary precision signed integers or arbitrary precision unsigned integers. There is no int8, int16 etc. discrimination in the gob format; there are only signed and unsigned integers. As described below, the transmitter sends the value in a variable-length encoding; the receiver accepts the value and stores it in the destination variable. Floating-point numbers are always sent using IEEE-754 64-bit precision (see below). </p> <p> Signed integers may be received into any signed integer variable: int, int16, etc.; unsigned integers may be received into any unsigned integer variable; and floating point values may be received into any floating point variable. However, the destination variable must be able to represent the value or the decode operation will fail. </p> <p> Structs, arrays and slices are also supported. Structs encode and decode only exported fields. Strings and arrays of bytes are supported with a special, efficient representation (see below). When a slice is decoded, if the existing slice has capacity the slice will be extended in place; if not, a new array is allocated. Regardless, the length of the resulting slice reports the number of elements decoded. </p> <p> In general, if allocation is required, the decoder will allocate memory. If not, it will update the destination variables with values read from the stream. It does not initialize them first, so if the destination is a compound value such as a map, struct, or slice, the decoded values will be merged elementwise into the existing variables. </p> <p> Functions and channels will not be sent in a gob. Attempting to encode such a value at the top level will fail. A struct field of chan or func type is treated exactly like an unexported field and is ignored. </p> <p> Gob can encode a value of any type implementing the GobEncoder or encoding.BinaryMarshaler interfaces by calling the corresponding method, in that order of preference. </p> <p> Gob can decode a value of any type implementing the GobDecoder or encoding.BinaryUnmarshaler interfaces by calling the corresponding method, again in that order of preference. </p> <h3 id=\"hdr-Encoding_Details\">Encoding Details</h3> <p> This section documents the encoding, details that are not important for most users. Details are presented bottom-up. </p> <p> An unsigned integer is sent one of two ways. If it is less than 128, it is sent as a byte with that value. Otherwise it is sent as a minimal-length big-endian (high byte first) byte stream holding the value, preceded by one byte holding the byte count, negated. Thus 0 is transmitted as (00), 7 is transmitted as (07) and 256 is transmitted as (FE 01 00). </p> <p> A boolean is encoded within an unsigned integer: 0 for false, 1 for true. </p> <p> A signed integer, i, is encoded within an unsigned integer, u. Within u, bits 1 upward contain the value; bit 0 says whether they should be complemented upon receipt. The encode algorithm looks like this: </p> <pre data-language=\"go\">var u uint\nif i &lt; 0 {\n\tu = (^uint(i) &lt;&lt; 1) | 1 // complement i, bit 0 is 1\n} else {\n\tu = (uint(i) &lt;&lt; 1) // do not complement i, bit 0 is 0\n}\nencodeUnsigned(u)\n</pre> <p> The low bit is therefore analogous to a sign bit, but making it the complement bit instead guarantees that the largest negative integer is not a special case. For example, -129=^128=(^256&gt;&gt;1) encodes as (FE 01 01). </p> <p> Floating-point numbers are always sent as a representation of a float64 value. That value is converted to a uint64 using math.Float64bits. The uint64 is then byte-reversed and sent as a regular unsigned integer. The byte-reversal means the exponent and high-precision part of the mantissa go first. Since the low bits are often zero, this can save encoding bytes. For instance, 17.0 is encoded in only three bytes (FE 31 40). </p> <p> Strings and slices of bytes are sent as an unsigned count followed by that many uninterpreted bytes of the value. </p> <p> All other slices and arrays are sent as an unsigned count followed by that many elements using the standard gob encoding for their type, recursively. </p> <p> Maps are sent as an unsigned count followed by that many key, element pairs. Empty but non-nil maps are sent, so if the receiver has not allocated one already, one will always be allocated on receipt unless the transmitted map is nil and not at the top level. </p> <p> In slices and arrays, as well as maps, all elements, even zero-valued elements, are transmitted, even if all the elements are zero. </p> <p> Structs are sent as a sequence of (field number, field value) pairs. The field value is sent using the standard gob encoding for its type, recursively. If a field has the zero value for its type (except for arrays; see above), it is omitted from the transmission. The field number is defined by the type of the encoded struct: the first field of the encoded type is field 0, the second is field 1, etc. When encoding a value, the field numbers are delta encoded for efficiency and the fields are always sent in order of increasing field number; the deltas are therefore unsigned. The initialization for the delta encoding sets the field number to -1, so an unsigned integer field 0 with value 7 is transmitted as unsigned delta = 1, unsigned value = 7 or (01 07). Finally, after all the fields have been sent a terminating mark denotes the end of the struct. That mark is a delta=0 value, which has representation (00). </p> <p> Interface types are not checked for compatibility; all interface types are treated, for transmission, as members of a single \"interface\" type, analogous to int or []byte - in effect they're all treated as interface{}. Interface values are transmitted as a string identifying the concrete type being sent (a name that must be pre-defined by calling Register), followed by a byte count of the length of the following data (so the value can be skipped if it cannot be stored), followed by the usual encoding of concrete (dynamic) value stored in the interface value. (A nil interface value is identified by the empty string and transmits no value.) Upon receipt, the decoder verifies that the unpacked concrete item satisfies the interface of the receiving variable. </p> <p> The representation of types is described below. When a type is defined on a given connection between an Encoder and Decoder, it is assigned a signed integer type id. When Encoder.Encode(v) is called, it makes sure there is an id assigned for the type of v and all its elements and then it sends the pair (typeid, encoded-v) where typeid is the type id of the encoded type of v and encoded-v is the gob encoding of the value v. </p> <p> To define a type, the encoder chooses an unused, positive type id and sends the pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType description, constructed from these types: </p> <pre data-language=\"go\">type wireType struct {\n\tArrayT  *ArrayType\n\tSliceT  *SliceType\n\tStructT *StructType\n\tMapT    *MapType\n}\ntype arrayType struct {\n\tCommonType\n\tElem typeId\n\tLen  int\n}\ntype CommonType struct {\n\tName string // the name of the struct type\n\tId  int    // the id of the type, repeated so it's inside the type\n}\ntype sliceType struct {\n\tCommonType\n\tElem typeId\n}\ntype structType struct {\n\tCommonType\n\tField []*fieldType // the fields of the struct.\n}\ntype fieldType struct {\n\tName string // the name of the field.\n\tId   int    // the type id of the field, which must be already defined\n}\ntype mapType struct {\n\tCommonType\n\tKey  typeId\n\tElem typeId\n}\n</pre> <p> If there are nested type ids, the types for all inner type ids must be defined before the top-level type id is used to describe an encoded-v. </p> <p> For simplicity in setup, the connection is defined to understand these types a priori, as well as the basic gob types int, uint, etc. Their ids are: </p> <pre data-language=\"go\">bool        1\nint         2\nuint        3\nfloat       4\n[]byte      5\nstring      6\ncomplex     7\ninterface   8\n// gap for reserved ids.\nWireType    16\nArrayType   17\nCommonType  18\nSliceType   19\nStructType  20\nFieldType   21\n// 22 is slice of fieldType.\nMapType     23\n</pre> <p> Finally, each message created by a call to Encode is preceded by an encoded unsigned integer count of the number of bytes remaining in the message. After the initial type name, interface values are wrapped the same way; in effect, the interface value acts like a recursive invocation of Encode. </p> <p> In summary, a gob stream looks like </p> <pre data-language=\"go\">(byteCount (-type id, encoding of a wireType)* (type id, encoding of a value))*\n</pre> <p> where * signifies zero or more repetitions and the type id of a value must be predefined or be defined before the value in the stream. </p> <p> Compatibility: Any future changes to the package will endeavor to maintain compatibility with streams encoded using previous versions. That is, any released version of this package should be able to decode data written with any previously released version, subject to issues such as security fixes. See the Go compatibility document for background: <a href=\"https://golang.org/doc/go1compat\">https://golang.org/doc/go1compat</a> </p> <p> See \"Gobs of data\" for a design discussion of the gob wire format: <a href=\"https://blog.golang.org/gobs-of-data\">https://blog.golang.org/gobs-of-data</a> </p> </div> </div> <div id=\"example__basic\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Basic)</h2> <p>This example shows the basic usage of the package: Create an encoder, transmit some values, receive them with a decoder. </p> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"log\"\n)\n\ntype P struct {\n\tX, Y, Z int\n\tName    string\n}\n\ntype Q struct {\n\tX, Y *int32\n\tName string\n}\n\n// This example shows the basic usage of the package: Create an encoder,\n// transmit some values, receive them with a decoder.\nfunc main() {\n\t// Initialize the encoder and decoder. Normally enc and dec would be\n\t// bound to network connections and the encoder and decoder would\n\t// run in different processes.\n\tvar network bytes.Buffer        // Stand-in for a network connection\n\tenc := gob.NewEncoder(&amp;network) // Will write to network.\n\tdec := gob.NewDecoder(&amp;network) // Will read from network.\n\n\t// Encode (send) some values.\n\terr := enc.Encode(P{3, 4, 5, \"Pythagoras\"})\n\tif err != nil {\n\t\tlog.Fatal(\"encode error:\", err)\n\t}\n\terr = enc.Encode(P{1782, 1841, 1922, \"Treehouse\"})\n\tif err != nil {\n\t\tlog.Fatal(\"encode error:\", err)\n\t}\n\n\t// Decode (receive) and print the values.\n\tvar q Q\n\terr = dec.Decode(&amp;q)\n\tif err != nil {\n\t\tlog.Fatal(\"decode error 1:\", err)\n\t}\n\tfmt.Printf(\"%q: {%d, %d}\\n\", q.Name, *q.X, *q.Y)\n\terr = dec.Decode(&amp;q)\n\tif err != nil {\n\t\tlog.Fatal(\"decode error 2:\", err)\n\t}\n\tfmt.Printf(\"%q: {%d, %d}\\n\", q.Name, *q.X, *q.Y)\n\n}\n</pre> </div> </div> <div id=\"example__encodeDecode\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (EncodeDecode)</h2> <p>This example transmits a value that implements the custom encoding and decoding methods. </p> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"log\"\n)\n\n// The Vector type has unexported fields, which the package cannot access.\n// We therefore write a BinaryMarshal/BinaryUnmarshal method pair to allow us\n// to send and receive the type with the gob package. These interfaces are\n// defined in the \"encoding\" package.\n// We could equivalently use the locally defined GobEncode/GobDecoder\n// interfaces.\ntype Vector struct {\n\tx, y, z int\n}\n\nfunc (v Vector) MarshalBinary() ([]byte, error) {\n\t// A simple encoding: plain text.\n\tvar b bytes.Buffer\n\tfmt.Fprintln(&amp;b, v.x, v.y, v.z)\n\treturn b.Bytes(), nil\n}\n\n// UnmarshalBinary modifies the receiver so it must take a pointer receiver.\nfunc (v *Vector) UnmarshalBinary(data []byte) error {\n\t// A simple encoding: plain text.\n\tb := bytes.NewBuffer(data)\n\t_, err := fmt.Fscanln(b, &amp;v.x, &amp;v.y, &amp;v.z)\n\treturn err\n}\n\n// This example transmits a value that implements the custom encoding and decoding methods.\nfunc main() {\n\tvar network bytes.Buffer // Stand-in for the network.\n\n\t// Create an encoder and send a value.\n\tenc := gob.NewEncoder(&amp;network)\n\terr := enc.Encode(Vector{3, 4, 5})\n\tif err != nil {\n\t\tlog.Fatal(\"encode:\", err)\n\t}\n\n\t// Create a decoder and receive a value.\n\tdec := gob.NewDecoder(&amp;network)\n\tvar v Vector\n\terr = dec.Decode(&amp;v)\n\tif err != nil {\n\t\tlog.Fatal(\"decode:\", err)\n\t}\n\tfmt.Println(v)\n\n}\n</pre> </div> </div> <div id=\"example__interface\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Interface)</h2> <p>This example shows how to encode an interface value. The key distinction from regular types is to register the concrete type that implements the interface. </p> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n)\n\ntype Point struct {\n\tX, Y int\n}\n\nfunc (p Point) Hypotenuse() float64 {\n\treturn math.Hypot(float64(p.X), float64(p.Y))\n}\n\ntype Pythagoras interface {\n\tHypotenuse() float64\n}\n\n// This example shows how to encode an interface value. The key\n// distinction from regular types is to register the concrete type that\n// implements the interface.\nfunc main() {\n\tvar network bytes.Buffer // Stand-in for the network.\n\n\t// We must register the concrete type for the encoder and decoder (which would\n\t// normally be on a separate machine from the encoder). On each end, this tells the\n\t// engine which concrete type is being sent that implements the interface.\n\tgob.Register(Point{})\n\n\t// Create an encoder and send some values.\n\tenc := gob.NewEncoder(&amp;network)\n\tfor i := 1; i &lt;= 3; i++ {\n\t\tinterfaceEncode(enc, Point{3 * i, 4 * i})\n\t}\n\n\t// Create a decoder and receive some values.\n\tdec := gob.NewDecoder(&amp;network)\n\tfor i := 1; i &lt;= 3; i++ {\n\t\tresult := interfaceDecode(dec)\n\t\tfmt.Println(result.Hypotenuse())\n\t}\n\n}\n\n// interfaceEncode encodes the interface value into the encoder.\nfunc interfaceEncode(enc *gob.Encoder, p Pythagoras) {\n\t// The encode will fail unless the concrete type has been\n\t// registered. We registered it in the calling function.\n\n\t// Pass pointer to interface so Encode sees (and hence sends) a value of\n\t// interface type. If we passed p directly it would see the concrete type instead.\n\t// See the blog post, \"The Laws of Reflection\" for background.\n\terr := enc.Encode(&amp;p)\n\tif err != nil {\n\t\tlog.Fatal(\"encode:\", err)\n\t}\n}\n\n// interfaceDecode decodes the next interface value from the stream and returns it.\nfunc interfaceDecode(dec *gob.Decoder) Pythagoras {\n\t// The decode will fail unless the concrete type on the wire has been\n\t// registered. We registered it in the calling function.\n\tvar p Pythagoras\n\terr := dec.Decode(&amp;p)\n\tif err != nil {\n\t\tlog.Fatal(\"decode:\", err)\n\t}\n\treturn p\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Register\">func Register(value interface{})</a></li>\n<li><a href=\"#RegisterName\">func RegisterName(name string, value interface{})</a></li>\n<li><a href=\"#CommonType\">type CommonType</a></li>\n<li><a href=\"#Decoder\">type Decoder</a></li>\n<li> <a href=\"#NewDecoder\">func NewDecoder(r io.Reader) *Decoder</a>\n</li>\n<li> <a href=\"#Decoder.Decode\">func (dec *Decoder) Decode(e interface{}) error</a>\n</li>\n<li> <a href=\"#Decoder.DecodeValue\">func (dec *Decoder) DecodeValue(v reflect.Value) error</a>\n</li>\n<li><a href=\"#Encoder\">type Encoder</a></li>\n<li> <a href=\"#NewEncoder\">func NewEncoder(w io.Writer) *Encoder</a>\n</li>\n<li> <a href=\"#Encoder.Encode\">func (enc *Encoder) Encode(e interface{}) error</a>\n</li>\n<li> <a href=\"#Encoder.EncodeValue\">func (enc *Encoder) EncodeValue(value reflect.Value) error</a>\n</li>\n<li><a href=\"#GobDecoder\">type GobDecoder</a></li>\n<li><a href=\"#GobEncoder\">type GobEncoder</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example__basic\">Package (Basic)</a></dd> <dd><a class=\"exampleLink\" href=\"#example__encodeDecode\">Package (EncodeDecode)</a></dd> <dd><a class=\"exampleLink\" href=\"#example__interface\">Package (Interface)</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/encoding/gob/dec_helpers.go\">dec_helpers.go</a> <a href=\"https://golang.org/src/encoding/gob/decode.go\">decode.go</a> <a href=\"https://golang.org/src/encoding/gob/decoder.go\">decoder.go</a> <a href=\"https://golang.org/src/encoding/gob/doc.go\">doc.go</a> <a href=\"https://golang.org/src/encoding/gob/enc_helpers.go\">enc_helpers.go</a> <a href=\"https://golang.org/src/encoding/gob/encode.go\">encode.go</a> <a href=\"https://golang.org/src/encoding/gob/encoder.go\">encoder.go</a> <a href=\"https://golang.org/src/encoding/gob/error.go\">error.go</a> <a href=\"https://golang.org/src/encoding/gob/type.go\">type.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Register\">func Register  </h2> <pre data-language=\"go\">func Register(value interface{})</pre> <p> Register records a type, identified by a value for that type, under its internal type name. That name will identify the concrete type of a value sent or received as an interface variable. Only types that will be transferred as implementations of interface values need to be registered. Expecting to be used only during initialization, it panics if the mapping between types and names is not a bijection. </p> <h2 id=\"RegisterName\">func RegisterName  </h2> <pre data-language=\"go\">func RegisterName(name string, value interface{})</pre> <p> RegisterName is like Register but uses the provided name rather than the type's default. </p> <h2 id=\"CommonType\">type CommonType  </h2> <pre data-language=\"go\">type CommonType struct {\n        Name string\n        Id   typeId\n}</pre> <p> CommonType holds elements of all types. It is a historical artifact, kept for binary compatibility and exported only for the benefit of the package's encoding of type descriptors. It is not intended for direct use by clients. </p> <h2 id=\"Decoder\">type Decoder  </h2> <pre data-language=\"go\">type Decoder struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Decoder manages the receipt of type and data information read from the remote side of a connection. </p> <h3 id=\"NewDecoder\">func <a href=\"https://golang.org/src/encoding/gob/decoder.go?s=1473:1510#L27\">NewDecoder</a>  </h3> <pre data-language=\"go\">func NewDecoder(r io.Reader) *Decoder</pre> <p> NewDecoder returns a new decoder that reads from the io.Reader. If r does not also implement io.ByteReader, it will be wrapped in a bufio.Reader. </p> <h3 id=\"Decoder.Decode\">func (*Decoder) <a href=\"https://golang.org/src/encoding/gob/decoder.go?s=5117:5164#L164\">Decode</a>  </h3> <pre data-language=\"go\">func (dec *Decoder) Decode(e interface{}) error</pre> <p> Decode reads the next value from the input stream and stores it in the data represented by the empty interface value. If e is nil, the value will be discarded. Otherwise, the value underlying e must be a pointer to the correct type for the next data item received. If the input is at EOF, Decode returns io.EOF and does not modify e. </p> <h3 id=\"Decoder.DecodeValue\">func (*Decoder) <a href=\"https://golang.org/src/encoding/gob/decoder.go?s=5920:5974#L184\">DecodeValue</a>  </h3> <pre data-language=\"go\">func (dec *Decoder) DecodeValue(v reflect.Value) error</pre> <p> DecodeValue reads the next value from the input stream. If v is the zero reflect.Value (v.Kind() == Invalid), DecodeValue discards the value. Otherwise, it stores the value into v. In that case, v must represent a non-nil pointer to data or be an assignable reflect.Value (v.CanSet()) If the input is at EOF, DecodeValue returns io.EOF and does not modify v. </p> <h2 id=\"Encoder\">type Encoder  </h2> <pre data-language=\"go\">type Encoder struct {\n        // contains filtered or unexported fields\n}</pre> <p> An Encoder manages the transmission of type and data information to the other side of a connection. </p> <h3 id=\"NewEncoder\">func <a href=\"https://golang.org/src/encoding/gob/encoder.go?s=1171:1208#L23\">NewEncoder</a>  </h3> <pre data-language=\"go\">func NewEncoder(w io.Writer) *Encoder</pre> <p> NewEncoder returns a new encoder that will transmit on the io.Writer. </p> <h3 id=\"Encoder.Encode\">func (*Encoder) <a href=\"https://golang.org/src/encoding/gob/encoder.go?s=5430:5477#L164\">Encode</a>  </h3> <pre data-language=\"go\">func (enc *Encoder) Encode(e interface{}) error</pre> <p> Encode transmits the data item represented by the empty interface value, guaranteeing that all necessary type information has been transmitted first. Passing a nil pointer to Encoder will panic, as they cannot be transmitted by gob. </p> <h3 id=\"Encoder.EncodeValue\">func (*Encoder) <a href=\"https://golang.org/src/encoding/gob/encoder.go?s=6895:6953#L207\">EncodeValue</a>  </h3> <pre data-language=\"go\">func (enc *Encoder) EncodeValue(value reflect.Value) error</pre> <p> EncodeValue transmits the data item represented by the reflection value, guaranteeing that all necessary type information has been transmitted first. Passing a nil pointer to EncodeValue will panic, as they cannot be transmitted by gob. </p> <h2 id=\"GobDecoder\">type GobDecoder  </h2> <pre data-language=\"go\">type GobDecoder interface {\n        // GobDecode overwrites the receiver, which must be a pointer,\n        // with the value represented by the byte slice, which was written\n        // by GobEncode, usually for the same concrete type.\n        GobDecode([]byte) error\n}</pre> <p> GobDecoder is the interface describing data that provides its own routine for decoding transmitted values sent by a GobEncoder. </p> <h2 id=\"GobEncoder\">type GobEncoder  </h2> <pre data-language=\"go\">type GobEncoder interface {\n        // GobEncode returns a byte slice representing the encoding of the\n        // receiver for transmission to a GobDecoder, usually of the same\n        // concrete type.\n        GobEncode() ([]byte, error)\n}</pre> <p> GobEncoder is the interface describing data that provides its own representation for encoding values for transmission to a GobDecoder. A type that implements GobEncoder and GobDecoder has complete control over the representation of its data and may therefore contain things such as private fields, channels, and functions, which are not usually transmissible in gob streams. </p> <p> Note: Since gobs can be stored permanently, it is good design to guarantee the encoding used by a GobEncoder is stable as the software evolves. For instance, it might make sense for GobEncode to include a version number in the encoding. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/encoding/gob/\" class=\"_attribution-link\">https://golang.org/pkg/encoding/gob/</a>\n  </p>\n</div>\n","image/draw/index":"<h1>Package draw</h1>     <ul id=\"short-nav\">\n<li><code>import \"image/draw\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package draw provides image composition functions. </p> <p> See \"The Go image/draw package\" for an introduction to this package: <a href=\"https://golang.org/doc/articles/image_draw.html\">https://golang.org/doc/articles/image_draw.html</a> </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Draw\">func Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)</a></li>\n<li><a href=\"#DrawMask\">func DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op)</a></li>\n<li><a href=\"#Drawer\">type Drawer</a></li>\n<li><a href=\"#Image\">type Image</a></li>\n<li><a href=\"#Op\">type Op</a></li>\n<li> <a href=\"#Op.Draw\">func (op Op) Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point)</a>\n</li>\n<li><a href=\"#Quantizer\">type Quantizer</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/image/draw/draw.go\">draw.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Draw\">func Draw  </h2> <pre data-language=\"go\">func Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)</pre> <p> Draw calls DrawMask with a nil mask. </p> <h2 id=\"DrawMask\">func DrawMask  </h2> <pre data-language=\"go\">func DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op)</pre> <p> DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r in dst with the result of a Porter-Duff composition. A nil mask is treated as opaque. </p> <h2 id=\"Drawer\">type Drawer  </h2> <pre data-language=\"go\">type Drawer interface {\n        // Draw aligns r.Min in dst with sp in src and then replaces the\n        // rectangle r in dst with the result of drawing src on dst.\n        Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point)\n}</pre> <p> Drawer contains the Draw method. </p> <pre data-language=\"go\">var FloydSteinberg Drawer = floydSteinberg{}</pre> <p> FloydSteinberg is a Drawer that is the Src Op with Floyd-Steinberg error diffusion. </p> <h2 id=\"Image\">type Image  </h2> <pre data-language=\"go\">type Image interface {\n        image.Image\n        Set(x, y int, c color.Color)\n}</pre> <p> Image is an image.Image with a Set method to change a single pixel. </p> <h2 id=\"Op\">type Op  </h2> <pre data-language=\"go\">type Op int</pre> <p> Op is a Porter-Duff compositing operator. </p> <pre data-language=\"go\">const (\n        // Over specifies ``(src in mask) over dst''.\n        Over Op = iota\n        // Src specifies ``src in mask''.\n        Src\n)</pre> <h3 id=\"Op.Draw\">func (Op) <a href=\"https://golang.org/src/image/draw/draw.go?s=1169:1249#L35\">Draw</a>  </h3> <pre data-language=\"go\">func (op Op) Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point)</pre> <p> Draw implements the Drawer interface by calling the Draw function with this Op. </p> <h2 id=\"Quantizer\">type Quantizer  </h2> <pre data-language=\"go\">type Quantizer interface {\n        // Quantize appends up to cap(p) - len(p) colors to p and returns the\n        // updated palette suitable for converting m to a paletted image.\n        Quantize(p color.Palette, m image.Image) color.Palette\n}</pre> <p> Quantizer produces a palette for an image. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/image/draw/\" class=\"_attribution-link\">https://golang.org/pkg/image/draw/</a>\n  </p>\n</div>\n","image/jpeg/index":"<h1>Package jpeg</h1>     <ul id=\"short-nav\">\n<li><code>import \"image/jpeg\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package jpeg implements a JPEG image decoder and encoder. </p> <p> JPEG is defined in ITU-T T.81: <a href=\"http://www.w3.org/Graphics/JPEG/itu-t81.pdf\">http://www.w3.org/Graphics/JPEG/itu-t81.pdf</a>. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#Decode\">func Decode(r io.Reader) (image.Image, error)</a></li>\n<li><a href=\"#DecodeConfig\">func DecodeConfig(r io.Reader) (image.Config, error)</a></li>\n<li><a href=\"#Encode\">func Encode(w io.Writer, m image.Image, o *Options) error</a></li>\n<li><a href=\"#FormatError\">type FormatError</a></li>\n<li> <a href=\"#FormatError.Error\">func (e FormatError) Error() string</a>\n</li>\n<li><a href=\"#Options\">type Options</a></li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li><a href=\"#UnsupportedError\">type UnsupportedError</a></li>\n<li> <a href=\"#UnsupportedError.Error\">func (e UnsupportedError) Error() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/image/jpeg/fdct.go\">fdct.go</a> <a href=\"https://golang.org/src/image/jpeg/huffman.go\">huffman.go</a> <a href=\"https://golang.org/src/image/jpeg/idct.go\">idct.go</a> <a href=\"https://golang.org/src/image/jpeg/reader.go\">reader.go</a> <a href=\"https://golang.org/src/image/jpeg/scan.go\">scan.go</a> <a href=\"https://golang.org/src/image/jpeg/writer.go\">writer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const DefaultQuality = 75</pre> <p> DefaultQuality is the default quality encoding parameter. </p> <h2 id=\"Decode\">func Decode  </h2> <pre data-language=\"go\">func Decode(r io.Reader) (image.Image, error)</pre> <p> Decode reads a JPEG image from r and returns it as an image.Image. </p> <h2 id=\"DecodeConfig\">func DecodeConfig  </h2> <pre data-language=\"go\">func DecodeConfig(r io.Reader) (image.Config, error)</pre> <p> DecodeConfig returns the color model and dimensions of a JPEG image without decoding the entire image. </p> <h2 id=\"Encode\">func Encode  </h2> <pre data-language=\"go\">func Encode(w io.Writer, m image.Image, o *Options) error</pre> <p> Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given options. Default parameters are used if a nil *Options is passed. </p> <h2 id=\"FormatError\">type FormatError  </h2> <pre data-language=\"go\">type FormatError string</pre> <p> A FormatError reports that the input is not a valid JPEG. </p> <h3 id=\"FormatError.Error\">func (FormatError) <a href=\"https://golang.org/src/image/jpeg/reader.go?s=607:642#L13\">Error</a>  </h3> <pre data-language=\"go\">func (e FormatError) Error() string</pre> <h2 id=\"Options\">type Options  </h2> <pre data-language=\"go\">type Options struct {\n        Quality int\n}</pre> <p> Options are the encoding parameters. Quality ranges from 1 to 100 inclusive, higher is better. </p> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader interface {\n        io.ByteReader\n        io.Reader\n}</pre> <p> Deprecated: Reader is deprecated. </p> <h2 id=\"UnsupportedError\">type UnsupportedError  </h2> <pre data-language=\"go\">type UnsupportedError string</pre> <p> An UnsupportedError reports that the input uses a valid but unimplemented JPEG feature. </p> <h3 id=\"UnsupportedError.Error\">func (UnsupportedError) <a href=\"https://golang.org/src/image/jpeg/reader.go?s=812:852#L18\">Error</a>  </h3> <pre data-language=\"go\">func (e UnsupportedError) Error() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/image/jpeg/\" class=\"_attribution-link\">https://golang.org/pkg/image/jpeg/</a>\n  </p>\n</div>\n","image/gif/index":"<h1>Package gif</h1>     <ul id=\"short-nav\">\n<li><code>import \"image/gif\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package gif implements a GIF image decoder and encoder. </p> <p> The GIF specification is at <a href=\"http://www.w3.org/Graphics/GIF/spec-gif89a.txt\">http://www.w3.org/Graphics/GIF/spec-gif89a.txt</a>. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#Decode\">func Decode(r io.Reader) (image.Image, error)</a></li>\n<li><a href=\"#DecodeConfig\">func DecodeConfig(r io.Reader) (image.Config, error)</a></li>\n<li><a href=\"#Encode\">func Encode(w io.Writer, m image.Image, o *Options) error</a></li>\n<li><a href=\"#EncodeAll\">func EncodeAll(w io.Writer, g *GIF) error</a></li>\n<li><a href=\"#GIF\">type GIF</a></li>\n<li> <a href=\"#DecodeAll\">func DecodeAll(r io.Reader) (*GIF, error)</a>\n</li>\n<li><a href=\"#Options\">type Options</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/image/gif/reader.go\">reader.go</a> <a href=\"https://golang.org/src/image/gif/writer.go\">writer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        DisposalNone       = 0x01\n        DisposalBackground = 0x02\n        DisposalPrevious   = 0x03\n)</pre> <p> Disposal Methods. </p> <h2 id=\"Decode\">func Decode  </h2> <pre data-language=\"go\">func Decode(r io.Reader) (image.Image, error)</pre> <p> Decode reads a GIF image from r and returns the first embedded image as an image.Image. </p> <h2 id=\"DecodeConfig\">func DecodeConfig  </h2> <pre data-language=\"go\">func DecodeConfig(r io.Reader) (image.Config, error)</pre> <p> DecodeConfig returns the global color model and dimensions of a GIF image without decoding the entire image. </p> <h2 id=\"Encode\">func Encode  </h2> <pre data-language=\"go\">func Encode(w io.Writer, m image.Image, o *Options) error</pre> <p> Encode writes the Image m to w in GIF format. </p> <h2 id=\"EncodeAll\">func EncodeAll  </h2> <pre data-language=\"go\">func EncodeAll(w io.Writer, g *GIF) error</pre> <p> EncodeAll writes the images in g to w in GIF format with the given loop count and delay between frames. </p> <h2 id=\"GIF\">type GIF  </h2> <pre data-language=\"go\">type GIF struct {\n        Image     []*image.Paletted // The successive images.\n        Delay     []int             // The successive delay times, one per frame, in 100ths of a second.\n        LoopCount int               // The loop count.\n        // Disposal is the successive disposal methods, one per frame. For\n        // backwards compatibility, a nil Disposal is valid to pass to EncodeAll,\n        // and implies that each frame's disposal method is 0 (no disposal\n        // specified).\n        Disposal []byte\n        // Config is the global color table (palette), width and height. A nil or\n        // empty-color.Palette Config.ColorModel means that each frame has its own\n        // color table and there is no global color table. Each frame's bounds must\n        // be within the rectangle defined by the two points (0, 0) and\n        // (Config.Width, Config.Height).\n        //\n        // For backwards compatibility, a zero-valued Config is valid to pass to\n        // EncodeAll, and implies that the overall GIF's width and height equals\n        // the first frame's bounds' Rectangle.Max point.\n        Config image.Config\n        // BackgroundIndex is the background index in the global color table, for\n        // use with the DisposalBackground disposal method.\n        BackgroundIndex byte\n}</pre> <p> GIF represents the possibly multiple images stored in a GIF file. </p> <h3 id=\"DecodeAll\">func <a href=\"https://golang.org/src/image/gif/reader.go?s=13147:13188#L467\">DecodeAll</a>  </h3> <pre data-language=\"go\">func DecodeAll(r io.Reader) (*GIF, error)</pre> <p> DecodeAll reads a GIF image from r and returns the sequential frames and timing information. </p> <h2 id=\"Options\">type Options  </h2> <pre data-language=\"go\">type Options struct {\n        // NumColors is the maximum number of colors used in the image.\n        // It ranges from 1 to 256.\n        NumColors int\n\n        // Quantizer is used to produce a palette with size NumColors.\n        // palette.Plan9 is used in place of a nil Quantizer.\n        Quantizer draw.Quantizer\n\n        // Drawer is used to convert the source image to the desired palette.\n        // draw.FloydSteinberg is used in place of a nil Drawer.\n        Drawer draw.Drawer\n}</pre> <p> Options are the encoding parameters. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/image/gif/\" class=\"_attribution-link\">https://golang.org/pkg/image/gif/</a>\n  </p>\n</div>\n","index/suffixarray/index":"<h1>Package suffixarray</h1>     <ul id=\"short-nav\">\n<li><code>import \"index/suffixarray\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package suffixarray implements substring search in logarithmic time using an in-memory suffix array. </p> <p> Example use: </p> <pre data-language=\"go\">// create index for some data\nindex := suffixarray.New(data)\n\n// lookup byte slice s\noffsets1 := index.Lookup(s, -1) // the list of all indices where s occurs in data\noffsets2 := index.Lookup(s, 3)  // the list of at most 3 indices where s occurs in data\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Index\">type Index</a></li>\n<li> <a href=\"#New\">func New(data []byte) *Index</a>\n</li>\n<li> <a href=\"#Index.Bytes\">func (x *Index) Bytes() []byte</a>\n</li>\n<li> <a href=\"#Index.FindAllIndex\">func (x *Index) FindAllIndex(r *regexp.Regexp, n int) (result [][]int)</a>\n</li>\n<li> <a href=\"#Index.Lookup\">func (x *Index) Lookup(s []byte, n int) (result []int)</a>\n</li>\n<li> <a href=\"#Index.Read\">func (x *Index) Read(r io.Reader) error</a>\n</li>\n<li> <a href=\"#Index.Write\">func (x *Index) Write(w io.Writer) error</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/index/suffixarray/qsufsort.go\">qsufsort.go</a> <a href=\"https://golang.org/src/index/suffixarray/suffixarray.go\">suffixarray.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Index\">type Index  </h2> <pre data-language=\"go\">type Index struct {\n        // contains filtered or unexported fields\n}</pre> <p> Index implements a suffix array for fast substring search. </p> <h3 id=\"New\">func <a href=\"https://golang.org/src/index/suffixarray/suffixarray.go?s=900:928#L25\">New</a>  </h3> <pre data-language=\"go\">func New(data []byte) *Index</pre> <p> New creates a new Index for data. Index creation time is O(N*log(N)) for N = len(data). </p> <h3 id=\"Index.Bytes\">func (*Index) <a href=\"https://golang.org/src/index/suffixarray/suffixarray.go?s=3824:3854#L155\">Bytes</a>  </h3> <pre data-language=\"go\">func (x *Index) Bytes() []byte</pre> <p> Bytes returns the data over which the index was created. It must not be modified. </p> <h3 id=\"Index.FindAllIndex\">func (*Index) <a href=\"https://golang.org/src/index/suffixarray/suffixarray.go?s=5421:5491#L202\">FindAllIndex</a>  </h3> <pre data-language=\"go\">func (x *Index) FindAllIndex(r *regexp.Regexp, n int) (result [][]int)</pre> <p> FindAllIndex returns a sorted list of non-overlapping matches of the regular expression r, where a match is a pair of indices specifying the matched slice of x.Bytes(). If n &lt; 0, all matches are returned in successive order. Otherwise, at most n matches are returned and they may not be successive. The result is nil if there are no matches, or if n == 0. </p> <h3 id=\"Index.Lookup\">func (*Index) <a href=\"https://golang.org/src/index/suffixarray/suffixarray.go?s=4764:4818#L180\">Lookup</a>  </h3> <pre data-language=\"go\">func (x *Index) Lookup(s []byte, n int) (result []int)</pre> <p> Lookup returns an unsorted list of at most n indices where the byte string s occurs in the indexed data. If n &lt; 0, all occurrences are returned. The result is nil if s is empty, s is not found, or n == 0. Lookup time is O(log(N)*len(s) + len(result)) where N is the size of the indexed data. </p> <h3 id=\"Index.Read\">func (*Index) <a href=\"https://golang.org/src/index/suffixarray/suffixarray.go?s=2583:2622#L88\">Read</a>  </h3> <pre data-language=\"go\">func (x *Index) Read(r io.Reader) error</pre> <p> Read reads the index from r into x; x must not be nil. </p> <h3 id=\"Index.Write\">func (*Index) <a href=\"https://golang.org/src/index/suffixarray/suffixarray.go?s=3317:3357#L127\">Write</a>  </h3> <pre data-language=\"go\">func (x *Index) Write(w io.Writer) error</pre> <p> Write writes the index x to w. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/index/suffixarray/\" class=\"_attribution-link\">https://golang.org/pkg/index/suffixarray/</a>\n  </p>\n</div>\n","image/png/index":"<h1>Package png</h1>     <ul id=\"short-nav\">\n<li><code>import \"image/png\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package png implements a PNG image decoder and encoder. </p> <p> The PNG specification is at <a href=\"http://www.w3.org/TR/PNG/\">http://www.w3.org/TR/PNG/</a>. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Decode\">func Decode(r io.Reader) (image.Image, error)</a></li>\n<li><a href=\"#DecodeConfig\">func DecodeConfig(r io.Reader) (image.Config, error)</a></li>\n<li><a href=\"#Encode\">func Encode(w io.Writer, m image.Image) error</a></li>\n<li><a href=\"#CompressionLevel\">type CompressionLevel</a></li>\n<li><a href=\"#Encoder\">type Encoder</a></li>\n<li> <a href=\"#Encoder.Encode\">func (enc *Encoder) Encode(w io.Writer, m image.Image) error</a>\n</li>\n<li><a href=\"#FormatError\">type FormatError</a></li>\n<li> <a href=\"#FormatError.Error\">func (e FormatError) Error() string</a>\n</li>\n<li><a href=\"#UnsupportedError\">type UnsupportedError</a></li>\n<li> <a href=\"#UnsupportedError.Error\">func (e UnsupportedError) Error() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/image/png/paeth.go\">paeth.go</a> <a href=\"https://golang.org/src/image/png/reader.go\">reader.go</a> <a href=\"https://golang.org/src/image/png/writer.go\">writer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Decode\">func Decode  </h2> <pre data-language=\"go\">func Decode(r io.Reader) (image.Image, error)</pre> <p> Decode reads a PNG image from r and returns it as an image.Image. The type of Image returned depends on the PNG contents. </p> <h2 id=\"DecodeConfig\">func DecodeConfig  </h2> <pre data-language=\"go\">func DecodeConfig(r io.Reader) (image.Config, error)</pre> <p> DecodeConfig returns the color model and dimensions of a PNG image without decoding the entire image. </p> <h2 id=\"Encode\">func Encode  </h2> <pre data-language=\"go\">func Encode(w io.Writer, m image.Image) error</pre> <p> Encode writes the Image m to w in PNG format. Any Image may be encoded, but images that are not image.NRGBA might be encoded lossily. </p> <h2 id=\"CompressionLevel\">type CompressionLevel  </h2> <pre data-language=\"go\">type CompressionLevel int</pre> <pre data-language=\"go\">const (\n        DefaultCompression CompressionLevel = 0\n        NoCompression      CompressionLevel = -1\n        BestSpeed          CompressionLevel = -2\n        BestCompression    CompressionLevel = -3\n)</pre> <h2 id=\"Encoder\">type Encoder  </h2> <pre data-language=\"go\">type Encoder struct {\n        CompressionLevel CompressionLevel\n}</pre> <p> Encoder configures encoding PNG images. </p> <h3 id=\"Encoder.Encode\">func (*Encoder) <a href=\"https://golang.org/src/image/png/writer.go?s=11106:11166#L470\">Encode</a>  </h3> <pre data-language=\"go\">func (enc *Encoder) Encode(w io.Writer, m image.Image) error</pre> <p> Encode writes the Image m to w in PNG format. </p> <h2 id=\"FormatError\">type FormatError  </h2> <pre data-language=\"go\">type FormatError string</pre> <p> A FormatError reports that the input is not a valid PNG. </p> <h3 id=\"FormatError.Error\">func (FormatError) <a href=\"https://golang.org/src/image/png/reader.go?s=2236:2271#L111\">Error</a>  </h3> <pre data-language=\"go\">func (e FormatError) Error() string</pre> <h2 id=\"UnsupportedError\">type UnsupportedError  </h2> <pre data-language=\"go\">type UnsupportedError string</pre> <p> An UnsupportedError reports that the input uses a valid but unimplemented PNG feature. </p> <h3 id=\"UnsupportedError.Error\">func (UnsupportedError) <a href=\"https://golang.org/src/image/png/reader.go?s=2497:2537#L118\">Error</a>  </h3> <pre data-language=\"go\">func (e UnsupportedError) Error() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/image/png/\" class=\"_attribution-link\">https://golang.org/pkg/image/png/</a>\n  </p>\n</div>\n","go/token/index":"<h1>Package token</h1>     <ul id=\"short-nav\">\n<li><code>import \"go/token\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package token defines constants representing the lexical tokens of the Go programming language and basic operations on tokens (printing, predicates). </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#File\">type File</a></li>\n<li> <a href=\"#File.AddLine\">func (f *File) AddLine(offset int)</a>\n</li>\n<li> <a href=\"#File.AddLineInfo\">func (f *File) AddLineInfo(offset int, filename string, line int)</a>\n</li>\n<li> <a href=\"#File.Base\">func (f *File) Base() int</a>\n</li>\n<li> <a href=\"#File.Line\">func (f *File) Line(p Pos) int</a>\n</li>\n<li> <a href=\"#File.LineCount\">func (f *File) LineCount() int</a>\n</li>\n<li> <a href=\"#File.MergeLine\">func (f *File) MergeLine(line int)</a>\n</li>\n<li> <a href=\"#File.Name\">func (f *File) Name() string</a>\n</li>\n<li> <a href=\"#File.Offset\">func (f *File) Offset(p Pos) int</a>\n</li>\n<li> <a href=\"#File.Pos\">func (f *File) Pos(offset int) Pos</a>\n</li>\n<li> <a href=\"#File.Position\">func (f *File) Position(p Pos) (pos Position)</a>\n</li>\n<li> <a href=\"#File.PositionFor\">func (f *File) PositionFor(p Pos, adjusted bool) (pos Position)</a>\n</li>\n<li> <a href=\"#File.SetLines\">func (f *File) SetLines(lines []int) bool</a>\n</li>\n<li> <a href=\"#File.SetLinesForContent\">func (f *File) SetLinesForContent(content []byte)</a>\n</li>\n<li> <a href=\"#File.Size\">func (f *File) Size() int</a>\n</li>\n<li><a href=\"#FileSet\">type FileSet</a></li>\n<li> <a href=\"#NewFileSet\">func NewFileSet() *FileSet</a>\n</li>\n<li> <a href=\"#FileSet.AddFile\">func (s *FileSet) AddFile(filename string, base, size int) *File</a>\n</li>\n<li> <a href=\"#FileSet.Base\">func (s *FileSet) Base() int</a>\n</li>\n<li> <a href=\"#FileSet.File\">func (s *FileSet) File(p Pos) (f *File)</a>\n</li>\n<li> <a href=\"#FileSet.Iterate\">func (s *FileSet) Iterate(f func(*File) bool)</a>\n</li>\n<li> <a href=\"#FileSet.Position\">func (s *FileSet) Position(p Pos) (pos Position)</a>\n</li>\n<li> <a href=\"#FileSet.PositionFor\">func (s *FileSet) PositionFor(p Pos, adjusted bool) (pos Position)</a>\n</li>\n<li> <a href=\"#FileSet.Read\">func (s *FileSet) Read(decode func(interface{}) error) error</a>\n</li>\n<li> <a href=\"#FileSet.Write\">func (s *FileSet) Write(encode func(interface{}) error) error</a>\n</li>\n<li><a href=\"#Pos\">type Pos</a></li>\n<li> <a href=\"#Pos.IsValid\">func (p Pos) IsValid() bool</a>\n</li>\n<li><a href=\"#Position\">type Position</a></li>\n<li> <a href=\"#Position.IsValid\">func (pos *Position) IsValid() bool</a>\n</li>\n<li> <a href=\"#Position.String\">func (pos Position) String() string</a>\n</li>\n<li><a href=\"#Token\">type Token</a></li>\n<li> <a href=\"#Lookup\">func Lookup(ident string) Token</a>\n</li>\n<li> <a href=\"#Token.IsKeyword\">func (tok Token) IsKeyword() bool</a>\n</li>\n<li> <a href=\"#Token.IsLiteral\">func (tok Token) IsLiteral() bool</a>\n</li>\n<li> <a href=\"#Token.IsOperator\">func (tok Token) IsOperator() bool</a>\n</li>\n<li> <a href=\"#Token.Precedence\">func (op Token) Precedence() int</a>\n</li>\n<li> <a href=\"#Token.String\">func (tok Token) String() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/go/token/position.go\">position.go</a> <a href=\"https://golang.org/src/go/token/serialize.go\">serialize.go</a> <a href=\"https://golang.org/src/go/token/token.go\">token.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        LowestPrec  = 0 // non-operators\n        UnaryPrec   = 6\n        HighestPrec = 7\n)</pre> <p> A set of constants for precedence-based expression parsing. Non-operators have lowest precedence, followed by operators starting with precedence 1 up to unary operators. The highest precedence serves as \"catch-all\" precedence for selector, indexing, and other operator and delimiter tokens. </p> <h2 id=\"File\">type File  </h2> <pre data-language=\"go\">type File struct {\n        // contains filtered or unexported fields\n}</pre> <p> A File is a handle for a file belonging to a FileSet. A File has a name, size, and line offset table. </p> <h3 id=\"File.AddLine\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=3983:4017#L119\">AddLine</a>  </h3> <pre data-language=\"go\">func (f *File) AddLine(offset int)</pre> <p> AddLine adds the line offset for a new line. The line offset must be larger than the offset for the previous line and smaller than the file size; otherwise the line offset is ignored. </p> <h3 id=\"File.AddLineInfo\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=7016:7081#L214\">AddLineInfo</a>  </h3> <pre data-language=\"go\">func (f *File) AddLineInfo(offset int, filename string, line int)</pre> <p> AddLineInfo adds alternative file and line number information for a given file offset. The offset must be larger than the offset for the previously added alternative line info and smaller than the file size; otherwise the information is ignored. </p> <p> AddLineInfo is typically used to register alternative position information for //line filename:line comments in source files. </p> <h3 id=\"File.Base\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=3471:3496#L98\">Base</a>  </h3> <pre data-language=\"go\">func (f *File) Base() int</pre> <p> Base returns the base offset of file f as registered with AddFile. </p> <h3 id=\"File.Line\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=7926:7956#L247\">Line</a>  </h3> <pre data-language=\"go\">func (f *File) Line(p Pos) int</pre> <p> Line returns the line number for the given file position p; p must be a Pos value in that file or NoPos. </p> <h3 id=\"File.LineCount\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=3678:3708#L108\">LineCount</a>  </h3> <pre data-language=\"go\">func (f *File) LineCount() int</pre> <p> LineCount returns the number of lines in file f. </p> <h3 id=\"File.MergeLine\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=4476:4510#L132\">MergeLine</a>  </h3> <pre data-language=\"go\">func (f *File) MergeLine(line int)</pre> <p> MergeLine merges a line with the following line. It is akin to replacing the newline character at the end of the line with a space (to not change the remaining offsets). To obtain the line number, consult e.g. Position.Line. MergeLine will panic if given an invalid line number. </p> <h3 id=\"File.Name\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=3352:3380#L93\">Name</a>  </h3> <pre data-language=\"go\">func (f *File) Name() string</pre> <p> Name returns the file name of file f as registered with AddFile. </p> <h3 id=\"File.Offset\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=7670:7702#L237\">Offset</a>  </h3> <pre data-language=\"go\">func (f *File) Offset(p Pos) int</pre> <p> Offset returns the offset for the given file position p; p must be a valid Pos value in that file. f.Offset(f.Pos(offset)) == offset. </p> <h3 id=\"File.Pos\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=7399:7433#L226\">Pos</a>  </h3> <pre data-language=\"go\">func (f *File) Pos(offset int) Pos</pre> <p> Pos returns the Pos value for the given file offset; the offset must be &lt;= f.Size(). f.Pos(f.Offset(p)) == p. </p> <h3 id=\"File.Position\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=9628:9673#L302\">Position</a>  </h3> <pre data-language=\"go\">func (f *File) Position(p Pos) (pos Position)</pre> <p> Position returns the Position value for the given file position p. Calling f.Position(p) is equivalent to calling f.PositionFor(p, true). </p> <h3 id=\"File.PositionFor\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=9269:9332#L289\">PositionFor</a>  </h3> <pre data-language=\"go\">func (f *File) PositionFor(p Pos, adjusted bool) (pos Position)</pre> <p> PositionFor returns the Position value for the given file position p. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in f or NoPos. </p> <h3 id=\"File.SetLines\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=5605:5646#L159\">SetLines</a>  </h3> <pre data-language=\"go\">func (f *File) SetLines(lines []int) bool</pre> <p> SetLines sets the line offsets for a file and reports whether it succeeded. The line offsets are the offsets of the first character of each line; for instance for the content \"ab\\nc\\n\" the line offsets are {0, 3}. An empty file has an empty line offset table. Each line offset must be larger than the offset for the previous line and smaller than the file size; otherwise SetLines fails and returns false. Callers must not mutate the provided slice after SetLines returns. </p> <h3 id=\"File.SetLinesForContent\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=6027:6076#L177\">SetLinesForContent</a>  </h3> <pre data-language=\"go\">func (f *File) SetLinesForContent(content []byte)</pre> <p> SetLinesForContent sets the line offsets for the given file content. It ignores position-altering //line comments. </p> <h3 id=\"File.Size\">func (*File) <a href=\"https://golang.org/src/go/token/position.go?s=3580:3605#L103\">Size</a>  </h3> <pre data-language=\"go\">func (f *File) Size() int</pre> <p> Size returns the size of file f as registered with AddFile. </p> <h2 id=\"FileSet\">type FileSet  </h2> <pre data-language=\"go\">type FileSet struct {\n        // contains filtered or unexported fields\n}</pre> <p> A FileSet represents a set of source files. Methods of file sets are synchronized; multiple goroutines may invoke them concurrently. </p> <h3 id=\"NewFileSet\">func <a href=\"https://golang.org/src/go/token/position.go?s=10228:10254#L321\">NewFileSet</a>  </h3> <pre data-language=\"go\">func NewFileSet() *FileSet</pre> <p> NewFileSet creates a new file set. </p> <h3 id=\"FileSet.AddFile\">func (*FileSet) <a href=\"https://golang.org/src/go/token/position.go?s=11309:11373#L354\">AddFile</a>  </h3> <pre data-language=\"go\">func (s *FileSet) AddFile(filename string, base, size int) *File</pre> <p> AddFile adds a new file with a given filename, base offset, and file size to the file set s and returns the file. Multiple files may have the same name. The base offset must not be smaller than the FileSet's Base(), and size must not be negative. As a special case, if a negative base is provided, the current value of the FileSet's Base() is used instead. </p> <p> Adding the file will set the file set's Base() value to base + size + 1 as the minimum base value for the next file. The following relationship exists between a Pos value p for a given file offset offs: </p> <pre data-language=\"go\">int(p) = base + offs\n</pre> <p> with offs in the range [0, size] and thus p in the range [base, base+size]. For convenience, File.Pos may be used to create file-specific position values from a file offset. </p> <h3 id=\"FileSet.Base\">func (*FileSet) <a href=\"https://golang.org/src/go/token/position.go?s=10412:10440#L330\">Base</a>  </h3> <pre data-language=\"go\">func (s *FileSet) Base() int</pre> <p> Base returns the minimum base offset that must be provided to AddFile when adding the next file. </p> <h3 id=\"FileSet.File\">func (*FileSet) <a href=\"https://golang.org/src/go/token/position.go?s=12994:13033#L424\">File</a>  </h3> <pre data-language=\"go\">func (s *FileSet) File(p Pos) (f *File)</pre> <p> File returns the file that contains the position p. If no such file is found (for instance for p == NoPos), the result is nil. </p> <h3 id=\"FileSet.Iterate\">func (*FileSet) <a href=\"https://golang.org/src/go/token/position.go?s=11956:12001#L379\">Iterate</a>  </h3> <pre data-language=\"go\">func (s *FileSet) Iterate(f func(*File) bool)</pre> <p> Iterate calls f for the files in the file set in the order they were added until f returns false. </p> <h3 id=\"FileSet.Position\">func (*FileSet) <a href=\"https://golang.org/src/go/token/position.go?s=13640:13688#L448\">Position</a>  </h3> <pre data-language=\"go\">func (s *FileSet) Position(p Pos) (pos Position)</pre> <p> Position converts a Pos p in the fileset into a Position value. Calling s.Position(p) is equivalent to calling s.PositionFor(p, true). </p> <h3 id=\"FileSet.PositionFor\">func (*FileSet) <a href=\"https://golang.org/src/go/token/position.go?s=13327:13393#L436\">PositionFor</a>  </h3> <pre data-language=\"go\">func (s *FileSet) PositionFor(p Pos, adjusted bool) (pos Position)</pre> <p> PositionFor converts a Pos p in the fileset into a Position value. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in s or NoPos. </p> <h3 id=\"FileSet.Read\">func (*FileSet) <a href=\"https://golang.org/src/go/token/serialize.go?s=490:550#L12\">Read</a>  </h3> <pre data-language=\"go\">func (s *FileSet) Read(decode func(interface{}) error) error</pre> <p> Read calls decode to deserialize a file set into s; s must not be nil. </p> <h3 id=\"FileSet.Write\">func (*FileSet) <a href=\"https://golang.org/src/go/token/serialize.go?s=947:1008#L33\">Write</a>  </h3> <pre data-language=\"go\">func (s *FileSet) Write(encode func(interface{}) error) error</pre> <p> Write calls encode to serialize the file set s. </p> <h2 id=\"Pos\">type Pos  </h2> <pre data-language=\"go\">type Pos int</pre> <p> Pos is a compact encoding of a source position within a file set. It can be converted into a Position for a more convenient, but much larger, representation. </p> <p> The Pos value for a given file is a number in the range [base, base+size], where base and size are specified when adding the file to the file set via AddFile. </p> <p> To create the Pos value for a specific source offset (measured in bytes), first add the respective file to the current file set using FileSet.AddFile and then call File.Pos(offset) for that file. Given a Pos value p for a specific file set fset, the corresponding Position value is obtained by calling fset.Position(p). </p> <p> Pos values can be compared directly with the usual comparison operators: If two Pos values p and q are in the same file, comparing p and q is equivalent to comparing the respective source file offsets. If p and q are in different files, p &lt; q is true if the file implied by p was added to the respective file set before the file implied by q. </p> <pre data-language=\"go\">const NoPos Pos = 0</pre> <p> The zero value for Pos is NoPos; there is no file and line information associated with it, and NoPos().IsValid() is false. NoPos is always smaller than any other Pos value. The corresponding Position value for NoPos is the zero value for Position. </p> <h3 id=\"Pos.IsValid\">func (Pos) <a href=\"https://golang.org/src/go/token/position.go?s=2653:2680#L71\">IsValid</a>  </h3> <pre data-language=\"go\">func (p Pos) IsValid() bool</pre> <p> IsValid reports whether the position is valid. </p> <h2 id=\"Position\">type Position  </h2> <pre data-language=\"go\">type Position struct {\n        Filename string // filename, if any\n        Offset   int    // offset, starting at 0\n        Line     int    // line number, starting at 1\n        Column   int    // column number, starting at 1 (byte count)\n}</pre> <p> Position describes an arbitrary source position including the file, line, and column location. A Position is valid if the line number is &gt; 0. </p> <h3 id=\"Position.IsValid\">func (*Position) <a href=\"https://golang.org/src/go/token/position.go?s=723:758#L18\">IsValid</a>  </h3> <pre data-language=\"go\">func (pos *Position) IsValid() bool</pre> <p> IsValid reports whether the position is valid. </p> <h3 id=\"Position.String\">func (Position) <a href=\"https://golang.org/src/go/token/position.go?s=1064:1099#L27\">String</a>  </h3> <pre data-language=\"go\">func (pos Position) String() string</pre> <p> String returns a string in one of several forms: </p> <pre data-language=\"go\">file:line:column    valid position with file name\nline:column         valid position without file name\nfile                invalid position with file name\n-                   invalid position without file name\n</pre> <h2 id=\"Token\">type Token  </h2> <pre data-language=\"go\">type Token int</pre> <p> Token is the set of lexical tokens of the Go programming language. </p> <pre data-language=\"go\">const (\n        // Special tokens\n        ILLEGAL Token = iota\n        EOF\n        COMMENT\n\n        // Identifiers and basic type literals\n        // (these tokens stand for classes of literals)\n        IDENT  // main\n        INT    // 12345\n        FLOAT  // 123.45\n        IMAG   // 123.45i\n        CHAR   // 'a'\n        STRING // \"abc\"\n\n        // Operators and delimiters\n        ADD // +\n        SUB // -\n        MUL // *\n        QUO // /\n        REM // %\n\n        AND     // &amp;\n        OR      // |\n        XOR     // ^\n        SHL     // &lt;&lt;\n        SHR     // &gt;&gt;\n        AND_NOT // &amp;^\n\n        ADD_ASSIGN // +=\n        SUB_ASSIGN // -=\n        MUL_ASSIGN // *=\n        QUO_ASSIGN // /=\n        REM_ASSIGN // %=\n\n        AND_ASSIGN     // &amp;=\n        OR_ASSIGN      // |=\n        XOR_ASSIGN     // ^=\n        SHL_ASSIGN     // &lt;&lt;=\n        SHR_ASSIGN     // &gt;&gt;=\n        AND_NOT_ASSIGN // &amp;^=\n\n        LAND  // &amp;&amp;\n        LOR   // ||\n        ARROW // &lt;-\n        INC   // ++\n        DEC   // --\n\n        EQL    // ==\n        LSS    // &lt;\n        GTR    // &gt;\n        ASSIGN // =\n        NOT    // !\n\n        NEQ      // !=\n        LEQ      // &lt;=\n        GEQ      // &gt;=\n        DEFINE   // :=\n        ELLIPSIS // ...\n\n        LPAREN // (\n        LBRACK // [\n        LBRACE // {\n        COMMA  // ,\n        PERIOD // .\n\n        RPAREN    // )\n        RBRACK    // ]\n        RBRACE    // }\n        SEMICOLON // ;\n        COLON     // :\n\n        // Keywords\n        BREAK\n        CASE\n        CHAN\n        CONST\n        CONTINUE\n\n        DEFAULT\n        DEFER\n        ELSE\n        FALLTHROUGH\n        FOR\n\n        FUNC\n        GO\n        GOTO\n        IF\n        IMPORT\n\n        INTERFACE\n        MAP\n        PACKAGE\n        RANGE\n        RETURN\n\n        SELECT\n        STRUCT\n        SWITCH\n        TYPE\n        VAR\n)</pre> <p> The list of tokens. </p> <h3 id=\"Lookup\">func <a href=\"https://golang.org/src/go/token/token.go?s=4785:4816#L276\">Lookup</a>  </h3> <pre data-language=\"go\">func Lookup(ident string) Token</pre> <p> Lookup maps an identifier to its keyword token or IDENT (if not a keyword). </p> <h3 id=\"Token.IsKeyword\">func (Token) <a href=\"https://golang.org/src/go/token/token.go?s=5431:5464#L298\">IsKeyword</a>  </h3> <pre data-language=\"go\">func (tok Token) IsKeyword() bool</pre> <p> IsKeyword returns true for tokens corresponding to keywords; it returns false otherwise. </p> <h3 id=\"Token.IsLiteral\">func (Token) <a href=\"https://golang.org/src/go/token/token.go?s=5045:5078#L288\">IsLiteral</a>  </h3> <pre data-language=\"go\">func (tok Token) IsLiteral() bool</pre> <p> IsLiteral returns true for tokens corresponding to identifiers and basic type literals; it returns false otherwise. </p> <h3 id=\"Token.IsOperator\">func (Token) <a href=\"https://golang.org/src/go/token/token.go?s=5245:5279#L293\">IsOperator</a>  </h3> <pre data-language=\"go\">func (tok Token) IsOperator() bool</pre> <p> IsOperator returns true for tokens corresponding to operators and delimiters; it returns false otherwise. </p> <h3 id=\"Token.Precedence\">func (Token) <a href=\"https://golang.org/src/go/token/token.go?s=4284:4316#L249\">Precedence</a>  </h3> <pre data-language=\"go\">func (op Token) Precedence() int</pre> <p> Precedence returns the operator precedence of the binary operator op. If op is not a binary operator, the result is LowestPrecedence. </p> <h3 id=\"Token.String\">func (Token) <a href=\"https://golang.org/src/go/token/token.go?s=3566:3598#L222\">String</a>  </h3> <pre data-language=\"go\">func (tok Token) String() string</pre> <p> String returns the string corresponding to the token tok. For operators, delimiters, and keywords the string is the actual token character sequence (e.g., for the token ADD, the string is \"+\"). For all other tokens the string corresponds to the token constant name (e.g. for the token IDENT, the string is \"IDENT\"). </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/go/token/\" class=\"_attribution-link\">https://golang.org/pkg/go/token/</a>\n  </p>\n</div>\n","flag/index":"<h1>Package flag</h1>     <ul id=\"short-nav\">\n<li><code>import \"flag\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package flag implements command-line flag parsing. </p> <p> Usage: </p> <p> Define flags using flag.String(), Bool(), Int(), etc. </p> <p> This declares an integer flag, -flagname, stored in the pointer ip, with type *int. </p> <pre data-language=\"go\">import \"flag\"\nvar ip = flag.Int(\"flagname\", 1234, \"help message for flagname\")\n</pre> <p> If you like, you can bind the flag to a variable using the Var() functions. </p> <pre data-language=\"go\">var flagvar int\nfunc init() {\n\tflag.IntVar(&amp;flagvar, \"flagname\", 1234, \"help message for flagname\")\n}\n</pre> <p> Or you can create custom flags that satisfy the Value interface (with pointer receivers) and couple them to flag parsing by </p> <pre data-language=\"go\">flag.Var(&amp;flagVal, \"name\", \"help message for flagname\")\n</pre> <p> For such flags, the default value is just the initial value of the variable. </p> <p> After all flags are defined, call </p> <pre data-language=\"go\">flag.Parse()\n</pre> <p> to parse the command line into the defined flags. </p> <p> Flags may then be used directly. If you're using the flags themselves, they are all pointers; if you bind to variables, they're values. </p> <pre data-language=\"go\">fmt.Println(\"ip has value \", *ip)\nfmt.Println(\"flagvar has value \", flagvar)\n</pre> <p> After parsing, the arguments following the flags are available as the slice flag.Args() or individually as flag.Arg(i). The arguments are indexed from 0 through flag.NArg()-1. </p> <p> Command line flag syntax: </p> <pre data-language=\"go\">-flag\n-flag=x\n-flag x  // non-boolean flags only\n</pre> <p> One or two minus signs may be used; they are equivalent. The last form is not permitted for boolean flags because the meaning of the command </p> <pre data-language=\"go\">cmd -x *\n</pre> <p> will change if there is a file called 0, false, etc. You must use the -flag=false form to turn off a boolean flag. </p> <p> Flag parsing stops just before the first non-flag argument (\"-\" is a non-flag argument) or after the terminator \"--\". </p> <p> Integer flags accept 1234, 0664, 0x1234 and may be negative. Boolean flags may be: </p> <pre data-language=\"go\">1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False\n</pre> <p> Duration flags accept any input valid for time.ParseDuration. </p> <p> The default set of command-line flags is controlled by top-level functions. The FlagSet type allows one to define independent sets of flags, such as to implement subcommands in a command-line interface. The methods of FlagSet are analogous to the top-level functions for the command-line flag set. </p> </div> </div> <div id=\"example_\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">// These examples demonstrate more intricate uses of the flag package.\npackage main\n\nimport (\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n)\n\n// Example 1: A single string flag called \"species\" with default value \"gopher\".\nvar species = flag.String(\"species\", \"gopher\", \"the species we are studying\")\n\n// Example 2: Two flags sharing a variable, so we can have a shorthand.\n// The order of initialization is undefined, so make sure both use the\n// same default value. They must be set up with an init function.\nvar gopherType string\n\nfunc init() {\n\tconst (\n\t\tdefaultGopher = \"pocket\"\n\t\tusage         = \"the variety of gopher\"\n\t)\n\tflag.StringVar(&amp;gopherType, \"gopher_type\", defaultGopher, usage)\n\tflag.StringVar(&amp;gopherType, \"g\", defaultGopher, usage+\" (shorthand)\")\n}\n\n// Example 3: A user-defined flag type, a slice of durations.\ntype interval []time.Duration\n\n// String is the method to format the flag's value, part of the flag.Value interface.\n// The String method's output will be used in diagnostics.\nfunc (i *interval) String() string {\n\treturn fmt.Sprint(*i)\n}\n\n// Set is the method to set the flag value, part of the flag.Value interface.\n// Set's argument is a string to be parsed to set the flag.\n// It's a comma-separated list, so we split it.\nfunc (i *interval) Set(value string) error {\n\t// If we wanted to allow the flag to be set multiple times,\n\t// accumulating values, we would delete this if statement.\n\t// That would permit usages such as\n\t//\t-deltaT 10s -deltaT 15s\n\t// and other combinations.\n\tif len(*i) &gt; 0 {\n\t\treturn errors.New(\"interval flag already set\")\n\t}\n\tfor _, dt := range strings.Split(value, \",\") {\n\t\tduration, err := time.ParseDuration(dt)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*i = append(*i, duration)\n\t}\n\treturn nil\n}\n\n// Define a flag to accumulate durations. Because it has a special type,\n// we need to use the Var function and therefore create the flag during\n// init.\n\nvar intervalFlag interval\n\nfunc init() {\n\t// Tie the command-line flag to the intervalFlag variable and\n\t// set a usage message.\n\tflag.Var(&amp;intervalFlag, \"deltaT\", \"comma-separated list of intervals to use between events\")\n}\n\nfunc main() {\n\t// All the interesting pieces are with the variables declared above, but\n\t// to enable the flag package to see the flags defined there, one must\n\t// execute, typically at the start of main (not init!):\n\t//\tflag.Parse()\n\t// We don't run it here because this is not a main function and\n\t// the testing suite has already parsed the flags.\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Arg\">func Arg(i int) string</a></li>\n<li><a href=\"#Args\">func Args() []string</a></li>\n<li><a href=\"#Bool\">func Bool(name string, value bool, usage string) *bool</a></li>\n<li><a href=\"#BoolVar\">func BoolVar(p *bool, name string, value bool, usage string)</a></li>\n<li><a href=\"#Duration\">func Duration(name string, value time.Duration, usage string) *time.Duration</a></li>\n<li><a href=\"#DurationVar\">func DurationVar(p *time.Duration, name string, value time.Duration, usage string)</a></li>\n<li><a href=\"#Float64\">func Float64(name string, value float64, usage string) *float64</a></li>\n<li><a href=\"#Float64Var\">func Float64Var(p *float64, name string, value float64, usage string)</a></li>\n<li><a href=\"#Int\">func Int(name string, value int, usage string) *int</a></li>\n<li><a href=\"#Int64\">func Int64(name string, value int64, usage string) *int64</a></li>\n<li><a href=\"#Int64Var\">func Int64Var(p *int64, name string, value int64, usage string)</a></li>\n<li><a href=\"#IntVar\">func IntVar(p *int, name string, value int, usage string)</a></li>\n<li><a href=\"#NArg\">func NArg() int</a></li>\n<li><a href=\"#NFlag\">func NFlag() int</a></li>\n<li><a href=\"#Parse\">func Parse()</a></li>\n<li><a href=\"#Parsed\">func Parsed() bool</a></li>\n<li><a href=\"#PrintDefaults\">func PrintDefaults()</a></li>\n<li><a href=\"#Set\">func Set(name, value string) error</a></li>\n<li><a href=\"#String\">func String(name string, value string, usage string) *string</a></li>\n<li><a href=\"#StringVar\">func StringVar(p *string, name string, value string, usage string)</a></li>\n<li><a href=\"#Uint\">func Uint(name string, value uint, usage string) *uint</a></li>\n<li><a href=\"#Uint64\">func Uint64(name string, value uint64, usage string) *uint64</a></li>\n<li><a href=\"#Uint64Var\">func Uint64Var(p *uint64, name string, value uint64, usage string)</a></li>\n<li><a href=\"#UintVar\">func UintVar(p *uint, name string, value uint, usage string)</a></li>\n<li><a href=\"#UnquoteUsage\">func UnquoteUsage(flag *Flag) (name string, usage string)</a></li>\n<li><a href=\"#Var\">func Var(value Value, name string, usage string)</a></li>\n<li><a href=\"#Visit\">func Visit(fn func(*Flag))</a></li>\n<li><a href=\"#VisitAll\">func VisitAll(fn func(*Flag))</a></li>\n<li><a href=\"#ErrorHandling\">type ErrorHandling</a></li>\n<li><a href=\"#Flag\">type Flag</a></li>\n<li> <a href=\"#Lookup\">func Lookup(name string) *Flag</a>\n</li>\n<li><a href=\"#FlagSet\">type FlagSet</a></li>\n<li> <a href=\"#NewFlagSet\">func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet</a>\n</li>\n<li> <a href=\"#FlagSet.Arg\">func (f *FlagSet) Arg(i int) string</a>\n</li>\n<li> <a href=\"#FlagSet.Args\">func (f *FlagSet) Args() []string</a>\n</li>\n<li> <a href=\"#FlagSet.Bool\">func (f *FlagSet) Bool(name string, value bool, usage string) *bool</a>\n</li>\n<li> <a href=\"#FlagSet.BoolVar\">func (f *FlagSet) BoolVar(p *bool, name string, value bool, usage string)</a>\n</li>\n<li> <a href=\"#FlagSet.Duration\">func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time.Duration</a>\n</li>\n<li> <a href=\"#FlagSet.DurationVar\">func (f *FlagSet) DurationVar(p *time.Duration, name string, value time.Duration, usage string)</a>\n</li>\n<li> <a href=\"#FlagSet.Float64\">func (f *FlagSet) Float64(name string, value float64, usage string) *float64</a>\n</li>\n<li> <a href=\"#FlagSet.Float64Var\">func (f *FlagSet) Float64Var(p *float64, name string, value float64, usage string)</a>\n</li>\n<li> <a href=\"#FlagSet.Init\">func (f *FlagSet) Init(name string, errorHandling ErrorHandling)</a>\n</li>\n<li> <a href=\"#FlagSet.Int\">func (f *FlagSet) Int(name string, value int, usage string) *int</a>\n</li>\n<li> <a href=\"#FlagSet.Int64\">func (f *FlagSet) Int64(name string, value int64, usage string) *int64</a>\n</li>\n<li> <a href=\"#FlagSet.Int64Var\">func (f *FlagSet) Int64Var(p *int64, name string, value int64, usage string)</a>\n</li>\n<li> <a href=\"#FlagSet.IntVar\">func (f *FlagSet) IntVar(p *int, name string, value int, usage string)</a>\n</li>\n<li> <a href=\"#FlagSet.Lookup\">func (f *FlagSet) Lookup(name string) *Flag</a>\n</li>\n<li> <a href=\"#FlagSet.NArg\">func (f *FlagSet) NArg() int</a>\n</li>\n<li> <a href=\"#FlagSet.NFlag\">func (f *FlagSet) NFlag() int</a>\n</li>\n<li> <a href=\"#FlagSet.Parse\">func (f *FlagSet) Parse(arguments []string) error</a>\n</li>\n<li> <a href=\"#FlagSet.Parsed\">func (f *FlagSet) Parsed() bool</a>\n</li>\n<li> <a href=\"#FlagSet.PrintDefaults\">func (f *FlagSet) PrintDefaults()</a>\n</li>\n<li> <a href=\"#FlagSet.Set\">func (f *FlagSet) Set(name, value string) error</a>\n</li>\n<li> <a href=\"#FlagSet.SetOutput\">func (f *FlagSet) SetOutput(output io.Writer)</a>\n</li>\n<li> <a href=\"#FlagSet.String\">func (f *FlagSet) String(name string, value string, usage string) *string</a>\n</li>\n<li> <a href=\"#FlagSet.StringVar\">func (f *FlagSet) StringVar(p *string, name string, value string, usage string)</a>\n</li>\n<li> <a href=\"#FlagSet.Uint\">func (f *FlagSet) Uint(name string, value uint, usage string) *uint</a>\n</li>\n<li> <a href=\"#FlagSet.Uint64\">func (f *FlagSet) Uint64(name string, value uint64, usage string) *uint64</a>\n</li>\n<li> <a href=\"#FlagSet.Uint64Var\">func (f *FlagSet) Uint64Var(p *uint64, name string, value uint64, usage string)</a>\n</li>\n<li> <a href=\"#FlagSet.UintVar\">func (f *FlagSet) UintVar(p *uint, name string, value uint, usage string)</a>\n</li>\n<li> <a href=\"#FlagSet.Var\">func (f *FlagSet) Var(value Value, name string, usage string)</a>\n</li>\n<li> <a href=\"#FlagSet.Visit\">func (f *FlagSet) Visit(fn func(*Flag))</a>\n</li>\n<li> <a href=\"#FlagSet.VisitAll\">func (f *FlagSet) VisitAll(fn func(*Flag))</a>\n</li>\n<li><a href=\"#Getter\">type Getter</a></li>\n<li><a href=\"#Value\">type Value</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_\">Package</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/flag/flag.go\">flag.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var CommandLine = NewFlagSet(os.Args[0], ExitOnError)</pre> <p> CommandLine is the default set of command-line flags, parsed from os.Args. The top-level functions such as BoolVar, Arg, and so on are wrappers for the methods of CommandLine. </p> <pre data-language=\"go\">var ErrHelp = errors.New(\"flag: help requested\")</pre> <p> ErrHelp is the error returned if the -help or -h flag is invoked but no such flag is defined. </p> <pre data-language=\"go\">var Usage = func() {\n        fmt.Fprintf(os.Stderr, \"Usage of %s:\\n\", os.Args[0])\n        PrintDefaults()\n}</pre> <p> Usage prints to standard error a usage message documenting all defined command-line flags. It is called when an error occurs while parsing flags. The function is a variable that may be changed to point to a custom function. By default it prints a simple header and calls PrintDefaults; for details about the format of the output and how to control it, see the documentation for PrintDefaults. </p> <h2 id=\"Arg\">func Arg  </h2> <pre data-language=\"go\">func Arg(i int) string</pre> <p> Arg returns the i'th command-line argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist. </p> <h2 id=\"Args\">func Args  </h2> <pre data-language=\"go\">func Args() []string</pre> <p> Args returns the non-flag command-line arguments. </p> <h2 id=\"Bool\">func Bool  </h2> <pre data-language=\"go\">func Bool(name string, value bool, usage string) *bool</pre> <p> Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag. </p> <h2 id=\"BoolVar\">func BoolVar  </h2> <pre data-language=\"go\">func BoolVar(p *bool, name string, value bool, usage string)</pre> <p> BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag. </p> <h2 id=\"Duration\">func Duration  </h2> <pre data-language=\"go\">func Duration(name string, value time.Duration, usage string) *time.Duration</pre> <p> Duration defines a time.Duration flag with specified name, default value, and usage string. The return value is the address of a time.Duration variable that stores the value of the flag. The flag accepts a value acceptable to time.ParseDuration. </p> <h2 id=\"DurationVar\">func DurationVar  </h2> <pre data-language=\"go\">func DurationVar(p *time.Duration, name string, value time.Duration, usage string)</pre> <p> DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration. </p> <h2 id=\"Float64\">func Float64  </h2> <pre data-language=\"go\">func Float64(name string, value float64, usage string) *float64</pre> <p> Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag. </p> <h2 id=\"Float64Var\">func Float64Var  </h2> <pre data-language=\"go\">func Float64Var(p *float64, name string, value float64, usage string)</pre> <p> Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag. </p> <h2 id=\"Int\">func Int  </h2> <pre data-language=\"go\">func Int(name string, value int, usage string) *int</pre> <p> Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag. </p> <h2 id=\"Int64\">func Int64  </h2> <pre data-language=\"go\">func Int64(name string, value int64, usage string) *int64</pre> <p> Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag. </p> <h2 id=\"Int64Var\">func Int64Var  </h2> <pre data-language=\"go\">func Int64Var(p *int64, name string, value int64, usage string)</pre> <p> Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag. </p> <h2 id=\"IntVar\">func IntVar  </h2> <pre data-language=\"go\">func IntVar(p *int, name string, value int, usage string)</pre> <p> IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag. </p> <h2 id=\"NArg\">func NArg  </h2> <pre data-language=\"go\">func NArg() int</pre> <p> NArg is the number of arguments remaining after flags have been processed. </p> <h2 id=\"NFlag\">func NFlag  </h2> <pre data-language=\"go\">func NFlag() int</pre> <p> NFlag returns the number of command-line flags that have been set. </p> <h2 id=\"Parse\">func Parse  </h2> <pre data-language=\"go\">func Parse()</pre> <p> Parse parses the command-line flags from os.Args[1:]. Must be called after all flags are defined and before flags are accessed by the program. </p> <h2 id=\"Parsed\">func Parsed  </h2> <pre data-language=\"go\">func Parsed() bool</pre> <p> Parsed reports whether the command-line flags have been parsed. </p> <h2 id=\"PrintDefaults\">func PrintDefaults  </h2> <pre data-language=\"go\">func PrintDefaults()</pre> <p> PrintDefaults prints, to standard error unless configured otherwise, a usage message showing the default settings of all defined command-line flags. For an integer valued flag x, the default output has the form </p> <pre data-language=\"go\">-x int\n\tusage-message-for-x (default 7)\n</pre> <p> The usage message will appear on a separate line for anything but a bool flag with a one-byte name. For bool flags, the type is omitted and if the flag name is one byte the usage message appears on the same line. The parenthetical default is omitted if the default is the zero value for the type. The listed type, here int, can be changed by placing a back-quoted name in the flag's usage string; the first such item in the message is taken to be a parameter name to show in the message and the back quotes are stripped from the message when displayed. For instance, given </p> <pre data-language=\"go\">flag.String(\"I\", \"\", \"search `directory` for include files\")\n</pre> <p> the output will be </p> <pre data-language=\"go\">-I directory\n\tsearch directory for include files.\n</pre> <h2 id=\"Set\">func Set  </h2> <pre data-language=\"go\">func Set(name, value string) error</pre> <p> Set sets the value of the named command-line flag. </p> <h2 id=\"String\">func String  </h2> <pre data-language=\"go\">func String(name string, value string, usage string) *string</pre> <p> String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag. </p> <h2 id=\"StringVar\">func StringVar  </h2> <pre data-language=\"go\">func StringVar(p *string, name string, value string, usage string)</pre> <p> StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag. </p> <h2 id=\"Uint\">func Uint  </h2> <pre data-language=\"go\">func Uint(name string, value uint, usage string) *uint</pre> <p> Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag. </p> <h2 id=\"Uint64\">func Uint64  </h2> <pre data-language=\"go\">func Uint64(name string, value uint64, usage string) *uint64</pre> <p> Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag. </p> <h2 id=\"Uint64Var\">func Uint64Var  </h2> <pre data-language=\"go\">func Uint64Var(p *uint64, name string, value uint64, usage string)</pre> <p> Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag. </p> <h2 id=\"UintVar\">func UintVar  </h2> <pre data-language=\"go\">func UintVar(p *uint, name string, value uint, usage string)</pre> <p> UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag. </p> <h2 id=\"UnquoteUsage\">func UnquoteUsage  </h2> <pre data-language=\"go\">func UnquoteUsage(flag *Flag) (name string, usage string)</pre> <p> UnquoteUsage extracts a back-quoted name from the usage string for a flag and returns it and the un-quoted usage. Given \"a `name` to show\" it returns (\"name\", \"a name to show\"). If there are no back quotes, the name is an educated guess of the type of the flag's value, or the empty string if the flag is boolean. </p> <h2 id=\"Var\">func Var  </h2> <pre data-language=\"go\">func Var(value Value, name string, usage string)</pre> <p> Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type Value, which typically holds a user-defined implementation of Value. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of Value; in particular, Set would decompose the comma-separated string into the slice. </p> <h2 id=\"Visit\">func Visit  </h2> <pre data-language=\"go\">func Visit(fn func(*Flag))</pre> <p> Visit visits the command-line flags in lexicographical order, calling fn for each. It visits only those flags that have been set. </p> <h2 id=\"VisitAll\">func VisitAll  </h2> <pre data-language=\"go\">func VisitAll(fn func(*Flag))</pre> <p> VisitAll visits the command-line flags in lexicographical order, calling fn for each. It visits all flags, even those not set. </p> <h2 id=\"ErrorHandling\">type ErrorHandling  </h2> <pre data-language=\"go\">type ErrorHandling int</pre> <p> ErrorHandling defines how FlagSet.Parse behaves if the parse fails. </p> <pre data-language=\"go\">const (\n        ContinueOnError ErrorHandling = iota // Return a descriptive error.\n        ExitOnError                          // Call os.Exit(2).\n        PanicOnError                         // Call panic with a descriptive error.\n)</pre> <p> These constants cause FlagSet.Parse to behave as described if the parse fails. </p> <h2 id=\"Flag\">type Flag  </h2> <pre data-language=\"go\">type Flag struct {\n        Name     string // name as it appears on command line\n        Usage    string // help message\n        Value    Value  // value as set\n        DefValue string // default value (as text); for usage message\n}</pre> <p> A Flag represents the state of a flag. </p> <h3 id=\"Lookup\">func <a href=\"https://golang.org/src/flag/flag.go?s=9645:9675#L344\">Lookup</a>  </h3> <pre data-language=\"go\">func Lookup(name string) *Flag</pre> <p> Lookup returns the Flag structure of the named command-line flag, returning nil if none exists. </p> <h2 id=\"FlagSet\">type FlagSet  </h2> <pre data-language=\"go\">type FlagSet struct {\n        // Usage is the function called when an error occurs while parsing flags.\n        // The field is a function (not a method) that may be changed to point to\n        // a custom error handler.\n        Usage func()\n        // contains filtered or unexported fields\n}</pre> <p> A FlagSet represents a set of defined flags. The zero value of a FlagSet has no name and has ContinueOnError error handling. </p> <h3 id=\"NewFlagSet\">func <a href=\"https://golang.org/src/flag/flag.go?s=31687:31753#L948\">NewFlagSet</a>  </h3> <pre data-language=\"go\">func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet</pre> <p> NewFlagSet returns a new, empty flag set with the specified name and error handling property. </p> <h3 id=\"FlagSet.Arg\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=15420:15455#L525\">Arg</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Arg(i int) string</pre> <p> Arg returns the i'th argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist. </p> <h3 id=\"FlagSet.Args\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=16074:16107#L546\">Args</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Args() []string</pre> <p> Args returns the non-flag arguments. </p> <h3 id=\"FlagSet.Bool\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=16984:17051#L565\">Bool</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Bool(name string, value bool, usage string) *bool</pre> <p> Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag. </p> <h3 id=\"FlagSet.BoolVar\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=16400:16473#L553\">BoolVar</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) BoolVar(p *bool, name string, value bool, usage string)</pre> <p> BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag. </p> <h3 id=\"FlagSet.Duration\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=25651:25740#L750\">Duration</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time.Duration</pre> <p> Duration defines a time.Duration flag with specified name, default value, and usage string. The return value is the address of a time.Duration variable that stores the value of the flag. The flag accepts a value acceptable to time.ParseDuration. </p> <h3 id=\"FlagSet.DurationVar\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=24847:24942#L736\">DurationVar</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) DurationVar(p *time.Duration, name string, value time.Duration, usage string)</pre> <p> DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration. </p> <h3 id=\"FlagSet.Float64\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=24148:24224#L721\">Float64</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Float64(name string, value float64, usage string) *float64</pre> <p> Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag. </p> <h3 id=\"FlagSet.Float64Var\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=23522:23604#L709\">Float64Var</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Float64Var(p *float64, name string, value float64, usage string)</pre> <p> Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag. </p> <h3 id=\"FlagSet.Init\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=32010:32074#L959\">Init</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Init(name string, errorHandling ErrorHandling)</pre> <p> Init sets the name and error handling property for a flag set. By default, the zero FlagSet uses an empty name and the ContinueOnError error handling policy. </p> <h3 id=\"FlagSet.Int\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=18136:18200#L591\">Int</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Int(name string, value int, usage string) *int</pre> <p> Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag. </p> <h3 id=\"FlagSet.Int64\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=19312:19382#L617\">Int64</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Int64(name string, value int64, usage string) *int64</pre> <p> Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag. </p> <h3 id=\"FlagSet.Int64Var\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=18710:18786#L605\">Int64Var</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Int64Var(p *int64, name string, value int64, usage string)</pre> <p> Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag. </p> <h3 id=\"FlagSet.IntVar\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=17562:17632#L579\">IntVar</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) IntVar(p *int, name string, value int, usage string)</pre> <p> IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag. </p> <h3 id=\"FlagSet.Lookup\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=9471:9514#L338\">Lookup</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Lookup(name string) *Flag</pre> <p> Lookup returns the Flag structure of the named flag, returning nil if none exists. </p> <h3 id=\"FlagSet.NArg\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=15853:15881#L540\">NArg</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) NArg() int</pre> <p> NArg is the number of arguments remaining after flags have been processed. </p> <h3 id=\"FlagSet.NFlag\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=15060:15089#L517\">NFlag</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) NFlag() int</pre> <p> NFlag returns the number of flags that have been set. </p> <h3 id=\"FlagSet.Parse\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=30528:30577#L901\">Parse</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Parse(arguments []string) error</pre> <p> Parse parses flag definitions from the argument list, which should not include the command name. Must be called after all flags in the FlagSet are defined and before flags are accessed by the program. The return value will be ErrHelp if -help or -h were set but not defined. </p> <h3 id=\"FlagSet.Parsed\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=30918:30949#L925\">Parsed</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Parsed() bool</pre> <p> Parsed reports whether f.Parse has been called. </p> <h3 id=\"FlagSet.PrintDefaults\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=12198:12231#L440\">PrintDefaults</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) PrintDefaults()</pre> <p> PrintDefaults prints to standard error the default values of all defined command-line flags in the set. See the documentation for the global function PrintDefaults for more information. </p> <h3 id=\"FlagSet.Set\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=9755:9802#L349\">Set</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Set(name, value string) error</pre> <p> Set sets the value of the named flag. </p> <h3 id=\"FlagSet.SetOutput\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=8478:8523#L305\">SetOutput</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) SetOutput(output io.Writer)</pre> <p> SetOutput sets the destination for usage and error messages. If output is nil, os.Stderr is used. </p> <h3 id=\"FlagSet.String\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=22910:22983#L695\">String</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) String(name string, value string, usage string) *string</pre> <p> String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag. </p> <h3 id=\"FlagSet.StringVar\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=22298:22377#L683\">StringVar</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) StringVar(p *string, name string, value string, usage string)</pre> <p> StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag. </p> <h3 id=\"FlagSet.Uint\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=20491:20558#L643\">Uint</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Uint(name string, value uint, usage string) *uint</pre> <p> Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag. </p> <h3 id=\"FlagSet.Uint64\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=21689:21762#L669\">Uint64</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Uint64(name string, value uint64, usage string) *uint64</pre> <p> Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag. </p> <h3 id=\"FlagSet.Uint64Var\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=21077:21156#L657\">Uint64Var</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Uint64Var(p *uint64, name string, value uint64, usage string)</pre> <p> Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag. </p> <h3 id=\"FlagSet.UintVar\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=19905:19978#L631\">UintVar</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) UintVar(p *uint, name string, value uint, usage string)</pre> <p> UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag. </p> <h3 id=\"FlagSet.Var\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=26656:26717#L769\">Var</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Var(value Value, name string, usage string)</pre> <p> Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type Value, which typically holds a user-defined implementation of Value. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of Value; in particular, Set would decompose the comma-separated string into the slice. </p> <h3 id=\"FlagSet.Visit\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=9091:9130#L325\">Visit</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) Visit(fn func(*Flag))</pre> <p> Visit visits the flags in lexicographical order, calling fn for each. It visits only those flags that have been set. </p> <h3 id=\"FlagSet.VisitAll\">func (*FlagSet) <a href=\"https://golang.org/src/flag/flag.go?s=8668:8710#L311\">VisitAll</a>  </h3> <pre data-language=\"go\">func (f *FlagSet) VisitAll(fn func(*Flag))</pre> <p> VisitAll visits the flags in lexicographical order, calling fn for each. It visits all flags, even those not set. </p> <h2 id=\"Getter\">type Getter  </h2> <pre data-language=\"go\">type Getter interface {\n        Value\n        Get() interface{}\n}</pre> <p> Getter is an interface that allows the contents of a Value to be retrieved. It wraps the Value interface, rather than being part of it, because it appeared after Go 1 and its compatibility rules. All Value types provided by this package satisfy the Getter interface. </p> <h2 id=\"Value\">type Value  </h2> <pre data-language=\"go\">type Value interface {\n        String() string\n        Set(string) error\n}</pre> <p> Value is the interface to the dynamic value stored in a flag. (The default value is represented as a string.) </p> <p> If a Value has an IsBoolFlag() bool method returning true, the command-line parser makes -name equivalent to -name=true rather than using the next command-line argument. </p> <p> Set is called once, in command line order, for each flag present. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/flag/\" class=\"_attribution-link\">https://golang.org/pkg/flag/</a>\n  </p>\n</div>\n","io/ioutil/index":"<h1>Package ioutil</h1>     <ul id=\"short-nav\">\n<li><code>import \"io/ioutil\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package ioutil implements some I/O utility functions. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#NopCloser\">func NopCloser(r io.Reader) io.ReadCloser</a></li>\n<li><a href=\"#ReadAll\">func ReadAll(r io.Reader) ([]byte, error)</a></li>\n<li><a href=\"#ReadDir\">func ReadDir(dirname string) ([]os.FileInfo, error)</a></li>\n<li><a href=\"#ReadFile\">func ReadFile(filename string) ([]byte, error)</a></li>\n<li><a href=\"#TempDir\">func TempDir(dir, prefix string) (name string, err error)</a></li>\n<li><a href=\"#TempFile\">func TempFile(dir, prefix string) (f *os.File, err error)</a></li>\n<li><a href=\"#WriteFile\">func WriteFile(filename string, data []byte, perm os.FileMode) error</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_ReadAll\">ReadAll</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ReadDir\">ReadDir</a></dd> <dd><a class=\"exampleLink\" href=\"#example_TempDir\">TempDir</a></dd> <dd><a class=\"exampleLink\" href=\"#example_TempFile\">TempFile</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/io/ioutil/ioutil.go\">ioutil.go</a> <a href=\"https://golang.org/src/io/ioutil/tempfile.go\">tempfile.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var Discard io.Writer = devNull(0)</pre> <p> Discard is an io.Writer on which all Write calls succeed without doing anything. </p> <h2 id=\"NopCloser\">func NopCloser  </h2> <pre data-language=\"go\">func NopCloser(r io.Reader) io.ReadCloser</pre> <p> NopCloser returns a ReadCloser with a no-op Close method wrapping the provided Reader r. </p> <h2 id=\"ReadAll\">func ReadAll  </h2> <pre data-language=\"go\">func ReadAll(r io.Reader) ([]byte, error)</pre> <p> ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported. </p> <div id=\"example_ReadAll\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"Go is a general-purpose language designed with systems programming in mind.\")\n\n\tb, err := ioutil.ReadAll(r)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"%s\", b)\n\n}\n</pre> </div> </div> <h2 id=\"ReadDir\">func ReadDir  </h2> <pre data-language=\"go\">func ReadDir(dirname string) ([]os.FileInfo, error)</pre> <p> ReadDir reads the directory named by dirname and returns a list of directory entries sorted by filename. </p> <div id=\"example_ReadDir\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\nfunc main() {\n\tfiles, err := ioutil.ReadDir(\".\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, file := range files {\n\t\tfmt.Println(file.Name())\n\t}\n}\n</pre> </div> </div> <h2 id=\"ReadFile\">func ReadFile  </h2> <pre data-language=\"go\">func ReadFile(filename string) ([]byte, error)</pre> <p> ReadFile reads the file named by filename and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported. </p> <h2 id=\"TempDir\">func TempDir  </h2> <pre data-language=\"go\">func TempDir(dir, prefix string) (name string, err error)</pre> <p> TempDir creates a new temporary directory in the directory dir with a name beginning with prefix and returns the path of the new directory. If dir is the empty string, TempDir uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempDir simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when no longer needed. </p> <div id=\"example_TempDir\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\tcontent := []byte(\"temporary file's content\")\n\tdir, err := ioutil.TempDir(\"\", \"example\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdefer os.RemoveAll(dir) // clean up\n\n\ttmpfn := filepath.Join(dir, \"tmpfile\")\n\tif err := ioutil.WriteFile(tmpfn, content, 0666); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n</pre> </div> </div> <h2 id=\"TempFile\">func TempFile  </h2> <pre data-language=\"go\">func TempFile(dir, prefix string) (f *os.File, err error)</pre> <p> TempFile creates a new temporary file in the directory dir with a name beginning with prefix, opens the file for reading and writing, and returns the resulting *os.File. If dir is the empty string, TempFile uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempFile simultaneously will not choose the same file. The caller can use f.Name() to find the pathname of the file. It is the caller's responsibility to remove the file when no longer needed. </p> <div id=\"example_TempFile\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tcontent := []byte(\"temporary file's content\")\n\ttmpfile, err := ioutil.TempFile(\"\", \"example\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdefer os.Remove(tmpfile.Name()) // clean up\n\n\tif _, err := tmpfile.Write(content); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := tmpfile.Close(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n</pre> </div> </div> <h2 id=\"WriteFile\">func WriteFile  </h2> <pre data-language=\"go\">func WriteFile(filename string, data []byte, perm os.FileMode) error</pre> <p> WriteFile writes data to a file named by filename. If the file does not exist, WriteFile creates it with permissions perm; otherwise WriteFile truncates it before writing. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/io/ioutil/\" class=\"_attribution-link\">https://golang.org/pkg/io/ioutil/</a>\n  </p>\n</div>\n","image/color/index":"<h1>Package color</h1>     <ul id=\"short-nav\">\n<li><code>import \"image/color\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package color implements a basic color library. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#CMYKToRGB\">func CMYKToRGB(c, m, y, k uint8) (uint8, uint8, uint8)</a></li>\n<li><a href=\"#RGBToCMYK\">func RGBToCMYK(r, g, b uint8) (uint8, uint8, uint8, uint8)</a></li>\n<li><a href=\"#RGBToYCbCr\">func RGBToYCbCr(r, g, b uint8) (uint8, uint8, uint8)</a></li>\n<li><a href=\"#YCbCrToRGB\">func YCbCrToRGB(y, cb, cr uint8) (uint8, uint8, uint8)</a></li>\n<li><a href=\"#Alpha\">type Alpha</a></li>\n<li> <a href=\"#Alpha.RGBA\">func (c Alpha) RGBA() (r, g, b, a uint32)</a>\n</li>\n<li><a href=\"#Alpha16\">type Alpha16</a></li>\n<li> <a href=\"#Alpha16.RGBA\">func (c Alpha16) RGBA() (r, g, b, a uint32)</a>\n</li>\n<li><a href=\"#CMYK\">type CMYK</a></li>\n<li> <a href=\"#CMYK.RGBA\">func (c CMYK) RGBA() (uint32, uint32, uint32, uint32)</a>\n</li>\n<li><a href=\"#Color\">type Color</a></li>\n<li><a href=\"#Gray\">type Gray</a></li>\n<li> <a href=\"#Gray.RGBA\">func (c Gray) RGBA() (r, g, b, a uint32)</a>\n</li>\n<li><a href=\"#Gray16\">type Gray16</a></li>\n<li> <a href=\"#Gray16.RGBA\">func (c Gray16) RGBA() (r, g, b, a uint32)</a>\n</li>\n<li><a href=\"#Model\">type Model</a></li>\n<li> <a href=\"#ModelFunc\">func ModelFunc(f func(Color) Color) Model</a>\n</li>\n<li><a href=\"#NRGBA\">type NRGBA</a></li>\n<li> <a href=\"#NRGBA.RGBA\">func (c NRGBA) RGBA() (r, g, b, a uint32)</a>\n</li>\n<li><a href=\"#NRGBA64\">type NRGBA64</a></li>\n<li> <a href=\"#NRGBA64.RGBA\">func (c NRGBA64) RGBA() (r, g, b, a uint32)</a>\n</li>\n<li><a href=\"#NYCbCrA\">type NYCbCrA</a></li>\n<li> <a href=\"#NYCbCrA.RGBA\">func (c NYCbCrA) RGBA() (uint32, uint32, uint32, uint32)</a>\n</li>\n<li><a href=\"#Palette\">type Palette</a></li>\n<li> <a href=\"#Palette.Convert\">func (p Palette) Convert(c Color) Color</a>\n</li>\n<li> <a href=\"#Palette.Index\">func (p Palette) Index(c Color) int</a>\n</li>\n<li><a href=\"#RGBA\">type RGBA</a></li>\n<li> <a href=\"#RGBA.RGBA\">func (c RGBA) RGBA() (r, g, b, a uint32)</a>\n</li>\n<li><a href=\"#RGBA64\">type RGBA64</a></li>\n<li> <a href=\"#RGBA64.RGBA\">func (c RGBA64) RGBA() (r, g, b, a uint32)</a>\n</li>\n<li><a href=\"#YCbCr\">type YCbCr</a></li>\n<li> <a href=\"#YCbCr.RGBA\">func (c YCbCr) RGBA() (uint32, uint32, uint32, uint32)</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/image/color/color.go\">color.go</a> <a href=\"https://golang.org/src/image/color/ycbcr.go\">ycbcr.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        Black       = Gray16{0}\n        White       = Gray16{0xffff}\n        Transparent = Alpha16{0}\n        Opaque      = Alpha16{0xffff}\n)</pre> <p> Standard colors. </p> <h2 id=\"CMYKToRGB\">func CMYKToRGB  </h2> <pre data-language=\"go\">func CMYKToRGB(c, m, y, k uint8) (uint8, uint8, uint8)</pre> <p> CMYKToRGB converts a CMYK quadruple to an RGB triple. </p> <h2 id=\"RGBToCMYK\">func RGBToCMYK  </h2> <pre data-language=\"go\">func RGBToCMYK(r, g, b uint8) (uint8, uint8, uint8, uint8)</pre> <p> RGBToCMYK converts an RGB triple to a CMYK quadruple. </p> <h2 id=\"RGBToYCbCr\">func RGBToYCbCr  </h2> <pre data-language=\"go\">func RGBToYCbCr(r, g, b uint8) (uint8, uint8, uint8)</pre> <p> RGBToYCbCr converts an RGB triple to a Y'CbCr triple. </p> <h2 id=\"YCbCrToRGB\">func YCbCrToRGB  </h2> <pre data-language=\"go\">func YCbCrToRGB(y, cb, cr uint8) (uint8, uint8, uint8)</pre> <p> YCbCrToRGB converts a Y'CbCr triple to an RGB triple. </p> <h2 id=\"Alpha\">type Alpha  </h2> <pre data-language=\"go\">type Alpha struct {\n        A uint8\n}</pre> <p> Alpha represents an 8-bit alpha color. </p> <h3 id=\"Alpha.RGBA\">func (Alpha) <a href=\"https://golang.org/src/image/color/color.go?s=2394:2435#L93\">RGBA</a>  </h3> <pre data-language=\"go\">func (c Alpha) RGBA() (r, g, b, a uint32)</pre> <h2 id=\"Alpha16\">type Alpha16  </h2> <pre data-language=\"go\">type Alpha16 struct {\n        A uint16\n}</pre> <p> Alpha16 represents a 16-bit alpha color. </p> <h3 id=\"Alpha16.RGBA\">func (Alpha16) <a href=\"https://golang.org/src/image/color/color.go?s=2569:2612#L104\">RGBA</a>  </h3> <pre data-language=\"go\">func (c Alpha16) RGBA() (r, g, b, a uint32)</pre> <h2 id=\"CMYK\">type CMYK  </h2> <pre data-language=\"go\">type CMYK struct {\n        C, M, Y, K uint8\n}</pre> <p> CMYK represents a fully opaque CMYK color, having 8 bits for each of cyan, magenta, yellow and black. </p> <p> It is not associated with any particular color profile. </p> <h3 id=\"CMYK.RGBA\">func (CMYK) <a href=\"https://golang.org/src/image/color/ycbcr.go?s=7054:7107#L258\">RGBA</a>  </h3> <pre data-language=\"go\">func (c CMYK) RGBA() (uint32, uint32, uint32, uint32)</pre> <h2 id=\"Color\">type Color  </h2> <pre data-language=\"go\">type Color interface {\n        // RGBA returns the alpha-premultiplied red, green, blue and alpha values\n        // for the color. Each value ranges within [0, 0xffff], but is represented\n        // by a uint32 so that multiplying by a blend factor up to 0xffff will not\n        // overflow.\n        //\n        // An alpha-premultiplied color component c has been scaled by alpha (a),\n        // so has valid values 0 &lt;= c &lt;= a.\n        RGBA() (r, g, b, a uint32)\n}</pre> <p> Color can convert itself to alpha-premultiplied 16-bits per channel RGBA. The conversion may be lossy. </p> <h2 id=\"Gray\">type Gray  </h2> <pre data-language=\"go\">type Gray struct {\n        Y uint8\n}</pre> <p> Gray represents an 8-bit grayscale color. </p> <h3 id=\"Gray.RGBA\">func (Gray) <a href=\"https://golang.org/src/image/color/color.go?s=2730:2770#L114\">RGBA</a>  </h3> <pre data-language=\"go\">func (c Gray) RGBA() (r, g, b, a uint32)</pre> <h2 id=\"Gray16\">type Gray16  </h2> <pre data-language=\"go\">type Gray16 struct {\n        Y uint16\n}</pre> <p> Gray16 represents a 16-bit grayscale color. </p> <h3 id=\"Gray16.RGBA\">func (Gray16) <a href=\"https://golang.org/src/image/color/color.go?s=2912:2954#L125\">RGBA</a>  </h3> <pre data-language=\"go\">func (c Gray16) RGBA() (r, g, b, a uint32)</pre> <h2 id=\"Model\">type Model  </h2> <pre data-language=\"go\">type Model interface {\n        Convert(c Color) Color\n}</pre> <p> Model can convert any Color to one from its own color model. The conversion may be lossy. </p> <pre data-language=\"go\">var (\n        RGBAModel    Model = ModelFunc(rgbaModel)\n        RGBA64Model  Model = ModelFunc(rgba64Model)\n        NRGBAModel   Model = ModelFunc(nrgbaModel)\n        NRGBA64Model Model = ModelFunc(nrgba64Model)\n        AlphaModel   Model = ModelFunc(alphaModel)\n        Alpha16Model Model = ModelFunc(alpha16Model)\n        GrayModel    Model = ModelFunc(grayModel)\n        Gray16Model  Model = ModelFunc(gray16Model)\n)</pre> <p> Models for the standard color types. </p> <pre data-language=\"go\">var CMYKModel Model = ModelFunc(cmykModel)</pre> <p> CMYKModel is the Model for CMYK colors. </p> <pre data-language=\"go\">var NYCbCrAModel Model = ModelFunc(nYCbCrAModel)</pre> <p> NYCbCrAModel is the Model for non-alpha-premultiplied Y'CbCr-with-alpha colors. </p> <pre data-language=\"go\">var YCbCrModel Model = ModelFunc(yCbCrModel)</pre> <p> YCbCrModel is the Model for Y'CbCr colors. </p> <h3 id=\"ModelFunc\">func <a href=\"https://golang.org/src/image/color/color.go?s=3221:3262#L137\">ModelFunc</a>  </h3> <pre data-language=\"go\">func ModelFunc(f func(Color) Color) Model</pre> <p> ModelFunc returns a Model that invokes f to implement the conversion. </p> <h2 id=\"NRGBA\">type NRGBA  </h2> <pre data-language=\"go\">type NRGBA struct {\n        R, G, B, A uint8\n}</pre> <p> NRGBA represents a non-alpha-premultiplied 32-bit color. </p> <h3 id=\"NRGBA.RGBA\">func (NRGBA) <a href=\"https://golang.org/src/image/color/color.go?s=1676:1717#L50\">RGBA</a>  </h3> <pre data-language=\"go\">func (c NRGBA) RGBA() (r, g, b, a uint32)</pre> <h2 id=\"NRGBA64\">type NRGBA64  </h2> <pre data-language=\"go\">type NRGBA64 struct {\n        R, G, B, A uint16\n}</pre> <p> NRGBA64 represents a non-alpha-premultiplied 64-bit color, having 16 bits for each of red, green, blue and alpha. </p> <h3 id=\"NRGBA64.RGBA\">func (NRGBA64) <a href=\"https://golang.org/src/image/color/color.go?s=2102:2145#L74\">RGBA</a>  </h3> <pre data-language=\"go\">func (c NRGBA64) RGBA() (r, g, b, a uint32)</pre> <h2 id=\"NYCbCrA\">type NYCbCrA  </h2> <pre data-language=\"go\">type NYCbCrA struct {\n        YCbCr\n        A uint8\n}</pre> <p> NYCbCrA represents a non-alpha-premultiplied Y'CbCr-with-alpha color, having 8 bits each for one luma, two chroma and one alpha component. </p> <h3 id=\"NYCbCrA.RGBA\">func (NYCbCrA) <a href=\"https://golang.org/src/image/color/ycbcr.go?s=4866:4922#L167\">RGBA</a>  </h3> <pre data-language=\"go\">func (c NYCbCrA) RGBA() (uint32, uint32, uint32, uint32)</pre> <h2 id=\"Palette\">type Palette  </h2> <pre data-language=\"go\">type Palette []Color</pre> <p> Palette is a palette of colors. </p> <h3 id=\"Palette.Convert\">func (Palette) <a href=\"https://golang.org/src/image/color/color.go?s=6048:6087#L256\">Convert</a>  </h3> <pre data-language=\"go\">func (p Palette) Convert(c Color) Color</pre> <p> Convert returns the palette color closest to c in Euclidean R,G,B space. </p> <h3 id=\"Palette.Index\">func (Palette) <a href=\"https://golang.org/src/image/color/color.go?s=6241:6276#L265\">Index</a>  </h3> <pre data-language=\"go\">func (p Palette) Index(c Color) int</pre> <p> Index returns the index of the palette color closest to c in Euclidean R,G,B,A space. </p> <h2 id=\"RGBA\">type RGBA  </h2> <pre data-language=\"go\">type RGBA struct {\n        R, G, B, A uint8\n}</pre> <p> RGBA represents a traditional 32-bit alpha-premultiplied color, having 8 bits for each of red, green, blue and alpha. </p> <p> An alpha-premultiplied color component C has been scaled by alpha (A), so has valid values 0 &lt;= C &lt;= A. </p> <h3 id=\"RGBA.RGBA\">func (RGBA) <a href=\"https://golang.org/src/image/color/color.go?s=1023:1063#L20\">RGBA</a>  </h3> <pre data-language=\"go\">func (c RGBA) RGBA() (r, g, b, a uint32)</pre> <h2 id=\"RGBA64\">type RGBA64  </h2> <pre data-language=\"go\">type RGBA64 struct {\n        R, G, B, A uint16\n}</pre> <p> RGBA64 represents a 64-bit alpha-premultiplied color, having 16 bits for each of red, green, blue and alpha. </p> <p> An alpha-premultiplied color component C has been scaled by alpha (A), so has valid values 0 &lt;= C &lt;= A. </p> <h3 id=\"RGBA64.RGBA\">func (RGBA64) <a href=\"https://golang.org/src/image/color/color.go?s=1468:1510#L41\">RGBA</a>  </h3> <pre data-language=\"go\">func (c RGBA64) RGBA() (r, g, b, a uint32)</pre> <h2 id=\"YCbCr\">type YCbCr  </h2> <pre data-language=\"go\">type YCbCr struct {\n        Y, Cb, Cr uint8\n}</pre> <p> YCbCr represents a fully opaque 24-bit Y'CbCr color, having 8 bits each for one luma and two chroma components. </p> <p> JPEG, VP8, the MPEG family and other codecs use this color model. Such codecs often use the terms YUV and Y'CbCr interchangeably, but strictly speaking, the term YUV applies only to analog video signals, and Y' (luma) is Y (luminance) after applying gamma correction. </p> <p> Conversion between RGB and Y'CbCr is lossy and there are multiple, slightly different formulae for converting between the two. This package follows the JFIF specification at <a href=\"http://www.w3.org/Graphics/JPEG/jfif3.pdf\">http://www.w3.org/Graphics/JPEG/jfif3.pdf</a>. </p> <h3 id=\"YCbCr.RGBA\">func (YCbCr) <a href=\"https://golang.org/src/image/color/ycbcr.go?s=3163:3217#L106\">RGBA</a>  </h3> <pre data-language=\"go\">func (c YCbCr) RGBA() (uint32, uint32, uint32, uint32)</pre> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"palette/index\">palette</a> </td> <td class=\"pkg-synopsis\"> Package palette provides standard color palettes. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/image/color/\" class=\"_attribution-link\">https://golang.org/pkg/image/color/</a>\n  </p>\n</div>\n","log/syslog/index":"<h1>Package syslog</h1>     <ul id=\"short-nav\">\n<li><code>import \"log/syslog\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package syslog provides a simple interface to the system log service. It can send messages to the syslog daemon using UNIX domain sockets, UDP or TCP. </p> <p> Only one call to Dial is necessary. On write failures, the syslog client will attempt to reconnect to the server and write again. </p> <p> The syslog package is frozen and not accepting new features. Some external packages provide more functionality. See: </p> <pre data-language=\"go\">https://godoc.org/?q=syslog\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#NewLogger\">func NewLogger(p Priority, logFlag int) (*log.Logger, error)</a></li>\n<li><a href=\"#Priority\">type Priority</a></li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#Dial\">func Dial(network, raddr string, priority Priority, tag string) (*Writer, error)</a>\n</li>\n<li> <a href=\"#New\">func New(priority Priority, tag string) (*Writer, error)</a>\n</li>\n<li> <a href=\"#Writer.Alert\">func (w *Writer) Alert(m string) error</a>\n</li>\n<li> <a href=\"#Writer.Close\">func (w *Writer) Close() error</a>\n</li>\n<li> <a href=\"#Writer.Crit\">func (w *Writer) Crit(m string) error</a>\n</li>\n<li> <a href=\"#Writer.Debug\">func (w *Writer) Debug(m string) error</a>\n</li>\n<li> <a href=\"#Writer.Emerg\">func (w *Writer) Emerg(m string) error</a>\n</li>\n<li> <a href=\"#Writer.Err\">func (w *Writer) Err(m string) error</a>\n</li>\n<li> <a href=\"#Writer.Info\">func (w *Writer) Info(m string) error</a>\n</li>\n<li> <a href=\"#Writer.Notice\">func (w *Writer) Notice(m string) error</a>\n</li>\n<li> <a href=\"#Writer.Warning\">func (w *Writer) Warning(m string) error</a>\n</li>\n<li> <a href=\"#Writer.Write\">func (w *Writer) Write(b []byte) (int, error)</a>\n</li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/log/syslog/doc.go\">doc.go</a> <a href=\"https://golang.org/src/log/syslog/syslog.go\">syslog.go</a> <a href=\"https://golang.org/src/log/syslog/syslog_unix.go\">syslog_unix.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"NewLogger\">func NewLogger  </h2> <pre data-language=\"go\">func NewLogger(p Priority, logFlag int) (*log.Logger, error)</pre> <p> NewLogger creates a log.Logger whose output is written to the system log service with the specified priority. The logFlag argument is the flag set passed through to log.New to create the Logger. </p> <h2 id=\"Priority\">type Priority  </h2> <pre data-language=\"go\">type Priority int</pre> <p> The Priority is a combination of the syslog facility and severity. For example, LOG_ALERT | LOG_FTP sends an alert severity message from the FTP facility. The default severity is LOG_EMERG; the default facility is LOG_KERN. </p> <pre data-language=\"go\">const (\n\n        // From /usr/include/sys/syslog.h.\n        // These are the same on Linux, BSD, and OS X.\n        LOG_EMERG Priority = iota\n        LOG_ALERT\n        LOG_CRIT\n        LOG_ERR\n        LOG_WARNING\n        LOG_NOTICE\n        LOG_INFO\n        LOG_DEBUG\n)</pre> <pre data-language=\"go\">const (\n\n        // From /usr/include/sys/syslog.h.\n        // These are the same up to LOG_FTP on Linux, BSD, and OS X.\n        LOG_KERN Priority = iota &lt;&lt; 3\n        LOG_USER\n        LOG_MAIL\n        LOG_DAEMON\n        LOG_AUTH\n        LOG_SYSLOG\n        LOG_LPR\n        LOG_NEWS\n        LOG_UUCP\n        LOG_CRON\n        LOG_AUTHPRIV\n        LOG_FTP\n\n        LOG_LOCAL0\n        LOG_LOCAL1\n        LOG_LOCAL2\n        LOG_LOCAL3\n        LOG_LOCAL4\n        LOG_LOCAL5\n        LOG_LOCAL6\n        LOG_LOCAL7\n)</pre> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Writer is a connection to a syslog server. </p> <h3 id=\"Dial\">func <a href=\"https://golang.org/src/log/syslog/syslog.go?s=2495:2575#L105\">Dial</a>  </h3> <pre data-language=\"go\">func Dial(network, raddr string, priority Priority, tag string) (*Writer, error)</pre> <p> Dial establishes a connection to a log daemon by connecting to address raddr on the specified network. Each write to the returned writer sends a log message with the given facility, severity and tag. If network is empty, Dial will connect to the local syslog server. </p> <h3 id=\"New\">func <a href=\"https://golang.org/src/log/syslog/syslog.go?s=2115:2171#L96\">New</a>  </h3> <pre data-language=\"go\">func New(priority Priority, tag string) (*Writer, error)</pre> <p> New establishes a new connection to the system log daemon. Each write to the returned writer sends a log message with the given priority and prefix. </p> <h3 id=\"Writer.Alert\">func (*Writer) <a href=\"https://golang.org/src/log/syslog/syslog.go?s=4184:4222#L187\">Alert</a>  </h3> <pre data-language=\"go\">func (w *Writer) Alert(m string) error</pre> <p> Alert logs a message with severity LOG_ALERT, ignoring the severity passed to New. </p> <h3 id=\"Writer.Close\">func (*Writer) <a href=\"https://golang.org/src/log/syslog/syslog.go?s=3751:3781#L166\">Close</a>  </h3> <pre data-language=\"go\">func (w *Writer) Close() error</pre> <p> Close closes a connection to the syslog daemon. </p> <h3 id=\"Writer.Crit\">func (*Writer) <a href=\"https://golang.org/src/log/syslog/syslog.go?s=4368:4405#L194\">Crit</a>  </h3> <pre data-language=\"go\">func (w *Writer) Crit(m string) error</pre> <p> Crit logs a message with severity LOG_CRIT, ignoring the severity passed to New. </p> <h3 id=\"Writer.Debug\">func (*Writer) <a href=\"https://golang.org/src/log/syslog/syslog.go?s=5296:5334#L229\">Debug</a>  </h3> <pre data-language=\"go\">func (w *Writer) Debug(m string) error</pre> <p> Debug logs a message with severity LOG_DEBUG, ignoring the severity passed to New. </p> <h3 id=\"Writer.Emerg\">func (*Writer) <a href=\"https://golang.org/src/log/syslog/syslog.go?s=3998:4036#L180\">Emerg</a>  </h3> <pre data-language=\"go\">func (w *Writer) Emerg(m string) error</pre> <p> Emerg logs a message with severity LOG_EMERG, ignoring the severity passed to New. </p> <h3 id=\"Writer.Err\">func (*Writer) <a href=\"https://golang.org/src/log/syslog/syslog.go?s=4548:4584#L201\">Err</a>  </h3> <pre data-language=\"go\">func (w *Writer) Err(m string) error</pre> <p> Err logs a message with severity LOG_ERR, ignoring the severity passed to New. </p> <h3 id=\"Writer.Info\">func (*Writer) <a href=\"https://golang.org/src/log/syslog/syslog.go?s=5112:5149#L222\">Info</a>  </h3> <pre data-language=\"go\">func (w *Writer) Info(m string) error</pre> <p> Info logs a message with severity LOG_INFO, ignoring the severity passed to New. </p> <h3 id=\"Writer.Notice\">func (*Writer) <a href=\"https://golang.org/src/log/syslog/syslog.go?s=4926:4965#L215\">Notice</a>  </h3> <pre data-language=\"go\">func (w *Writer) Notice(m string) error</pre> <p> Notice logs a message with severity LOG_NOTICE, ignoring the severity passed to New. </p> <h3 id=\"Writer.Warning\">func (*Writer) <a href=\"https://golang.org/src/log/syslog/syslog.go?s=4734:4774#L208\">Warning</a>  </h3> <pre data-language=\"go\">func (w *Writer) Warning(m string) error</pre> <p> Warning logs a message with severity LOG_WARNING, ignoring the severity passed to New. </p> <h3 id=\"Writer.Write\">func (*Writer) <a href=\"https://golang.org/src/log/syslog/syslog.go?s=3602:3647#L161\">Write</a>  </h3> <pre data-language=\"go\">func (w *Writer) Write(b []byte) (int, error)</pre> <p> Write sends a log message to the syslog daemon. </p> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/log/syslog/doc.go?s=640:873#L9\" style=\"float: left;\">☞</a> <p> This package is not implemented on Windows. As the syslog package is frozen, Windows users are encouraged to use a package outside of the standard library. For background, see <a href=\"https://golang.org/issue/1108\">https://golang.org/issue/1108</a>. </p> </li> <li>\n<a href=\"https://golang.org/src/log/syslog/doc.go?s=875:933#L14\" style=\"float: left;\">☞</a> <p> This package is not implemented on Plan 9. </p> </li> <li>\n<a href=\"https://golang.org/src/log/syslog/doc.go?s=935:1006#L16\" style=\"float: left;\">☞</a> <p> This package is not implemented on NaCl (Native Client). </p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/log/syslog/\" class=\"_attribution-link\">https://golang.org/pkg/log/syslog/</a>\n  </p>\n</div>\n","mime/quotedprintable/index":"<h1>Package quotedprintable</h1>     <ul id=\"short-nav\">\n<li><code>import \"mime/quotedprintable\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package quotedprintable implements quoted-printable encoding as specified by RFC 2045. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Reader\">type Reader</a></li>\n<li> <a href=\"#NewReader\">func NewReader(r io.Reader) *Reader</a>\n</li>\n<li> <a href=\"#Reader.Read\">func (r *Reader) Read(p []byte) (n int, err error)</a>\n</li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#NewWriter\">func NewWriter(w io.Writer) *Writer</a>\n</li>\n<li> <a href=\"#Writer.Close\">func (w *Writer) Close() error</a>\n</li>\n<li> <a href=\"#Writer.Write\">func (w *Writer) Write(p []byte) (n int, err error)</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/mime/quotedprintable/reader.go\">reader.go</a> <a href=\"https://golang.org/src/mime/quotedprintable/writer.go\">writer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader struct {\n        // contains filtered or unexported fields\n}</pre> <p> Reader is a quoted-printable decoder. </p> <h3 id=\"NewReader\">func <a href=\"https://golang.org/src/mime/quotedprintable/reader.go?s=552:587#L14\">NewReader</a>  </h3> <pre data-language=\"go\">func NewReader(r io.Reader) *Reader</pre> <p> NewReader returns a quoted-printable reader, decoding from r. </p> <h3 id=\"Reader.Read\">func (*Reader) <a href=\"https://golang.org/src/mime/quotedprintable/reader.go?s=1504:1554#L62\">Read</a>  </h3> <pre data-language=\"go\">func (r *Reader) Read(p []byte) (n int, err error)</pre> <p> Read reads and decodes quoted-printable data from the underlying reader. </p> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer struct {\n        // Binary mode treats the writer's input as pure binary and processes end of\n        // line bytes as binary data.\n        Binary bool\n        // contains filtered or unexported fields\n}</pre> <p> A Writer is a quoted-printable writer that implements io.WriteCloser. </p> <h3 id=\"NewWriter\">func <a href=\"https://golang.org/src/mime/quotedprintable/writer.go?s=545:580#L14\">NewWriter</a>  </h3> <pre data-language=\"go\">func NewWriter(w io.Writer) *Writer</pre> <p> NewWriter returns a new Writer that writes to w. </p> <h3 id=\"Writer.Close\">func (*Writer) <a href=\"https://golang.org/src/mime/quotedprintable/writer.go?s=1499:1529#L57\">Close</a>  </h3> <pre data-language=\"go\">func (w *Writer) Close() error</pre> <p> Close closes the Writer, flushing any unwritten data to the underlying io.Writer, but does not close the underlying io.Writer. </p> <h3 id=\"Writer.Write\">func (*Writer) <a href=\"https://golang.org/src/mime/quotedprintable/writer.go?s=822:873#L21\">Write</a>  </h3> <pre data-language=\"go\">func (w *Writer) Write(p []byte) (n int, err error)</pre> <p> Write encodes p using quoted-printable encoding and writes it to the underlying io.Writer. It limits line length to 76 characters. The encoded bytes are not necessarily flushed until the Writer is closed. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/mime/quotedprintable/\" class=\"_attribution-link\">https://golang.org/pkg/mime/quotedprintable/</a>\n  </p>\n</div>\n","math/cmplx/index":"<h1>Package cmplx</h1>     <ul id=\"short-nav\">\n<li><code>import \"math/cmplx\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package cmplx provides basic constants and mathematical functions for complex numbers. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Abs\">func Abs(x complex128) float64</a></li>\n<li><a href=\"#Acos\">func Acos(x complex128) complex128</a></li>\n<li><a href=\"#Acosh\">func Acosh(x complex128) complex128</a></li>\n<li><a href=\"#Asin\">func Asin(x complex128) complex128</a></li>\n<li><a href=\"#Asinh\">func Asinh(x complex128) complex128</a></li>\n<li><a href=\"#Atan\">func Atan(x complex128) complex128</a></li>\n<li><a href=\"#Atanh\">func Atanh(x complex128) complex128</a></li>\n<li><a href=\"#Conj\">func Conj(x complex128) complex128</a></li>\n<li><a href=\"#Cos\">func Cos(x complex128) complex128</a></li>\n<li><a href=\"#Cosh\">func Cosh(x complex128) complex128</a></li>\n<li><a href=\"#Cot\">func Cot(x complex128) complex128</a></li>\n<li><a href=\"#Exp\">func Exp(x complex128) complex128</a></li>\n<li><a href=\"#Inf\">func Inf() complex128</a></li>\n<li><a href=\"#IsInf\">func IsInf(x complex128) bool</a></li>\n<li><a href=\"#IsNaN\">func IsNaN(x complex128) bool</a></li>\n<li><a href=\"#Log\">func Log(x complex128) complex128</a></li>\n<li><a href=\"#Log10\">func Log10(x complex128) complex128</a></li>\n<li><a href=\"#NaN\">func NaN() complex128</a></li>\n<li><a href=\"#Phase\">func Phase(x complex128) float64</a></li>\n<li><a href=\"#Polar\">func Polar(x complex128) (r, θ float64)</a></li>\n<li><a href=\"#Pow\">func Pow(x, y complex128) complex128</a></li>\n<li><a href=\"#Rect\">func Rect(r, θ float64) complex128</a></li>\n<li><a href=\"#Sin\">func Sin(x complex128) complex128</a></li>\n<li><a href=\"#Sinh\">func Sinh(x complex128) complex128</a></li>\n<li><a href=\"#Sqrt\">func Sqrt(x complex128) complex128</a></li>\n<li><a href=\"#Tan\">func Tan(x complex128) complex128</a></li>\n<li><a href=\"#Tanh\">func Tanh(x complex128) complex128</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/math/cmplx/abs.go\">abs.go</a> <a href=\"https://golang.org/src/math/cmplx/asin.go\">asin.go</a> <a href=\"https://golang.org/src/math/cmplx/conj.go\">conj.go</a> <a href=\"https://golang.org/src/math/cmplx/exp.go\">exp.go</a> <a href=\"https://golang.org/src/math/cmplx/isinf.go\">isinf.go</a> <a href=\"https://golang.org/src/math/cmplx/isnan.go\">isnan.go</a> <a href=\"https://golang.org/src/math/cmplx/log.go\">log.go</a> <a href=\"https://golang.org/src/math/cmplx/phase.go\">phase.go</a> <a href=\"https://golang.org/src/math/cmplx/polar.go\">polar.go</a> <a href=\"https://golang.org/src/math/cmplx/pow.go\">pow.go</a> <a href=\"https://golang.org/src/math/cmplx/rect.go\">rect.go</a> <a href=\"https://golang.org/src/math/cmplx/sin.go\">sin.go</a> <a href=\"https://golang.org/src/math/cmplx/sqrt.go\">sqrt.go</a> <a href=\"https://golang.org/src/math/cmplx/tan.go\">tan.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Abs\">func Abs  </h2> <pre data-language=\"go\">func Abs(x complex128) float64</pre> <p> Abs returns the absolute value (also called the modulus) of x. </p> <h2 id=\"Acos\">func Acos  </h2> <pre data-language=\"go\">func Acos(x complex128) complex128</pre> <p> Acos returns the inverse cosine of x. </p> <h2 id=\"Acosh\">func Acosh  </h2> <pre data-language=\"go\">func Acosh(x complex128) complex128</pre> <p> Acosh returns the inverse hyperbolic cosine of x. </p> <h2 id=\"Asin\">func Asin  </h2> <pre data-language=\"go\">func Asin(x complex128) complex128</pre> <p> Asin returns the inverse sine of x. </p> <h2 id=\"Asinh\">func Asinh  </h2> <pre data-language=\"go\">func Asinh(x complex128) complex128</pre> <p> Asinh returns the inverse hyperbolic sine of x. </p> <h2 id=\"Atan\">func Atan  </h2> <pre data-language=\"go\">func Atan(x complex128) complex128</pre> <p> Atan returns the inverse tangent of x. </p> <h2 id=\"Atanh\">func Atanh  </h2> <pre data-language=\"go\">func Atanh(x complex128) complex128</pre> <p> Atanh returns the inverse hyperbolic tangent of x. </p> <h2 id=\"Conj\">func Conj  </h2> <pre data-language=\"go\">func Conj(x complex128) complex128</pre> <p> Conj returns the complex conjugate of x. </p> <h2 id=\"Cos\">func Cos  </h2> <pre data-language=\"go\">func Cos(x complex128) complex128</pre> <p> Cos returns the cosine of x. </p> <h2 id=\"Cosh\">func Cosh  </h2> <pre data-language=\"go\">func Cosh(x complex128) complex128</pre> <p> Cosh returns the hyperbolic cosine of x. </p> <h2 id=\"Cot\">func Cot  </h2> <pre data-language=\"go\">func Cot(x complex128) complex128</pre> <p> Cot returns the cotangent of x. </p> <h2 id=\"Exp\">func Exp  </h2> <pre data-language=\"go\">func Exp(x complex128) complex128</pre> <p> Exp returns e**x, the base-e exponential of x. </p> <h2 id=\"Inf\">func Inf  </h2> <pre data-language=\"go\">func Inf() complex128</pre> <p> Inf returns a complex infinity, complex(+Inf, +Inf). </p> <h2 id=\"IsInf\">func IsInf  </h2> <pre data-language=\"go\">func IsInf(x complex128) bool</pre> <p> IsInf returns true if either real(x) or imag(x) is an infinity. </p> <h2 id=\"IsNaN\">func IsNaN  </h2> <pre data-language=\"go\">func IsNaN(x complex128) bool</pre> <p> IsNaN returns true if either real(x) or imag(x) is NaN and neither is an infinity. </p> <h2 id=\"Log\">func Log  </h2> <pre data-language=\"go\">func Log(x complex128) complex128</pre> <p> Log returns the natural logarithm of x. </p> <h2 id=\"Log10\">func Log10  </h2> <pre data-language=\"go\">func Log10(x complex128) complex128</pre> <p> Log10 returns the decimal logarithm of x. </p> <h2 id=\"NaN\">func NaN  </h2> <pre data-language=\"go\">func NaN() complex128</pre> <p> NaN returns a complex “not-a-number” value. </p> <h2 id=\"Phase\">func Phase  </h2> <pre data-language=\"go\">func Phase(x complex128) float64</pre> <p> Phase returns the phase (also called the argument) of x. The returned value is in the range [-Pi, Pi]. </p> <h2 id=\"Polar\">func Polar  </h2> <pre data-language=\"go\">func Polar(x complex128) (r, θ float64)</pre> <p> Polar returns the absolute value r and phase θ of x, such that x = r * e**θi. The phase is in the range [-Pi, Pi]. </p> <h2 id=\"Pow\">func Pow  </h2> <pre data-language=\"go\">func Pow(x, y complex128) complex128</pre> <p> Pow returns x**y, the base-x exponential of y. For generalized compatibility with math.Pow: </p> <pre data-language=\"go\">Pow(0, ±0) returns 1+0i\nPow(0, c) for real(c)&lt;0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i.\n</pre> <h2 id=\"Rect\">func Rect  </h2> <pre data-language=\"go\">func Rect(r, θ float64) complex128</pre> <p> Rect returns the complex number x with polar coordinates r, θ. </p> <h2 id=\"Sin\">func Sin  </h2> <pre data-language=\"go\">func Sin(x complex128) complex128</pre> <p> Sin returns the sine of x. </p> <h2 id=\"Sinh\">func Sinh  </h2> <pre data-language=\"go\">func Sinh(x complex128) complex128</pre> <p> Sinh returns the hyperbolic sine of x. </p> <h2 id=\"Sqrt\">func Sqrt  </h2> <pre data-language=\"go\">func Sqrt(x complex128) complex128</pre> <p> Sqrt returns the square root of x. The result r is chosen so that real(r) ≥ 0 and imag(r) has the same sign as imag(x). </p> <h2 id=\"Tan\">func Tan  </h2> <pre data-language=\"go\">func Tan(x complex128) complex128</pre> <p> Tan returns the tangent of x. </p> <h2 id=\"Tanh\">func Tanh  </h2> <pre data-language=\"go\">func Tanh(x complex128) complex128</pre> <p> Tanh returns the hyperbolic tangent of x. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/math/cmplx/\" class=\"_attribution-link\">https://golang.org/pkg/math/cmplx/</a>\n  </p>\n</div>\n","log/index":"<h1>Package log</h1>     <ul id=\"short-nav\">\n<li><code>import \"log\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package log implements a simple logging package. It defines a type, Logger, with methods for formatting output. It also has a predefined 'standard' Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and Panic[f|ln], which are easier to use than creating a Logger manually. That logger writes to standard error and prints the date and time of each logged message. The Fatal functions call os.Exit(1) after writing the log message. The Panic functions call panic after writing the log message. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#Fatal\">func Fatal(v ...interface{})</a></li>\n<li><a href=\"#Fatalf\">func Fatalf(format string, v ...interface{})</a></li>\n<li><a href=\"#Fatalln\">func Fatalln(v ...interface{})</a></li>\n<li><a href=\"#Flags\">func Flags() int</a></li>\n<li><a href=\"#Output\">func Output(calldepth int, s string) error</a></li>\n<li><a href=\"#Panic\">func Panic(v ...interface{})</a></li>\n<li><a href=\"#Panicf\">func Panicf(format string, v ...interface{})</a></li>\n<li><a href=\"#Panicln\">func Panicln(v ...interface{})</a></li>\n<li><a href=\"#Prefix\">func Prefix() string</a></li>\n<li><a href=\"#Print\">func Print(v ...interface{})</a></li>\n<li><a href=\"#Printf\">func Printf(format string, v ...interface{})</a></li>\n<li><a href=\"#Println\">func Println(v ...interface{})</a></li>\n<li><a href=\"#SetFlags\">func SetFlags(flag int)</a></li>\n<li><a href=\"#SetOutput\">func SetOutput(w io.Writer)</a></li>\n<li><a href=\"#SetPrefix\">func SetPrefix(prefix string)</a></li>\n<li><a href=\"#Logger\">type Logger</a></li>\n<li> <a href=\"#New\">func New(out io.Writer, prefix string, flag int) *Logger</a>\n</li>\n<li> <a href=\"#Logger.Fatal\">func (l *Logger) Fatal(v ...interface{})</a>\n</li>\n<li> <a href=\"#Logger.Fatalf\">func (l *Logger) Fatalf(format string, v ...interface{})</a>\n</li>\n<li> <a href=\"#Logger.Fatalln\">func (l *Logger) Fatalln(v ...interface{})</a>\n</li>\n<li> <a href=\"#Logger.Flags\">func (l *Logger) Flags() int</a>\n</li>\n<li> <a href=\"#Logger.Output\">func (l *Logger) Output(calldepth int, s string) error</a>\n</li>\n<li> <a href=\"#Logger.Panic\">func (l *Logger) Panic(v ...interface{})</a>\n</li>\n<li> <a href=\"#Logger.Panicf\">func (l *Logger) Panicf(format string, v ...interface{})</a>\n</li>\n<li> <a href=\"#Logger.Panicln\">func (l *Logger) Panicln(v ...interface{})</a>\n</li>\n<li> <a href=\"#Logger.Prefix\">func (l *Logger) Prefix() string</a>\n</li>\n<li> <a href=\"#Logger.Print\">func (l *Logger) Print(v ...interface{})</a>\n</li>\n<li> <a href=\"#Logger.Printf\">func (l *Logger) Printf(format string, v ...interface{})</a>\n</li>\n<li> <a href=\"#Logger.Println\">func (l *Logger) Println(v ...interface{})</a>\n</li>\n<li> <a href=\"#Logger.SetFlags\">func (l *Logger) SetFlags(flag int)</a>\n</li>\n<li> <a href=\"#Logger.SetOutput\">func (l *Logger) SetOutput(w io.Writer)</a>\n</li>\n<li> <a href=\"#Logger.SetPrefix\">func (l *Logger) SetPrefix(prefix string)</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Logger\">Logger</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/log/log.go\">log.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        // Bits or'ed together to control what's printed.\n        // There is no control over the order they appear (the order listed\n        // here) or the format they present (as described in the comments).\n        // The prefix is followed by a colon only when Llongfile or Lshortfile\n        // is specified.\n        // For example, flags Ldate | Ltime (or LstdFlags) produce,\n        //\t2009/01/23 01:23:23 message\n        // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,\n        //\t2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message\n        Ldate         = 1 &lt;&lt; iota     // the date in the local time zone: 2009/01/23\n        Ltime                         // the time in the local time zone: 01:23:23\n        Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.\n        Llongfile                     // full file name and line number: /a/b/c/d.go:23\n        Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile\n        LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone\n        LstdFlags     = Ldate | Ltime // initial values for the standard logger\n)</pre> <p> These flags define which text to prefix to each log entry generated by the Logger. </p> <h2 id=\"Fatal\">func Fatal  </h2> <pre data-language=\"go\">func Fatal(v ...interface{})</pre> <p> Fatal is equivalent to Print() followed by a call to os.Exit(1). </p> <h2 id=\"Fatalf\">func Fatalf  </h2> <pre data-language=\"go\">func Fatalf(format string, v ...interface{})</pre> <p> Fatalf is equivalent to Printf() followed by a call to os.Exit(1). </p> <h2 id=\"Fatalln\">func Fatalln  </h2> <pre data-language=\"go\">func Fatalln(v ...interface{})</pre> <p> Fatalln is equivalent to Println() followed by a call to os.Exit(1). </p> <h2 id=\"Flags\">func Flags  </h2> <pre data-language=\"go\">func Flags() int</pre> <p> Flags returns the output flags for the standard logger. </p> <h2 id=\"Output\">func Output  </h2> <pre data-language=\"go\">func Output(calldepth int, s string) error</pre> <p> Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is the count of the number of frames to skip when computing the file name and line number if Llongfile or Lshortfile is set; a value of 1 will print the details for the caller of Output. </p> <h2 id=\"Panic\">func Panic  </h2> <pre data-language=\"go\">func Panic(v ...interface{})</pre> <p> Panic is equivalent to Print() followed by a call to panic(). </p> <h2 id=\"Panicf\">func Panicf  </h2> <pre data-language=\"go\">func Panicf(format string, v ...interface{})</pre> <p> Panicf is equivalent to Printf() followed by a call to panic(). </p> <h2 id=\"Panicln\">func Panicln  </h2> <pre data-language=\"go\">func Panicln(v ...interface{})</pre> <p> Panicln is equivalent to Println() followed by a call to panic(). </p> <h2 id=\"Prefix\">func Prefix  </h2> <pre data-language=\"go\">func Prefix() string</pre> <p> Prefix returns the output prefix for the standard logger. </p> <h2 id=\"Print\">func Print  </h2> <pre data-language=\"go\">func Print(v ...interface{})</pre> <p> Print calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Print. </p> <h2 id=\"Printf\">func Printf  </h2> <pre data-language=\"go\">func Printf(format string, v ...interface{})</pre> <p> Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf. </p> <h2 id=\"Println\">func Println  </h2> <pre data-language=\"go\">func Println(v ...interface{})</pre> <p> Println calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Println. </p> <h2 id=\"SetFlags\">func SetFlags  </h2> <pre data-language=\"go\">func SetFlags(flag int)</pre> <p> SetFlags sets the output flags for the standard logger. </p> <h2 id=\"SetOutput\">func SetOutput  </h2> <pre data-language=\"go\">func SetOutput(w io.Writer)</pre> <p> SetOutput sets the output destination for the standard logger. </p> <h2 id=\"SetPrefix\">func SetPrefix  </h2> <pre data-language=\"go\">func SetPrefix(prefix string)</pre> <p> SetPrefix sets the output prefix for the standard logger. </p> <h2 id=\"Logger\">type Logger  </h2> <pre data-language=\"go\">type Logger struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Logger represents an active logging object that generates lines of output to an io.Writer. Each logging operation makes a single call to the Writer's Write method. A Logger can be used simultaneously from multiple goroutines; it guarantees to serialize access to the Writer. </p> <div id=\"example_Logger\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n)\n\nfunc main() {\n\tvar buf bytes.Buffer\n\tlogger := log.New(&amp;buf, \"logger: \", log.Lshortfile)\n\tlogger.Print(\"Hello, log file!\")\n\n\tfmt.Print(&amp;buf)\n}\n</pre> </div> </div> <h3 id=\"New\">func <a href=\"https://golang.org/src/log/log.go?s=2767:2823#L50\">New</a>  </h3> <pre data-language=\"go\">func New(out io.Writer, prefix string, flag int) *Logger</pre> <p> New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line. The flag argument defines the logging properties. </p> <h3 id=\"Logger.Fatal\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=6138:6178#L175\">Fatal</a>  </h3> <pre data-language=\"go\">func (l *Logger) Fatal(v ...interface{})</pre> <p> Fatal is equivalent to l.Print() followed by a call to os.Exit(1). </p> <h3 id=\"Logger.Fatalf\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=6299:6355#L181\">Fatalf</a>  </h3> <pre data-language=\"go\">func (l *Logger) Fatalf(format string, v ...interface{})</pre> <p> Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1). </p> <h3 id=\"Logger.Fatalln\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=6487:6529#L187\">Fatalln</a>  </h3> <pre data-language=\"go\">func (l *Logger) Fatalln(v ...interface{})</pre> <p> Fatalln is equivalent to l.Println() followed by a call to os.Exit(1). </p> <h3 id=\"Logger.Flags\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=7151:7179#L214\">Flags</a>  </h3> <pre data-language=\"go\">func (l *Logger) Flags() int</pre> <p> Flags returns the output flags for the logger. </p> <h3 id=\"Logger.Output\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=4892:4946#L133\">Output</a>  </h3> <pre data-language=\"go\">func (l *Logger) Output(calldepth int, s string) error</pre> <p> Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is used to recover the PC and is provided for generality, although at the moment on all pre-defined paths it will be 2. </p> <h3 id=\"Logger.Panic\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=6647:6687#L193\">Panic</a>  </h3> <pre data-language=\"go\">func (l *Logger) Panic(v ...interface{})</pre> <p> Panic is equivalent to l.Print() followed by a call to panic(). </p> <h3 id=\"Logger.Panicf\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=6811:6867#L200\">Panicf</a>  </h3> <pre data-language=\"go\">func (l *Logger) Panicf(format string, v ...interface{})</pre> <p> Panicf is equivalent to l.Printf() followed by a call to panic(). </p> <h3 id=\"Logger.Panicln\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=7002:7044#L207\">Panicln</a>  </h3> <pre data-language=\"go\">func (l *Logger) Panicln(v ...interface{})</pre> <p> Panicln is equivalent to l.Println() followed by a call to panic(). </p> <h3 id=\"Logger.Prefix\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=7426:7458#L228\">Prefix</a>  </h3> <pre data-language=\"go\">func (l *Logger) Prefix() string</pre> <p> Prefix returns the output prefix for the logger. </p> <h3 id=\"Logger.Print\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=5807:5847#L168\">Print</a>  </h3> <pre data-language=\"go\">func (l *Logger) Print(v ...interface{})</pre> <p> Print calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Print. </p> <h3 id=\"Logger.Printf\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=5604:5660#L162\">Printf</a>  </h3> <pre data-language=\"go\">func (l *Logger) Printf(format string, v ...interface{})</pre> <p> Printf calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Printf. </p> <h3 id=\"Logger.Println\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=5988:6030#L172\">Println</a>  </h3> <pre data-language=\"go\">func (l *Logger) Println(v ...interface{})</pre> <p> Println calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Println. </p> <h3 id=\"Logger.SetFlags\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=7284:7319#L221\">SetFlags</a>  </h3> <pre data-language=\"go\">func (l *Logger) SetFlags(flag int)</pre> <p> SetFlags sets the output flags for the logger. </p> <h3 id=\"Logger.SetOutput\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=2940:2979#L55\">SetOutput</a>  </h3> <pre data-language=\"go\">func (l *Logger) SetOutput(w io.Writer)</pre> <p> SetOutput sets the output destination for the logger. </p> <h3 id=\"Logger.SetPrefix\">func (*Logger) <a href=\"https://golang.org/src/log/log.go?s=7567:7608#L235\">SetPrefix</a>  </h3> <pre data-language=\"go\">func (l *Logger) SetPrefix(prefix string)</pre> <p> SetPrefix sets the output prefix for the logger. </p> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"syslog/index\">syslog</a> </td> <td class=\"pkg-synopsis\"> Package syslog provides a simple interface to the system log service. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/log/\" class=\"_attribution-link\">https://golang.org/pkg/log/</a>\n  </p>\n</div>\n","net/http/cgi/index":"<h1>Package cgi</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/http/cgi\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875. </p> <p> Note that using CGI means starting a new process to handle each request, which is typically less efficient than using a long-running server. This package is intended primarily for compatibility with existing systems. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Request\">func Request() (*http.Request, error)</a></li>\n<li><a href=\"#RequestFromMap\">func RequestFromMap(params map[string]string) (*http.Request, error)</a></li>\n<li><a href=\"#Serve\">func Serve(handler http.Handler) error</a></li>\n<li><a href=\"#Handler\">type Handler</a></li>\n<li> <a href=\"#Handler.ServeHTTP\">func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request)</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/http/cgi/child.go\">child.go</a> <a href=\"https://golang.org/src/net/http/cgi/host.go\">host.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Request\">func Request  </h2> <pre data-language=\"go\">func Request() (*http.Request, error)</pre> <p> Request returns the HTTP request as represented in the current environment. This assumes the current program is being run by a web server in a CGI environment. The returned Request's Body is populated, if applicable. </p> <h2 id=\"RequestFromMap\">func RequestFromMap  </h2> <pre data-language=\"go\">func RequestFromMap(params map[string]string) (*http.Request, error)</pre> <p> RequestFromMap creates an http.Request from CGI variables. The returned Request's Body field is not populated. </p> <h2 id=\"Serve\">func Serve  </h2> <pre data-language=\"go\">func Serve(handler http.Handler) error</pre> <p> Serve executes the provided Handler on the currently active CGI request, if any. If there's no current CGI environment an error is returned. The provided handler may be nil to use http.DefaultServeMux. </p> <h2 id=\"Handler\">type Handler  </h2> <pre data-language=\"go\">type Handler struct {\n        Path string // path to the CGI executable\n        Root string // root URI prefix of handler or empty for \"/\"\n\n        // Dir specifies the CGI executable's working directory.\n        // If Dir is empty, the base directory of Path is used.\n        // If Path has no base directory, the current working\n        // directory is used.\n        Dir string\n\n        Env        []string    // extra environment variables to set, if any, as \"key=value\"\n        InheritEnv []string    // environment variables to inherit from host, as \"key\"\n        Logger     *log.Logger // optional log for errors or nil to use log.Print\n        Args       []string    // optional arguments to pass to child process\n        Stderr     io.Writer   // optional stderr for the child process; nil means os.Stderr\n\n        // PathLocationHandler specifies the root http Handler that\n        // should handle internal redirects when the CGI process\n        // returns a Location header value starting with a \"/\", as\n        // specified in RFC 3875 § 6.3.2. This will likely be\n        // http.DefaultServeMux.\n        //\n        // If nil, a CGI response with a local URI path is instead sent\n        // back to the client and not redirected internally.\n        PathLocationHandler http.Handler\n}</pre> <p> Handler runs an executable in a subprocess with a CGI environment. </p> <h3 id=\"Handler.ServeHTTP\">func (*Handler) <a href=\"https://golang.org/src/net/http/cgi/host.go?s=3102:3172#L96\">ServeHTTP</a>  </h3> <pre data-language=\"go\">func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request)</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/http/cgi/\" class=\"_attribution-link\">https://golang.org/pkg/net/http/cgi/</a>\n  </p>\n</div>\n","mime/index":"<h1>Package mime</h1>     <ul id=\"short-nav\">\n<li><code>import \"mime\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package mime implements parts of the MIME spec. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#AddExtensionType\">func AddExtensionType(ext, typ string) error</a></li>\n<li><a href=\"#ExtensionsByType\">func ExtensionsByType(typ string) ([]string, error)</a></li>\n<li><a href=\"#FormatMediaType\">func FormatMediaType(t string, param map[string]string) string</a></li>\n<li><a href=\"#ParseMediaType\">func ParseMediaType(v string) (mediatype string, params map[string]string, err error)</a></li>\n<li><a href=\"#TypeByExtension\">func TypeByExtension(ext string) string</a></li>\n<li><a href=\"#WordDecoder\">type WordDecoder</a></li>\n<li> <a href=\"#WordDecoder.Decode\">func (d *WordDecoder) Decode(word string) (string, error)</a>\n</li>\n<li> <a href=\"#WordDecoder.DecodeHeader\">func (d *WordDecoder) DecodeHeader(header string) (string, error)</a>\n</li>\n<li><a href=\"#WordEncoder\">type WordEncoder</a></li>\n<li> <a href=\"#WordEncoder.Encode\">func (e WordEncoder) Encode(charset, s string) string</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_WordDecoder_Decode\">WordDecoder.Decode</a></dd> <dd><a class=\"exampleLink\" href=\"#example_WordDecoder_DecodeHeader\">WordDecoder.DecodeHeader</a></dd> <dd><a class=\"exampleLink\" href=\"#example_WordEncoder_Encode\">WordEncoder.Encode</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/mime/encodedword.go\">encodedword.go</a> <a href=\"https://golang.org/src/mime/grammar.go\">grammar.go</a> <a href=\"https://golang.org/src/mime/mediatype.go\">mediatype.go</a> <a href=\"https://golang.org/src/mime/type.go\">type.go</a> <a href=\"https://golang.org/src/mime/type_unix.go\">type_unix.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        // BEncoding represents Base64 encoding scheme as defined by RFC 2045.\n        BEncoding = WordEncoder('b')\n        // QEncoding represents the Q-encoding scheme as defined by RFC 2047.\n        QEncoding = WordEncoder('q')\n)</pre> <h2 id=\"AddExtensionType\">func AddExtensionType  </h2> <pre data-language=\"go\">func AddExtensionType(ext, typ string) error</pre> <p> AddExtensionType sets the MIME type associated with the extension ext to typ. The extension should begin with a leading dot, as in \".html\". </p> <h2 id=\"ExtensionsByType\">func ExtensionsByType  </h2> <pre data-language=\"go\">func ExtensionsByType(typ string) ([]string, error)</pre> <p> ExtensionsByType returns the extensions known to be associated with the MIME type typ. The returned extensions will each begin with a leading dot, as in \".html\". When typ has no associated extensions, ExtensionsByType returns an nil slice. </p> <h2 id=\"FormatMediaType\">func FormatMediaType  </h2> <pre data-language=\"go\">func FormatMediaType(t string, param map[string]string) string</pre> <p> FormatMediaType serializes mediatype t and the parameters param as a media type conforming to RFC 2045 and RFC 2616. The type and parameter names are written in lower-case. When any of the arguments result in a standard violation then FormatMediaType returns the empty string. </p> <h2 id=\"ParseMediaType\">func ParseMediaType  </h2> <pre data-language=\"go\">func ParseMediaType(v string) (mediatype string, params map[string]string, err error)</pre> <p> ParseMediaType parses a media type value and any optional parameters, per RFC 1521. Media types are the values in Content-Type and Content-Disposition headers (RFC 2183). On success, ParseMediaType returns the media type converted to lowercase and trimmed of white space and a non-nil map. The returned map, params, maps from the lowercase attribute to the attribute value with its case preserved. </p> <h2 id=\"TypeByExtension\">func TypeByExtension  </h2> <pre data-language=\"go\">func TypeByExtension(ext string) string</pre> <p> TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in \".html\". When ext has no associated type, TypeByExtension returns \"\". </p> <p> Extensions are looked up first case-sensitively, then case-insensitively. </p> <p> The built-in table is small but on unix it is augmented by the local system's mime.types file(s) if available under one or more of these names: </p> <pre data-language=\"go\">/etc/mime.types\n/etc/apache2/mime.types\n/etc/apache/mime.types\n</pre> <p> On Windows, MIME types are extracted from the registry. </p> <p> Text types have the charset parameter set to \"utf-8\" by default. </p> <h2 id=\"WordDecoder\">type WordDecoder  </h2> <pre data-language=\"go\">type WordDecoder struct {\n        // CharsetReader, if non-nil, defines a function to generate\n        // charset-conversion readers, converting from the provided\n        // charset into UTF-8.\n        // Charsets are always lower-case. utf-8, iso-8859-1 and us-ascii charsets\n        // are handled by default.\n        // One of the the CharsetReader's result values must be non-nil.\n        CharsetReader func(charset string, input io.Reader) (io.Reader, error)\n}</pre> <p> A WordDecoder decodes MIME headers containing RFC 2047 encoded-words. </p> <h3 id=\"WordDecoder.Decode\">func (*WordDecoder) <a href=\"https://golang.org/src/mime/encodedword.go?s=5105:5162#L186\">Decode</a>  </h3> <pre data-language=\"go\">func (d *WordDecoder) Decode(word string) (string, error)</pre> <p> Decode decodes an RFC 2047 encoded-word. </p> <div id=\"example_WordDecoder_Decode\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime\"\n)\n\nfunc main() {\n\tdec := new(mime.WordDecoder)\n\theader, err := dec.Decode(\"=?utf-8?q?=C2=A1Hola,_se=C3=B1or!?=\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(header)\n\n\tdec.CharsetReader = func(charset string, input io.Reader) (io.Reader, error) {\n\t\tswitch charset {\n\t\tcase \"x-case\":\n\t\t\t// Fake character set for example.\n\t\t\t// Real use would integrate with packages such\n\t\t\t// as code.google.com/p/go-charset\n\t\t\tcontent, err := ioutil.ReadAll(input)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn bytes.NewReader(bytes.ToUpper(content)), nil\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unhandled charset %q\", charset)\n\t\t}\n\t}\n\theader, err = dec.Decode(\"=?x-case?q?hello!?=\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(header)\n}\n</pre> </div> </div> <h3 id=\"WordDecoder.DecodeHeader\">func (*WordDecoder) <a href=\"https://golang.org/src/mime/encodedword.go?s=6021:6086#L221\">DecodeHeader</a>  </h3> <pre data-language=\"go\">func (d *WordDecoder) DecodeHeader(header string) (string, error)</pre> <p> DecodeHeader decodes all encoded-words of the given string. It returns an error if and only if CharsetReader of d returns an error. </p> <div id=\"example_WordDecoder_DecodeHeader\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime\"\n)\n\nfunc main() {\n\tdec := new(mime.WordDecoder)\n\theader, err := dec.DecodeHeader(\"=?utf-8?q?=C3=89ric?= &lt;eric@example.org&gt;, =?utf-8?q?Ana=C3=AFs?= &lt;anais@example.org&gt;\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(header)\n\n\theader, err = dec.DecodeHeader(\"=?utf-8?q?=C2=A1Hola,?= =?utf-8?q?_se=C3=B1or!?=\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(header)\n\n\tdec.CharsetReader = func(charset string, input io.Reader) (io.Reader, error) {\n\t\tswitch charset {\n\t\tcase \"x-case\":\n\t\t\t// Fake character set for example.\n\t\t\t// Real use would integrate with packages such\n\t\t\t// as code.google.com/p/go-charset\n\t\t\tcontent, err := ioutil.ReadAll(input)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn bytes.NewReader(bytes.ToUpper(content)), nil\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unhandled charset %q\", charset)\n\t\t}\n\t}\n\theader, err = dec.DecodeHeader(\"=?x-case?q?hello_?= =?x-case?q?world!?=\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(header)\n}\n</pre> </div> </div> <h2 id=\"WordEncoder\">type WordEncoder  </h2> <pre data-language=\"go\">type WordEncoder byte</pre> <p> A WordEncoder is an RFC 2047 encoded-word encoder. </p> <h3 id=\"WordEncoder.Encode\">func (WordEncoder) <a href=\"https://golang.org/src/mime/encodedword.go?s=847:900#L26\">Encode</a>  </h3> <pre data-language=\"go\">func (e WordEncoder) Encode(charset, s string) string</pre> <p> Encode returns the encoded-word form of s. If s is ASCII without special characters, it is returned unchanged. The provided charset is the IANA charset name of s. It is case insensitive. </p> <div id=\"example_WordEncoder_Encode\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"mime\"\n)\n\nfunc main() {\n\tfmt.Println(mime.QEncoding.Encode(\"utf-8\", \"¡Hola, señor!\"))\n\tfmt.Println(mime.QEncoding.Encode(\"utf-8\", \"Hello!\"))\n\tfmt.Println(mime.BEncoding.Encode(\"UTF-8\", \"¡Hola, señor!\"))\n\tfmt.Println(mime.QEncoding.Encode(\"ISO-8859-1\", \"Caf\\xE9\"))\n}\n</pre> </div> </div> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"multipart/index\">multipart</a> </td> <td class=\"pkg-synopsis\"> Package multipart implements MIME multipart parsing, as defined in RFC 2046. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"quotedprintable/index\">quotedprintable</a> </td> <td class=\"pkg-synopsis\"> Package quotedprintable implements quoted-printable encoding as specified by RFC 2045. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/mime/\" class=\"_attribution-link\">https://golang.org/pkg/mime/</a>\n  </p>\n</div>\n","mime/multipart/index":"<h1>Package multipart</h1>     <ul id=\"short-nav\">\n<li><code>import \"mime/multipart\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package multipart implements MIME multipart parsing, as defined in RFC 2046. </p> <p> The implementation is sufficient for HTTP (RFC 2388) and the multipart bodies generated by popular browsers. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#File\">type File</a></li>\n<li><a href=\"#FileHeader\">type FileHeader</a></li>\n<li> <a href=\"#FileHeader.Open\">func (fh *FileHeader) Open() (File, error)</a>\n</li>\n<li><a href=\"#Form\">type Form</a></li>\n<li> <a href=\"#Form.RemoveAll\">func (f *Form) RemoveAll() error</a>\n</li>\n<li><a href=\"#Part\">type Part</a></li>\n<li> <a href=\"#Part.Close\">func (p *Part) Close() error</a>\n</li>\n<li> <a href=\"#Part.FileName\">func (p *Part) FileName() string</a>\n</li>\n<li> <a href=\"#Part.FormName\">func (p *Part) FormName() string</a>\n</li>\n<li> <a href=\"#Part.Read\">func (p *Part) Read(d []byte) (n int, err error)</a>\n</li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li> <a href=\"#NewReader\">func NewReader(r io.Reader, boundary string) *Reader</a>\n</li>\n<li> <a href=\"#Reader.NextPart\">func (r *Reader) NextPart() (*Part, error)</a>\n</li>\n<li> <a href=\"#Reader.ReadForm\">func (r *Reader) ReadForm(maxMemory int64) (*Form, error)</a>\n</li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#NewWriter\">func NewWriter(w io.Writer) *Writer</a>\n</li>\n<li> <a href=\"#Writer.Boundary\">func (w *Writer) Boundary() string</a>\n</li>\n<li> <a href=\"#Writer.Close\">func (w *Writer) Close() error</a>\n</li>\n<li> <a href=\"#Writer.CreateFormField\">func (w *Writer) CreateFormField(fieldname string) (io.Writer, error)</a>\n</li>\n<li> <a href=\"#Writer.CreateFormFile\">func (w *Writer) CreateFormFile(fieldname, filename string) (io.Writer, error)</a>\n</li>\n<li> <a href=\"#Writer.CreatePart\">func (w *Writer) CreatePart(header textproto.MIMEHeader) (io.Writer, error)</a>\n</li>\n<li> <a href=\"#Writer.FormDataContentType\">func (w *Writer) FormDataContentType() string</a>\n</li>\n<li> <a href=\"#Writer.SetBoundary\">func (w *Writer) SetBoundary(boundary string) error</a>\n</li>\n<li> <a href=\"#Writer.WriteField\">func (w *Writer) WriteField(fieldname, value string) error</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_NewReader\">NewReader</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/mime/multipart/formdata.go\">formdata.go</a> <a href=\"https://golang.org/src/mime/multipart/multipart.go\">multipart.go</a> <a href=\"https://golang.org/src/mime/multipart/writer.go\">writer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"File\">type File  </h2> <pre data-language=\"go\">type File interface {\n        io.Reader\n        io.ReaderAt\n        io.Seeker\n        io.Closer\n}</pre> <p> File is an interface to access the file part of a multipart message. Its contents may be either stored in memory or on disk. If stored on disk, the File's underlying concrete type will be an *os.File. </p> <h2 id=\"FileHeader\">type FileHeader  </h2> <pre data-language=\"go\">type FileHeader struct {\n        Filename string\n        Header   textproto.MIMEHeader\n        // contains filtered or unexported fields\n}</pre> <p> A FileHeader describes a file part of a multipart request. </p> <h3 id=\"FileHeader.Open\">func (*FileHeader) <a href=\"https://golang.org/src/mime/multipart/formdata.go?s=3035:3077#L125\">Open</a>  </h3> <pre data-language=\"go\">func (fh *FileHeader) Open() (File, error)</pre> <p> Open opens and returns the FileHeader's associated File. </p> <h2 id=\"Form\">type Form  </h2> <pre data-language=\"go\">type Form struct {\n        Value map[string][]string\n        File  map[string][]*FileHeader\n}</pre> <p> Form is a parsed multipart form. Its File parts are stored either in memory or on disk, and are accessible via the *FileHeader's Open method. Its Value parts are stored as strings. Both are keyed by field name. </p> <h3 id=\"Form.RemoveAll\">func (*Form) <a href=\"https://golang.org/src/mime/multipart/formdata.go?s=2563:2595#L100\">RemoveAll</a>  </h3> <pre data-language=\"go\">func (f *Form) RemoveAll() error</pre> <p> RemoveAll removes any temporary files associated with a Form. </p> <h2 id=\"Part\">type Part  </h2> <pre data-language=\"go\">type Part struct {\n        // The headers of the body, if any, with the keys canonicalized\n        // in the same fashion that the Go http.Request headers are.\n        // For example, \"foo-bar\" changes case to \"Foo-Bar\"\n        //\n        // As a special case, if the \"Content-Transfer-Encoding\" header\n        // has a value of \"quoted-printable\", that header is instead\n        // hidden from this map and the body is transparently decoded\n        // during Read calls.\n        Header textproto.MIMEHeader\n        // contains filtered or unexported fields\n}</pre> <p> A Part represents a single part in a multipart body. </p> <h3 id=\"Part.Close\">func (*Part) <a href=\"https://golang.org/src/mime/multipart/multipart.go?s=6361:6389#L215\">Close</a>  </h3> <pre data-language=\"go\">func (p *Part) Close() error</pre> <h3 id=\"Part.FileName\">func (*Part) <a href=\"https://golang.org/src/mime/multipart/multipart.go?s=2053:2085#L64\">FileName</a>  </h3> <pre data-language=\"go\">func (p *Part) FileName() string</pre> <p> FileName returns the filename parameter of the Part's Content-Disposition header. </p> <h3 id=\"Part.FormName\">func (*Part) <a href=\"https://golang.org/src/mime/multipart/multipart.go?s=1672:1704#L50\">FormName</a>  </h3> <pre data-language=\"go\">func (p *Part) FormName() string</pre> <p> FormName returns the name parameter if p has a Content-Disposition of type \"form-data\". Otherwise it returns the empty string. </p> <h3 id=\"Part.Read\">func (*Part) <a href=\"https://golang.org/src/mime/multipart/multipart.go?s=4171:4219#L144\">Read</a>  </h3> <pre data-language=\"go\">func (p *Part) Read(d []byte) (n int, err error)</pre> <p> Read reads the body of a part, after its headers and before the next part (if any) begins. </p> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader struct {\n        // contains filtered or unexported fields\n}</pre> <p> Reader is an iterator over parts in a MIME multipart body. Reader's underlying parser consumes its input as needed. Seeking isn't supported. </p> <h3 id=\"NewReader\">func <a href=\"https://golang.org/src/mime/multipart/multipart.go?s=2677:2729#L86\">NewReader</a>  </h3> <pre data-language=\"go\">func NewReader(r io.Reader, boundary string) *Reader</pre> <p> NewReader creates a new multipart Reader reading from r using the given MIME boundary. </p> <p> The boundary is usually obtained from the \"boundary\" parameter of the message's \"Content-Type\" header. Use mime.ParseMediaType to parse such headers. </p> <div id=\"example_NewReader\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"mime\"\n\t\"mime/multipart\"\n\t\"net/mail\"\n\t\"strings\"\n)\n\nfunc main() {\n\tmsg := &amp;mail.Message{\n\t\tHeader: map[string][]string{\n\t\t\t\"Content-Type\": {\"multipart/mixed; boundary=foo\"},\n\t\t},\n\t\tBody: strings.NewReader(\n\t\t\t\"--foo\\r\\nFoo: one\\r\\n\\r\\nA section\\r\\n\" +\n\t\t\t\t\"--foo\\r\\nFoo: two\\r\\n\\r\\nAnd another\\r\\n\" +\n\t\t\t\t\"--foo--\\r\\n\"),\n\t}\n\tmediaType, params, err := mime.ParseMediaType(msg.Header.Get(\"Content-Type\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif strings.HasPrefix(mediaType, \"multipart/\") {\n\t\tmr := multipart.NewReader(msg.Body, params[\"boundary\"])\n\t\tfor {\n\t\t\tp, err := mr.NextPart()\n\t\t\tif err == io.EOF {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tslurp, err := ioutil.ReadAll(p)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tfmt.Printf(\"Part %q: %q\\n\", p.Header.Get(\"Foo\"), slurp)\n\t\t}\n\t}\n\n}\n</pre> </div> </div> <h3 id=\"Reader.NextPart\">func (*Reader) <a href=\"https://golang.org/src/mime/multipart/multipart.go?s=7011:7053#L237\">NextPart</a>  </h3> <pre data-language=\"go\">func (r *Reader) NextPart() (*Part, error)</pre> <p> NextPart returns the next part in the multipart or an error. When there are no more parts, the error io.EOF is returned. </p> <h3 id=\"Reader.ReadForm\">func (*Reader) <a href=\"https://golang.org/src/mime/multipart/formdata.go?s=592:649#L13\">ReadForm</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadForm(maxMemory int64) (*Form, error)</pre> <p> ReadForm parses an entire multipart message whose parts have a Content-Disposition of \"form-data\". It stores up to maxMemory bytes of the file parts in memory and the remainder on disk in temporary files. </p> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Writer generates multipart messages. </p> <h3 id=\"NewWriter\">func <a href=\"https://golang.org/src/mime/multipart/writer.go?s=478:513#L17\">NewWriter</a>  </h3> <pre data-language=\"go\">func NewWriter(w io.Writer) *Writer</pre> <p> NewWriter returns a new multipart Writer with a random boundary, writing to w. </p> <h3 id=\"Writer.Boundary\">func (*Writer) <a href=\"https://golang.org/src/mime/multipart/writer.go?s=627:661#L25\">Boundary</a>  </h3> <pre data-language=\"go\">func (w *Writer) Boundary() string</pre> <p> Boundary returns the Writer's boundary. </p> <h3 id=\"Writer.Close\">func (*Writer) <a href=\"https://golang.org/src/mime/multipart/writer.go?s=4094:4124#L149\">Close</a>  </h3> <pre data-language=\"go\">func (w *Writer) Close() error</pre> <p> Close finishes the multipart message and writes the trailing boundary end line to the output. </p> <h3 id=\"Writer.CreateFormField\">func (*Writer) <a href=\"https://golang.org/src/mime/multipart/writer.go?s=3517:3586#L130\">CreateFormField</a>  </h3> <pre data-language=\"go\">func (w *Writer) CreateFormField(fieldname string) (io.Writer, error)</pre> <p> CreateFormField calls CreatePart with a header using the given field name. </p> <h3 id=\"Writer.CreateFormFile\">func (*Writer) <a href=\"https://golang.org/src/mime/multipart/writer.go?s=3108:3186#L119\">CreateFormFile</a>  </h3> <pre data-language=\"go\">func (w *Writer) CreateFormFile(fieldname, filename string) (io.Writer, error)</pre> <p> CreateFormFile is a convenience wrapper around CreatePart. It creates a new form-data header with the provided field name and file name. </p> <h3 id=\"Writer.CreatePart\">func (*Writer) <a href=\"https://golang.org/src/mime/multipart/writer.go?s=2140:2215#L76\">CreatePart</a>  </h3> <pre data-language=\"go\">func (w *Writer) CreatePart(header textproto.MIMEHeader) (io.Writer, error)</pre> <p> CreatePart creates a new multipart section with the provided header. The body of the part should be written to the returned Writer. After calling CreatePart, any previous part may no longer be written to. </p> <h3 id=\"Writer.FormDataContentType\">func (*Writer) <a href=\"https://golang.org/src/mime/multipart/writer.go?s=1655:1700#L59\">FormDataContentType</a>  </h3> <pre data-language=\"go\">func (w *Writer) FormDataContentType() string</pre> <p> FormDataContentType returns the Content-Type for an HTTP multipart/form-data with this Writer's Boundary. </p> <h3 id=\"Writer.SetBoundary\">func (*Writer) <a href=\"https://golang.org/src/mime/multipart/writer.go?s=958:1009#L35\">SetBoundary</a>  </h3> <pre data-language=\"go\">func (w *Writer) SetBoundary(boundary string) error</pre> <p> SetBoundary overrides the Writer's default randomly-generated boundary separator with an explicit value. </p> <p> SetBoundary must be called before any parts are created, may only contain certain ASCII characters, and must be non-empty and at most 69 bytes long. </p> <h3 id=\"Writer.WriteField\">func (*Writer) <a href=\"https://golang.org/src/mime/multipart/writer.go?s=3812:3870#L138\">WriteField</a>  </h3> <pre data-language=\"go\">func (w *Writer) WriteField(fieldname, value string) error</pre> <p> WriteField calls CreateFormField and then writes the given value. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/mime/multipart/\" class=\"_attribution-link\">https://golang.org/pkg/mime/multipart/</a>\n  </p>\n</div>\n","math/rand/index":"<h1>Package rand</h1>     <ul id=\"short-nav\">\n<li><code>import \"math/rand\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package rand implements pseudo-random number generators. </p> <p> Random numbers are generated by a Source. Top-level functions, such as Float64 and Int, use a default shared Source that produces a deterministic sequence of values each time a program is run. Use the Seed function to initialize the default Source if different behavior is required for each run. The default Source is safe for concurrent use by multiple goroutines. </p> <p> For random numbers suitable for security-sensitive work, see the crypto/rand package. </p> </div> </div> <div id=\"example_\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n)\n\nfunc main() {\n\trand.Seed(42) // Try changing this number!\n\tanswers := []string{\n\t\t\"It is certain\",\n\t\t\"It is decidedly so\",\n\t\t\"Without a doubt\",\n\t\t\"Yes definitely\",\n\t\t\"You may rely on it\",\n\t\t\"As I see it yes\",\n\t\t\"Most likely\",\n\t\t\"Outlook good\",\n\t\t\"Yes\",\n\t\t\"Signs point to yes\",\n\t\t\"Reply hazy try again\",\n\t\t\"Ask again later\",\n\t\t\"Better not tell you now\",\n\t\t\"Cannot predict now\",\n\t\t\"Concentrate and ask again\",\n\t\t\"Don't count on it\",\n\t\t\"My reply is no\",\n\t\t\"My sources say no\",\n\t\t\"Outlook not so good\",\n\t\t\"Very doubtful\",\n\t}\n\tfmt.Println(\"Magic 8-Ball says:\", answers[rand.Intn(len(answers))])\n}\n</pre> </div> </div> <div id=\"example__rand\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Rand)</h2> <p>This example shows the use of each of the methods on a *Rand. The use of the global functions is the same, without the receiver. </p> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"text/tabwriter\"\n)\n\nfunc main() {\n\t// Create and seed the generator.\n\t// Typically a non-fixed seed should be used, such as time.Now().UnixNano().\n\t// Using a fixed seed will produce the same output on every run.\n\tr := rand.New(rand.NewSource(99))\n\n\t// The tabwriter here helps us generate aligned output.\n\tw := tabwriter.NewWriter(os.Stdout, 1, 1, 1, ' ', 0)\n\tdefer w.Flush()\n\tshow := func(name string, v1, v2, v3 interface{}) {\n\t\tfmt.Fprintf(w, \"%s\\t%v\\t%v\\t%v\\n\", name, v1, v2, v3)\n\t}\n\n\t// Float32 and Float64 values are in [0, 1).\n\tshow(\"Float32\", r.Float32(), r.Float32(), r.Float32())\n\tshow(\"Float64\", r.Float64(), r.Float64(), r.Float64())\n\n\t// ExpFloat64 values have an average of 1 but decay exponentially.\n\tshow(\"ExpFloat64\", r.ExpFloat64(), r.ExpFloat64(), r.ExpFloat64())\n\n\t// NormFloat64 values have an average of 0 and a standard deviation of 1.\n\tshow(\"NormFloat64\", r.NormFloat64(), r.NormFloat64(), r.NormFloat64())\n\n\t// Int31, Int63, and Uint32 generate values of the given width.\n\t// The Int method (not shown) is like either Int31 or Int63\n\t// depending on the size of 'int'.\n\tshow(\"Int31\", r.Int31(), r.Int31(), r.Int31())\n\tshow(\"Int63\", r.Int63(), r.Int63(), r.Int63())\n\tshow(\"Uint32\", r.Uint32(), r.Uint32(), r.Uint32())\n\n\t// Intn, Int31n, and Int63n limit their output to be &lt; n.\n\t// They do so more carefully than using r.Int()%n.\n\tshow(\"Intn(10)\", r.Intn(10), r.Intn(10), r.Intn(10))\n\tshow(\"Int31n(10)\", r.Int31n(10), r.Int31n(10), r.Int31n(10))\n\tshow(\"Int63n(10)\", r.Int63n(10), r.Int63n(10), r.Int63n(10))\n\n\t// Perm generates a random permutation of the numbers [0, n).\n\tshow(\"Perm\", r.Perm(5), r.Perm(5), r.Perm(5))\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#ExpFloat64\">func ExpFloat64() float64</a></li>\n<li><a href=\"#Float32\">func Float32() float32</a></li>\n<li><a href=\"#Float64\">func Float64() float64</a></li>\n<li><a href=\"#Int\">func Int() int</a></li>\n<li><a href=\"#Int31\">func Int31() int32</a></li>\n<li><a href=\"#Int31n\">func Int31n(n int32) int32</a></li>\n<li><a href=\"#Int63\">func Int63() int64</a></li>\n<li><a href=\"#Int63n\">func Int63n(n int64) int64</a></li>\n<li><a href=\"#Intn\">func Intn(n int) int</a></li>\n<li><a href=\"#NormFloat64\">func NormFloat64() float64</a></li>\n<li><a href=\"#Perm\">func Perm(n int) []int</a></li>\n<li><a href=\"#Read\">func Read(p []byte) (n int, err error)</a></li>\n<li><a href=\"#Seed\">func Seed(seed int64)</a></li>\n<li><a href=\"#Uint32\">func Uint32() uint32</a></li>\n<li><a href=\"#Rand\">type Rand</a></li>\n<li> <a href=\"#New\">func New(src Source) *Rand</a>\n</li>\n<li> <a href=\"#Rand.ExpFloat64\">func (r *Rand) ExpFloat64() float64</a>\n</li>\n<li> <a href=\"#Rand.Float32\">func (r *Rand) Float32() float32</a>\n</li>\n<li> <a href=\"#Rand.Float64\">func (r *Rand) Float64() float64</a>\n</li>\n<li> <a href=\"#Rand.Int\">func (r *Rand) Int() int</a>\n</li>\n<li> <a href=\"#Rand.Int31\">func (r *Rand) Int31() int32</a>\n</li>\n<li> <a href=\"#Rand.Int31n\">func (r *Rand) Int31n(n int32) int32</a>\n</li>\n<li> <a href=\"#Rand.Int63\">func (r *Rand) Int63() int64</a>\n</li>\n<li> <a href=\"#Rand.Int63n\">func (r *Rand) Int63n(n int64) int64</a>\n</li>\n<li> <a href=\"#Rand.Intn\">func (r *Rand) Intn(n int) int</a>\n</li>\n<li> <a href=\"#Rand.NormFloat64\">func (r *Rand) NormFloat64() float64</a>\n</li>\n<li> <a href=\"#Rand.Perm\">func (r *Rand) Perm(n int) []int</a>\n</li>\n<li> <a href=\"#Rand.Read\">func (r *Rand) Read(p []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#Rand.Seed\">func (r *Rand) Seed(seed int64)</a>\n</li>\n<li> <a href=\"#Rand.Uint32\">func (r *Rand) Uint32() uint32</a>\n</li>\n<li><a href=\"#Source\">type Source</a></li>\n<li> <a href=\"#NewSource\">func NewSource(seed int64) Source</a>\n</li>\n<li><a href=\"#Zipf\">type Zipf</a></li>\n<li> <a href=\"#NewZipf\">func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf</a>\n</li>\n<li> <a href=\"#Zipf.Uint64\">func (z *Zipf) Uint64() uint64</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_\">Package</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Perm\">Perm</a></dd> <dd><a class=\"exampleLink\" href=\"#example__rand\">Package (Rand)</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/math/rand/exp.go\">exp.go</a> <a href=\"https://golang.org/src/math/rand/normal.go\">normal.go</a> <a href=\"https://golang.org/src/math/rand/rand.go\">rand.go</a> <a href=\"https://golang.org/src/math/rand/rng.go\">rng.go</a> <a href=\"https://golang.org/src/math/rand/zipf.go\">zipf.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"ExpFloat64\">func ExpFloat64  </h2> <pre data-language=\"go\">func ExpFloat64() float64</pre> <p> ExpFloat64 returns an exponentially distributed float64 in the range (0, +math.MaxFloat64] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1) from the default Source. To produce a distribution with a different rate parameter, callers can adjust the output using: </p> <pre data-language=\"go\">sample = ExpFloat64() / desiredRateParameter\n</pre> <h2 id=\"Float32\">func Float32  </h2> <pre data-language=\"go\">func Float32() float32</pre> <p> Float32 returns, as a float32, a pseudo-random number in [0.0,1.0) from the default Source. </p> <h2 id=\"Float64\">func Float64  </h2> <pre data-language=\"go\">func Float64() float64</pre> <p> Float64 returns, as a float64, a pseudo-random number in [0.0,1.0) from the default Source. </p> <h2 id=\"Int\">func Int  </h2> <pre data-language=\"go\">func Int() int</pre> <p> Int returns a non-negative pseudo-random int from the default Source. </p> <h2 id=\"Int31\">func Int31  </h2> <pre data-language=\"go\">func Int31() int32</pre> <p> Int31 returns a non-negative pseudo-random 31-bit integer as an int32 from the default Source. </p> <h2 id=\"Int31n\">func Int31n  </h2> <pre data-language=\"go\">func Int31n(n int32) int32</pre> <p> Int31n returns, as an int32, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &lt;= 0. </p> <h2 id=\"Int63\">func Int63  </h2> <pre data-language=\"go\">func Int63() int64</pre> <p> Int63 returns a non-negative pseudo-random 63-bit integer as an int64 from the default Source. </p> <h2 id=\"Int63n\">func Int63n  </h2> <pre data-language=\"go\">func Int63n(n int64) int64</pre> <p> Int63n returns, as an int64, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &lt;= 0. </p> <h2 id=\"Intn\">func Intn  </h2> <pre data-language=\"go\">func Intn(n int) int</pre> <p> Intn returns, as an int, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &lt;= 0. </p> <h2 id=\"NormFloat64\">func NormFloat64  </h2> <pre data-language=\"go\">func NormFloat64() float64</pre> <p> NormFloat64 returns a normally distributed float64 in the range [-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution (mean = 0, stddev = 1) from the default Source. To produce a different normal distribution, callers can adjust the output using: </p> <pre data-language=\"go\">sample = NormFloat64() * desiredStdDev + desiredMean\n</pre> <h2 id=\"Perm\">func Perm  </h2> <pre data-language=\"go\">func Perm(n int) []int</pre> <p> Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n) from the default Source. </p> <div id=\"example_Perm\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n)\n\nfunc main() {\n\tfor _, value := range rand.Perm(3) {\n\t\tfmt.Println(value)\n\t}\n\n\t// Unordered output: 1\n\t// 2\n\t// 0\n}\n</pre> </div> </div> <h2 id=\"Read\">func Read  </h2> <pre data-language=\"go\">func Read(p []byte) (n int, err error)</pre> <p> Read generates len(p) random bytes from the default Source and writes them into p. It always returns len(p) and a nil error. Read, unlike the Rand.Read method, is safe for concurrent use. </p> <h2 id=\"Seed\">func Seed  </h2> <pre data-language=\"go\">func Seed(seed int64)</pre> <p> Seed uses the provided seed value to initialize the default Source to a deterministic state. If Seed is not called, the generator behaves as if seeded by Seed(1). Seed values that have the same remainder when divided by 2^31-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed method, is safe for concurrent use. </p> <h2 id=\"Uint32\">func Uint32  </h2> <pre data-language=\"go\">func Uint32() uint32</pre> <p> Uint32 returns a pseudo-random 32-bit value as a uint32 from the default Source. </p> <h2 id=\"Rand\">type Rand  </h2> <pre data-language=\"go\">type Rand struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Rand is a source of random numbers. </p> <h3 id=\"New\">func <a href=\"https://golang.org/src/math/rand/rand.go?s=1543:1569#L39\">New</a>  </h3> <pre data-language=\"go\">func New(src Source) *Rand</pre> <p> New returns a new Rand that uses random values from src to generate other random values. </p> <h3 id=\"Rand.ExpFloat64\">func (*Rand) <a href=\"https://golang.org/src/math/rand/exp.go?s=765:800#L21\">ExpFloat64</a>  </h3> <pre data-language=\"go\">func (r *Rand) ExpFloat64() float64</pre> <p> ExpFloat64 returns an exponentially distributed float64 in the range (0, +math.MaxFloat64] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1). To produce a distribution with a different rate parameter, callers can adjust the output using: </p> <pre data-language=\"go\">sample = ExpFloat64() / desiredRateParameter\n</pre> <h3 id=\"Rand.Float32\">func (*Rand) <a href=\"https://golang.org/src/math/rand/rand.go?s=4611:4643#L141\">Float32</a>  </h3> <pre data-language=\"go\">func (r *Rand) Float32() float32</pre> <p> Float32 returns, as a float32, a pseudo-random number in [0.0,1.0). </p> <h3 id=\"Rand.Float64\">func (*Rand) <a href=\"https://golang.org/src/math/rand/rand.go?s=3599:3631#L115\">Float64</a>  </h3> <pre data-language=\"go\">func (r *Rand) Float64() float64</pre> <p> Float64 returns, as a float64, a pseudo-random number in [0.0,1.0). </p> <h3 id=\"Rand.Int\">func (*Rand) <a href=\"https://golang.org/src/math/rand/rand.go?s=2358:2382#L63\">Int</a>  </h3> <pre data-language=\"go\">func (r *Rand) Int() int</pre> <p> Int returns a non-negative pseudo-random int. </p> <h3 id=\"Rand.Int31\">func (*Rand) <a href=\"https://golang.org/src/math/rand/rand.go?s=2245:2273#L60\">Int31</a>  </h3> <pre data-language=\"go\">func (r *Rand) Int31() int32</pre> <p> Int31 returns a non-negative pseudo-random 31-bit integer as an int32. </p> <h3 id=\"Rand.Int31n\">func (*Rand) <a href=\"https://golang.org/src/math/rand/rand.go?s=2964:3000#L87\">Int31n</a>  </h3> <pre data-language=\"go\">func (r *Rand) Int31n(n int32) int32</pre> <p> Int31n returns, as an int32, a non-negative pseudo-random number in [0,n). It panics if n &lt;= 0. </p> <h3 id=\"Rand.Int63\">func (*Rand) <a href=\"https://golang.org/src/math/rand/rand.go?s=1989:2017#L54\">Int63</a>  </h3> <pre data-language=\"go\">func (r *Rand) Int63() int64</pre> <p> Int63 returns a non-negative pseudo-random 63-bit integer as an int64. </p> <h3 id=\"Rand.Int63n\">func (*Rand) <a href=\"https://golang.org/src/math/rand/rand.go?s=2571:2607#L70\">Int63n</a>  </h3> <pre data-language=\"go\">func (r *Rand) Int63n(n int64) int64</pre> <p> Int63n returns, as an int64, a non-negative pseudo-random number in [0,n). It panics if n &lt;= 0. </p> <h3 id=\"Rand.Intn\">func (*Rand) <a href=\"https://golang.org/src/math/rand/rand.go?s=3353:3383#L104\">Intn</a>  </h3> <pre data-language=\"go\">func (r *Rand) Intn(n int) int</pre> <p> Intn returns, as an int, a non-negative pseudo-random number in [0,n). It panics if n &lt;= 0. </p> <h3 id=\"Rand.NormFloat64\">func (*Rand) <a href=\"https://golang.org/src/math/rand/normal.go?s=804:840#L28\">NormFloat64</a>  </h3> <pre data-language=\"go\">func (r *Rand) NormFloat64() float64</pre> <p> NormFloat64 returns a normally distributed float64 in the range [-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution (mean = 0, stddev = 1). To produce a different normal distribution, callers can adjust the output using: </p> <pre data-language=\"go\">sample = NormFloat64() * desiredStdDev + desiredMean\n</pre> <h3 id=\"Rand.Perm\">func (*Rand) <a href=\"https://golang.org/src/math/rand/rand.go?s=5071:5103#L154\">Perm</a>  </h3> <pre data-language=\"go\">func (r *Rand) Perm(n int) []int</pre> <p> Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n). </p> <h3 id=\"Rand.Read\">func (*Rand) <a href=\"https://golang.org/src/math/rand/rand.go?s=5715:5763#L172\">Read</a>  </h3> <pre data-language=\"go\">func (r *Rand) Read(p []byte) (n int, err error)</pre> <p> Read generates len(p) random bytes and writes them into p. It always returns len(p) and a nil error. Read should not be called concurrently with any other Rand method. </p> <h3 id=\"Rand.Seed\">func (*Rand) <a href=\"https://golang.org/src/math/rand/rand.go?s=1759:1790#L43\">Seed</a>  </h3> <pre data-language=\"go\">func (r *Rand) Seed(seed int64)</pre> <p> Seed uses the provided seed value to initialize the generator to a deterministic state. Seed should not be called concurrently with any other Rand method. </p> <h3 id=\"Rand.Uint32\">func (*Rand) <a href=\"https://golang.org/src/math/rand/rand.go?s=2104:2134#L57\">Uint32</a>  </h3> <pre data-language=\"go\">func (r *Rand) Uint32() uint32</pre> <p> Uint32 returns a pseudo-random 32-bit value as a uint32. </p> <h2 id=\"Source\">type Source  </h2> <pre data-language=\"go\">type Source interface {\n        Int63() int64\n        Seed(seed int64)\n}</pre> <p> A Source represents a source of uniformly-distributed pseudo-random int64 values in the range [0, 1&lt;&lt;63). </p> <h3 id=\"NewSource\">func <a href=\"https://golang.org/src/math/rand/rand.go?s=977:1010#L17\">NewSource</a>  </h3> <pre data-language=\"go\">func NewSource(seed int64) Source</pre> <p> NewSource returns a new pseudo-random Source seeded with the given value. </p> <h2 id=\"Zipf\">type Zipf  </h2> <pre data-language=\"go\">type Zipf struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Zipf generates Zipf distributed variates. </p> <h3 id=\"NewZipf\">func <a href=\"https://golang.org/src/math/rand/zipf.go?s=1024:1086#L29\">NewZipf</a>  </h3> <pre data-language=\"go\">func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf</pre> <p> NewZipf returns a Zipf variate generator. The generator generates values k ∈ [0, imax] such that P(k) is proportional to (v + k) ** (-s). Requirements: s &gt; 1 and v &gt;= 1. </p> <h3 id=\"Zipf.Uint64\">func (*Zipf) <a href=\"https://golang.org/src/math/rand/zipf.go?s=1517:1547#L48\">Uint64</a>  </h3> <pre data-language=\"go\">func (z *Zipf) Uint64() uint64</pre> <p> Uint64 returns a value drawn from the Zipf distribution described by the Zipf object. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/math/rand/\" class=\"_attribution-link\">https://golang.org/pkg/math/rand/</a>\n  </p>\n</div>\n","net/http/cookiejar/index":"<h1>Package cookiejar</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/http/cookiejar\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Jar\">type Jar</a></li>\n<li> <a href=\"#New\">func New(o *Options) (*Jar, error)</a>\n</li>\n<li> <a href=\"#Jar.Cookies\">func (j *Jar) Cookies(u *url.URL) (cookies []*http.Cookie)</a>\n</li>\n<li> <a href=\"#Jar.SetCookies\">func (j *Jar) SetCookies(u *url.URL, cookies []*http.Cookie)</a>\n</li>\n<li><a href=\"#Options\">type Options</a></li>\n<li><a href=\"#PublicSuffixList\">type PublicSuffixList</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/http/cookiejar/jar.go\">jar.go</a> <a href=\"https://golang.org/src/net/http/cookiejar/punycode.go\">punycode.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Jar\">type Jar  </h2> <pre data-language=\"go\">type Jar struct {\n        // contains filtered or unexported fields\n}</pre> <p> Jar implements the http.CookieJar interface from the net/http package. </p> <h3 id=\"New\">func <a href=\"https://golang.org/src/net/http/cookiejar/jar.go?s=2387:2421#L67\">New</a>  </h3> <pre data-language=\"go\">func New(o *Options) (*Jar, error)</pre> <p> New returns a new cookie jar. A nil *Options is equivalent to a zero Options. </p> <h3 id=\"Jar.Cookies\">func (*Jar) <a href=\"https://golang.org/src/net/http/cookiejar/jar.go?s=5174:5232#L161\">Cookies</a>  </h3> <pre data-language=\"go\">func (j *Jar) Cookies(u *url.URL) (cookies []*http.Cookie)</pre> <p> Cookies implements the Cookies method of the http.CookieJar interface. </p> <p> It returns an empty slice if the URL's scheme is not HTTP or HTTPS. </p> <h3 id=\"Jar.SetCookies\">func (*Jar) <a href=\"https://golang.org/src/net/http/cookiejar/jar.go?s=6507:6567#L225\">SetCookies</a>  </h3> <pre data-language=\"go\">func (j *Jar) SetCookies(u *url.URL, cookies []*http.Cookie)</pre> <p> SetCookies implements the SetCookies method of the http.CookieJar interface. </p> <p> It does nothing if the URL's scheme is not HTTP or HTTPS. </p> <h2 id=\"Options\">type Options  </h2> <pre data-language=\"go\">type Options struct {\n        // PublicSuffixList is the public suffix list that determines whether\n        // an HTTP server can set a cookie for a domain.\n        //\n        // A nil value is valid and may be useful for testing but it is not\n        // secure: it means that the HTTP server for foo.co.uk can set a cookie\n        // for bar.co.uk.\n        PublicSuffixList PublicSuffixList\n}</pre> <p> Options are the options for creating a new Jar. </p> <h2 id=\"PublicSuffixList\">type PublicSuffixList  </h2> <pre data-language=\"go\">type PublicSuffixList interface {\n        // PublicSuffix returns the public suffix of domain.\n        //\n        // TODO: specify which of the caller and callee is responsible for IP\n        // addresses, for leading and trailing dots, for case sensitivity, and\n        // for IDN/Punycode.\n        PublicSuffix(domain string) string\n\n        // String returns a description of the source of this public suffix\n        // list. The description will typically contain something like a time\n        // stamp or version number.\n        String() string\n}</pre> <p> PublicSuffixList provides the public suffix of a domain. For example: </p> <pre data-language=\"go\">- the public suffix of \"example.com\" is \"com\",\n- the public suffix of \"foo1.foo2.foo3.co.uk\" is \"co.uk\", and\n- the public suffix of \"bar.pvt.k12.ma.us\" is \"pvt.k12.ma.us\".\n</pre> <p> Implementations of PublicSuffixList must be safe for concurrent use by multiple goroutines. </p> <p> An implementation that always returns \"\" is valid and may be useful for testing but it is not secure: it means that the HTTP server for foo.com can set a cookie for bar.com. </p> <p> A public suffix list implementation is in the package golang.org/x/net/publicsuffix. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/http/cookiejar/\" class=\"_attribution-link\">https://golang.org/pkg/net/http/cookiejar/</a>\n  </p>\n</div>\n","net/http/httptrace/index":"<h1>Package httptrace</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/http/httptrace\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package httptrace provides mechanisms to trace the events within HTTP client requests. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#WithClientTrace\">func WithClientTrace(ctx context.Context, trace *ClientTrace) context.Context</a></li>\n<li><a href=\"#ClientTrace\">type ClientTrace</a></li>\n<li> <a href=\"#ContextClientTrace\">func ContextClientTrace(ctx context.Context) *ClientTrace</a>\n</li>\n<li><a href=\"#DNSDoneInfo\">type DNSDoneInfo</a></li>\n<li><a href=\"#DNSStartInfo\">type DNSStartInfo</a></li>\n<li><a href=\"#GotConnInfo\">type GotConnInfo</a></li>\n<li><a href=\"#WroteRequestInfo\">type WroteRequestInfo</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/http/httptrace/trace.go\">trace.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"WithClientTrace\">func WithClientTrace  </h2> <pre data-language=\"go\">func WithClientTrace(ctx context.Context, trace *ClientTrace) context.Context</pre> <p> WithClientTrace returns a new context based on the provided parent ctx. HTTP client requests made with the returned context will use the provided trace hooks, in addition to any previous hooks registered with ctx. Any hooks defined in the provided trace will be called first. </p> <h2 id=\"ClientTrace\">type ClientTrace  </h2> <pre data-language=\"go\">type ClientTrace struct {\n        // GetConn is called before a connection is created or\n        // retrieved from an idle pool. The hostPort is the\n        // \"host:port\" of the target or proxy. GetConn is called even\n        // if there's already an idle cached connection available.\n        GetConn func(hostPort string)\n\n        // GotConn is called after a successful connection is\n        // obtained. There is no hook for failure to obtain a\n        // connection; instead, use the error from\n        // Transport.RoundTrip.\n        GotConn func(GotConnInfo)\n\n        // PutIdleConn is called when the connection is returned to\n        // the idle pool. If err is nil, the connection was\n        // successfully returned to the idle pool. If err is non-nil,\n        // it describes why not. PutIdleConn is not called if\n        // connection reuse is disabled via Transport.DisableKeepAlives.\n        // PutIdleConn is called before the caller's Response.Body.Close\n        // call returns.\n        // For HTTP/2, this hook is not currently used.\n        PutIdleConn func(err error)\n\n        // GotFirstResponseByte is called when the first byte of the response\n        // headers is available.\n        GotFirstResponseByte func()\n\n        // Got100Continue is called if the server replies with a \"100\n        // Continue\" response.\n        Got100Continue func()\n\n        // DNSStart is called when a DNS lookup begins.\n        DNSStart func(DNSStartInfo)\n\n        // DNSDone is called when a DNS lookup ends.\n        DNSDone func(DNSDoneInfo)\n\n        // ConnectStart is called when a new connection's Dial begins.\n        // If net.Dialer.DualStack (IPv6 \"Happy Eyeballs\") support is\n        // enabled, this may be called multiple times.\n        ConnectStart func(network, addr string)\n\n        // ConnectDone is called when a new connection's Dial\n        // completes. The provided err indicates whether the\n        // connection completedly successfully.\n        // If net.Dialer.DualStack (\"Happy Eyeballs\") support is\n        // enabled, this may be called multiple times.\n        ConnectDone func(network, addr string, err error)\n\n        // WroteHeaders is called after the Transport has written\n        // the request headers.\n        WroteHeaders func()\n\n        // Wait100Continue is called if the Request specified\n        // \"Expected: 100-continue\" and the Transport has written the\n        // request headers but is waiting for \"100 Continue\" from the\n        // server before writing the request body.\n        Wait100Continue func()\n\n        // WroteRequest is called with the result of writing the\n        // request and any body.\n        WroteRequest func(WroteRequestInfo)\n}</pre> <p> ClientTrace is a set of hooks to run at various stages of an HTTP client request. Any particular hook may be nil. Functions may be called concurrently from different goroutines, starting after the call to Transport.RoundTrip and ending either when RoundTrip returns an error, or when the Response.Body is closed. </p> <h3 id=\"ContextClientTrace\">func <a href=\"https://golang.org/src/net/http/httptrace/trace.go?s=530:587#L12\">ContextClientTrace</a>  </h3> <pre data-language=\"go\">func ContextClientTrace(ctx context.Context) *ClientTrace</pre> <p> ContextClientTrace returns the ClientTrace associated with the provided context. If none, it returns nil. </p> <h2 id=\"DNSDoneInfo\">type DNSDoneInfo  </h2> <pre data-language=\"go\">type DNSDoneInfo struct {\n        // Addrs are the IPv4 and/or IPv6 addresses found in the DNS\n        // lookup. The contents of the slice should not be mutated.\n        Addrs []net.IPAddr\n\n        // Err is any error that occurred during the DNS lookup.\n        Err error\n\n        // Coalesced is whether the Addrs were shared with another\n        // caller who was doing the same DNS lookup concurrently.\n        Coalesced bool\n}</pre> <p> DNSDoneInfo contains information about the results of a DNS lookup. </p> <h2 id=\"DNSStartInfo\">type DNSStartInfo  </h2> <pre data-language=\"go\">type DNSStartInfo struct {\n        Host string\n}</pre> <p> DNSStartInfo contains information about a DNS request. </p> <h2 id=\"GotConnInfo\">type GotConnInfo  </h2> <pre data-language=\"go\">type GotConnInfo struct {\n        // Conn is the connection that was obtained. It is owned by\n        // the http.Transport and should not be read, written or\n        // closed by users of ClientTrace.\n        Conn net.Conn\n\n        // Reused is whether this connection has been previously\n        // used for another HTTP request.\n        Reused bool\n\n        // WasIdle is whether this connection was obtained from an\n        // idle pool.\n        WasIdle bool\n\n        // IdleTime reports how long the connection was previously\n        // idle, if WasIdle is true.\n        IdleTime time.Duration\n}</pre> <p> GotConnInfo is the argument to the ClientTrace.GotConn function and contains information about the obtained connection. </p> <h2 id=\"WroteRequestInfo\">type WroteRequestInfo  </h2> <pre data-language=\"go\">type WroteRequestInfo struct {\n        // Err is any error encountered while writing the Request.\n        Err error\n}</pre> <p> WroteRequestInfo contains information provided to the WroteRequest hook. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/http/httptrace/\" class=\"_attribution-link\">https://golang.org/pkg/net/http/httptrace/</a>\n  </p>\n</div>\n","net/http/pprof/index":"<h1>Package pprof</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/http/pprof\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool. </p> <p> The package is typically only imported for the side effect of registering its HTTP handlers. The handled paths all begin with /debug/pprof/. </p> <p> To use pprof, link this package into your program: </p> <pre data-language=\"go\">import _ \"net/http/pprof\"\n</pre> <p> If your application is not already running an http server, you need to start one. Add \"net/http\" and \"log\" to your imports and the following code to your main function: </p> <pre data-language=\"go\">go func() {\n\tlog.Println(http.ListenAndServe(\"localhost:6060\", nil))\n}()\n</pre> <p> Then use the pprof tool to look at the heap profile: </p> <pre data-language=\"go\">go tool pprof http://localhost:6060/debug/pprof/heap\n</pre> <p> Or to look at a 30-second CPU profile: </p> <pre data-language=\"go\">go tool pprof http://localhost:6060/debug/pprof/profile\n</pre> <p> Or to look at the goroutine blocking profile, after calling runtime.SetBlockProfileRate in your program: </p> <pre data-language=\"go\">go tool pprof http://localhost:6060/debug/pprof/block\n</pre> <p> Or to collect a 5-second execution trace: </p> <pre data-language=\"go\">wget http://localhost:6060/debug/pprof/trace?seconds=5\n</pre> <p> To view all available profiles, open <a href=\"http://localhost:6060/debug/pprof/\">http://localhost:6060/debug/pprof/</a> in your browser. </p> <p> For a study of the facility in action, visit </p> <pre data-language=\"go\">https://blog.golang.org/2011/06/profiling-go-programs.html\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Cmdline\">func Cmdline(w http.ResponseWriter, r *http.Request)</a></li>\n<li><a href=\"#Handler\">func Handler(name string) http.Handler</a></li>\n<li><a href=\"#Index\">func Index(w http.ResponseWriter, r *http.Request)</a></li>\n<li><a href=\"#Profile\">func Profile(w http.ResponseWriter, r *http.Request)</a></li>\n<li><a href=\"#Symbol\">func Symbol(w http.ResponseWriter, r *http.Request)</a></li>\n<li><a href=\"#Trace\">func Trace(w http.ResponseWriter, r *http.Request)</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/http/pprof/pprof.go\">pprof.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Cmdline\">func Cmdline  </h2> <pre data-language=\"go\">func Cmdline(w http.ResponseWriter, r *http.Request)</pre> <p> Cmdline responds with the running program's command line, with arguments separated by NUL bytes. The package initialization registers it as /debug/pprof/cmdline. </p> <h2 id=\"Handler\">func Handler  </h2> <pre data-language=\"go\">func Handler(name string) http.Handler</pre> <p> Handler returns an HTTP handler that serves the named profile. </p> <h2 id=\"Index\">func Index  </h2> <pre data-language=\"go\">func Index(w http.ResponseWriter, r *http.Request)</pre> <p> Index responds with the pprof-formatted profile named by the request. For example, \"/debug/pprof/heap\" serves the \"heap\" profile. Index responds to a request for \"/debug/pprof/\" with an HTML page listing the available profiles. </p> <h2 id=\"Profile\">func Profile  </h2> <pre data-language=\"go\">func Profile(w http.ResponseWriter, r *http.Request)</pre> <p> Profile responds with the pprof-formatted cpu profile. The package initialization registers it as /debug/pprof/profile. </p> <h2 id=\"Symbol\">func Symbol  </h2> <pre data-language=\"go\">func Symbol(w http.ResponseWriter, r *http.Request)</pre> <p> Symbol looks up the program counters listed in the request, responding with a table mapping program counters to function names. The package initialization registers it as /debug/pprof/symbol. </p> <h2 id=\"Trace\">func Trace  </h2> <pre data-language=\"go\">func Trace(w http.ResponseWriter, r *http.Request)</pre> <p> Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/http/pprof/\" class=\"_attribution-link\">https://golang.org/pkg/net/http/pprof/</a>\n  </p>\n</div>\n","image/color/palette/index":"<h1>Package palette</h1>     <ul id=\"short-nav\">\n<li><code>import \"image/color/palette\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package palette provides standard color palettes. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\"><li><a href=\"#pkg-variables\">Variables</a></li></ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/image/color/palette/generate.go\">generate.go</a> <a href=\"https://golang.org/src/image/color/palette/palette.go\">palette.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var Plan9 = []color.Color{\n        color.RGBA{0x00, 0x00, 0x00, 0xff},\n        color.RGBA{0x00, 0x00, 0x44, 0xff},\n        color.RGBA{0x00, 0x00, 0x88, 0xff},\n        color.RGBA{0x00, 0x00, 0xcc, 0xff},\n        color.RGBA{0x00, 0x44, 0x00, 0xff},\n        color.RGBA{0x00, 0x44, 0x44, 0xff},\n        color.RGBA{0x00, 0x44, 0x88, 0xff},\n        color.RGBA{0x00, 0x44, 0xcc, 0xff},\n        color.RGBA{0x00, 0x88, 0x00, 0xff},\n        color.RGBA{0x00, 0x88, 0x44, 0xff},\n        color.RGBA{0x00, 0x88, 0x88, 0xff},\n        color.RGBA{0x00, 0x88, 0xcc, 0xff},\n        color.RGBA{0x00, 0xcc, 0x00, 0xff},\n        color.RGBA{0x00, 0xcc, 0x44, 0xff},\n        color.RGBA{0x00, 0xcc, 0x88, 0xff},\n        color.RGBA{0x00, 0xcc, 0xcc, 0xff},\n        color.RGBA{0x00, 0xdd, 0xdd, 0xff},\n        color.RGBA{0x11, 0x11, 0x11, 0xff},\n        color.RGBA{0x00, 0x00, 0x55, 0xff},\n        color.RGBA{0x00, 0x00, 0x99, 0xff},\n        color.RGBA{0x00, 0x00, 0xdd, 0xff},\n        color.RGBA{0x00, 0x55, 0x00, 0xff},\n        color.RGBA{0x00, 0x55, 0x55, 0xff},\n        color.RGBA{0x00, 0x4c, 0x99, 0xff},\n        color.RGBA{0x00, 0x49, 0xdd, 0xff},\n        color.RGBA{0x00, 0x99, 0x00, 0xff},\n        color.RGBA{0x00, 0x99, 0x4c, 0xff},\n        color.RGBA{0x00, 0x99, 0x99, 0xff},\n        color.RGBA{0x00, 0x93, 0xdd, 0xff},\n        color.RGBA{0x00, 0xdd, 0x00, 0xff},\n        color.RGBA{0x00, 0xdd, 0x49, 0xff},\n        color.RGBA{0x00, 0xdd, 0x93, 0xff},\n        color.RGBA{0x00, 0xee, 0x9e, 0xff},\n        color.RGBA{0x00, 0xee, 0xee, 0xff},\n        color.RGBA{0x22, 0x22, 0x22, 0xff},\n        color.RGBA{0x00, 0x00, 0x66, 0xff},\n        color.RGBA{0x00, 0x00, 0xaa, 0xff},\n        color.RGBA{0x00, 0x00, 0xee, 0xff},\n        color.RGBA{0x00, 0x66, 0x00, 0xff},\n        color.RGBA{0x00, 0x66, 0x66, 0xff},\n        color.RGBA{0x00, 0x55, 0xaa, 0xff},\n        color.RGBA{0x00, 0x4f, 0xee, 0xff},\n        color.RGBA{0x00, 0xaa, 0x00, 0xff},\n        color.RGBA{0x00, 0xaa, 0x55, 0xff},\n        color.RGBA{0x00, 0xaa, 0xaa, 0xff},\n        color.RGBA{0x00, 0x9e, 0xee, 0xff},\n        color.RGBA{0x00, 0xee, 0x00, 0xff},\n        color.RGBA{0x00, 0xee, 0x4f, 0xff},\n        color.RGBA{0x00, 0xff, 0x55, 0xff},\n        color.RGBA{0x00, 0xff, 0xaa, 0xff},\n        color.RGBA{0x00, 0xff, 0xff, 0xff},\n        color.RGBA{0x33, 0x33, 0x33, 0xff},\n        color.RGBA{0x00, 0x00, 0x77, 0xff},\n        color.RGBA{0x00, 0x00, 0xbb, 0xff},\n        color.RGBA{0x00, 0x00, 0xff, 0xff},\n        color.RGBA{0x00, 0x77, 0x00, 0xff},\n        color.RGBA{0x00, 0x77, 0x77, 0xff},\n        color.RGBA{0x00, 0x5d, 0xbb, 0xff},\n        color.RGBA{0x00, 0x55, 0xff, 0xff},\n        color.RGBA{0x00, 0xbb, 0x00, 0xff},\n        color.RGBA{0x00, 0xbb, 0x5d, 0xff},\n        color.RGBA{0x00, 0xbb, 0xbb, 0xff},\n        color.RGBA{0x00, 0xaa, 0xff, 0xff},\n        color.RGBA{0x00, 0xff, 0x00, 0xff},\n        color.RGBA{0x44, 0x00, 0x44, 0xff},\n        color.RGBA{0x44, 0x00, 0x88, 0xff},\n        color.RGBA{0x44, 0x00, 0xcc, 0xff},\n        color.RGBA{0x44, 0x44, 0x00, 0xff},\n        color.RGBA{0x44, 0x44, 0x44, 0xff},\n        color.RGBA{0x44, 0x44, 0x88, 0xff},\n        color.RGBA{0x44, 0x44, 0xcc, 0xff},\n        color.RGBA{0x44, 0x88, 0x00, 0xff},\n        color.RGBA{0x44, 0x88, 0x44, 0xff},\n        color.RGBA{0x44, 0x88, 0x88, 0xff},\n        color.RGBA{0x44, 0x88, 0xcc, 0xff},\n        color.RGBA{0x44, 0xcc, 0x00, 0xff},\n        color.RGBA{0x44, 0xcc, 0x44, 0xff},\n        color.RGBA{0x44, 0xcc, 0x88, 0xff},\n        color.RGBA{0x44, 0xcc, 0xcc, 0xff},\n        color.RGBA{0x44, 0x00, 0x00, 0xff},\n        color.RGBA{0x55, 0x00, 0x00, 0xff},\n        color.RGBA{0x55, 0x00, 0x55, 0xff},\n        color.RGBA{0x4c, 0x00, 0x99, 0xff},\n        color.RGBA{0x49, 0x00, 0xdd, 0xff},\n        color.RGBA{0x55, 0x55, 0x00, 0xff},\n        color.RGBA{0x55, 0x55, 0x55, 0xff},\n        color.RGBA{0x4c, 0x4c, 0x99, 0xff},\n        color.RGBA{0x49, 0x49, 0xdd, 0xff},\n        color.RGBA{0x4c, 0x99, 0x00, 0xff},\n        color.RGBA{0x4c, 0x99, 0x4c, 0xff},\n        color.RGBA{0x4c, 0x99, 0x99, 0xff},\n        color.RGBA{0x49, 0x93, 0xdd, 0xff},\n        color.RGBA{0x49, 0xdd, 0x00, 0xff},\n        color.RGBA{0x49, 0xdd, 0x49, 0xff},\n        color.RGBA{0x49, 0xdd, 0x93, 0xff},\n        color.RGBA{0x49, 0xdd, 0xdd, 0xff},\n        color.RGBA{0x4f, 0xee, 0xee, 0xff},\n        color.RGBA{0x66, 0x00, 0x00, 0xff},\n        color.RGBA{0x66, 0x00, 0x66, 0xff},\n        color.RGBA{0x55, 0x00, 0xaa, 0xff},\n        color.RGBA{0x4f, 0x00, 0xee, 0xff},\n        color.RGBA{0x66, 0x66, 0x00, 0xff},\n        color.RGBA{0x66, 0x66, 0x66, 0xff},\n        color.RGBA{0x55, 0x55, 0xaa, 0xff},\n        color.RGBA{0x4f, 0x4f, 0xee, 0xff},\n        color.RGBA{0x55, 0xaa, 0x00, 0xff},\n        color.RGBA{0x55, 0xaa, 0x55, 0xff},\n        color.RGBA{0x55, 0xaa, 0xaa, 0xff},\n        color.RGBA{0x4f, 0x9e, 0xee, 0xff},\n        color.RGBA{0x4f, 0xee, 0x00, 0xff},\n        color.RGBA{0x4f, 0xee, 0x4f, 0xff},\n        color.RGBA{0x4f, 0xee, 0x9e, 0xff},\n        color.RGBA{0x55, 0xff, 0xaa, 0xff},\n        color.RGBA{0x55, 0xff, 0xff, 0xff},\n        color.RGBA{0x77, 0x00, 0x00, 0xff},\n        color.RGBA{0x77, 0x00, 0x77, 0xff},\n        color.RGBA{0x5d, 0x00, 0xbb, 0xff},\n        color.RGBA{0x55, 0x00, 0xff, 0xff},\n        color.RGBA{0x77, 0x77, 0x00, 0xff},\n        color.RGBA{0x77, 0x77, 0x77, 0xff},\n        color.RGBA{0x5d, 0x5d, 0xbb, 0xff},\n        color.RGBA{0x55, 0x55, 0xff, 0xff},\n        color.RGBA{0x5d, 0xbb, 0x00, 0xff},\n        color.RGBA{0x5d, 0xbb, 0x5d, 0xff},\n        color.RGBA{0x5d, 0xbb, 0xbb, 0xff},\n        color.RGBA{0x55, 0xaa, 0xff, 0xff},\n        color.RGBA{0x55, 0xff, 0x00, 0xff},\n        color.RGBA{0x55, 0xff, 0x55, 0xff},\n        color.RGBA{0x88, 0x00, 0x88, 0xff},\n        color.RGBA{0x88, 0x00, 0xcc, 0xff},\n        color.RGBA{0x88, 0x44, 0x00, 0xff},\n        color.RGBA{0x88, 0x44, 0x44, 0xff},\n        color.RGBA{0x88, 0x44, 0x88, 0xff},\n        color.RGBA{0x88, 0x44, 0xcc, 0xff},\n        color.RGBA{0x88, 0x88, 0x00, 0xff},\n        color.RGBA{0x88, 0x88, 0x44, 0xff},\n        color.RGBA{0x88, 0x88, 0x88, 0xff},\n        color.RGBA{0x88, 0x88, 0xcc, 0xff},\n        color.RGBA{0x88, 0xcc, 0x00, 0xff},\n        color.RGBA{0x88, 0xcc, 0x44, 0xff},\n        color.RGBA{0x88, 0xcc, 0x88, 0xff},\n        color.RGBA{0x88, 0xcc, 0xcc, 0xff},\n        color.RGBA{0x88, 0x00, 0x00, 0xff},\n        color.RGBA{0x88, 0x00, 0x44, 0xff},\n        color.RGBA{0x99, 0x00, 0x4c, 0xff},\n        color.RGBA{0x99, 0x00, 0x99, 0xff},\n        color.RGBA{0x93, 0x00, 0xdd, 0xff},\n        color.RGBA{0x99, 0x4c, 0x00, 0xff},\n        color.RGBA{0x99, 0x4c, 0x4c, 0xff},\n        color.RGBA{0x99, 0x4c, 0x99, 0xff},\n        color.RGBA{0x93, 0x49, 0xdd, 0xff},\n        color.RGBA{0x99, 0x99, 0x00, 0xff},\n        color.RGBA{0x99, 0x99, 0x4c, 0xff},\n        color.RGBA{0x99, 0x99, 0x99, 0xff},\n        color.RGBA{0x93, 0x93, 0xdd, 0xff},\n        color.RGBA{0x93, 0xdd, 0x00, 0xff},\n        color.RGBA{0x93, 0xdd, 0x49, 0xff},\n        color.RGBA{0x93, 0xdd, 0x93, 0xff},\n        color.RGBA{0x93, 0xdd, 0xdd, 0xff},\n        color.RGBA{0x99, 0x00, 0x00, 0xff},\n        color.RGBA{0xaa, 0x00, 0x00, 0xff},\n        color.RGBA{0xaa, 0x00, 0x55, 0xff},\n        color.RGBA{0xaa, 0x00, 0xaa, 0xff},\n        color.RGBA{0x9e, 0x00, 0xee, 0xff},\n        color.RGBA{0xaa, 0x55, 0x00, 0xff},\n        color.RGBA{0xaa, 0x55, 0x55, 0xff},\n        color.RGBA{0xaa, 0x55, 0xaa, 0xff},\n        color.RGBA{0x9e, 0x4f, 0xee, 0xff},\n        color.RGBA{0xaa, 0xaa, 0x00, 0xff},\n        color.RGBA{0xaa, 0xaa, 0x55, 0xff},\n        color.RGBA{0xaa, 0xaa, 0xaa, 0xff},\n        color.RGBA{0x9e, 0x9e, 0xee, 0xff},\n        color.RGBA{0x9e, 0xee, 0x00, 0xff},\n        color.RGBA{0x9e, 0xee, 0x4f, 0xff},\n        color.RGBA{0x9e, 0xee, 0x9e, 0xff},\n        color.RGBA{0x9e, 0xee, 0xee, 0xff},\n        color.RGBA{0xaa, 0xff, 0xff, 0xff},\n        color.RGBA{0xbb, 0x00, 0x00, 0xff},\n        color.RGBA{0xbb, 0x00, 0x5d, 0xff},\n        color.RGBA{0xbb, 0x00, 0xbb, 0xff},\n        color.RGBA{0xaa, 0x00, 0xff, 0xff},\n        color.RGBA{0xbb, 0x5d, 0x00, 0xff},\n        color.RGBA{0xbb, 0x5d, 0x5d, 0xff},\n        color.RGBA{0xbb, 0x5d, 0xbb, 0xff},\n        color.RGBA{0xaa, 0x55, 0xff, 0xff},\n        color.RGBA{0xbb, 0xbb, 0x00, 0xff},\n        color.RGBA{0xbb, 0xbb, 0x5d, 0xff},\n        color.RGBA{0xbb, 0xbb, 0xbb, 0xff},\n        color.RGBA{0xaa, 0xaa, 0xff, 0xff},\n        color.RGBA{0xaa, 0xff, 0x00, 0xff},\n        color.RGBA{0xaa, 0xff, 0x55, 0xff},\n        color.RGBA{0xaa, 0xff, 0xaa, 0xff},\n        color.RGBA{0xcc, 0x00, 0xcc, 0xff},\n        color.RGBA{0xcc, 0x44, 0x00, 0xff},\n        color.RGBA{0xcc, 0x44, 0x44, 0xff},\n        color.RGBA{0xcc, 0x44, 0x88, 0xff},\n        color.RGBA{0xcc, 0x44, 0xcc, 0xff},\n        color.RGBA{0xcc, 0x88, 0x00, 0xff},\n        color.RGBA{0xcc, 0x88, 0x44, 0xff},\n        color.RGBA{0xcc, 0x88, 0x88, 0xff},\n        color.RGBA{0xcc, 0x88, 0xcc, 0xff},\n        color.RGBA{0xcc, 0xcc, 0x00, 0xff},\n        color.RGBA{0xcc, 0xcc, 0x44, 0xff},\n        color.RGBA{0xcc, 0xcc, 0x88, 0xff},\n        color.RGBA{0xcc, 0xcc, 0xcc, 0xff},\n        color.RGBA{0xcc, 0x00, 0x00, 0xff},\n        color.RGBA{0xcc, 0x00, 0x44, 0xff},\n        color.RGBA{0xcc, 0x00, 0x88, 0xff},\n        color.RGBA{0xdd, 0x00, 0x93, 0xff},\n        color.RGBA{0xdd, 0x00, 0xdd, 0xff},\n        color.RGBA{0xdd, 0x49, 0x00, 0xff},\n        color.RGBA{0xdd, 0x49, 0x49, 0xff},\n        color.RGBA{0xdd, 0x49, 0x93, 0xff},\n        color.RGBA{0xdd, 0x49, 0xdd, 0xff},\n        color.RGBA{0xdd, 0x93, 0x00, 0xff},\n        color.RGBA{0xdd, 0x93, 0x49, 0xff},\n        color.RGBA{0xdd, 0x93, 0x93, 0xff},\n        color.RGBA{0xdd, 0x93, 0xdd, 0xff},\n        color.RGBA{0xdd, 0xdd, 0x00, 0xff},\n        color.RGBA{0xdd, 0xdd, 0x49, 0xff},\n        color.RGBA{0xdd, 0xdd, 0x93, 0xff},\n        color.RGBA{0xdd, 0xdd, 0xdd, 0xff},\n        color.RGBA{0xdd, 0x00, 0x00, 0xff},\n        color.RGBA{0xdd, 0x00, 0x49, 0xff},\n        color.RGBA{0xee, 0x00, 0x4f, 0xff},\n        color.RGBA{0xee, 0x00, 0x9e, 0xff},\n        color.RGBA{0xee, 0x00, 0xee, 0xff},\n        color.RGBA{0xee, 0x4f, 0x00, 0xff},\n        color.RGBA{0xee, 0x4f, 0x4f, 0xff},\n        color.RGBA{0xee, 0x4f, 0x9e, 0xff},\n        color.RGBA{0xee, 0x4f, 0xee, 0xff},\n        color.RGBA{0xee, 0x9e, 0x00, 0xff},\n        color.RGBA{0xee, 0x9e, 0x4f, 0xff},\n        color.RGBA{0xee, 0x9e, 0x9e, 0xff},\n        color.RGBA{0xee, 0x9e, 0xee, 0xff},\n        color.RGBA{0xee, 0xee, 0x00, 0xff},\n        color.RGBA{0xee, 0xee, 0x4f, 0xff},\n        color.RGBA{0xee, 0xee, 0x9e, 0xff},\n        color.RGBA{0xee, 0xee, 0xee, 0xff},\n        color.RGBA{0xee, 0x00, 0x00, 0xff},\n        color.RGBA{0xff, 0x00, 0x00, 0xff},\n        color.RGBA{0xff, 0x00, 0x55, 0xff},\n        color.RGBA{0xff, 0x00, 0xaa, 0xff},\n        color.RGBA{0xff, 0x00, 0xff, 0xff},\n        color.RGBA{0xff, 0x55, 0x00, 0xff},\n        color.RGBA{0xff, 0x55, 0x55, 0xff},\n        color.RGBA{0xff, 0x55, 0xaa, 0xff},\n        color.RGBA{0xff, 0x55, 0xff, 0xff},\n        color.RGBA{0xff, 0xaa, 0x00, 0xff},\n        color.RGBA{0xff, 0xaa, 0x55, 0xff},\n        color.RGBA{0xff, 0xaa, 0xaa, 0xff},\n        color.RGBA{0xff, 0xaa, 0xff, 0xff},\n        color.RGBA{0xff, 0xff, 0x00, 0xff},\n        color.RGBA{0xff, 0xff, 0x55, 0xff},\n        color.RGBA{0xff, 0xff, 0xaa, 0xff},\n        color.RGBA{0xff, 0xff, 0xff, 0xff},\n}</pre> <p> Plan9 is a 256-color palette that partitions the 24-bit RGB space into 4×4×4 subdivision, with 4 shades in each subcube. Compared to the WebSafe, the idea is to reduce the color resolution by dicing the color cube into fewer cells, and to use the extra space to increase the intensity resolution. This results in 16 gray shades (4 gray subcubes with 4 samples in each), 13 shades of each primary and secondary color (3 subcubes with 4 samples plus black) and a reasonable selection of colors covering the rest of the color cube. The advantage is better representation of continuous tones. </p> <p> This palette was used in the Plan 9 Operating System, described at <a href=\"https://9p.io/magic/man2html/6/color\">https://9p.io/magic/man2html/6/color</a> </p> <pre data-language=\"go\">var WebSafe = []color.Color{\n        color.RGBA{0x00, 0x00, 0x00, 0xff},\n        color.RGBA{0x00, 0x00, 0x33, 0xff},\n        color.RGBA{0x00, 0x00, 0x66, 0xff},\n        color.RGBA{0x00, 0x00, 0x99, 0xff},\n        color.RGBA{0x00, 0x00, 0xcc, 0xff},\n        color.RGBA{0x00, 0x00, 0xff, 0xff},\n        color.RGBA{0x00, 0x33, 0x00, 0xff},\n        color.RGBA{0x00, 0x33, 0x33, 0xff},\n        color.RGBA{0x00, 0x33, 0x66, 0xff},\n        color.RGBA{0x00, 0x33, 0x99, 0xff},\n        color.RGBA{0x00, 0x33, 0xcc, 0xff},\n        color.RGBA{0x00, 0x33, 0xff, 0xff},\n        color.RGBA{0x00, 0x66, 0x00, 0xff},\n        color.RGBA{0x00, 0x66, 0x33, 0xff},\n        color.RGBA{0x00, 0x66, 0x66, 0xff},\n        color.RGBA{0x00, 0x66, 0x99, 0xff},\n        color.RGBA{0x00, 0x66, 0xcc, 0xff},\n        color.RGBA{0x00, 0x66, 0xff, 0xff},\n        color.RGBA{0x00, 0x99, 0x00, 0xff},\n        color.RGBA{0x00, 0x99, 0x33, 0xff},\n        color.RGBA{0x00, 0x99, 0x66, 0xff},\n        color.RGBA{0x00, 0x99, 0x99, 0xff},\n        color.RGBA{0x00, 0x99, 0xcc, 0xff},\n        color.RGBA{0x00, 0x99, 0xff, 0xff},\n        color.RGBA{0x00, 0xcc, 0x00, 0xff},\n        color.RGBA{0x00, 0xcc, 0x33, 0xff},\n        color.RGBA{0x00, 0xcc, 0x66, 0xff},\n        color.RGBA{0x00, 0xcc, 0x99, 0xff},\n        color.RGBA{0x00, 0xcc, 0xcc, 0xff},\n        color.RGBA{0x00, 0xcc, 0xff, 0xff},\n        color.RGBA{0x00, 0xff, 0x00, 0xff},\n        color.RGBA{0x00, 0xff, 0x33, 0xff},\n        color.RGBA{0x00, 0xff, 0x66, 0xff},\n        color.RGBA{0x00, 0xff, 0x99, 0xff},\n        color.RGBA{0x00, 0xff, 0xcc, 0xff},\n        color.RGBA{0x00, 0xff, 0xff, 0xff},\n        color.RGBA{0x33, 0x00, 0x00, 0xff},\n        color.RGBA{0x33, 0x00, 0x33, 0xff},\n        color.RGBA{0x33, 0x00, 0x66, 0xff},\n        color.RGBA{0x33, 0x00, 0x99, 0xff},\n        color.RGBA{0x33, 0x00, 0xcc, 0xff},\n        color.RGBA{0x33, 0x00, 0xff, 0xff},\n        color.RGBA{0x33, 0x33, 0x00, 0xff},\n        color.RGBA{0x33, 0x33, 0x33, 0xff},\n        color.RGBA{0x33, 0x33, 0x66, 0xff},\n        color.RGBA{0x33, 0x33, 0x99, 0xff},\n        color.RGBA{0x33, 0x33, 0xcc, 0xff},\n        color.RGBA{0x33, 0x33, 0xff, 0xff},\n        color.RGBA{0x33, 0x66, 0x00, 0xff},\n        color.RGBA{0x33, 0x66, 0x33, 0xff},\n        color.RGBA{0x33, 0x66, 0x66, 0xff},\n        color.RGBA{0x33, 0x66, 0x99, 0xff},\n        color.RGBA{0x33, 0x66, 0xcc, 0xff},\n        color.RGBA{0x33, 0x66, 0xff, 0xff},\n        color.RGBA{0x33, 0x99, 0x00, 0xff},\n        color.RGBA{0x33, 0x99, 0x33, 0xff},\n        color.RGBA{0x33, 0x99, 0x66, 0xff},\n        color.RGBA{0x33, 0x99, 0x99, 0xff},\n        color.RGBA{0x33, 0x99, 0xcc, 0xff},\n        color.RGBA{0x33, 0x99, 0xff, 0xff},\n        color.RGBA{0x33, 0xcc, 0x00, 0xff},\n        color.RGBA{0x33, 0xcc, 0x33, 0xff},\n        color.RGBA{0x33, 0xcc, 0x66, 0xff},\n        color.RGBA{0x33, 0xcc, 0x99, 0xff},\n        color.RGBA{0x33, 0xcc, 0xcc, 0xff},\n        color.RGBA{0x33, 0xcc, 0xff, 0xff},\n        color.RGBA{0x33, 0xff, 0x00, 0xff},\n        color.RGBA{0x33, 0xff, 0x33, 0xff},\n        color.RGBA{0x33, 0xff, 0x66, 0xff},\n        color.RGBA{0x33, 0xff, 0x99, 0xff},\n        color.RGBA{0x33, 0xff, 0xcc, 0xff},\n        color.RGBA{0x33, 0xff, 0xff, 0xff},\n        color.RGBA{0x66, 0x00, 0x00, 0xff},\n        color.RGBA{0x66, 0x00, 0x33, 0xff},\n        color.RGBA{0x66, 0x00, 0x66, 0xff},\n        color.RGBA{0x66, 0x00, 0x99, 0xff},\n        color.RGBA{0x66, 0x00, 0xcc, 0xff},\n        color.RGBA{0x66, 0x00, 0xff, 0xff},\n        color.RGBA{0x66, 0x33, 0x00, 0xff},\n        color.RGBA{0x66, 0x33, 0x33, 0xff},\n        color.RGBA{0x66, 0x33, 0x66, 0xff},\n        color.RGBA{0x66, 0x33, 0x99, 0xff},\n        color.RGBA{0x66, 0x33, 0xcc, 0xff},\n        color.RGBA{0x66, 0x33, 0xff, 0xff},\n        color.RGBA{0x66, 0x66, 0x00, 0xff},\n        color.RGBA{0x66, 0x66, 0x33, 0xff},\n        color.RGBA{0x66, 0x66, 0x66, 0xff},\n        color.RGBA{0x66, 0x66, 0x99, 0xff},\n        color.RGBA{0x66, 0x66, 0xcc, 0xff},\n        color.RGBA{0x66, 0x66, 0xff, 0xff},\n        color.RGBA{0x66, 0x99, 0x00, 0xff},\n        color.RGBA{0x66, 0x99, 0x33, 0xff},\n        color.RGBA{0x66, 0x99, 0x66, 0xff},\n        color.RGBA{0x66, 0x99, 0x99, 0xff},\n        color.RGBA{0x66, 0x99, 0xcc, 0xff},\n        color.RGBA{0x66, 0x99, 0xff, 0xff},\n        color.RGBA{0x66, 0xcc, 0x00, 0xff},\n        color.RGBA{0x66, 0xcc, 0x33, 0xff},\n        color.RGBA{0x66, 0xcc, 0x66, 0xff},\n        color.RGBA{0x66, 0xcc, 0x99, 0xff},\n        color.RGBA{0x66, 0xcc, 0xcc, 0xff},\n        color.RGBA{0x66, 0xcc, 0xff, 0xff},\n        color.RGBA{0x66, 0xff, 0x00, 0xff},\n        color.RGBA{0x66, 0xff, 0x33, 0xff},\n        color.RGBA{0x66, 0xff, 0x66, 0xff},\n        color.RGBA{0x66, 0xff, 0x99, 0xff},\n        color.RGBA{0x66, 0xff, 0xcc, 0xff},\n        color.RGBA{0x66, 0xff, 0xff, 0xff},\n        color.RGBA{0x99, 0x00, 0x00, 0xff},\n        color.RGBA{0x99, 0x00, 0x33, 0xff},\n        color.RGBA{0x99, 0x00, 0x66, 0xff},\n        color.RGBA{0x99, 0x00, 0x99, 0xff},\n        color.RGBA{0x99, 0x00, 0xcc, 0xff},\n        color.RGBA{0x99, 0x00, 0xff, 0xff},\n        color.RGBA{0x99, 0x33, 0x00, 0xff},\n        color.RGBA{0x99, 0x33, 0x33, 0xff},\n        color.RGBA{0x99, 0x33, 0x66, 0xff},\n        color.RGBA{0x99, 0x33, 0x99, 0xff},\n        color.RGBA{0x99, 0x33, 0xcc, 0xff},\n        color.RGBA{0x99, 0x33, 0xff, 0xff},\n        color.RGBA{0x99, 0x66, 0x00, 0xff},\n        color.RGBA{0x99, 0x66, 0x33, 0xff},\n        color.RGBA{0x99, 0x66, 0x66, 0xff},\n        color.RGBA{0x99, 0x66, 0x99, 0xff},\n        color.RGBA{0x99, 0x66, 0xcc, 0xff},\n        color.RGBA{0x99, 0x66, 0xff, 0xff},\n        color.RGBA{0x99, 0x99, 0x00, 0xff},\n        color.RGBA{0x99, 0x99, 0x33, 0xff},\n        color.RGBA{0x99, 0x99, 0x66, 0xff},\n        color.RGBA{0x99, 0x99, 0x99, 0xff},\n        color.RGBA{0x99, 0x99, 0xcc, 0xff},\n        color.RGBA{0x99, 0x99, 0xff, 0xff},\n        color.RGBA{0x99, 0xcc, 0x00, 0xff},\n        color.RGBA{0x99, 0xcc, 0x33, 0xff},\n        color.RGBA{0x99, 0xcc, 0x66, 0xff},\n        color.RGBA{0x99, 0xcc, 0x99, 0xff},\n        color.RGBA{0x99, 0xcc, 0xcc, 0xff},\n        color.RGBA{0x99, 0xcc, 0xff, 0xff},\n        color.RGBA{0x99, 0xff, 0x00, 0xff},\n        color.RGBA{0x99, 0xff, 0x33, 0xff},\n        color.RGBA{0x99, 0xff, 0x66, 0xff},\n        color.RGBA{0x99, 0xff, 0x99, 0xff},\n        color.RGBA{0x99, 0xff, 0xcc, 0xff},\n        color.RGBA{0x99, 0xff, 0xff, 0xff},\n        color.RGBA{0xcc, 0x00, 0x00, 0xff},\n        color.RGBA{0xcc, 0x00, 0x33, 0xff},\n        color.RGBA{0xcc, 0x00, 0x66, 0xff},\n        color.RGBA{0xcc, 0x00, 0x99, 0xff},\n        color.RGBA{0xcc, 0x00, 0xcc, 0xff},\n        color.RGBA{0xcc, 0x00, 0xff, 0xff},\n        color.RGBA{0xcc, 0x33, 0x00, 0xff},\n        color.RGBA{0xcc, 0x33, 0x33, 0xff},\n        color.RGBA{0xcc, 0x33, 0x66, 0xff},\n        color.RGBA{0xcc, 0x33, 0x99, 0xff},\n        color.RGBA{0xcc, 0x33, 0xcc, 0xff},\n        color.RGBA{0xcc, 0x33, 0xff, 0xff},\n        color.RGBA{0xcc, 0x66, 0x00, 0xff},\n        color.RGBA{0xcc, 0x66, 0x33, 0xff},\n        color.RGBA{0xcc, 0x66, 0x66, 0xff},\n        color.RGBA{0xcc, 0x66, 0x99, 0xff},\n        color.RGBA{0xcc, 0x66, 0xcc, 0xff},\n        color.RGBA{0xcc, 0x66, 0xff, 0xff},\n        color.RGBA{0xcc, 0x99, 0x00, 0xff},\n        color.RGBA{0xcc, 0x99, 0x33, 0xff},\n        color.RGBA{0xcc, 0x99, 0x66, 0xff},\n        color.RGBA{0xcc, 0x99, 0x99, 0xff},\n        color.RGBA{0xcc, 0x99, 0xcc, 0xff},\n        color.RGBA{0xcc, 0x99, 0xff, 0xff},\n        color.RGBA{0xcc, 0xcc, 0x00, 0xff},\n        color.RGBA{0xcc, 0xcc, 0x33, 0xff},\n        color.RGBA{0xcc, 0xcc, 0x66, 0xff},\n        color.RGBA{0xcc, 0xcc, 0x99, 0xff},\n        color.RGBA{0xcc, 0xcc, 0xcc, 0xff},\n        color.RGBA{0xcc, 0xcc, 0xff, 0xff},\n        color.RGBA{0xcc, 0xff, 0x00, 0xff},\n        color.RGBA{0xcc, 0xff, 0x33, 0xff},\n        color.RGBA{0xcc, 0xff, 0x66, 0xff},\n        color.RGBA{0xcc, 0xff, 0x99, 0xff},\n        color.RGBA{0xcc, 0xff, 0xcc, 0xff},\n        color.RGBA{0xcc, 0xff, 0xff, 0xff},\n        color.RGBA{0xff, 0x00, 0x00, 0xff},\n        color.RGBA{0xff, 0x00, 0x33, 0xff},\n        color.RGBA{0xff, 0x00, 0x66, 0xff},\n        color.RGBA{0xff, 0x00, 0x99, 0xff},\n        color.RGBA{0xff, 0x00, 0xcc, 0xff},\n        color.RGBA{0xff, 0x00, 0xff, 0xff},\n        color.RGBA{0xff, 0x33, 0x00, 0xff},\n        color.RGBA{0xff, 0x33, 0x33, 0xff},\n        color.RGBA{0xff, 0x33, 0x66, 0xff},\n        color.RGBA{0xff, 0x33, 0x99, 0xff},\n        color.RGBA{0xff, 0x33, 0xcc, 0xff},\n        color.RGBA{0xff, 0x33, 0xff, 0xff},\n        color.RGBA{0xff, 0x66, 0x00, 0xff},\n        color.RGBA{0xff, 0x66, 0x33, 0xff},\n        color.RGBA{0xff, 0x66, 0x66, 0xff},\n        color.RGBA{0xff, 0x66, 0x99, 0xff},\n        color.RGBA{0xff, 0x66, 0xcc, 0xff},\n        color.RGBA{0xff, 0x66, 0xff, 0xff},\n        color.RGBA{0xff, 0x99, 0x00, 0xff},\n        color.RGBA{0xff, 0x99, 0x33, 0xff},\n        color.RGBA{0xff, 0x99, 0x66, 0xff},\n        color.RGBA{0xff, 0x99, 0x99, 0xff},\n        color.RGBA{0xff, 0x99, 0xcc, 0xff},\n        color.RGBA{0xff, 0x99, 0xff, 0xff},\n        color.RGBA{0xff, 0xcc, 0x00, 0xff},\n        color.RGBA{0xff, 0xcc, 0x33, 0xff},\n        color.RGBA{0xff, 0xcc, 0x66, 0xff},\n        color.RGBA{0xff, 0xcc, 0x99, 0xff},\n        color.RGBA{0xff, 0xcc, 0xcc, 0xff},\n        color.RGBA{0xff, 0xcc, 0xff, 0xff},\n        color.RGBA{0xff, 0xff, 0x00, 0xff},\n        color.RGBA{0xff, 0xff, 0x33, 0xff},\n        color.RGBA{0xff, 0xff, 0x66, 0xff},\n        color.RGBA{0xff, 0xff, 0x99, 0xff},\n        color.RGBA{0xff, 0xff, 0xcc, 0xff},\n        color.RGBA{0xff, 0xff, 0xff, 0xff},\n}</pre> <p> WebSafe is a 216-color palette that was popularized by early versions of Netscape Navigator. It is also known as the Netscape Color Cube. </p> <p> See <a href=\"http://en.wikipedia.org/wiki/Web_colors#Web-safe_colors\">http://en.wikipedia.org/wiki/Web_colors#Web-safe_colors</a> for details. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/image/color/palette/\" class=\"_attribution-link\">https://golang.org/pkg/image/color/palette/</a>\n  </p>\n</div>\n","math/index":"<h1>Package math</h1>     <ul id=\"short-nav\">\n<li><code>import \"math\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package math provides basic constants and mathematical functions. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#Abs\">func Abs(x float64) float64</a></li>\n<li><a href=\"#Acos\">func Acos(x float64) float64</a></li>\n<li><a href=\"#Acosh\">func Acosh(x float64) float64</a></li>\n<li><a href=\"#Asin\">func Asin(x float64) float64</a></li>\n<li><a href=\"#Asinh\">func Asinh(x float64) float64</a></li>\n<li><a href=\"#Atan\">func Atan(x float64) float64</a></li>\n<li><a href=\"#Atan2\">func Atan2(y, x float64) float64</a></li>\n<li><a href=\"#Atanh\">func Atanh(x float64) float64</a></li>\n<li><a href=\"#Cbrt\">func Cbrt(x float64) float64</a></li>\n<li><a href=\"#Ceil\">func Ceil(x float64) float64</a></li>\n<li><a href=\"#Copysign\">func Copysign(x, y float64) float64</a></li>\n<li><a href=\"#Cos\">func Cos(x float64) float64</a></li>\n<li><a href=\"#Cosh\">func Cosh(x float64) float64</a></li>\n<li><a href=\"#Dim\">func Dim(x, y float64) float64</a></li>\n<li><a href=\"#Erf\">func Erf(x float64) float64</a></li>\n<li><a href=\"#Erfc\">func Erfc(x float64) float64</a></li>\n<li><a href=\"#Exp\">func Exp(x float64) float64</a></li>\n<li><a href=\"#Exp2\">func Exp2(x float64) float64</a></li>\n<li><a href=\"#Expm1\">func Expm1(x float64) float64</a></li>\n<li><a href=\"#Float32bits\">func Float32bits(f float32) uint32</a></li>\n<li><a href=\"#Float32frombits\">func Float32frombits(b uint32) float32</a></li>\n<li><a href=\"#Float64bits\">func Float64bits(f float64) uint64</a></li>\n<li><a href=\"#Float64frombits\">func Float64frombits(b uint64) float64</a></li>\n<li><a href=\"#Floor\">func Floor(x float64) float64</a></li>\n<li><a href=\"#Frexp\">func Frexp(f float64) (frac float64, exp int)</a></li>\n<li><a href=\"#Gamma\">func Gamma(x float64) float64</a></li>\n<li><a href=\"#Hypot\">func Hypot(p, q float64) float64</a></li>\n<li><a href=\"#Ilogb\">func Ilogb(x float64) int</a></li>\n<li><a href=\"#Inf\">func Inf(sign int) float64</a></li>\n<li><a href=\"#IsInf\">func IsInf(f float64, sign int) bool</a></li>\n<li><a href=\"#IsNaN\">func IsNaN(f float64) (is bool)</a></li>\n<li><a href=\"#J0\">func J0(x float64) float64</a></li>\n<li><a href=\"#J1\">func J1(x float64) float64</a></li>\n<li><a href=\"#Jn\">func Jn(n int, x float64) float64</a></li>\n<li><a href=\"#Ldexp\">func Ldexp(frac float64, exp int) float64</a></li>\n<li><a href=\"#Lgamma\">func Lgamma(x float64) (lgamma float64, sign int)</a></li>\n<li><a href=\"#Log\">func Log(x float64) float64</a></li>\n<li><a href=\"#Log10\">func Log10(x float64) float64</a></li>\n<li><a href=\"#Log1p\">func Log1p(x float64) float64</a></li>\n<li><a href=\"#Log2\">func Log2(x float64) float64</a></li>\n<li><a href=\"#Logb\">func Logb(x float64) float64</a></li>\n<li><a href=\"#Max\">func Max(x, y float64) float64</a></li>\n<li><a href=\"#Min\">func Min(x, y float64) float64</a></li>\n<li><a href=\"#Mod\">func Mod(x, y float64) float64</a></li>\n<li><a href=\"#Modf\">func Modf(f float64) (int float64, frac float64)</a></li>\n<li><a href=\"#NaN\">func NaN() float64</a></li>\n<li><a href=\"#Nextafter\">func Nextafter(x, y float64) (r float64)</a></li>\n<li><a href=\"#Nextafter32\">func Nextafter32(x, y float32) (r float32)</a></li>\n<li><a href=\"#Pow\">func Pow(x, y float64) float64</a></li>\n<li><a href=\"#Pow10\">func Pow10(e int) float64</a></li>\n<li><a href=\"#Remainder\">func Remainder(x, y float64) float64</a></li>\n<li><a href=\"#Signbit\">func Signbit(x float64) bool</a></li>\n<li><a href=\"#Sin\">func Sin(x float64) float64</a></li>\n<li><a href=\"#Sincos\">func Sincos(x float64) (sin, cos float64)</a></li>\n<li><a href=\"#Sinh\">func Sinh(x float64) float64</a></li>\n<li><a href=\"#Sqrt\">func Sqrt(x float64) float64</a></li>\n<li><a href=\"#Tan\">func Tan(x float64) float64</a></li>\n<li><a href=\"#Tanh\">func Tanh(x float64) float64</a></li>\n<li><a href=\"#Trunc\">func Trunc(x float64) float64</a></li>\n<li><a href=\"#Y0\">func Y0(x float64) float64</a></li>\n<li><a href=\"#Y1\">func Y1(x float64) float64</a></li>\n<li><a href=\"#Yn\">func Yn(n int, x float64) float64</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/math/abs.go\">abs.go</a> <a href=\"https://golang.org/src/math/acosh.go\">acosh.go</a> <a href=\"https://golang.org/src/math/asin.go\">asin.go</a> <a href=\"https://golang.org/src/math/asinh.go\">asinh.go</a> <a href=\"https://golang.org/src/math/atan.go\">atan.go</a> <a href=\"https://golang.org/src/math/atan2.go\">atan2.go</a> <a href=\"https://golang.org/src/math/atanh.go\">atanh.go</a> <a href=\"https://golang.org/src/math/bits.go\">bits.go</a> <a href=\"https://golang.org/src/math/cbrt.go\">cbrt.go</a> <a href=\"https://golang.org/src/math/const.go\">const.go</a> <a href=\"https://golang.org/src/math/copysign.go\">copysign.go</a> <a href=\"https://golang.org/src/math/dim.go\">dim.go</a> <a href=\"https://golang.org/src/math/erf.go\">erf.go</a> <a href=\"https://golang.org/src/math/exp.go\">exp.go</a> <a href=\"https://golang.org/src/math/expm1.go\">expm1.go</a> <a href=\"https://golang.org/src/math/floor.go\">floor.go</a> <a href=\"https://golang.org/src/math/floor_asm.go\">floor_asm.go</a> <a href=\"https://golang.org/src/math/frexp.go\">frexp.go</a> <a href=\"https://golang.org/src/math/gamma.go\">gamma.go</a> <a href=\"https://golang.org/src/math/hypot.go\">hypot.go</a> <a href=\"https://golang.org/src/math/j0.go\">j0.go</a> <a href=\"https://golang.org/src/math/j1.go\">j1.go</a> <a href=\"https://golang.org/src/math/jn.go\">jn.go</a> <a href=\"https://golang.org/src/math/ldexp.go\">ldexp.go</a> <a href=\"https://golang.org/src/math/lgamma.go\">lgamma.go</a> <a href=\"https://golang.org/src/math/log.go\">log.go</a> <a href=\"https://golang.org/src/math/log10.go\">log10.go</a> <a href=\"https://golang.org/src/math/log1p.go\">log1p.go</a> <a href=\"https://golang.org/src/math/logb.go\">logb.go</a> <a href=\"https://golang.org/src/math/mod.go\">mod.go</a> <a href=\"https://golang.org/src/math/modf.go\">modf.go</a> <a href=\"https://golang.org/src/math/nextafter.go\">nextafter.go</a> <a href=\"https://golang.org/src/math/pow.go\">pow.go</a> <a href=\"https://golang.org/src/math/pow10.go\">pow10.go</a> <a href=\"https://golang.org/src/math/remainder.go\">remainder.go</a> <a href=\"https://golang.org/src/math/signbit.go\">signbit.go</a> <a href=\"https://golang.org/src/math/sin.go\">sin.go</a> <a href=\"https://golang.org/src/math/sincos.go\">sincos.go</a> <a href=\"https://golang.org/src/math/sinh.go\">sinh.go</a> <a href=\"https://golang.org/src/math/sqrt.go\">sqrt.go</a> <a href=\"https://golang.org/src/math/tan.go\">tan.go</a> <a href=\"https://golang.org/src/math/tanh.go\">tanh.go</a> <a href=\"https://golang.org/src/math/unsafe.go\">unsafe.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        E   = 2.71828182845904523536028747135266249775724709369995957496696763 // http://oeis.org/A001113\n        Pi  = 3.14159265358979323846264338327950288419716939937510582097494459 // http://oeis.org/A000796\n        Phi = 1.61803398874989484820458683436563811772030917980576286213544862 // http://oeis.org/A001622\n\n        Sqrt2   = 1.41421356237309504880168872420969807856967187537694807317667974 // http://oeis.org/A002193\n        SqrtE   = 1.64872127070012814684865078781416357165377610071014801157507931 // http://oeis.org/A019774\n        SqrtPi  = 1.77245385090551602729816748334114518279754945612238712821380779 // http://oeis.org/A002161\n        SqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038 // http://oeis.org/A139339\n\n        Ln2    = 0.693147180559945309417232121458176568075500134360255254120680009 // http://oeis.org/A002162\n        Log2E  = 1 / Ln2\n        Ln10   = 2.30258509299404568401799145468436420760110148862877297603332790 // http://oeis.org/A002392\n        Log10E = 1 / Ln10\n)</pre> <p> Mathematical constants. </p> <pre data-language=\"go\">const (\n        MaxFloat32             = 3.40282346638528859811704183484516925440e+38  // 2**127 * (2**24 - 1) / 2**23\n        SmallestNonzeroFloat32 = 1.401298464324817070923729583289916131280e-45 // 1 / 2**(127 - 1 + 23)\n\n        MaxFloat64             = 1.797693134862315708145274237317043567981e+308 // 2**1023 * (2**53 - 1) / 2**52\n        SmallestNonzeroFloat64 = 4.940656458412465441765687928682213723651e-324 // 1 / 2**(1023 - 1 + 52)\n)</pre> <p> Floating-point limit values. Max is the largest finite value representable by the type. SmallestNonzero is the smallest positive, non-zero value representable by the type. </p> <pre data-language=\"go\">const (\n        MaxInt8   = 1&lt;&lt;7 - 1\n        MinInt8   = -1 &lt;&lt; 7\n        MaxInt16  = 1&lt;&lt;15 - 1\n        MinInt16  = -1 &lt;&lt; 15\n        MaxInt32  = 1&lt;&lt;31 - 1\n        MinInt32  = -1 &lt;&lt; 31\n        MaxInt64  = 1&lt;&lt;63 - 1\n        MinInt64  = -1 &lt;&lt; 63\n        MaxUint8  = 1&lt;&lt;8 - 1\n        MaxUint16 = 1&lt;&lt;16 - 1\n        MaxUint32 = 1&lt;&lt;32 - 1\n        MaxUint64 = 1&lt;&lt;64 - 1\n)</pre> <p> Integer limit values. </p> <h2 id=\"Abs\">func Abs  </h2> <pre data-language=\"go\">func Abs(x float64) float64</pre> <p> Abs returns the absolute value of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Abs(±Inf) = +Inf\nAbs(NaN) = NaN\n</pre> <h2 id=\"Acos\">func Acos  </h2> <pre data-language=\"go\">func Acos(x float64) float64</pre> <p> Acos returns the arccosine, in radians, of x. </p> <p> Special case is: </p> <pre data-language=\"go\">Acos(x) = NaN if x &lt; -1 or x &gt; 1\n</pre> <h2 id=\"Acosh\">func Acosh  </h2> <pre data-language=\"go\">func Acosh(x float64) float64</pre> <p> Acosh returns the inverse hyperbolic cosine of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Acosh(+Inf) = +Inf\nAcosh(x) = NaN if x &lt; 1\nAcosh(NaN) = NaN\n</pre> <h2 id=\"Asin\">func Asin  </h2> <pre data-language=\"go\">func Asin(x float64) float64</pre> <p> Asin returns the arcsine, in radians, of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Asin(±0) = ±0\nAsin(x) = NaN if x &lt; -1 or x &gt; 1\n</pre> <h2 id=\"Asinh\">func Asinh  </h2> <pre data-language=\"go\">func Asinh(x float64) float64</pre> <p> Asinh returns the inverse hyperbolic sine of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Asinh(±0) = ±0\nAsinh(±Inf) = ±Inf\nAsinh(NaN) = NaN\n</pre> <h2 id=\"Atan\">func Atan  </h2> <pre data-language=\"go\">func Atan(x float64) float64</pre> <p> Atan returns the arctangent, in radians, of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Atan(±0) = ±0\nAtan(±Inf) = ±Pi/2\n</pre> <h2 id=\"Atan2\">func Atan2  </h2> <pre data-language=\"go\">func Atan2(y, x float64) float64</pre> <p> Atan2 returns the arc tangent of y/x, using the signs of the two to determine the quadrant of the return value. </p> <p> Special cases are (in order): </p> <pre data-language=\"go\">Atan2(y, NaN) = NaN\nAtan2(NaN, x) = NaN\nAtan2(+0, x&gt;=0) = +0\nAtan2(-0, x&gt;=0) = -0\nAtan2(+0, x&lt;=-0) = +Pi\nAtan2(-0, x&lt;=-0) = -Pi\nAtan2(y&gt;0, 0) = +Pi/2\nAtan2(y&lt;0, 0) = -Pi/2\nAtan2(+Inf, +Inf) = +Pi/4\nAtan2(-Inf, +Inf) = -Pi/4\nAtan2(+Inf, -Inf) = 3Pi/4\nAtan2(-Inf, -Inf) = -3Pi/4\nAtan2(y, +Inf) = 0\nAtan2(y&gt;0, -Inf) = +Pi\nAtan2(y&lt;0, -Inf) = -Pi\nAtan2(+Inf, x) = +Pi/2\nAtan2(-Inf, x) = -Pi/2\n</pre> <h2 id=\"Atanh\">func Atanh  </h2> <pre data-language=\"go\">func Atanh(x float64) float64</pre> <p> Atanh returns the inverse hyperbolic tangent of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Atanh(1) = +Inf\nAtanh(±0) = ±0\nAtanh(-1) = -Inf\nAtanh(x) = NaN if x &lt; -1 or x &gt; 1\nAtanh(NaN) = NaN\n</pre> <h2 id=\"Cbrt\">func Cbrt  </h2> <pre data-language=\"go\">func Cbrt(x float64) float64</pre> <p> Cbrt returns the cube root of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Cbrt(±0) = ±0\nCbrt(±Inf) = ±Inf\nCbrt(NaN) = NaN\n</pre> <h2 id=\"Ceil\">func Ceil  </h2> <pre data-language=\"go\">func Ceil(x float64) float64</pre> <p> Ceil returns the least integer value greater than or equal to x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Ceil(±0) = ±0\nCeil(±Inf) = ±Inf\nCeil(NaN) = NaN\n</pre> <h2 id=\"Copysign\">func Copysign  </h2> <pre data-language=\"go\">func Copysign(x, y float64) float64</pre> <p> Copysign returns a value with the magnitude of x and the sign of y. </p> <h2 id=\"Cos\">func Cos  </h2> <pre data-language=\"go\">func Cos(x float64) float64</pre> <p> Cos returns the cosine of the radian argument x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Cos(±Inf) = NaN\nCos(NaN) = NaN\n</pre> <h2 id=\"Cosh\">func Cosh  </h2> <pre data-language=\"go\">func Cosh(x float64) float64</pre> <p> Cosh returns the hyperbolic cosine of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Cosh(±0) = 1\nCosh(±Inf) = +Inf\nCosh(NaN) = NaN\n</pre> <h2 id=\"Dim\">func Dim  </h2> <pre data-language=\"go\">func Dim(x, y float64) float64</pre> <p> Dim returns the maximum of x-y or 0. </p> <p> Special cases are: </p> <pre data-language=\"go\">Dim(+Inf, +Inf) = NaN\nDim(-Inf, -Inf) = NaN\nDim(x, NaN) = Dim(NaN, x) = NaN\n</pre> <h2 id=\"Erf\">func Erf  </h2> <pre data-language=\"go\">func Erf(x float64) float64</pre> <p> Erf returns the error function of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Erf(+Inf) = 1\nErf(-Inf) = -1\nErf(NaN) = NaN\n</pre> <h2 id=\"Erfc\">func Erfc  </h2> <pre data-language=\"go\">func Erfc(x float64) float64</pre> <p> Erfc returns the complementary error function of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Erfc(+Inf) = 0\nErfc(-Inf) = 2\nErfc(NaN) = NaN\n</pre> <h2 id=\"Exp\">func Exp  </h2> <pre data-language=\"go\">func Exp(x float64) float64</pre> <p> Exp returns e**x, the base-e exponential of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Exp(+Inf) = +Inf\nExp(NaN) = NaN\n</pre> <p> Very large values overflow to 0 or +Inf. Very small values underflow to 1. </p> <h2 id=\"Exp2\">func Exp2  </h2> <pre data-language=\"go\">func Exp2(x float64) float64</pre> <p> Exp2 returns 2**x, the base-2 exponential of x. </p> <p> Special cases are the same as Exp. </p> <h2 id=\"Expm1\">func Expm1  </h2> <pre data-language=\"go\">func Expm1(x float64) float64</pre> <p> Expm1 returns e**x - 1, the base-e exponential of x minus 1. It is more accurate than Exp(x) - 1 when x is near zero. </p> <p> Special cases are: </p> <pre data-language=\"go\">Expm1(+Inf) = +Inf\nExpm1(-Inf) = -1\nExpm1(NaN) = NaN\n</pre> <p> Very large values overflow to -1 or +Inf. </p> <h2 id=\"Float32bits\">func Float32bits  </h2> <pre data-language=\"go\">func Float32bits(f float32) uint32</pre> <p> Float32bits returns the IEEE 754 binary representation of f. </p> <h2 id=\"Float32frombits\">func Float32frombits  </h2> <pre data-language=\"go\">func Float32frombits(b uint32) float32</pre> <p> Float32frombits returns the floating point number corresponding to the IEEE 754 binary representation b. </p> <h2 id=\"Float64bits\">func Float64bits  </h2> <pre data-language=\"go\">func Float64bits(f float64) uint64</pre> <p> Float64bits returns the IEEE 754 binary representation of f. </p> <h2 id=\"Float64frombits\">func Float64frombits  </h2> <pre data-language=\"go\">func Float64frombits(b uint64) float64</pre> <p> Float64frombits returns the floating point number corresponding the IEEE 754 binary representation b. </p> <h2 id=\"Floor\">func Floor  </h2> <pre data-language=\"go\">func Floor(x float64) float64</pre> <p> Floor returns the greatest integer value less than or equal to x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Floor(±0) = ±0\nFloor(±Inf) = ±Inf\nFloor(NaN) = NaN\n</pre> <h2 id=\"Frexp\">func Frexp  </h2> <pre data-language=\"go\">func Frexp(f float64) (frac float64, exp int)</pre> <p> Frexp breaks f into a normalized fraction and an integral power of two. It returns frac and exp satisfying f == frac × 2**exp, with the absolute value of frac in the interval [½, 1). </p> <p> Special cases are: </p> <pre data-language=\"go\">Frexp(±0) = ±0, 0\nFrexp(±Inf) = ±Inf, 0\nFrexp(NaN) = NaN, 0\n</pre> <h2 id=\"Gamma\">func Gamma  </h2> <pre data-language=\"go\">func Gamma(x float64) float64</pre> <p> Gamma returns the Gamma function of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Gamma(+Inf) = +Inf\nGamma(+0) = +Inf\nGamma(-0) = -Inf\nGamma(x) = NaN for integer x &lt; 0\nGamma(-Inf) = NaN\nGamma(NaN) = NaN\n</pre> <h2 id=\"Hypot\">func Hypot  </h2> <pre data-language=\"go\">func Hypot(p, q float64) float64</pre> <p> Hypot returns Sqrt(p*p + q*q), taking care to avoid unnecessary overflow and underflow. </p> <p> Special cases are: </p> <pre data-language=\"go\">Hypot(±Inf, q) = +Inf\nHypot(p, ±Inf) = +Inf\nHypot(NaN, q) = NaN\nHypot(p, NaN) = NaN\n</pre> <h2 id=\"Ilogb\">func Ilogb  </h2> <pre data-language=\"go\">func Ilogb(x float64) int</pre> <p> Ilogb returns the binary exponent of x as an integer. </p> <p> Special cases are: </p> <pre data-language=\"go\">Ilogb(±Inf) = MaxInt32\nIlogb(0) = MinInt32\nIlogb(NaN) = MaxInt32\n</pre> <h2 id=\"Inf\">func Inf  </h2> <pre data-language=\"go\">func Inf(sign int) float64</pre> <p> Inf returns positive infinity if sign &gt;= 0, negative infinity if sign &lt; 0. </p> <h2 id=\"IsInf\">func IsInf  </h2> <pre data-language=\"go\">func IsInf(f float64, sign int) bool</pre> <p> IsInf reports whether f is an infinity, according to sign. If sign &gt; 0, IsInf reports whether f is positive infinity. If sign &lt; 0, IsInf reports whether f is negative infinity. If sign == 0, IsInf reports whether f is either infinity. </p> <h2 id=\"IsNaN\">func IsNaN  </h2> <pre data-language=\"go\">func IsNaN(f float64) (is bool)</pre> <p> IsNaN reports whether f is an IEEE 754 “not-a-number” value. </p> <h2 id=\"J0\">func J0  </h2> <pre data-language=\"go\">func J0(x float64) float64</pre> <p> J0 returns the order-zero Bessel function of the first kind. </p> <p> Special cases are: </p> <pre data-language=\"go\">J0(±Inf) = 0\nJ0(0) = 1\nJ0(NaN) = NaN\n</pre> <h2 id=\"J1\">func J1  </h2> <pre data-language=\"go\">func J1(x float64) float64</pre> <p> J1 returns the order-one Bessel function of the first kind. </p> <p> Special cases are: </p> <pre data-language=\"go\">J1(±Inf) = 0\nJ1(NaN) = NaN\n</pre> <h2 id=\"Jn\">func Jn  </h2> <pre data-language=\"go\">func Jn(n int, x float64) float64</pre> <p> Jn returns the order-n Bessel function of the first kind. </p> <p> Special cases are: </p> <pre data-language=\"go\">Jn(n, ±Inf) = 0\nJn(n, NaN) = NaN\n</pre> <h2 id=\"Ldexp\">func Ldexp  </h2> <pre data-language=\"go\">func Ldexp(frac float64, exp int) float64</pre> <p> Ldexp is the inverse of Frexp. It returns frac × 2**exp. </p> <p> Special cases are: </p> <pre data-language=\"go\">Ldexp(±0, exp) = ±0\nLdexp(±Inf, exp) = ±Inf\nLdexp(NaN, exp) = NaN\n</pre> <h2 id=\"Lgamma\">func Lgamma  </h2> <pre data-language=\"go\">func Lgamma(x float64) (lgamma float64, sign int)</pre> <p> Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x). </p> <p> Special cases are: </p> <pre data-language=\"go\">Lgamma(+Inf) = +Inf\nLgamma(0) = +Inf\nLgamma(-integer) = +Inf\nLgamma(-Inf) = -Inf\nLgamma(NaN) = NaN\n</pre> <h2 id=\"Log\">func Log  </h2> <pre data-language=\"go\">func Log(x float64) float64</pre> <p> Log returns the natural logarithm of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Log(+Inf) = +Inf\nLog(0) = -Inf\nLog(x &lt; 0) = NaN\nLog(NaN) = NaN\n</pre> <h2 id=\"Log10\">func Log10  </h2> <pre data-language=\"go\">func Log10(x float64) float64</pre> <p> Log10 returns the decimal logarithm of x. The special cases are the same as for Log. </p> <h2 id=\"Log1p\">func Log1p  </h2> <pre data-language=\"go\">func Log1p(x float64) float64</pre> <p> Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than Log(1 + x) when x is near zero. </p> <p> Special cases are: </p> <pre data-language=\"go\">Log1p(+Inf) = +Inf\nLog1p(±0) = ±0\nLog1p(-1) = -Inf\nLog1p(x &lt; -1) = NaN\nLog1p(NaN) = NaN\n</pre> <h2 id=\"Log2\">func Log2  </h2> <pre data-language=\"go\">func Log2(x float64) float64</pre> <p> Log2 returns the binary logarithm of x. The special cases are the same as for Log. </p> <h2 id=\"Logb\">func Logb  </h2> <pre data-language=\"go\">func Logb(x float64) float64</pre> <p> Logb returns the binary exponent of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Logb(±Inf) = +Inf\nLogb(0) = -Inf\nLogb(NaN) = NaN\n</pre> <h2 id=\"Max\">func Max  </h2> <pre data-language=\"go\">func Max(x, y float64) float64</pre> <p> Max returns the larger of x or y. </p> <p> Special cases are: </p> <pre data-language=\"go\">Max(x, +Inf) = Max(+Inf, x) = +Inf\nMax(x, NaN) = Max(NaN, x) = NaN\nMax(+0, ±0) = Max(±0, +0) = +0\nMax(-0, -0) = -0\n</pre> <h2 id=\"Min\">func Min  </h2> <pre data-language=\"go\">func Min(x, y float64) float64</pre> <p> Min returns the smaller of x or y. </p> <p> Special cases are: </p> <pre data-language=\"go\">Min(x, -Inf) = Min(-Inf, x) = -Inf\nMin(x, NaN) = Min(NaN, x) = NaN\nMin(-0, ±0) = Min(±0, -0) = -0\n</pre> <h2 id=\"Mod\">func Mod  </h2> <pre data-language=\"go\">func Mod(x, y float64) float64</pre> <p> Mod returns the floating-point remainder of x/y. The magnitude of the result is less than y and its sign agrees with that of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Mod(±Inf, y) = NaN\nMod(NaN, y) = NaN\nMod(x, 0) = NaN\nMod(x, ±Inf) = x\nMod(x, NaN) = NaN\n</pre> <h2 id=\"Modf\">func Modf  </h2> <pre data-language=\"go\">func Modf(f float64) (int float64, frac float64)</pre> <p> Modf returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f. </p> <p> Special cases are: </p> <pre data-language=\"go\">Modf(±Inf) = ±Inf, NaN\nModf(NaN) = NaN, NaN\n</pre> <h2 id=\"NaN\">func NaN  </h2> <pre data-language=\"go\">func NaN() float64</pre> <p> NaN returns an IEEE 754 “not-a-number” value. </p> <h2 id=\"Nextafter\">func Nextafter  </h2> <pre data-language=\"go\">func Nextafter(x, y float64) (r float64)</pre> <p> Nextafter returns the next representable float64 value after x towards y. </p> <p> Special cases are: </p> <pre data-language=\"go\">Nextafter(x, x)   = x\nNextafter(NaN, y) = NaN\nNextafter(x, NaN) = NaN\n</pre> <h2 id=\"Nextafter32\">func Nextafter32  </h2> <pre data-language=\"go\">func Nextafter32(x, y float32) (r float32)</pre> <p> Nextafter32 returns the next representable float32 value after x towards y. </p> <p> Special cases are: </p> <pre data-language=\"go\">Nextafter32(x, x)   = x\nNextafter32(NaN, y) = NaN\nNextafter32(x, NaN) = NaN\n</pre> <h2 id=\"Pow\">func Pow  </h2> <pre data-language=\"go\">func Pow(x, y float64) float64</pre> <p> Pow returns x**y, the base-x exponential of y. </p> <p> Special cases are (in order): </p> <pre data-language=\"go\">Pow(x, ±0) = 1 for any x\nPow(1, y) = 1 for any y\nPow(x, 1) = x for any x\nPow(NaN, y) = NaN\nPow(x, NaN) = NaN\nPow(±0, y) = ±Inf for y an odd integer &lt; 0\nPow(±0, -Inf) = +Inf\nPow(±0, +Inf) = +0\nPow(±0, y) = +Inf for finite y &lt; 0 and not an odd integer\nPow(±0, y) = ±0 for y an odd integer &gt; 0\nPow(±0, y) = +0 for finite y &gt; 0 and not an odd integer\nPow(-1, ±Inf) = 1\nPow(x, +Inf) = +Inf for |x| &gt; 1\nPow(x, -Inf) = +0 for |x| &gt; 1\nPow(x, +Inf) = +0 for |x| &lt; 1\nPow(x, -Inf) = +Inf for |x| &lt; 1\nPow(+Inf, y) = +Inf for y &gt; 0\nPow(+Inf, y) = +0 for y &lt; 0\nPow(-Inf, y) = Pow(-0, -y)\nPow(x, y) = NaN for finite x &lt; 0 and finite non-integer y\n</pre> <h2 id=\"Pow10\">func Pow10  </h2> <pre data-language=\"go\">func Pow10(e int) float64</pre> <p> Pow10 returns 10**e, the base-10 exponential of e. </p> <p> Special cases are: </p> <pre data-language=\"go\">Pow10(e) = +Inf for e &gt; 309\nPow10(e) = 0 for e &lt; -324\n</pre> <h2 id=\"Remainder\">func Remainder  </h2> <pre data-language=\"go\">func Remainder(x, y float64) float64</pre> <p> Remainder returns the IEEE 754 floating-point remainder of x/y. </p> <p> Special cases are: </p> <pre data-language=\"go\">Remainder(±Inf, y) = NaN\nRemainder(NaN, y) = NaN\nRemainder(x, 0) = NaN\nRemainder(x, ±Inf) = x\nRemainder(x, NaN) = NaN\n</pre> <h2 id=\"Signbit\">func Signbit  </h2> <pre data-language=\"go\">func Signbit(x float64) bool</pre> <p> Signbit returns true if x is negative or negative zero. </p> <h2 id=\"Sin\">func Sin  </h2> <pre data-language=\"go\">func Sin(x float64) float64</pre> <p> Sin returns the sine of the radian argument x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Sin(±0) = ±0\nSin(±Inf) = NaN\nSin(NaN) = NaN\n</pre> <h2 id=\"Sincos\">func Sincos  </h2> <pre data-language=\"go\">func Sincos(x float64) (sin, cos float64)</pre> <p> Sincos returns Sin(x), Cos(x). </p> <p> Special cases are: </p> <pre data-language=\"go\">Sincos(±0) = ±0, 1\nSincos(±Inf) = NaN, NaN\nSincos(NaN) = NaN, NaN\n</pre> <h2 id=\"Sinh\">func Sinh  </h2> <pre data-language=\"go\">func Sinh(x float64) float64</pre> <p> Sinh returns the hyperbolic sine of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Sinh(±0) = ±0\nSinh(±Inf) = ±Inf\nSinh(NaN) = NaN\n</pre> <h2 id=\"Sqrt\">func Sqrt  </h2> <pre data-language=\"go\">func Sqrt(x float64) float64</pre> <p> Sqrt returns the square root of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Sqrt(+Inf) = +Inf\nSqrt(±0) = ±0\nSqrt(x &lt; 0) = NaN\nSqrt(NaN) = NaN\n</pre> <h2 id=\"Tan\">func Tan  </h2> <pre data-language=\"go\">func Tan(x float64) float64</pre> <p> Tan returns the tangent of the radian argument x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Tan(±0) = ±0\nTan(±Inf) = NaN\nTan(NaN) = NaN\n</pre> <h2 id=\"Tanh\">func Tanh  </h2> <pre data-language=\"go\">func Tanh(x float64) float64</pre> <p> Tanh returns the hyperbolic tangent of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Tanh(±0) = ±0\nTanh(±Inf) = ±1\nTanh(NaN) = NaN\n</pre> <h2 id=\"Trunc\">func Trunc  </h2> <pre data-language=\"go\">func Trunc(x float64) float64</pre> <p> Trunc returns the integer value of x. </p> <p> Special cases are: </p> <pre data-language=\"go\">Trunc(±0) = ±0\nTrunc(±Inf) = ±Inf\nTrunc(NaN) = NaN\n</pre> <h2 id=\"Y0\">func Y0  </h2> <pre data-language=\"go\">func Y0(x float64) float64</pre> <p> Y0 returns the order-zero Bessel function of the second kind. </p> <p> Special cases are: </p> <pre data-language=\"go\">Y0(+Inf) = 0\nY0(0) = -Inf\nY0(x &lt; 0) = NaN\nY0(NaN) = NaN\n</pre> <h2 id=\"Y1\">func Y1  </h2> <pre data-language=\"go\">func Y1(x float64) float64</pre> <p> Y1 returns the order-one Bessel function of the second kind. </p> <p> Special cases are: </p> <pre data-language=\"go\">Y1(+Inf) = 0\nY1(0) = -Inf\nY1(x &lt; 0) = NaN\nY1(NaN) = NaN\n</pre> <h2 id=\"Yn\">func Yn  </h2> <pre data-language=\"go\">func Yn(n int, x float64) float64</pre> <p> Yn returns the order-n Bessel function of the second kind. </p> <p> Special cases are: </p> <pre data-language=\"go\">Yn(n, +Inf) = 0\nYn(n &gt; 0, 0) = -Inf\nYn(n &lt; 0, 0) = +Inf if n is odd, -Inf if n is even\nY1(n, x &lt; 0) = NaN\nY1(n, NaN) = NaN\n</pre> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"big/index\">big</a> </td> <td class=\"pkg-synopsis\"> Package big implements arbitrary-precision arithmetic (big numbers). </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"cmplx/index\">cmplx</a> </td> <td class=\"pkg-synopsis\"> Package cmplx provides basic constants and mathematical functions for complex numbers. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"rand/index\">rand</a> </td> <td class=\"pkg-synopsis\"> Package rand implements pseudo-random number generators. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/math/\" class=\"_attribution-link\">https://golang.org/pkg/math/</a>\n  </p>\n</div>\n","net/http/httptest/index":"<h1>Package httptest</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/http/httptest\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package httptest provides utilities for HTTP testing. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#NewRequest\">func NewRequest(method, target string, body io.Reader) *http.Request</a></li>\n<li><a href=\"#ResponseRecorder\">type ResponseRecorder</a></li>\n<li> <a href=\"#NewRecorder\">func NewRecorder() *ResponseRecorder</a>\n</li>\n<li> <a href=\"#ResponseRecorder.Flush\">func (rw *ResponseRecorder) Flush()</a>\n</li>\n<li> <a href=\"#ResponseRecorder.Header\">func (rw *ResponseRecorder) Header() http.Header</a>\n</li>\n<li> <a href=\"#ResponseRecorder.Result\">func (rw *ResponseRecorder) Result() *http.Response</a>\n</li>\n<li> <a href=\"#ResponseRecorder.Write\">func (rw *ResponseRecorder) Write(buf []byte) (int, error)</a>\n</li>\n<li> <a href=\"#ResponseRecorder.WriteHeader\">func (rw *ResponseRecorder) WriteHeader(code int)</a>\n</li>\n<li> <a href=\"#ResponseRecorder.WriteString\">func (rw *ResponseRecorder) WriteString(str string) (int, error)</a>\n</li>\n<li><a href=\"#Server\">type Server</a></li>\n<li> <a href=\"#NewServer\">func NewServer(handler http.Handler) *Server</a>\n</li>\n<li> <a href=\"#NewTLSServer\">func NewTLSServer(handler http.Handler) *Server</a>\n</li>\n<li> <a href=\"#NewUnstartedServer\">func NewUnstartedServer(handler http.Handler) *Server</a>\n</li>\n<li> <a href=\"#Server.Close\">func (s *Server) Close()</a>\n</li>\n<li> <a href=\"#Server.CloseClientConnections\">func (s *Server) CloseClientConnections()</a>\n</li>\n<li> <a href=\"#Server.Start\">func (s *Server) Start()</a>\n</li>\n<li> <a href=\"#Server.StartTLS\">func (s *Server) StartTLS()</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_ResponseRecorder\">ResponseRecorder</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Server\">Server</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/http/httptest/httptest.go\">httptest.go</a> <a href=\"https://golang.org/src/net/http/httptest/recorder.go\">recorder.go</a> <a href=\"https://golang.org/src/net/http/httptest/server.go\">server.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const DefaultRemoteAddr = \"1.2.3.4\"</pre> <p> DefaultRemoteAddr is the default remote address to return in RemoteAddr if an explicit DefaultRemoteAddr isn't set on ResponseRecorder. </p> <h2 id=\"NewRequest\">func NewRequest  </h2> <pre data-language=\"go\">func NewRequest(method, target string, body io.Reader) *http.Request</pre> <p> NewRequest returns a new incoming server Request, suitable for passing to an http.Handler for testing. </p> <p> The target is the RFC 7230 \"request-target\": it may be either a path or an absolute URL. If target is an absolute URL, the host name from the URL is used. Otherwise, \"example.com\" is used. </p> <p> The TLS field is set to a non-nil dummy value if target has scheme \"https\". </p> <p> The Request.Proto is always HTTP/1.1. </p> <p> An empty method means \"GET\". </p> <p> The provided body may be nil. If the body is of type *bytes.Reader, *strings.Reader, or *bytes.Buffer, the Request.ContentLength is set. </p> <p> NewRequest panics on error for ease of use in testing, where a panic is acceptable. </p> <h2 id=\"ResponseRecorder\">type ResponseRecorder  </h2> <pre data-language=\"go\">type ResponseRecorder struct {\n        Code      int           // the HTTP response code from WriteHeader\n        HeaderMap http.Header   // the HTTP response headers\n        Body      *bytes.Buffer // if non-nil, the bytes.Buffer to append written data to\n        Flushed   bool\n        // contains filtered or unexported fields\n}</pre> <p> ResponseRecorder is an implementation of http.ResponseWriter that records its mutations for later inspection in tests. </p> <div id=\"example_ResponseRecorder\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n)\n\nfunc main() {\n\thandler := func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Error(w, \"something failed\", http.StatusInternalServerError)\n\t}\n\n\treq := httptest.NewRequest(\"GET\", \"http://example.com/foo\", nil)\n\tw := httptest.NewRecorder()\n\thandler(w, req)\n\n\tfmt.Printf(\"%d - %s\", w.Code, w.Body.String())\n}\n</pre> </div> </div> <h3 id=\"NewRecorder\">func <a href=\"https://golang.org/src/net/http/httptest/recorder.go?s=809:845#L17\">NewRecorder</a>  </h3> <pre data-language=\"go\">func NewRecorder() *ResponseRecorder</pre> <p> NewRecorder returns an initialized ResponseRecorder. </p> <h3 id=\"ResponseRecorder.Flush\">func (*ResponseRecorder) <a href=\"https://golang.org/src/net/http/httptest/recorder.go?s=3004:3039#L111\">Flush</a>  </h3> <pre data-language=\"go\">func (rw *ResponseRecorder) Flush()</pre> <p> Flush sets rw.Flushed to true. </p> <h3 id=\"ResponseRecorder.Header\">func (*ResponseRecorder) <a href=\"https://golang.org/src/net/http/httptest/recorder.go?s=1182:1230#L30\">Header</a>  </h3> <pre data-language=\"go\">func (rw *ResponseRecorder) Header() http.Header</pre> <p> Header returns the response headers. </p> <h3 id=\"ResponseRecorder.Result\">func (*ResponseRecorder) <a href=\"https://golang.org/src/net/http/httptest/recorder.go?s=3619:3670#L130\">Result</a>  </h3> <pre data-language=\"go\">func (rw *ResponseRecorder) Result() *http.Response</pre> <p> Result returns the response generated by the handler. </p> <p> The returned Response will have at least its StatusCode, Header, Body, and optionally Trailer populated. More fields may be populated in the future, so callers should not DeepEqual the result in tests. </p> <p> The Response.Header is a snapshot of the headers at the time of the first write call, or at the time of this call, if the handler never did a write. </p> <p> Result must only be called after the handler has finished running. </p> <h3 id=\"ResponseRecorder.Write\">func (*ResponseRecorder) <a href=\"https://golang.org/src/net/http/httptest/recorder.go?s=2061:2119#L69\">Write</a>  </h3> <pre data-language=\"go\">func (rw *ResponseRecorder) Write(buf []byte) (int, error)</pre> <p> Write always succeeds and writes to rw.Body, if not nil. </p> <h3 id=\"ResponseRecorder.WriteHeader\">func (*ResponseRecorder) <a href=\"https://golang.org/src/net/http/httptest/recorder.go?s=2553:2602#L88\">WriteHeader</a>  </h3> <pre data-language=\"go\">func (rw *ResponseRecorder) WriteHeader(code int)</pre> <p> WriteHeader sets rw.Code. After it is called, changing rw.Header will not affect rw.HeaderMap. </p> <h3 id=\"ResponseRecorder.WriteString\">func (*ResponseRecorder) <a href=\"https://golang.org/src/net/http/httptest/recorder.go?s=2283:2347#L78\">WriteString</a>  </h3> <pre data-language=\"go\">func (rw *ResponseRecorder) WriteString(str string) (int, error)</pre> <p> WriteString always succeeds and writes to rw.Body, if not nil. </p> <h2 id=\"Server\">type Server  </h2> <pre data-language=\"go\">type Server struct {\n        URL      string // base URL of form http://ipaddr:port with no trailing slash\n        Listener net.Listener\n\n        // TLS is the optional TLS configuration, populated with a new config\n        // after TLS is started. If set on an unstarted server before StartTLS\n        // is called, existing fields are copied into the new config.\n        TLS *tls.Config\n\n        // Config may be changed after calling NewUnstartedServer and\n        // before Start or StartTLS.\n        Config *http.Server\n        // contains filtered or unexported fields\n}</pre> <p> A Server is an HTTP server listening on a system-chosen port on the local loopback interface, for use in end-to-end HTTP tests. </p> <div id=\"example_Server\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n)\n\nfunc main() {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, client\")\n\t}))\n\tdefer ts.Close()\n\n\tres, err := http.Get(ts.URL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tgreeting, err := ioutil.ReadAll(res.Body)\n\tres.Body.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"%s\", greeting)\n}\n</pre> </div> </div> <h3 id=\"NewServer\">func <a href=\"https://golang.org/src/net/http/httptest/server.go?s=2049:2093#L63\">NewServer</a>  </h3> <pre data-language=\"go\">func NewServer(handler http.Handler) *Server</pre> <p> NewServer starts and returns a new Server. The caller should call Close when finished, to shut it down. </p> <h3 id=\"NewTLSServer\">func <a href=\"https://golang.org/src/net/http/httptest/server.go?s=3640:3687#L125\">NewTLSServer</a>  </h3> <pre data-language=\"go\">func NewTLSServer(handler http.Handler) *Server</pre> <p> NewTLSServer starts and returns a new Server using TLS. The caller should call Close when finished, to shut it down. </p> <h3 id=\"NewUnstartedServer\">func <a href=\"https://golang.org/src/net/http/httptest/server.go?s=2374:2427#L75\">NewUnstartedServer</a>  </h3> <pre data-language=\"go\">func NewUnstartedServer(handler http.Handler) *Server</pre> <p> NewUnstartedServer returns a new Server but doesn't start it. </p> <p> After changing its configuration, the caller should call Start or StartTLS. </p> <p> The caller should call Close when finished, to shut it down. </p> <h3 id=\"Server.Close\">func (*Server) <a href=\"https://golang.org/src/net/http/httptest/server.go?s=3924:3948#L137\">Close</a>  </h3> <pre data-language=\"go\">func (s *Server) Close()</pre> <p> Close shuts down the server and blocks until all outstanding requests on this server have completed. </p> <h3 id=\"Server.CloseClientConnections\">func (*Server) <a href=\"https://golang.org/src/net/http/httptest/server.go?s=6004:6045#L194\">CloseClientConnections</a>  </h3> <pre data-language=\"go\">func (s *Server) CloseClientConnections()</pre> <p> CloseClientConnections closes any open HTTP connections to the test Server. </p> <h3 id=\"Server.Start\">func (*Server) <a href=\"https://golang.org/src/net/http/httptest/server.go?s=2579:2603#L83\">Start</a>  </h3> <pre data-language=\"go\">func (s *Server) Start()</pre> <p> Start starts a server from NewUnstartedServer. </p> <h3 id=\"Server.StartTLS\">func (*Server) <a href=\"https://golang.org/src/net/http/httptest/server.go?s=2886:2913#L97\">StartTLS</a>  </h3> <pre data-language=\"go\">func (s *Server) StartTLS()</pre> <p> StartTLS starts TLS on a server from NewUnstartedServer. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/http/httptest/\" class=\"_attribution-link\">https://golang.org/pkg/net/http/httptest/</a>\n  </p>\n</div>\n","net/rpc/jsonrpc/index":"<h1>Package jsonrpc</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/rpc/jsonrpc\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package jsonrpc implements a JSON-RPC ClientCodec and ServerCodec for the rpc package. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Dial\">func Dial(network, address string) (*rpc.Client, error)</a></li>\n<li><a href=\"#NewClient\">func NewClient(conn io.ReadWriteCloser) *rpc.Client</a></li>\n<li><a href=\"#NewClientCodec\">func NewClientCodec(conn io.ReadWriteCloser) rpc.ClientCodec</a></li>\n<li><a href=\"#NewServerCodec\">func NewServerCodec(conn io.ReadWriteCloser) rpc.ServerCodec</a></li>\n<li><a href=\"#ServeConn\">func ServeConn(conn io.ReadWriteCloser)</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/rpc/jsonrpc/client.go\">client.go</a> <a href=\"https://golang.org/src/net/rpc/jsonrpc/server.go\">server.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Dial\">func Dial  </h2> <pre data-language=\"go\">func Dial(network, address string) (*rpc.Client, error)</pre> <p> Dial connects to a JSON-RPC server at the specified network address. </p> <h2 id=\"NewClient\">func NewClient  </h2> <pre data-language=\"go\">func NewClient(conn io.ReadWriteCloser) *rpc.Client</pre> <p> NewClient returns a new rpc.Client to handle requests to the set of services at the other end of the connection. </p> <h2 id=\"NewClientCodec\">func NewClientCodec  </h2> <pre data-language=\"go\">func NewClientCodec(conn io.ReadWriteCloser) rpc.ClientCodec</pre> <p> NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn. </p> <h2 id=\"NewServerCodec\">func NewServerCodec  </h2> <pre data-language=\"go\">func NewServerCodec(conn io.ReadWriteCloser) rpc.ServerCodec</pre> <p> NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn. </p> <h2 id=\"ServeConn\">func ServeConn  </h2> <pre data-language=\"go\">func ServeConn(conn io.ReadWriteCloser)</pre> <p> ServeConn runs the JSON-RPC server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/rpc/jsonrpc/\" class=\"_attribution-link\">https://golang.org/pkg/net/rpc/jsonrpc/</a>\n  </p>\n</div>\n","io/index":"<h1>Package io</h1>     <ul id=\"short-nav\">\n<li><code>import \"io\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package io provides basic interfaces to I/O primitives. Its primary job is to wrap existing implementations of such primitives, such as those in package os, into shared public interfaces that abstract the functionality, plus some other related primitives. </p> <p> Because these interfaces and primitives wrap lower-level operations with various implementations, unless otherwise informed clients should not assume they are safe for parallel execution. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Copy\">func Copy(dst Writer, src Reader) (written int64, err error)</a></li>\n<li><a href=\"#CopyBuffer\">func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)</a></li>\n<li><a href=\"#CopyN\">func CopyN(dst Writer, src Reader, n int64) (written int64, err error)</a></li>\n<li><a href=\"#ReadAtLeast\">func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)</a></li>\n<li><a href=\"#ReadFull\">func ReadFull(r Reader, buf []byte) (n int, err error)</a></li>\n<li><a href=\"#WriteString\">func WriteString(w Writer, s string) (n int, err error)</a></li>\n<li><a href=\"#ByteReader\">type ByteReader</a></li>\n<li><a href=\"#ByteScanner\">type ByteScanner</a></li>\n<li><a href=\"#ByteWriter\">type ByteWriter</a></li>\n<li><a href=\"#Closer\">type Closer</a></li>\n<li><a href=\"#LimitedReader\">type LimitedReader</a></li>\n<li> <a href=\"#LimitedReader.Read\">func (l *LimitedReader) Read(p []byte) (n int, err error)</a>\n</li>\n<li><a href=\"#PipeReader\">type PipeReader</a></li>\n<li> <a href=\"#Pipe\">func Pipe() (*PipeReader, *PipeWriter)</a>\n</li>\n<li> <a href=\"#PipeReader.Close\">func (r *PipeReader) Close() error</a>\n</li>\n<li> <a href=\"#PipeReader.CloseWithError\">func (r *PipeReader) CloseWithError(err error) error</a>\n</li>\n<li> <a href=\"#PipeReader.Read\">func (r *PipeReader) Read(data []byte) (n int, err error)</a>\n</li>\n<li><a href=\"#PipeWriter\">type PipeWriter</a></li>\n<li> <a href=\"#PipeWriter.Close\">func (w *PipeWriter) Close() error</a>\n</li>\n<li> <a href=\"#PipeWriter.CloseWithError\">func (w *PipeWriter) CloseWithError(err error) error</a>\n</li>\n<li> <a href=\"#PipeWriter.Write\">func (w *PipeWriter) Write(data []byte) (n int, err error)</a>\n</li>\n<li><a href=\"#ReadCloser\">type ReadCloser</a></li>\n<li><a href=\"#ReadSeeker\">type ReadSeeker</a></li>\n<li><a href=\"#ReadWriteCloser\">type ReadWriteCloser</a></li>\n<li><a href=\"#ReadWriteSeeker\">type ReadWriteSeeker</a></li>\n<li><a href=\"#ReadWriter\">type ReadWriter</a></li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li> <a href=\"#LimitReader\">func LimitReader(r Reader, n int64) Reader</a>\n</li>\n<li> <a href=\"#MultiReader\">func MultiReader(readers ...Reader) Reader</a>\n</li>\n<li> <a href=\"#TeeReader\">func TeeReader(r Reader, w Writer) Reader</a>\n</li>\n<li><a href=\"#ReaderAt\">type ReaderAt</a></li>\n<li><a href=\"#ReaderFrom\">type ReaderFrom</a></li>\n<li><a href=\"#RuneReader\">type RuneReader</a></li>\n<li><a href=\"#RuneScanner\">type RuneScanner</a></li>\n<li><a href=\"#SectionReader\">type SectionReader</a></li>\n<li> <a href=\"#NewSectionReader\">func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</a>\n</li>\n<li> <a href=\"#SectionReader.Read\">func (s *SectionReader) Read(p []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#SectionReader.ReadAt\">func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)</a>\n</li>\n<li> <a href=\"#SectionReader.Seek\">func (s *SectionReader) Seek(offset int64, whence int) (int64, error)</a>\n</li>\n<li> <a href=\"#SectionReader.Size\">func (s *SectionReader) Size() int64</a>\n</li>\n<li><a href=\"#Seeker\">type Seeker</a></li>\n<li><a href=\"#WriteCloser\">type WriteCloser</a></li>\n<li><a href=\"#WriteSeeker\">type WriteSeeker</a></li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#MultiWriter\">func MultiWriter(writers ...Writer) Writer</a>\n</li>\n<li><a href=\"#WriterAt\">type WriterAt</a></li>\n<li><a href=\"#WriterTo\">type WriterTo</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Copy\">Copy</a></dd> <dd><a class=\"exampleLink\" href=\"#example_CopyBuffer\">CopyBuffer</a></dd> <dd><a class=\"exampleLink\" href=\"#example_CopyN\">CopyN</a></dd> <dd><a class=\"exampleLink\" href=\"#example_LimitReader\">LimitReader</a></dd> <dd><a class=\"exampleLink\" href=\"#example_MultiReader\">MultiReader</a></dd> <dd><a class=\"exampleLink\" href=\"#example_MultiWriter\">MultiWriter</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ReadAtLeast\">ReadAtLeast</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ReadFull\">ReadFull</a></dd> <dd><a class=\"exampleLink\" href=\"#example_SectionReader\">SectionReader</a></dd> <dd><a class=\"exampleLink\" href=\"#example_SectionReader_ReadAt\">SectionReader.ReadAt</a></dd> <dd><a class=\"exampleLink\" href=\"#example_SectionReader_Seek\">SectionReader.Seek</a></dd> <dd><a class=\"exampleLink\" href=\"#example_TeeReader\">TeeReader</a></dd> <dd><a class=\"exampleLink\" href=\"#example_WriteString\">WriteString</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/io/io.go\">io.go</a> <a href=\"https://golang.org/src/io/multi.go\">multi.go</a> <a href=\"https://golang.org/src/io/pipe.go\">pipe.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        SeekStart   = 0 // seek relative to the origin of the file\n        SeekCurrent = 1 // seek relative to the current offset\n        SeekEnd     = 2 // seek relative to the end\n)</pre> <p> Seek whence values. </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var EOF = errors.New(\"EOF\")</pre> <p> EOF is the error returned by Read when no more input is available. Functions should return EOF only to signal a graceful end of input. If the EOF occurs unexpectedly in a structured data stream, the appropriate error is either ErrUnexpectedEOF or some other error giving more detail. </p> <pre data-language=\"go\">var ErrClosedPipe = errors.New(\"io: read/write on closed pipe\")</pre> <p> ErrClosedPipe is the error used for read or write operations on a closed pipe. </p> <pre data-language=\"go\">var ErrNoProgress = errors.New(\"multiple Read calls return no data or error\")</pre> <p> ErrNoProgress is returned by some clients of an io.Reader when many calls to Read have failed to return any data or error, usually the sign of a broken io.Reader implementation. </p> <pre data-language=\"go\">var ErrShortBuffer = errors.New(\"short buffer\")</pre> <p> ErrShortBuffer means that a read required a longer buffer than was provided. </p> <pre data-language=\"go\">var ErrShortWrite = errors.New(\"short write\")</pre> <p> ErrShortWrite means that a write accepted fewer bytes than requested but failed to return an explicit error. </p> <pre data-language=\"go\">var ErrUnexpectedEOF = errors.New(\"unexpected EOF\")</pre> <p> ErrUnexpectedEOF means that EOF was encountered in the middle of reading a fixed-size block or data structure. </p> <h2 id=\"Copy\">func Copy  </h2> <pre data-language=\"go\">func Copy(dst Writer, src Reader) (written int64, err error)</pre> <p> Copy copies from src to dst until either EOF is reached on src or an error occurs. It returns the number of bytes copied and the first error encountered while copying, if any. </p> <p> A successful Copy returns err == nil, not err == EOF. Because Copy is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported. </p> <p> If src implements the WriterTo interface, the copy is implemented by calling src.WriteTo(dst). Otherwise, if dst implements the ReaderFrom interface, the copy is implemented by calling dst.ReadFrom(src). </p> <div id=\"example_Copy\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"some io.Reader stream to be read\\n\")\n\n\tif _, err := io.Copy(os.Stdout, r); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"CopyBuffer\">func CopyBuffer  </h2> <pre data-language=\"go\">func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)</pre> <p> CopyBuffer is identical to Copy except that it stages through the provided buffer (if one is required) rather than allocating a temporary one. If buf is nil, one is allocated; otherwise if it has zero length, CopyBuffer panics. </p> <div id=\"example_CopyBuffer\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr1 := strings.NewReader(\"first reader\\n\")\n\tr2 := strings.NewReader(\"second reader\\n\")\n\tbuf := make([]byte, 8)\n\n\t// buf is used here...\n\tif _, err := io.CopyBuffer(os.Stdout, r1, buf); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// ... reused here also. No need to allocate an extra buffer.\n\tif _, err := io.CopyBuffer(os.Stdout, r2, buf); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"CopyN\">func CopyN  </h2> <pre data-language=\"go\">func CopyN(dst Writer, src Reader, n int64) (written int64, err error)</pre> <p> CopyN copies n bytes (or until an error) from src to dst. It returns the number of bytes copied and the earliest error encountered while copying. On return, written == n if and only if err == nil. </p> <p> If dst implements the ReaderFrom interface, the copy is implemented using it. </p> <div id=\"example_CopyN\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"some io.Reader stream to be read\")\n\n\tif _, err := io.CopyN(os.Stdout, r, 5); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"ReadAtLeast\">func ReadAtLeast  </h2> <pre data-language=\"go\">func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)</pre> <p> ReadAtLeast reads from r into buf until it has read at least min bytes. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading fewer than min bytes, ReadAtLeast returns ErrUnexpectedEOF. If min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer. On return, n &gt;= min if and only if err == nil. </p> <div id=\"example_ReadAtLeast\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"some io.Reader stream to be read\\n\")\n\n\tbuf := make([]byte, 33)\n\tif _, err := io.ReadAtLeast(r, buf, 4); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"%s\\n\", buf)\n\n\t// buffer smaller than minimal read size.\n\tshortBuf := make([]byte, 3)\n\tif _, err := io.ReadAtLeast(r, shortBuf, 4); err != nil {\n\t\tfmt.Println(\"error:\", err)\n\t}\n\n\t// minimal read size bigger than io.Reader stream\n\tlongBuf := make([]byte, 64)\n\tif _, err := io.ReadAtLeast(r, longBuf, 64); err != nil {\n\t\tfmt.Println(\"error:\", err)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"ReadFull\">func ReadFull  </h2> <pre data-language=\"go\">func ReadFull(r Reader, buf []byte) (n int, err error)</pre> <p> ReadFull reads exactly len(buf) bytes from r into buf. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, ReadFull returns ErrUnexpectedEOF. On return, n == len(buf) if and only if err == nil. </p> <div id=\"example_ReadFull\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"some io.Reader stream to be read\\n\")\n\n\tbuf := make([]byte, 4)\n\tif _, err := io.ReadFull(r, buf); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"%s\\n\", buf)\n\n\t// minimal read size bigger than io.Reader stream\n\tlongBuf := make([]byte, 64)\n\tif _, err := io.ReadFull(r, longBuf); err != nil {\n\t\tfmt.Println(\"error:\", err)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"WriteString\">func WriteString  </h2> <pre data-language=\"go\">func WriteString(w Writer, s string) (n int, err error)</pre> <p> WriteString writes the contents of the string s to w, which accepts a slice of bytes. If w implements a WriteString method, it is invoked directly. Otherwise, w.Write is called exactly once. </p> <div id=\"example_WriteString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\tio.WriteString(os.Stdout, \"Hello World\")\n\n}\n</pre> </div> </div> <h2 id=\"ByteReader\">type ByteReader  </h2> <pre data-language=\"go\">type ByteReader interface {\n        ReadByte() (byte, error)\n}</pre> <p> ByteReader is the interface that wraps the ReadByte method. </p> <p> ReadByte reads and returns the next byte from the input. </p> <h2 id=\"ByteScanner\">type ByteScanner  </h2> <pre data-language=\"go\">type ByteScanner interface {\n        ByteReader\n        UnreadByte() error\n}</pre> <p> ByteScanner is the interface that adds the UnreadByte method to the basic ReadByte method. </p> <p> UnreadByte causes the next call to ReadByte to return the same byte as the previous call to ReadByte. It may be an error to call UnreadByte twice without an intervening call to ReadByte. </p> <h2 id=\"ByteWriter\">type ByteWriter  </h2> <pre data-language=\"go\">type ByteWriter interface {\n        WriteByte(c byte) error\n}</pre> <p> ByteWriter is the interface that wraps the WriteByte method. </p> <h2 id=\"Closer\">type Closer  </h2> <pre data-language=\"go\">type Closer interface {\n        Close() error\n}</pre> <p> Closer is the interface that wraps the basic Close method. </p> <p> The behavior of Close after the first call is undefined. Specific implementations may document their own behavior. </p> <h2 id=\"LimitedReader\">type LimitedReader  </h2> <pre data-language=\"go\">type LimitedReader struct {\n        R Reader // underlying reader\n        N int64  // max bytes remaining\n}</pre> <p> A LimitedReader reads from R but limits the amount of data returned to just N bytes. Each call to Read updates N to reflect the new amount remaining. </p> <h3 id=\"LimitedReader.Read\">func (*LimitedReader) <a href=\"https://golang.org/src/io/io.go?s=14366:14423#L419\">Read</a>  </h3> <pre data-language=\"go\">func (l *LimitedReader) Read(p []byte) (n int, err error)</pre> <h2 id=\"PipeReader\">type PipeReader  </h2> <pre data-language=\"go\">type PipeReader struct {\n        // contains filtered or unexported fields\n}</pre> <p> A PipeReader is the read half of a pipe. </p> <h3 id=\"Pipe\">func <a href=\"https://golang.org/src/io/pipe.go?s=4438:4476#L174\">Pipe</a>  </h3> <pre data-language=\"go\">func Pipe() (*PipeReader, *PipeWriter)</pre> <p> Pipe creates a synchronous in-memory pipe. It can be used to connect code expecting an io.Reader with code expecting an io.Writer. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering. It is safe to call Read and Write in parallel with each other or with Close. Close will complete once pending I/O is done. Parallel calls to Read, and parallel calls to Write, are also safe: the individual calls will be gated sequentially. </p> <h3 id=\"PipeReader.Close\">func (*PipeReader) <a href=\"https://golang.org/src/io/pipe.go?s=2743:2777#L124\">Close</a>  </h3> <pre data-language=\"go\">func (r *PipeReader) Close() error</pre> <p> Close closes the reader; subsequent writes to the write half of the pipe will return the error ErrClosedPipe. </p> <h3 id=\"PipeReader.CloseWithError\">func (*PipeReader) <a href=\"https://golang.org/src/io/pipe.go?s=2928:2980#L130\">CloseWithError</a>  </h3> <pre data-language=\"go\">func (r *PipeReader) CloseWithError(err error) error</pre> <p> CloseWithError closes the reader; subsequent writes to the write half of the pipe will return the error err. </p> <h3 id=\"PipeReader.Read\">func (*PipeReader) <a href=\"https://golang.org/src/io/pipe.go?s=2541:2598#L118\">Read</a>  </h3> <pre data-language=\"go\">func (r *PipeReader) Read(data []byte) (n int, err error)</pre> <p> Read implements the standard Read interface: it reads data from the pipe, blocking until a writer arrives or the write end is closed. If the write end is closed with an error, that error is returned as err; otherwise err is EOF. </p> <h2 id=\"PipeWriter\">type PipeWriter  </h2> <pre data-language=\"go\">type PipeWriter struct {\n        // contains filtered or unexported fields\n}</pre> <p> A PipeWriter is the write half of a pipe. </p> <h3 id=\"PipeWriter.Close\">func (*PipeWriter) <a href=\"https://golang.org/src/io/pipe.go?s=3563:3597#L151\">Close</a>  </h3> <pre data-language=\"go\">func (w *PipeWriter) Close() error</pre> <p> Close closes the writer; subsequent reads from the read half of the pipe will return no bytes and EOF. </p> <h3 id=\"PipeWriter.CloseWithError\">func (*PipeWriter) <a href=\"https://golang.org/src/io/pipe.go?s=3827:3879#L160\">CloseWithError</a>  </h3> <pre data-language=\"go\">func (w *PipeWriter) CloseWithError(err error) error</pre> <p> CloseWithError closes the writer; subsequent reads from the read half of the pipe will return no bytes and the error err, or EOF if err is nil. </p> <p> CloseWithError always returns nil. </p> <h3 id=\"PipeWriter.Write\">func (*PipeWriter) <a href=\"https://golang.org/src/io/pipe.go?s=3366:3424#L145\">Write</a>  </h3> <pre data-language=\"go\">func (w *PipeWriter) Write(data []byte) (n int, err error)</pre> <p> Write implements the standard Write interface: it writes data to the pipe, blocking until readers have consumed all the data or the read end is closed. If the read end is closed with an error, that err is returned as err; otherwise err is ErrClosedPipe. </p> <h2 id=\"ReadCloser\">type ReadCloser  </h2> <pre data-language=\"go\">type ReadCloser interface {\n        Reader\n        Closer\n}</pre> <p> ReadCloser is the interface that groups the basic Read and Close methods. </p> <h2 id=\"ReadSeeker\">type ReadSeeker  </h2> <pre data-language=\"go\">type ReadSeeker interface {\n        Reader\n        Seeker\n}</pre> <p> ReadSeeker is the interface that groups the basic Read and Seek methods. </p> <h2 id=\"ReadWriteCloser\">type ReadWriteCloser  </h2> <pre data-language=\"go\">type ReadWriteCloser interface {\n        Reader\n        Writer\n        Closer\n}</pre> <p> ReadWriteCloser is the interface that groups the basic Read, Write and Close methods. </p> <h2 id=\"ReadWriteSeeker\">type ReadWriteSeeker  </h2> <pre data-language=\"go\">type ReadWriteSeeker interface {\n        Reader\n        Writer\n        Seeker\n}</pre> <p> ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods. </p> <h2 id=\"ReadWriter\">type ReadWriter  </h2> <pre data-language=\"go\">type ReadWriter interface {\n        Reader\n        Writer\n}</pre> <p> ReadWriter is the interface that groups the basic Read and Write methods. </p> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader interface {\n        Read(p []byte) (n int, err error)\n}</pre> <p> Reader is the interface that wraps the basic Read method. </p> <p> Read reads up to len(p) bytes into p. It returns the number of bytes read (0 &lt;= n &lt;= len(p)) and any error encountered. Even if Read returns n &lt; len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more. </p> <p> When Read encounters an error or end-of-file condition after successfully reading n &gt; 0 bytes, it returns the number of bytes read. It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF. </p> <p> Callers should always process the n &gt; 0 bytes returned before considering the error err. Doing so correctly handles I/O errors that happen after reading some bytes and also both of the allowed EOF behaviors. </p> <p> Implementations of Read are discouraged from returning a zero byte count with a nil error, except when len(p) == 0. Callers should treat a return of 0 and nil as indicating that nothing happened; in particular it does not indicate EOF. </p> <p> Implementations must not retain p. </p> <h3 id=\"LimitReader\">func <a href=\"https://golang.org/src/io/io.go?s=14036:14078#L409\">LimitReader</a>  </h3> <pre data-language=\"go\">func LimitReader(r Reader, n int64) Reader</pre> <p> LimitReader returns a Reader that reads from r but stops with EOF after n bytes. The underlying implementation is a *LimitedReader. </p> <div id=\"example_LimitReader\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"some io.Reader stream to be read\\n\")\n\tlr := io.LimitReader(r, 4)\n\n\tif _, err := io.Copy(os.Stdout, lr); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n}\n</pre> </div> </div> <h3 id=\"MultiReader\">func <a href=\"https://golang.org/src/io/multi.go?s=1018:1060#L28\">MultiReader</a>  </h3> <pre data-language=\"go\">func MultiReader(readers ...Reader) Reader</pre> <p> MultiReader returns a Reader that's the logical concatenation of the provided input readers. They're read sequentially. Once all inputs have returned EOF, Read will return EOF. If any of the readers return a non-nil, non-EOF error, Read will return that error. </p> <div id=\"example_MultiReader\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr1 := strings.NewReader(\"first reader \")\n\tr2 := strings.NewReader(\"second reader \")\n\tr3 := strings.NewReader(\"third reader\\n\")\n\tr := io.MultiReader(r1, r2, r3)\n\n\tif _, err := io.Copy(os.Stdout, r); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n}\n</pre> </div> </div> <h3 id=\"TeeReader\">func <a href=\"https://golang.org/src/io/io.go?s=16387:16428#L503\">TeeReader</a>  </h3> <pre data-language=\"go\">func TeeReader(r Reader, w Writer) Reader</pre> <p> TeeReader returns a Reader that writes to w what it reads from r. All reads from r performed through it are matched with corresponding writes to w. There is no internal buffering - the write must complete before the read completes. Any error encountered while writing is reported as a read error. </p> <div id=\"example_TeeReader\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"some io.Reader stream to be read\\n\")\n\tvar buf bytes.Buffer\n\ttee := io.TeeReader(r, &amp;buf)\n\n\tprintall := func(r io.Reader) {\n\t\tb, err := ioutil.ReadAll(r)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tfmt.Printf(\"%s\", b)\n\t}\n\n\tprintall(tee)\n\tprintall(&amp;buf)\n\n}\n</pre> </div> </div> <h2 id=\"ReaderAt\">type ReaderAt  </h2> <pre data-language=\"go\">type ReaderAt interface {\n        ReadAt(p []byte, off int64) (n int, err error)\n}</pre> <p> ReaderAt is the interface that wraps the basic ReadAt method. </p> <p> ReadAt reads len(p) bytes into p starting at offset off in the underlying input source. It returns the number of bytes read (0 &lt;= n &lt;= len(p)) and any error encountered. </p> <p> When ReadAt returns n &lt; len(p), it returns a non-nil error explaining why more bytes were not returned. In this respect, ReadAt is stricter than Read. </p> <p> Even if ReadAt returns n &lt; len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, ReadAt blocks until either all the data is available or an error occurs. In this respect ReadAt is different from Read. </p> <p> If the n = len(p) bytes returned by ReadAt are at the end of the input source, ReadAt may return either err == EOF or err == nil. </p> <p> If ReadAt is reading from an input source with a seek offset, ReadAt should not affect nor be affected by the underlying seek offset. </p> <p> Clients of ReadAt can execute parallel ReadAt calls on the same input source. </p> <p> Implementations must not retain p. </p> <h2 id=\"ReaderFrom\">type ReaderFrom  </h2> <pre data-language=\"go\">type ReaderFrom interface {\n        ReadFrom(r Reader) (n int64, err error)\n}</pre> <p> ReaderFrom is the interface that wraps the ReadFrom method. </p> <p> ReadFrom reads data from r until EOF or error. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. </p> <p> The Copy function uses ReaderFrom if available. </p> <h2 id=\"RuneReader\">type RuneReader  </h2> <pre data-language=\"go\">type RuneReader interface {\n        ReadRune() (r rune, size int, err error)\n}</pre> <p> RuneReader is the interface that wraps the ReadRune method. </p> <p> ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If no character is available, err will be set. </p> <h2 id=\"RuneScanner\">type RuneScanner  </h2> <pre data-language=\"go\">type RuneScanner interface {\n        RuneReader\n        UnreadRune() error\n}</pre> <p> RuneScanner is the interface that adds the UnreadRune method to the basic ReadRune method. </p> <p> UnreadRune causes the next call to ReadRune to return the same rune as the previous call to ReadRune. It may be an error to call UnreadRune twice without an intervening call to ReadRune. </p> <h2 id=\"SectionReader\">type SectionReader  </h2> <pre data-language=\"go\">type SectionReader struct {\n        // contains filtered or unexported fields\n}</pre> <p> SectionReader implements Read, Seek, and ReadAt on a section of an underlying ReaderAt. </p> <div id=\"example_SectionReader\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"some io.Reader stream to be read\\n\")\n\ts := io.NewSectionReader(r, 5, 17)\n\n\tif _, err := io.Copy(os.Stdout, s); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n}\n</pre> </div> </div> <h3 id=\"NewSectionReader\">func <a href=\"https://golang.org/src/io/io.go?s=14676:14744#L433\">NewSectionReader</a>  </h3> <pre data-language=\"go\">func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</pre> <p> NewSectionReader returns a SectionReader that reads from r starting at offset off and stops with EOF after n bytes. </p> <h3 id=\"SectionReader.Read\">func (*SectionReader) <a href=\"https://golang.org/src/io/io.go?s=14975:15032#L446\">Read</a>  </h3> <pre data-language=\"go\">func (s *SectionReader) Read(p []byte) (n int, err error)</pre> <h3 id=\"SectionReader.ReadAt\">func (*SectionReader) <a href=\"https://golang.org/src/io/io.go?s=15636:15706#L479\">ReadAt</a>  </h3> <pre data-language=\"go\">func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)</pre> <div id=\"example_SectionReader_ReadAt\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"some io.Reader stream to be read\\n\")\n\ts := io.NewSectionReader(r, 5, 16)\n\n\tbuf := make([]byte, 6)\n\tif _, err := s.ReadAt(buf, 10); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"%s\\n\", buf)\n\n}\n</pre> </div> </div> <h3 id=\"SectionReader.Seek\">func (*SectionReader) <a href=\"https://golang.org/src/io/io.go?s=15309:15378#L461\">Seek</a>  </h3> <pre data-language=\"go\">func (s *SectionReader) Seek(offset int64, whence int) (int64, error)</pre> <div id=\"example_SectionReader_Seek\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"some io.Reader stream to be read\\n\")\n\ts := io.NewSectionReader(r, 5, 16)\n\n\tif _, err := s.Seek(10, io.SeekStart); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tbuf := make([]byte, 6)\n\tif _, err := s.Read(buf); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"%s\\n\", buf)\n\n}\n</pre> </div> </div> <h3 id=\"SectionReader.Size\">func (*SectionReader) <a href=\"https://golang.org/src/io/io.go?s=16009:16045#L496\">Size</a>  </h3> <pre data-language=\"go\">func (s *SectionReader) Size() int64</pre> <p> Size returns the size of the section in bytes. </p> <h2 id=\"Seeker\">type Seeker  </h2> <pre data-language=\"go\">type Seeker interface {\n        Seek(offset int64, whence int) (int64, error)\n}</pre> <p> Seeker is the interface that wraps the basic Seek method. </p> <p> Seek sets the offset for the next Read or Write to offset, interpreted according to whence: SeekStart means relative to the start of the file, SeekCurrent means relative to the current offset, and SeekEnd means relative to the end. Seek returns the new offset relative to the start of the file and an error, if any. </p> <p> Seeking to an offset before the start of the file is an error. Seeking to any positive offset is legal, but the behavior of subsequent I/O operations on the underlying object is implementation-dependent. </p> <h2 id=\"WriteCloser\">type WriteCloser  </h2> <pre data-language=\"go\">type WriteCloser interface {\n        Writer\n        Closer\n}</pre> <p> WriteCloser is the interface that groups the basic Write and Close methods. </p> <h2 id=\"WriteSeeker\">type WriteSeeker  </h2> <pre data-language=\"go\">type WriteSeeker interface {\n        Writer\n        Seeker\n}</pre> <p> WriteSeeker is the interface that groups the basic Write and Seek methods. </p> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer interface {\n        Write(p []byte) (n int, err error)\n}</pre> <p> Writer is the interface that wraps the basic Write method. </p> <p> Write writes len(p) bytes from p to the underlying data stream. It returns the number of bytes written from p (0 &lt;= n &lt;= len(p)) and any error encountered that caused the write to stop early. Write must return a non-nil error if it returns n &lt; len(p). Write must not modify the slice data, even temporarily. </p> <p> Implementations must not retain p. </p> <h3 id=\"MultiWriter\">func <a href=\"https://golang.org/src/io/multi.go?s=1992:2034#L78\">MultiWriter</a>  </h3> <pre data-language=\"go\">func MultiWriter(writers ...Writer) Writer</pre> <p> MultiWriter creates a writer that duplicates its writes to all the provided writers, similar to the Unix tee(1) command. </p> <div id=\"example_MultiWriter\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"some io.Reader stream to be read\\n\")\n\n\tvar buf1, buf2 bytes.Buffer\n\tw := io.MultiWriter(&amp;buf1, &amp;buf2)\n\n\tif _, err := io.Copy(w, r); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Print(buf1.String())\n\tfmt.Print(buf2.String())\n\n}\n</pre> </div> </div> <h2 id=\"WriterAt\">type WriterAt  </h2> <pre data-language=\"go\">type WriterAt interface {\n        WriteAt(p []byte, off int64) (n int, err error)\n}</pre> <p> WriterAt is the interface that wraps the basic WriteAt method. </p> <p> WriteAt writes len(p) bytes from p to the underlying data stream at offset off. It returns the number of bytes written from p (0 &lt;= n &lt;= len(p)) and any error encountered that caused the write to stop early. WriteAt must return a non-nil error if it returns n &lt; len(p). </p> <p> If WriteAt is writing to a destination with a seek offset, WriteAt should not affect nor be affected by the underlying seek offset. </p> <p> Clients of WriteAt can execute parallel WriteAt calls on the same destination if the ranges do not overlap. </p> <p> Implementations must not retain p. </p> <h2 id=\"WriterTo\">type WriterTo  </h2> <pre data-language=\"go\">type WriterTo interface {\n        WriteTo(w Writer) (n int64, err error)\n}</pre> <p> WriterTo is the interface that wraps the WriteTo method. </p> <p> WriteTo writes data to w until there's no more data to write or when an error occurs. The return value n is the number of bytes written. Any error encountered during the write is also returned. </p> <p> The Copy function uses WriterTo if available. </p> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"ioutil/index\">ioutil</a> </td> <td class=\"pkg-synopsis\"> Package ioutil implements some I/O utility functions. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/io/\" class=\"_attribution-link\">https://golang.org/pkg/io/</a>\n  </p>\n</div>\n","net/mail/index":"<h1>Package mail</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/mail\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package mail implements parsing of mail messages. </p> <p> For the most part, this package follows the syntax as specified by RFC 5322 and extended by RFC 6532. Notable divergences: </p> <pre data-language=\"go\">* Obsolete address formats are not parsed, including addresses with\n  embedded route information.\n* Group addresses are not parsed.\n* The full range of spacing (the CFWS syntax element) is not supported,\n  such as breaking addresses across lines.\n* No unicode normalization is performed.\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#ParseAddressList\">func ParseAddressList(list string) ([]*Address, error)</a></li>\n<li><a href=\"#Address\">type Address</a></li>\n<li> <a href=\"#ParseAddress\">func ParseAddress(address string) (*Address, error)</a>\n</li>\n<li> <a href=\"#Address.String\">func (a *Address) String() string</a>\n</li>\n<li><a href=\"#AddressParser\">type AddressParser</a></li>\n<li> <a href=\"#AddressParser.Parse\">func (p *AddressParser) Parse(address string) (*Address, error)</a>\n</li>\n<li> <a href=\"#AddressParser.ParseList\">func (p *AddressParser) ParseList(list string) ([]*Address, error)</a>\n</li>\n<li><a href=\"#Header\">type Header</a></li>\n<li> <a href=\"#Header.AddressList\">func (h Header) AddressList(key string) ([]*Address, error)</a>\n</li>\n<li> <a href=\"#Header.Date\">func (h Header) Date() (time.Time, error)</a>\n</li>\n<li> <a href=\"#Header.Get\">func (h Header) Get(key string) string</a>\n</li>\n<li><a href=\"#Message\">type Message</a></li>\n<li> <a href=\"#ReadMessage\">func ReadMessage(r io.Reader) (msg *Message, err error)</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_ParseAddress\">ParseAddress</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ParseAddressList\">ParseAddressList</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ReadMessage\">ReadMessage</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/mail/message.go\">message.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrHeaderNotPresent = errors.New(\"mail: header not in message\")</pre> <h2 id=\"ParseAddressList\">func ParseAddressList  </h2> <pre data-language=\"go\">func ParseAddressList(list string) ([]*Address, error)</pre> <p> ParseAddressList parses the given string as a list of addresses. </p> <div id=\"example_ParseAddressList\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/mail\"\n)\n\nfunc main() {\n\tconst list = \"Alice &lt;alice@example.com&gt;, Bob &lt;bob@example.com&gt;, Eve &lt;eve@example.com&gt;\"\n\temails, err := mail.ParseAddressList(list)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, v := range emails {\n\t\tfmt.Println(v.Name, v.Address)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"Address\">type Address  </h2> <pre data-language=\"go\">type Address struct {\n        Name    string // Proper name; may be empty.\n        Address string // user@domain\n}</pre> <p> Address represents a single mail address. An address such as \"Barry Gibbs &lt;bg@example.com&gt;\" is represented as Address{Name: \"Barry Gibbs\", Address: \"bg@example.com\"}. </p> <h3 id=\"ParseAddress\">func <a href=\"https://golang.org/src/net/mail/message.go?s=3640:3691#L133\">ParseAddress</a>  </h3> <pre data-language=\"go\">func ParseAddress(address string) (*Address, error)</pre> <p> Parses a single RFC 5322 address, e.g. \"Barry Gibbs &lt;bg@example.com&gt;\" </p> <div id=\"example_ParseAddress\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/mail\"\n)\n\nfunc main() {\n\te, err := mail.ParseAddress(\"Alice &lt;alice@example.com&gt;\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(e.Name, e.Address)\n\n}\n</pre> </div> </div> <h3 id=\"Address.String\">func (*Address) <a href=\"https://golang.org/src/net/mail/message.go?s=4818:4851#L163\">String</a>  </h3> <pre data-language=\"go\">func (a *Address) String() string</pre> <p> String formats the address as a valid RFC 5322 address. If the address's name contains non-ASCII characters the name will be rendered according to RFC 2047. </p> <h2 id=\"AddressParser\">type AddressParser  </h2> <pre data-language=\"go\">type AddressParser struct {\n        // WordDecoder optionally specifies a decoder for RFC 2047 encoded-words.\n        WordDecoder *mime.WordDecoder\n}</pre> <p> An AddressParser is an RFC 5322 address parser. </p> <h3 id=\"AddressParser.Parse\">func (*AddressParser) <a href=\"https://golang.org/src/net/mail/message.go?s=4225:4288#L150\">Parse</a>  </h3> <pre data-language=\"go\">func (p *AddressParser) Parse(address string) (*Address, error)</pre> <p> Parse parses a single RFC 5322 address of the form \"Gogh Fir &lt;gf@example.com&gt;\" or \"foo@example.com\". </p> <h3 id=\"AddressParser.ParseList\">func (*AddressParser) <a href=\"https://golang.org/src/net/mail/message.go?s=4510:4576#L156\">ParseList</a>  </h3> <pre data-language=\"go\">func (p *AddressParser) ParseList(list string) ([]*Address, error)</pre> <p> ParseList parses the given string as a list of comma-separated addresses of the form \"Gogh Fir &lt;gf@example.com&gt;\" or \"foo@example.com\". </p> <h2 id=\"Header\">type Header  </h2> <pre data-language=\"go\">type Header map[string][]string</pre> <p> A Header represents the key-value pairs in a mail message header. </p> <h3 id=\"Header.AddressList\">func (Header) <a href=\"https://golang.org/src/net/mail/message.go?s=3122:3181#L116\">AddressList</a>  </h3> <pre data-language=\"go\">func (h Header) AddressList(key string) ([]*Address, error)</pre> <p> AddressList parses the named header field as a list of addresses. </p> <h3 id=\"Header.Date\">func (Header) <a href=\"https://golang.org/src/net/mail/message.go?s=2900:2941#L107\">Date</a>  </h3> <pre data-language=\"go\">func (h Header) Date() (time.Time, error)</pre> <p> Date parses the Date header field. </p> <h3 id=\"Header.Get\">func (Header) <a href=\"https://golang.org/src/net/mail/message.go?s=2708:2746#L100\">Get</a>  </h3> <pre data-language=\"go\">func (h Header) Get(key string) string</pre> <p> Get gets the first value associated with the given key. If there are no values associated with the key, Get returns \"\". </p> <h2 id=\"Message\">type Message  </h2> <pre data-language=\"go\">type Message struct {\n        Header Header\n        Body   io.Reader\n}</pre> <p> A Message represents a parsed mail message. </p> <h3 id=\"ReadMessage\">func <a href=\"https://golang.org/src/net/mail/message.go?s=1158:1213#L43\">ReadMessage</a>  </h3> <pre data-language=\"go\">func ReadMessage(r io.Reader) (msg *Message, err error)</pre> <p> ReadMessage reads a message from r. The headers are parsed, and the body of the message will be available for reading from r. </p> <div id=\"example_ReadMessage\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/mail\"\n\t\"strings\"\n)\n\nfunc main() {\n\tmsg := `Date: Mon, 23 Jun 2015 11:40:36 -0400\nFrom: Gopher &lt;from@example.com&gt;\nTo: Another Gopher &lt;to@example.com&gt;\nSubject: Gophers at Gophercon\n\nMessage body\n`\n\n\tr := strings.NewReader(msg)\n\tm, err := mail.ReadMessage(r)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\theader := m.Header\n\tfmt.Println(\"Date:\", header.Get(\"Date\"))\n\tfmt.Println(\"From:\", header.Get(\"From\"))\n\tfmt.Println(\"To:\", header.Get(\"To\"))\n\tfmt.Println(\"Subject:\", header.Get(\"Subject\"))\n\n\tbody, err := ioutil.ReadAll(m.Body)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"%s\", body)\n\n}\n</pre> </div> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/mail/\" class=\"_attribution-link\">https://golang.org/pkg/net/mail/</a>\n  </p>\n</div>\n","net/http/fcgi/index":"<h1>Package fcgi</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/http/fcgi\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package fcgi implements the FastCGI protocol. Currently only the responder role is supported. The protocol is defined at <a href=\"http://www.fastcgi.com/drupal/node/6?q=node/22\">http://www.fastcgi.com/drupal/node/6?q=node/22</a> </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Serve\">func Serve(l net.Listener, handler http.Handler) error</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/http/fcgi/child.go\">child.go</a> <a href=\"https://golang.org/src/net/http/fcgi/fcgi.go\">fcgi.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrConnClosed = errors.New(\"fcgi: connection to web server closed\")</pre> <p> ErrConnClosed is returned by Read when a handler attempts to read the body of a request after the connection to the web server has been closed. </p> <pre data-language=\"go\">var ErrRequestAborted = errors.New(\"fcgi: request aborted by web server\")</pre> <p> ErrRequestAborted is returned by Read when a handler attempts to read the body of a request that has been aborted by the web server. </p> <h2 id=\"Serve\">func Serve  </h2> <pre data-language=\"go\">func Serve(l net.Listener, handler http.Handler) error</pre> <p> Serve accepts incoming FastCGI connections on the listener l, creating a new goroutine for each. The goroutine reads requests and then calls handler to reply to them. If l is nil, Serve accepts connections from os.Stdin. If handler is nil, http.DefaultServeMux is used. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/http/fcgi/\" class=\"_attribution-link\">https://golang.org/pkg/net/http/fcgi/</a>\n  </p>\n</div>\n","html/template/index":"<h1>Package template</h1>     <ul id=\"short-nav\">\n<li><code>import \"html/template\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package template (html/template) implements data-driven templates for generating HTML output safe against code injection. It provides the same interface as package text/template and should be used instead of text/template whenever the output is HTML. </p> <p> The documentation here focuses on the security features of the package. For information about how to program the templates themselves, see the documentation for text/template. </p> <h3 id=\"hdr-Introduction\">Introduction</h3> <p> This package wraps package text/template so you can share its template API to parse and execute HTML templates safely. </p> <pre data-language=\"go\">tmpl, err := template.New(\"name\").Parse(...)\n// Error checking elided\nerr = tmpl.Execute(out, data)\n</pre> <p> If successful, tmpl will now be injection-safe. Otherwise, err is an error defined in the docs for ErrorCode. </p> <p> HTML templates treat data values as plain text which should be encoded so they can be safely embedded in an HTML document. The escaping is contextual, so actions can appear within JavaScript, CSS, and URI contexts. </p> <p> The security model used by this package assumes that template authors are trusted, while Execute's data parameter is not. More details are provided below. </p> <p> Example </p> <pre data-language=\"go\">import \"text/template\"\n...\nt, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\nerr = t.ExecuteTemplate(out, \"T\", \"&lt;script&gt;alert('you have been pwned')&lt;/script&gt;\")\n</pre> <p> produces </p> <pre data-language=\"go\">Hello, &lt;script&gt;alert('you have been pwned')&lt;/script&gt;!\n</pre> <p> but the contextual autoescaping in html/template </p> <pre data-language=\"go\">import \"html/template\"\n...\nt, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\nerr = t.ExecuteTemplate(out, \"T\", \"&lt;script&gt;alert('you have been pwned')&lt;/script&gt;\")\n</pre> <p> produces safe, escaped HTML output </p> <pre data-language=\"go\">Hello, &amp;lt;script&amp;gt;alert(&amp;#39;you have been pwned&amp;#39;)&amp;lt;/script&amp;gt;!\n</pre> <h3 id=\"hdr-Contexts\">Contexts</h3> <p> This package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt </p> <pre data-language=\"go\">&lt;a href=\"/search?q={{.}}\"&gt;{{.}}&lt;/a&gt;\n</pre> <p> At parse time each {{.}} is overwritten to add escaping functions as necessary. In this case it becomes </p> <pre data-language=\"go\">&lt;a href=\"/search?q={{. | urlquery}}\"&gt;{{. | html}}&lt;/a&gt;\n</pre> <h3 id=\"hdr-Errors\">Errors</h3> <p> See the documentation of ErrorCode for details. </p> <h3 id=\"hdr-A_fuller_picture\">A fuller picture</h3> <p> The rest of this package comment may be skipped on first reading; it includes details necessary to understand escaping contexts and error messages. Most users will not need to understand these details. </p> <h3 id=\"hdr-Contexts\">Contexts</h3> <p> Assuming {{.}} is `O'Reilly: How are &lt;i&gt;you&lt;/i&gt;?`, the table below shows how {{.}} appears when used in the context to the left. </p> <pre data-language=\"go\">Context                          {{.}} After\n{{.}}                            O'Reilly: How are &amp;lt;i&amp;gt;you&amp;lt;/i&amp;gt;?\n&lt;a title='{{.}}'&gt;                O&amp;#39;Reilly: How are you?\n&lt;a href=\"/{{.}}\"&gt;                O&amp;#39;Reilly: How are %3ci%3eyou%3c/i%3e?\n&lt;a href=\"?q={{.}}\"&gt;              O&amp;#39;Reilly%3a%20How%20are%3ci%3e...%3f\n&lt;a onx='f(\"{{.}}\")'&gt;             O\\x27Reilly: How are \\x3ci\\x3eyou...?\n&lt;a onx='f({{.}})'&gt;               \"O\\x27Reilly: How are \\x3ci\\x3eyou...?\"\n&lt;a onx='pattern = /{{.}}/;'&gt;     O\\x27Reilly: How are \\x3ci\\x3eyou...\\x3f\n</pre> <p> If used in an unsafe context, then the value might be filtered out: </p> <pre data-language=\"go\">Context                          {{.}} After\n&lt;a href=\"{{.}}\"&gt;                 #ZgotmplZ\n</pre> <p> since \"O'Reilly:\" is not an allowed protocol like \"http:\". </p> <p> If {{.}} is the innocuous word, `left`, then it can appear more widely, </p> <pre data-language=\"go\">Context                              {{.}} After\n{{.}}                                left\n&lt;a title='{{.}}'&gt;                    left\n&lt;a href='{{.}}'&gt;                     left\n&lt;a href='/{{.}}'&gt;                    left\n&lt;a href='?dir={{.}}'&gt;                left\n&lt;a style=\"border-{{.}}: 4px\"&gt;        left\n&lt;a style=\"align: {{.}}\"&gt;             left\n&lt;a style=\"background: '{{.}}'&gt;       left\n&lt;a style=\"background: url('{{.}}')&gt;  left\n&lt;style&gt;p.{{.}} {color:red}&lt;/style&gt;   left\n</pre> <p> Non-string values can be used in JavaScript contexts. If {{.}} is </p> <pre data-language=\"go\">struct{A,B string}{ \"foo\", \"bar\" }\n</pre> <p> in the escaped template </p> <pre data-language=\"go\">&lt;script&gt;var pair = {{.}};&lt;/script&gt;\n</pre> <p> then the template output is </p> <pre data-language=\"go\">&lt;script&gt;var pair = {\"A\": \"foo\", \"B\": \"bar\"};&lt;/script&gt;\n</pre> <p> See package json to understand how non-string content is marshalled for embedding in JavaScript contexts. </p> <h3 id=\"hdr-Typed_Strings\">Typed Strings</h3> <p> By default, this package assumes that all pipelines produce a plain text string. It adds escaping pipeline stages necessary to correctly and safely embed that plain text string in the appropriate context. </p> <p> When a data value is not plain text, you can make sure it is not over-escaped by marking it with its type. </p> <p> Types HTML, JS, URL, and others from content.go can carry safe content that is exempted from escaping. </p> <p> The template </p> <pre data-language=\"go\">Hello, {{.}}!\n</pre> <p> can be invoked with </p> <pre data-language=\"go\">tmpl.Execute(out, template.HTML(`&lt;b&gt;World&lt;/b&gt;`))\n</pre> <p> to produce </p> <pre data-language=\"go\">Hello, &lt;b&gt;World&lt;/b&gt;!\n</pre> <p> instead of the </p> <pre data-language=\"go\">Hello, &amp;lt;b&amp;gt;World&amp;lt;b&amp;gt;!\n</pre> <p> that would have been produced if {{.}} was a regular string. </p> <h3 id=\"hdr-Security_Model\">Security Model</h3> <p> <a href=\"https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition\">https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition</a> defines \"safe\" as used by this package. </p> <p> This package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data: </p> <p> Structure Preservation Property: \"... when a template author writes an HTML tag in a safe templating language, the browser will interpret the corresponding portion of the output as a tag regardless of the values of untrusted data, and similarly for other structures such as attribute boundaries and JS and CSS string boundaries.\" </p> <p> Code Effect Property: \"... only code specified by the template author should run as a result of injecting the template output into a page and all code specified by the template author should run as a result of the same.\" </p> <p> Least Surprise Property: \"A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who knows that contextual autoescaping happens should be able to look at a {{.}} and correctly infer what sanitization happens.\" </p> </div> </div> <div id=\"example_\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"html/template\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tconst tpl = `\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset=\"UTF-8\"&gt;\n\t\t&lt;title&gt;{{.Title}}&lt;/title&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t\t{{range .Items}}&lt;div&gt;{{ . }}&lt;/div&gt;{{else}}&lt;div&gt;&lt;strong&gt;no rows&lt;/strong&gt;&lt;/div&gt;{{end}}\n\t&lt;/body&gt;\n&lt;/html&gt;`\n\n\tcheck := func(err error) {\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\tt, err := template.New(\"webpage\").Parse(tpl)\n\tcheck(err)\n\n\tdata := struct {\n\t\tTitle string\n\t\tItems []string\n\t}{\n\t\tTitle: \"My page\",\n\t\tItems: []string{\n\t\t\t\"My photos\",\n\t\t\t\"My blog\",\n\t\t},\n\t}\n\n\terr = t.Execute(os.Stdout, data)\n\tcheck(err)\n\n\tnoItems := struct {\n\t\tTitle string\n\t\tItems []string\n\t}{\n\t\tTitle: \"My another page\",\n\t\tItems: []string{},\n\t}\n\n\terr = t.Execute(os.Stdout, noItems)\n\tcheck(err)\n\n}\n</pre> </div> </div> <div id=\"example__autoescaping\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Autoescaping)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"html/template\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tcheck := func(err error) {\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\tt, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n\tcheck(err)\n\terr = t.ExecuteTemplate(os.Stdout, \"T\", \"&lt;script&gt;alert('you have been pwned')&lt;/script&gt;\")\n\tcheck(err)\n}\n</pre> </div> </div> <div id=\"example__escape\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Escape)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"os\"\n)\n\nfunc main() {\n\tconst s = `\"Fran &amp; Freddie's Diner\" &lt;tasty@example.com&gt;`\n\tv := []interface{}{`\"Fran &amp; Freddie's Diner\"`, ' ', `&lt;tasty@example.com&gt;`}\n\n\tfmt.Println(template.HTMLEscapeString(s))\n\ttemplate.HTMLEscape(os.Stdout, []byte(s))\n\tfmt.Fprintln(os.Stdout, \"\")\n\tfmt.Println(template.HTMLEscaper(v...))\n\n\tfmt.Println(template.JSEscapeString(s))\n\ttemplate.JSEscape(os.Stdout, []byte(s))\n\tfmt.Fprintln(os.Stdout, \"\")\n\tfmt.Println(template.JSEscaper(v...))\n\n\tfmt.Println(template.URLQueryEscaper(v...))\n\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#HTMLEscape\">func HTMLEscape(w io.Writer, b []byte)</a></li>\n<li><a href=\"#HTMLEscapeString\">func HTMLEscapeString(s string) string</a></li>\n<li><a href=\"#HTMLEscaper\">func HTMLEscaper(args ...interface{}) string</a></li>\n<li><a href=\"#IsTrue\">func IsTrue(val interface{}) (truth, ok bool)</a></li>\n<li><a href=\"#JSEscape\">func JSEscape(w io.Writer, b []byte)</a></li>\n<li><a href=\"#JSEscapeString\">func JSEscapeString(s string) string</a></li>\n<li><a href=\"#JSEscaper\">func JSEscaper(args ...interface{}) string</a></li>\n<li><a href=\"#URLQueryEscaper\">func URLQueryEscaper(args ...interface{}) string</a></li>\n<li><a href=\"#CSS\">type CSS</a></li>\n<li><a href=\"#Error\">type Error</a></li>\n<li> <a href=\"#Error.Error\">func (e *Error) Error() string</a>\n</li>\n<li><a href=\"#ErrorCode\">type ErrorCode</a></li>\n<li><a href=\"#FuncMap\">type FuncMap</a></li>\n<li><a href=\"#HTML\">type HTML</a></li>\n<li><a href=\"#HTMLAttr\">type HTMLAttr</a></li>\n<li><a href=\"#JS\">type JS</a></li>\n<li><a href=\"#JSStr\">type JSStr</a></li>\n<li><a href=\"#Template\">type Template</a></li>\n<li> <a href=\"#Must\">func Must(t *Template, err error) *Template</a>\n</li>\n<li> <a href=\"#New\">func New(name string) *Template</a>\n</li>\n<li> <a href=\"#ParseFiles\">func ParseFiles(filenames ...string) (*Template, error)</a>\n</li>\n<li> <a href=\"#ParseGlob\">func ParseGlob(pattern string) (*Template, error)</a>\n</li>\n<li> <a href=\"#Template.AddParseTree\">func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)</a>\n</li>\n<li> <a href=\"#Template.Clone\">func (t *Template) Clone() (*Template, error)</a>\n</li>\n<li> <a href=\"#Template.DefinedTemplates\">func (t *Template) DefinedTemplates() string</a>\n</li>\n<li> <a href=\"#Template.Delims\">func (t *Template) Delims(left, right string) *Template</a>\n</li>\n<li> <a href=\"#Template.Execute\">func (t *Template) Execute(wr io.Writer, data interface{}) error</a>\n</li>\n<li> <a href=\"#Template.ExecuteTemplate\">func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error</a>\n</li>\n<li> <a href=\"#Template.Funcs\">func (t *Template) Funcs(funcMap FuncMap) *Template</a>\n</li>\n<li> <a href=\"#Template.Lookup\">func (t *Template) Lookup(name string) *Template</a>\n</li>\n<li> <a href=\"#Template.Name\">func (t *Template) Name() string</a>\n</li>\n<li> <a href=\"#Template.New\">func (t *Template) New(name string) *Template</a>\n</li>\n<li> <a href=\"#Template.Option\">func (t *Template) Option(opt ...string) *Template</a>\n</li>\n<li> <a href=\"#Template.Parse\">func (t *Template) Parse(src string) (*Template, error)</a>\n</li>\n<li> <a href=\"#Template.ParseFiles\">func (t *Template) ParseFiles(filenames ...string) (*Template, error)</a>\n</li>\n<li> <a href=\"#Template.ParseGlob\">func (t *Template) ParseGlob(pattern string) (*Template, error)</a>\n</li>\n<li> <a href=\"#Template.Templates\">func (t *Template) Templates() []*Template</a>\n</li>\n<li><a href=\"#URL\">type URL</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_\">Package</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Template_block\">Template (Block)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Template_glob\">Template (Glob)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Template_helpers\">Template (Helpers)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Template_parsefiles\">Template (Parsefiles)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Template_share\">Template (Share)</a></dd> <dd><a class=\"exampleLink\" href=\"#example__autoescaping\">Package (Autoescaping)</a></dd> <dd><a class=\"exampleLink\" href=\"#example__escape\">Package (Escape)</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/html/template/attr.go\">attr.go</a> <a href=\"https://golang.org/src/html/template/content.go\">content.go</a> <a href=\"https://golang.org/src/html/template/context.go\">context.go</a> <a href=\"https://golang.org/src/html/template/css.go\">css.go</a> <a href=\"https://golang.org/src/html/template/doc.go\">doc.go</a> <a href=\"https://golang.org/src/html/template/error.go\">error.go</a> <a href=\"https://golang.org/src/html/template/escape.go\">escape.go</a> <a href=\"https://golang.org/src/html/template/html.go\">html.go</a> <a href=\"https://golang.org/src/html/template/js.go\">js.go</a> <a href=\"https://golang.org/src/html/template/template.go\">template.go</a> <a href=\"https://golang.org/src/html/template/transition.go\">transition.go</a> <a href=\"https://golang.org/src/html/template/url.go\">url.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"HTMLEscape\">func HTMLEscape  </h2> <pre data-language=\"go\">func HTMLEscape(w io.Writer, b []byte)</pre> <p> HTMLEscape writes to w the escaped HTML equivalent of the plain text data b. </p> <h2 id=\"HTMLEscapeString\">func HTMLEscapeString  </h2> <pre data-language=\"go\">func HTMLEscapeString(s string) string</pre> <p> HTMLEscapeString returns the escaped HTML equivalent of the plain text data s. </p> <h2 id=\"HTMLEscaper\">func HTMLEscaper  </h2> <pre data-language=\"go\">func HTMLEscaper(args ...interface{}) string</pre> <p> HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments. </p> <h2 id=\"IsTrue\">func IsTrue  </h2> <pre data-language=\"go\">func IsTrue(val interface{}) (truth, ok bool)</pre> <p> IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions. </p> <h2 id=\"JSEscape\">func JSEscape  </h2> <pre data-language=\"go\">func JSEscape(w io.Writer, b []byte)</pre> <p> JSEscape writes to w the escaped JavaScript equivalent of the plain text data b. </p> <h2 id=\"JSEscapeString\">func JSEscapeString  </h2> <pre data-language=\"go\">func JSEscapeString(s string) string</pre> <p> JSEscapeString returns the escaped JavaScript equivalent of the plain text data s. </p> <h2 id=\"JSEscaper\">func JSEscaper  </h2> <pre data-language=\"go\">func JSEscaper(args ...interface{}) string</pre> <p> JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments. </p> <h2 id=\"URLQueryEscaper\">func URLQueryEscaper  </h2> <pre data-language=\"go\">func URLQueryEscaper(args ...interface{}) string</pre> <p> URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query. </p> <h2 id=\"CSS\">type CSS  </h2> <pre data-language=\"go\">type CSS string</pre> <p> CSS encapsulates known safe content that matches any of: </p> <pre data-language=\"go\">1. The CSS3 stylesheet production, such as `p { color: purple }`.\n2. The CSS3 rule production, such as `a[href=~\"https:\"].foo#bar`.\n3. CSS3 declaration productions, such as `color: red; margin: 2px`.\n4. The CSS3 value production, such as `rgba(0, 0, 255, 127)`.\n</pre> <p> See <a href=\"http://www.w3.org/TR/css3-syntax/#parsing\">http://www.w3.org/TR/css3-syntax/#parsing</a> and <a href=\"https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style\">https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style</a> </p> <p> Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p> <h2 id=\"Error\">type Error  </h2> <pre data-language=\"go\">type Error struct {\n        // ErrorCode describes the kind of error.\n        ErrorCode ErrorCode\n        // Node is the node that caused the problem, if known.\n        // If not nil, it overrides Name and Line.\n        Node parse.Node\n        // Name is the name of the template in which the error was encountered.\n        Name string\n        // Line is the line number of the error in the template source or 0.\n        Line int\n        // Description is a human-readable description of the problem.\n        Description string\n}</pre> <p> Error describes a problem encountered during template Escaping. </p> <h3 id=\"Error.Error\">func (*Error) <a href=\"https://golang.org/src/html/template/error.go?s=6950:6980#L178\">Error</a>  </h3> <pre data-language=\"go\">func (e *Error) Error() string</pre> <h2 id=\"ErrorCode\">type ErrorCode  </h2> <pre data-language=\"go\">type ErrorCode int</pre> <p> ErrorCode is a code for a kind of error. </p> <pre data-language=\"go\">const (\n        // OK indicates the lack of an error.\n        OK ErrorCode = iota\n\n        // ErrAmbigContext: \"... appears in an ambiguous URL context\"\n        // Example:\n        //   &lt;a href=\"\n        //      {{if .C}}\n        //        /path/\n        //      {{else}}\n        //        /search?q=\n        //      {{end}}\n        //      {{.X}}\n        //   \"&gt;\n        // Discussion:\n        //   {{.X}} is in an ambiguous URL context since, depending on {{.C}},\n        //  it may be either a URL suffix or a query parameter.\n        //   Moving {{.X}} into the condition removes the ambiguity:\n        //   &lt;a href=\"{{if .C}}/path/{{.X}}{{else}}/search?q={{.X}}\"&gt;\n        ErrAmbigContext\n\n        // ErrBadHTML: \"expected space, attr name, or end of tag, but got ...\",\n        //   \"... in unquoted attr\", \"... in attribute name\"\n        // Example:\n        //   &lt;a href = /search?q=foo&gt;\n        //   &lt;href=foo&gt;\n        //   &lt;form na&lt;e=...&gt;\n        //   &lt;option selected&lt;\n        // Discussion:\n        //   This is often due to a typo in an HTML element, but some runes\n        //   are banned in tag names, attribute names, and unquoted attribute\n        //   values because they can tickle parser ambiguities.\n        //   Quoting all attributes is the best policy.\n        ErrBadHTML\n\n        // ErrBranchEnd: \"{{if}} branches end in different contexts\"\n        // Example:\n        //   {{if .C}}&lt;a href=\"{{end}}{{.X}}\n        // Discussion:\n        //   Package html/template statically examines each path through an\n        //   {{if}}, {{range}}, or {{with}} to escape any following pipelines.\n        //   The example is ambiguous since {{.X}} might be an HTML text node,\n        //   or a URL prefix in an HTML attribute. The context of {{.X}} is\n        //   used to figure out how to escape it, but that context depends on\n        //   the run-time value of {{.C}} which is not statically known.\n        //\n        //   The problem is usually something like missing quotes or angle\n        //   brackets, or can be avoided by refactoring to put the two contexts\n        //   into different branches of an if, range or with. If the problem\n        //   is in a {{range}} over a collection that should never be empty,\n        //   adding a dummy {{else}} can help.\n        ErrBranchEnd\n\n        // ErrEndContext: \"... ends in a non-text context: ...\"\n        // Examples:\n        //   &lt;div\n        //   &lt;div title=\"no close quote&gt;\n        //   &lt;script&gt;f()\n        // Discussion:\n        //   Executed templates should produce a DocumentFragment of HTML.\n        //   Templates that end without closing tags will trigger this error.\n        //   Templates that should not be used in an HTML context or that\n        //   produce incomplete Fragments should not be executed directly.\n        //\n        //   {{define \"main\"}} &lt;script&gt;{{template \"helper\"}}&lt;/script&gt; {{end}}\n        //   {{define \"helper\"}} document.write(' &lt;div title=\" ') {{end}}\n        //\n        //   \"helper\" does not produce a valid document fragment, so should\n        //   not be Executed directly.\n        ErrEndContext\n\n        // ErrNoSuchTemplate: \"no such template ...\"\n        // Examples:\n        //   {{define \"main\"}}&lt;div {{template \"attrs\"}}&gt;{{end}}\n        //   {{define \"attrs\"}}href=\"{{.URL}}\"{{end}}\n        // Discussion:\n        //   Package html/template looks through template calls to compute the\n        //   context.\n        //   Here the {{.URL}} in \"attrs\" must be treated as a URL when called\n        //   from \"main\", but you will get this error if \"attrs\" is not defined\n        //   when \"main\" is parsed.\n        ErrNoSuchTemplate\n\n        // ErrOutputContext: \"cannot compute output context for template ...\"\n        // Examples:\n        //   {{define \"t\"}}{{if .T}}{{template \"t\" .T}}{{end}}{{.H}}\",{{end}}\n        // Discussion:\n        //   A recursive template does not end in the same context in which it\n        //   starts, and a reliable output context cannot be computed.\n        //   Look for typos in the named template.\n        //   If the template should not be called in the named start context,\n        //   look for calls to that template in unexpected contexts.\n        //   Maybe refactor recursive templates to not be recursive.\n        ErrOutputContext\n\n        // ErrPartialCharset: \"unfinished JS regexp charset in ...\"\n        // Example:\n        //     &lt;script&gt;var pattern = /foo[{{.Chars}}]/&lt;/script&gt;\n        // Discussion:\n        //   Package html/template does not support interpolation into regular\n        //   expression literal character sets.\n        ErrPartialCharset\n\n        // ErrPartialEscape: \"unfinished escape sequence in ...\"\n        // Example:\n        //   &lt;script&gt;alert(\"\\{{.X}}\")&lt;/script&gt;\n        // Discussion:\n        //   Package html/template does not support actions following a\n        //   backslash.\n        //   This is usually an error and there are better solutions; for\n        //   example\n        //     &lt;script&gt;alert(\"{{.X}}\")&lt;/script&gt;\n        //   should work, and if {{.X}} is a partial escape sequence such as\n        //   \"xA0\", mark the whole sequence as safe content: JSStr(`\\xA0`)\n        ErrPartialEscape\n\n        // ErrRangeLoopReentry: \"on range loop re-entry: ...\"\n        // Example:\n        //   &lt;script&gt;var x = [{{range .}}'{{.}},{{end}}]&lt;/script&gt;\n        // Discussion:\n        //   If an iteration through a range would cause it to end in a\n        //   different context than an earlier pass, there is no single context.\n        //   In the example, there is missing a quote, so it is not clear\n        //   whether {{.}} is meant to be inside a JS string or in a JS value\n        //   context. The second iteration would produce something like\n        //\n        //     &lt;script&gt;var x = ['firstValue,'secondValue]&lt;/script&gt;\n        ErrRangeLoopReentry\n\n        // ErrSlashAmbig: '/' could start a division or regexp.\n        // Example:\n        //   &lt;script&gt;\n        //     {{if .C}}var x = 1{{end}}\n        //     /-{{.N}}/i.test(x) ? doThis : doThat();\n        //   &lt;/script&gt;\n        // Discussion:\n        //   The example above could produce `var x = 1/-2/i.test(s)...`\n        //   in which the first '/' is a mathematical division operator or it\n        //   could produce `/-2/i.test(s)` in which the first '/' starts a\n        //   regexp literal.\n        //   Look for missing semicolons inside branches, and maybe add\n        //   parentheses to make it clear which interpretation you intend.\n        ErrSlashAmbig\n)</pre> <p> We define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. </p> <p> Output: \"ZgotmplZ\" Example: </p> <pre data-language=\"go\">&lt;img src=\"{{.X}}\"&gt;\nwhere {{.X}} evaluates to `javascript:...`\n</pre> <p> Discussion: </p> <pre data-language=\"go\">\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  &lt;img src=\"#ZgotmplZ\"&gt;\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n</pre> <h2 id=\"FuncMap\">type FuncMap  </h2> <pre data-language=\"go\">type FuncMap map[string]interface{}</pre> <p> FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) argument evaluates to non-nil during execution, execution terminates and Execute returns that error. FuncMap has the same base type as FuncMap in \"text/template\", copied here so clients need not import \"text/template\". </p> <h2 id=\"HTML\">type HTML  </h2> <pre data-language=\"go\">type HTML string</pre> <p> HTML encapsulates a known safe HTML document fragment. It should not be used for HTML from a third-party, or HTML with unclosed tags or comments. The outputs of a sound HTML sanitizer and a template escaped by this package are fine for use with HTML. </p> <p> Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p> <h2 id=\"HTMLAttr\">type HTMLAttr  </h2> <pre data-language=\"go\">type HTMLAttr string</pre> <p> HTMLAttr encapsulates an HTML attribute from a trusted source, for example, ` dir=\"ltr\"`. </p> <p> Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p> <h2 id=\"JS\">type JS  </h2> <pre data-language=\"go\">type JS string</pre> <p> JS encapsulates a known safe EcmaScript5 Expression, for example, `(x + y * z())`. Template authors are responsible for ensuring that typed expressions do not break the intended precedence and that there is no statement/expression ambiguity as when passing an expression like \"{ foo: bar() }\\n['foo']()\", which is both a valid Expression and a valid Program with a very different meaning. </p> <p> Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p> <p> Using JS to include valid but untrusted JSON is not safe. A safe alternative is to parse the JSON with json.Unmarshal and then pass the resultant object into the template, where it will be converted to sanitized JSON when presented in a JavaScript context. </p> <h2 id=\"JSStr\">type JSStr  </h2> <pre data-language=\"go\">type JSStr string</pre> <p> JSStr encapsulates a sequence of characters meant to be embedded between quotes in a JavaScript expression. The string must match a series of StringCharacters: </p> <pre data-language=\"go\">StringCharacter :: SourceCharacter but not `\\` or LineTerminator\n                 | EscapeSequence\n</pre> <p> Note that LineContinuations are not allowed. JSStr(\"foo\\\\nbar\") is fine, but JSStr(\"foo\\\\\\nbar\") is not. </p> <p> Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p> <h2 id=\"Template\">type Template  </h2> <pre data-language=\"go\">type Template struct {\n\n        // The underlying template's parse tree, updated to be HTML-safe.\n        Tree *parse.Tree\n        // contains filtered or unexported fields\n}</pre> <p> Template is a specialized Template from \"text/template\" that produces a safe HTML document fragment. </p> <div id=\"example_Template_block\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Block)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"html/template\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tconst (\n\t\tmaster  = `Names:{{block \"list\" .}}{{\"\\n\"}}{{range .}}{{println \"-\" .}}{{end}}{{end}}`\n\t\toverlay = `{{define \"list\"}} {{join . \", \"}}{{end}} `\n\t)\n\tvar (\n\t\tfuncs     = template.FuncMap{\"join\": strings.Join}\n\t\tguardians = []string{\"Gamora\", \"Groot\", \"Nebula\", \"Rocket\", \"Star-Lord\"}\n\t)\n\tmasterTmpl, err := template.New(\"master\").Funcs(funcs).Parse(master)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\toverlayTmpl, err := template.Must(masterTmpl.Clone()).Parse(overlay)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := masterTmpl.Execute(os.Stdout, guardians); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := overlayTmpl.Execute(os.Stdout, guardians); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n</pre> </div> </div> <div id=\"example_Template_glob\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Glob)</h2> <p>Here we demonstrate loading a set of templates from a directory. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// Here we create a temporary directory and populate it with our sample\n    // template definition files; usually the template files would already\n    // exist in some location known to the program.\n    dir := createTestDir([]templateFile{\n            // T0.tmpl is a plain template file that just invokes T1.\n            {\"T0.tmpl\", `T0 invokes T1: ({{template \"T1\"}})`},\n            // T1.tmpl defines a template, T1 that invokes T2.\n            {\"T1.tmpl\", `{{define \"T1\"}}T1 invokes T2: ({{template \"T2\"}}){{end}}`},\n            // T2.tmpl defines a template T2.\n            {\"T2.tmpl\", `{{define \"T2\"}}This is T2{{end}}`},\n    })\n    // Clean up after the test; another quirk of running as an example.\n    defer os.RemoveAll(dir)\n\n    // pattern is the glob pattern used to find all the template files.\n    pattern := filepath.Join(dir, \"*.tmpl\")\n\n    // Here starts the example proper.\n    // T0.tmpl is the first name matched, so it becomes the starting template,\n    // the value returned by ParseGlob.\n    tmpl := template.Must(template.ParseGlob(pattern))\n\n    err := tmpl.Execute(os.Stdout, nil)\n    if err != nil {\n            log.Fatalf(\"template execution: %s\", err)\n    }\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">T0 invokes T1: (T1 invokes T2: (This is T2))\n</pre> </div> </div> <div id=\"example_Template_helpers\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Helpers)</h2> <p>This example demonstrates one way to share some templates and use them in different contexts. In this variant we add multiple driver templates by hand to an existing bundle of templates. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// Here we create a temporary directory and populate it with our sample\n    // template definition files; usually the template files would already\n    // exist in some location known to the program.\n    dir := createTestDir([]templateFile{\n            // T1.tmpl defines a template, T1 that invokes T2.\n            {\"T1.tmpl\", `{{define \"T1\"}}T1 invokes T2: ({{template \"T2\"}}){{end}}`},\n            // T2.tmpl defines a template T2.\n            {\"T2.tmpl\", `{{define \"T2\"}}This is T2{{end}}`},\n    })\n    // Clean up after the test; another quirk of running as an example.\n    defer os.RemoveAll(dir)\n\n    // pattern is the glob pattern used to find all the template files.\n    pattern := filepath.Join(dir, \"*.tmpl\")\n\n    // Here starts the example proper.\n    // Load the helpers.\n    templates := template.Must(template.ParseGlob(pattern))\n    // Add one driver template to the bunch; we do this with an explicit template definition.\n    _, err := templates.Parse(\"{{define `driver1`}}Driver 1 calls T1: ({{template `T1`}})\\n{{end}}\")\n    if err != nil {\n            log.Fatal(\"parsing driver1: \", err)\n    }\n    // Add another driver template.\n    _, err = templates.Parse(\"{{define `driver2`}}Driver 2 calls T2: ({{template `T2`}})\\n{{end}}\")\n    if err != nil {\n            log.Fatal(\"parsing driver2: \", err)\n    }\n    // We load all the templates before execution. This package does not require\n    // that behavior but html/template's escaping does, so it's a good habit.\n    err = templates.ExecuteTemplate(os.Stdout, \"driver1\", nil)\n    if err != nil {\n            log.Fatalf(\"driver1 execution: %s\", err)\n    }\n    err = templates.ExecuteTemplate(os.Stdout, \"driver2\", nil)\n    if err != nil {\n            log.Fatalf(\"driver2 execution: %s\", err)\n    }\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">Driver 1 calls T1: (T1 invokes T2: (This is T2))\nDriver 2 calls T2: (This is T2)\n</pre> </div> </div> <div id=\"example_Template_parsefiles\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Parsefiles)</h2> <p>Here we demonstrate loading a set of templates from files in different directories </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// Here we create different temporary directories and populate them with our sample\n    // template definition files; usually the template files would already\n    // exist in some location known to the program.\n    dir1 := createTestDir([]templateFile{\n            // T1.tmpl is a plain template file that just invokes T2.\n            {\"T1.tmpl\", `T1 invokes T2: ({{template \"T2\"}})`},\n    })\n\n    dir2 := createTestDir([]templateFile{\n            // T2.tmpl defines a template T2.\n            {\"T2.tmpl\", `{{define \"T2\"}}This is T2{{end}}`},\n    })\n\n    // Clean up after the test; another quirk of running as an example.\n    defer func(dirs ...string) {\n            for _, dir := range dirs {\n                    os.RemoveAll(dir)\n            }\n    }(dir1, dir2)\n\n    // Here starts the example proper.\n    // Let's just parse only dir1/T0 and dir2/T2\n    paths := []string{\n            filepath.Join(dir1, \"T1.tmpl\"),\n            filepath.Join(dir2, \"T2.tmpl\"),\n    }\n    tmpl := template.Must(template.ParseFiles(paths...))\n\n    err := tmpl.Execute(os.Stdout, nil)\n    if err != nil {\n            log.Fatalf(\"template execution: %s\", err)\n    }\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">T1 invokes T2: (This is T2)\n</pre> </div> </div> <div id=\"example_Template_share\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Share)</h2> <p>This example demonstrates how to use one group of driver templates with distinct sets of helper templates. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// Here we create a temporary directory and populate it with our sample\n    // template definition files; usually the template files would already\n    // exist in some location known to the program.\n    dir := createTestDir([]templateFile{\n            // T0.tmpl is a plain template file that just invokes T1.\n            {\"T0.tmpl\", \"T0 ({{.}} version) invokes T1: ({{template `T1`}})\\n\"},\n            // T1.tmpl defines a template, T1 that invokes T2. Note T2 is not defined\n            {\"T1.tmpl\", `{{define \"T1\"}}T1 invokes T2: ({{template \"T2\"}}){{end}}`},\n    })\n    // Clean up after the test; another quirk of running as an example.\n    defer os.RemoveAll(dir)\n\n    // pattern is the glob pattern used to find all the template files.\n    pattern := filepath.Join(dir, \"*.tmpl\")\n\n    // Here starts the example proper.\n    // Load the drivers.\n    drivers := template.Must(template.ParseGlob(pattern))\n\n    // We must define an implementation of the T2 template. First we clone\n    // the drivers, then add a definition of T2 to the template name space.\n\n    // 1. Clone the helper set to create a new name space from which to run them.\n    first, err := drivers.Clone()\n    if err != nil {\n            log.Fatal(\"cloning helpers: \", err)\n    }\n    // 2. Define T2, version A, and parse it.\n    _, err = first.Parse(\"{{define `T2`}}T2, version A{{end}}\")\n    if err != nil {\n            log.Fatal(\"parsing T2: \", err)\n    }\n\n    // Now repeat the whole thing, using a different version of T2.\n    // 1. Clone the drivers.\n    second, err := drivers.Clone()\n    if err != nil {\n            log.Fatal(\"cloning drivers: \", err)\n    }\n    // 2. Define T2, version B, and parse it.\n    _, err = second.Parse(\"{{define `T2`}}T2, version B{{end}}\")\n    if err != nil {\n            log.Fatal(\"parsing T2: \", err)\n    }\n\n    // Execute the templates in the reverse order to verify the\n    // first is unaffected by the second.\n    err = second.ExecuteTemplate(os.Stdout, \"T0.tmpl\", \"second\")\n    if err != nil {\n            log.Fatalf(\"second execution: %s\", err)\n    }\n    err = first.ExecuteTemplate(os.Stdout, \"T0.tmpl\", \"first\")\n    if err != nil {\n            log.Fatalf(\"first: execution: %s\", err)\n    }\n\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">T0 (second version) invokes T1: (T1 invokes T2: (T2, version B))\nT0 (first version) invokes T1: (T1 invokes T2: (T2, version A))\n</pre> </div> </div> <h3 id=\"Must\">func <a href=\"https://golang.org/src/html/template/template.go?s=10842:10885#L328\">Must</a>  </h3> <pre data-language=\"go\">func Must(t *Template, err error) *Template</pre> <p> Must is a helper that wraps a call to a function returning (*Template, error) and panics if the error is non-nil. It is intended for use in variable initializations such as </p> <pre data-language=\"go\">var t = template.Must(template.New(\"name\").Parse(\"html\"))\n</pre> <h3 id=\"New\">func <a href=\"https://golang.org/src/html/template/template.go?s=8205:8236#L249\">New</a>  </h3> <pre data-language=\"go\">func New(name string) *Template</pre> <p> New allocates a new HTML template with the given name. </p> <h3 id=\"ParseFiles\">func <a href=\"https://golang.org/src/html/template/template.go?s=11494:11549#L344\">ParseFiles</a>  </h3> <pre data-language=\"go\">func ParseFiles(filenames ...string) (*Template, error)</pre> <p> ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the (base) name and (parsed) contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil. </p> <p> When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template named \"foo\", while \"a/foo\" is unavailable. </p> <h3 id=\"ParseGlob\">func <a href=\"https://golang.org/src/html/template/template.go?s=13660:13709#L403\">ParseGlob</a>  </h3> <pre data-language=\"go\">func ParseGlob(pattern string) (*Template, error)</pre> <p> ParseGlob creates a new Template and parses the template definitions from the files identified by the pattern, which must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling ParseFiles with the list of files matched by the pattern. </p> <p> When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. </p> <h3 id=\"Template.AddParseTree\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=6423:6504#L184\">AddParseTree</a>  </h3> <pre data-language=\"go\">func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)</pre> <p> AddParseTree creates a new template with the name and parse tree and associates it with t. </p> <p> It returns an error if t has already been executed. </p> <h3 id=\"Template.Clone\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=7367:7412#L212\">Clone</a>  </h3> <pre data-language=\"go\">func (t *Template) Clone() (*Template, error)</pre> <p> Clone returns a duplicate of the template, including all associated templates. The actual representation is not copied, but the name space of associated templates is, so further calls to Parse in the copy will add templates to the copy but not to the original. Clone can be used to prepare common templates and use them with variant definitions for other templates by adding the variants after the clone is made. </p> <p> It returns an error if t has already been executed. </p> <h3 id=\"Template.DefinedTemplates\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=4801:4845#L139\">DefinedTemplates</a>  </h3> <pre data-language=\"go\">func (t *Template) DefinedTemplates() string</pre> <p> DefinedTemplates returns a string listing the defined templates, prefixed by the string \"; defined templates are: \". If there are none, it returns the empty string. Used to generate an error message. </p> <h3 id=\"Template.Delims\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=10254:10309#L311\">Delims</a>  </h3> <pre data-language=\"go\">func (t *Template) Delims(left, right string) *Template</pre> <p> Delims sets the action delimiters to the specified strings, to be used in subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template definitions will inherit the settings. An empty delimiter stands for the corresponding default: {{ or }}. The return value is the template, so calls can be chained. </p> <h3 id=\"Template.Execute\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=3033:3097#L90\">Execute</a>  </h3> <pre data-language=\"go\">func (t *Template) Execute(wr io.Writer, data interface{}) error</pre> <p> Execute applies a parsed template to the specified data object, writing the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel. </p> <h3 id=\"Template.ExecuteTemplate\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=3544:3629#L103\">ExecuteTemplate</a>  </h3> <pre data-language=\"go\">func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error</pre> <p> ExecuteTemplate applies the template associated with t that has the given name to the specified data object and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel. </p> <h3 id=\"Template.Funcs\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=9823:9874#L301\">Funcs</a>  </h3> <pre data-language=\"go\">func (t *Template) Funcs(funcMap FuncMap) *Template</pre> <p> Funcs adds the elements of the argument map to the template's function map. It panics if a value in the map is not a function with appropriate return type. However, it is legal to overwrite elements of the map. The return value is the template, so calls can be chained. </p> <h3 id=\"Template.Lookup\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=10471:10519#L318\">Lookup</a>  </h3> <pre data-language=\"go\">func (t *Template) Lookup(name string) *Template</pre> <p> Lookup returns the template with the given name that is associated with t, or nil if there is no such template. </p> <h3 id=\"Template.Name\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=8980:9012#L284\">Name</a>  </h3> <pre data-language=\"go\">func (t *Template) Name() string</pre> <p> Name returns the name of the template. </p> <h3 id=\"Template.New\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=8599:8644#L265\">New</a>  </h3> <pre data-language=\"go\">func (t *Template) New(name string) *Template</pre> <p> New allocates a new HTML template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action. </p> <h3 id=\"Template.Option\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=2184:2234#L62\">Option</a>  </h3> <pre data-language=\"go\">func (t *Template) Option(opt ...string) *Template</pre> <p> Option sets options for the template. Options are described by strings, either a simple string or \"key=value\". There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics. </p> <p> Known options: </p> <p> missingkey: Control the behavior during execution if a map is indexed with a key that is not present in the map. </p> <pre data-language=\"go\">\"missingkey=default\" or \"missingkey=invalid\"\n\tThe default behavior: Do nothing and continue execution.\n\tIf printed, the result of the index operation is the string\n\t\"&lt;no value&gt;\".\n\"missingkey=zero\"\n\tThe operation returns the zero value for the map type's element.\n\"missingkey=error\"\n\tExecution stops immediately with an error.\n</pre> <h3 id=\"Template.Parse\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=5426:5481#L151\">Parse</a>  </h3> <pre data-language=\"go\">func (t *Template) Parse(src string) (*Template, error)</pre> <p> Parse parses a string into a template. Nested template definitions will be associated with the top-level template t. Parse may be called multiple times to parse definitions of templates to associate with t. It is an error if a resulting template is non-empty (contains content other than template definitions) and would replace a non-empty template with the same name. (In multiple calls to Parse with the same receiver template, only one call can contain text other than space, comments, and template definitions.) </p> <h3 id=\"Template.ParseFiles\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=11938:12007#L354\">ParseFiles</a>  </h3> <pre data-language=\"go\">func (t *Template) ParseFiles(filenames ...string) (*Template, error)</pre> <p> ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file. </p> <p> When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. </p> <h3 id=\"Template.ParseGlob\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=14196:14259#L415\">ParseGlob</a>  </h3> <pre data-language=\"go\">func (t *Template) ParseGlob(pattern string) (*Template, error)</pre> <p> ParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The pattern is processed by filepath.Glob and must match at least one file. ParseGlob is equivalent to calling t.ParseFiles with the list of files matched by the pattern. </p> <p> When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. </p> <h3 id=\"Template.Templates\">func (*Template) <a href=\"https://golang.org/src/html/template/template.go?s=1183:1225#L32\">Templates</a>  </h3> <pre data-language=\"go\">func (t *Template) Templates() []*Template</pre> <p> Templates returns a slice of the templates associated with t, including t itself. </p> <h2 id=\"URL\">type URL  </h2> <pre data-language=\"go\">type URL string</pre> <p> URL encapsulates a known safe URL or URL substring (see RFC 3986). A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()` from a trusted source should go in the page, but by default dynamic `javascript:` URLs are filtered out since they are a frequently exploited injection vector. </p> <p> Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/html/template/\" class=\"_attribution-link\">https://golang.org/pkg/html/template/</a>\n  </p>\n</div>\n","net/http/httputil/index":"<h1>Package httputil</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/http/httputil\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#DumpRequest\">func DumpRequest(req *http.Request, body bool) ([]byte, error)</a></li>\n<li><a href=\"#DumpRequestOut\">func DumpRequestOut(req *http.Request, body bool) ([]byte, error)</a></li>\n<li><a href=\"#DumpResponse\">func DumpResponse(resp *http.Response, body bool) ([]byte, error)</a></li>\n<li><a href=\"#NewChunkedReader\">func NewChunkedReader(r io.Reader) io.Reader</a></li>\n<li><a href=\"#NewChunkedWriter\">func NewChunkedWriter(w io.Writer) io.WriteCloser</a></li>\n<li><a href=\"#BufferPool\">type BufferPool</a></li>\n<li><a href=\"#ClientConn\">type ClientConn</a></li>\n<li> <a href=\"#NewClientConn\">func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn</a>\n</li>\n<li> <a href=\"#NewProxyClientConn\">func NewProxyClientConn(c net.Conn, r *bufio.Reader) *ClientConn</a>\n</li>\n<li> <a href=\"#ClientConn.Close\">func (cc *ClientConn) Close() error</a>\n</li>\n<li> <a href=\"#ClientConn.Do\">func (cc *ClientConn) Do(req *http.Request) (*http.Response, error)</a>\n</li>\n<li> <a href=\"#ClientConn.Hijack\">func (cc *ClientConn) Hijack() (c net.Conn, r *bufio.Reader)</a>\n</li>\n<li> <a href=\"#ClientConn.Pending\">func (cc *ClientConn) Pending() int</a>\n</li>\n<li> <a href=\"#ClientConn.Read\">func (cc *ClientConn) Read(req *http.Request) (resp *http.Response, err error)</a>\n</li>\n<li> <a href=\"#ClientConn.Write\">func (cc *ClientConn) Write(req *http.Request) error</a>\n</li>\n<li><a href=\"#ReverseProxy\">type ReverseProxy</a></li>\n<li> <a href=\"#NewSingleHostReverseProxy\">func NewSingleHostReverseProxy(target *url.URL) *ReverseProxy</a>\n</li>\n<li> <a href=\"#ReverseProxy.ServeHTTP\">func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request)</a>\n</li>\n<li><a href=\"#ServerConn\">type ServerConn</a></li>\n<li> <a href=\"#NewServerConn\">func NewServerConn(c net.Conn, r *bufio.Reader) *ServerConn</a>\n</li>\n<li> <a href=\"#ServerConn.Close\">func (sc *ServerConn) Close() error</a>\n</li>\n<li> <a href=\"#ServerConn.Hijack\">func (sc *ServerConn) Hijack() (net.Conn, *bufio.Reader)</a>\n</li>\n<li> <a href=\"#ServerConn.Pending\">func (sc *ServerConn) Pending() int</a>\n</li>\n<li> <a href=\"#ServerConn.Read\">func (sc *ServerConn) Read() (*http.Request, error)</a>\n</li>\n<li> <a href=\"#ServerConn.Write\">func (sc *ServerConn) Write(req *http.Request, resp *http.Response) error</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_DumpRequest\">DumpRequest</a></dd> <dd><a class=\"exampleLink\" href=\"#example_DumpRequestOut\">DumpRequestOut</a></dd> <dd><a class=\"exampleLink\" href=\"#example_DumpResponse\">DumpResponse</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ReverseProxy\">ReverseProxy</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/http/httputil/dump.go\">dump.go</a> <a href=\"https://golang.org/src/net/http/httputil/httputil.go\">httputil.go</a> <a href=\"https://golang.org/src/net/http/httputil/persist.go\">persist.go</a> <a href=\"https://golang.org/src/net/http/httputil/reverseproxy.go\">reverseproxy.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        ErrPersistEOF = &amp;http.ProtocolError{ErrorString: \"persistent connection closed\"}\n        ErrClosed     = &amp;http.ProtocolError{ErrorString: \"connection closed by user\"}\n        ErrPipeline   = &amp;http.ProtocolError{ErrorString: \"pipeline error\"}\n)</pre> <pre data-language=\"go\">var ErrLineTooLong = internal.ErrLineTooLong</pre> <p> ErrLineTooLong is returned when reading malformed chunked data with lines that are too long. </p> <h2 id=\"DumpRequest\">func DumpRequest  </h2> <pre data-language=\"go\">func DumpRequest(req *http.Request, body bool) ([]byte, error)</pre> <p> DumpRequest returns the given request in its HTTP/1.x wire representation. It should only be used by servers to debug client requests. The returned representation is an approximation only; some details of the initial request are lost while parsing it into an http.Request. In particular, the order and case of header field names are lost. The order of values in multi-valued headers is kept intact. HTTP/2 requests are dumped in HTTP/1.x form, not in their original binary representations. </p> <p> If body is true, DumpRequest also returns the body. To do so, it consumes req.Body and then replaces it with a new io.ReadCloser that yields the same bytes. If DumpRequest returns an error, the state of req is undefined. </p> <p> The documentation for http.Request.Write details which fields of req are included in the dump. </p> <div id=\"example_DumpRequest\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/http/httputil\"\n\t\"strings\"\n)\n\nfunc main() {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdump, err := httputil.DumpRequest(r, true)\n\t\tif err != nil {\n\t\t\thttp.Error(w, fmt.Sprint(err), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Fprintf(w, \"%q\", dump)\n\t}))\n\tdefer ts.Close()\n\n\tconst body = \"Go is a general-purpose language designed with systems programming in mind.\"\n\treq, err := http.NewRequest(\"POST\", ts.URL, strings.NewReader(body))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treq.Host = \"www.example.org\"\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tb, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"%s\", b)\n\n}\n</pre> </div> </div> <h2 id=\"DumpRequestOut\">func DumpRequestOut  </h2> <pre data-language=\"go\">func DumpRequestOut(req *http.Request, body bool) ([]byte, error)</pre> <p> DumpRequestOut is like DumpRequest but for outgoing client requests. It includes any headers that the standard http.Transport adds, such as User-Agent. </p> <div id=\"example_DumpRequestOut\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"strings\"\n)\n\nfunc main() {\n\tconst body = \"Go is a general-purpose language designed with systems programming in mind.\"\n\treq, err := http.NewRequest(\"PUT\", \"http://www.example.org\", strings.NewReader(body))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdump, err := httputil.DumpRequestOut(req, true)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"%q\", dump)\n\n}\n</pre> </div> </div> <h2 id=\"DumpResponse\">func DumpResponse  </h2> <pre data-language=\"go\">func DumpResponse(resp *http.Response, body bool) ([]byte, error)</pre> <p> DumpResponse is like DumpRequest but dumps a response. </p> <div id=\"example_DumpResponse\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/http/httputil\"\n)\n\nfunc main() {\n\tconst body = \"Go is a general-purpose language designed with systems programming in mind.\"\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Date\", \"Wed, 19 Jul 1972 19:00:00 GMT\")\n\t\tfmt.Fprintln(w, body)\n\t}))\n\tdefer ts.Close()\n\n\tresp, err := http.Get(ts.URL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tdump, err := httputil.DumpResponse(resp, true)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"%q\", dump)\n\n}\n</pre> </div> </div> <h2 id=\"NewChunkedReader\">func NewChunkedReader  </h2> <pre data-language=\"go\">func NewChunkedReader(r io.Reader) io.Reader</pre> <p> NewChunkedReader returns a new chunkedReader that translates the data read from r out of HTTP \"chunked\" format before returning it. The chunkedReader returns io.EOF when the final 0-length chunk is read. </p> <p> NewChunkedReader is not needed by normal applications. The http package automatically decodes chunking when reading response bodies. </p> <h2 id=\"NewChunkedWriter\">func NewChunkedWriter  </h2> <pre data-language=\"go\">func NewChunkedWriter(w io.Writer) io.WriteCloser</pre> <p> NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP \"chunked\" format before writing them to w. Closing the returned chunkedWriter sends the final 0-length chunk that marks the end of the stream. </p> <p> NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using NewChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong. </p> <h2 id=\"BufferPool\">type BufferPool  </h2> <pre data-language=\"go\">type BufferPool interface {\n        Get() []byte\n        Put([]byte)\n}</pre> <p> A BufferPool is an interface for getting and returning temporary byte slices for use by io.CopyBuffer. </p> <h2 id=\"ClientConn\">type ClientConn  </h2> <pre data-language=\"go\">type ClientConn struct {\n        // contains filtered or unexported fields\n}</pre> <p> ClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1. </p> <p> Deprecated: Use Client or Transport in package net/http instead. </p> <h3 id=\"NewClientConn\">func <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=6499:6558#L233\">NewClientConn</a>  </h3> <pre data-language=\"go\">func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn</pre> <p> NewClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1. </p> <p> Deprecated: Use the Client or Transport in package net/http instead. </p> <h3 id=\"NewProxyClientConn\">func <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=6991:7055#L250\">NewProxyClientConn</a>  </h3> <pre data-language=\"go\">func NewProxyClientConn(c net.Conn, r *bufio.Reader) *ClientConn</pre> <p> NewProxyClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1. </p> <p> Deprecated: Use the Client or Transport in package net/http instead. </p> <h3 id=\"ClientConn.Close\">func (*ClientConn) <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=7673:7708#L271\">Close</a>  </h3> <pre data-language=\"go\">func (cc *ClientConn) Close() error</pre> <p> Close calls Hijack and then also closes the underlying connection. </p> <h3 id=\"ClientConn.Do\">func (*ClientConn) <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=11000:11067#L410\">Do</a>  </h3> <pre data-language=\"go\">func (cc *ClientConn) Do(req *http.Request) (*http.Response, error)</pre> <p> Do is convenience method that writes a request and reads a response. </p> <h3 id=\"ClientConn.Hijack\">func (*ClientConn) <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=7449:7509#L260\">Hijack</a>  </h3> <pre data-language=\"go\">func (cc *ClientConn) Hijack() (c net.Conn, r *bufio.Reader)</pre> <p> Hijack detaches the ClientConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before the user or Read have signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress. </p> <h3 id=\"ClientConn.Pending\">func (*ClientConn) <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=9273:9308#L338\">Pending</a>  </h3> <pre data-language=\"go\">func (cc *ClientConn) Pending() int</pre> <p> Pending returns the number of unanswered requests that have been sent on the connection. </p> <h3 id=\"ClientConn.Read\">func (*ClientConn) <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=9653:9731#L348\">Read</a>  </h3> <pre data-language=\"go\">func (cc *ClientConn) Read(req *http.Request) (resp *http.Response, err error)</pre> <p> Read reads the next response from the wire. A valid response might be returned together with an ErrPersistEOF, which means that the remote requested that this be the last request serviced. Read can be called concurrently with Write, but not with another Read. </p> <h3 id=\"ClientConn.Write\">func (*ClientConn) <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=8173:8225#L284\">Write</a>  </h3> <pre data-language=\"go\">func (cc *ClientConn) Write(req *http.Request) error</pre> <p> Write writes a request. An ErrPersistEOF error is returned if the connection has been closed in an HTTP keepalive sense. If req.Close equals true, the keepalive connection is logically closed after this request and the opposing server is informed. An ErrUnexpectedEOF indicates the remote closed the underlying TCP connection, which is usually considered as graceful close. </p> <h2 id=\"ReverseProxy\">type ReverseProxy  </h2> <pre data-language=\"go\">type ReverseProxy struct {\n        // Director must be a function which modifies\n        // the request into a new request to be sent\n        // using Transport. Its response is then copied\n        // back to the original client unmodified.\n        Director func(*http.Request)\n\n        // The transport used to perform proxy requests.\n        // If nil, http.DefaultTransport is used.\n        Transport http.RoundTripper\n\n        // FlushInterval specifies the flush interval\n        // to flush to the client while copying the\n        // response body.\n        // If zero, no periodic flushing is done.\n        FlushInterval time.Duration\n\n        // ErrorLog specifies an optional logger for errors\n        // that occur when attempting to proxy the request.\n        // If nil, logging goes to os.Stderr via the log package's\n        // standard logger.\n        ErrorLog *log.Logger\n\n        // BufferPool optionally specifies a buffer pool to\n        // get byte slices for use by io.CopyBuffer when\n        // copying HTTP response bodies.\n        BufferPool BufferPool\n}</pre> <p> ReverseProxy is an HTTP Handler that takes an incoming request and sends it to another server, proxying the response back to the client. </p> <div id=\"example_ReverseProxy\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n)\n\nfunc main() {\n\tbackendServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"this call was relayed by the reverse proxy\")\n\t}))\n\tdefer backendServer.Close()\n\n\trpURL, err := url.Parse(backendServer.URL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfrontendProxy := httptest.NewServer(httputil.NewSingleHostReverseProxy(rpURL))\n\tdefer frontendProxy.Close()\n\n\tresp, err := http.Get(frontendProxy.URL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tb, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"%s\", b)\n\n}\n</pre> </div> </div> <h3 id=\"NewSingleHostReverseProxy\">func <a href=\"https://golang.org/src/net/http/httputil/reverseproxy.go?s=2298:2359#L72\">NewSingleHostReverseProxy</a>  </h3> <pre data-language=\"go\">func NewSingleHostReverseProxy(target *url.URL) *ReverseProxy</pre> <p> NewSingleHostReverseProxy returns a new ReverseProxy that routes URLs to the scheme, host, and base path provided in target. If the target's path is \"/base\" and the incoming request was for \"/dir\", the target request will be for /base/dir. NewSingleHostReverseProxy does not rewrite the Host header. To rewrite Host headers, use ReverseProxy directly with a custom Director policy. </p> <h3 id=\"ReverseProxy.ServeHTTP\">func (*ReverseProxy) <a href=\"https://golang.org/src/net/http/httputil/reverseproxy.go?s=3924:3999#L134\">ServeHTTP</a>  </h3> <pre data-language=\"go\">func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request)</pre> <h2 id=\"ServerConn\">type ServerConn  </h2> <pre data-language=\"go\">type ServerConn struct {\n        // contains filtered or unexported fields\n}</pre> <p> ServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1. </p> <p> Deprecated: Use the Server in package net/http instead. </p> <h3 id=\"NewServerConn\">func <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=1472:1531#L39\">NewServerConn</a>  </h3> <pre data-language=\"go\">func NewServerConn(c net.Conn, r *bufio.Reader) *ServerConn</pre> <p> NewServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1. </p> <p> Deprecated: Use the Server in package net/http instead. </p> <h3 id=\"ServerConn.Close\">func (*ServerConn) <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=2173:2208#L61\">Close</a>  </h3> <pre data-language=\"go\">func (sc *ServerConn) Close() error</pre> <p> Close calls Hijack and then also closes the underlying connection. </p> <h3 id=\"ServerConn.Hijack\">func (*ServerConn) <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=1946:2002#L50\">Hijack</a>  </h3> <pre data-language=\"go\">func (sc *ServerConn) Hijack() (net.Conn, *bufio.Reader)</pre> <p> Hijack detaches the ServerConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before Read has signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress. </p> <h3 id=\"ServerConn.Pending\">func (*ServerConn) <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=4295:4330#L151\">Pending</a>  </h3> <pre data-language=\"go\">func (sc *ServerConn) Pending() int</pre> <p> Pending returns the number of unanswered requests that have been received on the connection. </p> <h3 id=\"ServerConn.Read\">func (*ServerConn) <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=2543:2594#L73\">Read</a>  </h3> <pre data-language=\"go\">func (sc *ServerConn) Read() (*http.Request, error)</pre> <p> Read returns the next request on the wire. An ErrPersistEOF is returned if it is gracefully determined that there are no more requests (e.g. after the first request on an HTTP/1.0 connection, or after a Connection:close on a HTTP/1.1 connection). </p> <h3 id=\"ServerConn.Write\">func (*ServerConn) <a href=\"https://golang.org/src/net/http/httputil/persist.go?s=4642:4715#L160\">Write</a>  </h3> <pre data-language=\"go\">func (sc *ServerConn) Write(req *http.Request, resp *http.Response) error</pre> <p> Write writes resp in response to req. To close the connection gracefully, set the Response.Close field to true. Write should be considered operational until it returns an error, regardless of any errors returned on the Read side. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/http/httputil/\" class=\"_attribution-link\">https://golang.org/pkg/net/http/httputil/</a>\n  </p>\n</div>\n","os/user/index":"<h1>Package user</h1>     <ul id=\"short-nav\">\n<li><code>import \"os/user\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package user allows user account lookups by name or id. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Group\">type Group</a></li>\n<li> <a href=\"#LookupGroup\">func LookupGroup(name string) (*Group, error)</a>\n</li>\n<li> <a href=\"#LookupGroupId\">func LookupGroupId(gid string) (*Group, error)</a>\n</li>\n<li><a href=\"#UnknownGroupError\">type UnknownGroupError</a></li>\n<li> <a href=\"#UnknownGroupError.Error\">func (e UnknownGroupError) Error() string</a>\n</li>\n<li><a href=\"#UnknownGroupIdError\">type UnknownGroupIdError</a></li>\n<li> <a href=\"#UnknownGroupIdError.Error\">func (e UnknownGroupIdError) Error() string</a>\n</li>\n<li><a href=\"#UnknownUserError\">type UnknownUserError</a></li>\n<li> <a href=\"#UnknownUserError.Error\">func (e UnknownUserError) Error() string</a>\n</li>\n<li><a href=\"#UnknownUserIdError\">type UnknownUserIdError</a></li>\n<li> <a href=\"#UnknownUserIdError.Error\">func (e UnknownUserIdError) Error() string</a>\n</li>\n<li><a href=\"#User\">type User</a></li>\n<li> <a href=\"#Current\">func Current() (*User, error)</a>\n</li>\n<li> <a href=\"#Lookup\">func Lookup(username string) (*User, error)</a>\n</li>\n<li> <a href=\"#LookupId\">func LookupId(uid string) (*User, error)</a>\n</li>\n<li> <a href=\"#User.GroupIds\">func (u *User) GroupIds() ([]string, error)</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/os/user/getgrouplist_unix.go\">getgrouplist_unix.go</a> <a href=\"https://golang.org/src/os/user/listgroups_unix.go\">listgroups_unix.go</a> <a href=\"https://golang.org/src/os/user/lookup.go\">lookup.go</a> <a href=\"https://golang.org/src/os/user/lookup_unix.go\">lookup_unix.go</a> <a href=\"https://golang.org/src/os/user/user.go\">user.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Group\">type Group  </h2> <pre data-language=\"go\">type Group struct {\n        Gid  string // group ID\n        Name string // group name\n}</pre> <p> Group represents a grouping of users. </p> <p> On POSIX systems Gid contains a decimal number representing the group ID. </p> <h3 id=\"LookupGroup\">func <a href=\"https://golang.org/src/os/user/lookup.go?s=777:822#L16\">LookupGroup</a>  </h3> <pre data-language=\"go\">func LookupGroup(name string) (*Group, error)</pre> <p> LookupGroup looks up a group by name. If the group cannot be found, the returned error is of type UnknownGroupError. </p> <h3 id=\"LookupGroupId\">func <a href=\"https://golang.org/src/os/user/lookup.go?s=984:1030#L22\">LookupGroupId</a>  </h3> <pre data-language=\"go\">func LookupGroupId(gid string) (*Group, error)</pre> <p> LookupGroupId looks up a group by groupid. If the group cannot be found, the returned error is of type UnknownGroupIdError. </p> <h2 id=\"UnknownGroupError\">type UnknownGroupError  </h2> <pre data-language=\"go\">type UnknownGroupError string</pre> <p> UnknownGroupError is returned by LookupGroup when a group cannot be found. </p> <h3 id=\"UnknownGroupError.Error\">func (UnknownGroupError) <a href=\"https://golang.org/src/os/user/user.go?s=1748:1789#L59\">Error</a>  </h3> <pre data-language=\"go\">func (e UnknownGroupError) Error() string</pre> <h2 id=\"UnknownGroupIdError\">type UnknownGroupIdError  </h2> <pre data-language=\"go\">type UnknownGroupIdError string</pre> <p> UnknownGroupIdError is returned by LookupGroupId when a group cannot be found. </p> <h3 id=\"UnknownGroupIdError.Error\">func (UnknownGroupIdError) <a href=\"https://golang.org/src/os/user/user.go?s=1541:1584#L51\">Error</a>  </h3> <pre data-language=\"go\">func (e UnknownGroupIdError) Error() string</pre> <h2 id=\"UnknownUserError\">type UnknownUserError  </h2> <pre data-language=\"go\">type UnknownUserError string</pre> <p> UnknownUserError is returned by Lookup when a user cannot be found. </p> <h3 id=\"UnknownUserError.Error\">func (UnknownUserError) <a href=\"https://golang.org/src/os/user/user.go?s=1335:1375#L43\">Error</a>  </h3> <pre data-language=\"go\">func (e UnknownUserError) Error() string</pre> <h2 id=\"UnknownUserIdError\">type UnknownUserIdError  </h2> <pre data-language=\"go\">type UnknownUserIdError int</pre> <p> UnknownUserIdError is returned by LookupId when a user cannot be found. </p> <h3 id=\"UnknownUserIdError.Error\">func (UnknownUserIdError) <a href=\"https://golang.org/src/os/user/user.go?s=1128:1170#L35\">Error</a>  </h3> <pre data-language=\"go\">func (e UnknownUserIdError) Error() string</pre> <h2 id=\"User\">type User  </h2> <pre data-language=\"go\">type User struct {\n        Uid      string // user ID\n        Gid      string // primary group ID\n        Username string\n        Name     string\n        HomeDir  string\n}</pre> <p> User represents a user account. </p> <p> On POSIX systems Uid and Gid contain a decimal number representing uid and gid. On windows Uid and Gid contain security identifier (SID) in a string format. On Plan 9, Uid, Gid, Username, and Name will be the contents of /dev/user. </p> <h3 id=\"Current\">func <a href=\"https://golang.org/src/os/user/lookup.go?s=211:240#L1\">Current</a>  </h3> <pre data-language=\"go\">func Current() (*User, error)</pre> <p> Current returns the current user. </p> <h3 id=\"Lookup\">func <a href=\"https://golang.org/src/os/user/lookup.go?s=383:426#L4\">Lookup</a>  </h3> <pre data-language=\"go\">func Lookup(username string) (*User, error)</pre> <p> Lookup looks up a user by username. If the user cannot be found, the returned error is of type UnknownUserError. </p> <h3 id=\"LookupId\">func <a href=\"https://golang.org/src/os/user/lookup.go?s=582:622#L10\">LookupId</a>  </h3> <pre data-language=\"go\">func LookupId(uid string) (*User, error)</pre> <p> LookupId looks up a user by userid. If the user cannot be found, the returned error is of type UnknownUserIdError. </p> <h3 id=\"User.GroupIds\">func (*User) <a href=\"https://golang.org/src/os/user/lookup.go?s=1135:1178#L27\">GroupIds</a>  </h3> <pre data-language=\"go\">func (u *User) GroupIds() ([]string, error)</pre> <p> GroupIds returns the list of group IDs that the user is a member of. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/os/user/\" class=\"_attribution-link\">https://golang.org/pkg/os/user/</a>\n  </p>\n</div>\n","net/rpc/index":"<h1>Package rpc</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/rpc\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package rpc provides access to the exported methods of an object across a network or other I/O connection. A server registers an object, making it visible as a service with the name of the type of the object. After registration, exported methods of the object will be accessible remotely. A server may register multiple objects (services) of different types but it is an error to register multiple objects of the same type. </p> <p> Only methods that satisfy these criteria will be made available for remote access; other methods will be ignored: </p> <pre data-language=\"go\">- the method's type is exported.\n- the method is exported.\n- the method has two arguments, both exported (or builtin) types.\n- the method's second argument is a pointer.\n- the method has return type error.\n</pre> <p> In effect, the method must look schematically like </p> <pre data-language=\"go\">func (t *T) MethodName(argType T1, replyType *T2) error\n</pre> <p> where T, T1 and T2 can be marshaled by encoding/gob. These requirements apply even if a different codec is used. (In the future, these requirements may soften for custom codecs.) </p> <p> The method's first argument represents the arguments provided by the caller; the second argument represents the result parameters to be returned to the caller. The method's return value, if non-nil, is passed back as a string that the client sees as if created by errors.New. If an error is returned, the reply parameter will not be sent back to the client. </p> <p> The server may handle requests on a single connection by calling ServeConn. More typically it will create a network listener and call Accept or, for an HTTP listener, HandleHTTP and http.Serve. </p> <p> A client wishing to use the service establishes a connection and then invokes NewClient on the connection. The convenience function Dial (DialHTTP) performs both steps for a raw network connection (an HTTP connection). The resulting Client object has two methods, Call and Go, that specify the service and method to call, a pointer containing the arguments, and a pointer to receive the result parameters. </p> <p> The Call method waits for the remote call to complete while the Go method launches the call asynchronously and signals completion using the Call structure's Done channel. </p> <p> Unless an explicit codec is set up, package encoding/gob is used to transport the data. </p> <p> Here is a simple example. A server wishes to export an object of type Arith: </p> <pre data-language=\"go\">package server\n\ntype Args struct {\n\tA, B int\n}\n\ntype Quotient struct {\n\tQuo, Rem int\n}\n\ntype Arith int\n\nfunc (t *Arith) Multiply(args *Args, reply *int) error {\n\t*reply = args.A * args.B\n\treturn nil\n}\n\nfunc (t *Arith) Divide(args *Args, quo *Quotient) error {\n\tif args.B == 0 {\n\t\treturn errors.New(\"divide by zero\")\n\t}\n\tquo.Quo = args.A / args.B\n\tquo.Rem = args.A % args.B\n\treturn nil\n}\n</pre> <p> The server calls (for HTTP service): </p> <pre data-language=\"go\">arith := new(Arith)\nrpc.Register(arith)\nrpc.HandleHTTP()\nl, e := net.Listen(\"tcp\", \":1234\")\nif e != nil {\n\tlog.Fatal(\"listen error:\", e)\n}\ngo http.Serve(l, nil)\n</pre> <p> At this point, clients can see a service \"Arith\" with methods \"Arith.Multiply\" and \"Arith.Divide\". To invoke one, a client first dials the server: </p> <pre data-language=\"go\">client, err := rpc.DialHTTP(\"tcp\", serverAddress + \":1234\")\nif err != nil {\n\tlog.Fatal(\"dialing:\", err)\n}\n</pre> <p> Then it can make a remote call: </p> <pre data-language=\"go\">// Synchronous call\nargs := &amp;server.Args{7,8}\nvar reply int\nerr = client.Call(\"Arith.Multiply\", args, &amp;reply)\nif err != nil {\n\tlog.Fatal(\"arith error:\", err)\n}\nfmt.Printf(\"Arith: %d*%d=%d\", args.A, args.B, reply)\n</pre> <p> or </p> <pre data-language=\"go\">// Asynchronous call\nquotient := new(Quotient)\ndivCall := client.Go(\"Arith.Divide\", args, quotient, nil)\nreplyCall := &lt;-divCall.Done\t// will be equal to divCall\n// check errors, print, etc.\n</pre> <p> A server implementation will often provide a simple, type-safe wrapper for the client. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Accept\">func Accept(lis net.Listener)</a></li>\n<li><a href=\"#HandleHTTP\">func HandleHTTP()</a></li>\n<li><a href=\"#Register\">func Register(rcvr interface{}) error</a></li>\n<li><a href=\"#RegisterName\">func RegisterName(name string, rcvr interface{}) error</a></li>\n<li><a href=\"#ServeCodec\">func ServeCodec(codec ServerCodec)</a></li>\n<li><a href=\"#ServeConn\">func ServeConn(conn io.ReadWriteCloser)</a></li>\n<li><a href=\"#ServeRequest\">func ServeRequest(codec ServerCodec) error</a></li>\n<li><a href=\"#Call\">type Call</a></li>\n<li><a href=\"#Client\">type Client</a></li>\n<li> <a href=\"#Dial\">func Dial(network, address string) (*Client, error)</a>\n</li>\n<li> <a href=\"#DialHTTP\">func DialHTTP(network, address string) (*Client, error)</a>\n</li>\n<li> <a href=\"#DialHTTPPath\">func DialHTTPPath(network, address, path string) (*Client, error)</a>\n</li>\n<li> <a href=\"#NewClient\">func NewClient(conn io.ReadWriteCloser) *Client</a>\n</li>\n<li> <a href=\"#NewClientWithCodec\">func NewClientWithCodec(codec ClientCodec) *Client</a>\n</li>\n<li> <a href=\"#Client.Call\">func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error</a>\n</li>\n<li> <a href=\"#Client.Close\">func (client *Client) Close() error</a>\n</li>\n<li> <a href=\"#Client.Go\">func (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call</a>\n</li>\n<li><a href=\"#ClientCodec\">type ClientCodec</a></li>\n<li><a href=\"#Request\">type Request</a></li>\n<li><a href=\"#Response\">type Response</a></li>\n<li><a href=\"#Server\">type Server</a></li>\n<li> <a href=\"#NewServer\">func NewServer() *Server</a>\n</li>\n<li> <a href=\"#Server.Accept\">func (server *Server) Accept(lis net.Listener)</a>\n</li>\n<li> <a href=\"#Server.HandleHTTP\">func (server *Server) HandleHTTP(rpcPath, debugPath string)</a>\n</li>\n<li> <a href=\"#Server.Register\">func (server *Server) Register(rcvr interface{}) error</a>\n</li>\n<li> <a href=\"#Server.RegisterName\">func (server *Server) RegisterName(name string, rcvr interface{}) error</a>\n</li>\n<li> <a href=\"#Server.ServeCodec\">func (server *Server) ServeCodec(codec ServerCodec)</a>\n</li>\n<li> <a href=\"#Server.ServeConn\">func (server *Server) ServeConn(conn io.ReadWriteCloser)</a>\n</li>\n<li> <a href=\"#Server.ServeHTTP\">func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request)</a>\n</li>\n<li> <a href=\"#Server.ServeRequest\">func (server *Server) ServeRequest(codec ServerCodec) error</a>\n</li>\n<li><a href=\"#ServerCodec\">type ServerCodec</a></li>\n<li><a href=\"#ServerError\">type ServerError</a></li>\n<li> <a href=\"#ServerError.Error\">func (e ServerError) Error() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/rpc/client.go\">client.go</a> <a href=\"https://golang.org/src/net/rpc/debug.go\">debug.go</a> <a href=\"https://golang.org/src/net/rpc/server.go\">server.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        // Defaults used by HandleHTTP\n        DefaultRPCPath   = \"/_goRPC_\"\n        DefaultDebugPath = \"/debug/rpc\"\n)</pre> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var DefaultServer = NewServer()</pre> <p> DefaultServer is the default instance of *Server. </p> <pre data-language=\"go\">var ErrShutdown = errors.New(\"connection is shut down\")</pre> <h2 id=\"Accept\">func Accept  </h2> <pre data-language=\"go\">func Accept(lis net.Listener)</pre> <p> Accept accepts connections on the listener and serves requests to DefaultServer for each incoming connection. Accept blocks; the caller typically invokes it in a go statement. </p> <h2 id=\"HandleHTTP\">func HandleHTTP  </h2> <pre data-language=\"go\">func HandleHTTP()</pre> <p> HandleHTTP registers an HTTP handler for RPC messages to DefaultServer on DefaultRPCPath and a debugging handler on DefaultDebugPath. It is still necessary to invoke http.Serve(), typically in a go statement. </p> <h2 id=\"Register\">func Register  </h2> <pre data-language=\"go\">func Register(rcvr interface{}) error</pre> <p> Register publishes the receiver's methods in the DefaultServer. </p> <h2 id=\"RegisterName\">func RegisterName  </h2> <pre data-language=\"go\">func RegisterName(name string, rcvr interface{}) error</pre> <p> RegisterName is like Register but uses the provided name for the type instead of the receiver's concrete type. </p> <h2 id=\"ServeCodec\">func ServeCodec  </h2> <pre data-language=\"go\">func ServeCodec(codec ServerCodec)</pre> <p> ServeCodec is like ServeConn but uses the specified codec to decode requests and encode responses. </p> <h2 id=\"ServeConn\">func ServeConn  </h2> <pre data-language=\"go\">func ServeConn(conn io.ReadWriteCloser)</pre> <p> ServeConn runs the DefaultServer on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. </p> <h2 id=\"ServeRequest\">func ServeRequest  </h2> <pre data-language=\"go\">func ServeRequest(codec ServerCodec) error</pre> <p> ServeRequest is like ServeCodec but synchronously serves a single request. It does not close the codec upon completion. </p> <h2 id=\"Call\">type Call  </h2> <pre data-language=\"go\">type Call struct {\n        ServiceMethod string      // The name of the service and method to call.\n        Args          interface{} // The argument to the function (*struct).\n        Reply         interface{} // The reply from the function (*struct).\n        Error         error       // After completion, the error status.\n        Done          chan *Call  // Strobes when call is complete.\n}</pre> <p> Call represents an active RPC. </p> <h2 id=\"Client\">type Client  </h2> <pre data-language=\"go\">type Client struct {\n        // contains filtered or unexported fields\n}</pre> <p> Client represents an RPC Client. There may be multiple outstanding Calls associated with a single Client, and a Client may be used by multiple goroutines simultaneously. </p> <h3 id=\"Dial\">func <a href=\"https://golang.org/src/net/rpc/client.go?s=7220:7271#L259\">Dial</a>  </h3> <pre data-language=\"go\">func Dial(network, address string) (*Client, error)</pre> <p> Dial connects to an RPC server at the specified network address. </p> <h3 id=\"DialHTTP\">func <a href=\"https://golang.org/src/net/rpc/client.go?s=6273:6328#L226\">DialHTTP</a>  </h3> <pre data-language=\"go\">func DialHTTP(network, address string) (*Client, error)</pre> <p> DialHTTP connects to an HTTP RPC server at the specified network address listening on the default HTTP RPC path. </p> <h3 id=\"DialHTTPPath\">func <a href=\"https://golang.org/src/net/rpc/client.go?s=6482:6547#L232\">DialHTTPPath</a>  </h3> <pre data-language=\"go\">func DialHTTPPath(network, address, path string) (*Client, error)</pre> <p> DialHTTPPath connects to an HTTP RPC server at the specified network address and path. </p> <h3 id=\"NewClient\">func <a href=\"https://golang.org/src/net/rpc/client.go?s=5071:5118#L178\">NewClient</a>  </h3> <pre data-language=\"go\">func NewClient(conn io.ReadWriteCloser) *Client</pre> <p> NewClient returns a new Client to handle requests to the set of services at the other end of the connection. It adds a buffer to the write side of the connection so the header and payload are sent as a unit. </p> <h3 id=\"NewClientWithCodec\">func <a href=\"https://golang.org/src/net/rpc/client.go?s=5392:5442#L186\">NewClientWithCodec</a>  </h3> <pre data-language=\"go\">func NewClientWithCodec(codec ClientCodec) *Client</pre> <p> NewClientWithCodec is like NewClient but uses the specified codec to encode requests and decode responses. </p> <h3 id=\"Client.Call\">func (*Client) <a href=\"https://golang.org/src/net/rpc/client.go?s=8630:8721#L304\">Call</a>  </h3> <pre data-language=\"go\">func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error</pre> <p> Call invokes the named function, waits for it to complete, and returns its error status. </p> <h3 id=\"Client.Close\">func (*Client) <a href=\"https://golang.org/src/net/rpc/client.go?s=7385:7420#L267\">Close</a>  </h3> <pre data-language=\"go\">func (client *Client) Close() error</pre> <h3 id=\"Client.Go\">func (*Client) <a href=\"https://golang.org/src/net/rpc/client.go?s=7905:8011#L282\">Go</a>  </h3> <pre data-language=\"go\">func (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call</pre> <p> Go invokes the function asynchronously. It returns the Call structure representing the invocation. The done channel will signal when the call is complete by returning the same Call object. If done is nil, Go will allocate a new channel. If non-nil, done must be buffered or Go will deliberately crash. </p> <h2 id=\"ClientCodec\">type ClientCodec  </h2> <pre data-language=\"go\">type ClientCodec interface {\n        // WriteRequest must be safe for concurrent use by multiple goroutines.\n        WriteRequest(*Request, interface{}) error\n        ReadResponseHeader(*Response) error\n        ReadResponseBody(interface{}) error\n\n        Close() error\n}</pre> <p> A ClientCodec implements writing of RPC requests and reading of RPC responses for the client side of an RPC session. The client calls WriteRequest to write a request to the connection and calls ReadResponseHeader and ReadResponseBody in pairs to read responses. The client calls Close when finished with the connection. ReadResponseBody may be called with a nil argument to force the body of the response to be read and then discarded. </p> <h2 id=\"Request\">type Request  </h2> <pre data-language=\"go\">type Request struct {\n        ServiceMethod string // format: \"Service.Method\"\n        Seq           uint64 // sequence number chosen by client\n        // contains filtered or unexported fields\n}</pre> <p> Request is a header written before every RPC call. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic. </p> <h2 id=\"Response\">type Response  </h2> <pre data-language=\"go\">type Response struct {\n        ServiceMethod string // echoes that of the Request\n        Seq           uint64 // echoes that of the request\n        Error         string // error, if any.\n        // contains filtered or unexported fields\n}</pre> <p> Response is a header written before every RPC return. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic. </p> <h2 id=\"Server\">type Server  </h2> <pre data-language=\"go\">type Server struct {\n        // contains filtered or unexported fields\n}</pre> <p> Server represents an RPC Server. </p> <h3 id=\"NewServer\">func <a href=\"https://golang.org/src/net/rpc/server.go?s=5942:5966#L185\">NewServer</a>  </h3> <pre data-language=\"go\">func NewServer() *Server</pre> <p> NewServer returns a new Server. </p> <h3 id=\"Server.Accept\">func (*Server) <a href=\"https://golang.org/src/net/rpc/server.go?s=17989:18035#L607\">Accept</a>  </h3> <pre data-language=\"go\">func (server *Server) Accept(lis net.Listener)</pre> <p> Accept accepts connections on the listener and serves requests for each incoming connection. Accept blocks until the listener returns a non-nil error. The caller typically invokes Accept in a go statement. </p> <h3 id=\"Server.HandleHTTP\">func (*Server) <a href=\"https://golang.org/src/net/rpc/server.go?s=21127:21186#L692\">HandleHTTP</a>  </h3> <pre data-language=\"go\">func (server *Server) HandleHTTP(rpcPath, debugPath string)</pre> <p> HandleHTTP registers an HTTP handler for RPC messages on rpcPath, and a debugging handler on debugPath. It is still necessary to invoke http.Serve(), typically in a go statement. </p> <h3 id=\"Server.Register\">func (*Server) <a href=\"https://golang.org/src/net/rpc/server.go?s=7099:7153#L218\">Register</a>  </h3> <pre data-language=\"go\">func (server *Server) Register(rcvr interface{}) error</pre> <p> Register publishes in the server the set of methods of the receiver value that satisfy the following conditions: </p> <pre data-language=\"go\">- exported method of exported type\n- two arguments, both of exported type\n- the second argument is a pointer\n- one return value, of type error\n</pre> <p> It returns an error if the receiver is not an exported type or has no suitable methods. It also logs the error using package log. The client accesses each method using a string of the form \"Type.Method\", where Type is the receiver's concrete type. </p> <h3 id=\"Server.RegisterName\">func (*Server) <a href=\"https://golang.org/src/net/rpc/server.go?s=7317:7388#L224\">RegisterName</a>  </h3> <pre data-language=\"go\">func (server *Server) RegisterName(name string, rcvr interface{}) error</pre> <p> RegisterName is like Register but uses the provided name for the type instead of the receiver's concrete type. </p> <h3 id=\"Server.ServeCodec\">func (*Server) <a href=\"https://golang.org/src/net/rpc/server.go?s=13817:13868#L449\">ServeCodec</a>  </h3> <pre data-language=\"go\">func (server *Server) ServeCodec(codec ServerCodec)</pre> <p> ServeCodec is like ServeConn but uses the specified codec to decode requests and encode responses. </p> <h3 id=\"Server.ServeConn\">func (*Server) <a href=\"https://golang.org/src/net/rpc/server.go?s=13474:13530#L436\">ServeConn</a>  </h3> <pre data-language=\"go\">func (server *Server) ServeConn(conn io.ReadWriteCloser)</pre> <p> ServeConn runs the server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. </p> <h3 id=\"Server.ServeHTTP\">func (*Server) <a href=\"https://golang.org/src/net/rpc/server.go?s=20455:20528#L673\">ServeHTTP</a>  </h3> <pre data-language=\"go\">func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request)</pre> <p> ServeHTTP implements an http.Handler that answers RPC requests. </p> <h3 id=\"Server.ServeRequest\">func (*Server) <a href=\"https://golang.org/src/net/rpc/server.go?s=14531:14590#L474\">ServeRequest</a>  </h3> <pre data-language=\"go\">func (server *Server) ServeRequest(codec ServerCodec) error</pre> <p> ServeRequest is like ServeCodec but synchronously serves a single request. It does not close the codec upon completion. </p> <h2 id=\"ServerCodec\">type ServerCodec  </h2> <pre data-language=\"go\">type ServerCodec interface {\n        ReadRequestHeader(*Request) error\n        ReadRequestBody(interface{}) error\n        // WriteResponse must be safe for concurrent use by multiple goroutines.\n        WriteResponse(*Response, interface{}) error\n\n        Close() error\n}</pre> <p> A ServerCodec implements reading of RPC requests and writing of RPC responses for the server side of an RPC session. The server calls ReadRequestHeader and ReadRequestBody in pairs to read requests from the connection, and it calls WriteResponse to write a response back. The server calls Close when finished with the connection. ReadRequestBody may be called with a nil argument to force the body of the request to be read and discarded. </p> <h2 id=\"ServerError\">type ServerError  </h2> <pre data-language=\"go\">type ServerError string</pre> <p> ServerError represents an error that has been returned from the remote side of the RPC connection. </p> <h3 id=\"ServerError.Error\">func (ServerError) <a href=\"https://golang.org/src/net/rpc/client.go?s=390:425#L12\">Error</a>  </h3> <pre data-language=\"go\">func (e ServerError) Error() string</pre> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"jsonrpc/index\">jsonrpc</a> </td> <td class=\"pkg-synopsis\"> Package jsonrpc implements a JSON-RPC ClientCodec and ServerCodec for the rpc package. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/rpc/\" class=\"_attribution-link\">https://golang.org/pkg/net/rpc/</a>\n  </p>\n</div>\n","net/smtp/index":"<h1>Package smtp</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/smtp\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321. It also implements the following extensions: </p> <pre data-language=\"go\">8BITMIME  RFC 1652\nAUTH      RFC 2554\nSTARTTLS  RFC 3207\n</pre> <p> Additional extensions may be handled by clients. </p> <p> The smtp package is frozen and not accepting new features. Some external packages provide more functionality. See: </p> <pre data-language=\"go\">https://godoc.org/?q=smtp\n</pre> </div> </div> <div id=\"example_\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    // Connect to the remote SMTP server.\n    c, err := smtp.Dial(\"mail.example.com:25\")\n    if err != nil {\n            log.Fatal(err)\n    }\n\n    // Set the sender and recipient first\n    if err := c.Mail(\"sender@example.org\"); err != nil {\n            log.Fatal(err)\n    }\n    if err := c.Rcpt(\"recipient@example.net\"); err != nil {\n            log.Fatal(err)\n    }\n\n    // Send the email body.\n    wc, err := c.Data()\n    if err != nil {\n            log.Fatal(err)\n    }\n    _, err = fmt.Fprintf(wc, \"This is the email body\")\n    if err != nil {\n            log.Fatal(err)\n    }\n    err = wc.Close()\n    if err != nil {\n            log.Fatal(err)\n    }\n\n    // Send the QUIT command and close the connection.\n    err = c.Quit()\n    if err != nil {\n            log.Fatal(err)\n    }\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#SendMail\">func SendMail(addr string, a Auth, from string, to []string, msg []byte) error</a></li>\n<li><a href=\"#Auth\">type Auth</a></li>\n<li> <a href=\"#CRAMMD5Auth\">func CRAMMD5Auth(username, secret string) Auth</a>\n</li>\n<li> <a href=\"#PlainAuth\">func PlainAuth(identity, username, password, host string) Auth</a>\n</li>\n<li><a href=\"#Client\">type Client</a></li>\n<li> <a href=\"#Dial\">func Dial(addr string) (*Client, error)</a>\n</li>\n<li> <a href=\"#NewClient\">func NewClient(conn net.Conn, host string) (*Client, error)</a>\n</li>\n<li> <a href=\"#Client.Auth\">func (c *Client) Auth(a Auth) error</a>\n</li>\n<li> <a href=\"#Client.Close\">func (c *Client) Close() error</a>\n</li>\n<li> <a href=\"#Client.Data\">func (c *Client) Data() (io.WriteCloser, error)</a>\n</li>\n<li> <a href=\"#Client.Extension\">func (c *Client) Extension(ext string) (bool, string)</a>\n</li>\n<li> <a href=\"#Client.Hello\">func (c *Client) Hello(localName string) error</a>\n</li>\n<li> <a href=\"#Client.Mail\">func (c *Client) Mail(from string) error</a>\n</li>\n<li> <a href=\"#Client.Quit\">func (c *Client) Quit() error</a>\n</li>\n<li> <a href=\"#Client.Rcpt\">func (c *Client) Rcpt(to string) error</a>\n</li>\n<li> <a href=\"#Client.Reset\">func (c *Client) Reset() error</a>\n</li>\n<li> <a href=\"#Client.StartTLS\">func (c *Client) StartTLS(config *tls.Config) error</a>\n</li>\n<li> <a href=\"#Client.TLSConnectionState\">func (c *Client) TLSConnectionState() (state tls.ConnectionState, ok bool)</a>\n</li>\n<li> <a href=\"#Client.Verify\">func (c *Client) Verify(addr string) error</a>\n</li>\n<li><a href=\"#ServerInfo\">type ServerInfo</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_\">Package</a></dd> <dd><a class=\"exampleLink\" href=\"#example_PlainAuth\">PlainAuth</a></dd> <dd><a class=\"exampleLink\" href=\"#example_SendMail\">SendMail</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/smtp/auth.go\">auth.go</a> <a href=\"https://golang.org/src/net/smtp/smtp.go\">smtp.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"SendMail\">func SendMail  </h2> <pre data-language=\"go\">func SendMail(addr string, a Auth, from string, to []string, msg []byte) error</pre> <p> SendMail connects to the server at addr, switches to TLS if possible, authenticates with the optional mechanism a if possible, and then sends an email from address from, to addresses to, with message msg. The addr must include a port, as in \"mail.example.com:smtp\". </p> <p> The addresses in the to parameter are the SMTP RCPT addresses. </p> <p> The msg parameter should be an RFC 822-style email with headers first, a blank line, and then the message body. The lines of msg should be CRLF terminated. The msg headers should usually include fields such as \"From\", \"To\", \"Subject\", and \"Cc\". Sending \"Bcc\" messages is accomplished by including an email address in the to parameter but not including it in the msg headers. </p> <p> The SendMail function and the the net/smtp package are low-level mechanisms and provide no support for DKIM signing, MIME attachments (see the mime/multipart package), or other mail functionality. Higher-level packages exist outside of the standard library. </p> <div id=\"example_SendMail\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"log\"\n\t\"net/smtp\"\n)\n\nfunc main() {\n\t// Set up authentication information.\n\tauth := smtp.PlainAuth(\"\", \"user@example.com\", \"password\", \"mail.example.com\")\n\n\t// Connect to the server, authenticate, set the sender and recipient,\n\t// and send the email all in one step.\n\tto := []string{\"recipient@example.net\"}\n\tmsg := []byte(\"To: recipient@example.net\\r\\n\" +\n\t\t\"Subject: discount Gophers!\\r\\n\" +\n\t\t\"\\r\\n\" +\n\t\t\"This is the email body.\\r\\n\")\n\terr := smtp.SendMail(\"mail.example.com:25\", auth, \"sender@example.org\", to, msg)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n</pre> </div> </div> <h2 id=\"Auth\">type Auth  </h2> <pre data-language=\"go\">type Auth interface {\n        // Start begins an authentication with a server.\n        // It returns the name of the authentication protocol\n        // and optionally data to include in the initial AUTH message\n        // sent to the server. It can return proto == \"\" to indicate\n        // that the authentication should be skipped.\n        // If it returns a non-nil error, the SMTP client aborts\n        // the authentication attempt and closes the connection.\n        Start(server *ServerInfo) (proto string, toServer []byte, err error)\n\n        // Next continues the authentication. The server has just sent\n        // the fromServer data. If more is true, the server expects a\n        // response, which Next should return as toServer; otherwise\n        // Next should return toServer == nil.\n        // If Next returns a non-nil error, the SMTP client aborts\n        // the authentication attempt and closes the connection.\n        Next(fromServer []byte, more bool) (toServer []byte, err error)\n}</pre> <p> Auth is implemented by an SMTP authentication mechanism. </p> <h3 id=\"CRAMMD5Auth\">func <a href=\"https://golang.org/src/net/smtp/auth.go?s=2924:2970#L81\">CRAMMD5Auth</a>  </h3> <pre data-language=\"go\">func CRAMMD5Auth(username, secret string) Auth</pre> <p> CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication mechanism as defined in RFC 2195. The returned Auth uses the given username and secret to authenticate to the server using the challenge-response mechanism. </p> <h3 id=\"PlainAuth\">func <a href=\"https://golang.org/src/net/smtp/auth.go?s=1820:1882#L41\">PlainAuth</a>  </h3> <pre data-language=\"go\">func PlainAuth(identity, username, password, host string) Auth</pre> <p> PlainAuth returns an Auth that implements the PLAIN authentication mechanism as defined in RFC 4616. The returned Auth uses the given username and password to authenticate on TLS connections to host and act as identity. Usually identity will be left blank to act as username. </p> <div id=\"example_PlainAuth\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    // hostname is used by PlainAuth to validate the TLS certificate.\n    hostname := \"mail.example.com\"\n    auth := smtp.PlainAuth(\"\", \"user@example.com\", \"password\", hostname)\n\n    err := smtp.SendMail(hostname+\":25\", auth, from, recipients, msg)\n    if err != nil {\n            log.Fatal(err)\n    }\n</pre> </div> </div> <h2 id=\"Client\">type Client  </h2> <pre data-language=\"go\">type Client struct {\n        // Text is the textproto.Conn used by the Client. It is exported to allow for\n        // clients to add extensions.\n        Text *textproto.Conn\n        // contains filtered or unexported fields\n}</pre> <p> A Client represents a client connection to an SMTP server. </p> <h3 id=\"Dial\">func <a href=\"https://golang.org/src/net/smtp/smtp.go?s=1463:1502#L40\">Dial</a>  </h3> <pre data-language=\"go\">func Dial(addr string) (*Client, error)</pre> <p> Dial returns a new Client connected to an SMTP server at addr. The addr must include a port, as in \"mail.example.com:smtp\". </p> <h3 id=\"NewClient\">func <a href=\"https://golang.org/src/net/smtp/smtp.go?s=1775:1834#L51\">NewClient</a>  </h3> <pre data-language=\"go\">func NewClient(conn net.Conn, host string) (*Client, error)</pre> <p> NewClient returns a new Client using an existing connection and host as a server name to be used when authenticating. </p> <h3 id=\"Client.Auth\">func (*Client) <a href=\"https://golang.org/src/net/smtp/smtp.go?s=5436:5471#L181\">Auth</a>  </h3> <pre data-language=\"go\">func (c *Client) Auth(a Auth) error</pre> <p> Auth authenticates a client using the provided authentication mechanism. A failed authentication closes the connection. Only servers that advertise the AUTH extension support this function. </p> <h3 id=\"Client.Close\">func (*Client) <a href=\"https://golang.org/src/net/smtp/smtp.go?s=2090:2120#L63\">Close</a>  </h3> <pre data-language=\"go\">func (c *Client) Close() error</pre> <p> Close closes the connection. </p> <h3 id=\"Client.Data\">func (*Client) <a href=\"https://golang.org/src/net/smtp/smtp.go?s=7660:7707#L265\">Data</a>  </h3> <pre data-language=\"go\">func (c *Client) Data() (io.WriteCloser, error)</pre> <p> Data issues a DATA command to the server and returns a writer that can be used to write the mail headers and body. The caller should close the writer before calling any more methods on c. A call to Data must be preceded by one or more calls to Rcpt. </p> <h3 id=\"Client.Extension\">func (*Client) <a href=\"https://golang.org/src/net/smtp/smtp.go?s=10039:10092#L347\">Extension</a>  </h3> <pre data-language=\"go\">func (c *Client) Extension(ext string) (bool, string)</pre> <p> Extension reports whether an extension is support by the server. The extension name is case-insensitive. If the extension is supported, Extension also returns a string that contains any parameters the server specifies for the extension. </p> <h3 id=\"Client.Hello\">func (*Client) <a href=\"https://golang.org/src/net/smtp/smtp.go?s=2671:2717#L84\">Hello</a>  </h3> <pre data-language=\"go\">func (c *Client) Hello(localName string) error</pre> <p> Hello sends a HELO or EHLO to the server as the given host name. Calling this method is only necessary if the client needs control over the host name used. The client will introduce itself as \"localhost\" automatically otherwise. If Hello is called, it must be called before any of the other methods. </p> <h3 id=\"Client.Mail\">func (*Client) <a href=\"https://golang.org/src/net/smtp/smtp.go?s=6666:6706#L228\">Mail</a>  </h3> <pre data-language=\"go\">func (c *Client) Mail(from string) error</pre> <p> Mail issues a MAIL command to the server using the provided email address. If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME parameter. This initiates a mail transaction and is followed by one or more Rcpt calls. </p> <h3 id=\"Client.Quit\">func (*Client) <a href=\"https://golang.org/src/net/smtp/smtp.go?s=10560:10589#L370\">Quit</a>  </h3> <pre data-language=\"go\">func (c *Client) Quit() error</pre> <p> Quit sends the QUIT command and closes the connection to the server. </p> <h3 id=\"Client.Rcpt\">func (*Client) <a href=\"https://golang.org/src/net/smtp/smtp.go?s=7127:7165#L245\">Rcpt</a>  </h3> <pre data-language=\"go\">func (c *Client) Rcpt(to string) error</pre> <p> Rcpt issues a RCPT command to the server using the provided email address. A call to Rcpt must be preceded by a call to Mail and may be followed by a Data call or another Rcpt call. </p> <h3 id=\"Client.Reset\">func (*Client) <a href=\"https://golang.org/src/net/smtp/smtp.go?s=10356:10386#L361\">Reset</a>  </h3> <pre data-language=\"go\">func (c *Client) Reset() error</pre> <p> Reset sends the RSET command to the server, aborting the current mail transaction. </p> <h3 id=\"Client.StartTLS\">func (*Client) <a href=\"https://golang.org/src/net/smtp/smtp.go?s=4248:4299#L141\">StartTLS</a>  </h3> <pre data-language=\"go\">func (c *Client) StartTLS(config *tls.Config) error</pre> <p> StartTLS sends the STARTTLS command and encrypts all further communication. Only servers that advertise the STARTTLS extension support this function. </p> <h3 id=\"Client.TLSConnectionState\">func (*Client) <a href=\"https://golang.org/src/net/smtp/smtp.go?s=4670:4744#L158\">TLSConnectionState</a>  </h3> <pre data-language=\"go\">func (c *Client) TLSConnectionState() (state tls.ConnectionState, ok bool)</pre> <p> TLSConnectionState returns the client's TLS connection state. The return values are their zero values if StartTLS did not succeed. </p> <h3 id=\"Client.Verify\">func (*Client) <a href=\"https://golang.org/src/net/smtp/smtp.go?s=5084:5126#L170\">Verify</a>  </h3> <pre data-language=\"go\">func (c *Client) Verify(addr string) error</pre> <p> Verify checks the validity of an email address on the server. If Verify returns nil, the address is valid. A non-nil return does not necessarily indicate an invalid address. Many servers will not verify addresses for security reasons. </p> <h2 id=\"ServerInfo\">type ServerInfo  </h2> <pre data-language=\"go\">type ServerInfo struct {\n        Name string   // SMTP server name\n        TLS  bool     // using TLS, with valid certificate for Name\n        Auth []string // advertised authentication mechanisms\n}</pre> <p> ServerInfo records information about an SMTP server. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/smtp/\" class=\"_attribution-link\">https://golang.org/pkg/net/smtp/</a>\n  </p>\n</div>\n","os/signal/index":"<h1>Package signal</h1>     <ul id=\"short-nav\">\n<li><code>import \"os/signal\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package signal implements access to incoming signals. </p> <p> Signals are primarily used on Unix-like systems. For the use of this package on Windows and Plan 9, see below. </p> <h3 id=\"hdr-Types_of_signals\">Types of signals</h3> <p> The signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package. </p> <p> Synchronous signals are signals triggered by errors in program execution: SIGBUS, SIGFPE, and SIGSEGV. These are only considered synchronous when caused by program execution, not when sent using os.Process.Kill or the kill program or some similar mechanism. In general, except as discussed below, Go programs will convert a synchronous signal into a run-time panic. </p> <p> The remaining signals are asynchronous signals. They are not triggered by program errors, but are instead sent from the kernel or from some other program. </p> <p> Of the asynchronous signals, the SIGHUP signal is sent when a program loses its controlling terminal. The SIGINT signal is sent when the user at the controlling terminal presses the interrupt character, which by default is ^C (Control-C). The SIGQUIT signal is sent when the user at the controlling terminal presses the quit character, which by default is ^\\ (Control-Backslash). In general you can cause a program to simply exit by pressing ^C, and you can cause it to exit with a stack dump by pressing ^\\. </p> <h3 id=\"hdr-Default_behavior_of_signals_in_Go_programs\">Default behavior of signals in Go programs</h3> <p> By default, a synchronous signal is converted into a run-time panic. A SIGHUP, SIGINT, or SIGTERM signal causes the program to exit. A SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal causes the program to exit with a stack dump. A SIGTSTP, SIGTTIN, or SIGTTOU signal gets the system default behavior (these signals are used by the shell for job control). The SIGPROF signal is handled directly by the Go runtime to implement runtime.CPUProfile. Other signals will be caught but no action will be taken. </p> <p> If the Go program is started with either SIGHUP or SIGINT ignored (signal handler set to SIG_IGN), they will remain ignored. </p> <p> If the Go program is started with a non-empty signal mask, that will generally be honored. However, some signals are explicitly unblocked: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, and, on GNU/Linux, signals 32 (SIGCANCEL) and 33 (SIGSETXID) (SIGCANCEL and SIGSETXID are used internally by glibc). Subprocesses started by os.Exec, or by the os/exec package, will inherit the modified signal mask. </p> <h3 id=\"hdr-Changing_the_behavior_of_signals_in_Go_programs\">Changing the behavior of signals in Go programs</h3> <p> The functions in this package allow a program to change the way Go programs handle signals. </p> <p> Notify disables the default behavior for a given set of asynchronous signals and instead delivers them over one or more registered channels. Specifically, it applies to the signals SIGHUP, SIGINT, SIGQUIT, SIGABRT, and SIGTERM. It also applies to the job control signals SIGTSTP, SIGTTIN, and SIGTTOU, in which case the system default behavior does not occur. It also applies to some signals that otherwise cause no action: SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH, SIGIO, SIGPWR, SIGSYS, SIGINFO, SIGTHR, SIGWAITING, SIGLWP, SIGFREEZE, SIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2, and any real time signals used on the system. Note that not all of these signals are available on all systems. </p> <p> If the program was started with SIGHUP or SIGINT ignored, and Notify is called for either signal, a signal handler will be installed for that signal and it will no longer be ignored. If, later, Reset or Ignore is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be ignored. Reset will restore the system default behavior for the signal, while Ignore will cause the system to ignore the signal entirely. </p> <p> If the program is started with a non-empty signal mask, some signals will be explicitly unblocked as described above. If Notify is called for a blocked signal, it will be unblocked. If, later, Reset is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be blocked. </p> <h3 id=\"hdr-SIGPIPE\">SIGPIPE</h3> <p> When a Go program writes to a broken pipe, the kernel will raise a SIGPIPE signal. </p> <p> If the program has not called Notify to receive SIGPIPE signals, then the behavior depends on the file descriptor number. A write to a broken pipe on file descriptors 1 or 2 (standard output or standard error) will cause the program to exit with a SIGPIPE signal. A write to a broken pipe on some other file descriptor will take no action on the SIGPIPE signal, and the write will fail with an EPIPE error. </p> <p> If the program has called Notify to receive SIGPIPE signals, the file descriptor number does not matter. The SIGPIPE signal will be delivered to the Notify channel, and the write will fail with an EPIPE error. </p> <p> This means that, by default, command line programs will behave like typical Unix command line programs, while other programs will not crash with SIGPIPE when writing to a closed network connection. </p> <h3 id=\"hdr-Go_programs_that_use_cgo_or_SWIG\">Go programs that use cgo or SWIG</h3> <p> In a Go program that includes non-Go code, typically C/C++ code accessed using cgo or SWIG, Go's startup code normally runs first. It configures the signal handlers as expected by the Go runtime, before the non-Go startup code runs. If the non-Go startup code wishes to install its own signal handlers, it must take certain steps to keep Go working well. This section documents those steps and the overall effect changes to signal handler settings by the non-Go code can have on Go programs. In rare cases, the non-Go code may run before the Go code, in which case the next section also applies. </p> <p> If the non-Go code called by the Go program does not change any signal handlers or masks, then the behavior is the same as for a pure Go program. </p> <p> If the non-Go code installs any signal handlers, it must use the SA_ONSTACK flag with sigaction. Failing to do so is likely to cause the program to crash if the signal is received. Go programs routinely run with a limited stack, and therefore set up an alternate signal stack. Also, the Go standard library expects that any signal handlers will use the SA_RESTART flag. Failing to do so may cause some library calls to return \"interrupted system call\" errors. </p> <p> If the non-Go code installs a signal handler for any of the synchronous signals (SIGBUS, SIGFPE, SIGSEGV), then it should record the existing Go signal handler. If those signals occur while executing Go code, it should invoke the Go signal handler (whether the signal occurs while executing Go code can be determined by looking at the PC passed to the signal handler). Otherwise some Go run-time panics will not occur as expected. </p> <p> If the non-Go code installs a signal handler for any of the asynchronous signals, it may invoke the Go signal handler or not as it chooses. Naturally, if it does not invoke the Go signal handler, the Go behavior described above will not occur. This can be an issue with the SIGPROF signal in particular. </p> <p> The non-Go code should not change the signal mask on any threads created by the Go runtime. If the non-Go code starts new threads of its own, it may set the signal mask as it pleases. </p> <p> If the non-Go code starts a new thread, changes the signal mask, and then invokes a Go function in that thread, the Go runtime will automatically unblock certain signals: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, SIGCANCEL, and SIGSETXID. When the Go function returns, the non-Go signal mask will be restored. </p> <p> If the Go signal handler is invoked on a non-Go thread not running Go code, the handler generally forwards the signal to the non-Go code, as follows. If the signal is SIGPROF, the Go handler does nothing. Otherwise, the Go handler removes itself, unblocks the signal, and raises it again, to invoke any non-Go handler or default system handler. If the program does not exit, the Go handler then reinstalls itself and continues execution of the program. </p> <h3 id=\"hdr-Non_Go_programs_that_call_Go_code\">Non-Go programs that call Go code</h3> <p> When Go code is built with options like -buildmode=c-shared, it will be run as part of an existing non-Go program. The non-Go code may have already installed signal handlers when the Go code starts (that may also happen in unusual cases when using cgo or SWIG; in that case, the discussion here applies). For -buildmode=c-archive the Go runtime will initialize signals at global constructor time. For -buildmode=c-shared the Go runtime will initialize signals when the shared library is loaded. </p> <p> If the Go runtime sees an existing signal handler for the SIGCANCEL or SIGSETXID signals (which are used only on GNU/Linux), it will turn on the SA_ONSTACK flag and otherwise keep the signal handler. </p> <p> For the synchronous signals, the Go runtime will install a signal handler. It will save any existing signal handler. If a synchronous signal arrives while executing non-Go code, the Go runtime will invoke the existing signal handler instead of the Go signal handler. </p> <p> Go code built with -buildmode=c-archive or -buildmode=c-shared will not install any other signal handlers by default. If there is an existing signal handler, the Go runtime will turn on the SA_ONSTACK flag and otherwise keep the signal handler. If Notify is called for an asynchronous signal, a Go signal handler will be installed for that signal. If, later, Reset is called for that signal, the original handling for that signal will be reinstalled, restoring the non-Go signal handler if any. </p> <p> Go code built without -buildmode=c-archive or -buildmode=c-shared will install a signal handler for the asynchronous signals listed above, and save any existing signal handler. If a signal is delivered to a non-Go thread, it will act as described above, except that if there is an existing non-Go signal handler, that handler will be installed before raising the signal. </p> <h3 id=\"hdr-Windows\">Windows</h3> <p> On Windows a ^C (Control-C) or ^BREAK (Control-Break) normally cause the program to exit. If Notify is called for os.Interrupt, ^C or ^BREAK will cause os.Interrupt to be sent on the channel, and the program will not exit. If Reset is called, or Stop is called on all channels passed to Notify, then the default behavior will be restored. </p> <h3 id=\"hdr-Plan_9\">Plan 9</h3> <p> On Plan 9, signals have type syscall.Note, which is a string. Calling Notify with a syscall.Note will cause that value to be sent on the channel when that string is posted as a note. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Ignore\">func Ignore(sig ...os.Signal)</a></li>\n<li><a href=\"#Notify\">func Notify(c chan&lt;- os.Signal, sig ...os.Signal)</a></li>\n<li><a href=\"#Reset\">func Reset(sig ...os.Signal)</a></li>\n<li><a href=\"#Stop\">func Stop(c chan&lt;- os.Signal)</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Notify\">Notify</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/os/signal/doc.go\">doc.go</a> <a href=\"https://golang.org/src/os/signal/signal.go\">signal.go</a> <a href=\"https://golang.org/src/os/signal/signal_unix.go\">signal_unix.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Ignore\">func Ignore  </h2> <pre data-language=\"go\">func Ignore(sig ...os.Signal)</pre> <p> Ignore causes the provided signals to be ignored. If they are received by the program, nothing will happen. Ignore undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all incoming signals will be ignored. </p> <h2 id=\"Notify\">func Notify  </h2> <pre data-language=\"go\">func Notify(c chan&lt;- os.Signal, sig ...os.Signal)</pre> <p> Notify causes package signal to relay incoming signals to c. If no signals are provided, all incoming signals will be relayed to c. Otherwise, just the provided signals will. </p> <p> Package signal will not block sending to c: the caller must ensure that c has sufficient buffer space to keep up with the expected signal rate. For a channel used for notification of just one signal value, a buffer of size 1 is sufficient. </p> <p> It is allowed to call Notify multiple times with the same channel: each call expands the set of signals sent to that channel. The only way to remove signals from the set is to call Stop. </p> <p> It is allowed to call Notify multiple times with different channels and the same signals: each channel receives copies of incoming signals independently. </p> <div id=\"example_Notify\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n)\n\nfunc main() {\n\t// Set up channel on which to send signal notifications.\n\t// We must use a buffered channel or risk missing the signal\n\t// if we're not ready to receive when the signal is sent.\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, os.Interrupt)\n\n\t// Block until a signal is received.\n\ts := &lt;-c\n\tfmt.Println(\"Got signal:\", s)\n}\n</pre> </div> </div> <h2 id=\"Reset\">func Reset  </h2> <pre data-language=\"go\">func Reset(sig ...os.Signal)</pre> <p> Reset undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all signal handlers will be reset. </p> <h2 id=\"Stop\">func Stop  </h2> <pre data-language=\"go\">func Stop(c chan&lt;- os.Signal)</pre> <p> Stop causes package signal to stop relaying incoming signals to c. It undoes the effect of all prior calls to Notify using c. When Stop returns, it is guaranteed that c will receive no more signals. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/os/signal/\" class=\"_attribution-link\">https://golang.org/pkg/os/signal/</a>\n  </p>\n</div>\n","path/index":"<h1>Package path</h1>     <ul id=\"short-nav\">\n<li><code>import \"path\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package path implements utility routines for manipulating slash-separated paths. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Base\">func Base(path string) string</a></li>\n<li><a href=\"#Clean\">func Clean(path string) string</a></li>\n<li><a href=\"#Dir\">func Dir(path string) string</a></li>\n<li><a href=\"#Ext\">func Ext(path string) string</a></li>\n<li><a href=\"#IsAbs\">func IsAbs(path string) bool</a></li>\n<li><a href=\"#Join\">func Join(elem ...string) string</a></li>\n<li><a href=\"#Match\">func Match(pattern, name string) (matched bool, err error)</a></li>\n<li><a href=\"#Split\">func Split(path string) (dir, file string)</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Base\">Base</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Clean\">Clean</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Dir\">Dir</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Ext\">Ext</a></dd> <dd><a class=\"exampleLink\" href=\"#example_IsAbs\">IsAbs</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Join\">Join</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Split\">Split</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/path/match.go\">match.go</a> <a href=\"https://golang.org/src/path/path.go\">path.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrBadPattern = errors.New(\"syntax error in pattern\")</pre> <p> ErrBadPattern indicates a globbing pattern was malformed. </p> <h2 id=\"Base\">func Base  </h2> <pre data-language=\"go\">func Base(path string) string</pre> <p> Base returns the last element of path. Trailing slashes are removed before extracting the last element. If the path is empty, Base returns \".\". If the path consists entirely of slashes, Base returns \"/\". </p> <div id=\"example_Base\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"path\"\n)\n\nfunc main() {\n\tfmt.Println(path.Base(\"/a/b\"))\n}\n</pre> </div> </div> <h2 id=\"Clean\">func Clean  </h2> <pre data-language=\"go\">func Clean(path string) string</pre> <p> Clean returns the shortest path name equivalent to path by purely lexical processing. It applies the following rules iteratively until no further processing can be done: </p> <pre data-language=\"go\">1. Replace multiple slashes with a single slash.\n2. Eliminate each . path name element (the current directory).\n3. Eliminate each inner .. path name element (the parent directory)\n   along with the non-.. element that precedes it.\n4. Eliminate .. elements that begin a rooted path:\n   that is, replace \"/..\" by \"/\" at the beginning of a path.\n</pre> <p> The returned path ends in a slash only if it is the root \"/\". </p> <p> If the result of this process is an empty string, Clean returns the string \".\". </p> <p> See also Rob Pike, “Lexical File Names in Plan 9 or Getting Dot-Dot Right,” <a href=\"https://9p.io/sys/doc/lexnames.html\">https://9p.io/sys/doc/lexnames.html</a> </p> <div id=\"example_Clean\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"path\"\n)\n\nfunc main() {\n\tpaths := []string{\n\t\t\"a/c\",\n\t\t\"a//c\",\n\t\t\"a/c/.\",\n\t\t\"a/c/b/..\",\n\t\t\"/../a/c\",\n\t\t\"/../a/b/../././/c\",\n\t}\n\n\tfor _, p := range paths {\n\t\tfmt.Printf(\"Clean(%q) = %q\\n\", p, path.Clean(p))\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"Dir\">func Dir  </h2> <pre data-language=\"go\">func Dir(path string) string</pre> <p> Dir returns all but the last element of path, typically the path's directory. After dropping the final element using Split, the path is Cleaned and trailing slashes are removed. If the path is empty, Dir returns \".\". If the path consists entirely of slashes followed by non-slash bytes, Dir returns a single slash. In any other case, the returned path does not end in a slash. </p> <div id=\"example_Dir\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"path\"\n)\n\nfunc main() {\n\tfmt.Println(path.Dir(\"/a/b/c\"))\n}\n</pre> </div> </div> <h2 id=\"Ext\">func Ext  </h2> <pre data-language=\"go\">func Ext(path string) string</pre> <p> Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final slash-separated element of path; it is empty if there is no dot. </p> <div id=\"example_Ext\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"path\"\n)\n\nfunc main() {\n\tfmt.Println(path.Ext(\"/a/b/c/bar.css\"))\n}\n</pre> </div> </div> <h2 id=\"IsAbs\">func IsAbs  </h2> <pre data-language=\"go\">func IsAbs(path string) bool</pre> <p> IsAbs reports whether the path is absolute. </p> <div id=\"example_IsAbs\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"path\"\n)\n\nfunc main() {\n\tfmt.Println(path.IsAbs(\"/dev/null\"))\n}\n</pre> </div> </div> <h2 id=\"Join\">func Join  </h2> <pre data-language=\"go\">func Join(elem ...string) string</pre> <p> Join joins any number of path elements into a single path, adding a separating slash if necessary. The result is Cleaned; in particular, all empty strings are ignored. </p> <div id=\"example_Join\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"path\"\n)\n\nfunc main() {\n\tfmt.Println(path.Join(\"a\", \"b\", \"c\"))\n\tfmt.Println(path.Join(\"a\", \"b/c\"))\n\tfmt.Println(path.Join(\"a/b\", \"c\"))\n\tfmt.Println(path.Join(\"a/b\", \"/c\"))\n}\n</pre> </div> </div> <h2 id=\"Match\">func Match  </h2> <pre data-language=\"go\">func Match(pattern, name string) (matched bool, err error)</pre> <p> Match reports whether name matches the shell file name pattern. The pattern syntax is: </p> <pre data-language=\"go\">pattern:\n\t{ term }\nterm:\n\t'*'         matches any sequence of non-/ characters\n\t'?'         matches any single non-/ character\n\t'[' [ '^' ] { character-range } ']'\n\t            character class (must be non-empty)\n\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t'\\\\' c      matches character c\n\ncharacter-range:\n\tc           matches character c (c != '\\\\', '-', ']')\n\t'\\\\' c      matches character c\n\tlo '-' hi   matches character c for lo &lt;= c &lt;= hi\n</pre> <p> Match requires pattern to match all of name, not just a substring. The only possible returned error is ErrBadPattern, when pattern is malformed. </p> <h2 id=\"Split\">func Split  </h2> <pre data-language=\"go\">func Split(path string) (dir, file string)</pre> <p> Split splits path immediately following the final slash, separating it into a directory and file name component. If there is no slash in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file. </p> <div id=\"example_Split\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"path\"\n)\n\nfunc main() {\n\tfmt.Println(path.Split(\"static/myfile.css\"))\n}\n</pre> </div> </div> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"filepath/index\">filepath</a> </td> <td class=\"pkg-synopsis\"> Package filepath implements utility routines for manipulating filename paths in a way compatible with the target operating system-defined file paths. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/path/\" class=\"_attribution-link\">https://golang.org/pkg/path/</a>\n  </p>\n</div>\n","net/url/index":"<h1>Package url</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/url\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package url parses URLs and implements query escaping. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#QueryEscape\">func QueryEscape(s string) string</a></li>\n<li><a href=\"#QueryUnescape\">func QueryUnescape(s string) (string, error)</a></li>\n<li><a href=\"#Error\">type Error</a></li>\n<li> <a href=\"#Error.Error\">func (e *Error) Error() string</a>\n</li>\n<li> <a href=\"#Error.Temporary\">func (e *Error) Temporary() bool</a>\n</li>\n<li> <a href=\"#Error.Timeout\">func (e *Error) Timeout() bool</a>\n</li>\n<li><a href=\"#EscapeError\">type EscapeError</a></li>\n<li> <a href=\"#EscapeError.Error\">func (e EscapeError) Error() string</a>\n</li>\n<li><a href=\"#InvalidHostError\">type InvalidHostError</a></li>\n<li> <a href=\"#InvalidHostError.Error\">func (e InvalidHostError) Error() string</a>\n</li>\n<li><a href=\"#URL\">type URL</a></li>\n<li> <a href=\"#Parse\">func Parse(rawurl string) (*URL, error)</a>\n</li>\n<li> <a href=\"#ParseRequestURI\">func ParseRequestURI(rawurl string) (*URL, error)</a>\n</li>\n<li> <a href=\"#URL.EscapedPath\">func (u *URL) EscapedPath() string</a>\n</li>\n<li> <a href=\"#URL.IsAbs\">func (u *URL) IsAbs() bool</a>\n</li>\n<li> <a href=\"#URL.Parse\">func (u *URL) Parse(ref string) (*URL, error)</a>\n</li>\n<li> <a href=\"#URL.Query\">func (u *URL) Query() Values</a>\n</li>\n<li> <a href=\"#URL.RequestURI\">func (u *URL) RequestURI() string</a>\n</li>\n<li> <a href=\"#URL.ResolveReference\">func (u *URL) ResolveReference(ref *URL) *URL</a>\n</li>\n<li> <a href=\"#URL.String\">func (u *URL) String() string</a>\n</li>\n<li><a href=\"#Userinfo\">type Userinfo</a></li>\n<li> <a href=\"#User\">func User(username string) *Userinfo</a>\n</li>\n<li> <a href=\"#UserPassword\">func UserPassword(username, password string) *Userinfo</a>\n</li>\n<li> <a href=\"#Userinfo.Password\">func (u *Userinfo) Password() (string, bool)</a>\n</li>\n<li> <a href=\"#Userinfo.String\">func (u *Userinfo) String() string</a>\n</li>\n<li> <a href=\"#Userinfo.Username\">func (u *Userinfo) Username() string</a>\n</li>\n<li><a href=\"#Values\">type Values</a></li>\n<li> <a href=\"#ParseQuery\">func ParseQuery(query string) (Values, error)</a>\n</li>\n<li> <a href=\"#Values.Add\">func (v Values) Add(key, value string)</a>\n</li>\n<li> <a href=\"#Values.Del\">func (v Values) Del(key string)</a>\n</li>\n<li> <a href=\"#Values.Encode\">func (v Values) Encode() string</a>\n</li>\n<li> <a href=\"#Values.Get\">func (v Values) Get(key string) string</a>\n</li>\n<li> <a href=\"#Values.Set\">func (v Values) Set(key, value string)</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_URL\">URL</a></dd> <dd><a class=\"exampleLink\" href=\"#example_URL_ResolveReference\">URL.ResolveReference</a></dd> <dd><a class=\"exampleLink\" href=\"#example_URL_opaque\">URL (Opaque)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_URL_roundtrip\">URL (Roundtrip)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Values\">Values</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/url/url.go\">url.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"QueryEscape\">func QueryEscape  </h2> <pre data-language=\"go\">func QueryEscape(s string) string</pre> <p> QueryEscape escapes the string so it can be safely placed inside a URL query. </p> <h2 id=\"QueryUnescape\">func QueryUnescape  </h2> <pre data-language=\"go\">func QueryUnescape(s string) (string, error)</pre> <p> QueryUnescape does the inverse transformation of QueryEscape, converting %AB into the byte 0xAB and '+' into ' ' (space). It returns an error if any % is not followed by two hexadecimal digits. </p> <h2 id=\"Error\">type Error  </h2> <pre data-language=\"go\">type Error struct {\n        Op  string\n        URL string\n        Err error\n}</pre> <p> Error reports an error and the operation and URL that caused it. </p> <h3 id=\"Error.Error\">func (*Error) <a href=\"https://golang.org/src/net/url/url.go?s=690:720#L19\">Error</a>  </h3> <pre data-language=\"go\">func (e *Error) Error() string</pre> <h3 id=\"Error.Temporary\">func (*Error) <a href=\"https://golang.org/src/net/url/url.go?s=955:987#L34\">Temporary</a>  </h3> <pre data-language=\"go\">func (e *Error) Temporary() bool</pre> <h3 id=\"Error.Timeout\">func (*Error) <a href=\"https://golang.org/src/net/url/url.go?s=819:849#L25\">Timeout</a>  </h3> <pre data-language=\"go\">func (e *Error) Timeout() bool</pre> <h2 id=\"EscapeError\">type EscapeError  </h2> <pre data-language=\"go\">type EscapeError string</pre> <h3 id=\"EscapeError.Error\">func (EscapeError) <a href=\"https://golang.org/src/net/url/url.go?s=1597:1632#L76\">Error</a>  </h3> <pre data-language=\"go\">func (e EscapeError) Error() string</pre> <h2 id=\"InvalidHostError\">type InvalidHostError  </h2> <pre data-language=\"go\">type InvalidHostError string</pre> <h3 id=\"InvalidHostError.Error\">func (InvalidHostError) <a href=\"https://golang.org/src/net/url/url.go?s=1725:1765#L82\">Error</a>  </h3> <pre data-language=\"go\">func (e InvalidHostError) Error() string</pre> <h2 id=\"URL\">type URL  </h2> <pre data-language=\"go\">type URL struct {\n        Scheme     string\n        Opaque     string    // encoded opaque data\n        User       *Userinfo // username and password information\n        Host       string    // host or host:port\n        Path       string\n        RawPath    string // encoded path hint (Go 1.5 and later only; see EscapedPath method)\n        ForceQuery bool   // append a query ('?') even if RawQuery is empty\n        RawQuery   string // encoded query values, without '?'\n        Fragment   string // fragment for references, without '#'\n}</pre> <p> A URL represents a parsed URL (technically, a URI reference). The general form represented is: </p> <pre data-language=\"go\">scheme://[userinfo@]host/path[?query][#fragment]\n</pre> <p> URLs that do not start with a slash after the scheme are interpreted as: </p> <pre data-language=\"go\">scheme:opaque[?query][#fragment]\n</pre> <p> Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/. A consequence is that it is impossible to tell which slashes in the Path were slashes in the raw URL and which were %2f. This distinction is rarely important, but when it is, code must not use Path directly. </p> <p> Go 1.5 introduced the RawPath field to hold the encoded form of Path. The Parse function sets both Path and RawPath in the URL it returns, and URL's String method uses RawPath if it is a valid encoding of Path, by calling the EscapedPath method. </p> <p> In earlier versions of Go, the more indirect workarounds were that an HTTP server could consult req.RequestURI and an HTTP client could construct a URL struct directly and set the Opaque field instead of Path. These still work as well. </p> <div id=\"example_URL\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n)\n\nfunc main() {\n\tu, err := url.Parse(\"http://bing.com/search?q=dotnet\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tu.Scheme = \"https\"\n\tu.Host = \"google.com\"\n\tq := u.Query()\n\tq.Set(\"q\", \"golang\")\n\tu.RawQuery = q.Encode()\n\tfmt.Println(u)\n}\n</pre> </div> </div> <div id=\"example_URL_opaque\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Opaque)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Sending a literal '%' in an HTTP request's Path\n\treq := &amp;http.Request{\n\t\tMethod: \"GET\",\n\t\tHost:   \"example.com\", // takes precedence over URL.Host\n\t\tURL: &amp;url.URL{\n\t\t\tHost:   \"ignored\",\n\t\t\tScheme: \"https\",\n\t\t\tOpaque: \"/%2f/\",\n\t\t},\n\t\tHeader: http.Header{\n\t\t\t\"User-Agent\": {\"godoc-example/0.1\"},\n\t\t},\n\t}\n\tout, err := httputil.DumpRequestOut(req, true)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(strings.Replace(string(out), \"\\r\", \"\", -1))\n}\n</pre> </div> </div> <div id=\"example_URL_roundtrip\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Roundtrip)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n)\n\nfunc main() {\n\t// Parse + String preserve the original encoding.\n\tu, err := url.Parse(\"https://example.com/foo%2fbar\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(u.Path)\n\tfmt.Println(u.RawPath)\n\tfmt.Println(u.String())\n}\n</pre> </div> </div> <h3 id=\"Parse\">func <a href=\"https://golang.org/src/net/url/url.go?s=11553:11592#L408\">Parse</a>  </h3> <pre data-language=\"go\">func Parse(rawurl string) (*URL, error)</pre> <p> Parse parses rawurl into a URL structure. The rawurl may be relative or absolute. </p> <h3 id=\"ParseRequestURI\">func <a href=\"https://golang.org/src/net/url/url.go?s=12219:12268#L429\">ParseRequestURI</a>  </h3> <pre data-language=\"go\">func ParseRequestURI(rawurl string) (*URL, error)</pre> <p> ParseRequestURI parses rawurl into a URL structure. It assumes that rawurl was received in an HTTP request, so the rawurl is interpreted only as an absolute URI or an absolute path. The string rawurl is assumed not to have a #fragment suffix. (Web browsers strip #fragment before sending the URL to a web server.) </p> <h3 id=\"URL.EscapedPath\">func (*URL) <a href=\"https://golang.org/src/net/url/url.go?s=16820:16854#L588\">EscapedPath</a>  </h3> <pre data-language=\"go\">func (u *URL) EscapedPath() string</pre> <p> EscapedPath returns the escaped form of u.Path. In general there are multiple possible escaped forms of any path. EscapedPath returns u.RawPath when it is a valid escaping of u.Path. Otherwise EscapedPath ignores u.RawPath and computes an escaped form on its own. The String and RequestURI methods use EscapedPath to construct their results. In general, code should call EscapedPath instead of reading u.RawPath directly. </p> <h3 id=\"URL.IsAbs\">func (*URL) <a href=\"https://golang.org/src/net/url/url.go?s=23085:23111#L845\">IsAbs</a>  </h3> <pre data-language=\"go\">func (u *URL) IsAbs() bool</pre> <p> IsAbs reports whether the URL is absolute. </p> <h3 id=\"URL.Parse\">func (*URL) <a href=\"https://golang.org/src/net/url/url.go?s=23347:23392#L852\">Parse</a>  </h3> <pre data-language=\"go\">func (u *URL) Parse(ref string) (*URL, error)</pre> <p> Parse parses a URL in the context of the receiver. The provided URL may be relative or absolute. Parse returns nil, err on parse failure, otherwise its return value is the same as ResolveReference. </p> <h3 id=\"URL.Query\">func (*URL) <a href=\"https://golang.org/src/net/url/url.go?s=24599:24627#L898\">Query</a>  </h3> <pre data-language=\"go\">func (u *URL) Query() Values</pre> <p> Query parses RawQuery and returns the corresponding values. </p> <h3 id=\"URL.RequestURI\">func (*URL) <a href=\"https://golang.org/src/net/url/url.go?s=24791:24824#L905\">RequestURI</a>  </h3> <pre data-language=\"go\">func (u *URL) RequestURI() string</pre> <p> RequestURI returns the encoded path?query or opaque?query string that would be used in an HTTP request for u. </p> <h3 id=\"URL.ResolveReference\">func (*URL) <a href=\"https://golang.org/src/net/url/url.go?s=23895:23940#L866\">ResolveReference</a>  </h3> <pre data-language=\"go\">func (u *URL) ResolveReference(ref *URL) *URL</pre> <p> ResolveReference resolves a URI reference to an absolute URI from an absolute base URI, per RFC 3986 Section 5.2. The URI reference may be relative or absolute. ResolveReference always returns a new URL instance, even if the returned URL is identical to either the base or reference. If ref is an absolute URL, then ResolveReference ignores base and returns a copy of ref. </p> <div id=\"example_URL_ResolveReference\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n)\n\nfunc main() {\n\tu, err := url.Parse(\"../../..//search?q=dotnet\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tbase, err := url.Parse(\"http://example.com/directory/\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(base.ResolveReference(u))\n}\n</pre> </div> </div> <h3 id=\"URL.String\">func (*URL) <a href=\"https://golang.org/src/net/url/url.go?s=19029:19058#L663\">String</a>  </h3> <pre data-language=\"go\">func (u *URL) String() string</pre> <p> String reassembles the URL into a valid URL string. The general form of the result is one of: </p> <pre data-language=\"go\">scheme:opaque?query#fragment\nscheme://userinfo@host/path?query#fragment\n</pre> <p> If u.Opaque is non-empty, String uses the first form; otherwise it uses the second form. To obtain the path, String uses u.EscapedPath(). </p> <p> In the second form, the following rules apply: </p> <pre data-language=\"go\">- if u.Scheme is empty, scheme: is omitted.\n- if u.User is nil, userinfo@ is omitted.\n- if u.Host is empty, host/ is omitted.\n- if u.Scheme and u.Host are empty and u.User is nil,\n   the entire scheme://userinfo@host/ is omitted.\n- if u.Host is non-empty and u.Path begins with a /,\n   the form host/path does not add its own /.\n- if u.RawQuery is empty, ?query is omitted.\n- if u.Fragment is empty, #fragment is omitted.\n</pre> <h2 id=\"Userinfo\">type Userinfo  </h2> <pre data-language=\"go\">type Userinfo struct {\n        // contains filtered or unexported fields\n}</pre> <p> The Userinfo type is an immutable encapsulation of username and password details for a URL. An existing Userinfo value is guaranteed to have a username set (potentially empty, as allowed by RFC 2396), and optionally a password. </p> <h3 id=\"User\">func <a href=\"https://golang.org/src/net/url/url.go?s=8972:9008#L317\">User</a>  </h3> <pre data-language=\"go\">func User(username string) *Userinfo</pre> <p> User returns a Userinfo containing the provided username and no password set. </p> <h3 id=\"UserPassword\">func <a href=\"https://golang.org/src/net/url/url.go?s=9446:9500#L328\">UserPassword</a>  </h3> <pre data-language=\"go\">func UserPassword(username, password string) *Userinfo</pre> <p> UserPassword returns a Userinfo containing the provided username and password. This functionality should only be used with legacy web sites. RFC 2396 warns that interpreting Userinfo this way “is NOT RECOMMENDED, because the passing of authentication information in clear text (such as URI) has proven to be a security risk in almost every case where it has been used.” </p> <h3 id=\"Userinfo.Password\">func (*Userinfo) <a href=\"https://golang.org/src/net/url/url.go?s=10044:10088#L348\">Password</a>  </h3> <pre data-language=\"go\">func (u *Userinfo) Password() (string, bool)</pre> <p> Password returns the password in case it is set, and whether it is set. </p> <h3 id=\"Userinfo.String\">func (*Userinfo) <a href=\"https://golang.org/src/net/url/url.go?s=10262:10296#L357\">String</a>  </h3> <pre data-language=\"go\">func (u *Userinfo) String() string</pre> <p> String returns the encoded userinfo information in the standard form of \"username[:password]\". </p> <h3 id=\"Userinfo.Username\">func (*Userinfo) <a href=\"https://golang.org/src/net/url/url.go?s=9908:9944#L343\">Username</a>  </h3> <pre data-language=\"go\">func (u *Userinfo) Username() string</pre> <p> Username returns the username. </p> <h2 id=\"Values\">type Values  </h2> <pre data-language=\"go\">type Values map[string][]string</pre> <p> Values maps a string key to a list of values. It is typically used for query parameters and form values. Unlike in the http.Header map, the keys in a Values map are case-sensitive. </p> <div id=\"example_Values\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n)\n\nfunc main() {\n\tv := url.Values{}\n\tv.Set(\"name\", \"Ava\")\n\tv.Add(\"friend\", \"Jess\")\n\tv.Add(\"friend\", \"Sarah\")\n\tv.Add(\"friend\", \"Zoe\")\n\t// v.Encode() == \"name=Ava&amp;friend=Jess&amp;friend=Sarah&amp;friend=Zoe\"\n\tfmt.Println(v.Get(\"name\"))\n\tfmt.Println(v.Get(\"friend\"))\n\tfmt.Println(v[\"friend\"])\n}\n</pre> </div> </div> <h3 id=\"ParseQuery\">func <a href=\"https://golang.org/src/net/url/url.go?s=21047:21092#L742\">ParseQuery</a>  </h3> <pre data-language=\"go\">func ParseQuery(query string) (Values, error)</pre> <p> ParseQuery parses the URL-encoded query string and returns a map listing the values specified for each key. ParseQuery always returns a non-nil map containing all the valid query parameters found; err describes the first decoding error encountered, if any. </p> <h3 id=\"Values.Add\">func (Values) <a href=\"https://golang.org/src/net/url/url.go?s=20599:20637#L728\">Add</a>  </h3> <pre data-language=\"go\">func (v Values) Add(key, value string)</pre> <p> Add adds the value to key. It appends to any existing values associated with key. </p> <h3 id=\"Values.Del\">func (Values) <a href=\"https://golang.org/src/net/url/url.go?s=20722:20753#L733\">Del</a>  </h3> <pre data-language=\"go\">func (v Values) Del(key string)</pre> <p> Del deletes the values associated with key. </p> <h3 id=\"Values.Encode\">func (Values) <a href=\"https://golang.org/src/net/url/url.go?s=21855:21886#L784\">Encode</a>  </h3> <pre data-language=\"go\">func (v Values) Encode() string</pre> <p> Encode encodes the values into “URL encoded” form (\"bar=baz&amp;foo=quux\") sorted by key. </p> <h3 id=\"Values.Get\">func (Values) <a href=\"https://golang.org/src/net/url/url.go?s=20239:20277#L709\">Get</a>  </h3> <pre data-language=\"go\">func (v Values) Get(key string) string</pre> <p> Get gets the first value associated with the given key. If there are no values associated with the key, Get returns the empty string. To access multiple values, use the map directly. </p> <h3 id=\"Values.Set\">func (Values) <a href=\"https://golang.org/src/net/url/url.go?s=20441:20479#L722\">Set</a>  </h3> <pre data-language=\"go\">func (v Values) Set(key, value string)</pre> <p> Set sets the key to value. It replaces any existing values. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/url/\" class=\"_attribution-link\">https://golang.org/pkg/net/url/</a>\n  </p>\n</div>\n","os/exec/index":"<h1>Package exec</h1>     <ul id=\"short-nav\">\n<li><code>import \"os/exec\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package exec runs external commands. It wraps os.StartProcess to make it easier to remap stdin and stdout, connect I/O with pipes, and do other adjustments. </p> <p> Note that the examples in this package assume a Unix system. They may not run on Windows, and they do not run in the Go Playground used by golang.org and godoc.org. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#LookPath\">func LookPath(file string) (string, error)</a></li>\n<li><a href=\"#Cmd\">type Cmd</a></li>\n<li> <a href=\"#Command\">func Command(name string, arg ...string) *Cmd</a>\n</li>\n<li> <a href=\"#CommandContext\">func CommandContext(ctx context.Context, name string, arg ...string) *Cmd</a>\n</li>\n<li> <a href=\"#Cmd.CombinedOutput\">func (c *Cmd) CombinedOutput() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Cmd.Output\">func (c *Cmd) Output() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Cmd.Run\">func (c *Cmd) Run() error</a>\n</li>\n<li> <a href=\"#Cmd.Start\">func (c *Cmd) Start() error</a>\n</li>\n<li> <a href=\"#Cmd.StderrPipe\">func (c *Cmd) StderrPipe() (io.ReadCloser, error)</a>\n</li>\n<li> <a href=\"#Cmd.StdinPipe\">func (c *Cmd) StdinPipe() (io.WriteCloser, error)</a>\n</li>\n<li> <a href=\"#Cmd.StdoutPipe\">func (c *Cmd) StdoutPipe() (io.ReadCloser, error)</a>\n</li>\n<li> <a href=\"#Cmd.Wait\">func (c *Cmd) Wait() error</a>\n</li>\n<li><a href=\"#Error\">type Error</a></li>\n<li> <a href=\"#Error.Error\">func (e *Error) Error() string</a>\n</li>\n<li><a href=\"#ExitError\">type ExitError</a></li>\n<li> <a href=\"#ExitError.Error\">func (e *ExitError) Error() string</a>\n</li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Cmd_Output\">Cmd.Output</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Cmd_Start\">Cmd.Start</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Cmd_StdoutPipe\">Cmd.StdoutPipe</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Command\">Command</a></dd> <dd><a class=\"exampleLink\" href=\"#example_LookPath\">LookPath</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/os/exec/exec.go\">exec.go</a> <a href=\"https://golang.org/src/os/exec/exec_posix.go\">exec_posix.go</a> <a href=\"https://golang.org/src/os/exec/lp_unix.go\">lp_unix.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrNotFound = errors.New(\"executable file not found in $PATH\")</pre> <p> ErrNotFound is the error resulting if a path search failed to find an executable file. </p> <h2 id=\"LookPath\">func LookPath  </h2> <pre data-language=\"go\">func LookPath(file string) (string, error)</pre> <p> LookPath searches for an executable binary named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. The result may be an absolute path or a path relative to the current directory. </p> <div id=\"example_LookPath\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tpath, err := exec.LookPath(\"fortune\")\n\tif err != nil {\n\t\tlog.Fatal(\"installing fortune is in your future\")\n\t}\n\tfmt.Printf(\"fortune is available at %s\\n\", path)\n}\n</pre> </div> </div> <h2 id=\"Cmd\">type Cmd  </h2> <pre data-language=\"go\">type Cmd struct {\n        // Path is the path of the command to run.\n        //\n        // This is the only field that must be set to a non-zero\n        // value. If Path is relative, it is evaluated relative\n        // to Dir.\n        Path string\n\n        // Args holds command line arguments, including the command as Args[0].\n        // If the Args field is empty or nil, Run uses {Path}.\n        //\n        // In typical use, both Path and Args are set by calling Command.\n        Args []string\n\n        // Env specifies the environment of the process.\n        // If Env is nil, Run uses the current process's environment.\n        Env []string\n\n        // Dir specifies the working directory of the command.\n        // If Dir is the empty string, Run runs the command in the\n        // calling process's current directory.\n        Dir string\n\n        // Stdin specifies the process's standard input.\n        // If Stdin is nil, the process reads from the null device (os.DevNull).\n        // If Stdin is an *os.File, the process's standard input is connected\n        // directly to that file.\n        // Otherwise, during the execution of the command a separate\n        // goroutine reads from Stdin and delivers that data to the command\n        // over a pipe. In this case, Wait does not complete until the goroutine\n        // stops copying, either because it has reached the end of Stdin\n        // (EOF or a read error) or because writing to the pipe returned an error.\n        Stdin io.Reader\n\n        // Stdout and Stderr specify the process's standard output and error.\n        //\n        // If either is nil, Run connects the corresponding file descriptor\n        // to the null device (os.DevNull).\n        //\n        // If Stdout and Stderr are the same writer, at most one\n        // goroutine at a time will call Write.\n        Stdout io.Writer\n        Stderr io.Writer\n\n        // ExtraFiles specifies additional open files to be inherited by the\n        // new process. It does not include standard input, standard output, or\n        // standard error. If non-nil, entry i becomes file descriptor 3+i.\n        //\n        // BUG(rsc): On OS X 10.6, child processes may sometimes inherit unwanted fds.\n        // https://golang.org/issue/2603\n        ExtraFiles []*os.File\n\n        // SysProcAttr holds optional, operating system-specific attributes.\n        // Run passes it to os.StartProcess as the os.ProcAttr's Sys field.\n        SysProcAttr *syscall.SysProcAttr\n\n        // Process is the underlying process, once started.\n        Process *os.Process\n\n        // ProcessState contains information about an exited process,\n        // available after a call to Wait or Run.\n        ProcessState *os.ProcessState\n        // contains filtered or unexported fields\n}</pre> <p> Cmd represents an external command being prepared or run. </p> <p> A Cmd cannot be reused after calling its Run, Output or CombinedOutput methods. </p> <h3 id=\"Command\">func <a href=\"https://golang.org/src/os/exec/exec.go?s=4289:4334#L119\">Command</a>  </h3> <pre data-language=\"go\">func Command(name string, arg ...string) *Cmd</pre> <p> Command returns the Cmd struct to execute the named program with the given arguments. </p> <p> It sets only the Path and Args in the returned structure. </p> <p> If name contains no path separators, Command uses LookPath to resolve the path to a complete name if possible. Otherwise it uses name directly. </p> <p> The returned Cmd's Args field is constructed from the command name followed by the elements of arg, so arg should not include the command name itself. For example, Command(\"echo\", \"hello\") </p> <div id=\"example_Command\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"tr\", \"a-z\", \"A-Z\")\n\tcmd.Stdin = strings.NewReader(\"some input\")\n\tvar out bytes.Buffer\n\tcmd.Stdout = &amp;out\n\terr := cmd.Run()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"in all caps: %q\\n\", out.String())\n}\n</pre> </div> </div> <h3 id=\"CommandContext\">func <a href=\"https://golang.org/src/os/exec/exec.go?s=4779:4852#L139\">CommandContext</a>  </h3> <pre data-language=\"go\">func CommandContext(ctx context.Context, name string, arg ...string) *Cmd</pre> <p> CommandContext is like Command but includes a context. </p> <p> The provided context is used to kill the process (by calling os.Process.Kill) if the context becomes done before the command completes on its own. </p> <h3 id=\"Cmd.CombinedOutput\">func (*Cmd) <a href=\"https://golang.org/src/os/exec/exec.go?s=12817:12863#L474\">CombinedOutput</a>  </h3> <pre data-language=\"go\">func (c *Cmd) CombinedOutput() ([]byte, error)</pre> <p> CombinedOutput runs the command and returns its combined standard output and standard error. </p> <h3 id=\"Cmd.Output\">func (*Cmd) <a href=\"https://golang.org/src/os/exec/exec.go?s=12280:12318#L451\">Output</a>  </h3> <pre data-language=\"go\">func (c *Cmd) Output() ([]byte, error)</pre> <p> Output runs the command and returns its standard output. Any returned error will usually be of type *ExitError. If c.Stderr was nil, Output populates ExitError.Stderr. </p> <div id=\"example_Cmd_Output\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tout, err := exec.Command(\"date\").Output()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"The date is %s\\n\", out)\n}\n</pre> </div> </div> <h3 id=\"Cmd.Run\">func (*Cmd) <a href=\"https://golang.org/src/os/exec/exec.go?s=7644:7669#L265\">Run</a>  </h3> <pre data-language=\"go\">func (c *Cmd) Run() error</pre> <p> Run starts the specified command and waits for it to complete. </p> <p> The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status. </p> <p> If the command fails to run or doesn't complete successfully, the error is of type *ExitError. Other error types may be returned for I/O problems. </p> <h3 id=\"Cmd.Start\">func (*Cmd) <a href=\"https://golang.org/src/os/exec/exec.go?s=8675:8702#L302\">Start</a>  </h3> <pre data-language=\"go\">func (c *Cmd) Start() error</pre> <p> Start starts the specified command but does not wait for it to complete. </p> <p> The Wait method will return the exit code and release associated resources once the command exits. </p> <div id=\"example_Cmd_Start\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"log\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"sleep\", \"5\")\n\terr := cmd.Start()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"Waiting for command to finish...\")\n\terr = cmd.Wait()\n\tlog.Printf(\"Command finished with error: %v\", err)\n}\n</pre> </div> </div> <h3 id=\"Cmd.StderrPipe\">func (*Cmd) <a href=\"https://golang.org/src/os/exec/exec.go?s=15473:15522#L561\">StderrPipe</a>  </h3> <pre data-language=\"go\">func (c *Cmd) StderrPipe() (io.ReadCloser, error)</pre> <p> StderrPipe returns a pipe that will be connected to the command's standard error when the command starts. </p> <p> Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage. </p> <h3 id=\"Cmd.StdinPipe\">func (*Cmd) <a href=\"https://golang.org/src/os/exec/exec.go?s=13490:13539#L494\">StdinPipe</a>  </h3> <pre data-language=\"go\">func (c *Cmd) StdinPipe() (io.WriteCloser, error)</pre> <p> StdinPipe returns a pipe that will be connected to the command's standard input when the command starts. The pipe will be closed automatically after Wait sees the command exit. A caller need only call Close to force the pipe to close sooner. For example, if the command being run will not exit until standard input is closed, the caller must close the pipe. </p> <h3 id=\"Cmd.StdoutPipe\">func (*Cmd) <a href=\"https://golang.org/src/os/exec/exec.go?s=14587:14636#L536\">StdoutPipe</a>  </h3> <pre data-language=\"go\">func (c *Cmd) StdoutPipe() (io.ReadCloser, error)</pre> <p> StdoutPipe returns a pipe that will be connected to the command's standard output when the command starts. </p> <p> Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage. </p> <div id=\"example_Cmd_StdoutPipe\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"echo\", \"-n\", `{\"Name\": \"Bob\", \"Age\": 32}`)\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := cmd.Start(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tvar person struct {\n\t\tName string\n\t\tAge  int\n\t}\n\tif err := json.NewDecoder(stdout).Decode(&amp;person); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := cmd.Wait(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"%s is %d years old\\n\", person.Name, person.Age)\n}\n</pre> </div> </div> <h3 id=\"Cmd.Wait\">func (*Cmd) <a href=\"https://golang.org/src/os/exec/exec.go?s=11516:11542#L415\">Wait</a>  </h3> <pre data-language=\"go\">func (c *Cmd) Wait() error</pre> <p> Wait waits for the command to exit. It must have been started by Start. </p> <p> The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status. </p> <p> If the command fails to run or doesn't complete successfully, the error is of type *ExitError. Other error types may be returned for I/O problems. </p> <p> If c.Stdin is not an *os.File, Wait also waits for the I/O loop copying from c.Stdin into the process's standard input to complete. </p> <p> Wait releases any resources associated with the Cmd. </p> <h2 id=\"Error\">type Error  </h2> <pre data-language=\"go\">type Error struct {\n        Name string\n        Err  error\n}</pre> <p> Error records the name of a binary that failed to be executed and the reason it failed. </p> <h3 id=\"Error.Error\">func (*Error) <a href=\"https://golang.org/src/os/exec/exec.go?s=782:812#L25\">Error</a>  </h3> <pre data-language=\"go\">func (e *Error) Error() string</pre> <h2 id=\"ExitError\">type ExitError  </h2> <pre data-language=\"go\">type ExitError struct {\n        *os.ProcessState\n\n        // Stderr holds a subset of the standard error output from the\n        // Cmd.Output method if standard error was not otherwise being\n        // collected.\n        //\n        // If the error output is long, Stderr may contain only a prefix\n        // and suffix of the output, with the middle replaced with\n        // text about the number of omitted bytes.\n        //\n        // Stderr is provided for debugging, for inclusion in error messages.\n        // Users with other needs should redirect Cmd.Stderr as needed.\n        Stderr []byte\n}</pre> <p> An ExitError reports an unsuccessful exit by a command. </p> <h3 id=\"ExitError.Error\">func (*ExitError) <a href=\"https://golang.org/src/os/exec/exec.go?s=10859:10893#L395\">Error</a>  </h3> <pre data-language=\"go\">func (e *ExitError) Error() string</pre> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/os/exec/exec.go?s=2878:2990#L81\" style=\"float: left;\">☞</a> <p> On OS X 10.6, child processes may sometimes inherit unwanted fds. <a href=\"https://golang.org/issue/2603\">https://golang.org/issue/2603</a> </p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/os/exec/\" class=\"_attribution-link\">https://golang.org/pkg/os/exec/</a>\n  </p>\n</div>\n","runtime/cgo/index":"<h1>Package cgo</h1>     <ul id=\"short-nav\">\n<li><code>import \"runtime/cgo\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package cgo contains runtime support for code generated by the cgo tool. See the documentation for the cgo command for details on using cgo. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>   <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/runtime/cgo/callbacks.go\">callbacks.go</a> <a href=\"https://golang.org/src/runtime/cgo/callbacks_traceback.go\">callbacks_traceback.go</a> <a href=\"https://golang.org/src/runtime/cgo/cgo.go\">cgo.go</a> <a href=\"https://golang.org/src/runtime/cgo/iscgo.go\">iscgo.go</a> <a href=\"https://golang.org/src/runtime/cgo/mmap.go\">mmap.go</a> <a href=\"https://golang.org/src/runtime/cgo/setenv.go\">setenv.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/runtime/cgo/\" class=\"_attribution-link\">https://golang.org/pkg/runtime/cgo/</a>\n  </p>\n</div>\n","net/textproto/index":"<h1>Package textproto</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/textproto\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP. </p> <p> The package provides: </p> <p> Error, which represents a numeric error response from a server. </p> <p> Pipeline, to manage pipelined requests and responses in a client. </p> <p> Reader, to read numeric response code lines, key: value headers, lines wrapped with leading spaces on continuation lines, and whole text blocks ending with a dot on a line by itself. </p> <p> Writer, to write dot-encoded text blocks. </p> <p> Conn, a convenient packaging of Reader, Writer, and Pipeline for use with a single network connection. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#CanonicalMIMEHeaderKey\">func CanonicalMIMEHeaderKey(s string) string</a></li>\n<li><a href=\"#TrimBytes\">func TrimBytes(b []byte) []byte</a></li>\n<li><a href=\"#TrimString\">func TrimString(s string) string</a></li>\n<li><a href=\"#Conn\">type Conn</a></li>\n<li> <a href=\"#Dial\">func Dial(network, addr string) (*Conn, error)</a>\n</li>\n<li> <a href=\"#NewConn\">func NewConn(conn io.ReadWriteCloser) *Conn</a>\n</li>\n<li> <a href=\"#Conn.Close\">func (c *Conn) Close() error</a>\n</li>\n<li> <a href=\"#Conn.Cmd\">func (c *Conn) Cmd(format string, args ...interface{}) (id uint, err error)</a>\n</li>\n<li><a href=\"#Error\">type Error</a></li>\n<li> <a href=\"#Error.Error\">func (e *Error) Error() string</a>\n</li>\n<li><a href=\"#MIMEHeader\">type MIMEHeader</a></li>\n<li> <a href=\"#MIMEHeader.Add\">func (h MIMEHeader) Add(key, value string)</a>\n</li>\n<li> <a href=\"#MIMEHeader.Del\">func (h MIMEHeader) Del(key string)</a>\n</li>\n<li> <a href=\"#MIMEHeader.Get\">func (h MIMEHeader) Get(key string) string</a>\n</li>\n<li> <a href=\"#MIMEHeader.Set\">func (h MIMEHeader) Set(key, value string)</a>\n</li>\n<li><a href=\"#Pipeline\">type Pipeline</a></li>\n<li> <a href=\"#Pipeline.EndRequest\">func (p *Pipeline) EndRequest(id uint)</a>\n</li>\n<li> <a href=\"#Pipeline.EndResponse\">func (p *Pipeline) EndResponse(id uint)</a>\n</li>\n<li> <a href=\"#Pipeline.Next\">func (p *Pipeline) Next() uint</a>\n</li>\n<li> <a href=\"#Pipeline.StartRequest\">func (p *Pipeline) StartRequest(id uint)</a>\n</li>\n<li> <a href=\"#Pipeline.StartResponse\">func (p *Pipeline) StartResponse(id uint)</a>\n</li>\n<li><a href=\"#ProtocolError\">type ProtocolError</a></li>\n<li> <a href=\"#ProtocolError.Error\">func (p ProtocolError) Error() string</a>\n</li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li> <a href=\"#NewReader\">func NewReader(r *bufio.Reader) *Reader</a>\n</li>\n<li> <a href=\"#Reader.DotReader\">func (r *Reader) DotReader() io.Reader</a>\n</li>\n<li> <a href=\"#Reader.ReadCodeLine\">func (r *Reader) ReadCodeLine(expectCode int) (code int, message string, err error)</a>\n</li>\n<li> <a href=\"#Reader.ReadContinuedLine\">func (r *Reader) ReadContinuedLine() (string, error)</a>\n</li>\n<li> <a href=\"#Reader.ReadContinuedLineBytes\">func (r *Reader) ReadContinuedLineBytes() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Reader.ReadDotBytes\">func (r *Reader) ReadDotBytes() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Reader.ReadDotLines\">func (r *Reader) ReadDotLines() ([]string, error)</a>\n</li>\n<li> <a href=\"#Reader.ReadLine\">func (r *Reader) ReadLine() (string, error)</a>\n</li>\n<li> <a href=\"#Reader.ReadLineBytes\">func (r *Reader) ReadLineBytes() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Reader.ReadMIMEHeader\">func (r *Reader) ReadMIMEHeader() (MIMEHeader, error)</a>\n</li>\n<li> <a href=\"#Reader.ReadResponse\">func (r *Reader) ReadResponse(expectCode int) (code int, message string, err error)</a>\n</li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#NewWriter\">func NewWriter(w *bufio.Writer) *Writer</a>\n</li>\n<li> <a href=\"#Writer.DotWriter\">func (w *Writer) DotWriter() io.WriteCloser</a>\n</li>\n<li> <a href=\"#Writer.PrintfLine\">func (w *Writer) PrintfLine(format string, args ...interface{}) error</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/textproto/header.go\">header.go</a> <a href=\"https://golang.org/src/net/textproto/pipeline.go\">pipeline.go</a> <a href=\"https://golang.org/src/net/textproto/reader.go\">reader.go</a> <a href=\"https://golang.org/src/net/textproto/textproto.go\">textproto.go</a> <a href=\"https://golang.org/src/net/textproto/writer.go\">writer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"CanonicalMIMEHeaderKey\">func CanonicalMIMEHeaderKey  </h2> <pre data-language=\"go\">func CanonicalMIMEHeaderKey(s string) string</pre> <p> CanonicalMIMEHeaderKey returns the canonical format of the MIME header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". MIME header keys are assumed to be ASCII only. If s contains a space or invalid header field bytes, it is returned without modifications. </p> <h2 id=\"TrimBytes\">func TrimBytes  </h2> <pre data-language=\"go\">func TrimBytes(b []byte) []byte</pre> <p> TrimBytes returns b without leading and trailing ASCII space. </p> <h2 id=\"TrimString\">func TrimString  </h2> <pre data-language=\"go\">func TrimString(s string) string</pre> <p> TrimString returns s without leading and trailing ASCII space. </p> <h2 id=\"Conn\">type Conn  </h2> <pre data-language=\"go\">type Conn struct {\n        Reader\n        Writer\n        Pipeline\n        // contains filtered or unexported fields\n}</pre> <p> A Conn represents a textual network protocol connection. It consists of a Reader and Writer to manage I/O and a Pipeline to sequence concurrent requests on the connection. These embedded types carry methods with them; see the documentation of those types for details. </p> <h3 id=\"Dial\">func <a href=\"https://golang.org/src/net/textproto/textproto.go?s=2064:2110#L71\">Dial</a>  </h3> <pre data-language=\"go\">func Dial(network, addr string) (*Conn, error)</pre> <p> Dial connects to the given address on the given network using net.Dial and then returns a new Conn for the connection. </p> <h3 id=\"NewConn\">func <a href=\"https://golang.org/src/net/textproto/textproto.go?s=1679:1722#L56\">NewConn</a>  </h3> <pre data-language=\"go\">func NewConn(conn io.ReadWriteCloser) *Conn</pre> <p> NewConn returns a new Conn using conn for I/O. </p> <h3 id=\"Conn.Close\">func (*Conn) <a href=\"https://golang.org/src/net/textproto/textproto.go?s=1882:1910#L65\">Close</a>  </h3> <pre data-language=\"go\">func (c *Conn) Close() error</pre> <p> Close closes the connection. </p> <h3 id=\"Conn.Cmd\">func (*Conn) <a href=\"https://golang.org/src/net/textproto/textproto.go?s=2883:2958#L104\">Cmd</a>  </h3> <pre data-language=\"go\">func (c *Conn) Cmd(format string, args ...interface{}) (id uint, err error)</pre> <p> Cmd is a convenience method that sends a command after waiting its turn in the pipeline. The command text is the result of formatting format with args and appending \\r\\n. Cmd returns the id of the command, for use with StartResponse and EndResponse. </p> <p> For example, a client might run a HELP command that returns a dot-body by using: </p> <pre data-language=\"go\">id, err := c.Cmd(\"HELP\")\nif err != nil {\n\treturn nil, err\n}\n\nc.StartResponse(id)\ndefer c.EndResponse(id)\n\nif _, _, err = c.ReadCodeLine(110); err != nil {\n\treturn nil, err\n}\ntext, err := c.ReadDotBytes()\nif err != nil {\n\treturn nil, err\n}\nreturn c.ReadCodeLine(250)\n</pre> <h2 id=\"Error\">type Error  </h2> <pre data-language=\"go\">type Error struct {\n        Code int\n        Msg  string\n}</pre> <p> An Error represents a numeric error response from a server. </p> <h3 id=\"Error.Error\">func (*Error) <a href=\"https://golang.org/src/net/textproto/textproto.go?s=997:1027#L31\">Error</a>  </h3> <pre data-language=\"go\">func (e *Error) Error() string</pre> <h2 id=\"MIMEHeader\">type MIMEHeader  </h2> <pre data-language=\"go\">type MIMEHeader map[string][]string</pre> <p> A MIMEHeader represents a MIME-style header mapping keys to sets of values. </p> <h3 id=\"MIMEHeader.Add\">func (MIMEHeader) <a href=\"https://golang.org/src/net/textproto/header.go?s=403:445#L3\">Add</a>  </h3> <pre data-language=\"go\">func (h MIMEHeader) Add(key, value string)</pre> <p> Add adds the key, value pair to the header. It appends to any existing values associated with key. </p> <h3 id=\"MIMEHeader.Del\">func (MIMEHeader) <a href=\"https://golang.org/src/net/textproto/header.go?s=1175:1210#L31\">Del</a>  </h3> <pre data-language=\"go\">func (h MIMEHeader) Del(key string)</pre> <p> Del deletes the values associated with key. </p> <h3 id=\"MIMEHeader.Get\">func (MIMEHeader) <a href=\"https://golang.org/src/net/textproto/header.go?s=967:1009#L19\">Get</a>  </h3> <pre data-language=\"go\">func (h MIMEHeader) Get(key string) string</pre> <p> Get gets the first value associated with the given key. If there are no values associated with the key, Get returns \"\". Get is a convenience method. For more complex queries, access the map directly. </p> <h3 id=\"MIMEHeader.Set\">func (MIMEHeader) <a href=\"https://golang.org/src/net/textproto/header.go?s=657:699#L11\">Set</a>  </h3> <pre data-language=\"go\">func (h MIMEHeader) Set(key, value string)</pre> <p> Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key. </p> <h2 id=\"Pipeline\">type Pipeline  </h2> <pre data-language=\"go\">type Pipeline struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Pipeline manages a pipelined in-order request/response sequence. </p> <p> To use a Pipeline p to manage multiple clients on a connection, each client should run: </p> <pre data-language=\"go\">id := p.Next()\t// take a number\n\np.StartRequest(id)\t// wait for turn to send request\n«send request»\np.EndRequest(id)\t// notify Pipeline that request is sent\n\np.StartResponse(id)\t// wait for turn to read response\n«read response»\np.EndResponse(id)\t// notify Pipeline that response is read\n</pre> <p> A pipelined server can use the same calls to ensure that responses computed in parallel are written in the correct order. </p> <h3 id=\"Pipeline.EndRequest\">func (*Pipeline) <a href=\"https://golang.org/src/net/textproto/pipeline.go?s=1368:1406#L42\">EndRequest</a>  </h3> <pre data-language=\"go\">func (p *Pipeline) EndRequest(id uint)</pre> <p> EndRequest notifies p that the request with the given id has been sent (or, if this is a server, received). </p> <h3 id=\"Pipeline.EndResponse\">func (*Pipeline) <a href=\"https://golang.org/src/net/textproto/pipeline.go?s=1734:1773#L54\">EndResponse</a>  </h3> <pre data-language=\"go\">func (p *Pipeline) EndResponse(id uint)</pre> <p> EndResponse notifies p that the response with the given id has been received (or, if this is a server, sent). </p> <h3 id=\"Pipeline.Next\">func (*Pipeline) <a href=\"https://golang.org/src/net/textproto/pipeline.go?s=975:1005#L26\">Next</a>  </h3> <pre data-language=\"go\">func (p *Pipeline) Next() uint</pre> <p> Next returns the next id for a request/response pair. </p> <h3 id=\"Pipeline.StartRequest\">func (*Pipeline) <a href=\"https://golang.org/src/net/textproto/pipeline.go?s=1187:1227#L36\">StartRequest</a>  </h3> <pre data-language=\"go\">func (p *Pipeline) StartRequest(id uint)</pre> <p> StartRequest blocks until it is time to send (or, if this is a server, receive) the request with the given id. </p> <h3 id=\"Pipeline.StartResponse\">func (*Pipeline) <a href=\"https://golang.org/src/net/textproto/pipeline.go?s=1549:1590#L48\">StartResponse</a>  </h3> <pre data-language=\"go\">func (p *Pipeline) StartResponse(id uint)</pre> <p> StartResponse blocks until it is time to receive (or, if this is a server, send) the request with the given id. </p> <h2 id=\"ProtocolError\">type ProtocolError  </h2> <pre data-language=\"go\">type ProtocolError string</pre> <p> A ProtocolError describes a protocol violation such as an invalid response or a hung-up connection. </p> <h3 id=\"ProtocolError.Error\">func (ProtocolError) <a href=\"https://golang.org/src/net/textproto/textproto.go?s=1212:1249#L39\">Error</a>  </h3> <pre data-language=\"go\">func (p ProtocolError) Error() string</pre> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader struct {\n        R *bufio.Reader\n        // contains filtered or unexported fields\n}</pre> <p> A Reader implements convenience methods for reading requests or responses from a text protocol network connection. </p> <h3 id=\"NewReader\">func <a href=\"https://golang.org/src/net/textproto/reader.go?s=706:745#L19\">NewReader</a>  </h3> <pre data-language=\"go\">func NewReader(r *bufio.Reader) *Reader</pre> <p> NewReader returns a new Reader reading from r. </p> <p> To avoid denial of service attacks, the provided bufio.Reader should be reading from an io.LimitReader or similar Reader to bound the size of responses. </p> <h3 id=\"Reader.DotReader\">func (*Reader) <a href=\"https://golang.org/src/net/textproto/reader.go?s=8317:8355#L286\">DotReader</a>  </h3> <pre data-language=\"go\">func (r *Reader) DotReader() io.Reader</pre> <p> DotReader returns a new Reader that satisfies Reads using the decoded text of a dot-encoded block read from r. The returned Reader is only valid until the next call to a method on r. </p> <p> Dot encoding is a common framing used for data blocks in text protocols such as SMTP. The data consists of a sequence of lines, each of which ends in \"\\r\\n\". The sequence itself ends at a line containing just a dot: \".\\r\\n\". Lines beginning with a dot are escaped with an additional dot to avoid looking like the end of the sequence. </p> <p> The decoded form returned by the Reader's Read method rewrites the \"\\r\\n\" line endings into the simpler \"\\n\", removes leading dot escapes if present, and stops with error io.EOF after consuming (and discarding) the end-of-sequence line. </p> <h3 id=\"Reader.ReadCodeLine\">func (*Reader) <a href=\"https://golang.org/src/net/textproto/reader.go?s=5685:5768#L209\">ReadCodeLine</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadCodeLine(expectCode int) (code int, message string, err error)</pre> <p> ReadCodeLine reads a response code line of the form </p> <pre data-language=\"go\">code message\n</pre> <p> where code is a three-digit status code and the message extends to the rest of the line. An example of such a line is: </p> <pre data-language=\"go\">220 plan9.bell-labs.com ESMTP\n</pre> <p> If the prefix of the status does not match the digits in expectCode, ReadCodeLine returns with err set to &amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319]. </p> <p> If the response is multi-line, ReadCodeLine returns an error. </p> <p> An expectCode &lt;= 0 disables the check of the status code. </p> <h3 id=\"Reader.ReadContinuedLine\">func (*Reader) <a href=\"https://golang.org/src/net/textproto/reader.go?s=2229:2281#L80\">ReadContinuedLine</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadContinuedLine() (string, error)</pre> <p> ReadContinuedLine reads a possibly continued line from r, eliding the final trailing ASCII white space. Lines after the first are considered continuations if they begin with a space or tab character. In the returned data, continuation lines are separated from the previous line only by a single space: the newline and leading white space are removed. </p> <p> For example, consider this input: </p> <pre data-language=\"go\">Line 1\n  continued...\nLine 2\n</pre> <p> The first call to ReadContinuedLine will return \"Line 1 continued...\" and the second will return \"Line 2\". </p> <p> A line consisting of only white space is never continued. </p> <h3 id=\"Reader.ReadContinuedLineBytes\">func (*Reader) <a href=\"https://golang.org/src/net/textproto/reader.go?s=2747:2804#L101\">ReadContinuedLineBytes</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadContinuedLineBytes() ([]byte, error)</pre> <p> ReadContinuedLineBytes is like ReadContinuedLine but returns a []byte instead of a string. </p> <h3 id=\"Reader.ReadDotBytes\">func (*Reader) <a href=\"https://golang.org/src/net/textproto/reader.go?s=10731:10778#L402\">ReadDotBytes</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadDotBytes() ([]byte, error)</pre> <p> ReadDotBytes reads a dot-encoding and returns the decoded data. </p> <p> See the documentation for the DotReader method for details about dot-encoding. </p> <h3 id=\"Reader.ReadDotLines\">func (*Reader) <a href=\"https://golang.org/src/net/textproto/reader.go?s=11041:11090#L410\">ReadDotLines</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadDotLines() ([]string, error)</pre> <p> ReadDotLines reads a dot-encoding and returns a slice containing the decoded lines, with the final \\r\\n or \\n elided from each. </p> <p> See the documentation for the DotReader method for details about dot-encoding. </p> <h3 id=\"Reader.ReadLine\">func (*Reader) <a href=\"https://golang.org/src/net/textproto/reader.go?s=871:914#L25\">ReadLine</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadLine() (string, error)</pre> <p> ReadLine reads a single line from r, eliding the final \\n or \\r\\n from the returned string. </p> <h3 id=\"Reader.ReadLineBytes\">func (*Reader) <a href=\"https://golang.org/src/net/textproto/reader.go?s=1054:1102#L31\">ReadLineBytes</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadLineBytes() ([]byte, error)</pre> <p> ReadLineBytes is like ReadLine but returns a []byte instead of a string. </p> <h3 id=\"Reader.ReadMIMEHeader\">func (*Reader) <a href=\"https://golang.org/src/net/textproto/reader.go?s=12175:12228#L458\">ReadMIMEHeader</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadMIMEHeader() (MIMEHeader, error)</pre> <p> ReadMIMEHeader reads a MIME-style header from r. The header is a sequence of possibly continued Key: Value lines ending in a blank line. The returned map m maps CanonicalMIMEHeaderKey(key) to a sequence of values in the same order encountered in the input. </p> <p> For example, consider this input: </p> <pre data-language=\"go\">My-Key: Value 1\nLong-Key: Even\n       Longer Value\nMy-Key: Value 2\n</pre> <p> Given that input, ReadMIMEHeader returns the map: </p> <pre data-language=\"go\">map[string][]string{\n\t\"My-Key\": {\"Value 1\", \"Value 2\"},\n\t\"Long-Key\": {\"Even Longer Value\"},\n}\n</pre> <h3 id=\"Reader.ReadResponse\">func (*Reader) <a href=\"https://golang.org/src/net/textproto/reader.go?s=6841:6924#L244\">ReadResponse</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadResponse(expectCode int) (code int, message string, err error)</pre> <p> ReadResponse reads a multi-line response of the form: </p> <pre data-language=\"go\">code-message line 1\ncode-message line 2\n...\ncode message line n\n</pre> <p> where code is a three-digit status code. The first line starts with the code and a hyphen. The response is terminated by a line that starts with the same code followed by a space. Each line in message is separated by a newline (\\n). </p> <p> See page 36 of RFC 959 (<a href=\"http://www.ietf.org/rfc/rfc959.txt\">http://www.ietf.org/rfc/rfc959.txt</a>) for details of another form of response accepted: </p> <pre data-language=\"go\">code-message line 1\nmessage line 2\n...\ncode message line n\n</pre> <p> If the prefix of the status does not match the digits in expectCode, ReadResponse returns with err set to &amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319]. </p> <p> An expectCode &lt;= 0 disables the check of the status code. </p> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer struct {\n        W *bufio.Writer\n        // contains filtered or unexported fields\n}</pre> <p> A Writer implements convenience methods for writing requests or responses to a text protocol network connection. </p> <h3 id=\"NewWriter\">func <a href=\"https://golang.org/src/net/textproto/writer.go?s=439:478#L11\">NewWriter</a>  </h3> <pre data-language=\"go\">func NewWriter(w *bufio.Writer) *Writer</pre> <p> NewWriter returns a new Writer writing to w. </p> <h3 id=\"Writer.DotWriter\">func (*Writer) <a href=\"https://golang.org/src/net/textproto/writer.go?s=1208:1251#L33\">DotWriter</a>  </h3> <pre data-language=\"go\">func (w *Writer) DotWriter() io.WriteCloser</pre> <p> DotWriter returns a writer that can be used to write a dot-encoding to w. It takes care of inserting leading dots when necessary, translating line-ending \\n into \\r\\n, and adding the final .\\r\\n line when the DotWriter is closed. The caller should close the DotWriter before the next call to a method on w. </p> <p> See the documentation for Reader's DotReader method for details about dot-encoding. </p> <h3 id=\"Writer.PrintfLine\">func (*Writer) <a href=\"https://golang.org/src/net/textproto/writer.go?s=635:704#L19\">PrintfLine</a>  </h3> <pre data-language=\"go\">func (w *Writer) PrintfLine(format string, args ...interface{}) error</pre> <p> PrintfLine writes the formatted output followed by \\r\\n. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/textproto/\" class=\"_attribution-link\">https://golang.org/pkg/net/textproto/</a>\n  </p>\n</div>\n","go/ast/index":"<h1>Package ast</h1>     <ul id=\"short-nav\">\n<li><code>import \"go/ast\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package ast declares the types used to represent syntax trees for Go packages. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#FileExports\">func FileExports(src *File) bool</a></li>\n<li><a href=\"#FilterDecl\">func FilterDecl(decl Decl, f Filter) bool</a></li>\n<li><a href=\"#FilterFile\">func FilterFile(src *File, f Filter) bool</a></li>\n<li><a href=\"#FilterPackage\">func FilterPackage(pkg *Package, f Filter) bool</a></li>\n<li><a href=\"#Fprint\">func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) error</a></li>\n<li><a href=\"#Inspect\">func Inspect(node Node, f func(Node) bool)</a></li>\n<li><a href=\"#IsExported\">func IsExported(name string) bool</a></li>\n<li><a href=\"#NotNilFilter\">func NotNilFilter(_ string, v reflect.Value) bool</a></li>\n<li><a href=\"#PackageExports\">func PackageExports(pkg *Package) bool</a></li>\n<li><a href=\"#Print\">func Print(fset *token.FileSet, x interface{}) error</a></li>\n<li><a href=\"#SortImports\">func SortImports(fset *token.FileSet, f *File)</a></li>\n<li><a href=\"#Walk\">func Walk(v Visitor, node Node)</a></li>\n<li><a href=\"#ArrayType\">type ArrayType</a></li>\n<li> <a href=\"#ArrayType.End\">func (x *ArrayType) End() token.Pos</a>\n</li>\n<li> <a href=\"#ArrayType.Pos\">func (x *ArrayType) Pos() token.Pos</a>\n</li>\n<li><a href=\"#AssignStmt\">type AssignStmt</a></li>\n<li> <a href=\"#AssignStmt.End\">func (s *AssignStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#AssignStmt.Pos\">func (s *AssignStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#BadDecl\">type BadDecl</a></li>\n<li> <a href=\"#BadDecl.End\">func (d *BadDecl) End() token.Pos</a>\n</li>\n<li> <a href=\"#BadDecl.Pos\">func (d *BadDecl) Pos() token.Pos</a>\n</li>\n<li><a href=\"#BadExpr\">type BadExpr</a></li>\n<li> <a href=\"#BadExpr.End\">func (x *BadExpr) End() token.Pos</a>\n</li>\n<li> <a href=\"#BadExpr.Pos\">func (x *BadExpr) Pos() token.Pos</a>\n</li>\n<li><a href=\"#BadStmt\">type BadStmt</a></li>\n<li> <a href=\"#BadStmt.End\">func (s *BadStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#BadStmt.Pos\">func (s *BadStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#BasicLit\">type BasicLit</a></li>\n<li> <a href=\"#BasicLit.End\">func (x *BasicLit) End() token.Pos</a>\n</li>\n<li> <a href=\"#BasicLit.Pos\">func (x *BasicLit) Pos() token.Pos</a>\n</li>\n<li><a href=\"#BinaryExpr\">type BinaryExpr</a></li>\n<li> <a href=\"#BinaryExpr.End\">func (x *BinaryExpr) End() token.Pos</a>\n</li>\n<li> <a href=\"#BinaryExpr.Pos\">func (x *BinaryExpr) Pos() token.Pos</a>\n</li>\n<li><a href=\"#BlockStmt\">type BlockStmt</a></li>\n<li> <a href=\"#BlockStmt.End\">func (s *BlockStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#BlockStmt.Pos\">func (s *BlockStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#BranchStmt\">type BranchStmt</a></li>\n<li> <a href=\"#BranchStmt.End\">func (s *BranchStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#BranchStmt.Pos\">func (s *BranchStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#CallExpr\">type CallExpr</a></li>\n<li> <a href=\"#CallExpr.End\">func (x *CallExpr) End() token.Pos</a>\n</li>\n<li> <a href=\"#CallExpr.Pos\">func (x *CallExpr) Pos() token.Pos</a>\n</li>\n<li><a href=\"#CaseClause\">type CaseClause</a></li>\n<li> <a href=\"#CaseClause.End\">func (s *CaseClause) End() token.Pos</a>\n</li>\n<li> <a href=\"#CaseClause.Pos\">func (s *CaseClause) Pos() token.Pos</a>\n</li>\n<li><a href=\"#ChanDir\">type ChanDir</a></li>\n<li><a href=\"#ChanType\">type ChanType</a></li>\n<li> <a href=\"#ChanType.End\">func (x *ChanType) End() token.Pos</a>\n</li>\n<li> <a href=\"#ChanType.Pos\">func (x *ChanType) Pos() token.Pos</a>\n</li>\n<li><a href=\"#CommClause\">type CommClause</a></li>\n<li> <a href=\"#CommClause.End\">func (s *CommClause) End() token.Pos</a>\n</li>\n<li> <a href=\"#CommClause.Pos\">func (s *CommClause) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Comment\">type Comment</a></li>\n<li> <a href=\"#Comment.End\">func (c *Comment) End() token.Pos</a>\n</li>\n<li> <a href=\"#Comment.Pos\">func (c *Comment) Pos() token.Pos</a>\n</li>\n<li><a href=\"#CommentGroup\">type CommentGroup</a></li>\n<li> <a href=\"#CommentGroup.End\">func (g *CommentGroup) End() token.Pos</a>\n</li>\n<li> <a href=\"#CommentGroup.Pos\">func (g *CommentGroup) Pos() token.Pos</a>\n</li>\n<li> <a href=\"#CommentGroup.Text\">func (g *CommentGroup) Text() string</a>\n</li>\n<li><a href=\"#CommentMap\">type CommentMap</a></li>\n<li> <a href=\"#NewCommentMap\">func NewCommentMap(fset *token.FileSet, node Node, comments []*CommentGroup) CommentMap</a>\n</li>\n<li> <a href=\"#CommentMap.Comments\">func (cmap CommentMap) Comments() []*CommentGroup</a>\n</li>\n<li> <a href=\"#CommentMap.Filter\">func (cmap CommentMap) Filter(node Node) CommentMap</a>\n</li>\n<li> <a href=\"#CommentMap.String\">func (cmap CommentMap) String() string</a>\n</li>\n<li> <a href=\"#CommentMap.Update\">func (cmap CommentMap) Update(old, new Node) Node</a>\n</li>\n<li><a href=\"#CompositeLit\">type CompositeLit</a></li>\n<li> <a href=\"#CompositeLit.End\">func (x *CompositeLit) End() token.Pos</a>\n</li>\n<li> <a href=\"#CompositeLit.Pos\">func (x *CompositeLit) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Decl\">type Decl</a></li>\n<li><a href=\"#DeclStmt\">type DeclStmt</a></li>\n<li> <a href=\"#DeclStmt.End\">func (s *DeclStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#DeclStmt.Pos\">func (s *DeclStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#DeferStmt\">type DeferStmt</a></li>\n<li> <a href=\"#DeferStmt.End\">func (s *DeferStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#DeferStmt.Pos\">func (s *DeferStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Ellipsis\">type Ellipsis</a></li>\n<li> <a href=\"#Ellipsis.End\">func (x *Ellipsis) End() token.Pos</a>\n</li>\n<li> <a href=\"#Ellipsis.Pos\">func (x *Ellipsis) Pos() token.Pos</a>\n</li>\n<li><a href=\"#EmptyStmt\">type EmptyStmt</a></li>\n<li> <a href=\"#EmptyStmt.End\">func (s *EmptyStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#EmptyStmt.Pos\">func (s *EmptyStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Expr\">type Expr</a></li>\n<li><a href=\"#ExprStmt\">type ExprStmt</a></li>\n<li> <a href=\"#ExprStmt.End\">func (s *ExprStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#ExprStmt.Pos\">func (s *ExprStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Field\">type Field</a></li>\n<li> <a href=\"#Field.End\">func (f *Field) End() token.Pos</a>\n</li>\n<li> <a href=\"#Field.Pos\">func (f *Field) Pos() token.Pos</a>\n</li>\n<li><a href=\"#FieldFilter\">type FieldFilter</a></li>\n<li><a href=\"#FieldList\">type FieldList</a></li>\n<li> <a href=\"#FieldList.End\">func (f *FieldList) End() token.Pos</a>\n</li>\n<li> <a href=\"#FieldList.NumFields\">func (f *FieldList) NumFields() int</a>\n</li>\n<li> <a href=\"#FieldList.Pos\">func (f *FieldList) Pos() token.Pos</a>\n</li>\n<li><a href=\"#File\">type File</a></li>\n<li> <a href=\"#MergePackageFiles\">func MergePackageFiles(pkg *Package, mode MergeMode) *File</a>\n</li>\n<li> <a href=\"#File.End\">func (f *File) End() token.Pos</a>\n</li>\n<li> <a href=\"#File.Pos\">func (f *File) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Filter\">type Filter</a></li>\n<li><a href=\"#ForStmt\">type ForStmt</a></li>\n<li> <a href=\"#ForStmt.End\">func (s *ForStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#ForStmt.Pos\">func (s *ForStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#FuncDecl\">type FuncDecl</a></li>\n<li> <a href=\"#FuncDecl.End\">func (d *FuncDecl) End() token.Pos</a>\n</li>\n<li> <a href=\"#FuncDecl.Pos\">func (d *FuncDecl) Pos() token.Pos</a>\n</li>\n<li><a href=\"#FuncLit\">type FuncLit</a></li>\n<li> <a href=\"#FuncLit.End\">func (x *FuncLit) End() token.Pos</a>\n</li>\n<li> <a href=\"#FuncLit.Pos\">func (x *FuncLit) Pos() token.Pos</a>\n</li>\n<li><a href=\"#FuncType\">type FuncType</a></li>\n<li> <a href=\"#FuncType.End\">func (x *FuncType) End() token.Pos</a>\n</li>\n<li> <a href=\"#FuncType.Pos\">func (x *FuncType) Pos() token.Pos</a>\n</li>\n<li><a href=\"#GenDecl\">type GenDecl</a></li>\n<li> <a href=\"#GenDecl.End\">func (d *GenDecl) End() token.Pos</a>\n</li>\n<li> <a href=\"#GenDecl.Pos\">func (d *GenDecl) Pos() token.Pos</a>\n</li>\n<li><a href=\"#GoStmt\">type GoStmt</a></li>\n<li> <a href=\"#GoStmt.End\">func (s *GoStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#GoStmt.Pos\">func (s *GoStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Ident\">type Ident</a></li>\n<li> <a href=\"#NewIdent\">func NewIdent(name string) *Ident</a>\n</li>\n<li> <a href=\"#Ident.End\">func (x *Ident) End() token.Pos</a>\n</li>\n<li> <a href=\"#Ident.IsExported\">func (id *Ident) IsExported() bool</a>\n</li>\n<li> <a href=\"#Ident.Pos\">func (x *Ident) Pos() token.Pos</a>\n</li>\n<li> <a href=\"#Ident.String\">func (id *Ident) String() string</a>\n</li>\n<li><a href=\"#IfStmt\">type IfStmt</a></li>\n<li> <a href=\"#IfStmt.End\">func (s *IfStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#IfStmt.Pos\">func (s *IfStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#ImportSpec\">type ImportSpec</a></li>\n<li> <a href=\"#ImportSpec.End\">func (s *ImportSpec) End() token.Pos</a>\n</li>\n<li> <a href=\"#ImportSpec.Pos\">func (s *ImportSpec) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Importer\">type Importer</a></li>\n<li><a href=\"#IncDecStmt\">type IncDecStmt</a></li>\n<li> <a href=\"#IncDecStmt.End\">func (s *IncDecStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#IncDecStmt.Pos\">func (s *IncDecStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#IndexExpr\">type IndexExpr</a></li>\n<li> <a href=\"#IndexExpr.End\">func (x *IndexExpr) End() token.Pos</a>\n</li>\n<li> <a href=\"#IndexExpr.Pos\">func (x *IndexExpr) Pos() token.Pos</a>\n</li>\n<li><a href=\"#InterfaceType\">type InterfaceType</a></li>\n<li> <a href=\"#InterfaceType.End\">func (x *InterfaceType) End() token.Pos</a>\n</li>\n<li> <a href=\"#InterfaceType.Pos\">func (x *InterfaceType) Pos() token.Pos</a>\n</li>\n<li><a href=\"#KeyValueExpr\">type KeyValueExpr</a></li>\n<li> <a href=\"#KeyValueExpr.End\">func (x *KeyValueExpr) End() token.Pos</a>\n</li>\n<li> <a href=\"#KeyValueExpr.Pos\">func (x *KeyValueExpr) Pos() token.Pos</a>\n</li>\n<li><a href=\"#LabeledStmt\">type LabeledStmt</a></li>\n<li> <a href=\"#LabeledStmt.End\">func (s *LabeledStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#LabeledStmt.Pos\">func (s *LabeledStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#MapType\">type MapType</a></li>\n<li> <a href=\"#MapType.End\">func (x *MapType) End() token.Pos</a>\n</li>\n<li> <a href=\"#MapType.Pos\">func (x *MapType) Pos() token.Pos</a>\n</li>\n<li><a href=\"#MergeMode\">type MergeMode</a></li>\n<li><a href=\"#Node\">type Node</a></li>\n<li><a href=\"#ObjKind\">type ObjKind</a></li>\n<li> <a href=\"#ObjKind.String\">func (kind ObjKind) String() string</a>\n</li>\n<li><a href=\"#Object\">type Object</a></li>\n<li> <a href=\"#NewObj\">func NewObj(kind ObjKind, name string) *Object</a>\n</li>\n<li> <a href=\"#Object.Pos\">func (obj *Object) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Package\">type Package</a></li>\n<li> <a href=\"#NewPackage\">func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)</a>\n</li>\n<li> <a href=\"#Package.End\">func (p *Package) End() token.Pos</a>\n</li>\n<li> <a href=\"#Package.Pos\">func (p *Package) Pos() token.Pos</a>\n</li>\n<li><a href=\"#ParenExpr\">type ParenExpr</a></li>\n<li> <a href=\"#ParenExpr.End\">func (x *ParenExpr) End() token.Pos</a>\n</li>\n<li> <a href=\"#ParenExpr.Pos\">func (x *ParenExpr) Pos() token.Pos</a>\n</li>\n<li><a href=\"#RangeStmt\">type RangeStmt</a></li>\n<li> <a href=\"#RangeStmt.End\">func (s *RangeStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#RangeStmt.Pos\">func (s *RangeStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#ReturnStmt\">type ReturnStmt</a></li>\n<li> <a href=\"#ReturnStmt.End\">func (s *ReturnStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#ReturnStmt.Pos\">func (s *ReturnStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Scope\">type Scope</a></li>\n<li> <a href=\"#NewScope\">func NewScope(outer *Scope) *Scope</a>\n</li>\n<li> <a href=\"#Scope.Insert\">func (s *Scope) Insert(obj *Object) (alt *Object)</a>\n</li>\n<li> <a href=\"#Scope.Lookup\">func (s *Scope) Lookup(name string) *Object</a>\n</li>\n<li> <a href=\"#Scope.String\">func (s *Scope) String() string</a>\n</li>\n<li><a href=\"#SelectStmt\">type SelectStmt</a></li>\n<li> <a href=\"#SelectStmt.End\">func (s *SelectStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#SelectStmt.Pos\">func (s *SelectStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#SelectorExpr\">type SelectorExpr</a></li>\n<li> <a href=\"#SelectorExpr.End\">func (x *SelectorExpr) End() token.Pos</a>\n</li>\n<li> <a href=\"#SelectorExpr.Pos\">func (x *SelectorExpr) Pos() token.Pos</a>\n</li>\n<li><a href=\"#SendStmt\">type SendStmt</a></li>\n<li> <a href=\"#SendStmt.End\">func (s *SendStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#SendStmt.Pos\">func (s *SendStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#SliceExpr\">type SliceExpr</a></li>\n<li> <a href=\"#SliceExpr.End\">func (x *SliceExpr) End() token.Pos</a>\n</li>\n<li> <a href=\"#SliceExpr.Pos\">func (x *SliceExpr) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Spec\">type Spec</a></li>\n<li><a href=\"#StarExpr\">type StarExpr</a></li>\n<li> <a href=\"#StarExpr.End\">func (x *StarExpr) End() token.Pos</a>\n</li>\n<li> <a href=\"#StarExpr.Pos\">func (x *StarExpr) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Stmt\">type Stmt</a></li>\n<li><a href=\"#StructType\">type StructType</a></li>\n<li> <a href=\"#StructType.End\">func (x *StructType) End() token.Pos</a>\n</li>\n<li> <a href=\"#StructType.Pos\">func (x *StructType) Pos() token.Pos</a>\n</li>\n<li><a href=\"#SwitchStmt\">type SwitchStmt</a></li>\n<li> <a href=\"#SwitchStmt.End\">func (s *SwitchStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#SwitchStmt.Pos\">func (s *SwitchStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#TypeAssertExpr\">type TypeAssertExpr</a></li>\n<li> <a href=\"#TypeAssertExpr.End\">func (x *TypeAssertExpr) End() token.Pos</a>\n</li>\n<li> <a href=\"#TypeAssertExpr.Pos\">func (x *TypeAssertExpr) Pos() token.Pos</a>\n</li>\n<li><a href=\"#TypeSpec\">type TypeSpec</a></li>\n<li> <a href=\"#TypeSpec.End\">func (s *TypeSpec) End() token.Pos</a>\n</li>\n<li> <a href=\"#TypeSpec.Pos\">func (s *TypeSpec) Pos() token.Pos</a>\n</li>\n<li><a href=\"#TypeSwitchStmt\">type TypeSwitchStmt</a></li>\n<li> <a href=\"#TypeSwitchStmt.End\">func (s *TypeSwitchStmt) End() token.Pos</a>\n</li>\n<li> <a href=\"#TypeSwitchStmt.Pos\">func (s *TypeSwitchStmt) Pos() token.Pos</a>\n</li>\n<li><a href=\"#UnaryExpr\">type UnaryExpr</a></li>\n<li> <a href=\"#UnaryExpr.End\">func (x *UnaryExpr) End() token.Pos</a>\n</li>\n<li> <a href=\"#UnaryExpr.Pos\">func (x *UnaryExpr) Pos() token.Pos</a>\n</li>\n<li><a href=\"#ValueSpec\">type ValueSpec</a></li>\n<li> <a href=\"#ValueSpec.End\">func (s *ValueSpec) End() token.Pos</a>\n</li>\n<li> <a href=\"#ValueSpec.Pos\">func (s *ValueSpec) Pos() token.Pos</a>\n</li>\n<li><a href=\"#Visitor\">type Visitor</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_CommentMap\">CommentMap</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Inspect\">Inspect</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Print\">Print</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/go/ast/ast.go\">ast.go</a> <a href=\"https://golang.org/src/go/ast/commentmap.go\">commentmap.go</a> <a href=\"https://golang.org/src/go/ast/filter.go\">filter.go</a> <a href=\"https://golang.org/src/go/ast/import.go\">import.go</a> <a href=\"https://golang.org/src/go/ast/print.go\">print.go</a> <a href=\"https://golang.org/src/go/ast/resolve.go\">resolve.go</a> <a href=\"https://golang.org/src/go/ast/scope.go\">scope.go</a> <a href=\"https://golang.org/src/go/ast/walk.go\">walk.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"FileExports\">func FileExports  </h2> <pre data-language=\"go\">func FileExports(src *File) bool</pre> <p> FileExports trims the AST for a Go source file in place such that only exported nodes remain: all top-level identifiers which are not exported and their associated information (such as type, initial value, or function body) are removed. Non-exported fields and methods of exported types are stripped. The File.Comments list is not changed. </p> <p> FileExports reports whether there are exported declarations. </p> <h2 id=\"FilterDecl\">func FilterDecl  </h2> <pre data-language=\"go\">func FilterDecl(decl Decl, f Filter) bool</pre> <p> FilterDecl trims the AST for a Go declaration in place by removing all names (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. </p> <p> FilterDecl reports whether there are any declared names left after filtering. </p> <h2 id=\"FilterFile\">func FilterFile  </h2> <pre data-language=\"go\">func FilterFile(src *File, f Filter) bool</pre> <p> FilterFile trims the AST for a Go file in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. Import declarations are always removed. The File.Comments list is not changed. </p> <p> FilterFile reports whether there are any top-level declarations left after filtering. </p> <h2 id=\"FilterPackage\">func FilterPackage  </h2> <pre data-language=\"go\">func FilterPackage(pkg *Package, f Filter) bool</pre> <p> FilterPackage trims the AST for a Go package in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost. </p> <p> FilterPackage reports whether there are any top-level declarations left after filtering. </p> <h2 id=\"Fprint\">func Fprint  </h2> <pre data-language=\"go\">func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) error</pre> <p> Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil, position information is interpreted relative to that file set. Otherwise positions are printed as integer values (file set specific offsets). </p> <p> A non-nil FieldFilter f may be provided to control the output: struct fields for which f(fieldname, fieldvalue) is true are printed; all others are filtered from the output. Unexported struct fields are never printed. </p> <h2 id=\"Inspect\">func Inspect  </h2> <pre data-language=\"go\">func Inspect(node Node, f func(Node) bool)</pre> <p> Inspect traverses an AST in depth-first order: It starts by calling f(node); node must not be nil. If f returns true, Inspect invokes f recursively for each of the non-nil children of node, followed by a call of f(nil). </p> <div id=\"example_Inspect\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>This example demonstrates how to inspect the AST of a Go program. </p> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/token\"\n)\n\nfunc main() {\n\t// src is the input for which we want to inspect the AST.\n\tsrc := `\npackage p\nconst c = 1.0\nvar X = f(3.14)*2 + c\n`\n\n\t// Create the AST by parsing src.\n\tfset := token.NewFileSet() // positions are relative to fset\n\tf, err := parser.ParseFile(fset, \"src.go\", src, 0)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Inspect the AST and print all identifiers and literals.\n\tast.Inspect(f, func(n ast.Node) bool {\n\t\tvar s string\n\t\tswitch x := n.(type) {\n\t\tcase *ast.BasicLit:\n\t\t\ts = x.Value\n\t\tcase *ast.Ident:\n\t\t\ts = x.Name\n\t\t}\n\t\tif s != \"\" {\n\t\t\tfmt.Printf(\"%s:\\t%s\\n\", fset.Position(n.Pos()), s)\n\t\t}\n\t\treturn true\n\t})\n\n}\n</pre> </div> </div> <h2 id=\"IsExported\">func IsExported  </h2> <pre data-language=\"go\">func IsExported(name string) bool</pre> <p> IsExported reports whether name is an exported Go symbol (that is, whether it begins with an upper-case letter). </p> <h2 id=\"NotNilFilter\">func NotNilFilter  </h2> <pre data-language=\"go\">func NotNilFilter(_ string, v reflect.Value) bool</pre> <p> NotNilFilter returns true for field values that are not nil; it returns false otherwise. </p> <h2 id=\"PackageExports\">func PackageExports  </h2> <pre data-language=\"go\">func PackageExports(pkg *Package) bool</pre> <p> PackageExports trims the AST for a Go package in place such that only exported nodes remain. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost. </p> <p> PackageExports reports whether there are exported declarations; it returns false otherwise. </p> <h2 id=\"Print\">func Print  </h2> <pre data-language=\"go\">func Print(fset *token.FileSet, x interface{}) error</pre> <p> Print prints x to standard output, skipping nil fields. Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter). </p> <div id=\"example_Print\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>This example shows what an AST looks like when printed for debugging. </p> <pre class=\"play\">package main\n\nimport (\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/token\"\n)\n\nfunc main() {\n\t// src is the input for which we want to print the AST.\n\tsrc := `\npackage main\nfunc main() {\n\tprintln(\"Hello, World!\")\n}\n`\n\n\t// Create the AST by parsing src.\n\tfset := token.NewFileSet() // positions are relative to fset\n\tf, err := parser.ParseFile(fset, \"\", src, 0)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Print the AST.\n\tast.Print(fset, f)\n\n}\n</pre> </div> </div> <h2 id=\"SortImports\">func SortImports  </h2> <pre data-language=\"go\">func SortImports(fset *token.FileSet, f *File)</pre> <p> SortImports sorts runs of consecutive import lines in import blocks in f. It also removes duplicate imports when it is possible to do so without data loss. </p> <h2 id=\"Walk\">func Walk  </h2> <pre data-language=\"go\">func Walk(v Visitor, node Node)</pre> <p> Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil). </p> <h2 id=\"ArrayType\">type ArrayType  </h2> <pre data-language=\"go\">type ArrayType struct {\n        Lbrack token.Pos // position of \"[\"\n        Len    Expr      // Ellipsis node for [...]T array types, nil for slice types\n        Elt    Expr      // element type\n}</pre> <p> An ArrayType node represents an array or slice type. </p> <h3 id=\"ArrayType.End\">func (*ArrayType) <a href=\"https://golang.org/src/go/ast/ast.go?s=14558:14593#L466\">End</a>  </h3> <pre data-language=\"go\">func (x *ArrayType) End() token.Pos</pre> <h3 id=\"ArrayType.Pos\">func (*ArrayType) <a href=\"https://golang.org/src/go/ast/ast.go?s=12940:12975#L433\">Pos</a>  </h3> <pre data-language=\"go\">func (x *ArrayType) Pos() token.Pos</pre> <h2 id=\"AssignStmt\">type AssignStmt  </h2> <pre data-language=\"go\">type AssignStmt struct {\n        Lhs    []Expr\n        TokPos token.Pos   // position of Tok\n        Tok    token.Token // assignment token, DEFINE\n        Rhs    []Expr\n}</pre> <p> An AssignStmt node represents an assignment or a short variable declaration. </p> <h3 id=\"AssignStmt.End\">func (*AssignStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=23461:23497#L739\">End</a>  </h3> <pre data-language=\"go\">func (s *AssignStmt) End() token.Pos</pre> <h3 id=\"AssignStmt.Pos\">func (*AssignStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22127:22163#L710\">Pos</a>  </h3> <pre data-language=\"go\">func (s *AssignStmt) Pos() token.Pos</pre> <h2 id=\"BadDecl\">type BadDecl  </h2> <pre data-language=\"go\">type BadDecl struct {\n        From, To token.Pos // position range of bad declaration\n}</pre> <p> A BadDecl node is a placeholder for declarations containing syntax errors for which no correct declaration nodes can be created. </p> <h3 id=\"BadDecl.End\">func (*BadDecl) <a href=\"https://golang.org/src/go/ast/ast.go?s=29383:29416#L929\">End</a>  </h3> <pre data-language=\"go\">func (d *BadDecl) End() token.Pos</pre> <h3 id=\"BadDecl.Pos\">func (*BadDecl) <a href=\"https://golang.org/src/go/ast/ast.go?s=29215:29248#L925\">Pos</a>  </h3> <pre data-language=\"go\">func (d *BadDecl) Pos() token.Pos</pre> <h2 id=\"BadExpr\">type BadExpr  </h2> <pre data-language=\"go\">type BadExpr struct {\n        From, To token.Pos // position range of bad expression\n}</pre> <p> A BadExpr node is a placeholder for expressions containing syntax errors for which no correct expression nodes can be created. </p> <h3 id=\"BadExpr.End\">func (*BadExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=13439:13472#L445\">End</a>  </h3> <pre data-language=\"go\">func (x *BadExpr) End() token.Pos</pre> <h3 id=\"BadExpr.Pos\">func (*BadExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=11935:11968#L412\">Pos</a>  </h3> <pre data-language=\"go\">func (x *BadExpr) Pos() token.Pos</pre> <h2 id=\"BadStmt\">type BadStmt  </h2> <pre data-language=\"go\">type BadStmt struct {\n        From, To token.Pos // position range of bad statement\n}</pre> <p> A BadStmt node is a placeholder for statements containing syntax errors for which no correct statement nodes can be created. </p> <h3 id=\"BadStmt.End\">func (*BadStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22969:23002#L725\">End</a>  </h3> <pre data-language=\"go\">func (s *BadStmt) End() token.Pos</pre> <h3 id=\"BadStmt.Pos\">func (*BadStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=21684:21717#L703\">Pos</a>  </h3> <pre data-language=\"go\">func (s *BadStmt) Pos() token.Pos</pre> <h2 id=\"BasicLit\">type BasicLit  </h2> <pre data-language=\"go\">type BasicLit struct {\n        ValuePos token.Pos   // literal position\n        Kind     token.Token // token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n        Value    string      // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n}</pre> <p> A BasicLit node represents a literal of basic type. </p> <h3 id=\"BasicLit.End\">func (*BasicLit) <a href=\"https://golang.org/src/go/ast/ast.go?s=13693:13727#L453\">End</a>  </h3> <pre data-language=\"go\">func (x *BasicLit) End() token.Pos</pre> <h3 id=\"BasicLit.Pos\">func (*BasicLit) <a href=\"https://golang.org/src/go/ast/ast.go?s=12101:12135#L415\">Pos</a>  </h3> <pre data-language=\"go\">func (x *BasicLit) Pos() token.Pos</pre> <h2 id=\"BinaryExpr\">type BinaryExpr  </h2> <pre data-language=\"go\">type BinaryExpr struct {\n        X     Expr        // left operand\n        OpPos token.Pos   // position of Op\n        Op    token.Token // operator\n        Y     Expr        // right operand\n}</pre> <p> A BinaryExpr node represents a binary expression. </p> <h3 id=\"BinaryExpr.End\">func (*BinaryExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=14430:14466#L464\">End</a>  </h3> <pre data-language=\"go\">func (x *BinaryExpr) End() token.Pos</pre> <h3 id=\"BinaryExpr.Pos\">func (*BinaryExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=12814:12850#L431\">Pos</a>  </h3> <pre data-language=\"go\">func (x *BinaryExpr) Pos() token.Pos</pre> <h2 id=\"BlockStmt\">type BlockStmt  </h2> <pre data-language=\"go\">type BlockStmt struct {\n        Lbrace token.Pos // position of \"{\"\n        List   []Stmt\n        Rbrace token.Pos // position of \"}\"\n}</pre> <p> A BlockStmt node represents a braced statement list. </p> <h3 id=\"BlockStmt.End\">func (*BlockStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=23945:23980#L754\">End</a>  </h3> <pre data-language=\"go\">func (s *BlockStmt) End() token.Pos</pre> <h3 id=\"BlockStmt.Pos\">func (*BlockStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22433:22468#L715\">Pos</a>  </h3> <pre data-language=\"go\">func (s *BlockStmt) Pos() token.Pos</pre> <h2 id=\"BranchStmt\">type BranchStmt  </h2> <pre data-language=\"go\">type BranchStmt struct {\n        TokPos token.Pos   // position of Tok\n        Tok    token.Token // keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n        Label  *Ident      // label name; or nil\n}</pre> <p> A BranchStmt node represents a break, continue, goto, or fallthrough statement. </p> <h3 id=\"BranchStmt.End\">func (*BranchStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=23802:23838#L748\">End</a>  </h3> <pre data-language=\"go\">func (s *BranchStmt) End() token.Pos</pre> <h3 id=\"BranchStmt.Pos\">func (*BranchStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22372:22408#L714\">Pos</a>  </h3> <pre data-language=\"go\">func (s *BranchStmt) Pos() token.Pos</pre> <h2 id=\"CallExpr\">type CallExpr  </h2> <pre data-language=\"go\">type CallExpr struct {\n        Fun      Expr      // function expression\n        Lparen   token.Pos // position of \"(\"\n        Args     []Expr    // function arguments; or nil\n        Ellipsis token.Pos // position of \"...\", if any\n        Rparen   token.Pos // position of \")\"\n}</pre> <p> A CallExpr node represents an expression followed by an argument list. </p> <h3 id=\"CallExpr.End\">func (*CallExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=14241:14275#L461\">End</a>  </h3> <pre data-language=\"go\">func (x *CallExpr) End() token.Pos</pre> <h3 id=\"CallExpr.Pos\">func (*CallExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=12631:12665#L428\">Pos</a>  </h3> <pre data-language=\"go\">func (x *CallExpr) Pos() token.Pos</pre> <h2 id=\"CaseClause\">type CaseClause  </h2> <pre data-language=\"go\">type CaseClause struct {\n        Case  token.Pos // position of \"case\" or \"default\" keyword\n        List  []Expr    // list of expressions or types; nil means default case\n        Colon token.Pos // position of \":\"\n        Body  []Stmt    // statement list; or nil\n}</pre> <p> A CaseClause represents a case of an expression or type switch statement. </p> <h3 id=\"CaseClause.End\">func (*CaseClause) <a href=\"https://golang.org/src/go/ast/ast.go?s=24108:24144#L761\">End</a>  </h3> <pre data-language=\"go\">func (s *CaseClause) End() token.Pos</pre> <h3 id=\"CaseClause.Pos\">func (*CaseClause) <a href=\"https://golang.org/src/go/ast/ast.go?s=22551:22587#L717\">Pos</a>  </h3> <pre data-language=\"go\">func (s *CaseClause) Pos() token.Pos</pre> <h2 id=\"ChanDir\">type ChanDir  </h2> <pre data-language=\"go\">type ChanDir int</pre> <p> The direction of a channel type is indicated by one of the following constants. </p> <pre data-language=\"go\">const (\n        SEND ChanDir = 1 &lt;&lt; iota\n        RECV\n)</pre> <h2 id=\"ChanType\">type ChanType  </h2> <pre data-language=\"go\">type ChanType struct {\n        Begin token.Pos // position of \"chan\" keyword or \"&lt;-\" (whichever comes first)\n        Arrow token.Pos // position of \"&lt;-\" (token.NoPos if there is no \"&lt;-\")\n        Dir   ChanDir   // channel direction\n        Value Expr      // value type\n}</pre> <p> A ChanType node represents a channel type. </p> <h3 id=\"ChanType.End\">func (*ChanType) <a href=\"https://golang.org/src/go/ast/ast.go?s=14934:14968#L476\">End</a>  </h3> <pre data-language=\"go\">func (x *ChanType) End() token.Pos</pre> <h3 id=\"ChanType.Pos\">func (*ChanType) <a href=\"https://golang.org/src/go/ast/ast.go?s=13379:13413#L443\">Pos</a>  </h3> <pre data-language=\"go\">func (x *ChanType) Pos() token.Pos</pre> <h2 id=\"CommClause\">type CommClause  </h2> <pre data-language=\"go\">type CommClause struct {\n        Case  token.Pos // position of \"case\" or \"default\" keyword\n        Comm  Stmt      // send or receive statement; nil means default case\n        Colon token.Pos // position of \":\"\n        Body  []Stmt    // statement list; or nil\n}</pre> <p> A CommClause node represents a case of a select statement. </p> <h3 id=\"CommClause.End\">func (*CommClause) <a href=\"https://golang.org/src/go/ast/ast.go?s=24359:24395#L769\">End</a>  </h3> <pre data-language=\"go\">func (s *CommClause) End() token.Pos</pre> <h3 id=\"CommClause.Pos\">func (*CommClause) <a href=\"https://golang.org/src/go/ast/ast.go?s=22732:22768#L720\">Pos</a>  </h3> <pre data-language=\"go\">func (s *CommClause) Pos() token.Pos</pre> <h2 id=\"Comment\">type Comment  </h2> <pre data-language=\"go\">type Comment struct {\n        Slash token.Pos // position of \"/\" starting the comment\n        Text  string    // comment text (excluding '\\n' for //-style comments)\n}</pre> <p> A Comment node represents a single //-style or /*-style comment. </p> <h3 id=\"Comment.End\">func (*Comment) <a href=\"https://golang.org/src/go/ast/ast.go?s=2037:2070#L58\">End</a>  </h3> <pre data-language=\"go\">func (c *Comment) End() token.Pos</pre> <h3 id=\"Comment.Pos\">func (*Comment) <a href=\"https://golang.org/src/go/ast/ast.go?s=1984:2017#L57\">Pos</a>  </h3> <pre data-language=\"go\">func (c *Comment) Pos() token.Pos</pre> <h2 id=\"CommentGroup\">type CommentGroup  </h2> <pre data-language=\"go\">type CommentGroup struct {\n        List []*Comment // len(List) &gt; 0\n}</pre> <p> A CommentGroup represents a sequence of comments with no other tokens and no empty lines between. </p> <h3 id=\"CommentGroup.End\">func (*CommentGroup) <a href=\"https://golang.org/src/go/ast/ast.go?s=2358:2396#L68\">End</a>  </h3> <pre data-language=\"go\">func (g *CommentGroup) End() token.Pos</pre> <h3 id=\"CommentGroup.Pos\">func (*CommentGroup) <a href=\"https://golang.org/src/go/ast/ast.go?s=2292:2330#L67\">Pos</a>  </h3> <pre data-language=\"go\">func (g *CommentGroup) Pos() token.Pos</pre> <h3 id=\"CommentGroup.Text\">func (*CommentGroup) <a href=\"https://golang.org/src/go/ast/ast.go?s=2968:3004#L86\">Text</a>  </h3> <pre data-language=\"go\">func (g *CommentGroup) Text() string</pre> <p> Text returns the text of the comment. Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. Multiple empty lines are reduced to one, and trailing space on lines is trimmed. Unless the result is empty, it is newline-terminated. </p> <h2 id=\"CommentMap\">type CommentMap  </h2> <pre data-language=\"go\">type CommentMap map[Node][]*CommentGroup</pre> <p> A CommentMap maps an AST node to a list of comment groups associated with it. See NewCommentMap for a description of the association. </p> <div id=\"example_CommentMap\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>This example illustrates how to remove a variable declaration in a Go program while maintaining correct comment association using an ast.CommentMap. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// src is the input for which we create the AST that we\n    // are going to manipulate.\n    src := `\n// This is the package comment.\npackage main\n\n// This comment is associated with the hello constant.\nconst hello = \"Hello, World!\" // line comment 1\n\n// This comment is associated with the foo variable.\nvar foo = hello // line comment 2 \n\n// This comment is associated with the main function.\nfunc main() {\n    fmt.Println(hello) // line comment 3\n}\n`\n\n    // Create the AST by parsing src.\n    fset := token.NewFileSet() // positions are relative to fset\n    f, err := parser.ParseFile(fset, \"src.go\", src, parser.ParseComments)\n    if err != nil {\n            panic(err)\n    }\n\n    // Create an ast.CommentMap from the ast.File's comments.\n    // This helps keeping the association between comments\n    // and AST nodes.\n    cmap := ast.NewCommentMap(fset, f, f.Comments)\n\n    // Remove the first variable declaration from the list of declarations.\n    f.Decls = removeFirstVarDecl(f.Decls)\n\n    // Use the comment map to filter comments that don't belong anymore\n    // (the comments associated with the variable declaration), and create\n    // the new comments list.\n    f.Comments = cmap.Filter(f).Comments()\n\n    // Print the modified AST.\n    var buf bytes.Buffer\n    if err := format.Node(&amp;buf, fset, f); err != nil {\n            panic(err)\n    }\n    fmt.Printf(\"%s\", buf.Bytes())\n\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">// This is the package comment.\npackage main\n\n// This comment is associated with the hello constant.\nconst hello = \"Hello, World!\" // line comment 1\n\n// This comment is associated with the main function.\nfunc main() {\n\tfmt.Println(hello) // line comment 3\n}\n</pre> </div> </div> <h3 id=\"NewCommentMap\">func <a href=\"https://golang.org/src/go/ast/commentmap.go?s=3964:4051#L133\">NewCommentMap</a>  </h3> <pre data-language=\"go\">func NewCommentMap(fset *token.FileSet, node Node, comments []*CommentGroup) CommentMap</pre> <p> NewCommentMap creates a new comment map by associating comment groups of the comments list with the nodes of the AST specified by node. </p> <p> A comment group g is associated with a node n if: </p> <pre data-language=\"go\">- g starts on the same line as n ends\n- g starts on the line immediately following n, and there is\n  at least one empty line after g and before the next node\n- g starts before n and is not associated to the node before n\n  via the previous rules\n</pre> <p> NewCommentMap tries to associate a comment group to the \"largest\" node possible: For instance, if the comment is a line comment trailing an assignment, the comment is associated with the entire assignment rather than just the last operand in the assignment. </p> <h3 id=\"CommentMap.Comments\">func (CommentMap) <a href=\"https://golang.org/src/go/ast/commentmap.go?s=7690:7739#L262\">Comments</a>  </h3> <pre data-language=\"go\">func (cmap CommentMap) Comments() []*CommentGroup</pre> <p> Comments returns the list of comment groups in the comment map. The result is sorted in source order. </p> <h3 id=\"CommentMap.Filter\">func (CommentMap) <a href=\"https://golang.org/src/go/ast/commentmap.go?s=7379:7430#L248\">Filter</a>  </h3> <pre data-language=\"go\">func (cmap CommentMap) Filter(node Node) CommentMap</pre> <p> Filter returns a new comment map consisting of only those entries of cmap for which a corresponding node exists in the AST specified by node. </p> <h3 id=\"CommentMap.String\">func (CommentMap) <a href=\"https://golang.org/src/go/ast/commentmap.go?s=8595:8633#L307\">String</a>  </h3> <pre data-language=\"go\">func (cmap CommentMap) String() string</pre> <h3 id=\"CommentMap.Update\">func (CommentMap) <a href=\"https://golang.org/src/go/ast/commentmap.go?s=7055:7104#L236\">Update</a>  </h3> <pre data-language=\"go\">func (cmap CommentMap) Update(old, new Node) Node</pre> <p> Update replaces an old node in the comment map with the new node and returns the new node. Comments that were associated with the old node are associated with the new node. </p> <h2 id=\"CompositeLit\">type CompositeLit  </h2> <pre data-language=\"go\">type CompositeLit struct {\n        Type   Expr      // literal type; or nil\n        Lbrace token.Pos // position of \"{\"\n        Elts   []Expr    // list of composite elements; or nil\n        Rbrace token.Pos // position of \"}\"\n}</pre> <p> A CompositeLit node represents a composite literal. </p> <h3 id=\"CompositeLit.End\">func (*CompositeLit) <a href=\"https://golang.org/src/go/ast/ast.go?s=13852:13890#L455\">End</a>  </h3> <pre data-language=\"go\">func (x *CompositeLit) End() token.Pos</pre> <h3 id=\"CompositeLit.Pos\">func (*CompositeLit) <a href=\"https://golang.org/src/go/ast/ast.go?s=12217:12255#L417\">Pos</a>  </h3> <pre data-language=\"go\">func (x *CompositeLit) Pos() token.Pos</pre> <h2 id=\"Decl\">type Decl  </h2> <pre data-language=\"go\">type Decl interface {\n        Node\n        // contains filtered or unexported methods\n}</pre> <p> All declaration nodes implement the Decl interface. </p> <h2 id=\"DeclStmt\">type DeclStmt  </h2> <pre data-language=\"go\">type DeclStmt struct {\n        Decl Decl // *GenDecl with CONST, TYPE, or VAR token\n}</pre> <p> A DeclStmt node represents a declaration in a statement list. </p> <h3 id=\"DeclStmt.End\">func (*DeclStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=23020:23054#L726\">End</a>  </h3> <pre data-language=\"go\">func (s *DeclStmt) End() token.Pos</pre> <h3 id=\"DeclStmt.Pos\">func (*DeclStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=21743:21777#L704\">Pos</a>  </h3> <pre data-language=\"go\">func (s *DeclStmt) Pos() token.Pos</pre> <h2 id=\"DeferStmt\">type DeferStmt  </h2> <pre data-language=\"go\">type DeferStmt struct {\n        Defer token.Pos // position of \"defer\" keyword\n        Call  *CallExpr\n}</pre> <p> A DeferStmt node represents a defer statement. </p> <h3 id=\"DeferStmt.End\">func (*DeferStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=23596:23631#L741\">End</a>  </h3> <pre data-language=\"go\">func (s *DeferStmt) End() token.Pos</pre> <h3 id=\"DeferStmt.Pos\">func (*DeferStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22251:22286#L712\">Pos</a>  </h3> <pre data-language=\"go\">func (s *DeferStmt) Pos() token.Pos</pre> <h2 id=\"Ellipsis\">type Ellipsis  </h2> <pre data-language=\"go\">type Ellipsis struct {\n        Ellipsis token.Pos // position of \"...\"\n        Elt      Expr      // ellipsis element type (parameter lists only); or nil\n}</pre> <p> An Ellipsis node stands for the \"...\" type in a parameter list or the \"...\" length in an array type. </p> <h3 id=\"Ellipsis.End\">func (*Ellipsis) <a href=\"https://golang.org/src/go/ast/ast.go?s=13574:13608#L447\">End</a>  </h3> <pre data-language=\"go\">func (x *Ellipsis) End() token.Pos</pre> <h3 id=\"Ellipsis.Pos\">func (*Ellipsis) <a href=\"https://golang.org/src/go/ast/ast.go?s=12044:12078#L414\">Pos</a>  </h3> <pre data-language=\"go\">func (x *Ellipsis) Pos() token.Pos</pre> <h2 id=\"EmptyStmt\">type EmptyStmt  </h2> <pre data-language=\"go\">type EmptyStmt struct {\n        Semicolon token.Pos // position of following \";\"\n        Implicit  bool      // if set, \";\" was omitted in the source\n}</pre> <p> An EmptyStmt node represents an empty statement. The \"position\" of the empty statement is the position of the immediately following (explicit or implicit) semicolon. </p> <h3 id=\"EmptyStmt.End\">func (*EmptyStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=23079:23114#L727\">End</a>  </h3> <pre data-language=\"go\">func (s *EmptyStmt) End() token.Pos</pre> <h3 id=\"EmptyStmt.Pos\">func (*EmptyStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=21808:21843#L705\">Pos</a>  </h3> <pre data-language=\"go\">func (s *EmptyStmt) Pos() token.Pos</pre> <h2 id=\"Expr\">type Expr  </h2> <pre data-language=\"go\">type Expr interface {\n        Node\n        // contains filtered or unexported methods\n}</pre> <p> All expression nodes implement the Expr interface. </p> <h2 id=\"ExprStmt\">type ExprStmt  </h2> <pre data-language=\"go\">type ExprStmt struct {\n        X Expr // expression\n}</pre> <p> An ExprStmt node represents a (stand-alone) expression in a statement list. </p> <h3 id=\"ExprStmt.End\">func (*ExprStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=23261:23295#L734\">End</a>  </h3> <pre data-language=\"go\">func (s *ExprStmt) End() token.Pos</pre> <h3 id=\"ExprStmt.Pos\">func (*ExprStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=21938:21972#L707\">Pos</a>  </h3> <pre data-language=\"go\">func (s *ExprStmt) Pos() token.Pos</pre> <h2 id=\"Field\">type Field  </h2> <pre data-language=\"go\">type Field struct {\n        Doc     *CommentGroup // associated documentation; or nil\n        Names   []*Ident      // field/method/parameter names; or nil if anonymous field\n        Type    Expr          // field/method/parameter type\n        Tag     *BasicLit     // field tag; or nil\n        Comment *CommentGroup // line comments; or nil\n}</pre> <p> A Field represents a Field declaration list in a struct type, a method list in an interface type, or a parameter/result declaration in a signature. </p> <h3 id=\"Field.End\">func (*Field) <a href=\"https://golang.org/src/go/ast/ast.go?s=4864:4895#L162\">End</a>  </h3> <pre data-language=\"go\">func (f *Field) End() token.Pos</pre> <h3 id=\"Field.Pos\">func (*Field) <a href=\"https://golang.org/src/go/ast/ast.go?s=4754:4785#L155\">Pos</a>  </h3> <pre data-language=\"go\">func (f *Field) Pos() token.Pos</pre> <h2 id=\"FieldFilter\">type FieldFilter  </h2> <pre data-language=\"go\">type FieldFilter func(name string, value reflect.Value) bool</pre> <p> A FieldFilter may be provided to Fprint to control the output. </p> <h2 id=\"FieldList\">type FieldList  </h2> <pre data-language=\"go\">type FieldList struct {\n        Opening token.Pos // position of opening parenthesis/brace, if any\n        List    []*Field  // field list; or nil\n        Closing token.Pos // position of closing parenthesis/brace, if any\n}</pre> <p> A FieldList represents a list of Fields, enclosed by parentheses or braces. </p> <h3 id=\"FieldList.End\">func (*FieldList) <a href=\"https://golang.org/src/go/ast/ast.go?s=5501:5536#L188\">End</a>  </h3> <pre data-language=\"go\">func (f *FieldList) End() token.Pos</pre> <h3 id=\"FieldList.NumFields\">func (*FieldList) <a href=\"https://golang.org/src/go/ast/ast.go?s=5848:5883#L201\">NumFields</a>  </h3> <pre data-language=\"go\">func (f *FieldList) NumFields() int</pre> <p> NumFields returns the number of (named and anonymous fields) in a FieldList. </p> <h3 id=\"FieldList.Pos\">func (*FieldList) <a href=\"https://golang.org/src/go/ast/ast.go?s=5248:5283#L176\">Pos</a>  </h3> <pre data-language=\"go\">func (f *FieldList) Pos() token.Pos</pre> <h2 id=\"File\">type File  </h2> <pre data-language=\"go\">type File struct {\n        Doc        *CommentGroup   // associated documentation; or nil\n        Package    token.Pos       // position of \"package\" keyword\n        Name       *Ident          // package name\n        Decls      []Decl          // top-level declarations; or nil\n        Scope      *Scope          // package scope (this file only)\n        Imports    []*ImportSpec   // imports in this file\n        Unresolved []*Ident        // unresolved identifiers in this file\n        Comments   []*CommentGroup // list of all comments in the source file\n}</pre> <p> A File node represents a Go source file. </p> <p> The Comments list contains all comments in the source file in order of appearance, including the comments that are pointed to from other nodes via Doc and Comment fields. </p> <h3 id=\"MergePackageFiles\">func <a href=\"https://golang.org/src/go/ast/filter.go?s=8206:8264#L305\">MergePackageFiles</a>  </h3> <pre data-language=\"go\">func MergePackageFiles(pkg *Package, mode MergeMode) *File</pre> <p> MergePackageFiles creates a file AST by merging the ASTs of the files belonging to a package. The mode flags control merging behavior. </p> <h3 id=\"File.End\">func (*File) <a href=\"https://golang.org/src/go/ast/ast.go?s=30719:30749#L971\">End</a>  </h3> <pre data-language=\"go\">func (f *File) End() token.Pos</pre> <h3 id=\"File.Pos\">func (*File) <a href=\"https://golang.org/src/go/ast/ast.go?s=30667:30697#L970\">Pos</a>  </h3> <pre data-language=\"go\">func (f *File) Pos() token.Pos</pre> <h2 id=\"Filter\">type Filter  </h2> <pre data-language=\"go\">type Filter func(string) bool</pre> <h2 id=\"ForStmt\">type ForStmt  </h2> <pre data-language=\"go\">type ForStmt struct {\n        For  token.Pos // position of \"for\" keyword\n        Init Stmt      // initialization statement; or nil\n        Cond Expr      // condition; or nil\n        Post Stmt      // post iteration statement; or nil\n        Body *BlockStmt\n}</pre> <p> A ForStmt represents a for statement. </p> <h3 id=\"ForStmt.End\">func (*ForStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=24541:24574#L776\">End</a>  </h3> <pre data-language=\"go\">func (s *ForStmt) End() token.Pos</pre> <h3 id=\"ForStmt.Pos\">func (*ForStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22852:22885#L722\">Pos</a>  </h3> <pre data-language=\"go\">func (s *ForStmt) Pos() token.Pos</pre> <h2 id=\"FuncDecl\">type FuncDecl  </h2> <pre data-language=\"go\">type FuncDecl struct {\n        Doc  *CommentGroup // associated documentation; or nil\n        Recv *FieldList    // receiver (methods); or nil (functions)\n        Name *Ident        // function/method name\n        Type *FuncType     // function signature: parameters, results, and position of \"func\" keyword\n        Body *BlockStmt    // function body; or nil (forward declaration)\n}</pre> <p> A FuncDecl node represents a function declaration. </p> <h3 id=\"FuncDecl.End\">func (*FuncDecl) <a href=\"https://golang.org/src/go/ast/ast.go?s=29546:29580#L936\">End</a>  </h3> <pre data-language=\"go\">func (d *FuncDecl) End() token.Pos</pre> <h3 id=\"FuncDecl.Pos\">func (*FuncDecl) <a href=\"https://golang.org/src/go/ast/ast.go?s=29323:29357#L927\">Pos</a>  </h3> <pre data-language=\"go\">func (d *FuncDecl) Pos() token.Pos</pre> <h2 id=\"FuncLit\">type FuncLit  </h2> <pre data-language=\"go\">type FuncLit struct {\n        Type *FuncType  // function type\n        Body *BlockStmt // function body\n}</pre> <p> A FuncLit node represents a function literal. </p> <h3 id=\"FuncLit.End\">func (*FuncLit) <a href=\"https://golang.org/src/go/ast/ast.go?s=13787:13820#L454\">End</a>  </h3> <pre data-language=\"go\">func (x *FuncLit) End() token.Pos</pre> <h3 id=\"FuncLit.Pos\">func (*FuncLit) <a href=\"https://golang.org/src/go/ast/ast.go?s=12158:12191#L416\">Pos</a>  </h3> <pre data-language=\"go\">func (x *FuncLit) Pos() token.Pos</pre> <h2 id=\"FuncType\">type FuncType  </h2> <pre data-language=\"go\">type FuncType struct {\n        Func    token.Pos  // position of \"func\" keyword (token.NoPos if there is no \"func\")\n        Params  *FieldList // (incoming) parameters; non-nil\n        Results *FieldList // (outgoing) results; or nil\n}</pre> <p> A FuncType node represents a function type. </p> <h3 id=\"FuncType.End\">func (*FuncType) <a href=\"https://golang.org/src/go/ast/ast.go?s=14689:14723#L468\">End</a>  </h3> <pre data-language=\"go\">func (x *FuncType) End() token.Pos</pre> <h3 id=\"FuncType.Pos\">func (*FuncType) <a href=\"https://golang.org/src/go/ast/ast.go?s=13062:13096#L435\">Pos</a>  </h3> <pre data-language=\"go\">func (x *FuncType) Pos() token.Pos</pre> <h2 id=\"GenDecl\">type GenDecl  </h2> <pre data-language=\"go\">type GenDecl struct {\n        Doc    *CommentGroup // associated documentation; or nil\n        TokPos token.Pos     // position of Tok\n        Tok    token.Token   // IMPORT, CONST, TYPE, VAR\n        Lparen token.Pos     // position of '(', if any\n        Specs  []Spec\n        Rparen token.Pos // position of ')', if any\n}</pre> <p> A GenDecl node (generic declaration node) represents an import, constant, type or variable declaration. A valid Lparen position (Lparen.Line &gt; 0) indicates a parenthesized declaration. </p> <p> Relationship between Tok value and Specs element type: </p> <pre data-language=\"go\">token.IMPORT  *ImportSpec\ntoken.CONST   *ValueSpec\ntoken.TYPE    *TypeSpec\ntoken.VAR     *ValueSpec\n</pre> <h3 id=\"GenDecl.End\">func (*GenDecl) <a href=\"https://golang.org/src/go/ast/ast.go?s=29433:29466#L930\">End</a>  </h3> <pre data-language=\"go\">func (d *GenDecl) End() token.Pos</pre> <h3 id=\"GenDecl.Pos\">func (*GenDecl) <a href=\"https://golang.org/src/go/ast/ast.go?s=29268:29301#L926\">Pos</a>  </h3> <pre data-language=\"go\">func (d *GenDecl) Pos() token.Pos</pre> <h2 id=\"GoStmt\">type GoStmt  </h2> <pre data-language=\"go\">type GoStmt struct {\n        Go   token.Pos // position of \"go\" keyword\n        Call *CallExpr\n}</pre> <p> A GoStmt node represents a go statement. </p> <h3 id=\"GoStmt.End\">func (*GoStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=23535:23567#L740\">End</a>  </h3> <pre data-language=\"go\">func (s *GoStmt) End() token.Pos</pre> <h3 id=\"GoStmt.Pos\">func (*GoStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22194:22226#L711\">Pos</a>  </h3> <pre data-language=\"go\">func (s *GoStmt) Pos() token.Pos</pre> <h2 id=\"Ident\">type Ident  </h2> <pre data-language=\"go\">type Ident struct {\n        NamePos token.Pos // identifier position\n        Name    string    // identifier name\n        Obj     *Object   // denoted object; or nil\n}</pre> <p> An Ident node represents an identifier. </p> <h3 id=\"NewIdent\">func <a href=\"https://golang.org/src/go/ast/ast.go?s=16131:16164#L511\">NewIdent</a>  </h3> <pre data-language=\"go\">func NewIdent(name string) *Ident</pre> <p> NewIdent creates a new Ident without position. Useful for ASTs generated by code other than the Go parser. </p> <h3 id=\"Ident.End\">func (*Ident) <a href=\"https://golang.org/src/go/ast/ast.go?s=13489:13520#L446\">End</a>  </h3> <pre data-language=\"go\">func (x *Ident) End() token.Pos</pre> <h3 id=\"Ident.IsExported\">func (*Ident) <a href=\"https://golang.org/src/go/ast/ast.go?s=16556:16590#L524\">IsExported</a>  </h3> <pre data-language=\"go\">func (id *Ident) IsExported() bool</pre> <p> IsExported reports whether id is an exported Go symbol (that is, whether it begins with an uppercase letter). </p> <h3 id=\"Ident.Pos\">func (*Ident) <a href=\"https://golang.org/src/go/ast/ast.go?s=11988:12019#L413\">Pos</a>  </h3> <pre data-language=\"go\">func (x *Ident) Pos() token.Pos</pre> <h3 id=\"Ident.String\">func (*Ident) <a href=\"https://golang.org/src/go/ast/ast.go?s=16623:16655#L526\">String</a>  </h3> <pre data-language=\"go\">func (id *Ident) String() string</pre> <h2 id=\"IfStmt\">type IfStmt  </h2> <pre data-language=\"go\">type IfStmt struct {\n        If   token.Pos // position of \"if\" keyword\n        Init Stmt      // initialization statement; or nil\n        Cond Expr      // condition\n        Body *BlockStmt\n        Else Stmt // else branch; or nil\n}</pre> <p> An IfStmt node represents an if statement. </p> <h3 id=\"IfStmt.End\">func (*IfStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=24005:24037#L755\">End</a>  </h3> <pre data-language=\"go\">func (s *IfStmt) End() token.Pos</pre> <h3 id=\"IfStmt.Pos\">func (*IfStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22494:22526#L716\">Pos</a>  </h3> <pre data-language=\"go\">func (s *IfStmt) Pos() token.Pos</pre> <h2 id=\"ImportSpec\">type ImportSpec  </h2> <pre data-language=\"go\">type ImportSpec struct {\n        Doc     *CommentGroup // associated documentation; or nil\n        Name    *Ident        // local package name (including \".\"); or nil\n        Path    *BasicLit     // import path\n        Comment *CommentGroup // line comments; or nil\n        EndPos  token.Pos     // end of spec (overrides Path.Pos if nonzero)\n}</pre> <p> An ImportSpec node represents a single package import. </p> <h3 id=\"ImportSpec.End\">func (*ImportSpec) <a href=\"https://golang.org/src/go/ast/ast.go?s=27244:27280#L857\">End</a>  </h3> <pre data-language=\"go\">func (s *ImportSpec) End() token.Pos</pre> <h3 id=\"ImportSpec.Pos\">func (*ImportSpec) <a href=\"https://golang.org/src/go/ast/ast.go?s=27012:27048#L848\">Pos</a>  </h3> <pre data-language=\"go\">func (s *ImportSpec) Pos() token.Pos</pre> <h2 id=\"Importer\">type Importer  </h2> <pre data-language=\"go\">type Importer func(imports map[string]*Object, path string) (pkg *Object, err error)</pre> <p> An Importer resolves import paths to package Objects. The imports map records the packages already imported, indexed by package id (canonical import path). An Importer must determine the canonical import path and check the map to see if it is already present in the imports map. If so, the Importer can return the map entry. Otherwise, the Importer should load the package data for the given path into a new *Object (pkg), record pkg in the imports map, and then return pkg. </p> <h2 id=\"IncDecStmt\">type IncDecStmt  </h2> <pre data-language=\"go\">type IncDecStmt struct {\n        X      Expr\n        TokPos token.Pos   // position of Tok\n        Tok    token.Token // INC or DEC\n}</pre> <p> An IncDecStmt node represents an increment or decrement statement. </p> <h3 id=\"IncDecStmt.End\">func (*IncDecStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=23383:23419#L736\">End</a>  </h3> <pre data-language=\"go\">func (s *IncDecStmt) End() token.Pos</pre> <h3 id=\"IncDecStmt.Pos\">func (*IncDecStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22065:22101#L709\">Pos</a>  </h3> <pre data-language=\"go\">func (s *IncDecStmt) Pos() token.Pos</pre> <h2 id=\"IndexExpr\">type IndexExpr  </h2> <pre data-language=\"go\">type IndexExpr struct {\n        X      Expr      // expression\n        Lbrack token.Pos // position of \"[\"\n        Index  Expr      // index expression\n        Rbrack token.Pos // position of \"]\"\n}</pre> <p> An IndexExpr node represents an expression followed by an index. </p> <h3 id=\"IndexExpr.End\">func (*IndexExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=14046:14081#L458\">End</a>  </h3> <pre data-language=\"go\">func (x *IndexExpr) End() token.Pos</pre> <h3 id=\"IndexExpr.Pos\">func (*IndexExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=12445:12480#L425\">Pos</a>  </h3> <pre data-language=\"go\">func (x *IndexExpr) Pos() token.Pos</pre> <h2 id=\"InterfaceType\">type InterfaceType  </h2> <pre data-language=\"go\">type InterfaceType struct {\n        Interface  token.Pos  // position of \"interface\" keyword\n        Methods    *FieldList // list of methods\n        Incomplete bool       // true if (source) methods are missing in the Methods list\n}</pre> <p> An InterfaceType node represents an interface type. </p> <h3 id=\"InterfaceType.End\">func (*InterfaceType) <a href=\"https://golang.org/src/go/ast/ast.go?s=14802:14841#L474\">End</a>  </h3> <pre data-language=\"go\">func (x *InterfaceType) End() token.Pos</pre> <h3 id=\"InterfaceType.Pos\">func (*InterfaceType) <a href=\"https://golang.org/src/go/ast/ast.go?s=13259:13298#L441\">Pos</a>  </h3> <pre data-language=\"go\">func (x *InterfaceType) Pos() token.Pos</pre> <h2 id=\"KeyValueExpr\">type KeyValueExpr  </h2> <pre data-language=\"go\">type KeyValueExpr struct {\n        Key   Expr\n        Colon token.Pos // position of \":\"\n        Value Expr\n}</pre> <p> A KeyValueExpr node represents (key : value) pairs in composite literals. </p> <h3 id=\"KeyValueExpr.End\">func (*KeyValueExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=14492:14530#L465\">End</a>  </h3> <pre data-language=\"go\">func (x *KeyValueExpr) End() token.Pos</pre> <h3 id=\"KeyValueExpr.Pos\">func (*KeyValueExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=12876:12914#L432\">Pos</a>  </h3> <pre data-language=\"go\">func (x *KeyValueExpr) Pos() token.Pos</pre> <h2 id=\"LabeledStmt\">type LabeledStmt  </h2> <pre data-language=\"go\">type LabeledStmt struct {\n        Label *Ident\n        Colon token.Pos // position of \":\"\n        Stmt  Stmt\n}</pre> <p> A LabeledStmt node represents a labeled statement. </p> <h3 id=\"LabeledStmt.End\">func (*LabeledStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=23199:23236#L733\">End</a>  </h3> <pre data-language=\"go\">func (s *LabeledStmt) End() token.Pos</pre> <h3 id=\"LabeledStmt.Pos\">func (*LabeledStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=21872:21909#L706\">Pos</a>  </h3> <pre data-language=\"go\">func (s *LabeledStmt) Pos() token.Pos</pre> <h2 id=\"MapType\">type MapType  </h2> <pre data-language=\"go\">type MapType struct {\n        Map   token.Pos // position of \"map\" keyword\n        Key   Expr\n        Value Expr\n}</pre> <p> A MapType node represents a map type. </p> <h3 id=\"MapType.End\">func (*MapType) <a href=\"https://golang.org/src/go/ast/ast.go?s=14869:14902#L475\">End</a>  </h3> <pre data-language=\"go\">func (x *MapType) End() token.Pos</pre> <h3 id=\"MapType.Pos\">func (*MapType) <a href=\"https://golang.org/src/go/ast/ast.go?s=13322:13355#L442\">Pos</a>  </h3> <pre data-language=\"go\">func (x *MapType) Pos() token.Pos</pre> <h2 id=\"MergeMode\">type MergeMode  </h2> <pre data-language=\"go\">type MergeMode uint</pre> <p> The MergeMode flags control the behavior of MergePackageFiles. </p> <pre data-language=\"go\">const (\n        // If set, duplicate function declarations are excluded.\n        FilterFuncDuplicates MergeMode = 1 &lt;&lt; iota\n        // If set, comments that are not associated with a specific\n        // AST node (as Doc or Comment) are excluded.\n        FilterUnassociatedComments\n        // If set, duplicate import declarations are excluded.\n        FilterImportDuplicates\n)</pre> <h2 id=\"Node\">type Node  </h2> <pre data-language=\"go\">type Node interface {\n        Pos() token.Pos // position of first character belonging to the node\n        End() token.Pos // position of first character immediately after the node\n}</pre> <p> All node types implement the Node interface. </p> <h2 id=\"ObjKind\">type ObjKind  </h2> <pre data-language=\"go\">type ObjKind int</pre> <p> ObjKind describes what an object represents. </p> <pre data-language=\"go\">const (\n        Bad ObjKind = iota // for error handling\n        Pkg                // package\n        Con                // constant\n        Typ                // type\n        Var                // variable\n        Fun                // function or method\n        Lbl                // label\n)</pre> <p> The list of possible Object kinds. </p> <h3 id=\"ObjKind.String\">func (ObjKind) <a href=\"https://golang.org/src/go/ast/scope.go?s=4082:4117#L152\">String</a>  </h3> <pre data-language=\"go\">func (kind ObjKind) String() string</pre> <h2 id=\"Object\">type Object  </h2> <pre data-language=\"go\">type Object struct {\n        Kind ObjKind\n        Name string      // declared name\n        Decl interface{} // corresponding Field, XxxSpec, FuncDecl, LabeledStmt, AssignStmt, Scope; or nil\n        Data interface{} // object-specific data; or nil\n        Type interface{} // placeholder for type information; may be nil\n}</pre> <p> An Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label. </p> <p> The Data fields contains object-specific data: </p> <pre data-language=\"go\">Kind    Data type         Data value\nPkg\t*types.Package    package scope\nCon     int               iota for the respective declaration\nCon     != nil            constant value\nTyp     *Scope            (used as method scope during type checking - transient)\n</pre> <h3 id=\"NewObj\">func <a href=\"https://golang.org/src/go/ast/scope.go?s=2475:2521#L77\">NewObj</a>  </h3> <pre data-language=\"go\">func NewObj(kind ObjKind, name string) *Object</pre> <p> NewObj creates a new object of a given kind and name. </p> <h3 id=\"Object.Pos\">func (*Object) <a href=\"https://golang.org/src/go/ast/scope.go?s=2748:2782#L84\">Pos</a>  </h3> <pre data-language=\"go\">func (obj *Object) Pos() token.Pos</pre> <p> Pos computes the source position of the declaration of an object name. The result may be an invalid position if it cannot be computed (obj.Decl may be nil or not correct). </p> <h2 id=\"Package\">type Package  </h2> <pre data-language=\"go\">type Package struct {\n        Name    string             // package name\n        Scope   *Scope             // package scope across all files\n        Imports map[string]*Object // map of package id -&gt; package object\n        Files   map[string]*File   // Go source files by filename\n}</pre> <p> A Package node represents a set of source files collectively building a Go package. </p> <h3 id=\"NewPackage\">func <a href=\"https://golang.org/src/go/ast/resolve.go?s=2445:2559#L64\">NewPackage</a>  </h3> <pre data-language=\"go\">func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)</pre> <p> NewPackage creates a new Package node from a set of File nodes. It resolves unresolved identifiers across files and updates each file's Unresolved list accordingly. If a non-nil importer and universe scope are provided, they are used to resolve identifiers not declared in any of the package files. Any remaining unresolved identifiers are reported as undeclared. If the files belong to different packages, one package name is selected and files with different package names are reported and then ignored. The result is a package node and a scanner.ErrorList if there were errors. </p> <h3 id=\"Package.End\">func (*Package) <a href=\"https://golang.org/src/go/ast/ast.go?s=31245:31278#L989\">End</a>  </h3> <pre data-language=\"go\">func (p *Package) End() token.Pos</pre> <h3 id=\"Package.Pos\">func (*Package) <a href=\"https://golang.org/src/go/ast/ast.go?s=31188:31221#L988\">Pos</a>  </h3> <pre data-language=\"go\">func (p *Package) Pos() token.Pos</pre> <h2 id=\"ParenExpr\">type ParenExpr  </h2> <pre data-language=\"go\">type ParenExpr struct {\n        Lparen token.Pos // position of \"(\"\n        X      Expr      // parenthesized expression\n        Rparen token.Pos // position of \")\"\n}</pre> <p> A ParenExpr node represents a parenthesized expression. </p> <h3 id=\"ParenExpr.End\">func (*ParenExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=13917:13952#L456\">End</a>  </h3> <pre data-language=\"go\">func (x *ParenExpr) End() token.Pos</pre> <h3 id=\"ParenExpr.Pos\">func (*ParenExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=12322:12357#L423\">Pos</a>  </h3> <pre data-language=\"go\">func (x *ParenExpr) Pos() token.Pos</pre> <h2 id=\"RangeStmt\">type RangeStmt  </h2> <pre data-language=\"go\">type RangeStmt struct {\n        For        token.Pos   // position of \"for\" keyword\n        Key, Value Expr        // Key, Value may be nil\n        TokPos     token.Pos   // position of Tok; invalid if Key == nil\n        Tok        token.Token // ILLEGAL if Key == nil, ASSIGN, DEFINE\n        X          Expr        // value to range over\n        Body       *BlockStmt\n}</pre> <p> A RangeStmt represents a for statement with a range clause. </p> <h3 id=\"RangeStmt.End\">func (*RangeStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=24602:24637#L777\">End</a>  </h3> <pre data-language=\"go\">func (s *RangeStmt) End() token.Pos</pre> <h3 id=\"RangeStmt.Pos\">func (*RangeStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22910:22945#L723\">Pos</a>  </h3> <pre data-language=\"go\">func (s *RangeStmt) Pos() token.Pos</pre> <h2 id=\"ReturnStmt\">type ReturnStmt  </h2> <pre data-language=\"go\">type ReturnStmt struct {\n        Return  token.Pos // position of \"return\" keyword\n        Results []Expr    // result expressions; or nil\n}</pre> <p> A ReturnStmt node represents a return statement. </p> <h3 id=\"ReturnStmt.End\">func (*ReturnStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=23657:23693#L742\">End</a>  </h3> <pre data-language=\"go\">func (s *ReturnStmt) End() token.Pos</pre> <h3 id=\"ReturnStmt.Pos\">func (*ReturnStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22311:22347#L713\">Pos</a>  </h3> <pre data-language=\"go\">func (s *ReturnStmt) Pos() token.Pos</pre> <h2 id=\"Scope\">type Scope  </h2> <pre data-language=\"go\">type Scope struct {\n        Outer   *Scope\n        Objects map[string]*Object\n}</pre> <p> A Scope maintains the set of named language entities declared in the scope and a link to the immediately surrounding (outer) scope. </p> <h3 id=\"NewScope\">func <a href=\"https://golang.org/src/go/ast/scope.go?s=545:579#L15\">NewScope</a>  </h3> <pre data-language=\"go\">func NewScope(outer *Scope) *Scope</pre> <p> NewScope creates a new scope nested in the outer scope. </p> <h3 id=\"Scope.Insert\">func (*Scope) <a href=\"https://golang.org/src/go/ast/scope.go?s=1120:1169#L33\">Insert</a>  </h3> <pre data-language=\"go\">func (s *Scope) Insert(obj *Object) (alt *Object)</pre> <p> Insert attempts to insert a named object obj into the scope s. If the scope already contains an object alt with the same name, Insert leaves the scope unchanged and returns alt. Otherwise it inserts obj and returns nil. </p> <h3 id=\"Scope.Lookup\">func (*Scope) <a href=\"https://golang.org/src/go/ast/scope.go?s=812:855#L24\">Lookup</a>  </h3> <pre data-language=\"go\">func (s *Scope) Lookup(name string) *Object</pre> <p> Lookup returns the object with the given name if it is found in scope s, otherwise it returns nil. Outer scopes are ignored. </p> <h3 id=\"Scope.String\">func (*Scope) <a href=\"https://golang.org/src/go/ast/scope.go?s=1279:1310#L41\">String</a>  </h3> <pre data-language=\"go\">func (s *Scope) String() string</pre> <p> Debugging support </p> <h2 id=\"SelectStmt\">type SelectStmt  </h2> <pre data-language=\"go\">type SelectStmt struct {\n        Select token.Pos  // position of \"select\" keyword\n        Body   *BlockStmt // CommClauses only\n}</pre> <p> An SelectStmt node represents a select statement. </p> <h3 id=\"SelectStmt.End\">func (*SelectStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=24480:24516#L775\">End</a>  </h3> <pre data-language=\"go\">func (s *SelectStmt) End() token.Pos</pre> <h3 id=\"SelectStmt.Pos\">func (*SelectStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22791:22827#L721\">Pos</a>  </h3> <pre data-language=\"go\">func (s *SelectStmt) Pos() token.Pos</pre> <h2 id=\"SelectorExpr\">type SelectorExpr  </h2> <pre data-language=\"go\">type SelectorExpr struct {\n        X   Expr   // expression\n        Sel *Ident // field selector\n}</pre> <p> A SelectorExpr node represents an expression followed by a selector. </p> <h3 id=\"SelectorExpr.End\">func (*SelectorExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=13982:14020#L457\">End</a>  </h3> <pre data-language=\"go\">func (x *SelectorExpr) End() token.Pos</pre> <h3 id=\"SelectorExpr.Pos\">func (*SelectorExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=12383:12421#L424\">Pos</a>  </h3> <pre data-language=\"go\">func (x *SelectorExpr) Pos() token.Pos</pre> <h2 id=\"SendStmt\">type SendStmt  </h2> <pre data-language=\"go\">type SendStmt struct {\n        Chan  Expr\n        Arrow token.Pos // position of \"&lt;-\"\n        Value Expr\n}</pre> <p> A SendStmt node represents a send statement. </p> <h3 id=\"SendStmt.End\">func (*SendStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=23320:23354#L735\">End</a>  </h3> <pre data-language=\"go\">func (s *SendStmt) End() token.Pos</pre> <h3 id=\"SendStmt.Pos\">func (*SendStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22000:22034#L708\">Pos</a>  </h3> <pre data-language=\"go\">func (s *SendStmt) Pos() token.Pos</pre> <h2 id=\"SliceExpr\">type SliceExpr  </h2> <pre data-language=\"go\">type SliceExpr struct {\n        X      Expr      // expression\n        Lbrack token.Pos // position of \"[\"\n        Low    Expr      // begin of slice range; or nil\n        High   Expr      // end of slice range; or nil\n        Max    Expr      // maximum capacity of slice; or nil\n        Slice3 bool      // true if 3-index slice (2 colons present)\n        Rbrack token.Pos // position of \"]\"\n}</pre> <p> An SliceExpr node represents an expression followed by slice indices. </p> <h3 id=\"SliceExpr.End\">func (*SliceExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=14111:14146#L459\">End</a>  </h3> <pre data-language=\"go\">func (x *SliceExpr) End() token.Pos</pre> <h3 id=\"SliceExpr.Pos\">func (*SliceExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=12507:12542#L426\">Pos</a>  </h3> <pre data-language=\"go\">func (x *SliceExpr) Pos() token.Pos</pre> <h2 id=\"Spec\">type Spec  </h2> <pre data-language=\"go\">type Spec interface {\n        Node\n        // contains filtered or unexported methods\n}</pre> <p> The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec. </p> <h2 id=\"StarExpr\">type StarExpr  </h2> <pre data-language=\"go\">type StarExpr struct {\n        Star token.Pos // position of \"*\"\n        X    Expr      // operand\n}</pre> <p> A StarExpr node represents an expression of the form \"*\" Expression. Semantically it could be a unary \"*\" expression, or a pointer type. </p> <h3 id=\"StarExpr.End\">func (*StarExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=14306:14340#L462\">End</a>  </h3> <pre data-language=\"go\">func (x *StarExpr) End() token.Pos</pre> <h3 id=\"StarExpr.Pos\">func (*StarExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=12695:12729#L429\">Pos</a>  </h3> <pre data-language=\"go\">func (x *StarExpr) Pos() token.Pos</pre> <h2 id=\"Stmt\">type Stmt  </h2> <pre data-language=\"go\">type Stmt interface {\n        Node\n        // contains filtered or unexported methods\n}</pre> <p> All statement nodes implement the Stmt interface. </p> <h2 id=\"StructType\">type StructType  </h2> <pre data-language=\"go\">type StructType struct {\n        Struct     token.Pos  // position of \"struct\" keyword\n        Fields     *FieldList // list of field declarations\n        Incomplete bool       // true if (source) fields are missing in the Fields list\n}</pre> <p> A StructType node represents a struct type. </p> <h3 id=\"StructType.End\">func (*StructType) <a href=\"https://golang.org/src/go/ast/ast.go?s=14622:14658#L467\">End</a>  </h3> <pre data-language=\"go\">func (x *StructType) End() token.Pos</pre> <h3 id=\"StructType.Pos\">func (*StructType) <a href=\"https://golang.org/src/go/ast/ast.go?s=13001:13037#L434\">Pos</a>  </h3> <pre data-language=\"go\">func (x *StructType) Pos() token.Pos</pre> <h2 id=\"SwitchStmt\">type SwitchStmt  </h2> <pre data-language=\"go\">type SwitchStmt struct {\n        Switch token.Pos  // position of \"switch\" keyword\n        Init   Stmt       // initialization statement; or nil\n        Tag    Expr       // tag expression; or nil\n        Body   *BlockStmt // CaseClauses only\n}</pre> <p> A SwitchStmt node represents an expression switch statement. </p> <h3 id=\"SwitchStmt.End\">func (*SwitchStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=24229:24265#L767\">End</a>  </h3> <pre data-language=\"go\">func (s *SwitchStmt) End() token.Pos</pre> <h3 id=\"SwitchStmt.Pos\">func (*SwitchStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22610:22646#L718\">Pos</a>  </h3> <pre data-language=\"go\">func (s *SwitchStmt) Pos() token.Pos</pre> <h2 id=\"TypeAssertExpr\">type TypeAssertExpr  </h2> <pre data-language=\"go\">type TypeAssertExpr struct {\n        X      Expr      // expression\n        Lparen token.Pos // position of \"(\"\n        Type   Expr      // asserted type; nil means type switch X.(type)\n        Rparen token.Pos // position of \")\"\n}</pre> <p> A TypeAssertExpr node represents an expression followed by a type assertion. </p> <h3 id=\"TypeAssertExpr.End\">func (*TypeAssertExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=14176:14216#L460\">End</a>  </h3> <pre data-language=\"go\">func (x *TypeAssertExpr) End() token.Pos</pre> <h3 id=\"TypeAssertExpr.Pos\">func (*TypeAssertExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=12569:12609#L427\">Pos</a>  </h3> <pre data-language=\"go\">func (x *TypeAssertExpr) Pos() token.Pos</pre> <h2 id=\"TypeSpec\">type TypeSpec  </h2> <pre data-language=\"go\">type TypeSpec struct {\n        Doc     *CommentGroup // associated documentation; or nil\n        Name    *Ident        // type name\n        Type    Expr          // *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes\n        Comment *CommentGroup // line comments; or nil\n}</pre> <p> A TypeSpec node represents a type declaration (TypeSpec production). </p> <h3 id=\"TypeSpec.End\">func (*TypeSpec) <a href=\"https://golang.org/src/go/ast/ast.go?s=27535:27569#L873\">End</a>  </h3> <pre data-language=\"go\">func (s *TypeSpec) End() token.Pos</pre> <h3 id=\"TypeSpec.Pos\">func (*TypeSpec) <a href=\"https://golang.org/src/go/ast/ast.go?s=27183:27217#L855\">Pos</a>  </h3> <pre data-language=\"go\">func (s *TypeSpec) Pos() token.Pos</pre> <h2 id=\"TypeSwitchStmt\">type TypeSwitchStmt  </h2> <pre data-language=\"go\">type TypeSwitchStmt struct {\n        Switch token.Pos  // position of \"switch\" keyword\n        Init   Stmt       // initialization statement; or nil\n        Assign Stmt       // x := y.(type) or y.(type)\n        Body   *BlockStmt // CaseClauses only\n}</pre> <p> An TypeSwitchStmt node represents a type switch statement. </p> <h3 id=\"TypeSwitchStmt.End\">func (*TypeSwitchStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=24294:24334#L768\">End</a>  </h3> <pre data-language=\"go\">func (s *TypeSwitchStmt) End() token.Pos</pre> <h3 id=\"TypeSwitchStmt.Pos\">func (*TypeSwitchStmt) <a href=\"https://golang.org/src/go/ast/ast.go?s=22671:22711#L719\">Pos</a>  </h3> <pre data-language=\"go\">func (s *TypeSwitchStmt) Pos() token.Pos</pre> <h2 id=\"UnaryExpr\">type UnaryExpr  </h2> <pre data-language=\"go\">type UnaryExpr struct {\n        OpPos token.Pos   // position of Op\n        Op    token.Token // operator\n        X     Expr        // operand\n}</pre> <p> A UnaryExpr node represents a unary expression. Unary \"*\" expressions are represented via StarExpr nodes. </p> <h3 id=\"UnaryExpr.End\">func (*UnaryExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=14368:14403#L463\">End</a>  </h3> <pre data-language=\"go\">func (x *UnaryExpr) End() token.Pos</pre> <h3 id=\"UnaryExpr.Pos\">func (*UnaryExpr) <a href=\"https://golang.org/src/go/ast/ast.go?s=12754:12789#L430\">Pos</a>  </h3> <pre data-language=\"go\">func (x *UnaryExpr) Pos() token.Pos</pre> <h2 id=\"ValueSpec\">type ValueSpec  </h2> <pre data-language=\"go\">type ValueSpec struct {\n        Doc     *CommentGroup // associated documentation; or nil\n        Names   []*Ident      // value names (len(Names) &gt; 0)\n        Type    Expr          // value type; or nil\n        Values  []Expr        // initial values; or nil\n        Comment *CommentGroup // line comments; or nil\n}</pre> <p> A ValueSpec node represents a constant or variable declaration (ConstSpec or VarSpec production). </p> <h3 id=\"ValueSpec.End\">func (*ValueSpec) <a href=\"https://golang.org/src/go/ast/ast.go?s=27348:27383#L864\">End</a>  </h3> <pre data-language=\"go\">func (s *ValueSpec) End() token.Pos</pre> <h3 id=\"ValueSpec.Pos\">func (*ValueSpec) <a href=\"https://golang.org/src/go/ast/ast.go?s=27119:27154#L854\">Pos</a>  </h3> <pre data-language=\"go\">func (s *ValueSpec) Pos() token.Pos</pre> <h2 id=\"Visitor\">type Visitor  </h2> <pre data-language=\"go\">type Visitor interface {\n        Visit(node Node) (w Visitor)\n}</pre> <p> A Visitor's Visit method is invoked for each node encountered by Walk. If the result visitor w is not nil, Walk visits each of the children of node with the visitor w, followed by a call of w.Visit(nil). </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/go/ast/\" class=\"_attribution-link\">https://golang.org/pkg/go/ast/</a>\n  </p>\n</div>\n","debug/elf/index":"<h1>Package elf</h1>     <ul id=\"short-nav\">\n<li><code>import \"debug/elf\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package elf implements access to ELF object files. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#R_INFO\">func R_INFO(sym, typ uint32) uint64</a></li>\n<li><a href=\"#R_INFO32\">func R_INFO32(sym, typ uint32) uint32</a></li>\n<li><a href=\"#R_SYM32\">func R_SYM32(info uint32) uint32</a></li>\n<li><a href=\"#R_SYM64\">func R_SYM64(info uint64) uint32</a></li>\n<li><a href=\"#R_TYPE32\">func R_TYPE32(info uint32) uint32</a></li>\n<li><a href=\"#R_TYPE64\">func R_TYPE64(info uint64) uint32</a></li>\n<li><a href=\"#ST_INFO\">func ST_INFO(bind SymBind, typ SymType) uint8</a></li>\n<li><a href=\"#Chdr32\">type Chdr32</a></li>\n<li><a href=\"#Chdr64\">type Chdr64</a></li>\n<li><a href=\"#Class\">type Class</a></li>\n<li> <a href=\"#Class.GoString\">func (i Class) GoString() string</a>\n</li>\n<li> <a href=\"#Class.String\">func (i Class) String() string</a>\n</li>\n<li><a href=\"#CompressionType\">type CompressionType</a></li>\n<li> <a href=\"#CompressionType.GoString\">func (i CompressionType) GoString() string</a>\n</li>\n<li> <a href=\"#CompressionType.String\">func (i CompressionType) String() string</a>\n</li>\n<li><a href=\"#Data\">type Data</a></li>\n<li> <a href=\"#Data.GoString\">func (i Data) GoString() string</a>\n</li>\n<li> <a href=\"#Data.String\">func (i Data) String() string</a>\n</li>\n<li><a href=\"#Dyn32\">type Dyn32</a></li>\n<li><a href=\"#Dyn64\">type Dyn64</a></li>\n<li><a href=\"#DynFlag\">type DynFlag</a></li>\n<li> <a href=\"#DynFlag.GoString\">func (i DynFlag) GoString() string</a>\n</li>\n<li> <a href=\"#DynFlag.String\">func (i DynFlag) String() string</a>\n</li>\n<li><a href=\"#DynTag\">type DynTag</a></li>\n<li> <a href=\"#DynTag.GoString\">func (i DynTag) GoString() string</a>\n</li>\n<li> <a href=\"#DynTag.String\">func (i DynTag) String() string</a>\n</li>\n<li><a href=\"#File\">type File</a></li>\n<li> <a href=\"#NewFile\">func NewFile(r io.ReaderAt) (*File, error)</a>\n</li>\n<li> <a href=\"#Open\">func Open(name string) (*File, error)</a>\n</li>\n<li> <a href=\"#File.Close\">func (f *File) Close() error</a>\n</li>\n<li> <a href=\"#File.DWARF\">func (f *File) DWARF() (*dwarf.Data, error)</a>\n</li>\n<li> <a href=\"#File.DynString\">func (f *File) DynString(tag DynTag) ([]string, error)</a>\n</li>\n<li> <a href=\"#File.DynamicSymbols\">func (f *File) DynamicSymbols() ([]Symbol, error)</a>\n</li>\n<li> <a href=\"#File.ImportedLibraries\">func (f *File) ImportedLibraries() ([]string, error)</a>\n</li>\n<li> <a href=\"#File.ImportedSymbols\">func (f *File) ImportedSymbols() ([]ImportedSymbol, error)</a>\n</li>\n<li> <a href=\"#File.Section\">func (f *File) Section(name string) *Section</a>\n</li>\n<li> <a href=\"#File.SectionByType\">func (f *File) SectionByType(typ SectionType) *Section</a>\n</li>\n<li> <a href=\"#File.Symbols\">func (f *File) Symbols() ([]Symbol, error)</a>\n</li>\n<li><a href=\"#FileHeader\">type FileHeader</a></li>\n<li><a href=\"#FormatError\">type FormatError</a></li>\n<li> <a href=\"#FormatError.Error\">func (e *FormatError) Error() string</a>\n</li>\n<li><a href=\"#Header32\">type Header32</a></li>\n<li><a href=\"#Header64\">type Header64</a></li>\n<li><a href=\"#ImportedSymbol\">type ImportedSymbol</a></li>\n<li><a href=\"#Machine\">type Machine</a></li>\n<li> <a href=\"#Machine.GoString\">func (i Machine) GoString() string</a>\n</li>\n<li> <a href=\"#Machine.String\">func (i Machine) String() string</a>\n</li>\n<li><a href=\"#NType\">type NType</a></li>\n<li> <a href=\"#NType.GoString\">func (i NType) GoString() string</a>\n</li>\n<li> <a href=\"#NType.String\">func (i NType) String() string</a>\n</li>\n<li><a href=\"#OSABI\">type OSABI</a></li>\n<li> <a href=\"#OSABI.GoString\">func (i OSABI) GoString() string</a>\n</li>\n<li> <a href=\"#OSABI.String\">func (i OSABI) String() string</a>\n</li>\n<li><a href=\"#Prog\">type Prog</a></li>\n<li> <a href=\"#Prog.Open\">func (p *Prog) Open() io.ReadSeeker</a>\n</li>\n<li><a href=\"#Prog32\">type Prog32</a></li>\n<li><a href=\"#Prog64\">type Prog64</a></li>\n<li><a href=\"#ProgFlag\">type ProgFlag</a></li>\n<li> <a href=\"#ProgFlag.GoString\">func (i ProgFlag) GoString() string</a>\n</li>\n<li> <a href=\"#ProgFlag.String\">func (i ProgFlag) String() string</a>\n</li>\n<li><a href=\"#ProgHeader\">type ProgHeader</a></li>\n<li><a href=\"#ProgType\">type ProgType</a></li>\n<li> <a href=\"#ProgType.GoString\">func (i ProgType) GoString() string</a>\n</li>\n<li> <a href=\"#ProgType.String\">func (i ProgType) String() string</a>\n</li>\n<li><a href=\"#R_386\">type R_386</a></li>\n<li> <a href=\"#R_386.GoString\">func (i R_386) GoString() string</a>\n</li>\n<li> <a href=\"#R_386.String\">func (i R_386) String() string</a>\n</li>\n<li><a href=\"#R_390\">type R_390</a></li>\n<li> <a href=\"#R_390.GoString\">func (i R_390) GoString() string</a>\n</li>\n<li> <a href=\"#R_390.String\">func (i R_390) String() string</a>\n</li>\n<li><a href=\"#R_AARCH64\">type R_AARCH64</a></li>\n<li> <a href=\"#R_AARCH64.GoString\">func (i R_AARCH64) GoString() string</a>\n</li>\n<li> <a href=\"#R_AARCH64.String\">func (i R_AARCH64) String() string</a>\n</li>\n<li><a href=\"#R_ALPHA\">type R_ALPHA</a></li>\n<li> <a href=\"#R_ALPHA.GoString\">func (i R_ALPHA) GoString() string</a>\n</li>\n<li> <a href=\"#R_ALPHA.String\">func (i R_ALPHA) String() string</a>\n</li>\n<li><a href=\"#R_ARM\">type R_ARM</a></li>\n<li> <a href=\"#R_ARM.GoString\">func (i R_ARM) GoString() string</a>\n</li>\n<li> <a href=\"#R_ARM.String\">func (i R_ARM) String() string</a>\n</li>\n<li><a href=\"#R_MIPS\">type R_MIPS</a></li>\n<li> <a href=\"#R_MIPS.GoString\">func (i R_MIPS) GoString() string</a>\n</li>\n<li> <a href=\"#R_MIPS.String\">func (i R_MIPS) String() string</a>\n</li>\n<li><a href=\"#R_PPC\">type R_PPC</a></li>\n<li> <a href=\"#R_PPC.GoString\">func (i R_PPC) GoString() string</a>\n</li>\n<li> <a href=\"#R_PPC.String\">func (i R_PPC) String() string</a>\n</li>\n<li><a href=\"#R_PPC64\">type R_PPC64</a></li>\n<li> <a href=\"#R_PPC64.GoString\">func (i R_PPC64) GoString() string</a>\n</li>\n<li> <a href=\"#R_PPC64.String\">func (i R_PPC64) String() string</a>\n</li>\n<li><a href=\"#R_SPARC\">type R_SPARC</a></li>\n<li> <a href=\"#R_SPARC.GoString\">func (i R_SPARC) GoString() string</a>\n</li>\n<li> <a href=\"#R_SPARC.String\">func (i R_SPARC) String() string</a>\n</li>\n<li><a href=\"#R_X86_64\">type R_X86_64</a></li>\n<li> <a href=\"#R_X86_64.GoString\">func (i R_X86_64) GoString() string</a>\n</li>\n<li> <a href=\"#R_X86_64.String\">func (i R_X86_64) String() string</a>\n</li>\n<li><a href=\"#Rel32\">type Rel32</a></li>\n<li><a href=\"#Rel64\">type Rel64</a></li>\n<li><a href=\"#Rela32\">type Rela32</a></li>\n<li><a href=\"#Rela64\">type Rela64</a></li>\n<li><a href=\"#Section\">type Section</a></li>\n<li> <a href=\"#Section.Data\">func (s *Section) Data() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Section.Open\">func (s *Section) Open() io.ReadSeeker</a>\n</li>\n<li><a href=\"#Section32\">type Section32</a></li>\n<li><a href=\"#Section64\">type Section64</a></li>\n<li><a href=\"#SectionFlag\">type SectionFlag</a></li>\n<li> <a href=\"#SectionFlag.GoString\">func (i SectionFlag) GoString() string</a>\n</li>\n<li> <a href=\"#SectionFlag.String\">func (i SectionFlag) String() string</a>\n</li>\n<li><a href=\"#SectionHeader\">type SectionHeader</a></li>\n<li><a href=\"#SectionIndex\">type SectionIndex</a></li>\n<li> <a href=\"#SectionIndex.GoString\">func (i SectionIndex) GoString() string</a>\n</li>\n<li> <a href=\"#SectionIndex.String\">func (i SectionIndex) String() string</a>\n</li>\n<li><a href=\"#SectionType\">type SectionType</a></li>\n<li> <a href=\"#SectionType.GoString\">func (i SectionType) GoString() string</a>\n</li>\n<li> <a href=\"#SectionType.String\">func (i SectionType) String() string</a>\n</li>\n<li><a href=\"#Sym32\">type Sym32</a></li>\n<li><a href=\"#Sym64\">type Sym64</a></li>\n<li><a href=\"#SymBind\">type SymBind</a></li>\n<li> <a href=\"#ST_BIND\">func ST_BIND(info uint8) SymBind</a>\n</li>\n<li> <a href=\"#SymBind.GoString\">func (i SymBind) GoString() string</a>\n</li>\n<li> <a href=\"#SymBind.String\">func (i SymBind) String() string</a>\n</li>\n<li><a href=\"#SymType\">type SymType</a></li>\n<li> <a href=\"#ST_TYPE\">func ST_TYPE(info uint8) SymType</a>\n</li>\n<li> <a href=\"#SymType.GoString\">func (i SymType) GoString() string</a>\n</li>\n<li> <a href=\"#SymType.String\">func (i SymType) String() string</a>\n</li>\n<li><a href=\"#SymVis\">type SymVis</a></li>\n<li> <a href=\"#ST_VISIBILITY\">func ST_VISIBILITY(other uint8) SymVis</a>\n</li>\n<li> <a href=\"#SymVis.GoString\">func (i SymVis) GoString() string</a>\n</li>\n<li> <a href=\"#SymVis.String\">func (i SymVis) String() string</a>\n</li>\n<li><a href=\"#Symbol\">type Symbol</a></li>\n<li><a href=\"#Type\">type Type</a></li>\n<li> <a href=\"#Type.GoString\">func (i Type) GoString() string</a>\n</li>\n<li> <a href=\"#Type.String\">func (i Type) String() string</a>\n</li>\n<li><a href=\"#Version\">type Version</a></li>\n<li> <a href=\"#Version.GoString\">func (i Version) GoString() string</a>\n</li>\n<li> <a href=\"#Version.String\">func (i Version) String() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/debug/elf/elf.go\">elf.go</a> <a href=\"https://golang.org/src/debug/elf/file.go\">file.go</a> <a href=\"https://golang.org/src/debug/elf/reader.go\">reader.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        EI_CLASS      = 4  /* Class of machine. */\n        EI_DATA       = 5  /* Data format. */\n        EI_VERSION    = 6  /* ELF format version. */\n        EI_OSABI      = 7  /* Operating system / ABI identification */\n        EI_ABIVERSION = 8  /* ABI version */\n        EI_PAD        = 9  /* Start of padding (per SVR4 ABI). */\n        EI_NIDENT     = 16 /* Size of e_ident array. */\n)</pre> <p> Indexes into the Header.Ident array. </p> <pre data-language=\"go\">const ARM_MAGIC_TRAMP_NUMBER = 0x5c000003</pre> <p> Magic number for the elf trampoline, chosen wisely to be an immediate value. </p> <pre data-language=\"go\">const ELFMAG = \"\\177ELF\"</pre> <p> Initial magic number for ELF files. </p> <pre data-language=\"go\">const Sym32Size = 16</pre> <pre data-language=\"go\">const Sym64Size = 24</pre> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrNoSymbols = errors.New(\"no symbol section\")</pre> <p> ErrNoSymbols is returned by File.Symbols and File.DynamicSymbols if there is no such section in the File. </p> <h2 id=\"R_INFO\">func R_INFO  </h2> <pre data-language=\"go\">func R_INFO(sym, typ uint32) uint64</pre> <h2 id=\"R_INFO32\">func R_INFO32  </h2> <pre data-language=\"go\">func R_INFO32(sym, typ uint32) uint32</pre> <h2 id=\"R_SYM32\">func R_SYM32  </h2> <pre data-language=\"go\">func R_SYM32(info uint32) uint32</pre> <h2 id=\"R_SYM64\">func R_SYM64  </h2> <pre data-language=\"go\">func R_SYM64(info uint64) uint32</pre> <h2 id=\"R_TYPE32\">func R_TYPE32  </h2> <pre data-language=\"go\">func R_TYPE32(info uint32) uint32</pre> <h2 id=\"R_TYPE64\">func R_TYPE64  </h2> <pre data-language=\"go\">func R_TYPE64(info uint64) uint32</pre> <h2 id=\"ST_INFO\">func ST_INFO  </h2> <pre data-language=\"go\">func ST_INFO(bind SymBind, typ SymType) uint8</pre> <h2 id=\"Chdr32\">type Chdr32  </h2> <pre data-language=\"go\">type Chdr32 struct {\n        Type      uint32\n        Size      uint32\n        Addralign uint32\n}</pre> <p> ELF32 Compression header. </p> <h2 id=\"Chdr64\">type Chdr64  </h2> <pre data-language=\"go\">type Chdr64 struct {\n        Type uint32\n\n        Size      uint64\n        Addralign uint64\n        // contains filtered or unexported fields\n}</pre> <p> ELF64 Compression header. </p> <h2 id=\"Class\">type Class  </h2> <pre data-language=\"go\">type Class byte</pre> <p> Class is found in Header.Ident[EI_CLASS] and Header.Class. </p> <pre data-language=\"go\">const (\n        ELFCLASSNONE Class = 0 /* Unknown class. */\n        ELFCLASS32   Class = 1 /* 32-bit architecture. */\n        ELFCLASS64   Class = 2 /* 64-bit architecture. */\n)</pre> <h3 id=\"Class.GoString\">func (Class) <a href=\"https://golang.org/src/debug/elf/elf.go?s=3639:3671#L86\">GoString</a>  </h3> <pre data-language=\"go\">func (i Class) GoString() string</pre> <h3 id=\"Class.String\">func (Class) <a href=\"https://golang.org/src/debug/elf/elf.go?s=3552:3582#L85\">String</a>  </h3> <pre data-language=\"go\">func (i Class) String() string</pre> <h2 id=\"CompressionType\">type CompressionType  </h2> <pre data-language=\"go\">type CompressionType int</pre> <p> Section compression type. </p> <pre data-language=\"go\">const (\n        COMPRESS_ZLIB   CompressionType = 1          /* ZLIB compression. */\n        COMPRESS_LOOS   CompressionType = 0x60000000 /* First OS-specific. */\n        COMPRESS_HIOS   CompressionType = 0x6fffffff /* Last OS-specific. */\n        COMPRESS_LOPROC CompressionType = 0x70000000 /* First processor-specific type. */\n        COMPRESS_HIPROC CompressionType = 0x7fffffff /* Last processor-specific type. */\n)</pre> <h3 id=\"CompressionType.GoString\">func (CompressionType) <a href=\"https://golang.org/src/debug/elf/elf.go?s=17239:17281#L446\">GoString</a>  </h3> <pre data-language=\"go\">func (i CompressionType) GoString() string</pre> <h3 id=\"CompressionType.String\">func (CompressionType) <a href=\"https://golang.org/src/debug/elf/elf.go?s=17136:17176#L445\">String</a>  </h3> <pre data-language=\"go\">func (i CompressionType) String() string</pre> <h2 id=\"Data\">type Data  </h2> <pre data-language=\"go\">type Data byte</pre> <p> Data is found in Header.Ident[EI_DATA] and Header.Data. </p> <pre data-language=\"go\">const (\n        ELFDATANONE Data = 0 /* Unknown data format. */\n        ELFDATA2LSB Data = 1 /* 2's complement little-endian. */\n        ELFDATA2MSB Data = 2 /* 2's complement big-endian. */\n)</pre> <h3 id=\"Data.GoString\">func (Data) <a href=\"https://golang.org/src/debug/elf/elf.go?s=4154:4185#L104\">GoString</a>  </h3> <pre data-language=\"go\">func (i Data) GoString() string</pre> <h3 id=\"Data.String\">func (Data) <a href=\"https://golang.org/src/debug/elf/elf.go?s=4069:4098#L103\">String</a>  </h3> <pre data-language=\"go\">func (i Data) String() string</pre> <h2 id=\"Dyn32\">type Dyn32  </h2> <pre data-language=\"go\">type Dyn32 struct {\n        Tag int32  /* Entry type. */\n        Val uint32 /* Integer/Address value. */\n}</pre> <p> ELF32 Dynamic structure. The \".dynamic\" section contains an array of them. </p> <h2 id=\"Dyn64\">type Dyn64  </h2> <pre data-language=\"go\">type Dyn64 struct {\n        Tag int64  /* Entry type. */\n        Val uint64 /* Integer/address value */\n}</pre> <p> ELF64 Dynamic structure. The \".dynamic\" section contains an array of them. </p> <h2 id=\"DynFlag\">type DynFlag  </h2> <pre data-language=\"go\">type DynFlag int</pre> <p> DT_FLAGS values. </p> <pre data-language=\"go\">const (\n        DF_ORIGIN DynFlag = 0x0001 /* Indicates that the object being loaded may\n           make reference to the\n           $ORIGIN substitution string */\n        DF_SYMBOLIC DynFlag = 0x0002 /* Indicates \"symbolic\" linking. */\n        DF_TEXTREL  DynFlag = 0x0004 /* Indicates there may be relocations in non-writable segments. */\n        DF_BIND_NOW DynFlag = 0x0008 /* Indicates that the dynamic linker should\n           process all relocations for the object\n           containing this entry before transferring\n           control to the program. */\n        DF_STATIC_TLS DynFlag = 0x0010 /* Indicates that the shared object or\n           executable contains code using a static\n           thread-local storage scheme. */\n)</pre> <h3 id=\"DynFlag.GoString\">func (DynFlag) <a href=\"https://golang.org/src/debug/elf/elf.go?s=24368:24402#L629\">GoString</a>  </h3> <pre data-language=\"go\">func (i DynFlag) GoString() string</pre> <h3 id=\"DynFlag.String\">func (DynFlag) <a href=\"https://golang.org/src/debug/elf/elf.go?s=24281:24313#L628\">String</a>  </h3> <pre data-language=\"go\">func (i DynFlag) String() string</pre> <h2 id=\"DynTag\">type DynTag  </h2> <pre data-language=\"go\">type DynTag int</pre> <p> Dyn.Tag </p> <pre data-language=\"go\">const (\n        DT_NULL         DynTag = 0  /* Terminating entry. */\n        DT_NEEDED       DynTag = 1  /* String table offset of a needed shared library. */\n        DT_PLTRELSZ     DynTag = 2  /* Total size in bytes of PLT relocations. */\n        DT_PLTGOT       DynTag = 3  /* Processor-dependent address. */\n        DT_HASH         DynTag = 4  /* Address of symbol hash table. */\n        DT_STRTAB       DynTag = 5  /* Address of string table. */\n        DT_SYMTAB       DynTag = 6  /* Address of symbol table. */\n        DT_RELA         DynTag = 7  /* Address of ElfNN_Rela relocations. */\n        DT_RELASZ       DynTag = 8  /* Total size of ElfNN_Rela relocations. */\n        DT_RELAENT      DynTag = 9  /* Size of each ElfNN_Rela relocation entry. */\n        DT_STRSZ        DynTag = 10 /* Size of string table. */\n        DT_SYMENT       DynTag = 11 /* Size of each symbol table entry. */\n        DT_INIT         DynTag = 12 /* Address of initialization function. */\n        DT_FINI         DynTag = 13 /* Address of finalization function. */\n        DT_SONAME       DynTag = 14 /* String table offset of shared object name. */\n        DT_RPATH        DynTag = 15 /* String table offset of library path. [sup] */\n        DT_SYMBOLIC     DynTag = 16 /* Indicates \"symbolic\" linking. [sup] */\n        DT_REL          DynTag = 17 /* Address of ElfNN_Rel relocations. */\n        DT_RELSZ        DynTag = 18 /* Total size of ElfNN_Rel relocations. */\n        DT_RELENT       DynTag = 19 /* Size of each ElfNN_Rel relocation. */\n        DT_PLTREL       DynTag = 20 /* Type of relocation used for PLT. */\n        DT_DEBUG        DynTag = 21 /* Reserved (not used). */\n        DT_TEXTREL      DynTag = 22 /* Indicates there may be relocations in non-writable segments. [sup] */\n        DT_JMPREL       DynTag = 23 /* Address of PLT relocations. */\n        DT_BIND_NOW     DynTag = 24 /* [sup] */\n        DT_INIT_ARRAY   DynTag = 25 /* Address of the array of pointers to initialization functions */\n        DT_FINI_ARRAY   DynTag = 26 /* Address of the array of pointers to termination functions */\n        DT_INIT_ARRAYSZ DynTag = 27 /* Size in bytes of the array of initialization functions. */\n        DT_FINI_ARRAYSZ DynTag = 28 /* Size in bytes of the array of termination functions. */\n        DT_RUNPATH      DynTag = 29 /* String table offset of a null-terminated library search path string. */\n        DT_FLAGS        DynTag = 30 /* Object specific flag values. */\n        DT_ENCODING     DynTag = 32 /* Values greater than or equal to DT_ENCODING\n           and less than DT_LOOS follow the rules for\n           the interpretation of the d_un union\n           as follows: even == 'd_ptr', even == 'd_val'\n           or none */\n        DT_PREINIT_ARRAY   DynTag = 32         /* Address of the array of pointers to pre-initialization functions. */\n        DT_PREINIT_ARRAYSZ DynTag = 33         /* Size in bytes of the array of pre-initialization functions. */\n        DT_LOOS            DynTag = 0x6000000d /* First OS-specific */\n        DT_HIOS            DynTag = 0x6ffff000 /* Last OS-specific */\n        DT_VERSYM          DynTag = 0x6ffffff0\n        DT_VERNEED         DynTag = 0x6ffffffe\n        DT_VERNEEDNUM      DynTag = 0x6fffffff\n        DT_LOPROC          DynTag = 0x70000000 /* First processor-specific type. */\n        DT_HIPROC          DynTag = 0x7fffffff /* Last processor-specific type. */\n)</pre> <h3 id=\"DynTag.GoString\">func (DynTag) <a href=\"https://golang.org/src/debug/elf/elf.go?s=23342:23375#L600\">GoString</a>  </h3> <pre data-language=\"go\">func (i DynTag) GoString() string</pre> <h3 id=\"DynTag.String\">func (DynTag) <a href=\"https://golang.org/src/debug/elf/elf.go?s=23257:23288#L599\">String</a>  </h3> <pre data-language=\"go\">func (i DynTag) String() string</pre> <h2 id=\"File\">type File  </h2> <pre data-language=\"go\">type File struct {\n        FileHeader\n        Sections []*Section\n        Progs    []*Prog\n        // contains filtered or unexported fields\n}</pre> <p> A File represents an open ELF file. </p> <h3 id=\"NewFile\">func <a href=\"https://golang.org/src/debug/elf/file.go?s=5309:5351#L214\">NewFile</a>  </h3> <pre data-language=\"go\">func NewFile(r io.ReaderAt) (*File, error)</pre> <p> NewFile creates a new File for accessing an ELF binary in an underlying reader. The ELF binary is expected to start at position 0 in the ReaderAt. </p> <h3 id=\"Open\">func <a href=\"https://golang.org/src/debug/elf/file.go?s=4449:4486#L175\">Open</a>  </h3> <pre data-language=\"go\">func Open(name string) (*File, error)</pre> <p> Open opens the named file using os.Open and prepares it for use as an ELF binary. </p> <h3 id=\"File.Close\">func (*File) <a href=\"https://golang.org/src/debug/elf/file.go?s=4776:4804#L192\">Close</a>  </h3> <pre data-language=\"go\">func (f *File) Close() error</pre> <p> Close closes the File. If the File was created using NewFile directly instead of Open, Close has no effect. </p> <h3 id=\"File.DWARF\">func (*File) <a href=\"https://golang.org/src/debug/elf/file.go?s=23495:23538#L955\">DWARF</a>  </h3> <pre data-language=\"go\">func (f *File) DWARF() (*dwarf.Data, error)</pre> <h3 id=\"File.DynString\">func (*File) <a href=\"https://golang.org/src/debug/elf/file.go?s=29364:29418#L1197\">DynString</a>  </h3> <pre data-language=\"go\">func (f *File) DynString(tag DynTag) ([]string, error)</pre> <p> DynString returns the strings listed for the given tag in the file's dynamic section. </p> <p> The tag must be one that takes string values: DT_NEEDED, DT_SONAME, DT_RPATH, or DT_RUNPATH. </p> <h3 id=\"File.DynamicSymbols\">func (*File) <a href=\"https://golang.org/src/debug/elf/file.go?s=26244:26293#L1063\">DynamicSymbols</a>  </h3> <pre data-language=\"go\">func (f *File) DynamicSymbols() ([]Symbol, error)</pre> <p> DynamicSymbols returns the dynamic symbol table for f. The symbols will be listed in the order they appear in f. </p> <p> For compatibility with Symbols, DynamicSymbols omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x]. </p> <h3 id=\"File.ImportedLibraries\">func (*File) <a href=\"https://golang.org/src/debug/elf/file.go?s=29081:29133#L1188\">ImportedLibraries</a>  </h3> <pre data-language=\"go\">func (f *File) ImportedLibraries() ([]string, error)</pre> <p> ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time. </p> <h3 id=\"File.ImportedSymbols\">func (*File) <a href=\"https://golang.org/src/debug/elf/file.go?s=26634:26692#L1078\">ImportedSymbols</a>  </h3> <pre data-language=\"go\">func (f *File) ImportedSymbols() ([]ImportedSymbol, error)</pre> <p> ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols. </p> <h3 id=\"File.Section\">func (*File) <a href=\"https://golang.org/src/debug/elf/file.go?s=14289:14333#L562\">Section</a>  </h3> <pre data-language=\"go\">func (f *File) Section(name string) *Section</pre> <p> Section returns a section with the given name, or nil if no such section exists. </p> <h3 id=\"File.SectionByType\">func (*File) <a href=\"https://golang.org/src/debug/elf/file.go?s=5012:5066#L203\">SectionByType</a>  </h3> <pre data-language=\"go\">func (f *File) SectionByType(typ SectionType) *Section</pre> <p> SectionByType returns the first section in f with the given type, or nil if there is no such section. </p> <h3 id=\"File.Symbols\">func (*File) <a href=\"https://golang.org/src/debug/elf/file.go?s=25812:25854#L1052\">Symbols</a>  </h3> <pre data-language=\"go\">func (f *File) Symbols() ([]Symbol, error)</pre> <p> Symbols returns the symbol table for f. The symbols will be listed in the order they appear in f. </p> <p> For compatibility with Go 1.0, Symbols omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x]. </p> <h2 id=\"FileHeader\">type FileHeader  </h2> <pre data-language=\"go\">type FileHeader struct {\n        Class      Class\n        Data       Data\n        Version    Version\n        OSABI      OSABI\n        ABIVersion uint8\n        ByteOrder  binary.ByteOrder\n        Type       Type\n        Machine    Machine\n        Entry      uint64\n}</pre> <p> A FileHeader represents an ELF file header. </p> <h2 id=\"FormatError\">type FormatError  </h2> <pre data-language=\"go\">type FormatError struct {\n        // contains filtered or unexported fields\n}</pre> <h3 id=\"FormatError.Error\">func (*FormatError) <a href=\"https://golang.org/src/debug/elf/file.go?s=4184:4220#L165\">Error</a>  </h3> <pre data-language=\"go\">func (e *FormatError) Error() string</pre> <h2 id=\"Header32\">type Header32  </h2> <pre data-language=\"go\">type Header32 struct {\n        Ident     [EI_NIDENT]byte /* File identification. */\n        Type      uint16          /* File type. */\n        Machine   uint16          /* Machine architecture. */\n        Version   uint32          /* ELF format version. */\n        Entry     uint32          /* Entry point. */\n        Phoff     uint32          /* Program header file offset. */\n        Shoff     uint32          /* Section header file offset. */\n        Flags     uint32          /* Architecture-specific flags. */\n        Ehsize    uint16          /* Size of ELF header in bytes. */\n        Phentsize uint16          /* Size of program header entry. */\n        Phnum     uint16          /* Number of program header entries. */\n        Shentsize uint16          /* Size of section header entry. */\n        Shnum     uint16          /* Number of section header entries. */\n        Shstrndx  uint16          /* Section name strings section. */\n}</pre> <p> ELF32 File header. </p> <h2 id=\"Header64\">type Header64  </h2> <pre data-language=\"go\">type Header64 struct {\n        Ident     [EI_NIDENT]byte /* File identification. */\n        Type      uint16          /* File type. */\n        Machine   uint16          /* Machine architecture. */\n        Version   uint32          /* ELF format version. */\n        Entry     uint64          /* Entry point. */\n        Phoff     uint64          /* Program header file offset. */\n        Shoff     uint64          /* Section header file offset. */\n        Flags     uint32          /* Architecture-specific flags. */\n        Ehsize    uint16          /* Size of ELF header in bytes. */\n        Phentsize uint16          /* Size of program header entry. */\n        Phnum     uint16          /* Number of program header entries. */\n        Shentsize uint16          /* Size of section header entry. */\n        Shnum     uint16          /* Number of section header entries. */\n        Shstrndx  uint16          /* Section name strings section. */\n}</pre> <p> ELF64 file header. </p> <h2 id=\"ImportedSymbol\">type ImportedSymbol  </h2> <pre data-language=\"go\">type ImportedSymbol struct {\n        Name    string\n        Version string\n        Library string\n}</pre> <h2 id=\"Machine\">type Machine  </h2> <pre data-language=\"go\">type Machine uint16</pre> <p> Machine is found in Header.Machine. </p> <pre data-language=\"go\">const (\n        EM_NONE        Machine = 0   /* Unknown machine. */\n        EM_M32         Machine = 1   /* AT&amp;T WE32100. */\n        EM_SPARC       Machine = 2   /* Sun SPARC. */\n        EM_386         Machine = 3   /* Intel i386. */\n        EM_68K         Machine = 4   /* Motorola 68000. */\n        EM_88K         Machine = 5   /* Motorola 88000. */\n        EM_860         Machine = 7   /* Intel i860. */\n        EM_MIPS        Machine = 8   /* MIPS R3000 Big-Endian only. */\n        EM_S370        Machine = 9   /* IBM System/370. */\n        EM_MIPS_RS3_LE Machine = 10  /* MIPS R3000 Little-Endian. */\n        EM_PARISC      Machine = 15  /* HP PA-RISC. */\n        EM_VPP500      Machine = 17  /* Fujitsu VPP500. */\n        EM_SPARC32PLUS Machine = 18  /* SPARC v8plus. */\n        EM_960         Machine = 19  /* Intel 80960. */\n        EM_PPC         Machine = 20  /* PowerPC 32-bit. */\n        EM_PPC64       Machine = 21  /* PowerPC 64-bit. */\n        EM_S390        Machine = 22  /* IBM System/390. */\n        EM_V800        Machine = 36  /* NEC V800. */\n        EM_FR20        Machine = 37  /* Fujitsu FR20. */\n        EM_RH32        Machine = 38  /* TRW RH-32. */\n        EM_RCE         Machine = 39  /* Motorola RCE. */\n        EM_ARM         Machine = 40  /* ARM. */\n        EM_SH          Machine = 42  /* Hitachi SH. */\n        EM_SPARCV9     Machine = 43  /* SPARC v9 64-bit. */\n        EM_TRICORE     Machine = 44  /* Siemens TriCore embedded processor. */\n        EM_ARC         Machine = 45  /* Argonaut RISC Core. */\n        EM_H8_300      Machine = 46  /* Hitachi H8/300. */\n        EM_H8_300H     Machine = 47  /* Hitachi H8/300H. */\n        EM_H8S         Machine = 48  /* Hitachi H8S. */\n        EM_H8_500      Machine = 49  /* Hitachi H8/500. */\n        EM_IA_64       Machine = 50  /* Intel IA-64 Processor. */\n        EM_MIPS_X      Machine = 51  /* Stanford MIPS-X. */\n        EM_COLDFIRE    Machine = 52  /* Motorola ColdFire. */\n        EM_68HC12      Machine = 53  /* Motorola M68HC12. */\n        EM_MMA         Machine = 54  /* Fujitsu MMA. */\n        EM_PCP         Machine = 55  /* Siemens PCP. */\n        EM_NCPU        Machine = 56  /* Sony nCPU. */\n        EM_NDR1        Machine = 57  /* Denso NDR1 microprocessor. */\n        EM_STARCORE    Machine = 58  /* Motorola Star*Core processor. */\n        EM_ME16        Machine = 59  /* Toyota ME16 processor. */\n        EM_ST100       Machine = 60  /* STMicroelectronics ST100 processor. */\n        EM_TINYJ       Machine = 61  /* Advanced Logic Corp. TinyJ processor. */\n        EM_X86_64      Machine = 62  /* Advanced Micro Devices x86-64 */\n        EM_AARCH64     Machine = 183 /* ARM 64-bit Architecture (AArch64) */\n\n        /* Non-standard or deprecated. */\n        EM_486         Machine = 6      /* Intel i486. */\n        EM_MIPS_RS4_BE Machine = 10     /* MIPS R4000 Big-Endian */\n        EM_ALPHA_STD   Machine = 41     /* Digital Alpha (standard value). */\n        EM_ALPHA       Machine = 0x9026 /* Alpha (written in the absence of an ABI) */\n)</pre> <h3 id=\"Machine.GoString\">func (Machine) <a href=\"https://golang.org/src/debug/elf/elf.go?s=10543:10577#L291\">GoString</a>  </h3> <pre data-language=\"go\">func (i Machine) GoString() string</pre> <h3 id=\"Machine.String\">func (Machine) <a href=\"https://golang.org/src/debug/elf/elf.go?s=10452:10484#L290\">String</a>  </h3> <pre data-language=\"go\">func (i Machine) String() string</pre> <h2 id=\"NType\">type NType  </h2> <pre data-language=\"go\">type NType int</pre> <p> NType values; used in core files. </p> <pre data-language=\"go\">const (\n        NT_PRSTATUS NType = 1 /* Process status. */\n        NT_FPREGSET NType = 2 /* Floating point registers. */\n        NT_PRPSINFO NType = 3 /* Process state info. */\n)</pre> <h3 id=\"NType.GoString\">func (NType) <a href=\"https://golang.org/src/debug/elf/elf.go?s=24851:24883#L647\">GoString</a>  </h3> <pre data-language=\"go\">func (i NType) GoString() string</pre> <h3 id=\"NType.String\">func (NType) <a href=\"https://golang.org/src/debug/elf/elf.go?s=24764:24794#L646\">String</a>  </h3> <pre data-language=\"go\">func (i NType) String() string</pre> <h2 id=\"OSABI\">type OSABI  </h2> <pre data-language=\"go\">type OSABI byte</pre> <p> OSABI is found in Header.Ident[EI_OSABI] and Header.OSABI. </p> <pre data-language=\"go\">const (\n        ELFOSABI_NONE       OSABI = 0   /* UNIX System V ABI */\n        ELFOSABI_HPUX       OSABI = 1   /* HP-UX operating system */\n        ELFOSABI_NETBSD     OSABI = 2   /* NetBSD */\n        ELFOSABI_LINUX      OSABI = 3   /* GNU/Linux */\n        ELFOSABI_HURD       OSABI = 4   /* GNU/Hurd */\n        ELFOSABI_86OPEN     OSABI = 5   /* 86Open common IA32 ABI */\n        ELFOSABI_SOLARIS    OSABI = 6   /* Solaris */\n        ELFOSABI_AIX        OSABI = 7   /* AIX */\n        ELFOSABI_IRIX       OSABI = 8   /* IRIX */\n        ELFOSABI_FREEBSD    OSABI = 9   /* FreeBSD */\n        ELFOSABI_TRU64      OSABI = 10  /* TRU64 UNIX */\n        ELFOSABI_MODESTO    OSABI = 11  /* Novell Modesto */\n        ELFOSABI_OPENBSD    OSABI = 12  /* OpenBSD */\n        ELFOSABI_OPENVMS    OSABI = 13  /* Open VMS */\n        ELFOSABI_NSK        OSABI = 14  /* HP Non-Stop Kernel */\n        ELFOSABI_ARM        OSABI = 97  /* ARM */\n        ELFOSABI_STANDALONE OSABI = 255 /* Standalone (embedded) application */\n)</pre> <h3 id=\"OSABI.GoString\">func (OSABI) <a href=\"https://golang.org/src/debug/elf/elf.go?s=5750:5782#L150\">GoString</a>  </h3> <pre data-language=\"go\">func (i OSABI) GoString() string</pre> <h3 id=\"OSABI.String\">func (OSABI) <a href=\"https://golang.org/src/debug/elf/elf.go?s=5663:5693#L149\">String</a>  </h3> <pre data-language=\"go\">func (i OSABI) String() string</pre> <h2 id=\"Prog\">type Prog  </h2> <pre data-language=\"go\">type Prog struct {\n        ProgHeader\n\n        // Embed ReaderAt for ReadAt method.\n        // Do not embed SectionReader directly\n        // to avoid having Read and Seek.\n        // If a client wants Read and Seek it must use\n        // Open() to avoid fighting over the seek offset\n        // with other clients.\n        io.ReaderAt\n        // contains filtered or unexported fields\n}</pre> <p> A Prog represents a single ELF program header in an ELF binary. </p> <h3 id=\"Prog.Open\">func (*Prog) <a href=\"https://golang.org/src/debug/elf/file.go?s=3835:3870#L145\">Open</a>  </h3> <pre data-language=\"go\">func (p *Prog) Open() io.ReadSeeker</pre> <p> Open returns a new ReadSeeker reading the ELF program body. </p> <h2 id=\"Prog32\">type Prog32  </h2> <pre data-language=\"go\">type Prog32 struct {\n        Type   uint32 /* Entry type. */\n        Off    uint32 /* File offset of contents. */\n        Vaddr  uint32 /* Virtual address in memory image. */\n        Paddr  uint32 /* Physical address (not used). */\n        Filesz uint32 /* Size of contents in file. */\n        Memsz  uint32 /* Size of contents in memory. */\n        Flags  uint32 /* Access permission flags. */\n        Align  uint32 /* Alignment in memory and file. */\n}</pre> <p> ELF32 Program header. </p> <h2 id=\"Prog64\">type Prog64  </h2> <pre data-language=\"go\">type Prog64 struct {\n        Type   uint32 /* Entry type. */\n        Flags  uint32 /* Access permission flags. */\n        Off    uint64 /* File offset of contents. */\n        Vaddr  uint64 /* Virtual address in memory image. */\n        Paddr  uint64 /* Physical address (not used). */\n        Filesz uint64 /* Size of contents in file. */\n        Memsz  uint64 /* Size of contents in memory. */\n        Align  uint64 /* Alignment in memory and file. */\n}</pre> <p> ELF64 Program header. </p> <h2 id=\"ProgFlag\">type ProgFlag  </h2> <pre data-language=\"go\">type ProgFlag uint32</pre> <p> Prog.Flag </p> <pre data-language=\"go\">const (\n        PF_X        ProgFlag = 0x1        /* Executable. */\n        PF_W        ProgFlag = 0x2        /* Writable. */\n        PF_R        ProgFlag = 0x4        /* Readable. */\n        PF_MASKOS   ProgFlag = 0x0ff00000 /* Operating system-specific. */\n        PF_MASKPROC ProgFlag = 0xf0000000 /* Processor-specific. */\n)</pre> <h3 id=\"ProgFlag.GoString\">func (ProgFlag) <a href=\"https://golang.org/src/debug/elf/elf.go?s=19111:19146#L502\">GoString</a>  </h3> <pre data-language=\"go\">func (i ProgFlag) GoString() string</pre> <h3 id=\"ProgFlag.String\">func (ProgFlag) <a href=\"https://golang.org/src/debug/elf/elf.go?s=19026:19059#L501\">String</a>  </h3> <pre data-language=\"go\">func (i ProgFlag) String() string</pre> <h2 id=\"ProgHeader\">type ProgHeader  </h2> <pre data-language=\"go\">type ProgHeader struct {\n        Type   ProgType\n        Flags  ProgFlag\n        Off    uint64\n        Vaddr  uint64\n        Paddr  uint64\n        Filesz uint64\n        Memsz  uint64\n        Align  uint64\n}</pre> <p> A ProgHeader represents a single ELF program header. </p> <h2 id=\"ProgType\">type ProgType  </h2> <pre data-language=\"go\">type ProgType int</pre> <p> Prog.Type </p> <pre data-language=\"go\">const (\n        PT_NULL    ProgType = 0          /* Unused entry. */\n        PT_LOAD    ProgType = 1          /* Loadable segment. */\n        PT_DYNAMIC ProgType = 2          /* Dynamic linking information segment. */\n        PT_INTERP  ProgType = 3          /* Pathname of interpreter. */\n        PT_NOTE    ProgType = 4          /* Auxiliary information. */\n        PT_SHLIB   ProgType = 5          /* Reserved (not used). */\n        PT_PHDR    ProgType = 6          /* Location of program header itself. */\n        PT_TLS     ProgType = 7          /* Thread local storage segment */\n        PT_LOOS    ProgType = 0x60000000 /* First OS-specific. */\n        PT_HIOS    ProgType = 0x6fffffff /* Last OS-specific. */\n        PT_LOPROC  ProgType = 0x70000000 /* First processor-specific type. */\n        PT_HIPROC  ProgType = 0x7fffffff /* Last processor-specific type. */\n)</pre> <h3 id=\"ProgType.GoString\">func (ProgType) <a href=\"https://golang.org/src/debug/elf/elf.go?s=18531:18566#L482\">GoString</a>  </h3> <pre data-language=\"go\">func (i ProgType) GoString() string</pre> <h3 id=\"ProgType.String\">func (ProgType) <a href=\"https://golang.org/src/debug/elf/elf.go?s=18444:18477#L481\">String</a>  </h3> <pre data-language=\"go\">func (i ProgType) String() string</pre> <h2 id=\"R_386\">type R_386  </h2> <pre data-language=\"go\">type R_386 int</pre> <p> Relocation types for 386. </p> <pre data-language=\"go\">const (\n        R_386_NONE         R_386 = 0  /* No relocation. */\n        R_386_32           R_386 = 1  /* Add symbol value. */\n        R_386_PC32         R_386 = 2  /* Add PC-relative symbol value. */\n        R_386_GOT32        R_386 = 3  /* Add PC-relative GOT offset. */\n        R_386_PLT32        R_386 = 4  /* Add PC-relative PLT offset. */\n        R_386_COPY         R_386 = 5  /* Copy data from shared object. */\n        R_386_GLOB_DAT     R_386 = 6  /* Set GOT entry to data address. */\n        R_386_JMP_SLOT     R_386 = 7  /* Set GOT entry to code address. */\n        R_386_RELATIVE     R_386 = 8  /* Add load address of shared object. */\n        R_386_GOTOFF       R_386 = 9  /* Add GOT-relative symbol address. */\n        R_386_GOTPC        R_386 = 10 /* Add PC-relative GOT table address. */\n        R_386_TLS_TPOFF    R_386 = 14 /* Negative offset in static TLS block */\n        R_386_TLS_IE       R_386 = 15 /* Absolute address of GOT for -ve static TLS */\n        R_386_TLS_GOTIE    R_386 = 16 /* GOT entry for negative static TLS block */\n        R_386_TLS_LE       R_386 = 17 /* Negative offset relative to static TLS */\n        R_386_TLS_GD       R_386 = 18 /* 32 bit offset to GOT (index,off) pair */\n        R_386_TLS_LDM      R_386 = 19 /* 32 bit offset to GOT (index,zero) pair */\n        R_386_TLS_GD_32    R_386 = 24 /* 32 bit offset to GOT (index,off) pair */\n        R_386_TLS_GD_PUSH  R_386 = 25 /* pushl instruction for Sun ABI GD sequence */\n        R_386_TLS_GD_CALL  R_386 = 26 /* call instruction for Sun ABI GD sequence */\n        R_386_TLS_GD_POP   R_386 = 27 /* popl instruction for Sun ABI GD sequence */\n        R_386_TLS_LDM_32   R_386 = 28 /* 32 bit offset to GOT (index,zero) pair */\n        R_386_TLS_LDM_PUSH R_386 = 29 /* pushl instruction for Sun ABI LD sequence */\n        R_386_TLS_LDM_CALL R_386 = 30 /* call instruction for Sun ABI LD sequence */\n        R_386_TLS_LDM_POP  R_386 = 31 /* popl instruction for Sun ABI LD sequence */\n        R_386_TLS_LDO_32   R_386 = 32 /* 32 bit offset from start of TLS block */\n        R_386_TLS_IE_32    R_386 = 33 /* 32 bit offset to GOT static TLS offset entry */\n        R_386_TLS_LE_32    R_386 = 34 /* 32 bit offset within static TLS block */\n        R_386_TLS_DTPMOD32 R_386 = 35 /* GOT entry containing TLS index */\n        R_386_TLS_DTPOFF32 R_386 = 36 /* GOT entry containing TLS offset */\n        R_386_TLS_TPOFF32  R_386 = 37 /* GOT entry of -ve static TLS offset */\n)</pre> <h3 id=\"R_386.GoString\">func (R_386) <a href=\"https://golang.org/src/debug/elf/elf.go?s=49975:50007#L1261\">GoString</a>  </h3> <pre data-language=\"go\">func (i R_386) GoString() string</pre> <h3 id=\"R_386.String\">func (R_386) <a href=\"https://golang.org/src/debug/elf/elf.go?s=49889:49919#L1260\">String</a>  </h3> <pre data-language=\"go\">func (i R_386) String() string</pre> <h2 id=\"R_390\">type R_390  </h2> <pre data-language=\"go\">type R_390 int</pre> <p> Relocation types for s390x processors. </p> <pre data-language=\"go\">const (\n        R_390_NONE        R_390 = 0\n        R_390_8           R_390 = 1\n        R_390_12          R_390 = 2\n        R_390_16          R_390 = 3\n        R_390_32          R_390 = 4\n        R_390_PC32        R_390 = 5\n        R_390_GOT12       R_390 = 6\n        R_390_GOT32       R_390 = 7\n        R_390_PLT32       R_390 = 8\n        R_390_COPY        R_390 = 9\n        R_390_GLOB_DAT    R_390 = 10\n        R_390_JMP_SLOT    R_390 = 11\n        R_390_RELATIVE    R_390 = 12\n        R_390_GOTOFF      R_390 = 13\n        R_390_GOTPC       R_390 = 14\n        R_390_GOT16       R_390 = 15\n        R_390_PC16        R_390 = 16\n        R_390_PC16DBL     R_390 = 17\n        R_390_PLT16DBL    R_390 = 18\n        R_390_PC32DBL     R_390 = 19\n        R_390_PLT32DBL    R_390 = 20\n        R_390_GOTPCDBL    R_390 = 21\n        R_390_64          R_390 = 22\n        R_390_PC64        R_390 = 23\n        R_390_GOT64       R_390 = 24\n        R_390_PLT64       R_390 = 25\n        R_390_GOTENT      R_390 = 26\n        R_390_GOTOFF16    R_390 = 27\n        R_390_GOTOFF64    R_390 = 28\n        R_390_GOTPLT12    R_390 = 29\n        R_390_GOTPLT16    R_390 = 30\n        R_390_GOTPLT32    R_390 = 31\n        R_390_GOTPLT64    R_390 = 32\n        R_390_GOTPLTENT   R_390 = 33\n        R_390_GOTPLTOFF16 R_390 = 34\n        R_390_GOTPLTOFF32 R_390 = 35\n        R_390_GOTPLTOFF64 R_390 = 36\n        R_390_TLS_LOAD    R_390 = 37\n        R_390_TLS_GDCALL  R_390 = 38\n        R_390_TLS_LDCALL  R_390 = 39\n        R_390_TLS_GD32    R_390 = 40\n        R_390_TLS_GD64    R_390 = 41\n        R_390_TLS_GOTIE12 R_390 = 42\n        R_390_TLS_GOTIE32 R_390 = 43\n        R_390_TLS_GOTIE64 R_390 = 44\n        R_390_TLS_LDM32   R_390 = 45\n        R_390_TLS_LDM64   R_390 = 46\n        R_390_TLS_IE32    R_390 = 47\n        R_390_TLS_IE64    R_390 = 48\n        R_390_TLS_IEENT   R_390 = 49\n        R_390_TLS_LE32    R_390 = 50\n        R_390_TLS_LE64    R_390 = 51\n        R_390_TLS_LDO32   R_390 = 52\n        R_390_TLS_LDO64   R_390 = 53\n        R_390_TLS_DTPMOD  R_390 = 54\n        R_390_TLS_DTPOFF  R_390 = 55\n        R_390_TLS_TPOFF   R_390 = 56\n        R_390_20          R_390 = 57\n        R_390_GOT20       R_390 = 58\n        R_390_GOTPLT20    R_390 = 59\n        R_390_TLS_GOTIE20 R_390 = 60\n)</pre> <h3 id=\"R_390.GoString\">func (R_390) <a href=\"https://golang.org/src/debug/elf/elf.go?s=68503:68535#L1850\">GoString</a>  </h3> <pre data-language=\"go\">func (i R_390) GoString() string</pre> <h3 id=\"R_390.String\">func (R_390) <a href=\"https://golang.org/src/debug/elf/elf.go?s=68417:68447#L1849\">String</a>  </h3> <pre data-language=\"go\">func (i R_390) String() string</pre> <h2 id=\"R_AARCH64\">type R_AARCH64  </h2> <pre data-language=\"go\">type R_AARCH64 int</pre> <p> Relocation types for AArch64 (aka arm64) </p> <pre data-language=\"go\">const (\n        R_AARCH64_NONE                            R_AARCH64 = 0\n        R_AARCH64_P32_ABS32                       R_AARCH64 = 1\n        R_AARCH64_P32_ABS16                       R_AARCH64 = 2\n        R_AARCH64_P32_PREL32                      R_AARCH64 = 3\n        R_AARCH64_P32_PREL16                      R_AARCH64 = 4\n        R_AARCH64_P32_MOVW_UABS_G0                R_AARCH64 = 5\n        R_AARCH64_P32_MOVW_UABS_G0_NC             R_AARCH64 = 6\n        R_AARCH64_P32_MOVW_UABS_G1                R_AARCH64 = 7\n        R_AARCH64_P32_MOVW_SABS_G0                R_AARCH64 = 8\n        R_AARCH64_P32_LD_PREL_LO19                R_AARCH64 = 9\n        R_AARCH64_P32_ADR_PREL_LO21               R_AARCH64 = 10\n        R_AARCH64_P32_ADR_PREL_PG_HI21            R_AARCH64 = 11\n        R_AARCH64_P32_ADD_ABS_LO12_NC             R_AARCH64 = 12\n        R_AARCH64_P32_LDST8_ABS_LO12_NC           R_AARCH64 = 13\n        R_AARCH64_P32_LDST16_ABS_LO12_NC          R_AARCH64 = 14\n        R_AARCH64_P32_LDST32_ABS_LO12_NC          R_AARCH64 = 15\n        R_AARCH64_P32_LDST64_ABS_LO12_NC          R_AARCH64 = 16\n        R_AARCH64_P32_LDST128_ABS_LO12_NC         R_AARCH64 = 17\n        R_AARCH64_P32_TSTBR14                     R_AARCH64 = 18\n        R_AARCH64_P32_CONDBR19                    R_AARCH64 = 19\n        R_AARCH64_P32_JUMP26                      R_AARCH64 = 20\n        R_AARCH64_P32_CALL26                      R_AARCH64 = 21\n        R_AARCH64_P32_GOT_LD_PREL19               R_AARCH64 = 25\n        R_AARCH64_P32_ADR_GOT_PAGE                R_AARCH64 = 26\n        R_AARCH64_P32_LD32_GOT_LO12_NC            R_AARCH64 = 27\n        R_AARCH64_P32_TLSGD_ADR_PAGE21            R_AARCH64 = 81\n        R_AARCH64_P32_TLSGD_ADD_LO12_NC           R_AARCH64 = 82\n        R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21   R_AARCH64 = 103\n        R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC R_AARCH64 = 104\n        R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19    R_AARCH64 = 105\n        R_AARCH64_P32_TLSLE_MOVW_TPREL_G1         R_AARCH64 = 106\n        R_AARCH64_P32_TLSLE_MOVW_TPREL_G0         R_AARCH64 = 107\n        R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC      R_AARCH64 = 108\n        R_AARCH64_P32_TLSLE_ADD_TPREL_HI12        R_AARCH64 = 109\n        R_AARCH64_P32_TLSLE_ADD_TPREL_LO12        R_AARCH64 = 110\n        R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC     R_AARCH64 = 111\n        R_AARCH64_P32_TLSDESC_LD_PREL19           R_AARCH64 = 122\n        R_AARCH64_P32_TLSDESC_ADR_PREL21          R_AARCH64 = 123\n        R_AARCH64_P32_TLSDESC_ADR_PAGE21          R_AARCH64 = 124\n        R_AARCH64_P32_TLSDESC_LD32_LO12_NC        R_AARCH64 = 125\n        R_AARCH64_P32_TLSDESC_ADD_LO12_NC         R_AARCH64 = 126\n        R_AARCH64_P32_TLSDESC_CALL                R_AARCH64 = 127\n        R_AARCH64_P32_COPY                        R_AARCH64 = 180\n        R_AARCH64_P32_GLOB_DAT                    R_AARCH64 = 181\n        R_AARCH64_P32_JUMP_SLOT                   R_AARCH64 = 182\n        R_AARCH64_P32_RELATIVE                    R_AARCH64 = 183\n        R_AARCH64_P32_TLS_DTPMOD                  R_AARCH64 = 184\n        R_AARCH64_P32_TLS_DTPREL                  R_AARCH64 = 185\n        R_AARCH64_P32_TLS_TPREL                   R_AARCH64 = 186\n        R_AARCH64_P32_TLSDESC                     R_AARCH64 = 187\n        R_AARCH64_P32_IRELATIVE                   R_AARCH64 = 188\n        R_AARCH64_NULL                            R_AARCH64 = 256\n        R_AARCH64_ABS64                           R_AARCH64 = 257\n        R_AARCH64_ABS32                           R_AARCH64 = 258\n        R_AARCH64_ABS16                           R_AARCH64 = 259\n        R_AARCH64_PREL64                          R_AARCH64 = 260\n        R_AARCH64_PREL32                          R_AARCH64 = 261\n        R_AARCH64_PREL16                          R_AARCH64 = 262\n        R_AARCH64_MOVW_UABS_G0                    R_AARCH64 = 263\n        R_AARCH64_MOVW_UABS_G0_NC                 R_AARCH64 = 264\n        R_AARCH64_MOVW_UABS_G1                    R_AARCH64 = 265\n        R_AARCH64_MOVW_UABS_G1_NC                 R_AARCH64 = 266\n        R_AARCH64_MOVW_UABS_G2                    R_AARCH64 = 267\n        R_AARCH64_MOVW_UABS_G2_NC                 R_AARCH64 = 268\n        R_AARCH64_MOVW_UABS_G3                    R_AARCH64 = 269\n        R_AARCH64_MOVW_SABS_G0                    R_AARCH64 = 270\n        R_AARCH64_MOVW_SABS_G1                    R_AARCH64 = 271\n        R_AARCH64_MOVW_SABS_G2                    R_AARCH64 = 272\n        R_AARCH64_LD_PREL_LO19                    R_AARCH64 = 273\n        R_AARCH64_ADR_PREL_LO21                   R_AARCH64 = 274\n        R_AARCH64_ADR_PREL_PG_HI21                R_AARCH64 = 275\n        R_AARCH64_ADR_PREL_PG_HI21_NC             R_AARCH64 = 276\n        R_AARCH64_ADD_ABS_LO12_NC                 R_AARCH64 = 277\n        R_AARCH64_LDST8_ABS_LO12_NC               R_AARCH64 = 278\n        R_AARCH64_TSTBR14                         R_AARCH64 = 279\n        R_AARCH64_CONDBR19                        R_AARCH64 = 280\n        R_AARCH64_JUMP26                          R_AARCH64 = 282\n        R_AARCH64_CALL26                          R_AARCH64 = 283\n        R_AARCH64_LDST16_ABS_LO12_NC              R_AARCH64 = 284\n        R_AARCH64_LDST32_ABS_LO12_NC              R_AARCH64 = 285\n        R_AARCH64_LDST64_ABS_LO12_NC              R_AARCH64 = 286\n        R_AARCH64_LDST128_ABS_LO12_NC             R_AARCH64 = 299\n        R_AARCH64_GOT_LD_PREL19                   R_AARCH64 = 309\n        R_AARCH64_ADR_GOT_PAGE                    R_AARCH64 = 311\n        R_AARCH64_LD64_GOT_LO12_NC                R_AARCH64 = 312\n        R_AARCH64_TLSGD_ADR_PAGE21                R_AARCH64 = 513\n        R_AARCH64_TLSGD_ADD_LO12_NC               R_AARCH64 = 514\n        R_AARCH64_TLSIE_MOVW_GOTTPREL_G1          R_AARCH64 = 539\n        R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC       R_AARCH64 = 540\n        R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21       R_AARCH64 = 541\n        R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC     R_AARCH64 = 542\n        R_AARCH64_TLSIE_LD_GOTTPREL_PREL19        R_AARCH64 = 543\n        R_AARCH64_TLSLE_MOVW_TPREL_G2             R_AARCH64 = 544\n        R_AARCH64_TLSLE_MOVW_TPREL_G1             R_AARCH64 = 545\n        R_AARCH64_TLSLE_MOVW_TPREL_G1_NC          R_AARCH64 = 546\n        R_AARCH64_TLSLE_MOVW_TPREL_G0             R_AARCH64 = 547\n        R_AARCH64_TLSLE_MOVW_TPREL_G0_NC          R_AARCH64 = 548\n        R_AARCH64_TLSLE_ADD_TPREL_HI12            R_AARCH64 = 549\n        R_AARCH64_TLSLE_ADD_TPREL_LO12            R_AARCH64 = 550\n        R_AARCH64_TLSLE_ADD_TPREL_LO12_NC         R_AARCH64 = 551\n        R_AARCH64_TLSDESC_LD_PREL19               R_AARCH64 = 560\n        R_AARCH64_TLSDESC_ADR_PREL21              R_AARCH64 = 561\n        R_AARCH64_TLSDESC_ADR_PAGE21              R_AARCH64 = 562\n        R_AARCH64_TLSDESC_LD64_LO12_NC            R_AARCH64 = 563\n        R_AARCH64_TLSDESC_ADD_LO12_NC             R_AARCH64 = 564\n        R_AARCH64_TLSDESC_OFF_G1                  R_AARCH64 = 565\n        R_AARCH64_TLSDESC_OFF_G0_NC               R_AARCH64 = 566\n        R_AARCH64_TLSDESC_LDR                     R_AARCH64 = 567\n        R_AARCH64_TLSDESC_ADD                     R_AARCH64 = 568\n        R_AARCH64_TLSDESC_CALL                    R_AARCH64 = 569\n        R_AARCH64_COPY                            R_AARCH64 = 1024\n        R_AARCH64_GLOB_DAT                        R_AARCH64 = 1025\n        R_AARCH64_JUMP_SLOT                       R_AARCH64 = 1026\n        R_AARCH64_RELATIVE                        R_AARCH64 = 1027\n        R_AARCH64_TLS_DTPMOD64                    R_AARCH64 = 1028\n        R_AARCH64_TLS_DTPREL64                    R_AARCH64 = 1029\n        R_AARCH64_TLS_TPREL64                     R_AARCH64 = 1030\n        R_AARCH64_TLSDESC                         R_AARCH64 = 1031\n        R_AARCH64_IRELATIVE                       R_AARCH64 = 1032\n)</pre> <h3 id=\"R_AARCH64.GoString\">func (R_AARCH64) <a href=\"https://golang.org/src/debug/elf/elf.go?s=41707:41743#L1041\">GoString</a>  </h3> <pre data-language=\"go\">func (i R_AARCH64) GoString() string</pre> <h3 id=\"R_AARCH64.String\">func (R_AARCH64) <a href=\"https://golang.org/src/debug/elf/elf.go?s=41613:41647#L1040\">String</a>  </h3> <pre data-language=\"go\">func (i R_AARCH64) String() string</pre> <h2 id=\"R_ALPHA\">type R_ALPHA  </h2> <pre data-language=\"go\">type R_ALPHA int</pre> <p> Relocation types for Alpha. </p> <pre data-language=\"go\">const (\n        R_ALPHA_NONE           R_ALPHA = 0  /* No reloc */\n        R_ALPHA_REFLONG        R_ALPHA = 1  /* Direct 32 bit */\n        R_ALPHA_REFQUAD        R_ALPHA = 2  /* Direct 64 bit */\n        R_ALPHA_GPREL32        R_ALPHA = 3  /* GP relative 32 bit */\n        R_ALPHA_LITERAL        R_ALPHA = 4  /* GP relative 16 bit w/optimization */\n        R_ALPHA_LITUSE         R_ALPHA = 5  /* Optimization hint for LITERAL */\n        R_ALPHA_GPDISP         R_ALPHA = 6  /* Add displacement to GP */\n        R_ALPHA_BRADDR         R_ALPHA = 7  /* PC+4 relative 23 bit shifted */\n        R_ALPHA_HINT           R_ALPHA = 8  /* PC+4 relative 16 bit shifted */\n        R_ALPHA_SREL16         R_ALPHA = 9  /* PC relative 16 bit */\n        R_ALPHA_SREL32         R_ALPHA = 10 /* PC relative 32 bit */\n        R_ALPHA_SREL64         R_ALPHA = 11 /* PC relative 64 bit */\n        R_ALPHA_OP_PUSH        R_ALPHA = 12 /* OP stack push */\n        R_ALPHA_OP_STORE       R_ALPHA = 13 /* OP stack pop and store */\n        R_ALPHA_OP_PSUB        R_ALPHA = 14 /* OP stack subtract */\n        R_ALPHA_OP_PRSHIFT     R_ALPHA = 15 /* OP stack right shift */\n        R_ALPHA_GPVALUE        R_ALPHA = 16\n        R_ALPHA_GPRELHIGH      R_ALPHA = 17\n        R_ALPHA_GPRELLOW       R_ALPHA = 18\n        R_ALPHA_IMMED_GP_16    R_ALPHA = 19\n        R_ALPHA_IMMED_GP_HI32  R_ALPHA = 20\n        R_ALPHA_IMMED_SCN_HI32 R_ALPHA = 21\n        R_ALPHA_IMMED_BR_HI32  R_ALPHA = 22\n        R_ALPHA_IMMED_LO32     R_ALPHA = 23\n        R_ALPHA_COPY           R_ALPHA = 24 /* Copy symbol at runtime */\n        R_ALPHA_GLOB_DAT       R_ALPHA = 25 /* Create GOT entry */\n        R_ALPHA_JMP_SLOT       R_ALPHA = 26 /* Create PLT entry */\n        R_ALPHA_RELATIVE       R_ALPHA = 27 /* Adjust by program base */\n)</pre> <h3 id=\"R_ALPHA.GoString\">func (R_ALPHA) <a href=\"https://golang.org/src/debug/elf/elf.go?s=44294:44328#L1109\">GoString</a>  </h3> <pre data-language=\"go\">func (i R_ALPHA) GoString() string</pre> <h3 id=\"R_ALPHA.String\">func (R_ALPHA) <a href=\"https://golang.org/src/debug/elf/elf.go?s=44204:44236#L1108\">String</a>  </h3> <pre data-language=\"go\">func (i R_ALPHA) String() string</pre> <h2 id=\"R_ARM\">type R_ARM  </h2> <pre data-language=\"go\">type R_ARM int</pre> <p> Relocation types for ARM. </p> <pre data-language=\"go\">const (\n        R_ARM_NONE          R_ARM = 0 /* No relocation. */\n        R_ARM_PC24          R_ARM = 1\n        R_ARM_ABS32         R_ARM = 2\n        R_ARM_REL32         R_ARM = 3\n        R_ARM_PC13          R_ARM = 4\n        R_ARM_ABS16         R_ARM = 5\n        R_ARM_ABS12         R_ARM = 6\n        R_ARM_THM_ABS5      R_ARM = 7\n        R_ARM_ABS8          R_ARM = 8\n        R_ARM_SBREL32       R_ARM = 9\n        R_ARM_THM_PC22      R_ARM = 10\n        R_ARM_THM_PC8       R_ARM = 11\n        R_ARM_AMP_VCALL9    R_ARM = 12\n        R_ARM_SWI24         R_ARM = 13\n        R_ARM_THM_SWI8      R_ARM = 14\n        R_ARM_XPC25         R_ARM = 15\n        R_ARM_THM_XPC22     R_ARM = 16\n        R_ARM_COPY          R_ARM = 20 /* Copy data from shared object. */\n        R_ARM_GLOB_DAT      R_ARM = 21 /* Set GOT entry to data address. */\n        R_ARM_JUMP_SLOT     R_ARM = 22 /* Set GOT entry to code address. */\n        R_ARM_RELATIVE      R_ARM = 23 /* Add load address of shared object. */\n        R_ARM_GOTOFF        R_ARM = 24 /* Add GOT-relative symbol address. */\n        R_ARM_GOTPC         R_ARM = 25 /* Add PC-relative GOT table address. */\n        R_ARM_GOT32         R_ARM = 26 /* Add PC-relative GOT offset. */\n        R_ARM_PLT32         R_ARM = 27 /* Add PC-relative PLT offset. */\n        R_ARM_GNU_VTENTRY   R_ARM = 100\n        R_ARM_GNU_VTINHERIT R_ARM = 101\n        R_ARM_RSBREL32      R_ARM = 250\n        R_ARM_THM_RPC22     R_ARM = 251\n        R_ARM_RREL32        R_ARM = 252\n        R_ARM_RABS32        R_ARM = 253\n        R_ARM_RPC24         R_ARM = 254\n        R_ARM_RBASE         R_ARM = 255\n)</pre> <h3 id=\"R_ARM.GoString\">func (R_ARM) <a href=\"https://golang.org/src/debug/elf/elf.go?s=46707:46739#L1187\">GoString</a>  </h3> <pre data-language=\"go\">func (i R_ARM) GoString() string</pre> <h3 id=\"R_ARM.String\">func (R_ARM) <a href=\"https://golang.org/src/debug/elf/elf.go?s=46621:46651#L1186\">String</a>  </h3> <pre data-language=\"go\">func (i R_ARM) String() string</pre> <h2 id=\"R_MIPS\">type R_MIPS  </h2> <pre data-language=\"go\">type R_MIPS int</pre> <p> Relocation types for MIPS. </p> <pre data-language=\"go\">const (\n        R_MIPS_NONE          R_MIPS = 0\n        R_MIPS_16            R_MIPS = 1\n        R_MIPS_32            R_MIPS = 2\n        R_MIPS_REL32         R_MIPS = 3\n        R_MIPS_26            R_MIPS = 4\n        R_MIPS_HI16          R_MIPS = 5  /* high 16 bits of symbol value */\n        R_MIPS_LO16          R_MIPS = 6  /* low 16 bits of symbol value */\n        R_MIPS_GPREL16       R_MIPS = 7  /* GP-relative reference  */\n        R_MIPS_LITERAL       R_MIPS = 8  /* Reference to literal section  */\n        R_MIPS_GOT16         R_MIPS = 9  /* Reference to global offset table */\n        R_MIPS_PC16          R_MIPS = 10 /* 16 bit PC relative reference */\n        R_MIPS_CALL16        R_MIPS = 11 /* 16 bit call through glbl offset tbl */\n        R_MIPS_GPREL32       R_MIPS = 12\n        R_MIPS_SHIFT5        R_MIPS = 16\n        R_MIPS_SHIFT6        R_MIPS = 17\n        R_MIPS_64            R_MIPS = 18\n        R_MIPS_GOT_DISP      R_MIPS = 19\n        R_MIPS_GOT_PAGE      R_MIPS = 20\n        R_MIPS_GOT_OFST      R_MIPS = 21\n        R_MIPS_GOT_HI16      R_MIPS = 22\n        R_MIPS_GOT_LO16      R_MIPS = 23\n        R_MIPS_SUB           R_MIPS = 24\n        R_MIPS_INSERT_A      R_MIPS = 25\n        R_MIPS_INSERT_B      R_MIPS = 26\n        R_MIPS_DELETE        R_MIPS = 27\n        R_MIPS_HIGHER        R_MIPS = 28\n        R_MIPS_HIGHEST       R_MIPS = 29\n        R_MIPS_CALL_HI16     R_MIPS = 30\n        R_MIPS_CALL_LO16     R_MIPS = 31\n        R_MIPS_SCN_DISP      R_MIPS = 32\n        R_MIPS_REL16         R_MIPS = 33\n        R_MIPS_ADD_IMMEDIATE R_MIPS = 34\n        R_MIPS_PJUMP         R_MIPS = 35\n        R_MIPS_RELGOT        R_MIPS = 36\n        R_MIPS_JALR          R_MIPS = 37\n\n        R_MIPS_TLS_DTPMOD32    R_MIPS = 38 /* Module number 32 bit */\n        R_MIPS_TLS_DTPREL32    R_MIPS = 39 /* Module-relative offset 32 bit */\n        R_MIPS_TLS_DTPMOD64    R_MIPS = 40 /* Module number 64 bit */\n        R_MIPS_TLS_DTPREL64    R_MIPS = 41 /* Module-relative offset 64 bit */\n        R_MIPS_TLS_GD          R_MIPS = 42 /* 16 bit GOT offset for GD */\n        R_MIPS_TLS_LDM         R_MIPS = 43 /* 16 bit GOT offset for LDM */\n        R_MIPS_TLS_DTPREL_HI16 R_MIPS = 44 /* Module-relative offset, high 16 bits */\n        R_MIPS_TLS_DTPREL_LO16 R_MIPS = 45 /* Module-relative offset, low 16 bits */\n        R_MIPS_TLS_GOTTPREL    R_MIPS = 46 /* 16 bit GOT offset for IE */\n        R_MIPS_TLS_TPREL32     R_MIPS = 47 /* TP-relative offset, 32 bit */\n        R_MIPS_TLS_TPREL64     R_MIPS = 48 /* TP-relative offset, 64 bit */\n        R_MIPS_TLS_TPREL_HI16  R_MIPS = 49 /* TP-relative offset, high 16 bits */\n        R_MIPS_TLS_TPREL_LO16  R_MIPS = 50 /* TP-relative offset, low 16 bits */\n)</pre> <h3 id=\"R_MIPS.GoString\">func (R_MIPS) <a href=\"https://golang.org/src/debug/elf/elf.go?s=53809:53842#L1370\">GoString</a>  </h3> <pre data-language=\"go\">func (i R_MIPS) GoString() string</pre> <h3 id=\"R_MIPS.String\">func (R_MIPS) <a href=\"https://golang.org/src/debug/elf/elf.go?s=53721:53752#L1369\">String</a>  </h3> <pre data-language=\"go\">func (i R_MIPS) String() string</pre> <h2 id=\"R_PPC\">type R_PPC  </h2> <pre data-language=\"go\">type R_PPC int</pre> <p> Relocation types for PowerPC. </p> <pre data-language=\"go\">const (\n        R_PPC_NONE            R_PPC = 0 /* No relocation. */\n        R_PPC_ADDR32          R_PPC = 1\n        R_PPC_ADDR24          R_PPC = 2\n        R_PPC_ADDR16          R_PPC = 3\n        R_PPC_ADDR16_LO       R_PPC = 4\n        R_PPC_ADDR16_HI       R_PPC = 5\n        R_PPC_ADDR16_HA       R_PPC = 6\n        R_PPC_ADDR14          R_PPC = 7\n        R_PPC_ADDR14_BRTAKEN  R_PPC = 8\n        R_PPC_ADDR14_BRNTAKEN R_PPC = 9\n        R_PPC_REL24           R_PPC = 10\n        R_PPC_REL14           R_PPC = 11\n        R_PPC_REL14_BRTAKEN   R_PPC = 12\n        R_PPC_REL14_BRNTAKEN  R_PPC = 13\n        R_PPC_GOT16           R_PPC = 14\n        R_PPC_GOT16_LO        R_PPC = 15\n        R_PPC_GOT16_HI        R_PPC = 16\n        R_PPC_GOT16_HA        R_PPC = 17\n        R_PPC_PLTREL24        R_PPC = 18\n        R_PPC_COPY            R_PPC = 19\n        R_PPC_GLOB_DAT        R_PPC = 20\n        R_PPC_JMP_SLOT        R_PPC = 21\n        R_PPC_RELATIVE        R_PPC = 22\n        R_PPC_LOCAL24PC       R_PPC = 23\n        R_PPC_UADDR32         R_PPC = 24\n        R_PPC_UADDR16         R_PPC = 25\n        R_PPC_REL32           R_PPC = 26\n        R_PPC_PLT32           R_PPC = 27\n        R_PPC_PLTREL32        R_PPC = 28\n        R_PPC_PLT16_LO        R_PPC = 29\n        R_PPC_PLT16_HI        R_PPC = 30\n        R_PPC_PLT16_HA        R_PPC = 31\n        R_PPC_SDAREL16        R_PPC = 32\n        R_PPC_SECTOFF         R_PPC = 33\n        R_PPC_SECTOFF_LO      R_PPC = 34\n        R_PPC_SECTOFF_HI      R_PPC = 35\n        R_PPC_SECTOFF_HA      R_PPC = 36\n        R_PPC_TLS             R_PPC = 67\n        R_PPC_DTPMOD32        R_PPC = 68\n        R_PPC_TPREL16         R_PPC = 69\n        R_PPC_TPREL16_LO      R_PPC = 70\n        R_PPC_TPREL16_HI      R_PPC = 71\n        R_PPC_TPREL16_HA      R_PPC = 72\n        R_PPC_TPREL32         R_PPC = 73\n        R_PPC_DTPREL16        R_PPC = 74\n        R_PPC_DTPREL16_LO     R_PPC = 75\n        R_PPC_DTPREL16_HI     R_PPC = 76\n        R_PPC_DTPREL16_HA     R_PPC = 77\n        R_PPC_DTPREL32        R_PPC = 78\n        R_PPC_GOT_TLSGD16     R_PPC = 79\n        R_PPC_GOT_TLSGD16_LO  R_PPC = 80\n        R_PPC_GOT_TLSGD16_HI  R_PPC = 81\n        R_PPC_GOT_TLSGD16_HA  R_PPC = 82\n        R_PPC_GOT_TLSLD16     R_PPC = 83\n        R_PPC_GOT_TLSLD16_LO  R_PPC = 84\n        R_PPC_GOT_TLSLD16_HI  R_PPC = 85\n        R_PPC_GOT_TLSLD16_HA  R_PPC = 86\n        R_PPC_GOT_TPREL16     R_PPC = 87\n        R_PPC_GOT_TPREL16_LO  R_PPC = 88\n        R_PPC_GOT_TPREL16_HI  R_PPC = 89\n        R_PPC_GOT_TPREL16_HA  R_PPC = 90\n        R_PPC_EMB_NADDR32     R_PPC = 101\n        R_PPC_EMB_NADDR16     R_PPC = 102\n        R_PPC_EMB_NADDR16_LO  R_PPC = 103\n        R_PPC_EMB_NADDR16_HI  R_PPC = 104\n        R_PPC_EMB_NADDR16_HA  R_PPC = 105\n        R_PPC_EMB_SDAI16      R_PPC = 106\n        R_PPC_EMB_SDA2I16     R_PPC = 107\n        R_PPC_EMB_SDA2REL     R_PPC = 108\n        R_PPC_EMB_SDA21       R_PPC = 109\n        R_PPC_EMB_MRKREF      R_PPC = 110\n        R_PPC_EMB_RELSEC16    R_PPC = 111\n        R_PPC_EMB_RELST_LO    R_PPC = 112\n        R_PPC_EMB_RELST_HI    R_PPC = 113\n        R_PPC_EMB_RELST_HA    R_PPC = 114\n        R_PPC_EMB_BIT_FLD     R_PPC = 115\n        R_PPC_EMB_RELSDA      R_PPC = 116\n)</pre> <h3 id=\"R_PPC.GoString\">func (R_PPC) <a href=\"https://golang.org/src/debug/elf/elf.go?s=58780:58812#L1538\">GoString</a>  </h3> <pre data-language=\"go\">func (i R_PPC) GoString() string</pre> <h3 id=\"R_PPC.String\">func (R_PPC) <a href=\"https://golang.org/src/debug/elf/elf.go?s=58694:58724#L1537\">String</a>  </h3> <pre data-language=\"go\">func (i R_PPC) String() string</pre> <h2 id=\"R_PPC64\">type R_PPC64  </h2> <pre data-language=\"go\">type R_PPC64 int</pre> <p> Relocation types for 64-bit PowerPC or Power Architecture processors. </p> <pre data-language=\"go\">const (\n        R_PPC64_NONE               R_PPC64 = 0\n        R_PPC64_ADDR32             R_PPC64 = 1\n        R_PPC64_ADDR24             R_PPC64 = 2\n        R_PPC64_ADDR16             R_PPC64 = 3\n        R_PPC64_ADDR16_LO          R_PPC64 = 4\n        R_PPC64_ADDR16_HI          R_PPC64 = 5\n        R_PPC64_ADDR16_HA          R_PPC64 = 6\n        R_PPC64_ADDR14             R_PPC64 = 7\n        R_PPC64_ADDR14_BRTAKEN     R_PPC64 = 8\n        R_PPC64_ADDR14_BRNTAKEN    R_PPC64 = 9\n        R_PPC64_REL24              R_PPC64 = 10\n        R_PPC64_REL14              R_PPC64 = 11\n        R_PPC64_REL14_BRTAKEN      R_PPC64 = 12\n        R_PPC64_REL14_BRNTAKEN     R_PPC64 = 13\n        R_PPC64_GOT16              R_PPC64 = 14\n        R_PPC64_GOT16_LO           R_PPC64 = 15\n        R_PPC64_GOT16_HI           R_PPC64 = 16\n        R_PPC64_GOT16_HA           R_PPC64 = 17\n        R_PPC64_JMP_SLOT           R_PPC64 = 21\n        R_PPC64_REL32              R_PPC64 = 26\n        R_PPC64_ADDR64             R_PPC64 = 38\n        R_PPC64_ADDR16_HIGHER      R_PPC64 = 39\n        R_PPC64_ADDR16_HIGHERA     R_PPC64 = 40\n        R_PPC64_ADDR16_HIGHEST     R_PPC64 = 41\n        R_PPC64_ADDR16_HIGHESTA    R_PPC64 = 42\n        R_PPC64_REL64              R_PPC64 = 44\n        R_PPC64_TOC16              R_PPC64 = 47\n        R_PPC64_TOC16_LO           R_PPC64 = 48\n        R_PPC64_TOC16_HI           R_PPC64 = 49\n        R_PPC64_TOC16_HA           R_PPC64 = 50\n        R_PPC64_TOC                R_PPC64 = 51\n        R_PPC64_ADDR16_DS          R_PPC64 = 56\n        R_PPC64_ADDR16_LO_DS       R_PPC64 = 57\n        R_PPC64_GOT16_DS           R_PPC64 = 58\n        R_PPC64_GOT16_LO_DS        R_PPC64 = 59\n        R_PPC64_TOC16_DS           R_PPC64 = 63\n        R_PPC64_TOC16_LO_DS        R_PPC64 = 64\n        R_PPC64_TLS                R_PPC64 = 67\n        R_PPC64_DTPMOD64           R_PPC64 = 68\n        R_PPC64_TPREL16            R_PPC64 = 69\n        R_PPC64_TPREL16_LO         R_PPC64 = 70\n        R_PPC64_TPREL16_HI         R_PPC64 = 71\n        R_PPC64_TPREL16_HA         R_PPC64 = 72\n        R_PPC64_TPREL64            R_PPC64 = 73\n        R_PPC64_DTPREL16           R_PPC64 = 74\n        R_PPC64_DTPREL16_LO        R_PPC64 = 75\n        R_PPC64_DTPREL16_HI        R_PPC64 = 76\n        R_PPC64_DTPREL16_HA        R_PPC64 = 77\n        R_PPC64_DTPREL64           R_PPC64 = 78\n        R_PPC64_GOT_TLSGD16        R_PPC64 = 79\n        R_PPC64_GOT_TLSGD16_LO     R_PPC64 = 80\n        R_PPC64_GOT_TLSGD16_HI     R_PPC64 = 81\n        R_PPC64_GOT_TLSGD16_HA     R_PPC64 = 82\n        R_PPC64_GOT_TLSLD16        R_PPC64 = 83\n        R_PPC64_GOT_TLSLD16_LO     R_PPC64 = 84\n        R_PPC64_GOT_TLSLD16_HI     R_PPC64 = 85\n        R_PPC64_GOT_TLSLD16_HA     R_PPC64 = 86\n        R_PPC64_GOT_TPREL16_DS     R_PPC64 = 87\n        R_PPC64_GOT_TPREL16_LO_DS  R_PPC64 = 88\n        R_PPC64_GOT_TPREL16_HI     R_PPC64 = 89\n        R_PPC64_GOT_TPREL16_HA     R_PPC64 = 90\n        R_PPC64_GOT_DTPREL16_DS    R_PPC64 = 91\n        R_PPC64_GOT_DTPREL16_LO_DS R_PPC64 = 92\n        R_PPC64_GOT_DTPREL16_HI    R_PPC64 = 93\n        R_PPC64_GOT_DTPREL16_HA    R_PPC64 = 94\n        R_PPC64_TPREL16_DS         R_PPC64 = 95\n        R_PPC64_TPREL16_LO_DS      R_PPC64 = 96\n        R_PPC64_TPREL16_HIGHER     R_PPC64 = 97\n        R_PPC64_TPREL16_HIGHERA    R_PPC64 = 98\n        R_PPC64_TPREL16_HIGHEST    R_PPC64 = 99\n        R_PPC64_TPREL16_HIGHESTA   R_PPC64 = 100\n        R_PPC64_DTPREL16_DS        R_PPC64 = 101\n        R_PPC64_DTPREL16_LO_DS     R_PPC64 = 102\n        R_PPC64_DTPREL16_HIGHER    R_PPC64 = 103\n        R_PPC64_DTPREL16_HIGHERA   R_PPC64 = 104\n        R_PPC64_DTPREL16_HIGHEST   R_PPC64 = 105\n        R_PPC64_DTPREL16_HIGHESTA  R_PPC64 = 106\n        R_PPC64_TLSGD              R_PPC64 = 107\n        R_PPC64_TLSLD              R_PPC64 = 108\n        R_PPC64_REL16              R_PPC64 = 249\n        R_PPC64_REL16_LO           R_PPC64 = 250\n        R_PPC64_REL16_HI           R_PPC64 = 251\n        R_PPC64_REL16_HA           R_PPC64 = 252\n)</pre> <h3 id=\"R_PPC64.GoString\">func (R_PPC64) <a href=\"https://golang.org/src/debug/elf/elf.go?s=64942:64976#L1716\">GoString</a>  </h3> <pre data-language=\"go\">func (i R_PPC64) GoString() string</pre> <h3 id=\"R_PPC64.String\">func (R_PPC64) <a href=\"https://golang.org/src/debug/elf/elf.go?s=64852:64884#L1715\">String</a>  </h3> <pre data-language=\"go\">func (i R_PPC64) String() string</pre> <h2 id=\"R_SPARC\">type R_SPARC  </h2> <pre data-language=\"go\">type R_SPARC int</pre> <p> Relocation types for SPARC. </p> <pre data-language=\"go\">const (\n        R_SPARC_NONE     R_SPARC = 0\n        R_SPARC_8        R_SPARC = 1\n        R_SPARC_16       R_SPARC = 2\n        R_SPARC_32       R_SPARC = 3\n        R_SPARC_DISP8    R_SPARC = 4\n        R_SPARC_DISP16   R_SPARC = 5\n        R_SPARC_DISP32   R_SPARC = 6\n        R_SPARC_WDISP30  R_SPARC = 7\n        R_SPARC_WDISP22  R_SPARC = 8\n        R_SPARC_HI22     R_SPARC = 9\n        R_SPARC_22       R_SPARC = 10\n        R_SPARC_13       R_SPARC = 11\n        R_SPARC_LO10     R_SPARC = 12\n        R_SPARC_GOT10    R_SPARC = 13\n        R_SPARC_GOT13    R_SPARC = 14\n        R_SPARC_GOT22    R_SPARC = 15\n        R_SPARC_PC10     R_SPARC = 16\n        R_SPARC_PC22     R_SPARC = 17\n        R_SPARC_WPLT30   R_SPARC = 18\n        R_SPARC_COPY     R_SPARC = 19\n        R_SPARC_GLOB_DAT R_SPARC = 20\n        R_SPARC_JMP_SLOT R_SPARC = 21\n        R_SPARC_RELATIVE R_SPARC = 22\n        R_SPARC_UA32     R_SPARC = 23\n        R_SPARC_PLT32    R_SPARC = 24\n        R_SPARC_HIPLT22  R_SPARC = 25\n        R_SPARC_LOPLT10  R_SPARC = 26\n        R_SPARC_PCPLT32  R_SPARC = 27\n        R_SPARC_PCPLT22  R_SPARC = 28\n        R_SPARC_PCPLT10  R_SPARC = 29\n        R_SPARC_10       R_SPARC = 30\n        R_SPARC_11       R_SPARC = 31\n        R_SPARC_64       R_SPARC = 32\n        R_SPARC_OLO10    R_SPARC = 33\n        R_SPARC_HH22     R_SPARC = 34\n        R_SPARC_HM10     R_SPARC = 35\n        R_SPARC_LM22     R_SPARC = 36\n        R_SPARC_PC_HH22  R_SPARC = 37\n        R_SPARC_PC_HM10  R_SPARC = 38\n        R_SPARC_PC_LM22  R_SPARC = 39\n        R_SPARC_WDISP16  R_SPARC = 40\n        R_SPARC_WDISP19  R_SPARC = 41\n        R_SPARC_GLOB_JMP R_SPARC = 42\n        R_SPARC_7        R_SPARC = 43\n        R_SPARC_5        R_SPARC = 44\n        R_SPARC_6        R_SPARC = 45\n        R_SPARC_DISP64   R_SPARC = 46\n        R_SPARC_PLT64    R_SPARC = 47\n        R_SPARC_HIX22    R_SPARC = 48\n        R_SPARC_LOX10    R_SPARC = 49\n        R_SPARC_H44      R_SPARC = 50\n        R_SPARC_M44      R_SPARC = 51\n        R_SPARC_L44      R_SPARC = 52\n        R_SPARC_REGISTER R_SPARC = 53\n        R_SPARC_UA64     R_SPARC = 54\n        R_SPARC_UA16     R_SPARC = 55\n)</pre> <h3 id=\"R_SPARC.GoString\">func (R_SPARC) <a href=\"https://golang.org/src/debug/elf/elf.go?s=71821:71855#L1974\">GoString</a>  </h3> <pre data-language=\"go\">func (i R_SPARC) GoString() string</pre> <h3 id=\"R_SPARC.String\">func (R_SPARC) <a href=\"https://golang.org/src/debug/elf/elf.go?s=71731:71763#L1973\">String</a>  </h3> <pre data-language=\"go\">func (i R_SPARC) String() string</pre> <h2 id=\"R_X86_64\">type R_X86_64  </h2> <pre data-language=\"go\">type R_X86_64 int</pre> <p> Relocation types for x86-64. </p> <pre data-language=\"go\">const (\n        R_X86_64_NONE     R_X86_64 = 0  /* No relocation. */\n        R_X86_64_64       R_X86_64 = 1  /* Add 64 bit symbol value. */\n        R_X86_64_PC32     R_X86_64 = 2  /* PC-relative 32 bit signed sym value. */\n        R_X86_64_GOT32    R_X86_64 = 3  /* PC-relative 32 bit GOT offset. */\n        R_X86_64_PLT32    R_X86_64 = 4  /* PC-relative 32 bit PLT offset. */\n        R_X86_64_COPY     R_X86_64 = 5  /* Copy data from shared object. */\n        R_X86_64_GLOB_DAT R_X86_64 = 6  /* Set GOT entry to data address. */\n        R_X86_64_JMP_SLOT R_X86_64 = 7  /* Set GOT entry to code address. */\n        R_X86_64_RELATIVE R_X86_64 = 8  /* Add load address of shared object. */\n        R_X86_64_GOTPCREL R_X86_64 = 9  /* Add 32 bit signed pcrel offset to GOT. */\n        R_X86_64_32       R_X86_64 = 10 /* Add 32 bit zero extended symbol value */\n        R_X86_64_32S      R_X86_64 = 11 /* Add 32 bit sign extended symbol value */\n        R_X86_64_16       R_X86_64 = 12 /* Add 16 bit zero extended symbol value */\n        R_X86_64_PC16     R_X86_64 = 13 /* Add 16 bit signed extended pc relative symbol value */\n        R_X86_64_8        R_X86_64 = 14 /* Add 8 bit zero extended symbol value */\n        R_X86_64_PC8      R_X86_64 = 15 /* Add 8 bit signed extended pc relative symbol value */\n        R_X86_64_DTPMOD64 R_X86_64 = 16 /* ID of module containing symbol */\n        R_X86_64_DTPOFF64 R_X86_64 = 17 /* Offset in TLS block */\n        R_X86_64_TPOFF64  R_X86_64 = 18 /* Offset in static TLS block */\n        R_X86_64_TLSGD    R_X86_64 = 19 /* PC relative offset to GD GOT entry */\n        R_X86_64_TLSLD    R_X86_64 = 20 /* PC relative offset to LD GOT entry */\n        R_X86_64_DTPOFF32 R_X86_64 = 21 /* Offset in TLS block */\n        R_X86_64_GOTTPOFF R_X86_64 = 22 /* PC relative offset to IE GOT entry */\n        R_X86_64_TPOFF32  R_X86_64 = 23 /* Offset in static TLS block */\n)</pre> <h3 id=\"R_X86_64.GoString\">func (R_X86_64) <a href=\"https://golang.org/src/debug/elf/elf.go?s=29970:30005#L791\">GoString</a>  </h3> <pre data-language=\"go\">func (i R_X86_64) GoString() string</pre> <h3 id=\"R_X86_64.String\">func (R_X86_64) <a href=\"https://golang.org/src/debug/elf/elf.go?s=29878:29911#L790\">String</a>  </h3> <pre data-language=\"go\">func (i R_X86_64) String() string</pre> <h2 id=\"Rel32\">type Rel32  </h2> <pre data-language=\"go\">type Rel32 struct {\n        Off  uint32 /* Location to be relocated. */\n        Info uint32 /* Relocation type and symbol index. */\n}</pre> <p> ELF32 Relocations that don't need an addend field. </p> <h2 id=\"Rel64\">type Rel64  </h2> <pre data-language=\"go\">type Rel64 struct {\n        Off  uint64 /* Location to be relocated. */\n        Info uint64 /* Relocation type and symbol index. */\n}</pre> <p> ELF64 relocations that don't need an addend field. </p> <h2 id=\"Rela32\">type Rela32  </h2> <pre data-language=\"go\">type Rela32 struct {\n        Off    uint32 /* Location to be relocated. */\n        Info   uint32 /* Relocation type and symbol index. */\n        Addend int32  /* Addend. */\n}</pre> <p> ELF32 Relocations that need an addend field. </p> <h2 id=\"Rela64\">type Rela64  </h2> <pre data-language=\"go\">type Rela64 struct {\n        Off    uint64 /* Location to be relocated. */\n        Info   uint64 /* Relocation type and symbol index. */\n        Addend int64  /* Addend. */\n}</pre> <p> ELF64 relocations that need an addend field. </p> <h2 id=\"Section\">type Section  </h2> <pre data-language=\"go\">type Section struct {\n        SectionHeader\n\n        // Embed ReaderAt for ReadAt method.\n        // Do not embed SectionReader directly\n        // to avoid having Read and Seek.\n        // If a client wants Read and Seek it must use\n        // Open() to avoid fighting over the seek offset\n        // with other clients.\n        //\n        // ReaderAt may be nil if the section is not easily available\n        // in a random-access form. For example, a compressed section\n        // may have a nil ReaderAt.\n        io.ReaderAt\n        // contains filtered or unexported fields\n}</pre> <p> A Section represents a single section in an ELF file. </p> <h3 id=\"Section.Data\">func (*Section) <a href=\"https://golang.org/src/debug/elf/file.go?s=2082:2122#L83\">Data</a>  </h3> <pre data-language=\"go\">func (s *Section) Data() ([]byte, error)</pre> <p> Data reads and returns the contents of the ELF section. Even if the section is stored compressed in the ELF file, Data returns uncompressed data. </p> <h3 id=\"Section.Open\">func (*Section) <a href=\"https://golang.org/src/debug/elf/file.go?s=2680:2718#L101\">Open</a>  </h3> <pre data-language=\"go\">func (s *Section) Open() io.ReadSeeker</pre> <p> Open returns a new ReadSeeker reading the ELF section. Even if the section is stored compressed in the ELF file, the ReadSeeker reads uncompressed data. </p> <h2 id=\"Section32\">type Section32  </h2> <pre data-language=\"go\">type Section32 struct {\n        Name      uint32 /* Section name (index into the section header string table). */\n        Type      uint32 /* Section type. */\n        Flags     uint32 /* Section flags. */\n        Addr      uint32 /* Address in memory image. */\n        Off       uint32 /* Offset in file. */\n        Size      uint32 /* Size in bytes. */\n        Link      uint32 /* Index of a related section. */\n        Info      uint32 /* Depends on section type. */\n        Addralign uint32 /* Alignment in bytes. */\n        Entsize   uint32 /* Size of each entry in section. */\n}</pre> <p> ELF32 Section header. </p> <h2 id=\"Section64\">type Section64  </h2> <pre data-language=\"go\">type Section64 struct {\n        Name      uint32 /* Section name (index into the section header string table). */\n        Type      uint32 /* Section type. */\n        Flags     uint64 /* Section flags. */\n        Addr      uint64 /* Address in memory image. */\n        Off       uint64 /* Offset in file. */\n        Size      uint64 /* Size in bytes. */\n        Link      uint32 /* Index of a related section. */\n        Info      uint32 /* Depends on section type. */\n        Addralign uint64 /* Alignment in bytes. */\n        Entsize   uint64 /* Size of each entry in section. */\n}</pre> <p> ELF64 Section header. </p> <h2 id=\"SectionFlag\">type SectionFlag  </h2> <pre data-language=\"go\">type SectionFlag uint32</pre> <p> Section flags. </p> <pre data-language=\"go\">const (\n        SHF_WRITE            SectionFlag = 0x1        /* Section contains writable data. */\n        SHF_ALLOC            SectionFlag = 0x2        /* Section occupies memory. */\n        SHF_EXECINSTR        SectionFlag = 0x4        /* Section contains instructions. */\n        SHF_MERGE            SectionFlag = 0x10       /* Section may be merged. */\n        SHF_STRINGS          SectionFlag = 0x20       /* Section contains strings. */\n        SHF_INFO_LINK        SectionFlag = 0x40       /* sh_info holds section index. */\n        SHF_LINK_ORDER       SectionFlag = 0x80       /* Special ordering requirements. */\n        SHF_OS_NONCONFORMING SectionFlag = 0x100      /* OS-specific processing required. */\n        SHF_GROUP            SectionFlag = 0x200      /* Member of section group. */\n        SHF_TLS              SectionFlag = 0x400      /* Section contains TLS data. */\n        SHF_COMPRESSED       SectionFlag = 0x800      /* Section is compressed. */\n        SHF_MASKOS           SectionFlag = 0x0ff00000 /* OS-specific semantics. */\n        SHF_MASKPROC         SectionFlag = 0xf0000000 /* Processor-specific semantics. */\n)</pre> <h3 id=\"SectionFlag.GoString\">func (SectionFlag) <a href=\"https://golang.org/src/debug/elf/elf.go?s=16411:16449#L424\">GoString</a>  </h3> <pre data-language=\"go\">func (i SectionFlag) GoString() string</pre> <h3 id=\"SectionFlag.String\">func (SectionFlag) <a href=\"https://golang.org/src/debug/elf/elf.go?s=16322:16358#L423\">String</a>  </h3> <pre data-language=\"go\">func (i SectionFlag) String() string</pre> <h2 id=\"SectionHeader\">type SectionHeader  </h2> <pre data-language=\"go\">type SectionHeader struct {\n        Name      string\n        Type      SectionType\n        Flags     SectionFlag\n        Addr      uint64\n        Offset    uint64\n        Size      uint64\n        Link      uint32\n        Info      uint32\n        Addralign uint64\n        Entsize   uint64\n\n        // FileSize is the size of this section in the file in bytes.\n        // If a section is compressed, FileSize is the size of the\n        // compressed data, while Size (above) is the size of the\n        // uncompressed data.\n        FileSize uint64\n}</pre> <p> A SectionHeader represents a single ELF section header. </p> <h2 id=\"SectionIndex\">type SectionIndex  </h2> <pre data-language=\"go\">type SectionIndex int</pre> <p> Special section indices. </p> <pre data-language=\"go\">const (\n        SHN_UNDEF     SectionIndex = 0      /* Undefined, missing, irrelevant. */\n        SHN_LORESERVE SectionIndex = 0xff00 /* First of reserved range. */\n        SHN_LOPROC    SectionIndex = 0xff00 /* First processor-specific. */\n        SHN_HIPROC    SectionIndex = 0xff1f /* Last processor-specific. */\n        SHN_LOOS      SectionIndex = 0xff20 /* First operating system-specific. */\n        SHN_HIOS      SectionIndex = 0xff3f /* Last operating system-specific. */\n        SHN_ABS       SectionIndex = 0xfff1 /* Absolute values. */\n        SHN_COMMON    SectionIndex = 0xfff2 /* Common data. */\n        SHN_XINDEX    SectionIndex = 0xffff /* Escape; index stored elsewhere. */\n        SHN_HIRESERVE SectionIndex = 0xffff /* Last of reserved range. */\n)</pre> <h3 id=\"SectionIndex.GoString\">func (SectionIndex) <a href=\"https://golang.org/src/debug/elf/elf.go?s=11647:11686#L319\">GoString</a>  </h3> <pre data-language=\"go\">func (i SectionIndex) GoString() string</pre> <h3 id=\"SectionIndex.String\">func (SectionIndex) <a href=\"https://golang.org/src/debug/elf/elf.go?s=11555:11592#L318\">String</a>  </h3> <pre data-language=\"go\">func (i SectionIndex) String() string</pre> <h2 id=\"SectionType\">type SectionType  </h2> <pre data-language=\"go\">type SectionType uint32</pre> <p> Section type. </p> <pre data-language=\"go\">const (\n        SHT_NULL           SectionType = 0          /* inactive */\n        SHT_PROGBITS       SectionType = 1          /* program defined information */\n        SHT_SYMTAB         SectionType = 2          /* symbol table section */\n        SHT_STRTAB         SectionType = 3          /* string table section */\n        SHT_RELA           SectionType = 4          /* relocation section with addends */\n        SHT_HASH           SectionType = 5          /* symbol hash table section */\n        SHT_DYNAMIC        SectionType = 6          /* dynamic section */\n        SHT_NOTE           SectionType = 7          /* note section */\n        SHT_NOBITS         SectionType = 8          /* no space section */\n        SHT_REL            SectionType = 9          /* relocation section - no addends */\n        SHT_SHLIB          SectionType = 10         /* reserved - purpose unknown */\n        SHT_DYNSYM         SectionType = 11         /* dynamic symbol table section */\n        SHT_INIT_ARRAY     SectionType = 14         /* Initialization function pointers. */\n        SHT_FINI_ARRAY     SectionType = 15         /* Termination function pointers. */\n        SHT_PREINIT_ARRAY  SectionType = 16         /* Pre-initialization function ptrs. */\n        SHT_GROUP          SectionType = 17         /* Section group. */\n        SHT_SYMTAB_SHNDX   SectionType = 18         /* Section indexes (see SHN_XINDEX). */\n        SHT_LOOS           SectionType = 0x60000000 /* First of OS specific semantics */\n        SHT_GNU_ATTRIBUTES SectionType = 0x6ffffff5 /* GNU object attributes */\n        SHT_GNU_HASH       SectionType = 0x6ffffff6 /* GNU hash table */\n        SHT_GNU_LIBLIST    SectionType = 0x6ffffff7 /* GNU prelink library list */\n        SHT_GNU_VERDEF     SectionType = 0x6ffffffd /* GNU version definition section */\n        SHT_GNU_VERNEED    SectionType = 0x6ffffffe /* GNU version needs section */\n        SHT_GNU_VERSYM     SectionType = 0x6fffffff /* GNU version symbol table */\n        SHT_HIOS           SectionType = 0x6fffffff /* Last of OS specific semantics */\n        SHT_LOPROC         SectionType = 0x70000000 /* reserved range for processor */\n        SHT_HIPROC         SectionType = 0x7fffffff /* specific section header types */\n        SHT_LOUSER         SectionType = 0x80000000 /* reserved range for application */\n        SHT_HIUSER         SectionType = 0xffffffff /* specific indexes */\n)</pre> <h3 id=\"SectionType.GoString\">func (SectionType) <a href=\"https://golang.org/src/debug/elf/elf.go?s=14827:14865#L388\">GoString</a>  </h3> <pre data-language=\"go\">func (i SectionType) GoString() string</pre> <h3 id=\"SectionType.String\">func (SectionType) <a href=\"https://golang.org/src/debug/elf/elf.go?s=14736:14772#L387\">String</a>  </h3> <pre data-language=\"go\">func (i SectionType) String() string</pre> <h2 id=\"Sym32\">type Sym32  </h2> <pre data-language=\"go\">type Sym32 struct {\n        Name  uint32\n        Value uint32\n        Size  uint32\n        Info  uint8\n        Other uint8\n        Shndx uint16\n}</pre> <p> ELF32 Symbol. </p> <h2 id=\"Sym64\">type Sym64  </h2> <pre data-language=\"go\">type Sym64 struct {\n        Name  uint32 /* String table index of name. */\n        Info  uint8  /* Type and binding information. */\n        Other uint8  /* Reserved (not used). */\n        Shndx uint16 /* Section index of symbol. */\n        Value uint64 /* Symbol value. */\n        Size  uint64 /* Size of associated object. */\n}</pre> <p> ELF64 symbol table entries. </p> <h2 id=\"SymBind\">type SymBind  </h2> <pre data-language=\"go\">type SymBind int</pre> <p> Symbol Binding - ELFNN_ST_BIND - st_info </p> <pre data-language=\"go\">const (\n        STB_LOCAL  SymBind = 0  /* Local symbol */\n        STB_GLOBAL SymBind = 1  /* Global symbol */\n        STB_WEAK   SymBind = 2  /* like global - lower precedence */\n        STB_LOOS   SymBind = 10 /* Reserved range for operating system */\n        STB_HIOS   SymBind = 12 /*   specific semantics. */\n        STB_LOPROC SymBind = 13 /* reserved range for processor */\n        STB_HIPROC SymBind = 15 /*   specific semantics. */\n)</pre> <h3 id=\"ST_BIND\">func <a href=\"https://golang.org/src/debug/elf/elf.go?s=74883:74915#L2069\">ST_BIND</a>  </h3> <pre data-language=\"go\">func ST_BIND(info uint8) SymBind</pre> <h3 id=\"SymBind.GoString\">func (SymBind) <a href=\"https://golang.org/src/debug/elf/elf.go?s=25653:25687#L673\">GoString</a>  </h3> <pre data-language=\"go\">func (i SymBind) GoString() string</pre> <h3 id=\"SymBind.String\">func (SymBind) <a href=\"https://golang.org/src/debug/elf/elf.go?s=25566:25598#L672\">String</a>  </h3> <pre data-language=\"go\">func (i SymBind) String() string</pre> <h2 id=\"SymType\">type SymType  </h2> <pre data-language=\"go\">type SymType int</pre> <p> Symbol type - ELFNN_ST_TYPE - st_info </p> <pre data-language=\"go\">const (\n        STT_NOTYPE  SymType = 0  /* Unspecified type. */\n        STT_OBJECT  SymType = 1  /* Data object. */\n        STT_FUNC    SymType = 2  /* Function. */\n        STT_SECTION SymType = 3  /* Section. */\n        STT_FILE    SymType = 4  /* Source file. */\n        STT_COMMON  SymType = 5  /* Uninitialized common block. */\n        STT_TLS     SymType = 6  /* TLS object. */\n        STT_LOOS    SymType = 10 /* Reserved range for operating system */\n        STT_HIOS    SymType = 12 /*   specific semantics. */\n        STT_LOPROC  SymType = 13 /* reserved range for processor */\n        STT_HIPROC  SymType = 15 /*   specific semantics. */\n)</pre> <h3 id=\"ST_TYPE\">func <a href=\"https://golang.org/src/debug/elf/elf.go?s=74946:74978#L2070\">ST_TYPE</a>  </h3> <pre data-language=\"go\">func ST_TYPE(info uint8) SymType</pre> <h3 id=\"SymType.GoString\">func (SymType) <a href=\"https://golang.org/src/debug/elf/elf.go?s=26709:26743#L707\">GoString</a>  </h3> <pre data-language=\"go\">func (i SymType) GoString() string</pre> <h3 id=\"SymType.String\">func (SymType) <a href=\"https://golang.org/src/debug/elf/elf.go?s=26622:26654#L706\">String</a>  </h3> <pre data-language=\"go\">func (i SymType) String() string</pre> <h2 id=\"SymVis\">type SymVis  </h2> <pre data-language=\"go\">type SymVis int</pre> <p> Symbol visibility - ELFNN_ST_VISIBILITY - st_other </p> <pre data-language=\"go\">const (\n        STV_DEFAULT   SymVis = 0x0 /* Default visibility (see binding). */\n        STV_INTERNAL  SymVis = 0x1 /* Special meaning in relocatable objects. */\n        STV_HIDDEN    SymVis = 0x2 /* Not visible. */\n        STV_PROTECTED SymVis = 0x3 /* Visible but not preemptible. */\n)</pre> <h3 id=\"ST_VISIBILITY\">func <a href=\"https://golang.org/src/debug/elf/elf.go?s=75100:75138#L2074\">ST_VISIBILITY</a>  </h3> <pre data-language=\"go\">func ST_VISIBILITY(other uint8) SymVis</pre> <h3 id=\"SymVis.GoString\">func (SymVis) <a href=\"https://golang.org/src/debug/elf/elf.go?s=27344:27377#L727\">GoString</a>  </h3> <pre data-language=\"go\">func (i SymVis) GoString() string</pre> <h3 id=\"SymVis.String\">func (SymVis) <a href=\"https://golang.org/src/debug/elf/elf.go?s=27258:27289#L726\">String</a>  </h3> <pre data-language=\"go\">func (i SymVis) String() string</pre> <h2 id=\"Symbol\">type Symbol  </h2> <pre data-language=\"go\">type Symbol struct {\n        Name        string\n        Info, Other byte\n        Section     SectionIndex\n        Value, Size uint64\n}</pre> <p> A Symbol represents an entry in an ELF symbol table section. </p> <h2 id=\"Type\">type Type  </h2> <pre data-language=\"go\">type Type uint16</pre> <p> Type is found in Header.Type. </p> <pre data-language=\"go\">const (\n        ET_NONE   Type = 0      /* Unknown type. */\n        ET_REL    Type = 1      /* Relocatable. */\n        ET_EXEC   Type = 2      /* Executable. */\n        ET_DYN    Type = 3      /* Shared object. */\n        ET_CORE   Type = 4      /* Core file. */\n        ET_LOOS   Type = 0xfe00 /* First operating system specific. */\n        ET_HIOS   Type = 0xfeff /* Last operating system-specific. */\n        ET_LOPROC Type = 0xff00 /* First processor-specific. */\n        ET_HIPROC Type = 0xffff /* Last processor-specific. */\n)</pre> <h3 id=\"Type.GoString\">func (Type) <a href=\"https://golang.org/src/debug/elf/elf.go?s=6651:6682#L180\">GoString</a>  </h3> <pre data-language=\"go\">func (i Type) GoString() string</pre> <h3 id=\"Type.String\">func (Type) <a href=\"https://golang.org/src/debug/elf/elf.go?s=6566:6595#L179\">String</a>  </h3> <pre data-language=\"go\">func (i Type) String() string</pre> <h2 id=\"Version\">type Version  </h2> <pre data-language=\"go\">type Version byte</pre> <p> Version is found in Header.Ident[EI_VERSION] and Header.Version. </p> <pre data-language=\"go\">const (\n        EV_NONE    Version = 0\n        EV_CURRENT Version = 1\n)</pre> <h3 id=\"Version.GoString\">func (Version) <a href=\"https://golang.org/src/debug/elf/elf.go?s=3129:3163#L68\">GoString</a>  </h3> <pre data-language=\"go\">func (i Version) GoString() string</pre> <h3 id=\"Version.String\">func (Version) <a href=\"https://golang.org/src/debug/elf/elf.go?s=3038:3070#L67\">String</a>  </h3> <pre data-language=\"go\">func (i Version) String() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/debug/elf/\" class=\"_attribution-link\">https://golang.org/pkg/debug/elf/</a>\n  </p>\n</div>\n","path/filepath/index":"<h1>Package filepath</h1>     <ul id=\"short-nav\">\n<li><code>import \"path/filepath\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package filepath implements utility routines for manipulating filename paths in a way compatible with the target operating system-defined file paths. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Abs\">func Abs(path string) (string, error)</a></li>\n<li><a href=\"#Base\">func Base(path string) string</a></li>\n<li><a href=\"#Clean\">func Clean(path string) string</a></li>\n<li><a href=\"#Dir\">func Dir(path string) string</a></li>\n<li><a href=\"#EvalSymlinks\">func EvalSymlinks(path string) (string, error)</a></li>\n<li><a href=\"#Ext\">func Ext(path string) string</a></li>\n<li><a href=\"#FromSlash\">func FromSlash(path string) string</a></li>\n<li><a href=\"#Glob\">func Glob(pattern string) (matches []string, err error)</a></li>\n<li><a href=\"#HasPrefix\">func HasPrefix(p, prefix string) bool</a></li>\n<li><a href=\"#IsAbs\">func IsAbs(path string) bool</a></li>\n<li><a href=\"#Join\">func Join(elem ...string) string</a></li>\n<li><a href=\"#Match\">func Match(pattern, name string) (matched bool, err error)</a></li>\n<li><a href=\"#Rel\">func Rel(basepath, targpath string) (string, error)</a></li>\n<li><a href=\"#Split\">func Split(path string) (dir, file string)</a></li>\n<li><a href=\"#SplitList\">func SplitList(path string) []string</a></li>\n<li><a href=\"#ToSlash\">func ToSlash(path string) string</a></li>\n<li><a href=\"#VolumeName\">func VolumeName(path string) string</a></li>\n<li><a href=\"#Walk\">func Walk(root string, walkFn WalkFunc) error</a></li>\n<li><a href=\"#WalkFunc\">type WalkFunc</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Join\">Join</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Rel\">Rel</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Split\">Split</a></dd> <dd><a class=\"exampleLink\" href=\"#example_SplitList\">SplitList</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/path/filepath/match.go\">match.go</a> <a href=\"https://golang.org/src/path/filepath/path.go\">path.go</a> <a href=\"https://golang.org/src/path/filepath/path_unix.go\">path_unix.go</a> <a href=\"https://golang.org/src/path/filepath/symlink.go\">symlink.go</a> <a href=\"https://golang.org/src/path/filepath/symlink_unix.go\">symlink_unix.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        Separator     = os.PathSeparator\n        ListSeparator = os.PathListSeparator\n)</pre> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrBadPattern = errors.New(\"syntax error in pattern\")</pre> <p> ErrBadPattern indicates a globbing pattern was malformed. </p> <pre data-language=\"go\">var SkipDir = errors.New(\"skip this directory\")</pre> <p> SkipDir is used as a return value from WalkFuncs to indicate that the directory named in the call is to be skipped. It is not returned as an error by any function. </p> <h2 id=\"Abs\">func Abs  </h2> <pre data-language=\"go\">func Abs(path string) (string, error)</pre> <p> Abs returns an absolute representation of path. If the path is not absolute it will be joined with the current working directory to turn it into an absolute path. The absolute path name for a given file is not guaranteed to be unique. Abs calls Clean on the result. </p> <h2 id=\"Base\">func Base  </h2> <pre data-language=\"go\">func Base(path string) string</pre> <p> Base returns the last element of path. Trailing path separators are removed before extracting the last element. If the path is empty, Base returns \".\". If the path consists entirely of separators, Base returns a single separator. </p> <h2 id=\"Clean\">func Clean  </h2> <pre data-language=\"go\">func Clean(path string) string</pre> <p> Clean returns the shortest path name equivalent to path by purely lexical processing. It applies the following rules iteratively until no further processing can be done: </p> <pre data-language=\"go\">1. Replace multiple Separator elements with a single one.\n2. Eliminate each . path name element (the current directory).\n3. Eliminate each inner .. path name element (the parent directory)\n   along with the non-.. element that precedes it.\n4. Eliminate .. elements that begin a rooted path:\n   that is, replace \"/..\" by \"/\" at the beginning of a path,\n   assuming Separator is '/'.\n</pre> <p> The returned path ends in a slash only if it represents a root directory, such as \"/\" on Unix or `C:\\` on Windows. </p> <p> Finally, any occurrences of slash are replaced by Separator. </p> <p> If the result of this process is an empty string, Clean returns the string \".\". </p> <p> See also Rob Pike, “Lexical File Names in Plan 9 or Getting Dot-Dot Right,” <a href=\"https://9p.io/sys/doc/lexnames.html\">https://9p.io/sys/doc/lexnames.html</a> </p> <h2 id=\"Dir\">func Dir  </h2> <pre data-language=\"go\">func Dir(path string) string</pre> <p> Dir returns all but the last element of path, typically the path's directory. After dropping the final element, Dir calls Clean on the path and trailing slashes are removed. If the path is empty, Dir returns \".\". If the path consists entirely of separators, Dir returns a single separator. The returned path does not end in a separator unless it is the root directory. </p> <h2 id=\"EvalSymlinks\">func EvalSymlinks  </h2> <pre data-language=\"go\">func EvalSymlinks(path string) (string, error)</pre> <p> EvalSymlinks returns the path name after the evaluation of any symbolic links. If path is relative the result will be relative to the current directory, unless one of the components is an absolute symbolic link. EvalSymlinks calls Clean on the result. </p> <h2 id=\"Ext\">func Ext  </h2> <pre data-language=\"go\">func Ext(path string) string</pre> <p> Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final element of path; it is empty if there is no dot. </p> <h2 id=\"FromSlash\">func FromSlash  </h2> <pre data-language=\"go\">func FromSlash(path string) string</pre> <p> FromSlash returns the result of replacing each slash ('/') character in path with a separator character. Multiple slashes are replaced by multiple separators. </p> <h2 id=\"Glob\">func Glob  </h2> <pre data-language=\"go\">func Glob(pattern string) (matches []string, err error)</pre> <p> Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in Match. The pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/'). </p> <p> Glob ignores file system errors such as I/O errors reading directories. The only possible returned error is ErrBadPattern, when pattern is malformed. </p> <h2 id=\"HasPrefix\">func HasPrefix  </h2> <pre data-language=\"go\">func HasPrefix(p, prefix string) bool</pre> <p> HasPrefix exists for historical compatibility and should not be used. </p> <h2 id=\"IsAbs\">func IsAbs  </h2> <pre data-language=\"go\">func IsAbs(path string) bool</pre> <p> IsAbs reports whether the path is absolute. </p> <h2 id=\"Join\">func Join  </h2> <pre data-language=\"go\">func Join(elem ...string) string</pre> <p> Join joins any number of path elements into a single path, adding a Separator if necessary. Join calls Clean on the result; in particular, all empty strings are ignored. On Windows, the result is a UNC path if and only if the first path element is a UNC path. </p> <div id=\"example_Join\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\tfmt.Println(\"On Unix:\")\n\tfmt.Println(filepath.Join(\"a\", \"b\", \"c\"))\n\tfmt.Println(filepath.Join(\"a\", \"b/c\"))\n\tfmt.Println(filepath.Join(\"a/b\", \"c\"))\n\tfmt.Println(filepath.Join(\"a/b\", \"/c\"))\n}\n</pre> </div> </div> <h2 id=\"Match\">func Match  </h2> <pre data-language=\"go\">func Match(pattern, name string) (matched bool, err error)</pre> <p> Match reports whether name matches the shell file name pattern. The pattern syntax is: </p> <pre data-language=\"go\">pattern:\n\t{ term }\nterm:\n\t'*'         matches any sequence of non-Separator characters\n\t'?'         matches any single non-Separator character\n\t'[' [ '^' ] { character-range } ']'\n\t            character class (must be non-empty)\n\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t'\\\\' c      matches character c\n\ncharacter-range:\n\tc           matches character c (c != '\\\\', '-', ']')\n\t'\\\\' c      matches character c\n\tlo '-' hi   matches character c for lo &lt;= c &lt;= hi\n</pre> <p> Match requires pattern to match all of name, not just a substring. The only possible returned error is ErrBadPattern, when pattern is malformed. </p> <p> On Windows, escaping is disabled. Instead, '\\\\' is treated as path separator. </p> <h2 id=\"Rel\">func Rel  </h2> <pre data-language=\"go\">func Rel(basepath, targpath string) (string, error)</pre> <p> Rel returns a relative path that is lexically equivalent to targpath when joined to basepath with an intervening separator. That is, Join(basepath, Rel(basepath, targpath)) is equivalent to targpath itself. On success, the returned path will always be relative to basepath, even if basepath and targpath share no elements. An error is returned if targpath can't be made relative to basepath or if knowing the current working directory would be necessary to compute it. Rel calls Clean on the result. </p> <div id=\"example_Rel\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\tpaths := []string{\n\t\t\"/a/b/c\",\n\t\t\"/b/c\",\n\t\t\"./b/c\",\n\t}\n\tbase := \"/a\"\n\n\tfmt.Println(\"On Unix:\")\n\tfor _, p := range paths {\n\t\trel, err := filepath.Rel(base, p)\n\t\tfmt.Printf(\"%q: %q %v\\n\", p, rel, err)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"Split\">func Split  </h2> <pre data-language=\"go\">func Split(path string) (dir, file string)</pre> <p> Split splits path immediately following the final Separator, separating it into a directory and file name component. If there is no Separator in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file. </p> <div id=\"example_Split\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\tpaths := []string{\n\t\t\"/home/arnie/amelia.jpg\",\n\t\t\"/mnt/photos/\",\n\t\t\"rabbit.jpg\",\n\t\t\"/usr/local//go\",\n\t}\n\tfmt.Println(\"On Unix:\")\n\tfor _, p := range paths {\n\t\tdir, file := filepath.Split(p)\n\t\tfmt.Printf(\"input: %q\\n\\tdir: %q\\n\\tfile: %q\\n\", p, dir, file)\n\t}\n}\n</pre> </div> </div> <h2 id=\"SplitList\">func SplitList  </h2> <pre data-language=\"go\">func SplitList(path string) []string</pre> <p> SplitList splits a list of paths joined by the OS-specific ListSeparator, usually found in PATH or GOPATH environment variables. Unlike strings.Split, SplitList returns an empty slice when passed an empty string. SplitList does not replace slash characters in the returned paths. </p> <div id=\"example_SplitList\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\tfmt.Println(\"On Unix:\", filepath.SplitList(\"/a/b/c:/usr/bin\"))\n}\n</pre> </div> </div> <h2 id=\"ToSlash\">func ToSlash  </h2> <pre data-language=\"go\">func ToSlash(path string) string</pre> <p> ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes. </p> <h2 id=\"VolumeName\">func VolumeName  </h2> <pre data-language=\"go\">func VolumeName(path string) string</pre> <p> VolumeName returns leading volume name. Given \"C:\\foo\\bar\" it returns \"C:\" on Windows. Given \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\". On other platforms it returns \"\". </p> <h2 id=\"Walk\">func Walk  </h2> <pre data-language=\"go\">func Walk(root string, walkFn WalkFunc) error</pre> <p> Walk walks the file tree rooted at root, calling walkFn for each file or directory in the tree, including root. All errors that arise visiting files and directories are filtered by walkFn. The files are walked in lexical order, which makes the output deterministic but means that for very large directories Walk can be inefficient. Walk does not follow symbolic links. </p> <h2 id=\"WalkFunc\">type WalkFunc  </h2> <pre data-language=\"go\">type WalkFunc func(path string, info os.FileInfo, err error) error</pre> <p> WalkFunc is the type of the function called for each file or directory visited by Walk. The path argument contains the argument to Walk as a prefix; that is, if Walk is called with \"dir\", which is a directory containing the file \"a\", the walk function will be called with argument \"dir/a\". The info argument is the os.FileInfo for the named path. </p> <p> If there was a problem walking to the file or directory named by path, the incoming error will describe the problem and the function can decide how to handle that error (and Walk will not descend into that directory). If an error is returned, processing stops. The sole exception is when the function returns the special value SkipDir. If the function returns SkipDir when invoked on a directory, Walk skips the directory's contents entirely. If the function returns SkipDir when invoked on a non-directory file, Walk skips the remaining files in the containing directory. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/path/filepath/\" class=\"_attribution-link\">https://golang.org/pkg/path/filepath/</a>\n  </p>\n</div>\n","runtime/msan/index":"<h1>Command msan</h1><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/runtime/msan/\" class=\"_attribution-link\">https://golang.org/pkg/runtime/msan/</a>\n  </p>\n</div>\n","runtime/race/index":"<h1>Package race</h1>     <ul id=\"short-nav\">\n<li><code>import \"runtime/race\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package race implements data race detection logic. No public interface is provided. For details about the race detector see <a href=\"https://golang.org/doc/articles/race_detector.html\">https://golang.org/doc/articles/race_detector.html</a> </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>   <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/runtime/race/doc.go\">doc.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/runtime/race/\" class=\"_attribution-link\">https://golang.org/pkg/runtime/race/</a>\n  </p>\n</div>\n","runtime/trace/index":"<h1>Package trace</h1>     <ul id=\"short-nav\">\n<li><code>import \"runtime/trace\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Go execution tracer. The tracer captures a wide range of execution events like goroutine creation/blocking/unblocking, syscall enter/exit/block, GC-related events, changes of heap size, processor start/stop, etc and writes them to an io.Writer in a compact form. A precise nanosecond-precision timestamp and a stack trace is captured for most events. A trace can be analyzed later with 'go tool trace' command. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Start\">func Start(w io.Writer) error</a></li>\n<li><a href=\"#Stop\">func Stop()</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/runtime/trace/trace.go\">trace.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Start\">func Start  </h2> <pre data-language=\"go\">func Start(w io.Writer) error</pre> <p> Start enables tracing for the current program. While tracing, the trace will be buffered and written to w. Start returns an error if tracing is already enabled. </p> <h2 id=\"Stop\">func Stop  </h2> <pre data-language=\"go\">func Stop()</pre> <p> Stop stops the current tracing, if any. Stop only returns after all the writes for the trace have completed. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/runtime/trace/\" class=\"_attribution-link\">https://golang.org/pkg/runtime/trace/</a>\n  </p>\n</div>\n","image/index":"<h1>Package image</h1>     <ul id=\"short-nav\">\n<li><code>import \"image\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package image implements a basic 2-D image library. </p> <p> The fundamental interface is called Image. An Image contains colors, which are described in the image/color package. </p> <p> Values of the Image interface are created either by calling functions such as NewRGBA and NewPaletted, or by calling Decode on an io.Reader containing image data in a format such as GIF, JPEG or PNG. Decoding any particular image format requires the prior registration of a decoder function. Registration is typically automatic as a side effect of initializing that format's package so that, to decode a PNG image, it suffices to have </p> <pre data-language=\"go\">import _ \"image/png\"\n</pre> <p> in a program's main package. The _ means to import a package purely for its initialization side effects. </p> <p> See \"The Go image package\" for more details: <a href=\"https://golang.org/doc/articles/image_package.html\">https://golang.org/doc/articles/image_package.html</a> </p> </div> </div> <div id=\"example_\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">// This example demonstrates decoding a JPEG image and examining its pixels.\npackage main\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"image\"\n\t\"log\"\n\t\"strings\"\n\n\t// Package image/jpeg is not used explicitly in the code below,\n\t// but is imported for its initialization side-effect, which allows\n\t// image.Decode to understand JPEG formatted images. Uncomment these\n\t// two lines to also understand GIF and PNG images:\n\t// _ \"image/gif\"\n\t// _ \"image/png\"\n\t_ \"image/jpeg\"\n)\n\nfunc main() {\n\t// Decode the JPEG data. If reading from file, create a reader with\n\t//\n\t// reader, err := os.Open(\"testdata/video-001.q50.420.jpeg\")\n\t// if err != nil {\n\t//     log.Fatal(err)\n\t// }\n\t// defer reader.Close()\n\treader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(data))\n\tm, _, err := image.Decode(reader)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tbounds := m.Bounds()\n\n\t// Calculate a 16-bin histogram for m's red, green, blue and alpha components.\n\t//\n\t// An image's bounds do not necessarily start at (0, 0), so the two loops start\n\t// at bounds.Min.Y and bounds.Min.X. Looping over Y first and X second is more\n\t// likely to result in better memory access patterns than X first and Y second.\n\tvar histogram [16][4]int\n\tfor y := bounds.Min.Y; y &lt; bounds.Max.Y; y++ {\n\t\tfor x := bounds.Min.X; x &lt; bounds.Max.X; x++ {\n\t\t\tr, g, b, a := m.At(x, y).RGBA()\n\t\t\t// A color's RGBA method returns values in the range [0, 65535].\n\t\t\t// Shifting by 12 reduces this to the range [0, 15].\n\t\t\thistogram[r&gt;&gt;12][0]++\n\t\t\thistogram[g&gt;&gt;12][1]++\n\t\t\thistogram[b&gt;&gt;12][2]++\n\t\t\thistogram[a&gt;&gt;12][3]++\n\t\t}\n\t}\n\n\t// Print the results.\n\tfmt.Printf(\"%-14s %6s %6s %6s %6s\\n\", \"bin\", \"red\", \"green\", \"blue\", \"alpha\")\n\tfor i, x := range histogram {\n\t\tfmt.Printf(\"0x%04x-0x%04x: %6d %6d %6d %6d\\n\", i&lt;&lt;12, (i+1)&lt;&lt;12-1, x[0], x[1], x[2], x[3])\n\t}\n}\n\nconst data = `\n/9j/4AAQSkZJRgABAQIAHAAcAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdA\nSFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2Nj\nY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCABnAJYDASIAAhEBAxEB/8QA\nHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIh\nMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVW\nV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG\nx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQF\nBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAV\nYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOE\nhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq\n8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDlwKMD0pwzSiuK57QzGDxS7D6in8Y5ximnAPUfSlcq4m3ilUYp\n2OKXHvRcVxnTtS7c07HNFK4DQPakC4PNOA+tOx70XAjK/So5gBGP94fzqfvUVx/qxx/EP51UXqRP4WSE\ncmgjilP3jSEZqS0IO/NGDnpUiocDg/McDjvV6HTPOdVWYgsM5KcfzzQ2JySM2jp6VYu7SWzmMUwG4cgj\nkMPUVBjjtTGtRu0Zopw+lFFxhinrGzuqqMsxAA9yaXFSRv5cqSEcIwYj6GpuZ30O30fSLKzhUpbpNMv3\n5XGTn29BV28jt7pPLuIVljPBBFVreYx+VbqAjycgt3x14zRcNOxGyVFHQkIc/wA61exyKLbuzjdZ046d\nftEuTEw3Rk9SPT8P8Kpbea3tchbyVae4JkjbbGpGdwOM89Af6ViFTWUtGdcXoM2+woK1JtpNtTcoZt+l\nJt7ZqTbRtouFyPFRXI/c9D94fzqzioLsfuD/ALw/nVReqIn8LJCOTSY+tSMOTmkIpXLRu+F0t5pJxPHG\nwjjUAuBjJJz1+laD6Pai+WaK9SBX6puzn6ZP+NV/Dkdtc6ZNbyAFwxLAHDYPv6VoQ21nPNEEiQGEFRtk\nGf0NaWTOeW7Of8QwGG4MRZnEbYXPJwRnOR0zWNXW+KrqBLUWi5EjbWCgcAA9c/gRXKYqZaGlK/LqMH0F\nFLtHvRSNiYD2pSDTgpp6p0ywUHoTULXYxcktzrdCf7Xo8LP/AKyEmMNjJ46dfbFWJ5TDGNwB9lFUvDV9\nYrbfYGbyrjcWG88S57g+vtV26ZIvMlumKwwjLZ6V0WfU54yTvYwtbubea2WNWbzg4bYQeBgj8OtYeKhj\nu4y2HQxqxOD1xzxmrWAQCCGB6EGsaikndmsJxeiYzBo280/Z7UbayuaXGY5oIp+2lx9KLjIsVDeD/Rj/\nALy/zq1t96r3y4tT/vL/ADq4P3kRP4WSleTSFKkkKoCW4GaqNcMxIjXj1pxjKT0FKrGC1Nrw3vGrKkYz\n5kTAr6455/HH510UdwPtRgWCbzF5+YYUf4Vwun39xpmoR3qASMmQUJwGU9Rnt/8AWrpbrxhb8/ZdOmaQ\ngAGZwFH5ZJrpVKVlY5ZYhN6kXiu2eO/ikZlIljAAB5yM549OawSOOlPuLqe+umuLqTfM4OSOAo7ADsKh\nhl/cRsTuJHPv7mlKi3sVTxNtGP20VJhThgSQaK52mnZnUqsWrpkyeUrr5pABOAPU1AGaXUCWJISHGPfP\nP8qL7BiKnsMg46H3qrbzupbj5mPTPTpXVSglG551SpzSsXJ4/MBUgYIxyKpySyGBYJriV1D7kRpCVH4V\nbSeNJ4xchni3DeqnBI+td7F4b0mKIRjT45VbktJlzk455+n6VtYzv2PNwFZWBHBGKVJDGVC54/nXQeMN\nNttLNkba1jgWVWDmM8bhg4/nzXLSSbXVj6fyNKUdNRp21RtIRJGrjuM0u3FQ2DbodvcEkfQmrW2vLqLl\nk0ejCXNFMj2/jQV9qkxSYNRcsZiq2oI32N2CkhWXJxwOe9XMcVt6hoPn6dFaW0wgRpNzvKDlz6+/0rai\nryv2Jm9LHJai+ZRGCBjnr71ErdAxAY9B611t1Y2cunbbaOQ3FvKZI3UqGlZMbiWwfcfhV231iwvLSM3U\nlt5Uq52TuZG+hGMA12xXJGxxzjzybOQtNOvb5j9ktZJhnBIHyg+5PFX38JayqK/2eLJIBUTgkDA9q7ex\nitrSHFpGsUbndhRgc+g7VNIyfZJAoJZUbb3I46CtFJMylBo8sdWhmYMuCnylc9wef5VUT7+1chc5NS7h\nsUZO5RtIPUH3pkBDOxxxmqM9TQtn+WilhHfHaik43KTG3Z4IyPyrNVjGCsZ+dmwv6V3cXhSG8sYpJLud\nJJIwxChdoJGcYx/Wkg8DafA4knvLiQr/ALqj+VQpKw3FtnFFfvbiSMgZJ6/jXp2n3d9cQRBTFsKD96EP\noOxPU/8A68VVtbbRtMVntbePKDLTSHJH/Aj/AEqHTvE66rq72VugMMcbSGTnL4wMAfjT5n0HyW3L+s6b\nbaxaJBdzN+7bcrxkAhun0rz3VNCv7e7lgigknWI43xLu6jjIHTjtXqfkpPGVYsBkghTikgsYIN/lhgXb\ncxLkknp/ShczQ7xtY8vtEmhkj8yGRBuCnehUcnHcVtmwfJ/fQ8e7f/E12txZW91C0U6b42xlST2OR/Ko\nBo1gM/uW55/1jf41nOipu7LhV5FZHIGzI6zwj/vr/Ck+yr3uYf8Ax7/CutbQdMb71tn/ALaN/jSf8I/p\nX/PoP++2/wAan6rAr6wzkWt0II+1Rc/7Lf4Vd1eeCSKBbdZDdShYoiZNoyfY10P/AAj2lf8APmP++2/x\noPh/SjKspsozIuNrZORjp3qo0FHYPb3OZt7ae3SzjuItsiRSAgnccl/UA+3Q1yNjKLR4ZZYY5VD7tkv3\nWwO/+e1evPp9nI257aJm6bioz1z1+tY+s6Hplnot9PbWMMcqwOFcLyOO1bJWMZSTOPHi+9w3mosrlyd2\n9lCj02g9P/1e9a3hzxAbl2ikZRcdQueHHt7j864Y8Z4I4oRzG6urFWU5BHBB7HNJxTFGbR6he6Vpmtgm\neLy5zwZI/lb8fX8azIvBUUTHdfSFP4QsYB/HNZ+k+KEnRY75hHOvAk6K/v7H9K6yyvlnQBmDZ6GsnzR0\nN0oy1RzOtaN/Y1tHNFO06u+zYy4I4Jzx9KKveJblXuordSGES5b6n/62PzorKVdp2LjQTVyWz8UWEWlq\njSgyxfJt6EgdDzWTdeLIZGO7zHI/hVajGmWWP+PWL8qwlAIURrhpMAHHJA71pRcZrToZzcoEuo6heakA\nGHk245CZ6/X1qPTLq40q+W5t2QybSpDAkEEc55/zilk5k2r91eKhLDzWz2rpsczbbuemeD76fUNG865I\nMiysmQMZAAwa3a5j4ftu0ByP+fh/5CulkLLG7INzhSVHqe1Fh3uOoqn9qQQxyhndmHIxwOmSR2xQ13KD\nKoiBZOV9JBnt707MVy5RWdNdy7wRGf3bfMinnO1jg+vY03WXLaJO3mhQ20b0zwpYf0qlG7S7icrJs08U\nVwumgC+YiQyeVtZH567hzj8aSL949oGhE/2v5pJCDkksQwBHC4/+vXQ8LZ2uYxxCavY7us/xCcaBfn0h\nb+VP0bnSrb94ZMJgOecj1rl/GfidUE2k2gy5+SeQjgA/wj3rlas2jdao48qrjLAGkSKPk4Gc1WMj92I+\nlIJnU8OfxPWo5inBokmtQTmM4OOh71b0q6vbFmWCbaxHyqQGAP0PT8KhSTzVyo5ocSKA5VfTOTmqsmRd\npl99XjPzThzK3zOeOSeveirNmkgg/fIpYsTkYORxRXmzlTjJqx6EVUcU7mhkKCzdAK59QI9zYxtG1fYU\nUVtgtmY4nZEa8Ak9aqFv3rfSiiu1nMeifDv/AJF+T/r4f+QrqqKKQwzQenNFFMCOKFIgNuThdoJ5OPSk\nubeK6t3gnXdG4wwziiii/UTKMOg6dbzJLFE4dSCP3rEdeOM8805tDsGMvySgSsS6rM6gk9eAcUUVftZt\n3uyVGNthuq3Eei6DK8H7sRR7YuMgHtXkc8rzTNLM26RyWY+p70UVnLY0iEsUipG7rhZBlDkc1HgYoorM\n0HwyBXGeRjmrcUhMg2ghezd//rUUVcTKW5s2jZtY/QDaOKKKK8ip8bPRj8KP/9k=\n`\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#RegisterFormat\">func RegisterFormat(name, magic string, decode func(io.Reader) (Image, error), decodeConfig func(io.Reader) (Config, error))</a></li>\n<li><a href=\"#Alpha\">type Alpha</a></li>\n<li> <a href=\"#NewAlpha\">func NewAlpha(r Rectangle) *Alpha</a>\n</li>\n<li> <a href=\"#Alpha.AlphaAt\">func (p *Alpha) AlphaAt(x, y int) color.Alpha</a>\n</li>\n<li> <a href=\"#Alpha.At\">func (p *Alpha) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#Alpha.Bounds\">func (p *Alpha) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#Alpha.ColorModel\">func (p *Alpha) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#Alpha.Opaque\">func (p *Alpha) Opaque() bool</a>\n</li>\n<li> <a href=\"#Alpha.PixOffset\">func (p *Alpha) PixOffset(x, y int) int</a>\n</li>\n<li> <a href=\"#Alpha.Set\">func (p *Alpha) Set(x, y int, c color.Color)</a>\n</li>\n<li> <a href=\"#Alpha.SetAlpha\">func (p *Alpha) SetAlpha(x, y int, c color.Alpha)</a>\n</li>\n<li> <a href=\"#Alpha.SubImage\">func (p *Alpha) SubImage(r Rectangle) Image</a>\n</li>\n<li><a href=\"#Alpha16\">type Alpha16</a></li>\n<li> <a href=\"#NewAlpha16\">func NewAlpha16(r Rectangle) *Alpha16</a>\n</li>\n<li> <a href=\"#Alpha16.Alpha16At\">func (p *Alpha16) Alpha16At(x, y int) color.Alpha16</a>\n</li>\n<li> <a href=\"#Alpha16.At\">func (p *Alpha16) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#Alpha16.Bounds\">func (p *Alpha16) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#Alpha16.ColorModel\">func (p *Alpha16) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#Alpha16.Opaque\">func (p *Alpha16) Opaque() bool</a>\n</li>\n<li> <a href=\"#Alpha16.PixOffset\">func (p *Alpha16) PixOffset(x, y int) int</a>\n</li>\n<li> <a href=\"#Alpha16.Set\">func (p *Alpha16) Set(x, y int, c color.Color)</a>\n</li>\n<li> <a href=\"#Alpha16.SetAlpha16\">func (p *Alpha16) SetAlpha16(x, y int, c color.Alpha16)</a>\n</li>\n<li> <a href=\"#Alpha16.SubImage\">func (p *Alpha16) SubImage(r Rectangle) Image</a>\n</li>\n<li><a href=\"#CMYK\">type CMYK</a></li>\n<li> <a href=\"#NewCMYK\">func NewCMYK(r Rectangle) *CMYK</a>\n</li>\n<li> <a href=\"#CMYK.At\">func (p *CMYK) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#CMYK.Bounds\">func (p *CMYK) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#CMYK.CMYKAt\">func (p *CMYK) CMYKAt(x, y int) color.CMYK</a>\n</li>\n<li> <a href=\"#CMYK.ColorModel\">func (p *CMYK) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#CMYK.Opaque\">func (p *CMYK) Opaque() bool</a>\n</li>\n<li> <a href=\"#CMYK.PixOffset\">func (p *CMYK) PixOffset(x, y int) int</a>\n</li>\n<li> <a href=\"#CMYK.Set\">func (p *CMYK) Set(x, y int, c color.Color)</a>\n</li>\n<li> <a href=\"#CMYK.SetCMYK\">func (p *CMYK) SetCMYK(x, y int, c color.CMYK)</a>\n</li>\n<li> <a href=\"#CMYK.SubImage\">func (p *CMYK) SubImage(r Rectangle) Image</a>\n</li>\n<li><a href=\"#Config\">type Config</a></li>\n<li> <a href=\"#DecodeConfig\">func DecodeConfig(r io.Reader) (Config, string, error)</a>\n</li>\n<li><a href=\"#Gray\">type Gray</a></li>\n<li> <a href=\"#NewGray\">func NewGray(r Rectangle) *Gray</a>\n</li>\n<li> <a href=\"#Gray.At\">func (p *Gray) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#Gray.Bounds\">func (p *Gray) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#Gray.ColorModel\">func (p *Gray) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#Gray.GrayAt\">func (p *Gray) GrayAt(x, y int) color.Gray</a>\n</li>\n<li> <a href=\"#Gray.Opaque\">func (p *Gray) Opaque() bool</a>\n</li>\n<li> <a href=\"#Gray.PixOffset\">func (p *Gray) PixOffset(x, y int) int</a>\n</li>\n<li> <a href=\"#Gray.Set\">func (p *Gray) Set(x, y int, c color.Color)</a>\n</li>\n<li> <a href=\"#Gray.SetGray\">func (p *Gray) SetGray(x, y int, c color.Gray)</a>\n</li>\n<li> <a href=\"#Gray.SubImage\">func (p *Gray) SubImage(r Rectangle) Image</a>\n</li>\n<li><a href=\"#Gray16\">type Gray16</a></li>\n<li> <a href=\"#NewGray16\">func NewGray16(r Rectangle) *Gray16</a>\n</li>\n<li> <a href=\"#Gray16.At\">func (p *Gray16) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#Gray16.Bounds\">func (p *Gray16) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#Gray16.ColorModel\">func (p *Gray16) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#Gray16.Gray16At\">func (p *Gray16) Gray16At(x, y int) color.Gray16</a>\n</li>\n<li> <a href=\"#Gray16.Opaque\">func (p *Gray16) Opaque() bool</a>\n</li>\n<li> <a href=\"#Gray16.PixOffset\">func (p *Gray16) PixOffset(x, y int) int</a>\n</li>\n<li> <a href=\"#Gray16.Set\">func (p *Gray16) Set(x, y int, c color.Color)</a>\n</li>\n<li> <a href=\"#Gray16.SetGray16\">func (p *Gray16) SetGray16(x, y int, c color.Gray16)</a>\n</li>\n<li> <a href=\"#Gray16.SubImage\">func (p *Gray16) SubImage(r Rectangle) Image</a>\n</li>\n<li><a href=\"#Image\">type Image</a></li>\n<li> <a href=\"#Decode\">func Decode(r io.Reader) (Image, string, error)</a>\n</li>\n<li><a href=\"#NRGBA\">type NRGBA</a></li>\n<li> <a href=\"#NewNRGBA\">func NewNRGBA(r Rectangle) *NRGBA</a>\n</li>\n<li> <a href=\"#NRGBA.At\">func (p *NRGBA) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#NRGBA.Bounds\">func (p *NRGBA) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#NRGBA.ColorModel\">func (p *NRGBA) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#NRGBA.NRGBAAt\">func (p *NRGBA) NRGBAAt(x, y int) color.NRGBA</a>\n</li>\n<li> <a href=\"#NRGBA.Opaque\">func (p *NRGBA) Opaque() bool</a>\n</li>\n<li> <a href=\"#NRGBA.PixOffset\">func (p *NRGBA) PixOffset(x, y int) int</a>\n</li>\n<li> <a href=\"#NRGBA.Set\">func (p *NRGBA) Set(x, y int, c color.Color)</a>\n</li>\n<li> <a href=\"#NRGBA.SetNRGBA\">func (p *NRGBA) SetNRGBA(x, y int, c color.NRGBA)</a>\n</li>\n<li> <a href=\"#NRGBA.SubImage\">func (p *NRGBA) SubImage(r Rectangle) Image</a>\n</li>\n<li><a href=\"#NRGBA64\">type NRGBA64</a></li>\n<li> <a href=\"#NewNRGBA64\">func NewNRGBA64(r Rectangle) *NRGBA64</a>\n</li>\n<li> <a href=\"#NRGBA64.At\">func (p *NRGBA64) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#NRGBA64.Bounds\">func (p *NRGBA64) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#NRGBA64.ColorModel\">func (p *NRGBA64) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#NRGBA64.NRGBA64At\">func (p *NRGBA64) NRGBA64At(x, y int) color.NRGBA64</a>\n</li>\n<li> <a href=\"#NRGBA64.Opaque\">func (p *NRGBA64) Opaque() bool</a>\n</li>\n<li> <a href=\"#NRGBA64.PixOffset\">func (p *NRGBA64) PixOffset(x, y int) int</a>\n</li>\n<li> <a href=\"#NRGBA64.Set\">func (p *NRGBA64) Set(x, y int, c color.Color)</a>\n</li>\n<li> <a href=\"#NRGBA64.SetNRGBA64\">func (p *NRGBA64) SetNRGBA64(x, y int, c color.NRGBA64)</a>\n</li>\n<li> <a href=\"#NRGBA64.SubImage\">func (p *NRGBA64) SubImage(r Rectangle) Image</a>\n</li>\n<li><a href=\"#NYCbCrA\">type NYCbCrA</a></li>\n<li> <a href=\"#NewNYCbCrA\">func NewNYCbCrA(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *NYCbCrA</a>\n</li>\n<li> <a href=\"#NYCbCrA.AOffset\">func (p *NYCbCrA) AOffset(x, y int) int</a>\n</li>\n<li> <a href=\"#NYCbCrA.At\">func (p *NYCbCrA) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#NYCbCrA.ColorModel\">func (p *NYCbCrA) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#NYCbCrA.NYCbCrAAt\">func (p *NYCbCrA) NYCbCrAAt(x, y int) color.NYCbCrA</a>\n</li>\n<li> <a href=\"#NYCbCrA.Opaque\">func (p *NYCbCrA) Opaque() bool</a>\n</li>\n<li> <a href=\"#NYCbCrA.SubImage\">func (p *NYCbCrA) SubImage(r Rectangle) Image</a>\n</li>\n<li><a href=\"#Paletted\">type Paletted</a></li>\n<li> <a href=\"#NewPaletted\">func NewPaletted(r Rectangle, p color.Palette) *Paletted</a>\n</li>\n<li> <a href=\"#Paletted.At\">func (p *Paletted) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#Paletted.Bounds\">func (p *Paletted) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#Paletted.ColorIndexAt\">func (p *Paletted) ColorIndexAt(x, y int) uint8</a>\n</li>\n<li> <a href=\"#Paletted.ColorModel\">func (p *Paletted) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#Paletted.Opaque\">func (p *Paletted) Opaque() bool</a>\n</li>\n<li> <a href=\"#Paletted.PixOffset\">func (p *Paletted) PixOffset(x, y int) int</a>\n</li>\n<li> <a href=\"#Paletted.Set\">func (p *Paletted) Set(x, y int, c color.Color)</a>\n</li>\n<li> <a href=\"#Paletted.SetColorIndex\">func (p *Paletted) SetColorIndex(x, y int, index uint8)</a>\n</li>\n<li> <a href=\"#Paletted.SubImage\">func (p *Paletted) SubImage(r Rectangle) Image</a>\n</li>\n<li><a href=\"#PalettedImage\">type PalettedImage</a></li>\n<li><a href=\"#Point\">type Point</a></li>\n<li> <a href=\"#Pt\">func Pt(X, Y int) Point</a>\n</li>\n<li> <a href=\"#Point.Add\">func (p Point) Add(q Point) Point</a>\n</li>\n<li> <a href=\"#Point.Div\">func (p Point) Div(k int) Point</a>\n</li>\n<li> <a href=\"#Point.Eq\">func (p Point) Eq(q Point) bool</a>\n</li>\n<li> <a href=\"#Point.In\">func (p Point) In(r Rectangle) bool</a>\n</li>\n<li> <a href=\"#Point.Mod\">func (p Point) Mod(r Rectangle) Point</a>\n</li>\n<li> <a href=\"#Point.Mul\">func (p Point) Mul(k int) Point</a>\n</li>\n<li> <a href=\"#Point.String\">func (p Point) String() string</a>\n</li>\n<li> <a href=\"#Point.Sub\">func (p Point) Sub(q Point) Point</a>\n</li>\n<li><a href=\"#RGBA\">type RGBA</a></li>\n<li> <a href=\"#NewRGBA\">func NewRGBA(r Rectangle) *RGBA</a>\n</li>\n<li> <a href=\"#RGBA.At\">func (p *RGBA) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#RGBA.Bounds\">func (p *RGBA) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#RGBA.ColorModel\">func (p *RGBA) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#RGBA.Opaque\">func (p *RGBA) Opaque() bool</a>\n</li>\n<li> <a href=\"#RGBA.PixOffset\">func (p *RGBA) PixOffset(x, y int) int</a>\n</li>\n<li> <a href=\"#RGBA.RGBAAt\">func (p *RGBA) RGBAAt(x, y int) color.RGBA</a>\n</li>\n<li> <a href=\"#RGBA.Set\">func (p *RGBA) Set(x, y int, c color.Color)</a>\n</li>\n<li> <a href=\"#RGBA.SetRGBA\">func (p *RGBA) SetRGBA(x, y int, c color.RGBA)</a>\n</li>\n<li> <a href=\"#RGBA.SubImage\">func (p *RGBA) SubImage(r Rectangle) Image</a>\n</li>\n<li><a href=\"#RGBA64\">type RGBA64</a></li>\n<li> <a href=\"#NewRGBA64\">func NewRGBA64(r Rectangle) *RGBA64</a>\n</li>\n<li> <a href=\"#RGBA64.At\">func (p *RGBA64) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#RGBA64.Bounds\">func (p *RGBA64) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#RGBA64.ColorModel\">func (p *RGBA64) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#RGBA64.Opaque\">func (p *RGBA64) Opaque() bool</a>\n</li>\n<li> <a href=\"#RGBA64.PixOffset\">func (p *RGBA64) PixOffset(x, y int) int</a>\n</li>\n<li> <a href=\"#RGBA64.RGBA64At\">func (p *RGBA64) RGBA64At(x, y int) color.RGBA64</a>\n</li>\n<li> <a href=\"#RGBA64.Set\">func (p *RGBA64) Set(x, y int, c color.Color)</a>\n</li>\n<li> <a href=\"#RGBA64.SetRGBA64\">func (p *RGBA64) SetRGBA64(x, y int, c color.RGBA64)</a>\n</li>\n<li> <a href=\"#RGBA64.SubImage\">func (p *RGBA64) SubImage(r Rectangle) Image</a>\n</li>\n<li><a href=\"#Rectangle\">type Rectangle</a></li>\n<li> <a href=\"#Rect\">func Rect(x0, y0, x1, y1 int) Rectangle</a>\n</li>\n<li> <a href=\"#Rectangle.Add\">func (r Rectangle) Add(p Point) Rectangle</a>\n</li>\n<li> <a href=\"#Rectangle.At\">func (r Rectangle) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#Rectangle.Bounds\">func (r Rectangle) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#Rectangle.Canon\">func (r Rectangle) Canon() Rectangle</a>\n</li>\n<li> <a href=\"#Rectangle.ColorModel\">func (r Rectangle) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#Rectangle.Dx\">func (r Rectangle) Dx() int</a>\n</li>\n<li> <a href=\"#Rectangle.Dy\">func (r Rectangle) Dy() int</a>\n</li>\n<li> <a href=\"#Rectangle.Empty\">func (r Rectangle) Empty() bool</a>\n</li>\n<li> <a href=\"#Rectangle.Eq\">func (r Rectangle) Eq(s Rectangle) bool</a>\n</li>\n<li> <a href=\"#Rectangle.In\">func (r Rectangle) In(s Rectangle) bool</a>\n</li>\n<li> <a href=\"#Rectangle.Inset\">func (r Rectangle) Inset(n int) Rectangle</a>\n</li>\n<li> <a href=\"#Rectangle.Intersect\">func (r Rectangle) Intersect(s Rectangle) Rectangle</a>\n</li>\n<li> <a href=\"#Rectangle.Overlaps\">func (r Rectangle) Overlaps(s Rectangle) bool</a>\n</li>\n<li> <a href=\"#Rectangle.Size\">func (r Rectangle) Size() Point</a>\n</li>\n<li> <a href=\"#Rectangle.String\">func (r Rectangle) String() string</a>\n</li>\n<li> <a href=\"#Rectangle.Sub\">func (r Rectangle) Sub(p Point) Rectangle</a>\n</li>\n<li> <a href=\"#Rectangle.Union\">func (r Rectangle) Union(s Rectangle) Rectangle</a>\n</li>\n<li><a href=\"#Uniform\">type Uniform</a></li>\n<li> <a href=\"#NewUniform\">func NewUniform(c color.Color) *Uniform</a>\n</li>\n<li> <a href=\"#Uniform.At\">func (c *Uniform) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#Uniform.Bounds\">func (c *Uniform) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#Uniform.ColorModel\">func (c *Uniform) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#Uniform.Convert\">func (c *Uniform) Convert(color.Color) color.Color</a>\n</li>\n<li> <a href=\"#Uniform.Opaque\">func (c *Uniform) Opaque() bool</a>\n</li>\n<li> <a href=\"#Uniform.RGBA\">func (c *Uniform) RGBA() (r, g, b, a uint32)</a>\n</li>\n<li><a href=\"#YCbCr\">type YCbCr</a></li>\n<li> <a href=\"#NewYCbCr\">func NewYCbCr(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *YCbCr</a>\n</li>\n<li> <a href=\"#YCbCr.At\">func (p *YCbCr) At(x, y int) color.Color</a>\n</li>\n<li> <a href=\"#YCbCr.Bounds\">func (p *YCbCr) Bounds() Rectangle</a>\n</li>\n<li> <a href=\"#YCbCr.COffset\">func (p *YCbCr) COffset(x, y int) int</a>\n</li>\n<li> <a href=\"#YCbCr.ColorModel\">func (p *YCbCr) ColorModel() color.Model</a>\n</li>\n<li> <a href=\"#YCbCr.Opaque\">func (p *YCbCr) Opaque() bool</a>\n</li>\n<li> <a href=\"#YCbCr.SubImage\">func (p *YCbCr) SubImage(r Rectangle) Image</a>\n</li>\n<li> <a href=\"#YCbCr.YCbCrAt\">func (p *YCbCr) YCbCrAt(x, y int) color.YCbCr</a>\n</li>\n<li> <a href=\"#YCbCr.YOffset\">func (p *YCbCr) YOffset(x, y int) int</a>\n</li>\n<li><a href=\"#YCbCrSubsampleRatio\">type YCbCrSubsampleRatio</a></li>\n<li> <a href=\"#YCbCrSubsampleRatio.String\">func (s YCbCrSubsampleRatio) String() string</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_\">Package</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/image/format.go\">format.go</a> <a href=\"https://golang.org/src/image/geom.go\">geom.go</a> <a href=\"https://golang.org/src/image/image.go\">image.go</a> <a href=\"https://golang.org/src/image/names.go\">names.go</a> <a href=\"https://golang.org/src/image/ycbcr.go\">ycbcr.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        // Black is an opaque black uniform image.\n        Black = NewUniform(color.Black)\n        // White is an opaque white uniform image.\n        White = NewUniform(color.White)\n        // Transparent is a fully transparent uniform image.\n        Transparent = NewUniform(color.Transparent)\n        // Opaque is a fully opaque uniform image.\n        Opaque = NewUniform(color.Opaque)\n)</pre> <pre data-language=\"go\">var ErrFormat = errors.New(\"image: unknown format\")</pre> <p> ErrFormat indicates that decoding encountered an unknown format. </p> <h2 id=\"RegisterFormat\">func RegisterFormat  </h2> <pre data-language=\"go\">func RegisterFormat(name, magic string, decode func(io.Reader) (Image, error), decodeConfig func(io.Reader) (Config, error))</pre> <p> RegisterFormat registers an image format for use by Decode. Name is the name of the format, like \"jpeg\" or \"png\". Magic is the magic prefix that identifies the format's encoding. The magic string can contain \"?\" wildcards that each match any one byte. Decode is the function that decodes the encoded image. DecodeConfig is the function that decodes just its configuration. </p> <h2 id=\"Alpha\">type Alpha  </h2> <pre data-language=\"go\">type Alpha struct {\n        // Pix holds the image's pixels, as alpha values. The pixel at\n        // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].\n        Pix []uint8\n        // Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n        Stride int\n        // Rect is the image's bounds.\n        Rect Rectangle\n}</pre> <p> Alpha is an in-memory image whose At method returns color.Alpha values. </p> <h3 id=\"NewAlpha\">func <a href=\"https://golang.org/src/image/image.go?s=15648:15681#L557\">NewAlpha</a>  </h3> <pre data-language=\"go\">func NewAlpha(r Rectangle) *Alpha</pre> <p> NewAlpha returns a new Alpha image with the given bounds. </p> <h3 id=\"Alpha.AlphaAt\">func (*Alpha) <a href=\"https://golang.org/src/image/image.go?s=13976:14021#L490\">AlphaAt</a>  </h3> <pre data-language=\"go\">func (p *Alpha) AlphaAt(x, y int) color.Alpha</pre> <h3 id=\"Alpha.At\">func (*Alpha) <a href=\"https://golang.org/src/image/image.go?s=13906:13946#L486\">At</a>  </h3> <pre data-language=\"go\">func (p *Alpha) At(x, y int) color.Color</pre> <h3 id=\"Alpha.Bounds\">func (*Alpha) <a href=\"https://golang.org/src/image/image.go?s=13852:13886#L484\">Bounds</a>  </h3> <pre data-language=\"go\">func (p *Alpha) Bounds() Rectangle</pre> <h3 id=\"Alpha.ColorModel\">func (*Alpha) <a href=\"https://golang.org/src/image/image.go?s=13782:13822#L482\">ColorModel</a>  </h3> <pre data-language=\"go\">func (p *Alpha) ColorModel() color.Model</pre> <h3 id=\"Alpha.Opaque\">func (*Alpha) <a href=\"https://golang.org/src/image/image.go?s=15310:15339#L539\">Opaque</a>  </h3> <pre data-language=\"go\">func (p *Alpha) Opaque() bool</pre> <p> Opaque scans the entire image and reports whether it is fully opaque. </p> <h3 id=\"Alpha.PixOffset\">func (*Alpha) <a href=\"https://golang.org/src/image/image.go?s=14242:14281#L500\">PixOffset</a>  </h3> <pre data-language=\"go\">func (p *Alpha) PixOffset(x, y int) int</pre> <p> PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p> <h3 id=\"Alpha.Set\">func (*Alpha) <a href=\"https://golang.org/src/image/image.go?s=14342:14386#L504\">Set</a>  </h3> <pre data-language=\"go\">func (p *Alpha) Set(x, y int, c color.Color)</pre> <h3 id=\"Alpha.SetAlpha\">func (*Alpha) <a href=\"https://golang.org/src/image/image.go?s=14516:14565#L512\">SetAlpha</a>  </h3> <pre data-language=\"go\">func (p *Alpha) SetAlpha(x, y int, c color.Alpha)</pre> <h3 id=\"Alpha.SubImage\">func (*Alpha) <a href=\"https://golang.org/src/image/image.go?s=14804:14847#L522\">SubImage</a>  </h3> <pre data-language=\"go\">func (p *Alpha) SubImage(r Rectangle) Image</pre> <p> SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p> <h2 id=\"Alpha16\">type Alpha16  </h2> <pre data-language=\"go\">type Alpha16 struct {\n        // Pix holds the image's pixels, as alpha values in big-endian format. The pixel at\n        // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2].\n        Pix []uint8\n        // Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n        Stride int\n        // Rect is the image's bounds.\n        Rect Rectangle\n}</pre> <p> Alpha16 is an in-memory image whose At method returns color.Alpha16 values. </p> <h3 id=\"NewAlpha16\">func <a href=\"https://golang.org/src/image/image.go?s=18240:18277#L652\">NewAlpha16</a>  </h3> <pre data-language=\"go\">func NewAlpha16(r Rectangle) *Alpha16</pre> <p> NewAlpha16 returns a new Alpha16 image with the given bounds. </p> <h3 id=\"Alpha16.Alpha16At\">func (*Alpha16) <a href=\"https://golang.org/src/image/image.go?s=16380:16431#L582\">Alpha16At</a>  </h3> <pre data-language=\"go\">func (p *Alpha16) Alpha16At(x, y int) color.Alpha16</pre> <h3 id=\"Alpha16.At\">func (*Alpha16) <a href=\"https://golang.org/src/image/image.go?s=16306:16348#L578\">At</a>  </h3> <pre data-language=\"go\">func (p *Alpha16) At(x, y int) color.Color</pre> <h3 id=\"Alpha16.Bounds\">func (*Alpha16) <a href=\"https://golang.org/src/image/image.go?s=16250:16286#L576\">Bounds</a>  </h3> <pre data-language=\"go\">func (p *Alpha16) Bounds() Rectangle</pre> <h3 id=\"Alpha16.ColorModel\">func (*Alpha16) <a href=\"https://golang.org/src/image/image.go?s=16176:16218#L574\">ColorModel</a>  </h3> <pre data-language=\"go\">func (p *Alpha16) ColorModel() color.Model</pre> <h3 id=\"Alpha16.Opaque\">func (*Alpha16) <a href=\"https://golang.org/src/image/image.go?s=17867:17898#L634\">Opaque</a>  </h3> <pre data-language=\"go\">func (p *Alpha16) Opaque() bool</pre> <p> Opaque scans the entire image and reports whether it is fully opaque. </p> <h3 id=\"Alpha16.PixOffset\">func (*Alpha16) <a href=\"https://golang.org/src/image/image.go?s=16690:16731#L592\">PixOffset</a>  </h3> <pre data-language=\"go\">func (p *Alpha16) PixOffset(x, y int) int</pre> <p> PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p> <h3 id=\"Alpha16.Set\">func (*Alpha16) <a href=\"https://golang.org/src/image/image.go?s=16792:16838#L596\">Set</a>  </h3> <pre data-language=\"go\">func (p *Alpha16) Set(x, y int, c color.Color)</pre> <h3 id=\"Alpha16.SetAlpha16\">func (*Alpha16) <a href=\"https://golang.org/src/image/image.go?s=17022:17077#L606\">SetAlpha16</a>  </h3> <pre data-language=\"go\">func (p *Alpha16) SetAlpha16(x, y int, c color.Alpha16)</pre> <h3 id=\"Alpha16.SubImage\">func (*Alpha16) <a href=\"https://golang.org/src/image/image.go?s=17355:17400#L617\">SubImage</a>  </h3> <pre data-language=\"go\">func (p *Alpha16) SubImage(r Rectangle) Image</pre> <p> SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p> <h2 id=\"CMYK\">type CMYK  </h2> <pre data-language=\"go\">type CMYK struct {\n        // Pix holds the image's pixels, in C, M, Y, K order. The pixel at\n        // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].\n        Pix []uint8\n        // Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n        Stride int\n        // Rect is the image's bounds.\n        Rect Rectangle\n}</pre> <p> CMYK is an in-memory image whose At method returns color.CMYK values. </p> <h3 id=\"NewCMYK\">func <a href=\"https://golang.org/src/image/image.go?s=24943:24974#L899\">NewCMYK</a>  </h3> <pre data-language=\"go\">func NewCMYK(r Rectangle) *CMYK</pre> <p> NewCMYK returns a new CMYK image with the given bounds. </p> <h3 id=\"CMYK.At\">func (*CMYK) <a href=\"https://golang.org/src/image/image.go?s=23287:23326#L834\">At</a>  </h3> <pre data-language=\"go\">func (p *CMYK) At(x, y int) color.Color</pre> <h3 id=\"CMYK.Bounds\">func (*CMYK) <a href=\"https://golang.org/src/image/image.go?s=23234:23267#L832\">Bounds</a>  </h3> <pre data-language=\"go\">func (p *CMYK) Bounds() Rectangle</pre> <h3 id=\"CMYK.CMYKAt\">func (*CMYK) <a href=\"https://golang.org/src/image/image.go?s=23355:23397#L838\">CMYKAt</a>  </h3> <pre data-language=\"go\">func (p *CMYK) CMYKAt(x, y int) color.CMYK</pre> <h3 id=\"CMYK.ColorModel\">func (*CMYK) <a href=\"https://golang.org/src/image/image.go?s=23166:23205#L830\">ColorModel</a>  </h3> <pre data-language=\"go\">func (p *CMYK) ColorModel() color.Model</pre> <h3 id=\"CMYK.Opaque\">func (*CMYK) <a href=\"https://golang.org/src/image/image.go?s=24837:24865#L894\">Opaque</a>  </h3> <pre data-language=\"go\">func (p *CMYK) Opaque() bool</pre> <p> Opaque scans the entire image and reports whether it is fully opaque. </p> <h3 id=\"CMYK.PixOffset\">func (*CMYK) <a href=\"https://golang.org/src/image/image.go?s=23654:23692#L848\">PixOffset</a>  </h3> <pre data-language=\"go\">func (p *CMYK) PixOffset(x, y int) int</pre> <p> PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p> <h3 id=\"CMYK.Set\">func (*CMYK) <a href=\"https://golang.org/src/image/image.go?s=23753:23796#L852\">Set</a>  </h3> <pre data-language=\"go\">func (p *CMYK) Set(x, y int, c color.Color)</pre> <h3 id=\"CMYK.SetCMYK\">func (*CMYK) <a href=\"https://golang.org/src/image/image.go?s=23993:24039#L864\">SetCMYK</a>  </h3> <pre data-language=\"go\">func (p *CMYK) SetCMYK(x, y int, c color.CMYK)</pre> <h3 id=\"CMYK.SubImage\">func (*CMYK) <a href=\"https://golang.org/src/image/image.go?s=24334:24376#L877\">SubImage</a>  </h3> <pre data-language=\"go\">func (p *CMYK) SubImage(r Rectangle) Image</pre> <p> SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p> <h2 id=\"Config\">type Config  </h2> <pre data-language=\"go\">type Config struct {\n        ColorModel    color.Model\n        Width, Height int\n}</pre> <p> Config holds an image's color model and dimensions. </p> <h3 id=\"DecodeConfig\">func <a href=\"https://golang.org/src/image/format.go?s=2676:2730#L82\">DecodeConfig</a>  </h3> <pre data-language=\"go\">func DecodeConfig(r io.Reader) (Config, string, error)</pre> <p> DecodeConfig decodes the color model and dimensions of an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec-specific package. </p> <h2 id=\"Gray\">type Gray  </h2> <pre data-language=\"go\">type Gray struct {\n        // Pix holds the image's pixels, as gray values. The pixel at\n        // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].\n        Pix []uint8\n        // Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n        Stride int\n        // Rect is the image's bounds.\n        Rect Rectangle\n}</pre> <p> Gray is an in-memory image whose At method returns color.Gray values. </p> <h3 id=\"NewGray\">func <a href=\"https://golang.org/src/image/image.go?s=20357:20388#L731\">NewGray</a>  </h3> <pre data-language=\"go\">func NewGray(r Rectangle) *Gray</pre> <p> NewGray returns a new Gray image with the given bounds. </p> <h3 id=\"Gray.At\">func (*Gray) <a href=\"https://golang.org/src/image/image.go?s=18864:18903#L673\">At</a>  </h3> <pre data-language=\"go\">func (p *Gray) At(x, y int) color.Color</pre> <h3 id=\"Gray.Bounds\">func (*Gray) <a href=\"https://golang.org/src/image/image.go?s=18811:18844#L671\">Bounds</a>  </h3> <pre data-language=\"go\">func (p *Gray) Bounds() Rectangle</pre> <h3 id=\"Gray.ColorModel\">func (*Gray) <a href=\"https://golang.org/src/image/image.go?s=18743:18782#L669\">ColorModel</a>  </h3> <pre data-language=\"go\">func (p *Gray) ColorModel() color.Model</pre> <h3 id=\"Gray.GrayAt\">func (*Gray) <a href=\"https://golang.org/src/image/image.go?s=18932:18974#L677\">GrayAt</a>  </h3> <pre data-language=\"go\">func (p *Gray) GrayAt(x, y int) color.Gray</pre> <h3 id=\"Gray.Opaque\">func (*Gray) <a href=\"https://golang.org/src/image/image.go?s=20251:20279#L726\">Opaque</a>  </h3> <pre data-language=\"go\">func (p *Gray) Opaque() bool</pre> <p> Opaque scans the entire image and reports whether it is fully opaque. </p> <h3 id=\"Gray.PixOffset\">func (*Gray) <a href=\"https://golang.org/src/image/image.go?s=19193:19231#L687\">PixOffset</a>  </h3> <pre data-language=\"go\">func (p *Gray) PixOffset(x, y int) int</pre> <p> PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p> <h3 id=\"Gray.Set\">func (*Gray) <a href=\"https://golang.org/src/image/image.go?s=19292:19335#L691\">Set</a>  </h3> <pre data-language=\"go\">func (p *Gray) Set(x, y int, c color.Color)</pre> <h3 id=\"Gray.SetGray\">func (*Gray) <a href=\"https://golang.org/src/image/image.go?s=19463:19509#L699\">SetGray</a>  </h3> <pre data-language=\"go\">func (p *Gray) SetGray(x, y int, c color.Gray)</pre> <h3 id=\"Gray.SubImage\">func (*Gray) <a href=\"https://golang.org/src/image/image.go?s=19748:19790#L709\">SubImage</a>  </h3> <pre data-language=\"go\">func (p *Gray) SubImage(r Rectangle) Image</pre> <p> SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p> <h2 id=\"Gray16\">type Gray16  </h2> <pre data-language=\"go\">type Gray16 struct {\n        // Pix holds the image's pixels, as gray values in big-endian format. The pixel at\n        // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2].\n        Pix []uint8\n        // Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n        Stride int\n        // Rect is the image's bounds.\n        Rect Rectangle\n}</pre> <p> Gray16 is an in-memory image whose At method returns color.Gray16 values. </p> <h3 id=\"NewGray16\">func <a href=\"https://golang.org/src/image/image.go?s=22661:22696#L813\">NewGray16</a>  </h3> <pre data-language=\"go\">func NewGray16(r Rectangle) *Gray16</pre> <p> NewGray16 returns a new Gray16 image with the given bounds. </p> <h3 id=\"Gray16.At\">func (*Gray16) <a href=\"https://golang.org/src/image/image.go?s=21005:21046#L752\">At</a>  </h3> <pre data-language=\"go\">func (p *Gray16) At(x, y int) color.Color</pre> <h3 id=\"Gray16.Bounds\">func (*Gray16) <a href=\"https://golang.org/src/image/image.go?s=20950:20985#L750\">Bounds</a>  </h3> <pre data-language=\"go\">func (p *Gray16) Bounds() Rectangle</pre> <h3 id=\"Gray16.ColorModel\">func (*Gray16) <a href=\"https://golang.org/src/image/image.go?s=20878:20919#L748\">ColorModel</a>  </h3> <pre data-language=\"go\">func (p *Gray16) ColorModel() color.Model</pre> <h3 id=\"Gray16.Gray16At\">func (*Gray16) <a href=\"https://golang.org/src/image/image.go?s=21077:21125#L756\">Gray16At</a>  </h3> <pre data-language=\"go\">func (p *Gray16) Gray16At(x, y int) color.Gray16</pre> <h3 id=\"Gray16.Opaque\">func (*Gray16) <a href=\"https://golang.org/src/image/image.go?s=22549:22579#L808\">Opaque</a>  </h3> <pre data-language=\"go\">func (p *Gray16) Opaque() bool</pre> <p> Opaque scans the entire image and reports whether it is fully opaque. </p> <h3 id=\"Gray16.PixOffset\">func (*Gray16) <a href=\"https://golang.org/src/image/image.go?s=21382:21422#L766\">PixOffset</a>  </h3> <pre data-language=\"go\">func (p *Gray16) PixOffset(x, y int) int</pre> <p> PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p> <h3 id=\"Gray16.Set\">func (*Gray16) <a href=\"https://golang.org/src/image/image.go?s=21483:21528#L770\">Set</a>  </h3> <pre data-language=\"go\">func (p *Gray16) Set(x, y int, c color.Color)</pre> <h3 id=\"Gray16.SetGray16\">func (*Gray16) <a href=\"https://golang.org/src/image/image.go?s=21710:21762#L780\">SetGray16</a>  </h3> <pre data-language=\"go\">func (p *Gray16) SetGray16(x, y int, c color.Gray16)</pre> <h3 id=\"Gray16.SubImage\">func (*Gray16) <a href=\"https://golang.org/src/image/image.go?s=22040:22084#L791\">SubImage</a>  </h3> <pre data-language=\"go\">func (p *Gray16) SubImage(r Rectangle) Image</pre> <p> SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p> <h2 id=\"Image\">type Image  </h2> <pre data-language=\"go\">type Image interface {\n        // ColorModel returns the Image's color model.\n        ColorModel() color.Model\n        // Bounds returns the domain for which At can return non-zero color.\n        // The bounds do not necessarily contain the point (0, 0).\n        Bounds() Rectangle\n        // At returns the color of the pixel at (x, y).\n        // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid.\n        // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one.\n        At(x, y int) color.Color\n}</pre> <p> Image is a finite rectangular grid of color.Color values taken from a color model. </p> <h3 id=\"Decode\">func <a href=\"https://golang.org/src/image/format.go?s=2205:2252#L68\">Decode</a>  </h3> <pre data-language=\"go\">func Decode(r io.Reader) (Image, string, error)</pre> <p> Decode decodes an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec- specific package. </p> <h2 id=\"NRGBA\">type NRGBA  </h2> <pre data-language=\"go\">type NRGBA struct {\n        // Pix holds the image's pixels, in R, G, B, A order. The pixel at\n        // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].\n        Pix []uint8\n        // Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n        Stride int\n        // Rect is the image's bounds.\n        Rect Rectangle\n}</pre> <p> NRGBA is an in-memory image whose At method returns color.NRGBA values. </p> <h3 id=\"NewNRGBA\">func <a href=\"https://golang.org/src/image/image.go?s=10198:10231#L353\">NewNRGBA</a>  </h3> <pre data-language=\"go\">func NewNRGBA(r Rectangle) *NRGBA</pre> <p> NewNRGBA returns a new NRGBA image with the given bounds. </p> <h3 id=\"NRGBA.At\">func (*NRGBA) <a href=\"https://golang.org/src/image/image.go?s=8288:8328#L275\">At</a>  </h3> <pre data-language=\"go\">func (p *NRGBA) At(x, y int) color.Color</pre> <h3 id=\"NRGBA.Bounds\">func (*NRGBA) <a href=\"https://golang.org/src/image/image.go?s=8234:8268#L273\">Bounds</a>  </h3> <pre data-language=\"go\">func (p *NRGBA) Bounds() Rectangle</pre> <h3 id=\"NRGBA.ColorModel\">func (*NRGBA) <a href=\"https://golang.org/src/image/image.go?s=8164:8204#L271\">ColorModel</a>  </h3> <pre data-language=\"go\">func (p *NRGBA) ColorModel() color.Model</pre> <h3 id=\"NRGBA.NRGBAAt\">func (*NRGBA) <a href=\"https://golang.org/src/image/image.go?s=8358:8403#L279\">NRGBAAt</a>  </h3> <pre data-language=\"go\">func (p *NRGBA) NRGBAAt(x, y int) color.NRGBA</pre> <h3 id=\"NRGBA.Opaque\">func (*NRGBA) <a href=\"https://golang.org/src/image/image.go?s=9855:9884#L335\">Opaque</a>  </h3> <pre data-language=\"go\">func (p *NRGBA) Opaque() bool</pre> <p> Opaque scans the entire image and reports whether it is fully opaque. </p> <h3 id=\"NRGBA.PixOffset\">func (*NRGBA) <a href=\"https://golang.org/src/image/image.go?s=8662:8701#L289\">PixOffset</a>  </h3> <pre data-language=\"go\">func (p *NRGBA) PixOffset(x, y int) int</pre> <p> PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p> <h3 id=\"NRGBA.Set\">func (*NRGBA) <a href=\"https://golang.org/src/image/image.go?s=8762:8806#L293\">Set</a>  </h3> <pre data-language=\"go\">func (p *NRGBA) Set(x, y int, c color.Color)</pre> <h3 id=\"NRGBA.SetNRGBA\">func (*NRGBA) <a href=\"https://golang.org/src/image/image.go?s=9005:9054#L305\">SetNRGBA</a>  </h3> <pre data-language=\"go\">func (p *NRGBA) SetNRGBA(x, y int, c color.NRGBA)</pre> <h3 id=\"NRGBA.SubImage\">func (*NRGBA) <a href=\"https://golang.org/src/image/image.go?s=9349:9392#L318\">SubImage</a>  </h3> <pre data-language=\"go\">func (p *NRGBA) SubImage(r Rectangle) Image</pre> <p> SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p> <h2 id=\"NRGBA64\">type NRGBA64  </h2> <pre data-language=\"go\">type NRGBA64 struct {\n        // Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at\n        // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8].\n        Pix []uint8\n        // Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n        Stride int\n        // Rect is the image's bounds.\n        Rect Rectangle\n}</pre> <p> NRGBA64 is an in-memory image whose At method returns color.NRGBA64 values. </p> <h3 id=\"NewNRGBA64\">func <a href=\"https://golang.org/src/image/image.go?s=13275:13312#L465\">NewNRGBA64</a>  </h3> <pre data-language=\"go\">func NewNRGBA64(r Rectangle) *NRGBA64</pre> <p> NewNRGBA64 returns a new NRGBA64 image with the given bounds. </p> <h3 id=\"NRGBA64.At\">func (*NRGBA64) <a href=\"https://golang.org/src/image/image.go?s=10861:10903#L374\">At</a>  </h3> <pre data-language=\"go\">func (p *NRGBA64) At(x, y int) color.Color</pre> <h3 id=\"NRGBA64.Bounds\">func (*NRGBA64) <a href=\"https://golang.org/src/image/image.go?s=10805:10841#L372\">Bounds</a>  </h3> <pre data-language=\"go\">func (p *NRGBA64) Bounds() Rectangle</pre> <h3 id=\"NRGBA64.ColorModel\">func (*NRGBA64) <a href=\"https://golang.org/src/image/image.go?s=10731:10773#L370\">ColorModel</a>  </h3> <pre data-language=\"go\">func (p *NRGBA64) ColorModel() color.Model</pre> <h3 id=\"NRGBA64.NRGBA64At\">func (*NRGBA64) <a href=\"https://golang.org/src/image/image.go?s=10935:10986#L378\">NRGBA64At</a>  </h3> <pre data-language=\"go\">func (p *NRGBA64) NRGBA64At(x, y int) color.NRGBA64</pre> <h3 id=\"NRGBA64.Opaque\">func (*NRGBA64) <a href=\"https://golang.org/src/image/image.go?s=12902:12933#L447\">Opaque</a>  </h3> <pre data-language=\"go\">func (p *NRGBA64) Opaque() bool</pre> <p> Opaque scans the entire image and reports whether it is fully opaque. </p> <h3 id=\"NRGBA64.PixOffset\">func (*NRGBA64) <a href=\"https://golang.org/src/image/image.go?s=11389:11430#L393\">PixOffset</a>  </h3> <pre data-language=\"go\">func (p *NRGBA64) PixOffset(x, y int) int</pre> <p> PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p> <h3 id=\"NRGBA64.Set\">func (*NRGBA64) <a href=\"https://golang.org/src/image/image.go?s=11491:11537#L397\">Set</a>  </h3> <pre data-language=\"go\">func (p *NRGBA64) Set(x, y int, c color.Color)</pre> <h3 id=\"NRGBA64.SetNRGBA64\">func (*NRGBA64) <a href=\"https://golang.org/src/image/image.go?s=11892:11947#L413\">SetNRGBA64</a>  </h3> <pre data-language=\"go\">func (p *NRGBA64) SetNRGBA64(x, y int, c color.NRGBA64)</pre> <h3 id=\"NRGBA64.SubImage\">func (*NRGBA64) <a href=\"https://golang.org/src/image/image.go?s=12390:12435#L430\">SubImage</a>  </h3> <pre data-language=\"go\">func (p *NRGBA64) SubImage(r Rectangle) Image</pre> <p> SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p> <h2 id=\"NYCbCrA\">type NYCbCrA  </h2> <pre data-language=\"go\">type NYCbCrA struct {\n        YCbCr\n        A       []uint8\n        AStride int\n}</pre> <p> NYCbCrA is an in-memory image of non-alpha-premultiplied Y'CbCr-with-alpha colors. A and AStride are analogous to the Y and YStride fields of the embedded YCbCr. </p> <h3 id=\"NewNYCbCrA\">func <a href=\"https://golang.org/src/image/ycbcr.go?s=7546:7619#L268\">NewNYCbCrA</a>  </h3> <pre data-language=\"go\">func NewNYCbCrA(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *NYCbCrA</pre> <p> NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample ratio. </p> <h3 id=\"NYCbCrA.AOffset\">func (*NYCbCrA) <a href=\"https://golang.org/src/image/ycbcr.go?s=6067:6106#L212\">AOffset</a>  </h3> <pre data-language=\"go\">func (p *NYCbCrA) AOffset(x, y int) int</pre> <p> AOffset returns the index of the first element of A that corresponds to the pixel at (x, y). </p> <h3 id=\"NYCbCrA.At\">func (*NYCbCrA) <a href=\"https://golang.org/src/image/ycbcr.go?s=5595:5637#L189\">At</a>  </h3> <pre data-language=\"go\">func (p *NYCbCrA) At(x, y int) color.Color</pre> <h3 id=\"NYCbCrA.ColorModel\">func (*NYCbCrA) <a href=\"https://golang.org/src/image/ycbcr.go?s=5520:5562#L185\">ColorModel</a>  </h3> <pre data-language=\"go\">func (p *NYCbCrA) ColorModel() color.Model</pre> <h3 id=\"NYCbCrA.NYCbCrAAt\">func (*NYCbCrA) <a href=\"https://golang.org/src/image/ycbcr.go?s=5669:5720#L193\">NYCbCrAAt</a>  </h3> <pre data-language=\"go\">func (p *NYCbCrA) NYCbCrAAt(x, y int) color.NYCbCrA</pre> <h3 id=\"NYCbCrA.Opaque\">func (*NYCbCrA) <a href=\"https://golang.org/src/image/ycbcr.go?s=7180:7211#L249\">Opaque</a>  </h3> <pre data-language=\"go\">func (p *NYCbCrA) Opaque() bool</pre> <p> Opaque scans the entire image and reports whether it is fully opaque. </p> <h3 id=\"NYCbCrA.SubImage\">func (*NYCbCrA) <a href=\"https://golang.org/src/image/ycbcr.go?s=6317:6362#L218\">SubImage</a>  </h3> <pre data-language=\"go\">func (p *NYCbCrA) SubImage(r Rectangle) Image</pre> <p> SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p> <h2 id=\"Paletted\">type Paletted  </h2> <pre data-language=\"go\">type Paletted struct {\n        // Pix holds the image's pixels, as palette indices. The pixel at\n        // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].\n        Pix []uint8\n        // Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n        Stride int\n        // Rect is the image's bounds.\n        Rect Rectangle\n        // Palette is the image's palette.\n        Palette color.Palette\n}</pre> <p> Paletted is an in-memory image of uint8 indices into a given palette. </p> <h3 id=\"NewPaletted\">func <a href=\"https://golang.org/src/image/image.go?s=27679:27735#L1009\">NewPaletted</a>  </h3> <pre data-language=\"go\">func NewPaletted(r Rectangle, p color.Palette) *Paletted</pre> <p> NewPaletted returns a new Paletted image with the given width, height and palette. </p> <h3 id=\"Paletted.At\">func (*Paletted) <a href=\"https://golang.org/src/image/image.go?s=25627:25670#L922\">At</a>  </h3> <pre data-language=\"go\">func (p *Paletted) At(x, y int) color.Color</pre> <h3 id=\"Paletted.Bounds\">func (*Paletted) <a href=\"https://golang.org/src/image/image.go?s=25570:25607#L920\">Bounds</a>  </h3> <pre data-language=\"go\">func (p *Paletted) Bounds() Rectangle</pre> <h3 id=\"Paletted.ColorIndexAt\">func (*Paletted) <a href=\"https://golang.org/src/image/image.go?s=26192:26239#L947\">ColorIndexAt</a>  </h3> <pre data-language=\"go\">func (p *Paletted) ColorIndexAt(x, y int) uint8</pre> <h3 id=\"Paletted.ColorModel\">func (*Paletted) <a href=\"https://golang.org/src/image/image.go?s=25504:25547#L918\">ColorModel</a>  </h3> <pre data-language=\"go\">func (p *Paletted) ColorModel() color.Model</pre> <h3 id=\"Paletted.Opaque\">func (*Paletted) <a href=\"https://golang.org/src/image/image.go?s=27212:27244#L985\">Opaque</a>  </h3> <pre data-language=\"go\">func (p *Paletted) Opaque() bool</pre> <p> Opaque scans the entire image and reports whether it is fully opaque. </p> <h3 id=\"Paletted.PixOffset\">func (*Paletted) <a href=\"https://golang.org/src/image/image.go?s=25930:25972#L935\">PixOffset</a>  </h3> <pre data-language=\"go\">func (p *Paletted) PixOffset(x, y int) int</pre> <p> PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p> <h3 id=\"Paletted.Set\">func (*Paletted) <a href=\"https://golang.org/src/image/image.go?s=26033:26080#L939\">Set</a>  </h3> <pre data-language=\"go\">func (p *Paletted) Set(x, y int, c color.Color)</pre> <h3 id=\"Paletted.SetColorIndex\">func (*Paletted) <a href=\"https://golang.org/src/image/image.go?s=26332:26387#L955\">SetColorIndex</a>  </h3> <pre data-language=\"go\">func (p *Paletted) SetColorIndex(x, y int, index uint8)</pre> <h3 id=\"Paletted.SubImage\">func (*Paletted) <a href=\"https://golang.org/src/image/image.go?s=26628:26674#L965\">SubImage</a>  </h3> <pre data-language=\"go\">func (p *Paletted) SubImage(r Rectangle) Image</pre> <p> SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p> <h2 id=\"PalettedImage\">type PalettedImage  </h2> <pre data-language=\"go\">type PalettedImage interface {\n        // ColorIndexAt returns the palette index of the pixel at (x, y).\n        ColorIndexAt(x, y int) uint8\n        Image\n}</pre> <p> PalettedImage is an image whose colors may come from a limited palette. If m is a PalettedImage and m.ColorModel() returns a color.Palette p, then m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m's color model is not a color.Palette, then ColorIndexAt's behavior is undefined. </p> <h2 id=\"Point\">type Point  </h2> <pre data-language=\"go\">type Point struct {\n        X, Y int\n}</pre> <p> A Point is an X, Y coordinate pair. The axes increase right and down. </p> <pre data-language=\"go\">var ZP Point</pre> <p> ZP is the zero Point. </p> <h3 id=\"Pt\">func <a href=\"https://golang.org/src/image/geom.go?s=1524:1547#L63\">Pt</a>  </h3> <pre data-language=\"go\">func Pt(X, Y int) Point</pre> <p> Pt is shorthand for Point{X, Y}. </p> <h3 id=\"Point.Add\">func (Point) <a href=\"https://golang.org/src/image/geom.go?s=511:544#L13\">Add</a>  </h3> <pre data-language=\"go\">func (p Point) Add(q Point) Point</pre> <p> Add returns the vector p+q. </p> <h3 id=\"Point.Div\">func (Point) <a href=\"https://golang.org/src/image/geom.go?s=823:854#L28\">Div</a>  </h3> <pre data-language=\"go\">func (p Point) Div(k int) Point</pre> <p> Div returns the vector p/k. </p> <h3 id=\"Point.Eq\">func (Point) <a href=\"https://golang.org/src/image/geom.go?s=1397:1428#L55\">Eq</a>  </h3> <pre data-language=\"go\">func (p Point) Eq(q Point) bool</pre> <p> Eq reports whether p and q are equal. </p> <h3 id=\"Point.In\">func (Point) <a href=\"https://golang.org/src/image/geom.go?s=925:960#L33\">In</a>  </h3> <pre data-language=\"go\">func (p Point) In(r Rectangle) bool</pre> <p> In reports whether p is in r. </p> <h3 id=\"Point.Mod\">func (Point) <a href=\"https://golang.org/src/image/geom.go?s=1164:1201#L40\">Mod</a>  </h3> <pre data-language=\"go\">func (p Point) Mod(r Rectangle) Point</pre> <p> Mod returns the point q in r such that p.X-q.X is a multiple of r's width and p.Y-q.Y is a multiple of r's height. </p> <h3 id=\"Point.Mul\">func (Point) <a href=\"https://golang.org/src/image/geom.go?s=723:754#L23\">Mul</a>  </h3> <pre data-language=\"go\">func (p Point) Mul(k int) Point</pre> <p> Mul returns the vector p*k. </p> <h3 id=\"Point.String\">func (Point) <a href=\"https://golang.org/src/image/geom.go?s=380:410#L8\">String</a>  </h3> <pre data-language=\"go\">func (p Point) String() string</pre> <p> String returns a string representation of p like \"(3,4)\". </p> <h3 id=\"Point.Sub\">func (Point) <a href=\"https://golang.org/src/image/geom.go?s=617:650#L18\">Sub</a>  </h3> <pre data-language=\"go\">func (p Point) Sub(q Point) Point</pre> <p> Sub returns the vector p-q. </p> <h2 id=\"RGBA\">type RGBA  </h2> <pre data-language=\"go\">type RGBA struct {\n        // Pix holds the image's pixels, in R, G, B, A order. The pixel at\n        // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].\n        Pix []uint8\n        // Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n        Stride int\n        // Rect is the image's bounds.\n        Rect Rectangle\n}</pre> <p> RGBA is an in-memory image whose At method returns color.RGBA values. </p> <h3 id=\"NewRGBA\">func <a href=\"https://golang.org/src/image/image.go?s=4608:4639#L142\">NewRGBA</a>  </h3> <pre data-language=\"go\">func NewRGBA(r Rectangle) *RGBA</pre> <p> NewRGBA returns a new RGBA image with the given bounds. </p> <h3 id=\"RGBA.At\">func (*RGBA) <a href=\"https://golang.org/src/image/image.go?s=2718:2757#L64\">At</a>  </h3> <pre data-language=\"go\">func (p *RGBA) At(x, y int) color.Color</pre> <h3 id=\"RGBA.Bounds\">func (*RGBA) <a href=\"https://golang.org/src/image/image.go?s=2665:2698#L62\">Bounds</a>  </h3> <pre data-language=\"go\">func (p *RGBA) Bounds() Rectangle</pre> <h3 id=\"RGBA.ColorModel\">func (*RGBA) <a href=\"https://golang.org/src/image/image.go?s=2597:2636#L60\">ColorModel</a>  </h3> <pre data-language=\"go\">func (p *RGBA) ColorModel() color.Model</pre> <h3 id=\"RGBA.Opaque\">func (*RGBA) <a href=\"https://golang.org/src/image/image.go?s=4268:4296#L124\">Opaque</a>  </h3> <pre data-language=\"go\">func (p *RGBA) Opaque() bool</pre> <p> Opaque scans the entire image and reports whether it is fully opaque. </p> <h3 id=\"RGBA.PixOffset\">func (*RGBA) <a href=\"https://golang.org/src/image/image.go?s=3085:3123#L78\">PixOffset</a>  </h3> <pre data-language=\"go\">func (p *RGBA) PixOffset(x, y int) int</pre> <p> PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p> <h3 id=\"RGBA.RGBAAt\">func (*RGBA) <a href=\"https://golang.org/src/image/image.go?s=2786:2828#L68\">RGBAAt</a>  </h3> <pre data-language=\"go\">func (p *RGBA) RGBAAt(x, y int) color.RGBA</pre> <h3 id=\"RGBA.Set\">func (*RGBA) <a href=\"https://golang.org/src/image/image.go?s=3184:3227#L82\">Set</a>  </h3> <pre data-language=\"go\">func (p *RGBA) Set(x, y int, c color.Color)</pre> <h3 id=\"RGBA.SetRGBA\">func (*RGBA) <a href=\"https://golang.org/src/image/image.go?s=3424:3470#L94\">SetRGBA</a>  </h3> <pre data-language=\"go\">func (p *RGBA) SetRGBA(x, y int, c color.RGBA)</pre> <h3 id=\"RGBA.SubImage\">func (*RGBA) <a href=\"https://golang.org/src/image/image.go?s=3765:3807#L107\">SubImage</a>  </h3> <pre data-language=\"go\">func (p *RGBA) SubImage(r Rectangle) Image</pre> <p> SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p> <h2 id=\"RGBA64\">type RGBA64  </h2> <pre data-language=\"go\">type RGBA64 struct {\n        // Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at\n        // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8].\n        Pix []uint8\n        // Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n        Stride int\n        // Rect is the image's bounds.\n        Rect Rectangle\n}</pre> <p> RGBA64 is an in-memory image whose At method returns color.RGBA64 values. </p> <h3 id=\"NewRGBA64\">func <a href=\"https://golang.org/src/image/image.go?s=7656:7691#L254\">NewRGBA64</a>  </h3> <pre data-language=\"go\">func NewRGBA64(r Rectangle) *RGBA64</pre> <p> NewRGBA64 returns a new RGBA64 image with the given bounds. </p> <h3 id=\"RGBA64.At\">func (*RGBA64) <a href=\"https://golang.org/src/image/image.go?s=5262:5303#L163\">At</a>  </h3> <pre data-language=\"go\">func (p *RGBA64) At(x, y int) color.Color</pre> <h3 id=\"RGBA64.Bounds\">func (*RGBA64) <a href=\"https://golang.org/src/image/image.go?s=5207:5242#L161\">Bounds</a>  </h3> <pre data-language=\"go\">func (p *RGBA64) Bounds() Rectangle</pre> <h3 id=\"RGBA64.ColorModel\">func (*RGBA64) <a href=\"https://golang.org/src/image/image.go?s=5135:5176#L159\">ColorModel</a>  </h3> <pre data-language=\"go\">func (p *RGBA64) ColorModel() color.Model</pre> <h3 id=\"RGBA64.Opaque\">func (*RGBA64) <a href=\"https://golang.org/src/image/image.go?s=7286:7316#L236\">Opaque</a>  </h3> <pre data-language=\"go\">func (p *RGBA64) Opaque() bool</pre> <p> Opaque scans the entire image and reports whether it is fully opaque. </p> <h3 id=\"RGBA64.PixOffset\">func (*RGBA64) <a href=\"https://golang.org/src/image/image.go?s=5783:5823#L182\">PixOffset</a>  </h3> <pre data-language=\"go\">func (p *RGBA64) PixOffset(x, y int) int</pre> <p> PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p> <h3 id=\"RGBA64.RGBA64At\">func (*RGBA64) <a href=\"https://golang.org/src/image/image.go?s=5334:5382#L167\">RGBA64At</a>  </h3> <pre data-language=\"go\">func (p *RGBA64) RGBA64At(x, y int) color.RGBA64</pre> <h3 id=\"RGBA64.Set\">func (*RGBA64) <a href=\"https://golang.org/src/image/image.go?s=5884:5929#L186\">Set</a>  </h3> <pre data-language=\"go\">func (p *RGBA64) Set(x, y int, c color.Color)</pre> <h3 id=\"RGBA64.SetRGBA64\">func (*RGBA64) <a href=\"https://golang.org/src/image/image.go?s=6282:6334#L202\">SetRGBA64</a>  </h3> <pre data-language=\"go\">func (p *RGBA64) SetRGBA64(x, y int, c color.RGBA64)</pre> <h3 id=\"RGBA64.SubImage\">func (*RGBA64) <a href=\"https://golang.org/src/image/image.go?s=6777:6821#L219\">SubImage</a>  </h3> <pre data-language=\"go\">func (p *RGBA64) SubImage(r Rectangle) Image</pre> <p> SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p> <h2 id=\"Rectangle\">type Rectangle  </h2> <pre data-language=\"go\">type Rectangle struct {\n        Min, Max Point\n}</pre> <p> A Rectangle contains the points with Min.X &lt;= X &lt; Max.X, Min.Y &lt;= Y &lt; Max.Y. It is well-formed if Min.X &lt;= Max.X and likewise for Y. Points are always well-formed. A rectangle's methods always return well-formed outputs for well-formed inputs. </p> <p> A Rectangle is also an Image whose bounds are the rectangle itself. At returns color.Opaque for points in the rectangle and color.Transparent otherwise. </p> <pre data-language=\"go\">var ZR Rectangle</pre> <p> ZR is the zero Rectangle. </p> <h3 id=\"Rect\">func <a href=\"https://golang.org/src/image/geom.go?s=6047:6086#L248\">Rect</a>  </h3> <pre data-language=\"go\">func Rect(x0, y0, x1, y1 int) Rectangle</pre> <p> Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed. </p> <h3 id=\"Rectangle.Add\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=2542:2583#L103\">Add</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Add(p Point) Rectangle</pre> <p> Add returns the rectangle r translated by p. </p> <h3 id=\"Rectangle.At\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=5484:5527#L225\">At</a>  </h3> <pre data-language=\"go\">func (r Rectangle) At(x, y int) color.Color</pre> <p> At implements the Image interface. </p> <h3 id=\"Rectangle.Bounds\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=5652:5689#L233\">Bounds</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Bounds() Rectangle</pre> <p> Bounds implements the Image interface. </p> <h3 id=\"Rectangle.Canon\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=5264:5300#L214\">Canon</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Canon() Rectangle</pre> <p> Canon returns the canonical version of r. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed. </p> <h3 id=\"Rectangle.ColorModel\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=5751:5794#L238\">ColorModel</a>  </h3> <pre data-language=\"go\">func (r Rectangle) ColorModel() color.Model</pre> <p> ColorModel implements the Image interface. </p> <h3 id=\"Rectangle.Dx\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=2215:2242#L85\">Dx</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Dx() int</pre> <p> Dx returns r's width. </p> <h3 id=\"Rectangle.Dy\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=2300:2327#L90\">Dy</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Dy() int</pre> <p> Dy returns r's height. </p> <h3 id=\"Rectangle.Empty\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=4265:4296#L184\">Empty</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Empty() bool</pre> <p> Empty reports whether the rectangle contains no points. </p> <h3 id=\"Rectangle.Eq\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=4459:4498#L190\">Eq</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Eq(s Rectangle) bool</pre> <p> Eq reports whether r and s contain the same set of points. All empty rectangles are considered equal. </p> <h3 id=\"Rectangle.In\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=4832:4871#L202\">In</a>  </h3> <pre data-language=\"go\">func (r Rectangle) In(s Rectangle) bool</pre> <p> In reports whether every point in r is in s. </p> <h3 id=\"Rectangle.Inset\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=3067:3108#L121\">Inset</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Inset(n int) Rectangle</pre> <p> Inset returns the rectangle r inset by n, which may be negative. If either of r's dimensions is less than 2*n then an empty rectangle near the center of r will be returned. </p> <h3 id=\"Rectangle.Intersect\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=3512:3563#L141\">Intersect</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Intersect(s Rectangle) Rectangle</pre> <p> Intersect returns the largest rectangle contained by both r and s. If the two rectangles do not overlap then the zero rectangle will be returned. </p> <h3 id=\"Rectangle.Overlaps\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=4612:4657#L195\">Overlaps</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Overlaps(s Rectangle) bool</pre> <p> Overlaps reports whether r and s have a non-empty intersection. </p> <h3 id=\"Rectangle.Size\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=2397:2428#L95\">Size</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Size() Point</pre> <p> Size returns r's width and height. </p> <h3 id=\"Rectangle.String\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=2104:2138#L80\">String</a>  </h3> <pre data-language=\"go\">func (r Rectangle) String() string</pre> <p> String returns a string representation of r like \"(3,4)-(6,5)\". </p> <h3 id=\"Rectangle.Sub\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=2738:2779#L111\">Sub</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Sub(p Point) Rectangle</pre> <p> Sub returns the rectangle r translated by -p. </p> <h3 id=\"Rectangle.Union\">func (Rectangle) <a href=\"https://golang.org/src/image/geom.go?s=3895:3942#L161\">Union</a>  </h3> <pre data-language=\"go\">func (r Rectangle) Union(s Rectangle) Rectangle</pre> <p> Union returns the smallest rectangle that contains both r and s. </p> <h2 id=\"Uniform\">type Uniform  </h2> <pre data-language=\"go\">type Uniform struct {\n        C color.Color\n}</pre> <p> Uniform is an infinite-sized Image of uniform color. It implements the color.Color, color.Model, and Image interfaces. </p> <h3 id=\"NewUniform\">func <a href=\"https://golang.org/src/image/names.go?s=1213:1252#L40\">NewUniform</a>  </h3> <pre data-language=\"go\">func NewUniform(c color.Color) *Uniform</pre> <h3 id=\"Uniform.At\">func (*Uniform) <a href=\"https://golang.org/src/image/names.go?s=998:1040#L32\">At</a>  </h3> <pre data-language=\"go\">func (c *Uniform) At(x, y int) color.Color</pre> <h3 id=\"Uniform.Bounds\">func (*Uniform) <a href=\"https://golang.org/src/image/names.go?s=903:939#L30\">Bounds</a>  </h3> <pre data-language=\"go\">func (c *Uniform) Bounds() Rectangle</pre> <h3 id=\"Uniform.ColorModel\">func (*Uniform) <a href=\"https://golang.org/src/image/names.go?s=777:819#L22\">ColorModel</a>  </h3> <pre data-language=\"go\">func (c *Uniform) ColorModel() color.Model</pre> <h3 id=\"Uniform.Convert\">func (*Uniform) <a href=\"https://golang.org/src/image/names.go?s=835:885#L26\">Convert</a>  </h3> <pre data-language=\"go\">func (c *Uniform) Convert(color.Color) color.Color</pre> <h3 id=\"Uniform.Opaque\">func (*Uniform) <a href=\"https://golang.org/src/image/names.go?s=1130:1161#L35\">Opaque</a>  </h3> <pre data-language=\"go\">func (c *Uniform) Opaque() bool</pre> <p> Opaque scans the entire image and reports whether it is fully opaque. </p> <h3 id=\"Uniform.RGBA\">func (*Uniform) <a href=\"https://golang.org/src/image/names.go?s=708:752#L18\">RGBA</a>  </h3> <pre data-language=\"go\">func (c *Uniform) RGBA() (r, g, b, a uint32)</pre> <h2 id=\"YCbCr\">type YCbCr  </h2> <pre data-language=\"go\">type YCbCr struct {\n        Y, Cb, Cr      []uint8\n        YStride        int\n        CStride        int\n        SubsampleRatio YCbCrSubsampleRatio\n        Rect           Rectangle\n}</pre> <p> YCbCr is an in-memory image of Y'CbCr colors. There is one Y sample per pixel, but each Cb and Cr sample can span one or more pixels. YStride is the Y slice index delta between vertically adjacent pixels. CStride is the Cb and Cr slice index delta between vertically adjacent pixels that map to separate chroma samples. It is not an absolute requirement, but YStride and len(Y) are typically multiples of 8, and: </p> <pre data-language=\"go\">For 4:4:4, CStride == YStride/1 &amp;&amp; len(Cb) == len(Cr) == len(Y)/1.\nFor 4:2:2, CStride == YStride/2 &amp;&amp; len(Cb) == len(Cr) == len(Y)/2.\nFor 4:2:0, CStride == YStride/2 &amp;&amp; len(Cb) == len(Cr) == len(Y)/4.\nFor 4:4:0, CStride == YStride/1 &amp;&amp; len(Cb) == len(Cr) == len(Y)/2.\nFor 4:1:1, CStride == YStride/4 &amp;&amp; len(Cb) == len(Cr) == len(Y)/4.\nFor 4:1:0, CStride == YStride/4 &amp;&amp; len(Cb) == len(Cr) == len(Y)/8.\n</pre> <h3 id=\"NewYCbCr\">func <a href=\"https://golang.org/src/image/ycbcr.go?s=4872:4941#L159\">NewYCbCr</a>  </h3> <pre data-language=\"go\">func NewYCbCr(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *YCbCr</pre> <p> NewYCbCr returns a new YCbCr image with the given bounds and subsample ratio. </p> <h3 id=\"YCbCr.At\">func (*YCbCr) <a href=\"https://golang.org/src/image/ycbcr.go?s=2105:2145#L60\">At</a>  </h3> <pre data-language=\"go\">func (p *YCbCr) At(x, y int) color.Color</pre> <h3 id=\"YCbCr.Bounds\">func (*YCbCr) <a href=\"https://golang.org/src/image/ycbcr.go?s=2050:2084#L56\">Bounds</a>  </h3> <pre data-language=\"go\">func (p *YCbCr) Bounds() Rectangle</pre> <h3 id=\"YCbCr.COffset\">func (*YCbCr) <a href=\"https://golang.org/src/image/ycbcr.go?s=2693:2730#L85\">COffset</a>  </h3> <pre data-language=\"go\">func (p *YCbCr) COffset(x, y int) int</pre> <p> COffset returns the index of the first element of Cb or Cr that corresponds to the pixel at (x, y). </p> <h3 id=\"YCbCr.ColorModel\">func (*YCbCr) <a href=\"https://golang.org/src/image/ycbcr.go?s=1979:2019#L52\">ColorModel</a>  </h3> <pre data-language=\"go\">func (p *YCbCr) ColorModel() color.Model</pre> <h3 id=\"YCbCr.Opaque\">func (*YCbCr) <a href=\"https://golang.org/src/image/ycbcr.go?s=4122:4151#L127\">Opaque</a>  </h3> <pre data-language=\"go\">func (p *YCbCr) Opaque() bool</pre> <h3 id=\"YCbCr.SubImage\">func (*YCbCr) <a href=\"https://golang.org/src/image/ycbcr.go?s=3468:3511#L104\">SubImage</a>  </h3> <pre data-language=\"go\">func (p *YCbCr) SubImage(r Rectangle) Image</pre> <p> SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p> <h3 id=\"YCbCr.YCbCrAt\">func (*YCbCr) <a href=\"https://golang.org/src/image/ycbcr.go?s=2175:2220#L64\">YCbCrAt</a>  </h3> <pre data-language=\"go\">func (p *YCbCr) YCbCrAt(x, y int) color.YCbCr</pre> <h3 id=\"YCbCr.YOffset\">func (*YCbCr) <a href=\"https://golang.org/src/image/ycbcr.go?s=2488:2525#L79\">YOffset</a>  </h3> <pre data-language=\"go\">func (p *YCbCr) YOffset(x, y int) int</pre> <p> YOffset returns the index of the first element of Y that corresponds to the pixel at (x, y). </p> <h2 id=\"YCbCrSubsampleRatio\">type YCbCrSubsampleRatio  </h2> <pre data-language=\"go\">type YCbCrSubsampleRatio int</pre> <p> YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image. </p> <pre data-language=\"go\">const (\n        YCbCrSubsampleRatio444 YCbCrSubsampleRatio = iota\n        YCbCrSubsampleRatio422\n        YCbCrSubsampleRatio420\n        YCbCrSubsampleRatio440\n        YCbCrSubsampleRatio411\n        YCbCrSubsampleRatio410\n)</pre> <h3 id=\"YCbCrSubsampleRatio.String\">func (YCbCrSubsampleRatio) <a href=\"https://golang.org/src/image/ycbcr.go?s=490:534#L13\">String</a>  </h3> <pre data-language=\"go\">func (s YCbCrSubsampleRatio) String() string</pre> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"color/index\">color</a> </td> <td class=\"pkg-synopsis\"> Package color implements a basic color library. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"color/palette/index\">palette</a> </td> <td class=\"pkg-synopsis\"> Package palette provides standard color palettes. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"draw/index\">draw</a> </td> <td class=\"pkg-synopsis\"> Package draw provides image composition functions. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"gif/index\">gif</a> </td> <td class=\"pkg-synopsis\"> Package gif implements a GIF image decoder and encoder. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"jpeg/index\">jpeg</a> </td> <td class=\"pkg-synopsis\"> Package jpeg implements a JPEG image decoder and encoder. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"png/index\">png</a> </td> <td class=\"pkg-synopsis\"> Package png implements a PNG image decoder and encoder. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/image/\" class=\"_attribution-link\">https://golang.org/pkg/image/</a>\n  </p>\n</div>\n","runtime/debug/index":"<h1>Package debug</h1>     <ul id=\"short-nav\">\n<li><code>import \"runtime/debug\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package debug contains facilities for programs to debug themselves while they are running. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#FreeOSMemory\">func FreeOSMemory()</a></li>\n<li><a href=\"#PrintStack\">func PrintStack()</a></li>\n<li><a href=\"#ReadGCStats\">func ReadGCStats(stats *GCStats)</a></li>\n<li><a href=\"#SetGCPercent\">func SetGCPercent(percent int) int</a></li>\n<li><a href=\"#SetMaxStack\">func SetMaxStack(bytes int) int</a></li>\n<li><a href=\"#SetMaxThreads\">func SetMaxThreads(threads int) int</a></li>\n<li><a href=\"#SetPanicOnFault\">func SetPanicOnFault(enabled bool) bool</a></li>\n<li><a href=\"#SetTraceback\">func SetTraceback(level string)</a></li>\n<li><a href=\"#Stack\">func Stack() []byte</a></li>\n<li><a href=\"#WriteHeapDump\">func WriteHeapDump(fd uintptr)</a></li>\n<li><a href=\"#GCStats\">type GCStats</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/runtime/debug/garbage.go\">garbage.go</a> <a href=\"https://golang.org/src/runtime/debug/stack.go\">stack.go</a> <a href=\"https://golang.org/src/runtime/debug/stubs.go\">stubs.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"FreeOSMemory\">func FreeOSMemory  </h2> <pre data-language=\"go\">func FreeOSMemory()</pre> <p> FreeOSMemory forces a garbage collection followed by an attempt to return as much memory to the operating system as possible. (Even if this is not called, the runtime gradually returns memory to the operating system in a background task.) </p> <h2 id=\"PrintStack\">func PrintStack  </h2> <pre data-language=\"go\">func PrintStack()</pre> <p> PrintStack prints to standard error the stack trace returned by runtime.Stack. </p> <h2 id=\"ReadGCStats\">func ReadGCStats  </h2> <pre data-language=\"go\">func ReadGCStats(stats *GCStats)</pre> <p> ReadGCStats reads statistics about garbage collection into stats. The number of entries in the pause history is system-dependent; stats.Pause slice will be reused if large enough, reallocated otherwise. ReadGCStats may use the full capacity of the stats.Pause slice. If stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles summarizing the distribution of pause time. For example, if len(stats.PauseQuantiles) is 5, it will be filled with the minimum, 25%, 50%, 75%, and maximum pause times. </p> <h2 id=\"SetGCPercent\">func SetGCPercent  </h2> <pre data-language=\"go\">func SetGCPercent(percent int) int</pre> <p> SetGCPercent sets the garbage collection target percentage: a collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. SetGCPercent returns the previous setting. The initial setting is the value of the GOGC environment variable at startup, or 100 if the variable is not set. A negative percentage disables garbage collection. </p> <h2 id=\"SetMaxStack\">func SetMaxStack  </h2> <pre data-language=\"go\">func SetMaxStack(bytes int) int</pre> <p> SetMaxStack sets the maximum amount of memory that can be used by a single goroutine stack. If any goroutine exceeds this limit while growing its stack, the program crashes. SetMaxStack returns the previous setting. The initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems. </p> <p> SetMaxStack is useful mainly for limiting the damage done by goroutines that enter an infinite recursion. It only limits future stack growth. </p> <h2 id=\"SetMaxThreads\">func SetMaxThreads  </h2> <pre data-language=\"go\">func SetMaxThreads(threads int) int</pre> <p> SetMaxThreads sets the maximum number of operating system threads that the Go program can use. If it attempts to use more than this many, the program crashes. SetMaxThreads returns the previous setting. The initial setting is 10,000 threads. </p> <p> The limit controls the number of operating system threads, not the number of goroutines. A Go program creates a new thread only when a goroutine is ready to run but all the existing threads are blocked in system calls, cgo calls, or are locked to other goroutines due to use of runtime.LockOSThread. </p> <p> SetMaxThreads is useful mainly for limiting the damage done by programs that create an unbounded number of threads. The idea is to take down the program before it takes down the operating system. </p> <h2 id=\"SetPanicOnFault\">func SetPanicOnFault  </h2> <pre data-language=\"go\">func SetPanicOnFault(enabled bool) bool</pre> <p> SetPanicOnFault controls the runtime's behavior when a program faults at an unexpected (non-nil) address. Such faults are typically caused by bugs such as runtime memory corruption, so the default response is to crash the program. Programs working with memory-mapped files or unsafe manipulation of memory may cause faults at non-nil addresses in less dramatic situations; SetPanicOnFault allows such programs to request that the runtime trigger only a panic, not a crash. SetPanicOnFault applies only to the current goroutine. It returns the previous setting. </p> <h2 id=\"SetTraceback\">func SetTraceback  </h2> <pre data-language=\"go\">func SetTraceback(level string)</pre> <p> SetTraceback sets the amount of detail printed by the runtime in the traceback it prints before exiting due to an unrecovered panic or an internal runtime error. The level argument takes the same values as the GOTRACEBACK environment variable. For example, SetTraceback(\"all\") ensure that the program prints all goroutines when it crashes. See the package runtime documentation for details. If SetTraceback is called with a level lower than that of the environment variable, the call is ignored. </p> <h2 id=\"Stack\">func Stack  </h2> <pre data-language=\"go\">func Stack() []byte</pre> <p> Stack returns a formatted stack trace of the goroutine that calls it. It calls runtime.Stack with a large enough buffer to capture the entire trace. </p> <h2 id=\"WriteHeapDump\">func WriteHeapDump  </h2> <pre data-language=\"go\">func WriteHeapDump(fd uintptr)</pre> <p> WriteHeapDump writes a description of the heap and the objects in it to the given file descriptor. </p> <p> WriteHeapDump suspends the execution of all goroutines until the heap dump is completely written. Thus, the file descriptor must not be connected to a pipe or socket whose other end is in the same Go process; instead, use a temporary file or network socket. </p> <p> The heap dump format is defined at <a href=\"https://golang.org/s/go15heapdump\">https://golang.org/s/go15heapdump</a>. </p> <h2 id=\"GCStats\">type GCStats  </h2> <pre data-language=\"go\">type GCStats struct {\n        LastGC         time.Time       // time of last collection\n        NumGC          int64           // number of garbage collections\n        PauseTotal     time.Duration   // total pause for all collections\n        Pause          []time.Duration // pause history, most recent first\n        PauseEnd       []time.Time     // pause end times history, most recent first\n        PauseQuantiles []time.Duration\n}</pre> <p> GCStats collect information about recent garbage collections. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/runtime/debug/\" class=\"_attribution-link\">https://golang.org/pkg/runtime/debug/</a>\n  </p>\n</div>\n","runtime/pprof/index":"<h1>Package pprof</h1>     <ul id=\"short-nav\">\n<li><code>import \"runtime/pprof\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package pprof writes runtime profiling data in the format expected by the pprof visualization tool. </p> <h3 id=\"hdr-Profiling_a_Go_program\">Profiling a Go program</h3> <p> The first step to profiling a Go program is to enable profiling. Support for profiling benchmarks built with the standard testing package is built into go test. For example, the following command runs benchmarks in the current directory and writes the CPU and memory profiles to cpu.prof and mem.prof: </p> <pre data-language=\"go\">go test -cpuprofile cpu.prof -memprofile mem.prof -bench .\n</pre> <p> To add equivalent profiling support to a standalone program, add code like the following to your main function: </p> <pre data-language=\"go\">var cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile `file`\")\nvar memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to `file`\")\n\nfunc main() {\n    flag.Parse()\n    if *cpuprofile != \"\" {\n        f, err := os.Create(*cpuprofile)\n        if err != nil {\n            log.Fatal(\"could not create CPU profile: \", err)\n        }\n        if err := pprof.StartCPUProfile(f); err != nil {\n            log.Fatal(\"could not start CPU profile: \", err)\n        }\n        defer pprof.StopCPUProfile()\n    }\n    ...\n    if *memprofile != \"\" {\n        f, err := os.Create(*memprofile)\n        if err != nil {\n            log.Fatal(\"could not create memory profile: \", err)\n        }\n        runtime.GC() // get up-to-date statistics\n        if err := pprof.WriteHeapProfile(f); err != nil {\n            log.Fatal(\"could not write memory profile: \", err)\n        }\n        f.Close()\n    }\n}\n</pre> <p> There is also a standard HTTP interface to profiling data. Adding the following line will install handlers under the /debug/pprof/ URL to download live profiles: </p> <pre data-language=\"go\">import _ \"net/http/pprof\"\n</pre> <p> See the net/http/pprof package for more details. </p> <p> Profiles can then be visualized with the pprof tool: </p> <pre data-language=\"go\">go tool pprof cpu.prof\n</pre> <p> There are many commands available from the pprof command line. Commonly used commands include \"top\", which prints a summary of the top program hot-spots, and \"web\", which opens an interactive graph of hot-spots and their call graphs. Use \"help\" for information on all pprof commands. </p> <p> For more information about pprof, see <a href=\"https://github.com/google/pprof/blob/master/doc/pprof.md\">https://github.com/google/pprof/blob/master/doc/pprof.md</a>. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Profiles\">func Profiles() []*Profile</a></li>\n<li><a href=\"#StartCPUProfile\">func StartCPUProfile(w io.Writer) error</a></li>\n<li><a href=\"#StopCPUProfile\">func StopCPUProfile()</a></li>\n<li><a href=\"#WriteHeapProfile\">func WriteHeapProfile(w io.Writer) error</a></li>\n<li><a href=\"#Profile\">type Profile</a></li>\n<li> <a href=\"#Lookup\">func Lookup(name string) *Profile</a>\n</li>\n<li> <a href=\"#NewProfile\">func NewProfile(name string) *Profile</a>\n</li>\n<li> <a href=\"#Profile.Add\">func (p *Profile) Add(value interface{}, skip int)</a>\n</li>\n<li> <a href=\"#Profile.Count\">func (p *Profile) Count() int</a>\n</li>\n<li> <a href=\"#Profile.Name\">func (p *Profile) Name() string</a>\n</li>\n<li> <a href=\"#Profile.Remove\">func (p *Profile) Remove(value interface{})</a>\n</li>\n<li> <a href=\"#Profile.WriteTo\">func (p *Profile) WriteTo(w io.Writer, debug int) error</a>\n</li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/runtime/pprof/pprof.go\">pprof.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Profiles\">func Profiles  </h2> <pre data-language=\"go\">func Profiles() []*Profile</pre> <p> Profiles returns a slice of all the known profiles, sorted by name. </p> <h2 id=\"StartCPUProfile\">func StartCPUProfile  </h2> <pre data-language=\"go\">func StartCPUProfile(w io.Writer) error</pre> <p> StartCPUProfile enables CPU profiling for the current process. While profiling, the profile will be buffered and written to w. StartCPUProfile returns an error if profiling is already enabled. </p> <p> On Unix-like systems, StartCPUProfile does not work by default for Go code built with -buildmode=c-archive or -buildmode=c-shared. StartCPUProfile relies on the SIGPROF signal, but that signal will be delivered to the main program's SIGPROF signal handler (if any) not to the one used by Go. To make it work, call os/signal.Notify for syscall.SIGPROF, but note that doing so may break any profiling being done by the main program. </p> <h2 id=\"StopCPUProfile\">func StopCPUProfile  </h2> <pre data-language=\"go\">func StopCPUProfile()</pre> <p> StopCPUProfile stops the current CPU profile, if any. StopCPUProfile only returns after all the writes for the profile have completed. </p> <h2 id=\"WriteHeapProfile\">func WriteHeapProfile  </h2> <pre data-language=\"go\">func WriteHeapProfile(w io.Writer) error</pre> <p> WriteHeapProfile is shorthand for Lookup(\"heap\").WriteTo(w, 0). It is preserved for backwards compatibility. </p> <h2 id=\"Profile\">type Profile  </h2> <pre data-language=\"go\">type Profile struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Profile is a collection of stack traces showing the call sequences that led to instances of a particular event, such as allocation. Packages can create and maintain their own profiles; the most common use is for tracking resources that must be explicitly closed, such as files or network connections. </p> <p> A Profile's methods can be called from multiple goroutines simultaneously. </p> <p> Each Profile has a unique name. A few profiles are predefined: </p> <pre data-language=\"go\">goroutine    - stack traces of all current goroutines\nheap         - a sampling of all heap allocations\nthreadcreate - stack traces that led to the creation of new OS threads\nblock        - stack traces that led to blocking on synchronization primitives\n</pre> <p> These predefined profiles maintain themselves and panic on an explicit Add or Remove method call. </p> <p> The heap profile reports statistics as of the most recently completed garbage collection; it elides more recent allocation to avoid skewing the profile away from live data and toward garbage. If there has been no garbage collection at all, the heap profile reports all known allocations. This exception helps mainly in programs running without garbage collection enabled, usually for debugging purposes. </p> <p> The CPU profile is not available as a Profile. It has a special API, the StartCPUProfile and StopCPUProfile functions, because it streams output to a writer during profiling. </p> <h3 id=\"Lookup\">func <a href=\"https://golang.org/src/runtime/pprof/pprof.go?s=6007:6040#L184\">Lookup</a>  </h3> <pre data-language=\"go\">func Lookup(name string) *Profile</pre> <p> Lookup returns the profile with the given name, or nil if no such profile exists. </p> <h3 id=\"NewProfile\">func <a href=\"https://golang.org/src/runtime/pprof/pprof.go?s=5581:5618#L166\">NewProfile</a>  </h3> <pre data-language=\"go\">func NewProfile(name string) *Profile</pre> <p> NewProfile creates a new profile with the given name. If a profile with that name already exists, NewProfile panics. The convention is to use a 'import/path.' prefix to create separate name spaces for each package. </p> <h3 id=\"Profile.Add\">func (*Profile) <a href=\"https://golang.org/src/runtime/pprof/pprof.go?s=7723:7773#L243\">Add</a>  </h3> <pre data-language=\"go\">func (p *Profile) Add(value interface{}, skip int)</pre> <p> Add adds the current execution stack to the profile, associated with value. Add stores value in an internal map, so value must be suitable for use as a map key and will not be garbage collected until the corresponding call to Remove. Add panics if the profile already contains a stack for value. </p> <p> The skip parameter has the same meaning as runtime.Caller's skip and controls where the stack trace begins. Passing skip=0 begins the trace in the function calling Add. For example, given this execution stack: </p> <pre data-language=\"go\">Add\ncalled from rpc.NewClient\ncalled from mypkg.Run\ncalled from main.main\n</pre> <p> Passing skip=0 begins the stack trace at the call to Add inside rpc.NewClient. Passing skip=1 begins the stack trace at the call to NewClient inside mypkg.Run. </p> <h3 id=\"Profile.Count\">func (*Profile) <a href=\"https://golang.org/src/runtime/pprof/pprof.go?s=6800:6829#L216\">Count</a>  </h3> <pre data-language=\"go\">func (p *Profile) Count() int</pre> <p> Count returns the number of execution stacks currently in the profile. </p> <h3 id=\"Profile.Name\">func (*Profile) <a href=\"https://golang.org/src/runtime/pprof/pprof.go?s=6674:6705#L211\">Name</a>  </h3> <pre data-language=\"go\">func (p *Profile) Name() string</pre> <p> Name returns this profile's name, which can be passed to Lookup to reobtain the profile. </p> <h3 id=\"Profile.Remove\">func (*Profile) <a href=\"https://golang.org/src/runtime/pprof/pprof.go?s=8262:8305#L264\">Remove</a>  </h3> <pre data-language=\"go\">func (p *Profile) Remove(value interface{})</pre> <p> Remove removes the execution stack associated with value from the profile. It is a no-op if the value is not in the profile. </p> <h3 id=\"Profile.WriteTo\">func (*Profile) <a href=\"https://golang.org/src/runtime/pprof/pprof.go?s=9067:9122#L283\">WriteTo</a>  </h3> <pre data-language=\"go\">func (p *Profile) WriteTo(w io.Writer, debug int) error</pre> <p> WriteTo writes a pprof-formatted snapshot of the profile to w. If a write to w returns an error, WriteTo returns that error. Otherwise, WriteTo returns nil. </p> <p> The debug parameter enables additional output. Passing debug=0 prints only the hexadecimal addresses that pprof needs. Passing debug=1 adds comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools. </p> <p> The predefined profiles may assign meaning to other debug values; for example, when printing the \"goroutine\" profile, debug=2 means to print the goroutine stacks in the same form that a Go program uses when dying due to an unrecovered panic. </p> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/runtime/pprof/pprof.go?s=2756:2911#L75\" style=\"float: left;\">☞</a> <p> Profiles are only as good as the kernel support used to generate them. See <a href=\"https://golang.org/issue/13841\">https://golang.org/issue/13841</a> for details about known problems. </p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/runtime/pprof/\" class=\"_attribution-link\">https://golang.org/pkg/runtime/pprof/</a>\n  </p>\n</div>\n","text/index":"<h1>Directory /src/text</h1>    <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"scanner/index\">scanner</a> </td> <td class=\"pkg-synopsis\"> Package scanner provides a scanner and tokenizer for UTF-8-encoded text. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"tabwriter/index\">tabwriter</a> </td> <td class=\"pkg-synopsis\"> Package tabwriter implements a write filter (tabwriter.Writer) that translates tabbed columns in input into properly aligned text. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"template/index\">template</a> </td> <td class=\"pkg-synopsis\"> Package template implements data-driven templates for generating textual output. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"template/parse/index\">parse</a> </td> <td class=\"pkg-synopsis\"> Package parse builds parse trees for templates as defined by text/template and html/template. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/text/\" class=\"_attribution-link\">https://golang.org/pkg/text/</a>\n  </p>\n</div>\n","regexp/syntax/index":"<h1>Package syntax</h1>     <ul id=\"short-nav\">\n<li><code>import \"regexp/syntax\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package syntax parses regular expressions into parse trees and compiles parse trees into programs. Most clients of regular expressions will use the facilities of package regexp (such as Compile and Match) instead of this package. </p> <h3 id=\"hdr-Syntax\">Syntax</h3> <p> The regular expression syntax understood by this package when parsing with the Perl flag is as follows. Parts of the syntax can be disabled by passing alternate flags to Parse. </p> <p> Single characters: </p> <pre data-language=\"go\">.              any character, possibly including newline (flag s=true)\n[xyz]          character class\n[^xyz]         negated character class\n\\d             Perl character class\n\\D             negated Perl character class\n[[:alpha:]]    ASCII character class\n[[:^alpha:]]   negated ASCII character class\n\\pN            Unicode character class (one-letter name)\n\\p{Greek}      Unicode character class\n\\PN            negated Unicode character class (one-letter name)\n\\P{Greek}      negated Unicode character class\n</pre> <p> Composites: </p> <pre data-language=\"go\">xy             x followed by y\nx|y            x or y (prefer x)\n</pre> <p> Repetitions: </p> <pre data-language=\"go\">x*             zero or more x, prefer more\nx+             one or more x, prefer more\nx?             zero or one x, prefer one\nx{n,m}         n or n+1 or ... or m x, prefer more\nx{n,}          n or more x, prefer more\nx{n}           exactly n x\nx*?            zero or more x, prefer fewer\nx+?            one or more x, prefer fewer\nx??            zero or one x, prefer zero\nx{n,m}?        n or n+1 or ... or m x, prefer fewer\nx{n,}?         n or more x, prefer fewer\nx{n}?          exactly n x\n</pre> <p> Implementation restriction: The counting forms x{n,m}, x{n,}, and x{n} reject forms that create a minimum or maximum repetition count above 1000. Unlimited repetitions are not subject to this restriction. </p> <p> Grouping: </p> <pre data-language=\"go\">(re)           numbered capturing group (submatch)\n(?P&lt;name&gt;re)   named &amp; numbered capturing group (submatch)\n(?:re)         non-capturing group\n(?flags)       set flags within current group; non-capturing\n(?flags:re)    set flags during re; non-capturing\n\nFlag syntax is xyz (set) or -xyz (clear) or xy-z (set xy, clear z). The flags are:\n\ni              case-insensitive (default false)\nm              multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false)\ns              let . match \\n (default false)\nU              ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false)\n</pre> <p> Empty strings: </p> <pre data-language=\"go\">^              at beginning of text or line (flag m=true)\n$              at end of text (like \\z not Perl's \\Z) or line (flag m=true)\n\\A             at beginning of text\n\\b             at ASCII word boundary (\\w on one side and \\W, \\A, or \\z on the other)\n\\B             not at ASCII word boundary\n\\z             at end of text\n</pre> <p> Escape sequences: </p> <pre data-language=\"go\">\\a             bell (== \\007)\n\\f             form feed (== \\014)\n\\t             horizontal tab (== \\011)\n\\n             newline (== \\012)\n\\r             carriage return (== \\015)\n\\v             vertical tab character (== \\013)\n\\*             literal *, for any punctuation character *\n\\123           octal character code (up to three digits)\n\\x7F           hex character code (exactly two digits)\n\\x{10FFFF}     hex character code\n\\Q...\\E        literal text ... even if ... has punctuation\n</pre> <p> Character class elements: </p> <pre data-language=\"go\">x              single character\nA-Z            character range (inclusive)\n\\d             Perl character class\n[:foo:]        ASCII character class foo\n\\p{Foo}        Unicode character class Foo\n\\pF            Unicode character class F (one-letter name)\n</pre> <p> Named character classes as character class elements: </p> <pre data-language=\"go\">[\\d]           digits (== \\d)\n[^\\d]          not digits (== \\D)\n[\\D]           not digits (== \\D)\n[^\\D]          not not digits (== \\d)\n[[:name:]]     named ASCII class inside character class (== [:name:])\n[^[:name:]]    named ASCII class inside negated character class (== [:^name:])\n[\\p{Name}]     named Unicode property inside character class (== \\p{Name})\n[^\\p{Name}]    named Unicode property inside negated character class (== \\P{Name})\n</pre> <p> Perl character classes (all ASCII-only): </p> <pre data-language=\"go\">\\d             digits (== [0-9])\n\\D             not digits (== [^0-9])\n\\s             whitespace (== [\\t\\n\\f\\r ])\n\\S             not whitespace (== [^\\t\\n\\f\\r ])\n\\w             word characters (== [0-9A-Za-z_])\n\\W             not word characters (== [^0-9A-Za-z_])\n</pre> <p> ASCII character classes: </p> <pre data-language=\"go\">[[:alnum:]]    alphanumeric (== [0-9A-Za-z])\n[[:alpha:]]    alphabetic (== [A-Za-z])\n[[:ascii:]]    ASCII (== [\\x00-\\x7F])\n[[:blank:]]    blank (== [\\t ])\n[[:cntrl:]]    control (== [\\x00-\\x1F\\x7F])\n[[:digit:]]    digits (== [0-9])\n[[:graph:]]    graphical (== [!-~] == [A-Za-z0-9!\"#$%&amp;'()*+,\\-./:;&lt;=&gt;?@[\\\\\\]^_`{|}~])\n[[:lower:]]    lower case (== [a-z])\n[[:print:]]    printable (== [ -~] == [ [:graph:]])\n[[:punct:]]    punctuation (== [!-/:-@[-`{-~])\n[[:space:]]    whitespace (== [\\t\\n\\v\\f\\r ])\n[[:upper:]]    upper case (== [A-Z])\n[[:word:]]     word characters (== [0-9A-Za-z_])\n[[:xdigit:]]   hex digit (== [0-9A-Fa-f])\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#IsWordChar\">func IsWordChar(r rune) bool</a></li>\n<li><a href=\"#EmptyOp\">type EmptyOp</a></li>\n<li> <a href=\"#EmptyOpContext\">func EmptyOpContext(r1, r2 rune) EmptyOp</a>\n</li>\n<li><a href=\"#Error\">type Error</a></li>\n<li> <a href=\"#Error.Error\">func (e *Error) Error() string</a>\n</li>\n<li><a href=\"#ErrorCode\">type ErrorCode</a></li>\n<li> <a href=\"#ErrorCode.String\">func (e ErrorCode) String() string</a>\n</li>\n<li><a href=\"#Flags\">type Flags</a></li>\n<li><a href=\"#Inst\">type Inst</a></li>\n<li> <a href=\"#Inst.MatchEmptyWidth\">func (i *Inst) MatchEmptyWidth(before rune, after rune) bool</a>\n</li>\n<li> <a href=\"#Inst.MatchRune\">func (i *Inst) MatchRune(r rune) bool</a>\n</li>\n<li> <a href=\"#Inst.MatchRunePos\">func (i *Inst) MatchRunePos(r rune) int</a>\n</li>\n<li> <a href=\"#Inst.String\">func (i *Inst) String() string</a>\n</li>\n<li><a href=\"#InstOp\">type InstOp</a></li>\n<li> <a href=\"#InstOp.String\">func (i InstOp) String() string</a>\n</li>\n<li><a href=\"#Op\">type Op</a></li>\n<li><a href=\"#Prog\">type Prog</a></li>\n<li> <a href=\"#Compile\">func Compile(re *Regexp) (*Prog, error)</a>\n</li>\n<li> <a href=\"#Prog.Prefix\">func (p *Prog) Prefix() (prefix string, complete bool)</a>\n</li>\n<li> <a href=\"#Prog.StartCond\">func (p *Prog) StartCond() EmptyOp</a>\n</li>\n<li> <a href=\"#Prog.String\">func (p *Prog) String() string</a>\n</li>\n<li><a href=\"#Regexp\">type Regexp</a></li>\n<li> <a href=\"#Parse\">func Parse(s string, flags Flags) (*Regexp, error)</a>\n</li>\n<li> <a href=\"#Regexp.CapNames\">func (re *Regexp) CapNames() []string</a>\n</li>\n<li> <a href=\"#Regexp.Equal\">func (x *Regexp) Equal(y *Regexp) bool</a>\n</li>\n<li> <a href=\"#Regexp.MaxCap\">func (re *Regexp) MaxCap() int</a>\n</li>\n<li> <a href=\"#Regexp.Simplify\">func (re *Regexp) Simplify() *Regexp</a>\n</li>\n<li> <a href=\"#Regexp.String\">func (re *Regexp) String() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/regexp/syntax/compile.go\">compile.go</a> <a href=\"https://golang.org/src/regexp/syntax/doc.go\">doc.go</a> <a href=\"https://golang.org/src/regexp/syntax/parse.go\">parse.go</a> <a href=\"https://golang.org/src/regexp/syntax/perl_groups.go\">perl_groups.go</a> <a href=\"https://golang.org/src/regexp/syntax/prog.go\">prog.go</a> <a href=\"https://golang.org/src/regexp/syntax/regexp.go\">regexp.go</a> <a href=\"https://golang.org/src/regexp/syntax/simplify.go\">simplify.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"IsWordChar\">func IsWordChar  </h2> <pre data-language=\"go\">func IsWordChar(r rune) bool</pre> <p> IsWordChar reports whether r is consider a “word character” during the evaluation of the \\b and \\B zero-width assertions. These assertions are ASCII-only: the word characters are [A-Za-z0-9_]. </p> <h2 id=\"EmptyOp\">type EmptyOp  </h2> <pre data-language=\"go\">type EmptyOp uint8</pre> <p> An EmptyOp specifies a kind or mixture of zero-width assertions. </p> <pre data-language=\"go\">const (\n        EmptyBeginLine EmptyOp = 1 &lt;&lt; iota\n        EmptyEndLine\n        EmptyBeginText\n        EmptyEndText\n        EmptyWordBoundary\n        EmptyNoWordBoundary\n)</pre> <h3 id=\"EmptyOpContext\">func <a href=\"https://golang.org/src/regexp/syntax/prog.go?s=1501:1541#L69\">EmptyOpContext</a>  </h3> <pre data-language=\"go\">func EmptyOpContext(r1, r2 rune) EmptyOp</pre> <p> EmptyOpContext returns the zero-width assertions satisfied at the position between the runes r1 and r2. Passing r1 == -1 indicates that the position is at the beginning of the text. Passing r2 == -1 indicates that the position is at the end of the text. </p> <h2 id=\"Error\">type Error  </h2> <pre data-language=\"go\">type Error struct {\n        Code ErrorCode\n        Expr string\n}</pre> <p> An Error describes a failure to parse a regular expression and gives the offending expression. </p> <h3 id=\"Error.Error\">func (*Error) <a href=\"https://golang.org/src/regexp/syntax/parse.go?s=387:417#L11\">Error</a>  </h3> <pre data-language=\"go\">func (e *Error) Error() string</pre> <h2 id=\"ErrorCode\">type ErrorCode  </h2> <pre data-language=\"go\">type ErrorCode string</pre> <p> An ErrorCode describes a failure to parse a regular expression. </p> <pre data-language=\"go\">const (\n        // Unexpected error\n        ErrInternalError ErrorCode = \"regexp/syntax: internal error\"\n\n        // Parse errors\n        ErrInvalidCharClass      ErrorCode = \"invalid character class\"\n        ErrInvalidCharRange      ErrorCode = \"invalid character class range\"\n        ErrInvalidEscape         ErrorCode = \"invalid escape sequence\"\n        ErrInvalidNamedCapture   ErrorCode = \"invalid named capture\"\n        ErrInvalidPerlOp         ErrorCode = \"invalid or unsupported Perl syntax\"\n        ErrInvalidRepeatOp       ErrorCode = \"invalid nested repetition operator\"\n        ErrInvalidRepeatSize     ErrorCode = \"invalid repeat count\"\n        ErrInvalidUTF8           ErrorCode = \"invalid UTF-8\"\n        ErrMissingBracket        ErrorCode = \"missing closing ]\"\n        ErrMissingParen          ErrorCode = \"missing closing )\"\n        ErrMissingRepeatArgument ErrorCode = \"missing argument to repetition operator\"\n        ErrTrailingBackslash     ErrorCode = \"trailing backslash at end of expression\"\n        ErrUnexpectedParen       ErrorCode = \"unexpected )\"\n)</pre> <h3 id=\"ErrorCode.String\">func (ErrorCode) <a href=\"https://golang.org/src/regexp/syntax/parse.go?s=1553:1587#L38\">String</a>  </h3> <pre data-language=\"go\">func (e ErrorCode) String() string</pre> <h2 id=\"Flags\">type Flags  </h2> <pre data-language=\"go\">type Flags uint16</pre> <p> Flags control the behavior of the parser and record information about regexp context. </p> <pre data-language=\"go\">const (\n        FoldCase      Flags = 1 &lt;&lt; iota // case-insensitive match\n        Literal                         // treat pattern as literal string\n        ClassNL                         // allow character classes like [^a-z] and [[:space:]] to match newline\n        DotNL                           // allow . to match newline\n        OneLine                         // treat ^ and $ as only matching at beginning and end of text\n        NonGreedy                       // make repetition operators default to non-greedy\n        PerlX                           // allow Perl extensions\n        UnicodeGroups                   // allow \\p{Han}, \\P{Han} for Unicode group and negation\n        WasDollar                       // regexp OpEndText was $, not \\z\n        Simple                          // regexp contains no counted repetition\n\n        MatchNL = ClassNL | DotNL\n\n        Perl        = ClassNL | OneLine | PerlX | UnicodeGroups // as close to Perl as possible\n        POSIX Flags = 0                                         // POSIX syntax\n)</pre> <h2 id=\"Inst\">type Inst  </h2> <pre data-language=\"go\">type Inst struct {\n        Op   InstOp\n        Out  uint32 // all but InstMatch, InstFail\n        Arg  uint32 // InstAlt, InstAltMatch, InstCapture, InstEmptyWidth\n        Rune []rune\n}</pre> <p> An Inst is a single instruction in a regular expression program. </p> <h3 id=\"Inst.MatchEmptyWidth\">func (*Inst) <a href=\"https://golang.org/src/regexp/syntax/prog.go?s=5958:6018#L252\">MatchEmptyWidth</a>  </h3> <pre data-language=\"go\">func (i *Inst) MatchEmptyWidth(before rune, after rune) bool</pre> <p> MatchEmptyWidth reports whether the instruction matches an empty string between the runes before and after. It should only be called when i.Op == InstEmptyWidth. </p> <h3 id=\"Inst.MatchRune\">func (*Inst) <a href=\"https://golang.org/src/regexp/syntax/prog.go?s=4332:4369#L184\">MatchRune</a>  </h3> <pre data-language=\"go\">func (i *Inst) MatchRune(r rune) bool</pre> <p> MatchRune reports whether the instruction matches (and consumes) r. It should only be called when i.Op == InstRune. </p> <h3 id=\"Inst.MatchRunePos\">func (*Inst) <a href=\"https://golang.org/src/regexp/syntax/prog.go?s=4697:4736#L193\">MatchRunePos</a>  </h3> <pre data-language=\"go\">func (i *Inst) MatchRunePos(r rune) int</pre> <p> MatchRunePos checks whether the instruction matches (and consumes) r. If so, MatchRunePos returns the index of the matching rune pair (or, when len(i.Rune) == 1, rune singleton). If not, MatchRunePos returns -1. MatchRunePos should only be called when i.Op == InstRune. </p> <h3 id=\"Inst.String\">func (*Inst) <a href=\"https://golang.org/src/regexp/syntax/prog.go?s=6433:6463#L270\">String</a>  </h3> <pre data-language=\"go\">func (i *Inst) String() string</pre> <h2 id=\"InstOp\">type InstOp  </h2> <pre data-language=\"go\">type InstOp uint8</pre> <p> An InstOp is an instruction opcode. </p> <pre data-language=\"go\">const (\n        InstAlt InstOp = iota\n        InstAltMatch\n        InstCapture\n        InstEmptyWidth\n        InstMatch\n        InstFail\n        InstNop\n        InstRune\n        InstRune1\n        InstRuneAny\n        InstRuneAnyNotNL\n)</pre> <h3 id=\"InstOp.String\">func (InstOp) <a href=\"https://golang.org/src/regexp/syntax/prog.go?s=895:926#L44\">String</a>  </h3> <pre data-language=\"go\">func (i InstOp) String() string</pre> <h2 id=\"Op\">type Op  </h2> <pre data-language=\"go\">type Op uint8</pre> <p> An Op is a single regular expression operator. </p> <pre data-language=\"go\">const (\n        OpNoMatch        Op = 1 + iota // matches no strings\n        OpEmptyMatch                   // matches empty string\n        OpLiteral                      // matches Runes sequence\n        OpCharClass                    // matches Runes interpreted as range pair list\n        OpAnyCharNotNL                 // matches any character except newline\n        OpAnyChar                      // matches any character\n        OpBeginLine                    // matches empty string at beginning of line\n        OpEndLine                      // matches empty string at end of line\n        OpBeginText                    // matches empty string at beginning of text\n        OpEndText                      // matches empty string at end of text\n        OpWordBoundary                 // matches word boundary `\\b`\n        OpNoWordBoundary               // matches word non-boundary `\\B`\n        OpCapture                      // capturing subexpression with index Cap, optional name Name\n        OpStar                         // matches Sub[0] zero or more times\n        OpPlus                         // matches Sub[0] one or more times\n        OpQuest                        // matches Sub[0] zero or one times\n        OpRepeat                       // matches Sub[0] at least Min times, at most Max (Max == -1 is no limit)\n        OpConcat                       // matches concatenation of Subs\n        OpAlternate                    // matches alternation of Subs\n)</pre> <h2 id=\"Prog\">type Prog  </h2> <pre data-language=\"go\">type Prog struct {\n        Inst   []Inst\n        Start  int // index of start instruction\n        NumCap int // number of InstCapture insts in re\n}</pre> <p> A Prog is a compiled regular expression program. </p> <h3 id=\"Compile\">func <a href=\"https://golang.org/src/regexp/syntax/compile.go?s=1852:1891#L70\">Compile</a>  </h3> <pre data-language=\"go\">func Compile(re *Regexp) (*Prog, error)</pre> <p> Compile compiles the regexp into a program to be executed. The regexp should have been simplified already (returned from re.Simplify). </p> <h3 id=\"Prog.Prefix\">func (*Prog) <a href=\"https://golang.org/src/regexp/syntax/prog.go?s=3258:3312#L139\">Prefix</a>  </h3> <pre data-language=\"go\">func (p *Prog) Prefix() (prefix string, complete bool)</pre> <p> Prefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match. </p> <h3 id=\"Prog.StartCond\">func (*Prog) <a href=\"https://golang.org/src/regexp/syntax/prog.go?s=3858:3892#L158\">StartCond</a>  </h3> <pre data-language=\"go\">func (p *Prog) StartCond() EmptyOp</pre> <p> StartCond returns the leading empty-width conditions that must be true in any match. It returns ^EmptyOp(0) if no matches are possible. </p> <h3 id=\"Prog.String\">func (*Prog) <a href=\"https://golang.org/src/regexp/syntax/prog.go?s=2563:2593#L109\">String</a>  </h3> <pre data-language=\"go\">func (p *Prog) String() string</pre> <h2 id=\"Regexp\">type Regexp  </h2> <pre data-language=\"go\">type Regexp struct {\n        Op       Op // operator\n        Flags    Flags\n        Sub      []*Regexp  // subexpressions, if any\n        Sub0     [1]*Regexp // storage for short Sub\n        Rune     []rune     // matched runes, for OpLiteral, OpCharClass\n        Rune0    [2]rune    // storage for short Rune\n        Min, Max int        // min, max for OpRepeat\n        Cap      int        // capturing index, for OpCapture\n        Name     string     // capturing name, for OpCapture\n}</pre> <p> A Regexp is a node in a regular expression syntax tree. </p> <h3 id=\"Parse\">func <a href=\"https://golang.org/src/regexp/syntax/parse.go?s=19259:19309#L691\">Parse</a>  </h3> <pre data-language=\"go\">func Parse(s string, flags Flags) (*Regexp, error)</pre> <p> Parse parses a regular expression string s, controlled by the specified Flags, and returns a regular expression parse tree. The syntax is described in the top-level comment. </p> <h3 id=\"Regexp.CapNames\">func (*Regexp) <a href=\"https://golang.org/src/regexp/syntax/regexp.go?s=7513:7550#L296\">CapNames</a>  </h3> <pre data-language=\"go\">func (re *Regexp) CapNames() []string</pre> <p> CapNames walks the regexp to find the names of capturing groups. </p> <h3 id=\"Regexp.Equal\">func (*Regexp) <a href=\"https://golang.org/src/regexp/syntax/regexp.go?s=2524:2562#L52\">Equal</a>  </h3> <pre data-language=\"go\">func (x *Regexp) Equal(y *Regexp) bool</pre> <p> Equal returns true if x and y have identical structure. </p> <h3 id=\"Regexp.MaxCap\">func (*Regexp) <a href=\"https://golang.org/src/regexp/syntax/regexp.go?s=7272:7302#L282\">MaxCap</a>  </h3> <pre data-language=\"go\">func (re *Regexp) MaxCap() int</pre> <p> MaxCap walks the regexp to find the maximum capture index. </p> <h3 id=\"Regexp.Simplify\">func (*Regexp) <a href=\"https://golang.org/src/regexp/syntax/simplify.go?s=690:726#L4\">Simplify</a>  </h3> <pre data-language=\"go\">func (re *Regexp) Simplify() *Regexp</pre> <p> Simplify returns a regexp equivalent to re but without counted repetitions and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/. The resulting regexp will execute correctly but its string representation will not produce the same parse tree, because capturing parentheses may have been duplicated or removed. For example, the simplified form for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1. The returned regexp may share structure with or be the original. </p> <h3 id=\"Regexp.String\">func (*Regexp) <a href=\"https://golang.org/src/regexp/syntax/regexp.go?s=6419:6452#L235\">String</a>  </h3> <pre data-language=\"go\">func (re *Regexp) String() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/regexp/syntax/\" class=\"_attribution-link\">https://golang.org/pkg/regexp/syntax/</a>\n  </p>\n</div>\n","testing/iotest/index":"<h1>Package iotest</h1>     <ul id=\"short-nav\">\n<li><code>import \"testing/iotest\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package iotest implements Readers and Writers useful mainly for testing. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#DataErrReader\">func DataErrReader(r io.Reader) io.Reader</a></li>\n<li><a href=\"#HalfReader\">func HalfReader(r io.Reader) io.Reader</a></li>\n<li><a href=\"#NewReadLogger\">func NewReadLogger(prefix string, r io.Reader) io.Reader</a></li>\n<li><a href=\"#NewWriteLogger\">func NewWriteLogger(prefix string, w io.Writer) io.Writer</a></li>\n<li><a href=\"#OneByteReader\">func OneByteReader(r io.Reader) io.Reader</a></li>\n<li><a href=\"#TimeoutReader\">func TimeoutReader(r io.Reader) io.Reader</a></li>\n<li><a href=\"#TruncateWriter\">func TruncateWriter(w io.Writer, n int64) io.Writer</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/testing/iotest/logger.go\">logger.go</a> <a href=\"https://golang.org/src/testing/iotest/reader.go\">reader.go</a> <a href=\"https://golang.org/src/testing/iotest/writer.go\">writer.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrTimeout = errors.New(\"timeout\")</pre> <h2 id=\"DataErrReader\">func DataErrReader  </h2> <pre data-language=\"go\">func DataErrReader(r io.Reader) io.Reader</pre> <p> DataErrReader changes the way errors are handled by a Reader. Normally, a Reader returns an error (typically EOF) from the first Read call after the last piece of data is read. DataErrReader wraps a Reader and changes its behavior so the final error is returned along with the final data, instead of in the first call after the final data. </p> <h2 id=\"HalfReader\">func HalfReader  </h2> <pre data-language=\"go\">func HalfReader(r io.Reader) io.Reader</pre> <p> HalfReader returns a Reader that implements Read by reading half as many requested bytes from r. </p> <h2 id=\"NewReadLogger\">func NewReadLogger  </h2> <pre data-language=\"go\">func NewReadLogger(prefix string, r io.Reader) io.Reader</pre> <p> NewReadLogger returns a reader that behaves like r except that it logs (using log.Print) each read to standard error, printing the prefix and the hexadecimal data read. </p> <h2 id=\"NewWriteLogger\">func NewWriteLogger  </h2> <pre data-language=\"go\">func NewWriteLogger(prefix string, w io.Writer) io.Writer</pre> <p> NewWriteLogger returns a writer that behaves like w except that it logs (using log.Printf) each write to standard error, printing the prefix and the hexadecimal data written. </p> <h2 id=\"OneByteReader\">func OneByteReader  </h2> <pre data-language=\"go\">func OneByteReader(r io.Reader) io.Reader</pre> <p> OneByteReader returns a Reader that implements each non-empty Read by reading one byte from r. </p> <h2 id=\"TimeoutReader\">func TimeoutReader  </h2> <pre data-language=\"go\">func TimeoutReader(r io.Reader) io.Reader</pre> <p> TimeoutReader returns ErrTimeout on the second read with no data. Subsequent calls to read succeed. </p> <h2 id=\"TruncateWriter\">func TruncateWriter  </h2> <pre data-language=\"go\">func TruncateWriter(w io.Writer, n int64) io.Writer</pre> <p> TruncateWriter returns a Writer that writes to w but stops silently after n bytes. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/testing/iotest/\" class=\"_attribution-link\">https://golang.org/pkg/testing/iotest/</a>\n  </p>\n</div>\n","math/big/index":"<h1>Package big</h1>     <ul id=\"short-nav\">\n<li><code>import \"math/big\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package big implements arbitrary-precision arithmetic (big numbers). The following numeric types are supported: </p> <pre data-language=\"go\">Int    signed integers\nRat    rational numbers\nFloat  floating-point numbers\n</pre> <p> The zero value for an Int, Rat, or Float correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization: </p> <pre data-language=\"go\">var x Int        // &amp;x is an *Int of value 0\nvar r = &amp;Rat{}   // r is a *Rat of value 0\ny := new(Float)  // y is a *Float of value 0\n</pre> <p> Alternatively, new values can be allocated and initialized with factory functions of the form: </p> <pre data-language=\"go\">func NewT(v V) *T\n</pre> <p> For instance, NewInt(x) returns an *Int set to the value of the int64 argument x, NewRat(a, b) returns a *Rat set to the fraction a/b where a and b are int64 values, and NewFloat(f) returns a *Float initialized to the float64 argument f. More flexibility is provided with explicit setters, for instance: </p> <pre data-language=\"go\">var z1 Int\nz1.SetUint64(123)                 // z1 := 123\nz2 := new(Rat).SetFloat64(1.2)    // z2 := 6/5\nz3 := new(Float).SetInt(z1)       // z3 := 123.0\n</pre> <p> Setters, numeric operations and predicates are represented as methods of the form: </p> <pre data-language=\"go\">func (z *T) SetV(v V) *T          // z = v\nfunc (z *T) Unary(x *T) *T        // z = unary x\nfunc (z *T) Binary(x, y *T) *T    // z = x binary y\nfunc (x *T) Pred() P              // p = pred(x)\n</pre> <p> with T one of Int, Rat, or Float. For unary and binary operations, the result is the receiver (usually named z in that case; see below); if it is one of the operands x or y it may be safely overwritten (and its memory reused). </p> <p> Arithmetic expressions are typically written as a sequence of individual method calls, with each call corresponding to an operation. The receiver denotes the result and the method arguments are the operation's operands. For instance, given three *Int values a, b and c, the invocation </p> <pre data-language=\"go\">c.Add(a, b)\n</pre> <p> computes the sum a + b and stores the result in c, overwriting whatever value was held in c before. Unless specified otherwise, operations permit aliasing of parameters, so it is perfectly ok to write </p> <pre data-language=\"go\">sum.Add(sum, x)\n</pre> <p> to accumulate values x in a sum. </p> <p> (By always passing in a result value via the receiver, memory use can be much better controlled. Instead of having to allocate new memory for each result, an operation can reuse the space allocated for the result value, and overwrite that value with the new result in the process.) </p> <p> Notational convention: Incoming method parameters (including the receiver) are named consistently in the API to clarify their use. Incoming operands are usually named x, y, a, b, and so on, but never z. A parameter specifying the result is named z (typically the receiver). </p> <p> For instance, the arguments for (*Int).Add are named x and y, and because the receiver specifies the result destination, it is called z: </p> <pre data-language=\"go\">func (z *Int) Add(x, y *Int) *Int\n</pre> <p> Methods of this form typically return the incoming receiver as well, to enable simple call chaining. </p> <p> Methods which don't require a result value to be passed in (for instance, Int.Sign), simply return the result. In this case, the receiver is typically the first operand, named x: </p> <pre data-language=\"go\">func (x *Int) Sign() int\n</pre> <p> Various methods support conversions between strings and corresponding numeric values, and vice versa: *Int, *Rat, and *Float values implement the Stringer interface for a (default) string representation of the value, but also provide SetString methods to initialize a value from a string in a variety of supported formats (see the respective SetString documentation). </p> <p> Finally, *Int, *Rat, and *Float satisfy the fmt package's Scanner interface for scanning and (except for *Rat) the Formatter interface for formatted printing. </p> </div> </div> <div id=\"example__eConvergents\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (EConvergents)</h2> <p>This example demonstrates how to use big.Rat to compute the first 15 terms in the sequence of rational convergents for the constant e (base of natural logarithm). </p> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n)\n\n// Use the classic continued fraction for e\n//     e = [1; 0, 1, 1, 2, 1, 1, ... 2n, 1, 1, ...]\n// i.e., for the nth term, use\n//     1          if   n mod 3 != 1\n//  (n-1)/3 * 2   if   n mod 3 == 1\nfunc recur(n, lim int64) *big.Rat {\n\tterm := new(big.Rat)\n\tif n%3 != 1 {\n\t\tterm.SetInt64(1)\n\t} else {\n\t\tterm.SetInt64((n - 1) / 3 * 2)\n\t}\n\n\tif n &gt; lim {\n\t\treturn term\n\t}\n\n\t// Directly initialize frac as the fractional\n\t// inverse of the result of recur.\n\tfrac := new(big.Rat).Inv(recur(n+1, lim))\n\n\treturn term.Add(term, frac)\n}\n\n// This example demonstrates how to use big.Rat to compute the\n// first 15 terms in the sequence of rational convergents for\n// the constant e (base of natural logarithm).\nfunc main() {\n\tfor i := 1; i &lt;= 15; i++ {\n\t\tr := recur(0, int64(i))\n\n\t\t// Print r both as a fraction and as a floating-point number.\n\t\t// Since big.Rat implements fmt.Formatter, we can use %-13s to\n\t\t// get a left-aligned string representation of the fraction.\n\t\tfmt.Printf(\"%-13s = %s\\n\", r, r.FloatString(8))\n\t}\n\n}\n</pre> </div> </div> <div id=\"example__fibonacci\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Fibonacci)</h2> <p>This example demonstrates how to use big.Int to compute the smallest Fibonacci number with 100 decimal digits and to test whether it is prime. </p> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n)\n\nfunc main() {\n\t// Initialize two big ints with the first two numbers in the sequence.\n\ta := big.NewInt(0)\n\tb := big.NewInt(1)\n\n\t// Initialize limit as 10^99, the smallest integer with 100 digits.\n\tvar limit big.Int\n\tlimit.Exp(big.NewInt(10), big.NewInt(99), nil)\n\n\t// Loop while a is smaller than 1e100.\n\tfor a.Cmp(&amp;limit) &lt; 0 {\n\t\t// Compute the next Fibonacci number, storing it in a.\n\t\ta.Add(a, b)\n\t\t// Swap a and b so that b is the next number in the sequence.\n\t\ta, b = b, a\n\t}\n\tfmt.Println(a) // 100-digit Fibonacci number\n\n\t// Test a for primality.\n\t// (ProbablyPrimes' argument sets the number of Miller-Rabin\n\t// rounds to be performed. 20 is a good value.)\n\tfmt.Println(a.ProbablyPrime(20))\n\n}\n</pre> </div> </div> <div id=\"example__sqrt2\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Sqrt2)</h2> <p>This example shows how to use big.Float to compute the square root of 2 with a precision of 200 bits, and how to print the result as a decimal number. </p> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n)\n\nfunc main() {\n\t// We'll do computations with 200 bits of precision in the mantissa.\n\tconst prec = 200\n\n\t// Compute the square root of 2 using Newton's Method. We start with\n\t// an initial estimate for sqrt(2), and then iterate:\n\t//     x_{n+1} = 1/2 * ( x_n + (2.0 / x_n) )\n\n\t// Since Newton's Method doubles the number of correct digits at each\n\t// iteration, we need at least log_2(prec) steps.\n\tsteps := int(math.Log2(prec))\n\n\t// Initialize values we need for the computation.\n\ttwo := new(big.Float).SetPrec(prec).SetInt64(2)\n\thalf := new(big.Float).SetPrec(prec).SetFloat64(0.5)\n\n\t// Use 1 as the initial estimate.\n\tx := new(big.Float).SetPrec(prec).SetInt64(1)\n\n\t// We use t as a temporary variable. There's no need to set its precision\n\t// since big.Float values with unset (== 0) precision automatically assume\n\t// the largest precision of the arguments when used as the result (receiver)\n\t// of a big.Float operation.\n\tt := new(big.Float)\n\n\t// Iterate.\n\tfor i := 0; i &lt;= steps; i++ {\n\t\tt.Quo(two, x)  // t = 2.0 / x_n\n\t\tt.Add(x, t)    // t = x_n + (2.0 / x_n)\n\t\tx.Mul(half, t) // x_{n+1} = 0.5 * t\n\t}\n\n\t// We can use the usual fmt.Printf verbs since big.Float implements fmt.Formatter\n\tfmt.Printf(\"sqrt(2) = %.50f\\n\", x)\n\n\t// Print the error between 2 and x*x.\n\tt.Mul(x, x) // t = x*x\n\tfmt.Printf(\"error = %e\\n\", t.Sub(two, t))\n\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#Jacobi\">func Jacobi(x, y *Int) int</a></li>\n<li><a href=\"#Accuracy\">type Accuracy</a></li>\n<li> <a href=\"#Accuracy.String\">func (i Accuracy) String() string</a>\n</li>\n<li><a href=\"#ErrNaN\">type ErrNaN</a></li>\n<li> <a href=\"#ErrNaN.Error\">func (err ErrNaN) Error() string</a>\n</li>\n<li><a href=\"#Float\">type Float</a></li>\n<li> <a href=\"#NewFloat\">func NewFloat(x float64) *Float</a>\n</li>\n<li> <a href=\"#ParseFloat\">func ParseFloat(s string, base int, prec uint, mode RoundingMode) (f *Float, b int, err error)</a>\n</li>\n<li> <a href=\"#Float.Abs\">func (z *Float) Abs(x *Float) *Float</a>\n</li>\n<li> <a href=\"#Float.Acc\">func (x *Float) Acc() Accuracy</a>\n</li>\n<li> <a href=\"#Float.Add\">func (z *Float) Add(x, y *Float) *Float</a>\n</li>\n<li> <a href=\"#Float.Append\">func (x *Float) Append(buf []byte, fmt byte, prec int) []byte</a>\n</li>\n<li> <a href=\"#Float.Cmp\">func (x *Float) Cmp(y *Float) int</a>\n</li>\n<li> <a href=\"#Float.Copy\">func (z *Float) Copy(x *Float) *Float</a>\n</li>\n<li> <a href=\"#Float.Float32\">func (x *Float) Float32() (float32, Accuracy)</a>\n</li>\n<li> <a href=\"#Float.Float64\">func (x *Float) Float64() (float64, Accuracy)</a>\n</li>\n<li> <a href=\"#Float.Format\">func (x *Float) Format(s fmt.State, format rune)</a>\n</li>\n<li> <a href=\"#Float.GobDecode\">func (z *Float) GobDecode(buf []byte) error</a>\n</li>\n<li> <a href=\"#Float.GobEncode\">func (x *Float) GobEncode() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Float.Int\">func (x *Float) Int(z *Int) (*Int, Accuracy)</a>\n</li>\n<li> <a href=\"#Float.Int64\">func (x *Float) Int64() (int64, Accuracy)</a>\n</li>\n<li> <a href=\"#Float.IsInf\">func (x *Float) IsInf() bool</a>\n</li>\n<li> <a href=\"#Float.IsInt\">func (x *Float) IsInt() bool</a>\n</li>\n<li> <a href=\"#Float.MantExp\">func (x *Float) MantExp(mant *Float) (exp int)</a>\n</li>\n<li> <a href=\"#Float.MarshalText\">func (x *Float) MarshalText() (text []byte, err error)</a>\n</li>\n<li> <a href=\"#Float.MinPrec\">func (x *Float) MinPrec() uint</a>\n</li>\n<li> <a href=\"#Float.Mode\">func (x *Float) Mode() RoundingMode</a>\n</li>\n<li> <a href=\"#Float.Mul\">func (z *Float) Mul(x, y *Float) *Float</a>\n</li>\n<li> <a href=\"#Float.Neg\">func (z *Float) Neg(x *Float) *Float</a>\n</li>\n<li> <a href=\"#Float.Parse\">func (z *Float) Parse(s string, base int) (f *Float, b int, err error)</a>\n</li>\n<li> <a href=\"#Float.Prec\">func (x *Float) Prec() uint</a>\n</li>\n<li> <a href=\"#Float.Quo\">func (z *Float) Quo(x, y *Float) *Float</a>\n</li>\n<li> <a href=\"#Float.Rat\">func (x *Float) Rat(z *Rat) (*Rat, Accuracy)</a>\n</li>\n<li> <a href=\"#Float.Set\">func (z *Float) Set(x *Float) *Float</a>\n</li>\n<li> <a href=\"#Float.SetFloat64\">func (z *Float) SetFloat64(x float64) *Float</a>\n</li>\n<li> <a href=\"#Float.SetInf\">func (z *Float) SetInf(signbit bool) *Float</a>\n</li>\n<li> <a href=\"#Float.SetInt\">func (z *Float) SetInt(x *Int) *Float</a>\n</li>\n<li> <a href=\"#Float.SetInt64\">func (z *Float) SetInt64(x int64) *Float</a>\n</li>\n<li> <a href=\"#Float.SetMantExp\">func (z *Float) SetMantExp(mant *Float, exp int) *Float</a>\n</li>\n<li> <a href=\"#Float.SetMode\">func (z *Float) SetMode(mode RoundingMode) *Float</a>\n</li>\n<li> <a href=\"#Float.SetPrec\">func (z *Float) SetPrec(prec uint) *Float</a>\n</li>\n<li> <a href=\"#Float.SetRat\">func (z *Float) SetRat(x *Rat) *Float</a>\n</li>\n<li> <a href=\"#Float.SetString\">func (z *Float) SetString(s string) (*Float, bool)</a>\n</li>\n<li> <a href=\"#Float.SetUint64\">func (z *Float) SetUint64(x uint64) *Float</a>\n</li>\n<li> <a href=\"#Float.Sign\">func (x *Float) Sign() int</a>\n</li>\n<li> <a href=\"#Float.Signbit\">func (x *Float) Signbit() bool</a>\n</li>\n<li> <a href=\"#Float.String\">func (x *Float) String() string</a>\n</li>\n<li> <a href=\"#Float.Sub\">func (z *Float) Sub(x, y *Float) *Float</a>\n</li>\n<li> <a href=\"#Float.Text\">func (x *Float) Text(format byte, prec int) string</a>\n</li>\n<li> <a href=\"#Float.Uint64\">func (x *Float) Uint64() (uint64, Accuracy)</a>\n</li>\n<li> <a href=\"#Float.UnmarshalText\">func (z *Float) UnmarshalText(text []byte) error</a>\n</li>\n<li><a href=\"#Int\">type Int</a></li>\n<li> <a href=\"#NewInt\">func NewInt(x int64) *Int</a>\n</li>\n<li> <a href=\"#Int.Abs\">func (z *Int) Abs(x *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.Add\">func (z *Int) Add(x, y *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.And\">func (z *Int) And(x, y *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.AndNot\">func (z *Int) AndNot(x, y *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.Append\">func (x *Int) Append(buf []byte, base int) []byte</a>\n</li>\n<li> <a href=\"#Int.Binomial\">func (z *Int) Binomial(n, k int64) *Int</a>\n</li>\n<li> <a href=\"#Int.Bit\">func (x *Int) Bit(i int) uint</a>\n</li>\n<li> <a href=\"#Int.BitLen\">func (x *Int) BitLen() int</a>\n</li>\n<li> <a href=\"#Int.Bits\">func (x *Int) Bits() []Word</a>\n</li>\n<li> <a href=\"#Int.Bytes\">func (x *Int) Bytes() []byte</a>\n</li>\n<li> <a href=\"#Int.Cmp\">func (x *Int) Cmp(y *Int) (r int)</a>\n</li>\n<li> <a href=\"#Int.Div\">func (z *Int) Div(x, y *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.DivMod\">func (z *Int) DivMod(x, y, m *Int) (*Int, *Int)</a>\n</li>\n<li> <a href=\"#Int.Exp\">func (z *Int) Exp(x, y, m *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.Format\">func (x *Int) Format(s fmt.State, ch rune)</a>\n</li>\n<li> <a href=\"#Int.GCD\">func (z *Int) GCD(x, y, a, b *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.GobDecode\">func (z *Int) GobDecode(buf []byte) error</a>\n</li>\n<li> <a href=\"#Int.GobEncode\">func (x *Int) GobEncode() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Int.Int64\">func (x *Int) Int64() int64</a>\n</li>\n<li> <a href=\"#Int.Lsh\">func (z *Int) Lsh(x *Int, n uint) *Int</a>\n</li>\n<li> <a href=\"#Int.MarshalJSON\">func (x *Int) MarshalJSON() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Int.MarshalText\">func (x *Int) MarshalText() (text []byte, err error)</a>\n</li>\n<li> <a href=\"#Int.Mod\">func (z *Int) Mod(x, y *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.ModInverse\">func (z *Int) ModInverse(g, n *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.ModSqrt\">func (z *Int) ModSqrt(x, p *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.Mul\">func (z *Int) Mul(x, y *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.MulRange\">func (z *Int) MulRange(a, b int64) *Int</a>\n</li>\n<li> <a href=\"#Int.Neg\">func (z *Int) Neg(x *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.Not\">func (z *Int) Not(x *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.Or\">func (z *Int) Or(x, y *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.ProbablyPrime\">func (x *Int) ProbablyPrime(n int) bool</a>\n</li>\n<li> <a href=\"#Int.Quo\">func (z *Int) Quo(x, y *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.QuoRem\">func (z *Int) QuoRem(x, y, r *Int) (*Int, *Int)</a>\n</li>\n<li> <a href=\"#Int.Rand\">func (z *Int) Rand(rnd *rand.Rand, n *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.Rem\">func (z *Int) Rem(x, y *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.Rsh\">func (z *Int) Rsh(x *Int, n uint) *Int</a>\n</li>\n<li> <a href=\"#Int.Scan\">func (z *Int) Scan(s fmt.ScanState, ch rune) error</a>\n</li>\n<li> <a href=\"#Int.Set\">func (z *Int) Set(x *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.SetBit\">func (z *Int) SetBit(x *Int, i int, b uint) *Int</a>\n</li>\n<li> <a href=\"#Int.SetBits\">func (z *Int) SetBits(abs []Word) *Int</a>\n</li>\n<li> <a href=\"#Int.SetBytes\">func (z *Int) SetBytes(buf []byte) *Int</a>\n</li>\n<li> <a href=\"#Int.SetInt64\">func (z *Int) SetInt64(x int64) *Int</a>\n</li>\n<li> <a href=\"#Int.SetString\">func (z *Int) SetString(s string, base int) (*Int, bool)</a>\n</li>\n<li> <a href=\"#Int.SetUint64\">func (z *Int) SetUint64(x uint64) *Int</a>\n</li>\n<li> <a href=\"#Int.Sign\">func (x *Int) Sign() int</a>\n</li>\n<li> <a href=\"#Int.String\">func (x *Int) String() string</a>\n</li>\n<li> <a href=\"#Int.Sub\">func (z *Int) Sub(x, y *Int) *Int</a>\n</li>\n<li> <a href=\"#Int.Text\">func (x *Int) Text(base int) string</a>\n</li>\n<li> <a href=\"#Int.Uint64\">func (x *Int) Uint64() uint64</a>\n</li>\n<li> <a href=\"#Int.UnmarshalJSON\">func (z *Int) UnmarshalJSON(text []byte) error</a>\n</li>\n<li> <a href=\"#Int.UnmarshalText\">func (z *Int) UnmarshalText(text []byte) error</a>\n</li>\n<li> <a href=\"#Int.Xor\">func (z *Int) Xor(x, y *Int) *Int</a>\n</li>\n<li><a href=\"#Rat\">type Rat</a></li>\n<li> <a href=\"#NewRat\">func NewRat(a, b int64) *Rat</a>\n</li>\n<li> <a href=\"#Rat.Abs\">func (z *Rat) Abs(x *Rat) *Rat</a>\n</li>\n<li> <a href=\"#Rat.Add\">func (z *Rat) Add(x, y *Rat) *Rat</a>\n</li>\n<li> <a href=\"#Rat.Cmp\">func (x *Rat) Cmp(y *Rat) int</a>\n</li>\n<li> <a href=\"#Rat.Denom\">func (x *Rat) Denom() *Int</a>\n</li>\n<li> <a href=\"#Rat.Float32\">func (x *Rat) Float32() (f float32, exact bool)</a>\n</li>\n<li> <a href=\"#Rat.Float64\">func (x *Rat) Float64() (f float64, exact bool)</a>\n</li>\n<li> <a href=\"#Rat.FloatString\">func (x *Rat) FloatString(prec int) string</a>\n</li>\n<li> <a href=\"#Rat.GobDecode\">func (z *Rat) GobDecode(buf []byte) error</a>\n</li>\n<li> <a href=\"#Rat.GobEncode\">func (x *Rat) GobEncode() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Rat.Inv\">func (z *Rat) Inv(x *Rat) *Rat</a>\n</li>\n<li> <a href=\"#Rat.IsInt\">func (x *Rat) IsInt() bool</a>\n</li>\n<li> <a href=\"#Rat.MarshalText\">func (x *Rat) MarshalText() (text []byte, err error)</a>\n</li>\n<li> <a href=\"#Rat.Mul\">func (z *Rat) Mul(x, y *Rat) *Rat</a>\n</li>\n<li> <a href=\"#Rat.Neg\">func (z *Rat) Neg(x *Rat) *Rat</a>\n</li>\n<li> <a href=\"#Rat.Num\">func (x *Rat) Num() *Int</a>\n</li>\n<li> <a href=\"#Rat.Quo\">func (z *Rat) Quo(x, y *Rat) *Rat</a>\n</li>\n<li> <a href=\"#Rat.RatString\">func (x *Rat) RatString() string</a>\n</li>\n<li> <a href=\"#Rat.Scan\">func (z *Rat) Scan(s fmt.ScanState, ch rune) error</a>\n</li>\n<li> <a href=\"#Rat.Set\">func (z *Rat) Set(x *Rat) *Rat</a>\n</li>\n<li> <a href=\"#Rat.SetFloat64\">func (z *Rat) SetFloat64(f float64) *Rat</a>\n</li>\n<li> <a href=\"#Rat.SetFrac\">func (z *Rat) SetFrac(a, b *Int) *Rat</a>\n</li>\n<li> <a href=\"#Rat.SetFrac64\">func (z *Rat) SetFrac64(a, b int64) *Rat</a>\n</li>\n<li> <a href=\"#Rat.SetInt\">func (z *Rat) SetInt(x *Int) *Rat</a>\n</li>\n<li> <a href=\"#Rat.SetInt64\">func (z *Rat) SetInt64(x int64) *Rat</a>\n</li>\n<li> <a href=\"#Rat.SetString\">func (z *Rat) SetString(s string) (*Rat, bool)</a>\n</li>\n<li> <a href=\"#Rat.Sign\">func (x *Rat) Sign() int</a>\n</li>\n<li> <a href=\"#Rat.String\">func (x *Rat) String() string</a>\n</li>\n<li> <a href=\"#Rat.Sub\">func (z *Rat) Sub(x, y *Rat) *Rat</a>\n</li>\n<li> <a href=\"#Rat.UnmarshalText\">func (z *Rat) UnmarshalText(text []byte) error</a>\n</li>\n<li><a href=\"#RoundingMode\">type RoundingMode</a></li>\n<li> <a href=\"#RoundingMode.String\">func (i RoundingMode) String() string</a>\n</li>\n<li><a href=\"#Word\">type Word</a></li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Float_Add\">Float.Add</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Float_Cmp\">Float.Cmp</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Int_Scan\">Int.Scan</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Int_SetString\">Int.SetString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Rat_Scan\">Rat.Scan</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Rat_SetString\">Rat.SetString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_RoundingMode\">RoundingMode</a></dd> <dd><a class=\"exampleLink\" href=\"#example__eConvergents\">Package (EConvergents)</a></dd> <dd><a class=\"exampleLink\" href=\"#example__fibonacci\">Package (Fibonacci)</a></dd> <dd><a class=\"exampleLink\" href=\"#example__sqrt2\">Package (Sqrt2)</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/math/big/accuracy_string.go\">accuracy_string.go</a> <a href=\"https://golang.org/src/math/big/arith.go\">arith.go</a> <a href=\"https://golang.org/src/math/big/arith_decl.go\">arith_decl.go</a> <a href=\"https://golang.org/src/math/big/decimal.go\">decimal.go</a> <a href=\"https://golang.org/src/math/big/doc.go\">doc.go</a> <a href=\"https://golang.org/src/math/big/float.go\">float.go</a> <a href=\"https://golang.org/src/math/big/floatconv.go\">floatconv.go</a> <a href=\"https://golang.org/src/math/big/floatmarsh.go\">floatmarsh.go</a> <a href=\"https://golang.org/src/math/big/ftoa.go\">ftoa.go</a> <a href=\"https://golang.org/src/math/big/int.go\">int.go</a> <a href=\"https://golang.org/src/math/big/intconv.go\">intconv.go</a> <a href=\"https://golang.org/src/math/big/intmarsh.go\">intmarsh.go</a> <a href=\"https://golang.org/src/math/big/nat.go\">nat.go</a> <a href=\"https://golang.org/src/math/big/natconv.go\">natconv.go</a> <a href=\"https://golang.org/src/math/big/rat.go\">rat.go</a> <a href=\"https://golang.org/src/math/big/ratconv.go\">ratconv.go</a> <a href=\"https://golang.org/src/math/big/ratmarsh.go\">ratmarsh.go</a> <a href=\"https://golang.org/src/math/big/roundingmode_string.go\">roundingmode_string.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        MaxExp  = math.MaxInt32  // largest supported exponent\n        MinExp  = math.MinInt32  // smallest supported exponent\n        MaxPrec = math.MaxUint32 // largest (theoretically) supported precision; likely memory-limited\n)</pre> <p> Exponent and precision limits. </p> <pre data-language=\"go\">const MaxBase = 'z' - 'a' + 10 + 1</pre> <p> MaxBase is the largest number base accepted for string conversions. </p> <h2 id=\"Jacobi\">func Jacobi  </h2> <pre data-language=\"go\">func Jacobi(x, y *Int) int</pre> <p> Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0. The y argument must be an odd integer. </p> <h2 id=\"Accuracy\">type Accuracy  </h2> <pre data-language=\"go\">type Accuracy int8</pre> <p> Accuracy describes the rounding error produced by the most recent operation that generated a Float value, relative to the exact value. </p> <pre data-language=\"go\">const (\n        Below Accuracy = -1\n        Exact Accuracy = 0\n        Above Accuracy = +1\n)</pre> <p> Constants describing the Accuracy of a Float. </p> <h3 id=\"Accuracy.String\">func (Accuracy) <a href=\"https://golang.org/src/math/big/accuracy_string.go?s=171:204#L1\">String</a>  </h3> <pre data-language=\"go\">func (i Accuracy) String() string</pre> <h2 id=\"ErrNaN\">type ErrNaN  </h2> <pre data-language=\"go\">type ErrNaN struct {\n        // contains filtered or unexported fields\n}</pre> <p> An ErrNaN panic is raised by a Float operation that would lead to a NaN under IEEE-754 rules. An ErrNaN implements the error interface. </p> <h3 id=\"ErrNaN.Error\">func (ErrNaN) <a href=\"https://golang.org/src/math/big/float.go?s=2929:2961#L64\">Error</a>  </h3> <pre data-language=\"go\">func (err ErrNaN) Error() string</pre> <h2 id=\"Float\">type Float  </h2> <pre data-language=\"go\">type Float struct {\n        // contains filtered or unexported fields\n}</pre> <p> A nonzero finite Float represents a multi-precision floating point number </p> <pre data-language=\"go\">sign × mantissa × 2**exponent\n</pre> <p> with 0.5 &lt;= mantissa &lt; 1.0, and MinExp &lt;= exponent &lt;= MaxExp. A Float may also be zero (+0, -0) or infinite (+Inf, -Inf). All Floats are ordered, and the ordering of two Floats x and y is defined by x.Cmp(y). </p> <p> Each Float value also has a precision, rounding mode, and accuracy. The precision is the maximum number of mantissa bits available to represent the value. The rounding mode specifies how a result should be rounded to fit into the mantissa bits, and accuracy describes the rounding error with respect to the exact result. </p> <p> Unless specified otherwise, all operations (including setters) that specify a *Float variable for the result (usually via the receiver with the exception of MantExp), round the numeric result according to the precision and rounding mode of the result variable. </p> <p> If the provided result precision is 0 (see below), it is set to the precision of the argument with the largest precision value before any rounding takes place, and the rounding mode remains unchanged. Thus, uninitialized Floats provided as result arguments will have their precision set to a reasonable value determined by the operands and their mode is the zero value for RoundingMode (ToNearestEven). </p> <p> By setting the desired precision to 24 or 53 and using matching rounding mode (typically ToNearestEven), Float operations produce the same results as the corresponding float32 or float64 IEEE-754 arithmetic for operands that correspond to normal (i.e., not denormal) float32 or float64 numbers. Exponent underflow and overflow lead to a 0 or an Infinity for different values than IEEE-754 because Float exponents have a much larger range. </p> <p> The zero (uninitialized) value for a Float is ready to use and represents the number +0.0 exactly, with precision 0 and rounding mode ToNearestEven. </p> <h3 id=\"NewFloat\">func <a href=\"https://golang.org/src/math/big/float.go?s=3139:3170#L71\">NewFloat</a>  </h3> <pre data-language=\"go\">func NewFloat(x float64) *Float</pre> <p> NewFloat allocates and returns a new Float set to x, with precision 53 and rounding mode ToNearestEven. NewFloat panics with ErrNaN if x is a NaN. </p> <h3 id=\"ParseFloat\">func <a href=\"https://golang.org/src/math/big/floatconv.go?s=6935:7029#L263\">ParseFloat</a>  </h3> <pre data-language=\"go\">func ParseFloat(s string, base int, prec uint, mode RoundingMode) (f *Float, b int, err error)</pre> <p> ParseFloat is like f.Parse(s, base) with f set to the given precision and rounding mode. </p> <h3 id=\"Float.Abs\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=31351:31387#L1153\">Abs</a>  </h3> <pre data-language=\"go\">func (z *Float) Abs(x *Float) *Float</pre> <p> Abs sets z to the (possibly rounded) value |x| (the absolute value of x) and returns z. </p> <h3 id=\"Float.Acc\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=7444:7474#L211\">Acc</a>  </h3> <pre data-language=\"go\">func (x *Float) Acc() Accuracy</pre> <p> Acc returns the accuracy of x produced by the most recent operation. </p> <h3 id=\"Float.Add\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=38828:38867#L1399\">Add</a>  </h3> <pre data-language=\"go\">func (z *Float) Add(x, y *Float) *Float</pre> <p> Add sets z to the rounded sum x+y and returns z. If z's precision is 0, it is changed to the larger of x's or y's precision before the operation. Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result. Add panics with ErrNaN if x and y are infinities with opposite signs. The value of z is undefined in that case. </p> <p> BUG(gri) When rounding ToNegativeInf, the sign of Float values rounded to 0 is incorrect. </p> <div id=\"example_Float_Add\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n)\n\nfunc main() {\n\t// Operating on numbers of different precision.\n\tvar x, y, z big.Float\n\tx.SetInt64(1000)          // x is automatically set to 64bit precision\n\ty.SetFloat64(2.718281828) // y is automatically set to 53bit precision\n\tz.SetPrec(32)\n\tz.Add(&amp;x, &amp;y)\n\tfmt.Printf(\"x = %.10g (%s, prec = %d, acc = %s)\\n\", &amp;x, x.Text('p', 0), x.Prec(), x.Acc())\n\tfmt.Printf(\"y = %.10g (%s, prec = %d, acc = %s)\\n\", &amp;y, y.Text('p', 0), y.Prec(), y.Acc())\n\tfmt.Printf(\"z = %.10g (%s, prec = %d, acc = %s)\\n\", &amp;z, z.Text('p', 0), z.Prec(), z.Acc())\n}\n</pre> </div> </div> <h3 id=\"Float.Append\">func (*Float) <a href=\"https://golang.org/src/math/big/ftoa.go?s=2243:2304#L49\">Append</a>  </h3> <pre data-language=\"go\">func (x *Float) Append(buf []byte, fmt byte, prec int) []byte</pre> <p> Append appends to buf the string form of the floating-point number x, as generated by x.Text, and returns the extended buffer. </p> <h3 id=\"Float.Cmp\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=43182:43215#L1617\">Cmp</a>  </h3> <pre data-language=\"go\">func (x *Float) Cmp(y *Float) int</pre> <p> Cmp compares x and y and returns: </p> <pre data-language=\"go\">-1 if x &lt;  y\n 0 if x == y (incl. -0 == 0, -Inf == -Inf, and +Inf == +Inf)\n+1 if x &gt;  y\n</pre> <div id=\"example_Float_Cmp\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n)\n\nfunc main() {\n\tinf := math.Inf(1)\n\tzero := 0.0\n\n\toperands := []float64{-inf, -1.2, -zero, 0, +1.2, +inf}\n\n\tfmt.Println(\"   x     y  cmp\")\n\tfmt.Println(\"---------------\")\n\tfor _, x64 := range operands {\n\t\tx := big.NewFloat(x64)\n\t\tfor _, y64 := range operands {\n\t\t\ty := big.NewFloat(y64)\n\t\t\tfmt.Printf(\"%4g  %4g  %3d\\n\", x, y, x.Cmp(y))\n\t\t}\n\t\tfmt.Println()\n\t}\n\n}\n</pre> </div> </div> <h3 id=\"Float.Copy\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=18333:18370#L649\">Copy</a>  </h3> <pre data-language=\"go\">func (z *Float) Copy(x *Float) *Float</pre> <p> Copy sets z to x, with the same precision, rounding mode, and accuracy as x, and returns z. x is not changed even if z and x are the same. </p> <h3 id=\"Float.Float32\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=21739:21784#L812\">Float32</a>  </h3> <pre data-language=\"go\">func (x *Float) Float32() (float32, Accuracy)</pre> <p> Float32 returns the float32 value nearest to x. If x is too small to be represented by a float32 (|x| &lt; math.SmallestNonzeroFloat32), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float32 (|x| &gt; math.MaxFloat32), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x. </p> <h3 id=\"Float.Float64\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=25592:25637#L932\">Float64</a>  </h3> <pre data-language=\"go\">func (x *Float) Float64() (float64, Accuracy)</pre> <p> Float64 returns the float64 value nearest to x. If x is too small to be represented by a float64 (|x| &lt; math.SmallestNonzeroFloat64), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float64 (|x| &gt; math.MaxFloat64), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x. </p> <h3 id=\"Float.Format\">func (*Float) <a href=\"https://golang.org/src/math/big/ftoa.go?s=10338:10386#L378\">Format</a>  </h3> <pre data-language=\"go\">func (x *Float) Format(s fmt.State, format rune)</pre> <p> Format implements fmt.Formatter. It accepts all the regular formats for floating-point numbers ('b', 'e', 'E', 'f', 'F', 'g', 'G') as well as 'p' and 'v'. See (*Float).Text for the interpretation of 'p'. The 'v' format is handled like 'g'. Format also supports specification of the minimum precision in digits, the output field width, as well as the format flags '+' and ' ' for sign control, '0' for space or zero padding, and '-' for left or right justification. See the fmt package for details. </p> <h3 id=\"Float.GobDecode\">func (*Float) <a href=\"https://golang.org/src/math/big/floatmarsh.go?s=1926:1969#L54\">GobDecode</a>  </h3> <pre data-language=\"go\">func (z *Float) GobDecode(buf []byte) error</pre> <p> GobDecode implements the gob.GobDecoder interface. The result is rounded per the precision and rounding mode of z unless z's precision is 0, in which case z is set exactly to the decoded value. </p> <h3 id=\"Float.GobEncode\">func (*Float) <a href=\"https://golang.org/src/math/big/floatmarsh.go?s=524:567#L10\">GobEncode</a>  </h3> <pre data-language=\"go\">func (x *Float) GobEncode() ([]byte, error)</pre> <p> GobEncode implements the gob.GobEncoder interface. The Float value and all its attributes (precision, rounding mode, accuracy) are marshalled. </p> <h3 id=\"Float.Int\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=29318:29362#L1053\">Int</a>  </h3> <pre data-language=\"go\">func (x *Float) Int(z *Int) (*Int, Accuracy)</pre> <p> Int returns the result of truncating x towards zero; or nil if x is an infinity. The result is Exact if x.IsInt(); otherwise it is Below for x &gt; 0, and Above for x &lt; 0. If a non-nil *Int argument z is provided, Int stores the result in z instead of allocating a new Int. </p> <h3 id=\"Float.Int64\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=20470:20511#L757\">Int64</a>  </h3> <pre data-language=\"go\">func (x *Float) Int64() (int64, Accuracy)</pre> <p> Int64 returns the integer resulting from truncating x towards zero. If math.MinInt64 &lt;= x &lt;= math.MaxInt64, the result is Exact if x is an integer, and Above (x &lt; 0) or Below (x &gt; 0) otherwise. The result is (math.MinInt64, Above) for x &lt; math.MinInt64, and (math.MaxInt64, Below) for x &gt; math.MaxInt64. </p> <h3 id=\"Float.IsInf\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=9686:9714#L319\">IsInf</a>  </h3> <pre data-language=\"go\">func (x *Float) IsInf() bool</pre> <p> IsInf reports whether x is +Inf or -Inf. </p> <h3 id=\"Float.IsInt\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=9818:9846#L325\">IsInt</a>  </h3> <pre data-language=\"go\">func (x *Float) IsInt() bool</pre> <p> IsInt reports whether x is an integer. ±Inf values are not integers. </p> <h3 id=\"Float.MantExp\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=8319:8365#L249\">MantExp</a>  </h3> <pre data-language=\"go\">func (x *Float) MantExp(mant *Float) (exp int)</pre> <p> MantExp breaks x into its mantissa and exponent components and returns the exponent. If a non-nil mant argument is provided its value is set to the mantissa of x, with the same precision and rounding mode as x. The components satisfy x == mant × 2**exp, with 0.5 &lt;= |mant| &lt; 1.0. Calling MantExp with a nil argument is an efficient way to get the exponent of the receiver. </p> <p> Special cases are: </p> <pre data-language=\"go\">(  ±0).MantExp(mant) = 0, with mant set to   ±0\n(±Inf).MantExp(mant) = 0, with mant set to ±Inf\n</pre> <p> x and mant may be the same in which case x is set to its mantissa value. </p> <h3 id=\"Float.MarshalText\">func (*Float) <a href=\"https://golang.org/src/math/big/floatmarsh.go?s=2782:2836#L91\">MarshalText</a>  </h3> <pre data-language=\"go\">func (x *Float) MarshalText() (text []byte, err error)</pre> <p> MarshalText implements the encoding.TextMarshaler interface. Only the Float value is marshaled (in full precision), other attributes such as precision or accuracy are ignored. </p> <h3 id=\"Float.MinPrec\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=7146:7176#L198\">MinPrec</a>  </h3> <pre data-language=\"go\">func (x *Float) MinPrec() uint</pre> <p> MinPrec returns the minimum precision required to represent x exactly (i.e., the smallest prec before x.SetPrec(prec) would start rounding x). The result is 0 for |x| == 0 and |x| == Inf. </p> <h3 id=\"Float.Mode\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=7316:7351#L206\">Mode</a>  </h3> <pre data-language=\"go\">func (x *Float) Mode() RoundingMode</pre> <p> Mode returns the rounding mode of x. </p> <h3 id=\"Float.Mul\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=41414:41453#L1525\">Mul</a>  </h3> <pre data-language=\"go\">func (z *Float) Mul(x, y *Float) *Float</pre> <p> Mul sets z to the rounded product x*y and returns z. Precision, rounding, and accuracy reporting are as for Add. Mul panics with ErrNaN if one operand is zero and the other operand an infinity. The value of z is undefined in that case. </p> <h3 id=\"Float.Neg\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=31520:31556#L1161\">Neg</a>  </h3> <pre data-language=\"go\">func (z *Float) Neg(x *Float) *Float</pre> <p> Neg sets z to the (possibly rounded) value of x with its sign negated, and returns z. </p> <h3 id=\"Float.Parse\">func (*Float) <a href=\"https://golang.org/src/math/big/floatconv.go?s=6239:6309#L235\">Parse</a>  </h3> <pre data-language=\"go\">func (z *Float) Parse(s string, base int) (f *Float, b int, err error)</pre> <p> Parse parses s which must contain a text representation of a floating- point number with a mantissa in the given conversion base (the exponent is always a decimal number), or a string representing an infinite value. </p> <p> It sets z to the (possibly rounded) value of the corresponding floating- point value, and returns z, the actual base b, and an error err, if any. If z's precision is 0, it is changed to 64 before rounding takes effect. The number must be of the form: </p> <pre data-language=\"go\">\tnumber   = [ sign ] [ prefix ] mantissa [ exponent ] | infinity .\n\tsign     = \"+\" | \"-\" .\n     prefix   = \"0\" ( \"x\" | \"X\" | \"b\" | \"B\" ) .\n\tmantissa = digits | digits \".\" [ digits ] | \".\" digits .\n\texponent = ( \"E\" | \"e\" | \"p\" ) [ sign ] digits .\n\tdigits   = digit { digit } .\n\tdigit    = \"0\" ... \"9\" | \"a\" ... \"z\" | \"A\" ... \"Z\" .\n     infinity = [ sign ] ( \"inf\" | \"Inf\" ) .\n</pre> <p> The base argument must be 0, 2, 10, or 16. Providing an invalid base argument will lead to a run-time panic. </p> <p> For base 0, the number prefix determines the actual base: A prefix of \"0x\" or \"0X\" selects base 16, and a \"0b\" or \"0B\" prefix selects base 2; otherwise, the actual base is 10 and no prefix is accepted. The octal prefix \"0\" is not supported (a leading \"0\" is simply considered a \"0\"). </p> <p> A \"p\" exponent indicates a binary (rather then decimal) exponent; for instance \"0x1.fffffffffffffp1023\" (using base 0) represents the maximum float64 value. For hexadecimal mantissae, the exponent must be binary, if present (an \"e\" or \"E\" exponent indicator cannot be distinguished from a mantissa digit). </p> <p> The returned *Float f is nil and the value of z is valid but not defined if an error is reported. </p> <h3 id=\"Float.Prec\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=6895:6922#L191\">Prec</a>  </h3> <pre data-language=\"go\">func (x *Float) Prec() uint</pre> <p> Prec returns the mantissa precision of x in bits. The result may be 0 for |x| == 0 and |x| == Inf. </p> <h3 id=\"Float.Quo\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=42335:42374#L1570\">Quo</a>  </h3> <pre data-language=\"go\">func (z *Float) Quo(x, y *Float) *Float</pre> <p> Quo sets z to the rounded quotient x/y and returns z. Precision, rounding, and accuracy reporting are as for Add. Quo panics with ErrNaN if both operands are zero or infinities. The value of z is undefined in that case. </p> <h3 id=\"Float.Rat\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=30417:30461#L1109\">Rat</a>  </h3> <pre data-language=\"go\">func (x *Float) Rat(z *Rat) (*Rat, Accuracy)</pre> <p> Rat returns the rational number corresponding to x; or nil if x is an infinity. The result is Exact if x is not an Inf. If a non-nil *Rat argument z is provided, Rat stores the result in z instead of allocating a new Rat. </p> <h3 id=\"Float.Set\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=17871:17907#L625\">Set</a>  </h3> <pre data-language=\"go\">func (z *Float) Set(x *Float) *Float</pre> <p> Set sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the precision of x before setting z (and rounding will have no effect). Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result. </p> <h3 id=\"Float.SetFloat64\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=15234:15278#L523\">SetFloat64</a>  </h3> <pre data-language=\"go\">func (z *Float) SetFloat64(x float64) *Float</pre> <p> SetFloat64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 53 (and rounding will have no effect). SetFloat64 panics with ErrNaN if x is a NaN. </p> <h3 id=\"Float.SetInf\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=17419:17462#L612\">SetInf</a>  </h3> <pre data-language=\"go\">func (z *Float) SetInf(signbit bool) *Float</pre> <p> SetInf sets z to the infinite Float -Inf if signbit is set, or +Inf if signbit is not set, and returns z. The precision of z is unchanged and the result is always Exact. </p> <h3 id=\"Float.SetInt\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=16410:16447#L571\">SetInt</a>  </h3> <pre data-language=\"go\">func (z *Float) SetInt(x *Int) *Float</pre> <p> SetInt sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the larger of x.BitLen() or 64 (and rounding will have no effect). </p> <h3 id=\"Float.SetInt64\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=14796:14836#L510\">SetInt64</a>  </h3> <pre data-language=\"go\">func (z *Float) SetInt64(x int64) *Float</pre> <p> SetInt64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect). </p> <h3 id=\"Float.SetMantExp\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=9312:9367#L300\">SetMantExp</a>  </h3> <pre data-language=\"go\">func (z *Float) SetMantExp(mant *Float, exp int) *Float</pre> <p> SetMantExp sets z to mant × 2**exp and and returns z. The result z has the same precision and rounding mode as mant. SetMantExp is an inverse of MantExp but does not require 0.5 &lt;= |mant| &lt; 1.0. Specifically: </p> <pre data-language=\"go\">mant := new(Float)\nnew(Float).SetMantExp(mant, x.MantExp(mant)).Cmp(x) == 0\n</pre> <p> Special cases are: </p> <pre data-language=\"go\">z.SetMantExp(  ±0, exp) =   ±0\nz.SetMantExp(±Inf, exp) = ±Inf\n</pre> <p> z and mant may be the same in which case z's exponent is set to exp. </p> <h3 id=\"Float.SetMode\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=6695:6744#L183\">SetMode</a>  </h3> <pre data-language=\"go\">func (z *Float) SetMode(mode RoundingMode) *Float</pre> <p> SetMode sets z's rounding mode to mode and returns an exact z. z remains unchanged otherwise. z.SetMode(z.Mode()) is a cheap way to set z's accuracy to Exact. </p> <h3 id=\"Float.SetPrec\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=6039:6080#L147\">SetPrec</a>  </h3> <pre data-language=\"go\">func (z *Float) SetPrec(prec uint) *Float</pre> <p> SetPrec sets z's precision to prec and returns the (possibly) rounded value of z. Rounding occurs according to z's rounding mode if the mantissa cannot be represented in prec bits without loss of precision. SetPrec(0) maps all finite values to ±0; infinite values remain unchanged. If prec &gt; MaxPrec, it is set to MaxPrec. </p> <h3 id=\"Float.SetRat\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=17015:17052#L595\">SetRat</a>  </h3> <pre data-language=\"go\">func (z *Float) SetRat(x *Rat) *Float</pre> <p> SetRat sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the largest of a.BitLen(), b.BitLen(), or 64; with x = a/b. </p> <h3 id=\"Float.SetString\">func (*Float) <a href=\"https://golang.org/src/math/big/floatconv.go?s=461:511#L8\">SetString</a>  </h3> <pre data-language=\"go\">func (z *Float) SetString(s string) (*Float, bool)</pre> <p> SetString sets z to the value of s and returns z and a boolean indicating success. s must be a floating-point number of the same format as accepted by Parse, with base argument 0. </p> <h3 id=\"Float.SetUint64\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=14562:14604#L503\">SetUint64</a>  </h3> <pre data-language=\"go\">func (z *Float) SetUint64(x uint64) *Float</pre> <p> SetUint64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect). </p> <h3 id=\"Float.Sign\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=7569:7595#L221\">Sign</a>  </h3> <pre data-language=\"go\">func (x *Float) Sign() int</pre> <p> Sign returns: </p> <pre data-language=\"go\">-1 if x &lt;   0\n 0 if x is ±0\n+1 if x &gt;   0\n</pre> <h3 id=\"Float.Signbit\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=9592:9622#L314\">Signbit</a>  </h3> <pre data-language=\"go\">func (x *Float) Signbit() bool</pre> <p> Signbit returns true if x is negative or negative zero. </p> <h3 id=\"Float.String\">func (*Float) <a href=\"https://golang.org/src/math/big/ftoa.go?s=2049:2080#L43\">String</a>  </h3> <pre data-language=\"go\">func (x *Float) String() string</pre> <p> String formats x like x.Text('g', 10). (String must be called explicitly, Float.Format does not support %s verb.) </p> <h3 id=\"Float.Sub\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=40115:40154#L1462\">Sub</a>  </h3> <pre data-language=\"go\">func (z *Float) Sub(x, y *Float) *Float</pre> <p> Sub sets z to the rounded difference x-y and returns z. Precision, rounding, and accuracy reporting are as for Add. Sub panics with ErrNaN if x and y are infinities with equal signs. The value of z is undefined in that case. </p> <h3 id=\"Float.Text\">func (*Float) <a href=\"https://golang.org/src/math/big/ftoa.go?s=1721:1771#L33\">Text</a>  </h3> <pre data-language=\"go\">func (x *Float) Text(format byte, prec int) string</pre> <p> Text converts the floating-point number x to a string according to the given format and precision prec. The format is one of: </p> <pre data-language=\"go\">'e'\t-d.dddde±dd, decimal exponent, at least two (possibly 0) exponent digits\n'E'\t-d.ddddE±dd, decimal exponent, at least two (possibly 0) exponent digits\n'f'\t-ddddd.dddd, no exponent\n'g'\tlike 'e' for large exponents, like 'f' otherwise\n'G'\tlike 'E' for large exponents, like 'f' otherwise\n'b'\t-ddddddp±dd, binary exponent\n'p'\t-0x.dddp±dd, binary exponent, hexadecimal mantissa\n</pre> <p> For the binary exponent formats, the mantissa is printed in normalized form: </p> <pre data-language=\"go\">'b'\tdecimal integer mantissa using x.Prec() bits, or -0\n'p'\thexadecimal fraction with 0.5 &lt;= 0.mantissa &lt; 1.0, or -0\n</pre> <p> If format is a different character, Text returns a \"%\" followed by the unrecognized format character. </p> <p> The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', and 'G' formats. For 'e', 'E', and 'f' it is the number of digits after the decimal point. For 'g' and 'G' it is the total number of digits. A negative precision selects the smallest number of decimal digits necessary to identify the value x uniquely using x.Prec() mantissa bits. The prec value is ignored for the 'b' or 'p' format. </p> <h3 id=\"Float.Uint64\">func (*Float) <a href=\"https://golang.org/src/math/big/float.go?s=19530:19573#L712\">Uint64</a>  </h3> <pre data-language=\"go\">func (x *Float) Uint64() (uint64, Accuracy)</pre> <p> Uint64 returns the unsigned integer resulting from truncating x towards zero. If 0 &lt;= x &lt;= math.MaxUint64, the result is Exact if x is an integer and Below otherwise. The result is (0, Above) for x &lt; 0, and (math.MaxUint64, Below) for x &gt; math.MaxUint64. </p> <h3 id=\"Float.UnmarshalText\">func (*Float) <a href=\"https://golang.org/src/math/big/floatmarsh.go?s=3156:3204#L103\">UnmarshalText</a>  </h3> <pre data-language=\"go\">func (z *Float) UnmarshalText(text []byte) error</pre> <p> UnmarshalText implements the encoding.TextUnmarshaler interface. The result is rounded per the precision and rounding mode of z. If z's precision is 0, it is changed to 64 before rounding takes effect. </p> <h2 id=\"Int\">type Int  </h2> <pre data-language=\"go\">type Int struct {\n        // contains filtered or unexported fields\n}</pre> <p> An Int represents a signed multi-precision integer. The zero value for an Int represents the value 0. </p> <h3 id=\"NewInt\">func <a href=\"https://golang.org/src/math/big/int.go?s=1058:1083#L51\">NewInt</a>  </h3> <pre data-language=\"go\">func NewInt(x int64) *Int</pre> <p> NewInt allocates and returns a new Int set to x. </p> <h3 id=\"Int.Abs\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=2124:2154#L85\">Abs</a>  </h3> <pre data-language=\"go\">func (z *Int) Abs(x *Int) *Int</pre> <p> Abs sets z to |x| (the absolute value of x) and returns z. </p> <h3 id=\"Int.Add\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=2381:2414#L99\">Add</a>  </h3> <pre data-language=\"go\">func (z *Int) Add(x, y *Int) *Int</pre> <p> Add sets z to the sum x+y and returns z. </p> <h3 id=\"Int.And\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=18694:18727#L789\">And</a>  </h3> <pre data-language=\"go\">func (z *Int) And(x, y *Int) *Int</pre> <p> And sets z = x &amp; y and returns z. </p> <h3 id=\"Int.AndNot\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=19375:19411#L819\">AndNot</a>  </h3> <pre data-language=\"go\">func (z *Int) AndNot(x, y *Int) *Int</pre> <p> AndNot sets z = x &amp;^ y and returns z. </p> <h3 id=\"Int.Append\">func (*Int) <a href=\"https://golang.org/src/math/big/intconv.go?s=1046:1095#L24\">Append</a>  </h3> <pre data-language=\"go\">func (x *Int) Append(buf []byte, base int) []byte</pre> <p> Append appends the string representation of x, as generated by x.Text(base), to buf and returns the extended buffer. </p> <h3 id=\"Int.Binomial\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=4127:4166#L175\">Binomial</a>  </h3> <pre data-language=\"go\">func (z *Int) Binomial(n, k int64) *Int</pre> <p> Binomial sets z to the binomial coefficient of (n, k) and returns z. </p> <h3 id=\"Int.Bit\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=17806:17835#L749\">Bit</a>  </h3> <pre data-language=\"go\">func (x *Int) Bit(i int) uint</pre> <p> Bit returns the value of the i'th bit of x. That is, it returns (x&gt;&gt;i)&amp;1. The bit index i must be &gt;= 0. </p> <h3 id=\"Int.BitLen\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=9739:9765#L391\">BitLen</a>  </h3> <pre data-language=\"go\">func (x *Int) BitLen() int</pre> <p> BitLen returns the length of the absolute value of x in bits. The bit length of 0 is 0. </p> <h3 id=\"Int.Bits\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=1572:1599#L69\">Bits</a>  </h3> <pre data-language=\"go\">func (x *Int) Bits() []Word</pre> <p> Bits provides raw (unchecked but fast) access to x by returning its absolute value as a little-endian Word slice. The result and x share the same underlying array. Bits is intended to support implementation of missing low-level Int functionality outside this package; it should be avoided otherwise. </p> <h3 id=\"Int.Bytes\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=9544:9572#L384\">Bytes</a>  </h3> <pre data-language=\"go\">func (x *Int) Bytes() []byte</pre> <p> Bytes returns the absolute value of x as a big-endian byte slice. </p> <h3 id=\"Int.Cmp\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=7472:7505#L298\">Cmp</a>  </h3> <pre data-language=\"go\">func (x *Int) Cmp(y *Int) (r int)</pre> <p> Cmp compares x and y and returns: </p> <pre data-language=\"go\">-1 if x &lt;  y\n 0 if x == y\n+1 if x &gt;  y\n</pre> <h3 id=\"Int.Div\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=5888:5921#L225\">Div</a>  </h3> <pre data-language=\"go\">func (z *Int) Div(x, y *Int) *Int</pre> <p> Div sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Div implements Euclidean division (unlike Go); see DivMod for more details. </p> <h3 id=\"Int.DivMod\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=7093:7140#L274\">DivMod</a>  </h3> <pre data-language=\"go\">func (z *Int) DivMod(x, y, m *Int) (*Int, *Int)</pre> <p> DivMod sets z to the quotient x div y and m to the modulus x mod y and returns the pair (z, m) for y != 0. If y == 0, a division-by-zero run-time panic occurs. </p> <p> DivMod implements Euclidean division and modulus (unlike Go): </p> <pre data-language=\"go\">q = x div y  such that\nm = x - y*q  with 0 &lt;= m &lt; |y|\n</pre> <p> (See Raymond T. Boute, “The Euclidean definition of the functions div and mod”. ACM Transactions on Programming Languages and Systems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992. ACM press.) See QuoRem for T-division and modulus (like Go). </p> <h3 id=\"Int.Exp\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=9982:10018#L398\">Exp</a>  </h3> <pre data-language=\"go\">func (z *Int) Exp(x, y, m *Int) *Int</pre> <p> Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z. If y &lt;= 0, the result is 1 mod |m|; if m == nil or m == 0, z = x**y. See Knuth, volume 2, section 4.6.3. </p> <h3 id=\"Int.Format\">func (*Int) <a href=\"https://golang.org/src/math/big/intconv.go?s=1992:2034#L56\">Format</a>  </h3> <pre data-language=\"go\">func (x *Int) Format(s fmt.State, ch rune)</pre> <p> Format implements fmt.Formatter. It accepts the formats 'b' (binary), 'o' (octal), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal). Also supported are the full suite of package fmt's format flags for integral types, including '+' and ' ' for sign control, '#' for leading zero in octal and for hexadecimal, a leading \"0x\" or \"0X\" for \"%#x\" and \"%#X\" respectively, specification of minimum digits precision, output field width, space or zero padding, and '-' for left or right justification. </p> <h3 id=\"Int.GCD\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=10689:10728#L425\">GCD</a>  </h3> <pre data-language=\"go\">func (z *Int) GCD(x, y, a, b *Int) *Int</pre> <p> GCD sets z to the greatest common divisor of a and b, which both must be &gt; 0, and returns z. If x and y are not nil, GCD sets x and y such that z = a*x + b*y. If either a or b is &lt;= 0, GCD sets z = x = y = 0. </p> <h3 id=\"Int.GobDecode\">func (*Int) <a href=\"https://golang.org/src/math/big/intmarsh.go?s=782:823#L20\">GobDecode</a>  </h3> <pre data-language=\"go\">func (z *Int) GobDecode(buf []byte) error</pre> <p> GobDecode implements the gob.GobDecoder interface. </p> <h3 id=\"Int.GobEncode\">func (*Int) <a href=\"https://golang.org/src/math/big/intmarsh.go?s=398:439#L5\">GobEncode</a>  </h3> <pre data-language=\"go\">func (x *Int) GobEncode() ([]byte, error)</pre> <p> GobEncode implements the gob.GobEncoder interface. </p> <h3 id=\"Int.Int64\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=8193:8220#L339\">Int64</a>  </h3> <pre data-language=\"go\">func (x *Int) Int64() int64</pre> <p> Int64 returns the int64 representation of x. If x cannot be represented in an int64, the result is undefined. </p> <h3 id=\"Int.Lsh\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=17204:17242#L725\">Lsh</a>  </h3> <pre data-language=\"go\">func (z *Int) Lsh(x *Int, n uint) *Int</pre> <p> Lsh sets z = x &lt;&lt; n and returns z. </p> <h3 id=\"Int.MarshalJSON\">func (*Int) <a href=\"https://golang.org/src/math/big/intmarsh.go?s=1859:1902#L57\">MarshalJSON</a>  </h3> <pre data-language=\"go\">func (x *Int) MarshalJSON() ([]byte, error)</pre> <p> MarshalJSON implements the json.Marshaler interface. </p> <h3 id=\"Int.MarshalText\">func (*Int) <a href=\"https://golang.org/src/math/big/intmarsh.go?s=1172:1224#L36\">MarshalText</a>  </h3> <pre data-language=\"go\">func (x *Int) MarshalText() (text []byte, err error)</pre> <p> MarshalText implements the encoding.TextMarshaler interface. </p> <h3 id=\"Int.Mod\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=6287:6320#L242\">Mod</a>  </h3> <pre data-language=\"go\">func (z *Int) Mod(x, y *Int) *Int</pre> <p> Mod sets z to the modulus x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Mod implements Euclidean modulus (unlike Go); see DivMod for more details. </p> <h3 id=\"Int.ModInverse\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=13523:13563#L569\">ModInverse</a>  </h3> <pre data-language=\"go\">func (z *Int) ModInverse(g, n *Int) *Int</pre> <p> ModInverse sets z to the multiplicative inverse of g in the ring ℤ/nℤ and returns z. If g and n are not relatively prime, the result is undefined. </p> <h3 id=\"Int.ModSqrt\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=16679:16716#L703\">ModSqrt</a>  </h3> <pre data-language=\"go\">func (z *Int) ModSqrt(x, p *Int) *Int</pre> <p> ModSqrt sets z to a square root of x mod p if such a square root exists, and returns z. The modulus p must be an odd prime. If x is not a square mod p, ModSqrt leaves z unchanged and returns nil. This function panics if p is not an odd integer. </p> <h3 id=\"Int.Mul\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=3332:3365#L141\">Mul</a>  </h3> <pre data-language=\"go\">func (z *Int) Mul(x, y *Int) *Int</pre> <p> Mul sets z to the product x*y and returns z. </p> <h3 id=\"Int.MulRange\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=3711:3750#L154\">MulRange</a>  </h3> <pre data-language=\"go\">func (z *Int) MulRange(a, b int64) *Int</pre> <p> MulRange sets z to the product of all integers in the range [a, b] inclusively and returns z. If a &gt; b (empty range), the result is 1. </p> <h3 id=\"Int.Neg\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=2230:2260#L92\">Neg</a>  </h3> <pre data-language=\"go\">func (z *Int) Neg(x *Int) *Int</pre> <p> Neg sets z to -x and returns z. </p> <h3 id=\"Int.Not\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=21636:21666#L912\">Not</a>  </h3> <pre data-language=\"go\">func (z *Int) Not(x *Int) *Int</pre> <p> Not sets z = ^x and returns z. </p> <h3 id=\"Int.Or\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=20189:20221#L852\">Or</a>  </h3> <pre data-language=\"go\">func (z *Int) Or(x, y *Int) *Int</pre> <p> Or sets z = x | y and returns z. </p> <h3 id=\"Int.ProbablyPrime\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=12959:12998#L549\">ProbablyPrime</a>  </h3> <pre data-language=\"go\">func (x *Int) ProbablyPrime(n int) bool</pre> <p> ProbablyPrime performs n Miller-Rabin tests to check whether x is prime. If x is prime, it returns true. If x is not prime, it returns false with probability at least 1 - ¼ⁿ. </p> <p> It is not suitable for judging primes that an adversary may have crafted to fool this test. </p> <h3 id=\"Int.Quo\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=4573:4606#L189\">Quo</a>  </h3> <pre data-language=\"go\">func (z *Int) Quo(x, y *Int) *Int</pre> <p> Quo sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Quo implements truncated division (like Go); see QuoRem for more details. </p> <h3 id=\"Int.QuoRem\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=5489:5536#L216\">QuoRem</a>  </h3> <pre data-language=\"go\">func (z *Int) QuoRem(x, y, r *Int) (*Int, *Int)</pre> <p> QuoRem sets z to the quotient x/y and r to the remainder x%y and returns the pair (z, r) for y != 0. If y == 0, a division-by-zero run-time panic occurs. </p> <p> QuoRem implements T-division and modulus (like Go): </p> <pre data-language=\"go\">q = x/y      with the result truncated to zero\nr = x - y*q\n</pre> <p> (See Daan Leijen, “Division and Modulus for Computer Scientists”.) See DivMod for Euclidean division and modulus (unlike Go). </p> <h3 id=\"Int.Rand\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=13171:13218#L557\">Rand</a>  </h3> <pre data-language=\"go\">func (z *Int) Rand(rnd *rand.Rand, n *Int) *Int</pre> <p> Rand sets z to a pseudo-random number in [0, n) and returns z. </p> <h3 id=\"Int.Rem\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=4915:4948#L198\">Rem</a>  </h3> <pre data-language=\"go\">func (z *Int) Rem(x, y *Int) *Int</pre> <p> Rem sets z to the remainder x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Rem implements truncated modulus (like Go); see QuoRem for more details. </p> <h3 id=\"Int.Rsh\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=17340:17378#L732\">Rsh</a>  </h3> <pre data-language=\"go\">func (z *Int) Rsh(x *Int, n uint) *Int</pre> <p> Rsh sets z = x &gt;&gt; n and returns z. </p> <h3 id=\"Int.Scan\">func (*Int) <a href=\"https://golang.org/src/math/big/intconv.go?s=6286:6336#L219\">Scan</a>  </h3> <pre data-language=\"go\">func (z *Int) Scan(s fmt.ScanState, ch rune) error</pre> <p> Scan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts the formats 'b' (binary), 'o' (octal), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal). </p> <div id=\"example_Int_Scan\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"math/big\"\n)\n\nfunc main() {\n\t// The Scan function is rarely used directly;\n\t// the fmt package recognizes it as an implementation of fmt.Scanner.\n\ti := new(big.Int)\n\t_, err := fmt.Sscan(\"18446744073709551617\", i)\n\tif err != nil {\n\t\tlog.Println(\"error scanning value:\", err)\n\t} else {\n\t\tfmt.Println(i)\n\t}\n}\n</pre> </div> </div> <h3 id=\"Int.Set\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=1152:1182#L56\">Set</a>  </h3> <pre data-language=\"go\">func (z *Int) Set(x *Int) *Int</pre> <p> Set sets z to x and returns z. </p> <h3 id=\"Int.SetBit\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=18350:18398#L772\">SetBit</a>  </h3> <pre data-language=\"go\">func (z *Int) SetBit(x *Int, i int, b uint) *Int</pre> <p> SetBit sets z to x, with x's i'th bit set to b (0 or 1). That is, if b is 1 SetBit sets z = x | (1 &lt;&lt; i); if b is 0 SetBit sets z = x &amp;^ (1 &lt;&lt; i). If b is not 0 or 1, SetBit will panic. </p> <h3 id=\"Int.SetBits\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=1968:2006#L78\">SetBits</a>  </h3> <pre data-language=\"go\">func (z *Int) SetBits(abs []Word) *Int</pre> <p> SetBits provides raw (unchecked but fast) access to z by setting its value to abs, interpreted as a little-endian Word slice, and returning z. The result and abs share the same underlying array. SetBits is intended to support implementation of missing low-level Int functionality outside this package; it should be avoided otherwise. </p> <h3 id=\"Int.SetBytes\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=9376:9415#L377\">SetBytes</a>  </h3> <pre data-language=\"go\">func (z *Int) SetBytes(buf []byte) *Int</pre> <p> SetBytes interprets buf as the bytes of a big-endian unsigned integer, sets z to that value, and returns z. </p> <h3 id=\"Int.SetInt64\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=717:753#L32\">SetInt64</a>  </h3> <pre data-language=\"go\">func (z *Int) SetInt64(x int64) *Int</pre> <p> SetInt64 sets z to x and returns z. </p> <h3 id=\"Int.SetString\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=8978:9034#L362\">SetString</a>  </h3> <pre data-language=\"go\">func (z *Int) SetString(s string, base int) (*Int, bool)</pre> <p> SetString sets z to the value of s, interpreted in the given base, and returns z and a boolean indicating success. If SetString fails, the value of z is undefined but the returned value is nil. </p> <p> The base argument must be 0 or a value between 2 and MaxBase. If the base is 0, the string prefix determines the actual conversion base. A prefix of “0x” or “0X” selects base 16; the “0” prefix selects base 8, and a “0b” or “0B” prefix selects base 2. Otherwise the selected base is 10. </p> <div id=\"example_Int_SetString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n)\n\nfunc main() {\n\ti := new(big.Int)\n\ti.SetString(\"644\", 8) // octal\n\tfmt.Println(i)\n}\n</pre> </div> </div> <h3 id=\"Int.SetUint64\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=909:947#L44\">SetUint64</a>  </h3> <pre data-language=\"go\">func (z *Int) SetUint64(x uint64) *Int</pre> <p> SetUint64 sets z to x and returns z. </p> <h3 id=\"Int.Sign\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=575:599#L21\">Sign</a>  </h3> <pre data-language=\"go\">func (x *Int) Sign() int</pre> <p> Sign returns: </p> <pre data-language=\"go\">-1 if x &lt;  0\n 0 if x == 0\n+1 if x &gt;  0\n</pre> <h3 id=\"Int.String\">func (*Int) <a href=\"https://golang.org/src/math/big/intconv.go?s=1200:1229#L31\">String</a>  </h3> <pre data-language=\"go\">func (x *Int) String() string</pre> <h3 id=\"Int.Sub\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=2858:2891#L120\">Sub</a>  </h3> <pre data-language=\"go\">func (z *Int) Sub(x, y *Int) *Int</pre> <p> Sub sets z to the difference x-y and returns z. </p> <h3 id=\"Int.Text\">func (*Int) <a href=\"https://golang.org/src/math/big/intconv.go?s=807:842#L15\">Text</a>  </h3> <pre data-language=\"go\">func (x *Int) Text(base int) string</pre> <p> Text returns the string representation of x in the given base. Base must be between 2 and 36, inclusive. The result uses the lower-case letters 'a' to 'z' for digit values &gt;= 10. No base prefix (such as \"0x\") is added to the string. </p> <h3 id=\"Int.Uint64\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=8404:8433#L349\">Uint64</a>  </h3> <pre data-language=\"go\">func (x *Int) Uint64() uint64</pre> <p> Uint64 returns the uint64 representation of x. If x cannot be represented in a uint64, the result is undefined. </p> <h3 id=\"Int.UnmarshalJSON\">func (*Int) <a href=\"https://golang.org/src/math/big/intmarsh.go?s=1992:2038#L62\">UnmarshalJSON</a>  </h3> <pre data-language=\"go\">func (z *Int) UnmarshalJSON(text []byte) error</pre> <p> UnmarshalJSON implements the json.Unmarshaler interface. </p> <h3 id=\"Int.UnmarshalText\">func (*Int) <a href=\"https://golang.org/src/math/big/intmarsh.go?s=1381:1427#L44\">UnmarshalText</a>  </h3> <pre data-language=\"go\">func (z *Int) UnmarshalText(text []byte) error</pre> <p> UnmarshalText implements the encoding.TextUnmarshaler interface. </p> <h3 id=\"Int.Xor\">func (*Int) <a href=\"https://golang.org/src/math/big/int.go?s=20959:20992#L882\">Xor</a>  </h3> <pre data-language=\"go\">func (z *Int) Xor(x, y *Int) *Int</pre> <p> Xor sets z = x ^ y and returns z. </p> <h2 id=\"Rat\">type Rat  </h2> <pre data-language=\"go\">type Rat struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Rat represents a quotient a/b of arbitrary precision. The zero value for a Rat represents the value 0. </p> <h3 id=\"NewRat\">func <a href=\"https://golang.org/src/math/big/rat.go?s=636:664#L14\">NewRat</a>  </h3> <pre data-language=\"go\">func NewRat(a, b int64) *Rat</pre> <p> NewRat creates a new Rat with numerator a and denominator b. </p> <h3 id=\"Rat.Abs\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=8895:8925#L335\">Abs</a>  </h3> <pre data-language=\"go\">func (z *Rat) Abs(x *Rat) *Rat</pre> <p> Abs sets z to |x| (the absolute value of x) and returns z. </p> <h3 id=\"Rat.Add\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=11793:11826#L464\">Add</a>  </h3> <pre data-language=\"go\">func (z *Rat) Add(x, y *Rat) *Rat</pre> <p> Add sets z to the sum x+y and returns z. </p> <h3 id=\"Rat.Cmp\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=11649:11678#L459\">Cmp</a>  </h3> <pre data-language=\"go\">func (x *Rat) Cmp(y *Rat) int</pre> <p> Cmp compares x and y and returns: </p> <pre data-language=\"go\">-1 if x &lt;  y\n 0 if x == y\n+1 if x &gt;  y\n</pre> <h3 id=\"Rat.Denom\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=10166:10192#L392\">Denom</a>  </h3> <pre data-language=\"go\">func (x *Rat) Denom() *Int</pre> <p> Denom returns the denominator of x; it is always &gt; 0. The result is a reference to x's denominator; it may change if a new value is assigned to x, and vice versa. </p> <h3 id=\"Rat.Float32\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=7124:7171#L254\">Float32</a>  </h3> <pre data-language=\"go\">func (x *Rat) Float32() (f float32, exact bool)</pre> <p> Float32 returns the nearest float32 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float32, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0. </p> <h3 id=\"Rat.Float64\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=7609:7656#L270\">Float64</a>  </h3> <pre data-language=\"go\">func (x *Rat) Float64() (f float64, exact bool)</pre> <p> Float64 returns the nearest float64 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float64, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0. </p> <h3 id=\"Rat.FloatString\">func (*Rat) <a href=\"https://golang.org/src/math/big/ratconv.go?s=4897:4939#L210\">FloatString</a>  </h3> <pre data-language=\"go\">func (x *Rat) FloatString(prec int) string</pre> <p> FloatString returns a string representation of x in decimal form with prec digits of precision after the decimal point. The last digit is rounded to nearest, with halves rounded away from zero. </p> <h3 id=\"Rat.GobDecode\">func (*Rat) <a href=\"https://golang.org/src/math/big/ratmarsh.go?s=1058:1099#L32\">GobDecode</a>  </h3> <pre data-language=\"go\">func (z *Rat) GobDecode(buf []byte) error</pre> <p> GobDecode implements the gob.GobDecoder interface. </p> <h3 id=\"Rat.GobEncode\">func (*Rat) <a href=\"https://golang.org/src/math/big/ratmarsh.go?s=432:473#L9\">GobEncode</a>  </h3> <pre data-language=\"go\">func (x *Rat) GobEncode() ([]byte, error)</pre> <p> GobEncode implements the gob.GobEncoder interface. </p> <h3 id=\"Rat.Inv\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=9152:9182#L349\">Inv</a>  </h3> <pre data-language=\"go\">func (z *Rat) Inv(x *Rat) *Rat</pre> <p> Inv sets z to 1/x and returns z. </p> <h3 id=\"Rat.IsInt\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=9642:9668#L377\">IsInt</a>  </h3> <pre data-language=\"go\">func (x *Rat) IsInt() bool</pre> <p> IsInt reports whether the denominator of x is 1. </p> <h3 id=\"Rat.MarshalText\">func (*Rat) <a href=\"https://golang.org/src/math/big/ratmarsh.go?s=1555:1607#L51\">MarshalText</a>  </h3> <pre data-language=\"go\">func (x *Rat) MarshalText() (text []byte, err error)</pre> <p> MarshalText implements the encoding.TextMarshaler interface. </p> <h3 id=\"Rat.Mul\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=12264:12297#L482\">Mul</a>  </h3> <pre data-language=\"go\">func (z *Rat) Mul(x, y *Rat) *Rat</pre> <p> Mul sets z to the product x*y and returns z. </p> <h3 id=\"Rat.Neg\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=9003:9033#L342\">Neg</a>  </h3> <pre data-language=\"go\">func (z *Rat) Neg(x *Rat) *Rat</pre> <p> Neg sets z to -x and returns z. </p> <h3 id=\"Rat.Num\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=9951:9975#L385\">Num</a>  </h3> <pre data-language=\"go\">func (x *Rat) Num() *Int</pre> <p> Num returns the numerator of x; it may be &lt;= 0. The result is a reference to x's numerator; it may change if a new value is assigned to x, and vice versa. The sign of the numerator corresponds to the sign of x. </p> <h3 id=\"Rat.Quo\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=12493:12526#L490\">Quo</a>  </h3> <pre data-language=\"go\">func (z *Rat) Quo(x, y *Rat) *Rat</pre> <p> Quo sets z to the quotient x/y and returns z. If y == 0, a division-by-zero run-time panic occurs. </p> <h3 id=\"Rat.RatString\">func (*Rat) <a href=\"https://golang.org/src/math/big/ratconv.go?s=4596:4628#L200\">RatString</a>  </h3> <pre data-language=\"go\">func (x *Rat) RatString() string</pre> <p> RatString returns a string representation of x in the form \"a/b\" if b != 1, and in the form \"a\" if b == 1. </p> <h3 id=\"Rat.Scan\">func (*Rat) <a href=\"https://golang.org/src/math/big/ratconv.go?s=514:564#L13\">Scan</a>  </h3> <pre data-language=\"go\">func (z *Rat) Scan(s fmt.ScanState, ch rune) error</pre> <p> Scan is a support routine for fmt.Scanner. It accepts the formats 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent. </p> <div id=\"example_Rat_Scan\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"math/big\"\n)\n\nfunc main() {\n\t// The Scan function is rarely used directly;\n\t// the fmt package recognizes it as an implementation of fmt.Scanner.\n\tr := new(big.Rat)\n\t_, err := fmt.Sscan(\"1.5000\", r)\n\tif err != nil {\n\t\tlog.Println(\"error scanning value:\", err)\n\t} else {\n\t\tfmt.Println(r)\n\t}\n}\n</pre> </div> </div> <h3 id=\"Rat.Set\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=8739:8769#L326\">Set</a>  </h3> <pre data-language=\"go\">func (z *Rat) Set(x *Rat) *Rat</pre> <p> Set sets z to x (by making a copy of x) and returns z. </p> <h3 id=\"Rat.SetFloat64\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=797:837#L20\">SetFloat64</a>  </h3> <pre data-language=\"go\">func (z *Rat) SetFloat64(f float64) *Rat</pre> <p> SetFloat64 sets z to exactly f and returns z. If f is not finite, SetFloat returns nil. </p> <h3 id=\"Rat.SetFrac\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=7856:7893#L283\">SetFrac</a>  </h3> <pre data-language=\"go\">func (z *Rat) SetFrac(a, b *Int) *Rat</pre> <p> SetFrac sets z to a/b and returns z. </p> <h3 id=\"Rat.SetFrac64\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=8196:8236#L298\">SetFrac64</a>  </h3> <pre data-language=\"go\">func (z *Rat) SetFrac64(a, b int64) *Rat</pre> <p> SetFrac64 sets z to a/b and returns z. </p> <h3 id=\"Rat.SetInt\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=8466:8499#L312\">SetInt</a>  </h3> <pre data-language=\"go\">func (z *Rat) SetInt(x *Int) *Rat</pre> <p> SetInt sets z to x (by making a copy of x) and returns z. </p> <h3 id=\"Rat.SetInt64\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=8589:8625#L319\">SetInt64</a>  </h3> <pre data-language=\"go\">func (z *Rat) SetInt64(x int64) *Rat</pre> <p> SetInt64 sets z to x and returns z. </p> <h3 id=\"Rat.SetString\">func (*Rat) <a href=\"https://golang.org/src/math/big/ratconv.go?s=1118:1164#L31\">SetString</a>  </h3> <pre data-language=\"go\">func (z *Rat) SetString(s string) (*Rat, bool)</pre> <p> SetString sets z to the value of s and returns z and a boolean indicating success. s can be given as a fraction \"a/b\" or as a floating-point number optionally followed by an exponent. If the operation failed, the value of z is undefined but the returned value is nil. </p> <div id=\"example_Rat_SetString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n)\n\nfunc main() {\n\tr := new(big.Rat)\n\tr.SetString(\"355/113\")\n\tfmt.Println(r.FloatString(3))\n}\n</pre> </div> </div> <h3 id=\"Rat.Sign\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=9541:9565#L372\">Sign</a>  </h3> <pre data-language=\"go\">func (x *Rat) Sign() int</pre> <p> Sign returns: </p> <pre data-language=\"go\">-1 if x &lt;  0\n 0 if x == 0\n+1 if x &gt;  0\n</pre> <h3 id=\"Rat.String\">func (*Rat) <a href=\"https://golang.org/src/math/big/ratconv.go?s=4271:4300#L186\">String</a>  </h3> <pre data-language=\"go\">func (x *Rat) String() string</pre> <p> String returns a string representation of x in the form \"a/b\" (even if b == 1). </p> <h3 id=\"Rat.Sub\">func (*Rat) <a href=\"https://golang.org/src/math/big/rat.go?s=12030:12063#L473\">Sub</a>  </h3> <pre data-language=\"go\">func (z *Rat) Sub(x, y *Rat) *Rat</pre> <p> Sub sets z to the difference x-y and returns z. </p> <h3 id=\"Rat.UnmarshalText\">func (*Rat) <a href=\"https://golang.org/src/math/big/ratmarsh.go?s=1771:1817#L57\">UnmarshalText</a>  </h3> <pre data-language=\"go\">func (z *Rat) UnmarshalText(text []byte) error</pre> <p> UnmarshalText implements the encoding.TextUnmarshaler interface. </p> <h2 id=\"RoundingMode\">type RoundingMode  </h2> <pre data-language=\"go\">type RoundingMode byte</pre> <p> RoundingMode determines how a Float value is rounded to the desired precision. Rounding may change the Float value; the rounding error is described by the Float's Accuracy. </p> <pre data-language=\"go\">const (\n        ToNearestEven RoundingMode = iota // == IEEE 754-2008 roundTiesToEven\n        ToNearestAway                     // == IEEE 754-2008 roundTiesToAway\n        ToZero                            // == IEEE 754-2008 roundTowardZero\n        AwayFromZero                      // no IEEE 754-2008 equivalent\n        ToNegativeInf                     // == IEEE 754-2008 roundTowardNegative\n        ToPositiveInf                     // == IEEE 754-2008 roundTowardPositive\n)</pre> <p> These constants define supported rounding modes. </p> <div id=\"example_RoundingMode\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n)\n\nfunc main() {\n\toperands := []float64{2.6, 2.5, 2.1, -2.1, -2.5, -2.6}\n\n\tfmt.Print(\"   x\")\n\tfor mode := big.ToNearestEven; mode &lt;= big.ToPositiveInf; mode++ {\n\t\tfmt.Printf(\"  %s\", mode)\n\t}\n\tfmt.Println()\n\n\tfor _, f64 := range operands {\n\t\tfmt.Printf(\"%4g\", f64)\n\t\tfor mode := big.ToNearestEven; mode &lt;= big.ToPositiveInf; mode++ {\n\t\t\t// sample operands above require 2 bits to represent mantissa\n\t\t\t// set binary precision to 2 to round them to integer values\n\t\t\tf := new(big.Float).SetPrec(2).SetMode(mode).SetFloat64(f64)\n\t\t\tfmt.Printf(\"  %*g\", len(mode.String()), f)\n\t\t}\n\t\tfmt.Println()\n\t}\n\n}\n</pre> </div> </div> <h3 id=\"RoundingMode.String\">func (RoundingMode) <a href=\"https://golang.org/src/math/big/roundingmode_string.go?s=251:288#L1\">String</a>  </h3> <pre data-language=\"go\">func (i RoundingMode) String() string</pre> <h2 id=\"Word\">type Word  </h2> <pre data-language=\"go\">type Word uintptr</pre> <p> A Word represents a single digit of a multi-precision unsigned integer. </p> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/math/big/float.go?s=38735:38827#L1398\" style=\"float: left;\">☞</a> <p> When rounding ToNegativeInf, the sign of Float values rounded to 0 is incorrect. </p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/math/big/\" class=\"_attribution-link\">https://golang.org/pkg/math/big/</a>\n  </p>\n</div>\n","os/index":"<h1>Package os</h1>     <ul id=\"short-nav\">\n<li><code>import \"os\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package os provides a platform-independent interface to operating system functionality. The design is Unix-like, although the error handling is Go-like; failing calls return values of type error rather than error numbers. Often, more information is available within the error. For example, if a call that takes a file name fails, such as Open or Stat, the error will include the failing file name when printed and will be of type *PathError, which may be unpacked for more information. </p> <p> The os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall. </p> <p> Here is a simple example, opening a file and reading some of it. </p> <pre data-language=\"go\">file, err := os.Open(\"file.go\") // For read access.\nif err != nil {\n\tlog.Fatal(err)\n}\n</pre> <p> If the open fails, the error string will be self-explanatory, like </p> <pre data-language=\"go\">open file.go: no such file or directory\n</pre> <p> The file's data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice. </p> <pre data-language=\"go\">data := make([]byte, 100)\ncount, err := file.Read(data)\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Printf(\"read %d bytes: %q\\n\", count, data[:count])\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Chdir\">func Chdir(dir string) error</a></li>\n<li><a href=\"#Chmod\">func Chmod(name string, mode FileMode) error</a></li>\n<li><a href=\"#Chown\">func Chown(name string, uid, gid int) error</a></li>\n<li><a href=\"#Chtimes\">func Chtimes(name string, atime time.Time, mtime time.Time) error</a></li>\n<li><a href=\"#Clearenv\">func Clearenv()</a></li>\n<li><a href=\"#Environ\">func Environ() []string</a></li>\n<li><a href=\"#Exit\">func Exit(code int)</a></li>\n<li><a href=\"#Expand\">func Expand(s string, mapping func(string) string) string</a></li>\n<li><a href=\"#ExpandEnv\">func ExpandEnv(s string) string</a></li>\n<li><a href=\"#Getegid\">func Getegid() int</a></li>\n<li><a href=\"#Getenv\">func Getenv(key string) string</a></li>\n<li><a href=\"#Geteuid\">func Geteuid() int</a></li>\n<li><a href=\"#Getgid\">func Getgid() int</a></li>\n<li><a href=\"#Getgroups\">func Getgroups() ([]int, error)</a></li>\n<li><a href=\"#Getpagesize\">func Getpagesize() int</a></li>\n<li><a href=\"#Getpid\">func Getpid() int</a></li>\n<li><a href=\"#Getppid\">func Getppid() int</a></li>\n<li><a href=\"#Getuid\">func Getuid() int</a></li>\n<li><a href=\"#Getwd\">func Getwd() (dir string, err error)</a></li>\n<li><a href=\"#Hostname\">func Hostname() (name string, err error)</a></li>\n<li><a href=\"#IsExist\">func IsExist(err error) bool</a></li>\n<li><a href=\"#IsNotExist\">func IsNotExist(err error) bool</a></li>\n<li><a href=\"#IsPathSeparator\">func IsPathSeparator(c uint8) bool</a></li>\n<li><a href=\"#IsPermission\">func IsPermission(err error) bool</a></li>\n<li><a href=\"#Lchown\">func Lchown(name string, uid, gid int) error</a></li>\n<li><a href=\"#Link\">func Link(oldname, newname string) error</a></li>\n<li><a href=\"#LookupEnv\">func LookupEnv(key string) (string, bool)</a></li>\n<li><a href=\"#Mkdir\">func Mkdir(name string, perm FileMode) error</a></li>\n<li><a href=\"#MkdirAll\">func MkdirAll(path string, perm FileMode) error</a></li>\n<li><a href=\"#NewSyscallError\">func NewSyscallError(syscall string, err error) error</a></li>\n<li><a href=\"#Readlink\">func Readlink(name string) (string, error)</a></li>\n<li><a href=\"#Remove\">func Remove(name string) error</a></li>\n<li><a href=\"#RemoveAll\">func RemoveAll(path string) error</a></li>\n<li><a href=\"#Rename\">func Rename(oldpath, newpath string) error</a></li>\n<li><a href=\"#SameFile\">func SameFile(fi1, fi2 FileInfo) bool</a></li>\n<li><a href=\"#Setenv\">func Setenv(key, value string) error</a></li>\n<li><a href=\"#Symlink\">func Symlink(oldname, newname string) error</a></li>\n<li><a href=\"#TempDir\">func TempDir() string</a></li>\n<li><a href=\"#Truncate\">func Truncate(name string, size int64) error</a></li>\n<li><a href=\"#Unsetenv\">func Unsetenv(key string) error</a></li>\n<li><a href=\"#File\">type File</a></li>\n<li> <a href=\"#Create\">func Create(name string) (*File, error)</a>\n</li>\n<li> <a href=\"#NewFile\">func NewFile(fd uintptr, name string) *File</a>\n</li>\n<li> <a href=\"#Open\">func Open(name string) (*File, error)</a>\n</li>\n<li> <a href=\"#OpenFile\">func OpenFile(name string, flag int, perm FileMode) (*File, error)</a>\n</li>\n<li> <a href=\"#Pipe\">func Pipe() (r *File, w *File, err error)</a>\n</li>\n<li> <a href=\"#File.Chdir\">func (f *File) Chdir() error</a>\n</li>\n<li> <a href=\"#File.Chmod\">func (f *File) Chmod(mode FileMode) error</a>\n</li>\n<li> <a href=\"#File.Chown\">func (f *File) Chown(uid, gid int) error</a>\n</li>\n<li> <a href=\"#File.Close\">func (f *File) Close() error</a>\n</li>\n<li> <a href=\"#File.Fd\">func (f *File) Fd() uintptr</a>\n</li>\n<li> <a href=\"#File.Name\">func (f *File) Name() string</a>\n</li>\n<li> <a href=\"#File.Read\">func (f *File) Read(b []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#File.ReadAt\">func (f *File) ReadAt(b []byte, off int64) (n int, err error)</a>\n</li>\n<li> <a href=\"#File.Readdir\">func (f *File) Readdir(n int) ([]FileInfo, error)</a>\n</li>\n<li> <a href=\"#File.Readdirnames\">func (f *File) Readdirnames(n int) (names []string, err error)</a>\n</li>\n<li> <a href=\"#File.Seek\">func (f *File) Seek(offset int64, whence int) (ret int64, err error)</a>\n</li>\n<li> <a href=\"#File.Stat\">func (f *File) Stat() (FileInfo, error)</a>\n</li>\n<li> <a href=\"#File.Sync\">func (f *File) Sync() error</a>\n</li>\n<li> <a href=\"#File.Truncate\">func (f *File) Truncate(size int64) error</a>\n</li>\n<li> <a href=\"#File.Write\">func (f *File) Write(b []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#File.WriteAt\">func (f *File) WriteAt(b []byte, off int64) (n int, err error)</a>\n</li>\n<li> <a href=\"#File.WriteString\">func (f *File) WriteString(s string) (n int, err error)</a>\n</li>\n<li><a href=\"#FileInfo\">type FileInfo</a></li>\n<li> <a href=\"#Lstat\">func Lstat(name string) (FileInfo, error)</a>\n</li>\n<li> <a href=\"#Stat\">func Stat(name string) (FileInfo, error)</a>\n</li>\n<li><a href=\"#FileMode\">type FileMode</a></li>\n<li> <a href=\"#FileMode.IsDir\">func (m FileMode) IsDir() bool</a>\n</li>\n<li> <a href=\"#FileMode.IsRegular\">func (m FileMode) IsRegular() bool</a>\n</li>\n<li> <a href=\"#FileMode.Perm\">func (m FileMode) Perm() FileMode</a>\n</li>\n<li> <a href=\"#FileMode.String\">func (m FileMode) String() string</a>\n</li>\n<li><a href=\"#LinkError\">type LinkError</a></li>\n<li> <a href=\"#LinkError.Error\">func (e *LinkError) Error() string</a>\n</li>\n<li><a href=\"#PathError\">type PathError</a></li>\n<li> <a href=\"#PathError.Error\">func (e *PathError) Error() string</a>\n</li>\n<li><a href=\"#ProcAttr\">type ProcAttr</a></li>\n<li><a href=\"#Process\">type Process</a></li>\n<li> <a href=\"#FindProcess\">func FindProcess(pid int) (*Process, error)</a>\n</li>\n<li> <a href=\"#StartProcess\">func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)</a>\n</li>\n<li> <a href=\"#Process.Kill\">func (p *Process) Kill() error</a>\n</li>\n<li> <a href=\"#Process.Release\">func (p *Process) Release() error</a>\n</li>\n<li> <a href=\"#Process.Signal\">func (p *Process) Signal(sig Signal) error</a>\n</li>\n<li> <a href=\"#Process.Wait\">func (p *Process) Wait() (*ProcessState, error)</a>\n</li>\n<li><a href=\"#ProcessState\">type ProcessState</a></li>\n<li> <a href=\"#ProcessState.Exited\">func (p *ProcessState) Exited() bool</a>\n</li>\n<li> <a href=\"#ProcessState.Pid\">func (p *ProcessState) Pid() int</a>\n</li>\n<li> <a href=\"#ProcessState.String\">func (p *ProcessState) String() string</a>\n</li>\n<li> <a href=\"#ProcessState.Success\">func (p *ProcessState) Success() bool</a>\n</li>\n<li> <a href=\"#ProcessState.Sys\">func (p *ProcessState) Sys() interface{}</a>\n</li>\n<li> <a href=\"#ProcessState.SysUsage\">func (p *ProcessState) SysUsage() interface{}</a>\n</li>\n<li> <a href=\"#ProcessState.SystemTime\">func (p *ProcessState) SystemTime() time.Duration</a>\n</li>\n<li> <a href=\"#ProcessState.UserTime\">func (p *ProcessState) UserTime() time.Duration</a>\n</li>\n<li><a href=\"#Signal\">type Signal</a></li>\n<li><a href=\"#SyscallError\">type SyscallError</a></li>\n<li> <a href=\"#SyscallError.Error\">func (e *SyscallError) Error() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/os/dir_unix.go\">dir_unix.go</a> <a href=\"https://golang.org/src/os/doc.go\">doc.go</a> <a href=\"https://golang.org/src/os/env.go\">env.go</a> <a href=\"https://golang.org/src/os/error.go\">error.go</a> <a href=\"https://golang.org/src/os/error_unix.go\">error_unix.go</a> <a href=\"https://golang.org/src/os/exec.go\">exec.go</a> <a href=\"https://golang.org/src/os/exec_posix.go\">exec_posix.go</a> <a href=\"https://golang.org/src/os/exec_unix.go\">exec_unix.go</a> <a href=\"https://golang.org/src/os/file.go\">file.go</a> <a href=\"https://golang.org/src/os/file_posix.go\">file_posix.go</a> <a href=\"https://golang.org/src/os/file_unix.go\">file_unix.go</a> <a href=\"https://golang.org/src/os/getwd.go\">getwd.go</a> <a href=\"https://golang.org/src/os/path.go\">path.go</a> <a href=\"https://golang.org/src/os/path_unix.go\">path_unix.go</a> <a href=\"https://golang.org/src/os/pipe_linux.go\">pipe_linux.go</a> <a href=\"https://golang.org/src/os/proc.go\">proc.go</a> <a href=\"https://golang.org/src/os/stat_linux.go\">stat_linux.go</a> <a href=\"https://golang.org/src/os/sticky_notbsd.go\">sticky_notbsd.go</a> <a href=\"https://golang.org/src/os/str.go\">str.go</a> <a href=\"https://golang.org/src/os/sys_linux.go\">sys_linux.go</a> <a href=\"https://golang.org/src/os/sys_unix.go\">sys_unix.go</a> <a href=\"https://golang.org/src/os/types.go\">types.go</a> <a href=\"https://golang.org/src/os/types_unix.go\">types_unix.go</a> <a href=\"https://golang.org/src/os/wait_waitid.go\">wait_waitid.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        O_RDONLY int = syscall.O_RDONLY // open the file read-only.\n        O_WRONLY int = syscall.O_WRONLY // open the file write-only.\n        O_RDWR   int = syscall.O_RDWR   // open the file read-write.\n        O_APPEND int = syscall.O_APPEND // append data to the file when writing.\n        O_CREATE int = syscall.O_CREAT  // create a new file if none exists.\n        O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist\n        O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.\n        O_TRUNC  int = syscall.O_TRUNC  // if possible, truncate file when opened.\n)</pre> <p> Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. </p> <pre data-language=\"go\">const (\n        SEEK_SET int = 0 // seek relative to the origin of the file\n        SEEK_CUR int = 1 // seek relative to the current offset\n        SEEK_END int = 2 // seek relative to the end\n)</pre> <p> Seek whence values. </p> <p> Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd. </p> <pre data-language=\"go\">const (\n        PathSeparator     = '/' // OS-specific path separator\n        PathListSeparator = ':' // OS-specific path list separator\n)</pre> <pre data-language=\"go\">const DevNull = \"/dev/null\"</pre> <p> DevNull is the name of the operating system's “null device.” On Unix-like systems, it is \"/dev/null\"; on Windows, \"NUL\". </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        ErrInvalid    = errors.New(\"invalid argument\") // methods on File will return this error when the receiver is nil\n        ErrPermission = errors.New(\"permission denied\")\n        ErrExist      = errors.New(\"file already exists\")\n        ErrNotExist   = errors.New(\"file does not exist\")\n)</pre> <p> Portable analogs of some common system call errors. </p> <pre data-language=\"go\">var (\n        Stdin  = NewFile(uintptr(syscall.Stdin), \"/dev/stdin\")\n        Stdout = NewFile(uintptr(syscall.Stdout), \"/dev/stdout\")\n        Stderr = NewFile(uintptr(syscall.Stderr), \"/dev/stderr\")\n)</pre> <p> Stdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors. </p> <p> Note that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later. </p> <pre data-language=\"go\">var Args []string</pre> <p> Args hold the command-line arguments, starting with the program name. </p> <h2 id=\"Chdir\">func Chdir  </h2> <pre data-language=\"go\">func Chdir(dir string) error</pre> <p> Chdir changes the current working directory to the named directory. If there is an error, it will be of type *PathError. </p> <h2 id=\"Chmod\">func Chmod  </h2> <pre data-language=\"go\">func Chmod(name string, mode FileMode) error</pre> <p> Chmod changes the mode of the named file to mode. If the file is a symbolic link, it changes the mode of the link's target. If there is an error, it will be of type *PathError. </p> <h2 id=\"Chown\">func Chown  </h2> <pre data-language=\"go\">func Chown(name string, uid, gid int) error</pre> <p> Chown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link's target. If there is an error, it will be of type *PathError. </p> <h2 id=\"Chtimes\">func Chtimes  </h2> <pre data-language=\"go\">func Chtimes(name string, atime time.Time, mtime time.Time) error</pre> <p> Chtimes changes the access and modification times of the named file, similar to the Unix utime() or utimes() functions. </p> <p> The underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type *PathError. </p> <h2 id=\"Clearenv\">func Clearenv  </h2> <pre data-language=\"go\">func Clearenv()</pre> <p> Clearenv deletes all environment variables. </p> <h2 id=\"Environ\">func Environ  </h2> <pre data-language=\"go\">func Environ() []string</pre> <p> Environ returns a copy of strings representing the environment, in the form \"key=value\". </p> <h2 id=\"Exit\">func Exit  </h2> <pre data-language=\"go\">func Exit(code int)</pre> <p> Exit causes the current program to exit with the given status code. Conventionally, code zero indicates success, non-zero an error. The program terminates immediately; deferred functions are not run. </p> <h2 id=\"Expand\">func Expand  </h2> <pre data-language=\"go\">func Expand(s string, mapping func(string) string) string</pre> <p> Expand replaces ${var} or $var in the string based on the mapping function. For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv). </p> <h2 id=\"ExpandEnv\">func ExpandEnv  </h2> <pre data-language=\"go\">func ExpandEnv(s string) string</pre> <p> ExpandEnv replaces ${var} or $var in the string according to the values of the current environment variables. References to undefined variables are replaced by the empty string. </p> <h2 id=\"Getegid\">func Getegid  </h2> <pre data-language=\"go\">func Getegid() int</pre> <p> Getegid returns the numeric effective group id of the caller. </p> <h2 id=\"Getenv\">func Getenv  </h2> <pre data-language=\"go\">func Getenv(key string) string</pre> <p> Getenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. </p> <h2 id=\"Geteuid\">func Geteuid  </h2> <pre data-language=\"go\">func Geteuid() int</pre> <p> Geteuid returns the numeric effective user id of the caller. </p> <h2 id=\"Getgid\">func Getgid  </h2> <pre data-language=\"go\">func Getgid() int</pre> <p> Getgid returns the numeric group id of the caller. </p> <h2 id=\"Getgroups\">func Getgroups  </h2> <pre data-language=\"go\">func Getgroups() ([]int, error)</pre> <p> Getgroups returns a list of the numeric ids of groups that the caller belongs to. </p> <h2 id=\"Getpagesize\">func Getpagesize  </h2> <pre data-language=\"go\">func Getpagesize() int</pre> <p> Getpagesize returns the underlying system's memory page size. </p> <h2 id=\"Getpid\">func Getpid  </h2> <pre data-language=\"go\">func Getpid() int</pre> <p> Getpid returns the process id of the caller. </p> <h2 id=\"Getppid\">func Getppid  </h2> <pre data-language=\"go\">func Getppid() int</pre> <p> Getppid returns the process id of the caller's parent. </p> <h2 id=\"Getuid\">func Getuid  </h2> <pre data-language=\"go\">func Getuid() int</pre> <p> Getuid returns the numeric user id of the caller. </p> <h2 id=\"Getwd\">func Getwd  </h2> <pre data-language=\"go\">func Getwd() (dir string, err error)</pre> <p> Getwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them. </p> <h2 id=\"Hostname\">func Hostname  </h2> <pre data-language=\"go\">func Hostname() (name string, err error)</pre> <p> Hostname returns the host name reported by the kernel. </p> <h2 id=\"IsExist\">func IsExist  </h2> <pre data-language=\"go\">func IsExist(err error) bool</pre> <p> IsExist returns a boolean indicating whether the error is known to report that a file or directory already exists. It is satisfied by ErrExist as well as some syscall errors. </p> <h2 id=\"IsNotExist\">func IsNotExist  </h2> <pre data-language=\"go\">func IsNotExist(err error) bool</pre> <p> IsNotExist returns a boolean indicating whether the error is known to report that a file or directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors. </p> <h2 id=\"IsPathSeparator\">func IsPathSeparator  </h2> <pre data-language=\"go\">func IsPathSeparator(c uint8) bool</pre> <p> IsPathSeparator reports whether c is a directory separator character. </p> <h2 id=\"IsPermission\">func IsPermission  </h2> <pre data-language=\"go\">func IsPermission(err error) bool</pre> <p> IsPermission returns a boolean indicating whether the error is known to report that permission is denied. It is satisfied by ErrPermission as well as some syscall errors. </p> <h2 id=\"Lchown\">func Lchown  </h2> <pre data-language=\"go\">func Lchown(name string, uid, gid int) error</pre> <p> Lchown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link itself. If there is an error, it will be of type *PathError. </p> <h2 id=\"Link\">func Link  </h2> <pre data-language=\"go\">func Link(oldname, newname string) error</pre> <p> Link creates newname as a hard link to the oldname file. If there is an error, it will be of type *LinkError. </p> <h2 id=\"LookupEnv\">func LookupEnv  </h2> <pre data-language=\"go\">func LookupEnv(key string) (string, bool)</pre> <p> LookupEnv retrieves the value of the environment variable named by the key. If the variable is present in the environment the value (which may be empty) is returned and the boolean is true. Otherwise the returned value will be empty and the boolean will be false. </p> <h2 id=\"Mkdir\">func Mkdir  </h2> <pre data-language=\"go\">func Mkdir(name string, perm FileMode) error</pre> <p> Mkdir creates a new directory with the specified name and permission bits. If there is an error, it will be of type *PathError. </p> <h2 id=\"MkdirAll\">func MkdirAll  </h2> <pre data-language=\"go\">func MkdirAll(path string, perm FileMode) error</pre> <p> MkdirAll creates a directory named path, along with any necessary parents, and returns nil, or else returns an error. The permission bits perm are used for all directories that MkdirAll creates. If path is already a directory, MkdirAll does nothing and returns nil. </p> <h2 id=\"NewSyscallError\">func NewSyscallError  </h2> <pre data-language=\"go\">func NewSyscallError(syscall string, err error) error</pre> <p> NewSyscallError returns, as an error, a new SyscallError with the given system call name and error details. As a convenience, if err is nil, NewSyscallError returns nil. </p> <h2 id=\"Readlink\">func Readlink  </h2> <pre data-language=\"go\">func Readlink(name string) (string, error)</pre> <p> Readlink returns the destination of the named symbolic link. If there is an error, it will be of type *PathError. </p> <h2 id=\"Remove\">func Remove  </h2> <pre data-language=\"go\">func Remove(name string) error</pre> <p> Remove removes the named file or directory. If there is an error, it will be of type *PathError. </p> <h2 id=\"RemoveAll\">func RemoveAll  </h2> <pre data-language=\"go\">func RemoveAll(path string) error</pre> <p> RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error). </p> <h2 id=\"Rename\">func Rename  </h2> <pre data-language=\"go\">func Rename(oldpath, newpath string) error</pre> <p> Rename renames (moves) oldpath to newpath. If newpath already exists, Rename replaces it. OS-specific restrictions may apply when oldpath and newpath are in different directories. If there is an error, it will be of type *LinkError. </p> <h2 id=\"SameFile\">func SameFile  </h2> <pre data-language=\"go\">func SameFile(fi1, fi2 FileInfo) bool</pre> <p> SameFile reports whether fi1 and fi2 describe the same file. For example, on Unix this means that the device and inode fields of the two underlying structures are identical; on other systems the decision may be based on the path names. SameFile only applies to results returned by this package's Stat. It returns false in other cases. </p> <h2 id=\"Setenv\">func Setenv  </h2> <pre data-language=\"go\">func Setenv(key, value string) error</pre> <p> Setenv sets the value of the environment variable named by the key. It returns an error, if any. </p> <h2 id=\"Symlink\">func Symlink  </h2> <pre data-language=\"go\">func Symlink(oldname, newname string) error</pre> <p> Symlink creates newname as a symbolic link to oldname. If there is an error, it will be of type *LinkError. </p> <h2 id=\"TempDir\">func TempDir  </h2> <pre data-language=\"go\">func TempDir() string</pre> <p> TempDir returns the default directory to use for temporary files. </p> <h2 id=\"Truncate\">func Truncate  </h2> <pre data-language=\"go\">func Truncate(name string, size int64) error</pre> <p> Truncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type *PathError. </p> <h2 id=\"Unsetenv\">func Unsetenv  </h2> <pre data-language=\"go\">func Unsetenv(key string) error</pre> <p> Unsetenv unsets a single environment variable. </p> <h2 id=\"File\">type File  </h2> <pre data-language=\"go\">type File struct {\n        // contains filtered or unexported fields\n}</pre> <p> File represents an open file descriptor. </p> <h3 id=\"Create\">func <a href=\"https://golang.org/src/os/file.go?s=7623:7662#L248\">Create</a>  </h3> <pre data-language=\"go\">func Create(name string) (*File, error)</pre> <p> Create creates the named file with mode 0666 (before umask), truncating it if it already exists. If successful, methods on the returned File can be used for I/O; the associated file descriptor has mode O_RDWR. If there is an error, it will be of type *PathError. </p> <h3 id=\"NewFile\">func <a href=\"https://golang.org/src/os/file_unix.go?s=1267:1310#L41\">NewFile</a>  </h3> <pre data-language=\"go\">func NewFile(fd uintptr, name string) *File</pre> <p> NewFile returns a new File with the given file descriptor and name. </p> <h3 id=\"Open\">func <a href=\"https://golang.org/src/os/file.go?s=7266:7303#L239\">Open</a>  </h3> <pre data-language=\"go\">func Open(name string) (*File, error)</pre> <p> Open opens the named file for reading. If successful, methods on the returned file can be used for reading; the associated file descriptor has mode O_RDONLY. If there is an error, it will be of type *PathError. </p> <h3 id=\"OpenFile\">func <a href=\"https://golang.org/src/os/file_unix.go?s=2430:2496#L76\">OpenFile</a>  </h3> <pre data-language=\"go\">func OpenFile(name string, flag int, perm FileMode) (*File, error)</pre> <p> OpenFile is the generalized open call; most users will use Open or Create instead. It opens the named file with specified flag (O_RDONLY etc.) and perm, (0666 etc.) if applicable. If successful, methods on the returned File can be used for I/O. If there is an error, it will be of type *PathError. </p> <h3 id=\"Pipe\">func <a href=\"https://golang.org/src/os/pipe_linux.go?s=319:360#L1\">Pipe</a>  </h3> <pre data-language=\"go\">func Pipe() (r *File, w *File, err error)</pre> <p> Pipe returns a connected pair of Files; reads from r return bytes written to w. It returns the files and an error, if any. </p> <h3 id=\"File.Chdir\">func (*File) <a href=\"https://golang.org/src/os/file.go?s=6874:6902#L225\">Chdir</a>  </h3> <pre data-language=\"go\">func (f *File) Chdir() error</pre> <p> Chdir changes the current working directory to the file, which must be a directory. If there is an error, it will be of type *PathError. </p> <h3 id=\"File.Chmod\">func (*File) <a href=\"https://golang.org/src/os/file_posix.go?s=1532:1573#L49\">Chmod</a>  </h3> <pre data-language=\"go\">func (f *File) Chmod(mode FileMode) error</pre> <p> Chmod changes the mode of the file to mode. If there is an error, it will be of type *PathError. </p> <h3 id=\"File.Chown\">func (*File) <a href=\"https://golang.org/src/os/file_posix.go?s=2557:2597#L81\">Chown</a>  </h3> <pre data-language=\"go\">func (f *File) Chown(uid, gid int) error</pre> <p> Chown changes the numeric uid and gid of the named file. If there is an error, it will be of type *PathError. </p> <h3 id=\"File.Close\">func (*File) <a href=\"https://golang.org/src/os/file_unix.go?s=3522:3550#L118\">Close</a>  </h3> <pre data-language=\"go\">func (f *File) Close() error</pre> <p> Close closes the File, rendering it unusable for I/O. It returns an error, if any. </p> <h3 id=\"File.Fd\">func (*File) <a href=\"https://golang.org/src/os/file_unix.go?s=1100:1127#L33\">Fd</a>  </h3> <pre data-language=\"go\">func (f *File) Fd() uintptr</pre> <p> Fd returns the integer Unix file descriptor referencing the open file. The file descriptor is valid only until f.Close is called or f is garbage collected. </p> <h3 id=\"File.Name\">func (*File) <a href=\"https://golang.org/src/os/file.go?s=1531:1559#L35\">Name</a>  </h3> <pre data-language=\"go\">func (f *File) Name() string</pre> <p> Name returns the name of the file as presented to Open. </p> <h3 id=\"File.Read\">func (*File) <a href=\"https://golang.org/src/os/file.go?s=3461:3509#L87\">Read</a>  </h3> <pre data-language=\"go\">func (f *File) Read(b []byte) (n int, err error)</pre> <p> Read reads up to len(b) bytes from the File. It returns the number of bytes read and an error, if any. EOF is signaled by a zero count with err set to io.EOF. </p> <h3 id=\"File.ReadAt\">func (*File) <a href=\"https://golang.org/src/os/file.go?s=3940:4001#L105\">ReadAt</a>  </h3> <pre data-language=\"go\">func (f *File) ReadAt(b []byte, off int64) (n int, err error)</pre> <p> ReadAt reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. ReadAt always returns a non-nil error when n &lt; len(b). At end of file, that error is io.EOF. </p> <h3 id=\"File.Readdir\">func (*File) <a href=\"https://golang.org/src/os/doc.go?s=3939:3988#L105\">Readdir</a>  </h3> <pre data-language=\"go\">func (f *File) Readdir(n int) ([]FileInfo, error)</pre> <p> Readdir reads the contents of the directory associated with file and returns a slice of up to n FileInfo values, as would be returned by Lstat, in directory order. Subsequent calls on the same file will yield further FileInfos. </p> <p> If n &gt; 0, Readdir returns at most n FileInfo structures. In this case, if Readdir returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF. </p> <p> If n &lt;= 0, Readdir returns all the FileInfo from the directory in a single slice. In this case, if Readdir succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdir returns the FileInfo read until that point and a non-nil error. </p> <h3 id=\"File.Readdirnames\">func (*File) <a href=\"https://golang.org/src/os/doc.go?s=4704:4766#L124\">Readdirnames</a>  </h3> <pre data-language=\"go\">func (f *File) Readdirnames(n int) (names []string, err error)</pre> <p> Readdirnames reads and returns a slice of names from the directory f. </p> <p> If n &gt; 0, Readdirnames returns at most n names. In this case, if Readdirnames returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF. </p> <p> If n &lt;= 0, Readdirnames returns all the names from the directory in a single slice. In this case, if Readdirnames succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdirnames returns the names read until that point and a non-nil error. </p> <h3 id=\"File.Seek\">func (*File) <a href=\"https://golang.org/src/os/file.go?s=5506:5574#L173\">Seek</a>  </h3> <pre data-language=\"go\">func (f *File) Seek(offset int64, whence int) (ret int64, err error)</pre> <p> Seek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. The behavior of Seek on a file opened with O_APPEND is not specified. </p> <h3 id=\"File.Stat\">func (*File) <a href=\"https://golang.org/src/os/file_unix.go?s=4057:4096#L142\">Stat</a>  </h3> <pre data-language=\"go\">func (f *File) Stat() (FileInfo, error)</pre> <p> Stat returns the FileInfo structure describing file. If there is an error, it will be of type *PathError. </p> <h3 id=\"File.Sync\">func (*File) <a href=\"https://golang.org/src/os/file_posix.go?s=3250:3277#L107\">Sync</a>  </h3> <pre data-language=\"go\">func (f *File) Sync() error</pre> <p> Sync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk. </p> <h3 id=\"File.Truncate\">func (*File) <a href=\"https://golang.org/src/os/file_posix.go?s=2884:2925#L94\">Truncate</a>  </h3> <pre data-language=\"go\">func (f *File) Truncate(size int64) error</pre> <p> Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError. </p> <h3 id=\"File.Write\">func (*File) <a href=\"https://golang.org/src/os/file.go?s=4417:4466#L128\">Write</a>  </h3> <pre data-language=\"go\">func (f *File) Write(b []byte) (n int, err error)</pre> <p> Write writes len(b) bytes to the File. It returns the number of bytes written and an error, if any. Write returns a non-nil error when n != len(b). </p> <h3 id=\"File.WriteAt\">func (*File) <a href=\"https://golang.org/src/os/file.go?s=4883:4945#L151\">WriteAt</a>  </h3> <pre data-language=\"go\">func (f *File) WriteAt(b []byte, off int64) (n int, err error)</pre> <p> WriteAt writes len(b) bytes to the File starting at byte offset off. It returns the number of bytes written and an error, if any. WriteAt returns a non-nil error when n != len(b). </p> <h3 id=\"File.WriteString\">func (*File) <a href=\"https://golang.org/src/os/file.go?s=5896:5951#L189\">WriteString</a>  </h3> <pre data-language=\"go\">func (f *File) WriteString(s string) (n int, err error)</pre> <p> WriteString is like Write, but writes the contents of string s rather than a slice of bytes. </p> <h2 id=\"FileInfo\">type FileInfo  </h2> <pre data-language=\"go\">type FileInfo interface {\n        Name() string       // base name of the file\n        Size() int64        // length in bytes for regular files; system-dependent for others\n        Mode() FileMode     // file mode bits\n        ModTime() time.Time // modification time\n        IsDir() bool        // abbreviation for Mode().IsDir()\n        Sys() interface{}   // underlying data source (can return nil)\n}</pre> <p> A FileInfo describes a file and is returned by Stat and Lstat. </p> <h3 id=\"Lstat\">func <a href=\"https://golang.org/src/os/file_unix.go?s=4881:4922#L171\">Lstat</a>  </h3> <pre data-language=\"go\">func Lstat(name string) (FileInfo, error)</pre> <p> Lstat returns a FileInfo describing the named file. If the file is a symbolic link, the returned FileInfo describes the symbolic link. Lstat makes no attempt to follow the link. If there is an error, it will be of type *PathError. </p> <h3 id=\"Stat\">func <a href=\"https://golang.org/src/os/file_unix.go?s=4426:4466#L157\">Stat</a>  </h3> <pre data-language=\"go\">func Stat(name string) (FileInfo, error)</pre> <p> Stat returns a FileInfo describing the named file. If there is an error, it will be of type *PathError. </p> <h2 id=\"FileMode\">type FileMode  </h2> <pre data-language=\"go\">type FileMode uint32</pre> <p> A FileMode represents a file's mode and permission bits. The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is ModeDir for directories. </p> <pre data-language=\"go\">const (\n        // The single letters are the abbreviations\n        // used by the String method's formatting.\n        ModeDir        FileMode = 1 &lt;&lt; (32 - 1 - iota) // d: is a directory\n        ModeAppend                                     // a: append-only\n        ModeExclusive                                  // l: exclusive use\n        ModeTemporary                                  // T: temporary file (not backed up)\n        ModeSymlink                                    // L: symbolic link\n        ModeDevice                                     // D: device file\n        ModeNamedPipe                                  // p: named pipe (FIFO)\n        ModeSocket                                     // S: Unix domain socket\n        ModeSetuid                                     // u: setuid\n        ModeSetgid                                     // g: setgid\n        ModeCharDevice                                 // c: Unix character device, when ModeDevice is set\n        ModeSticky                                     // t: sticky\n\n        // Mask for the type bits. For regular files, none will be set.\n        ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice\n\n        ModePerm FileMode = 0777 // Unix permission bits\n)</pre> <p> The defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. </p> <h3 id=\"FileMode.IsDir\">func (FileMode) <a href=\"https://golang.org/src/os/types.go?s=3074:3104#L77\">IsDir</a>  </h3> <pre data-language=\"go\">func (m FileMode) IsDir() bool</pre> <p> IsDir reports whether m describes a directory. That is, it tests for the ModeDir bit being set in m. </p> <h3 id=\"FileMode.IsRegular\">func (FileMode) <a href=\"https://golang.org/src/os/types.go?s=3243:3277#L83\">IsRegular</a>  </h3> <pre data-language=\"go\">func (m FileMode) IsRegular() bool</pre> <p> IsRegular reports whether m describes a regular file. That is, it tests that no mode type bits are set. </p> <h3 id=\"FileMode.Perm\">func (FileMode) <a href=\"https://golang.org/src/os/types.go?s=3354:3387#L88\">Perm</a>  </h3> <pre data-language=\"go\">func (m FileMode) Perm() FileMode</pre> <p> Perm returns the Unix permission bits in m. </p> <h3 id=\"FileMode.String\">func (FileMode) <a href=\"https://golang.org/src/os/types.go?s=2562:2595#L49\">String</a>  </h3> <pre data-language=\"go\">func (m FileMode) String() string</pre> <h2 id=\"LinkError\">type LinkError  </h2> <pre data-language=\"go\">type LinkError struct {\n        Op  string\n        Old string\n        New string\n        Err error\n}</pre> <p> LinkError records an error during a link or symlink or rename system call and the paths that caused it. </p> <h3 id=\"LinkError.Error\">func (*LinkError) <a href=\"https://golang.org/src/os/file.go?s=3189:3223#L80\">Error</a>  </h3> <pre data-language=\"go\">func (e *LinkError) Error() string</pre> <h2 id=\"PathError\">type PathError  </h2> <pre data-language=\"go\">type PathError struct {\n        Op   string\n        Path string\n        Err  error\n}</pre> <p> PathError records an error and the operation and file path that caused it. </p> <h3 id=\"PathError.Error\">func (*PathError) <a href=\"https://golang.org/src/os/error.go?s=667:701#L16\">Error</a>  </h3> <pre data-language=\"go\">func (e *PathError) Error() string</pre> <h2 id=\"ProcAttr\">type ProcAttr  </h2> <pre data-language=\"go\">type ProcAttr struct {\n        // If Dir is non-empty, the child changes into the directory before\n        // creating the process.\n        Dir string\n        // If Env is non-nil, it gives the environment variables for the\n        // new process in the form returned by Environ.\n        // If it is nil, the result of Environ will be used.\n        Env []string\n        // Files specifies the open files inherited by the new process. The\n        // first three entries correspond to standard input, standard output, and\n        // standard error. An implementation may support additional entries,\n        // depending on the underlying operating system. A nil entry corresponds\n        // to that file being closed when the process starts.\n        Files []*File\n\n        // Operating system-specific process creation attributes.\n        // Note that setting this field means that your program\n        // may not execute properly or even compile on some\n        // operating systems.\n        Sys *syscall.SysProcAttr\n}</pre> <p> ProcAttr holds the attributes that will be applied to a new process started by StartProcess. </p> <h2 id=\"Process\">type Process  </h2> <pre data-language=\"go\">type Process struct {\n        Pid int\n        // contains filtered or unexported fields\n}</pre> <p> Process stores the information about a process created by StartProcess. </p> <h3 id=\"FindProcess\">func <a href=\"https://golang.org/src/os/doc.go?s=492:535#L6\">FindProcess</a>  </h3> <pre data-language=\"go\">func FindProcess(pid int) (*Process, error)</pre> <p> FindProcess looks for a running process by its pid. </p> <p> The Process it returns can be used to obtain information about the underlying operating system process. </p> <p> On Unix systems, FindProcess always succeeds and returns a Process for the given pid, regardless of whether the process exists. </p> <h3 id=\"StartProcess\">func <a href=\"https://golang.org/src/os/doc.go?s=844:923#L17\">StartProcess</a>  </h3> <pre data-language=\"go\">func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)</pre> <p> StartProcess starts a new process with the program, arguments and attributes specified by name, argv and attr. </p> <p> StartProcess is a low-level interface. The os/exec package provides higher-level interfaces. </p> <p> If there is an error, it will be of type *PathError. </p> <h3 id=\"Process.Kill\">func (*Process) <a href=\"https://golang.org/src/os/doc.go?s=1231:1261#L29\">Kill</a>  </h3> <pre data-language=\"go\">func (p *Process) Kill() error</pre> <p> Kill causes the Process to exit immediately. </p> <h3 id=\"Process.Release\">func (*Process) <a href=\"https://golang.org/src/os/doc.go?s=1124:1157#L24\">Release</a>  </h3> <pre data-language=\"go\">func (p *Process) Release() error</pre> <p> Release releases any resources associated with the Process p, rendering it unusable in the future. Release only needs to be called if Wait is not. </p> <h3 id=\"Process.Signal\">func (*Process) <a href=\"https://golang.org/src/os/doc.go?s=1739:1781#L44\">Signal</a>  </h3> <pre data-language=\"go\">func (p *Process) Signal(sig Signal) error</pre> <p> Signal sends a signal to the Process. Sending Interrupt on Windows is not implemented. </p> <h3 id=\"Process.Wait\">func (*Process) <a href=\"https://golang.org/src/os/doc.go?s=1576:1623#L38\">Wait</a>  </h3> <pre data-language=\"go\">func (p *Process) Wait() (*ProcessState, error)</pre> <p> Wait waits for the Process to exit, and then returns a ProcessState describing its status and an error, if any. Wait releases any resources associated with the Process. On most operating systems, the Process must be a child of the current process or an error will be returned. </p> <h2 id=\"ProcessState\">type ProcessState  </h2> <pre data-language=\"go\">type ProcessState struct {\n        // contains filtered or unexported fields\n}</pre> <p> ProcessState stores information about a process, as reported by Wait. </p> <h3 id=\"ProcessState.Exited\">func (*ProcessState) <a href=\"https://golang.org/src/os/doc.go?s=2171:2207#L59\">Exited</a>  </h3> <pre data-language=\"go\">func (p *ProcessState) Exited() bool</pre> <p> Exited reports whether the program has exited. </p> <h3 id=\"ProcessState.Pid\">func (*ProcessState) <a href=\"https://golang.org/src/os/exec_posix.go?s=1671:1703#L54\">Pid</a>  </h3> <pre data-language=\"go\">func (p *ProcessState) Pid() int</pre> <p> Pid returns the process id of the exited process. </p> <h3 id=\"ProcessState.String\">func (*ProcessState) <a href=\"https://golang.org/src/os/exec_posix.go?s=2000:2038#L74\">String</a>  </h3> <pre data-language=\"go\">func (p *ProcessState) String() string</pre> <h3 id=\"ProcessState.Success\">func (*ProcessState) <a href=\"https://golang.org/src/os/doc.go?s=2331:2368#L65\">Success</a>  </h3> <pre data-language=\"go\">func (p *ProcessState) Success() bool</pre> <p> Success reports whether the program exited successfully, such as with exit status 0 on Unix. </p> <h3 id=\"ProcessState.Sys\">func (*ProcessState) <a href=\"https://golang.org/src/os/doc.go?s=2575:2615#L72\">Sys</a>  </h3> <pre data-language=\"go\">func (p *ProcessState) Sys() interface{}</pre> <p> Sys returns system-dependent exit information about the process. Convert it to the appropriate underlying type, such as syscall.WaitStatus on Unix, to access its contents. </p> <h3 id=\"ProcessState.SysUsage\">func (*ProcessState) <a href=\"https://golang.org/src/os/doc.go?s=2936:2981#L81\">SysUsage</a>  </h3> <pre data-language=\"go\">func (p *ProcessState) SysUsage() interface{}</pre> <p> SysUsage returns system-dependent resource usage information about the exited process. Convert it to the appropriate underlying type, such as *syscall.Rusage on Unix, to access its contents. (On Unix, *syscall.Rusage matches struct rusage as defined in the getrusage(2) manual page.) </p> <h3 id=\"ProcessState.SystemTime\">func (*ProcessState) <a href=\"https://golang.org/src/os/doc.go?s=2043:2092#L54\">SystemTime</a>  </h3> <pre data-language=\"go\">func (p *ProcessState) SystemTime() time.Duration</pre> <p> SystemTime returns the system CPU time of the exited process and its children. </p> <h3 id=\"ProcessState.UserTime\">func (*ProcessState) <a href=\"https://golang.org/src/os/doc.go?s=1887:1934#L49\">UserTime</a>  </h3> <pre data-language=\"go\">func (p *ProcessState) UserTime() time.Duration</pre> <p> UserTime returns the user CPU time of the exited process and its children. </p> <h2 id=\"Signal\">type Signal  </h2> <pre data-language=\"go\">type Signal interface {\n        String() string\n        Signal() // to distinguish from other Stringers\n}</pre> <p> A Signal represents an operating system signal. The usual underlying implementation is operating system-dependent: on Unix it is syscall.Signal. </p> <pre data-language=\"go\">var (\n        Interrupt Signal = syscall.SIGINT\n        Kill      Signal = syscall.SIGKILL\n)</pre> <p> The only signal values guaranteed to be present on all systems are Interrupt (send the process an interrupt) and Kill (force the process to exit). </p> <h2 id=\"SyscallError\">type SyscallError  </h2> <pre data-language=\"go\">type SyscallError struct {\n        Syscall string\n        Err     error\n}</pre> <p> SyscallError records an error from a specific system call. </p> <h3 id=\"SyscallError.Error\">func (*SyscallError) <a href=\"https://golang.org/src/os/error.go?s=880:917#L24\">Error</a>  </h3> <pre data-language=\"go\">func (e *SyscallError) Error() string</pre> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"exec/index\">exec</a> </td> <td class=\"pkg-synopsis\"> Package exec runs external commands. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"signal/index\">signal</a> </td> <td class=\"pkg-synopsis\"> Package signal implements access to incoming signals. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"user/index\">user</a> </td> <td class=\"pkg-synopsis\"> Package user allows user account lookups by name or id. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/os/\" class=\"_attribution-link\">https://golang.org/pkg/os/</a>\n  </p>\n</div>\n","sort/index":"<h1>Package sort</h1>     <ul id=\"short-nav\">\n<li><code>import \"sort\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package sort provides primitives for sorting slices and user-defined collections. </p> </div> </div> <div id=\"example_\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype Person struct {\n\tName string\n\tAge  int\n}\n\nfunc (p Person) String() string {\n\treturn fmt.Sprintf(\"%s: %d\", p.Name, p.Age)\n}\n\n// ByAge implements sort.Interface for []Person based on\n// the Age field.\ntype ByAge []Person\n\nfunc (a ByAge) Len() int           { return len(a) }\nfunc (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a ByAge) Less(i, j int) bool { return a[i].Age &lt; a[j].Age }\n\nfunc main() {\n\tpeople := []Person{\n\t\t{\"Bob\", 31},\n\t\t{\"John\", 42},\n\t\t{\"Michael\", 17},\n\t\t{\"Jenny\", 26},\n\t}\n\n\tfmt.Println(people)\n\tsort.Sort(ByAge(people))\n\tfmt.Println(people)\n\n}\n</pre> </div> </div> <div id=\"example__sortKeys\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (SortKeys)</h2> <p>ExampleSortKeys demonstrates a technique for sorting a struct type using programmable sort criteria. </p> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// A couple of type definitions to make the units clear.\ntype earthMass float64\ntype au float64\n\n// A Planet defines the properties of a solar system object.\ntype Planet struct {\n\tname     string\n\tmass     earthMass\n\tdistance au\n}\n\n// By is the type of a \"less\" function that defines the ordering of its Planet arguments.\ntype By func(p1, p2 *Planet) bool\n\n// Sort is a method on the function type, By, that sorts the argument slice according to the function.\nfunc (by By) Sort(planets []Planet) {\n\tps := &amp;planetSorter{\n\t\tplanets: planets,\n\t\tby:      by, // The Sort method's receiver is the function (closure) that defines the sort order.\n\t}\n\tsort.Sort(ps)\n}\n\n// planetSorter joins a By function and a slice of Planets to be sorted.\ntype planetSorter struct {\n\tplanets []Planet\n\tby      func(p1, p2 *Planet) bool // Closure used in the Less method.\n}\n\n// Len is part of sort.Interface.\nfunc (s *planetSorter) Len() int {\n\treturn len(s.planets)\n}\n\n// Swap is part of sort.Interface.\nfunc (s *planetSorter) Swap(i, j int) {\n\ts.planets[i], s.planets[j] = s.planets[j], s.planets[i]\n}\n\n// Less is part of sort.Interface. It is implemented by calling the \"by\" closure in the sorter.\nfunc (s *planetSorter) Less(i, j int) bool {\n\treturn s.by(&amp;s.planets[i], &amp;s.planets[j])\n}\n\nvar planets = []Planet{\n\t{\"Mercury\", 0.055, 0.4},\n\t{\"Venus\", 0.815, 0.7},\n\t{\"Earth\", 1.0, 1.0},\n\t{\"Mars\", 0.107, 1.5},\n}\n\n// ExampleSortKeys demonstrates a technique for sorting a struct type using programmable sort criteria.\nfunc main() {\n\t// Closures that order the Planet structure.\n\tname := func(p1, p2 *Planet) bool {\n\t\treturn p1.name &lt; p2.name\n\t}\n\tmass := func(p1, p2 *Planet) bool {\n\t\treturn p1.mass &lt; p2.mass\n\t}\n\tdistance := func(p1, p2 *Planet) bool {\n\t\treturn p1.distance &lt; p2.distance\n\t}\n\tdecreasingDistance := func(p1, p2 *Planet) bool {\n\t\treturn !distance(p1, p2)\n\t}\n\n\t// Sort the planets by the various criteria.\n\tBy(name).Sort(planets)\n\tfmt.Println(\"By name:\", planets)\n\n\tBy(mass).Sort(planets)\n\tfmt.Println(\"By mass:\", planets)\n\n\tBy(distance).Sort(planets)\n\tfmt.Println(\"By distance:\", planets)\n\n\tBy(decreasingDistance).Sort(planets)\n\tfmt.Println(\"By decreasing distance:\", planets)\n\n}\n</pre> </div> </div> <div id=\"example__sortMultiKeys\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (SortMultiKeys)</h2> <p>ExampleMultiKeys demonstrates a technique for sorting a struct type using different sets of multiple fields in the comparison. We chain together \"Less\" functions, each of which compares a single field. </p> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// A Change is a record of source code changes, recording user, language, and delta size.\ntype Change struct {\n\tuser     string\n\tlanguage string\n\tlines    int\n}\n\ntype lessFunc func(p1, p2 *Change) bool\n\n// multiSorter implements the Sort interface, sorting the changes within.\ntype multiSorter struct {\n\tchanges []Change\n\tless    []lessFunc\n}\n\n// Sort sorts the argument slice according to the less functions passed to OrderedBy.\nfunc (ms *multiSorter) Sort(changes []Change) {\n\tms.changes = changes\n\tsort.Sort(ms)\n}\n\n// OrderedBy returns a Sorter that sorts using the less functions, in order.\n// Call its Sort method to sort the data.\nfunc OrderedBy(less ...lessFunc) *multiSorter {\n\treturn &amp;multiSorter{\n\t\tless: less,\n\t}\n}\n\n// Len is part of sort.Interface.\nfunc (ms *multiSorter) Len() int {\n\treturn len(ms.changes)\n}\n\n// Swap is part of sort.Interface.\nfunc (ms *multiSorter) Swap(i, j int) {\n\tms.changes[i], ms.changes[j] = ms.changes[j], ms.changes[i]\n}\n\n// Less is part of sort.Interface. It is implemented by looping along the\n// less functions until it finds a comparison that is either Less or\n// !Less. Note that it can call the less functions twice per call. We\n// could change the functions to return -1, 0, 1 and reduce the\n// number of calls for greater efficiency: an exercise for the reader.\nfunc (ms *multiSorter) Less(i, j int) bool {\n\tp, q := &amp;ms.changes[i], &amp;ms.changes[j]\n\t// Try all but the last comparison.\n\tvar k int\n\tfor k = 0; k &lt; len(ms.less)-1; k++ {\n\t\tless := ms.less[k]\n\t\tswitch {\n\t\tcase less(p, q):\n\t\t\t// p &lt; q, so we have a decision.\n\t\t\treturn true\n\t\tcase less(q, p):\n\t\t\t// p &gt; q, so we have a decision.\n\t\t\treturn false\n\t\t}\n\t\t// p == q; try the next comparison.\n\t}\n\t// All comparisons to here said \"equal\", so just return whatever\n\t// the final comparison reports.\n\treturn ms.less[k](p, q)\n}\n\nvar changes = []Change{\n\t{\"gri\", \"Go\", 100},\n\t{\"ken\", \"C\", 150},\n\t{\"glenda\", \"Go\", 200},\n\t{\"rsc\", \"Go\", 200},\n\t{\"r\", \"Go\", 100},\n\t{\"ken\", \"Go\", 200},\n\t{\"dmr\", \"C\", 100},\n\t{\"r\", \"C\", 150},\n\t{\"gri\", \"Smalltalk\", 80},\n}\n\n// ExampleMultiKeys demonstrates a technique for sorting a struct type using different\n// sets of multiple fields in the comparison. We chain together \"Less\" functions, each of\n// which compares a single field.\nfunc main() {\n\t// Closures that order the Change structure.\n\tuser := func(c1, c2 *Change) bool {\n\t\treturn c1.user &lt; c2.user\n\t}\n\tlanguage := func(c1, c2 *Change) bool {\n\t\treturn c1.language &lt; c2.language\n\t}\n\tincreasingLines := func(c1, c2 *Change) bool {\n\t\treturn c1.lines &lt; c2.lines\n\t}\n\tdecreasingLines := func(c1, c2 *Change) bool {\n\t\treturn c1.lines &gt; c2.lines // Note: &gt; orders downwards.\n\t}\n\n\t// Simple use: Sort by user.\n\tOrderedBy(user).Sort(changes)\n\tfmt.Println(\"By user:\", changes)\n\n\t// More examples.\n\tOrderedBy(user, increasingLines).Sort(changes)\n\tfmt.Println(\"By user,&lt;lines:\", changes)\n\n\tOrderedBy(user, decreasingLines).Sort(changes)\n\tfmt.Println(\"By user,&gt;lines:\", changes)\n\n\tOrderedBy(language, increasingLines).Sort(changes)\n\tfmt.Println(\"By language,&lt;lines:\", changes)\n\n\tOrderedBy(language, increasingLines, user).Sort(changes)\n\tfmt.Println(\"By language,&lt;lines,user:\", changes)\n\n}\n</pre> </div> </div> <div id=\"example__sortWrapper\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (SortWrapper)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype Grams int\n\nfunc (g Grams) String() string { return fmt.Sprintf(\"%dg\", int(g)) }\n\ntype Organ struct {\n\tName   string\n\tWeight Grams\n}\n\ntype Organs []*Organ\n\nfunc (s Organs) Len() int      { return len(s) }\nfunc (s Organs) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\n\n// ByName implements sort.Interface by providing Less and using the Len and\n// Swap methods of the embedded Organs value.\ntype ByName struct{ Organs }\n\nfunc (s ByName) Less(i, j int) bool { return s.Organs[i].Name &lt; s.Organs[j].Name }\n\n// ByWeight implements sort.Interface by providing Less and using the Len and\n// Swap methods of the embedded Organs value.\ntype ByWeight struct{ Organs }\n\nfunc (s ByWeight) Less(i, j int) bool { return s.Organs[i].Weight &lt; s.Organs[j].Weight }\n\nfunc main() {\n\ts := []*Organ{\n\t\t{\"brain\", 1340},\n\t\t{\"heart\", 290},\n\t\t{\"liver\", 1494},\n\t\t{\"pancreas\", 131},\n\t\t{\"prostate\", 62},\n\t\t{\"spleen\", 162},\n\t}\n\n\tsort.Sort(ByWeight{s})\n\tfmt.Println(\"Organs by weight:\")\n\tprintOrgans(s)\n\n\tsort.Sort(ByName{s})\n\tfmt.Println(\"Organs by name:\")\n\tprintOrgans(s)\n\n}\n\nfunc printOrgans(s []*Organ) {\n\tfor _, o := range s {\n\t\tfmt.Printf(\"%-8s (%v)\\n\", o.Name, o.Weight)\n\t}\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Float64s\">func Float64s(a []float64)</a></li>\n<li><a href=\"#Float64sAreSorted\">func Float64sAreSorted(a []float64) bool</a></li>\n<li><a href=\"#Ints\">func Ints(a []int)</a></li>\n<li><a href=\"#IntsAreSorted\">func IntsAreSorted(a []int) bool</a></li>\n<li><a href=\"#IsSorted\">func IsSorted(data Interface) bool</a></li>\n<li><a href=\"#Search\">func Search(n int, f func(int) bool) int</a></li>\n<li><a href=\"#SearchFloat64s\">func SearchFloat64s(a []float64, x float64) int</a></li>\n<li><a href=\"#SearchInts\">func SearchInts(a []int, x int) int</a></li>\n<li><a href=\"#SearchStrings\">func SearchStrings(a []string, x string) int</a></li>\n<li><a href=\"#Sort\">func Sort(data Interface)</a></li>\n<li><a href=\"#Stable\">func Stable(data Interface)</a></li>\n<li><a href=\"#Strings\">func Strings(a []string)</a></li>\n<li><a href=\"#StringsAreSorted\">func StringsAreSorted(a []string) bool</a></li>\n<li><a href=\"#Float64Slice\">type Float64Slice</a></li>\n<li> <a href=\"#Float64Slice.Len\">func (p Float64Slice) Len() int</a>\n</li>\n<li> <a href=\"#Float64Slice.Less\">func (p Float64Slice) Less(i, j int) bool</a>\n</li>\n<li> <a href=\"#Float64Slice.Search\">func (p Float64Slice) Search(x float64) int</a>\n</li>\n<li> <a href=\"#Float64Slice.Sort\">func (p Float64Slice) Sort()</a>\n</li>\n<li> <a href=\"#Float64Slice.Swap\">func (p Float64Slice) Swap(i, j int)</a>\n</li>\n<li><a href=\"#IntSlice\">type IntSlice</a></li>\n<li> <a href=\"#IntSlice.Len\">func (p IntSlice) Len() int</a>\n</li>\n<li> <a href=\"#IntSlice.Less\">func (p IntSlice) Less(i, j int) bool</a>\n</li>\n<li> <a href=\"#IntSlice.Search\">func (p IntSlice) Search(x int) int</a>\n</li>\n<li> <a href=\"#IntSlice.Sort\">func (p IntSlice) Sort()</a>\n</li>\n<li> <a href=\"#IntSlice.Swap\">func (p IntSlice) Swap(i, j int)</a>\n</li>\n<li><a href=\"#Interface\">type Interface</a></li>\n<li> <a href=\"#Reverse\">func Reverse(data Interface) Interface</a>\n</li>\n<li><a href=\"#StringSlice\">type StringSlice</a></li>\n<li> <a href=\"#StringSlice.Len\">func (p StringSlice) Len() int</a>\n</li>\n<li> <a href=\"#StringSlice.Less\">func (p StringSlice) Less(i, j int) bool</a>\n</li>\n<li> <a href=\"#StringSlice.Search\">func (p StringSlice) Search(x string) int</a>\n</li>\n<li> <a href=\"#StringSlice.Sort\">func (p StringSlice) Sort()</a>\n</li>\n<li> <a href=\"#StringSlice.Swap\">func (p StringSlice) Swap(i, j int)</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_\">Package</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Ints\">Ints</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Reverse\">Reverse</a></dd> <dd><a class=\"exampleLink\" href=\"#example__sortKeys\">Package (SortKeys)</a></dd> <dd><a class=\"exampleLink\" href=\"#example__sortMultiKeys\">Package (SortMultiKeys)</a></dd> <dd><a class=\"exampleLink\" href=\"#example__sortWrapper\">Package (SortWrapper)</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/sort/search.go\">search.go</a> <a href=\"https://golang.org/src/sort/sort.go\">sort.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Float64s\">func Float64s  </h2> <pre data-language=\"go\">func Float64s(a []float64)</pre> <p> Float64s sorts a slice of float64s in increasing order. </p> <h2 id=\"Float64sAreSorted\">func Float64sAreSorted  </h2> <pre data-language=\"go\">func Float64sAreSorted(a []float64) bool</pre> <p> Float64sAreSorted tests whether a slice of float64s is sorted in increasing order. </p> <h2 id=\"Ints\">func Ints  </h2> <pre data-language=\"go\">func Ints(a []int)</pre> <p> Ints sorts a slice of ints in increasing order. </p> <div id=\"example_Ints\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc main() {\n\ts := []int{5, 2, 6, 3, 1, 4} // unsorted\n\tsort.Ints(s)\n\tfmt.Println(s)\n}\n</pre> </div> </div> <h2 id=\"IntsAreSorted\">func IntsAreSorted  </h2> <pre data-language=\"go\">func IntsAreSorted(a []int) bool</pre> <p> IntsAreSorted tests whether a slice of ints is sorted in increasing order. </p> <h2 id=\"IsSorted\">func IsSorted  </h2> <pre data-language=\"go\">func IsSorted(data Interface) bool</pre> <p> IsSorted reports whether data is sorted. </p> <h2 id=\"Search\">func Search  </h2> <pre data-language=\"go\">func Search(n int, f func(int) bool) int</pre> <p> Search uses binary search to find and return the smallest index i in [0, n) at which f(i) is true, assuming that on the range [0, n), f(i) == true implies f(i+1) == true. That is, Search requires that f is false for some (possibly empty) prefix of the input range [0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the \"not found\" return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range [0, n). </p> <p> A common use of Search is to find the index i for a value x in a sorted, indexable data structure such as an array or slice. In this case, the argument f, typically a closure, captures the value to be searched for, and how the data structure is indexed and ordered. </p> <p> For instance, given a slice data sorted in ascending order, the call Search(len(data), func(i int) bool { return data[i] &gt;= 23 }) returns the smallest index i such that data[i] &gt;= 23. If the caller wants to find whether 23 is in the slice, it must test data[i] == 23 separately. </p> <p> Searching data sorted in descending order would use the &lt;= operator instead of the &gt;= operator. </p> <p> To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order: </p> <pre data-language=\"go\">x := 23\ni := sort.Search(len(data), func(i int) bool { return data[i] &gt;= x })\nif i &lt; len(data) &amp;&amp; data[i] == x {\n\t// x is present at data[i]\n} else {\n\t// x is not present in data,\n\t// but i is the index where it would be inserted.\n}\n</pre> <p> As a more whimsical example, this program guesses your number: </p> <pre data-language=\"go\">func GuessingGame() {\n\tvar s string\n\tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n\tanswer := sort.Search(100, func(i int) bool {\n\t\tfmt.Printf(\"Is your number &lt;= %d? \", i)\n\t\tfmt.Scanf(\"%s\", &amp;s)\n\t\treturn s != \"\" &amp;&amp; s[0] == 'y'\n\t})\n\tfmt.Printf(\"Your number is %d.\\n\", answer)\n}\n</pre> <h2 id=\"SearchFloat64s\">func SearchFloat64s  </h2> <pre data-language=\"go\">func SearchFloat64s(a []float64, x float64) int</pre> <p> SearchFloat64s searches for x in a sorted slice of float64s and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order. </p> <h2 id=\"SearchInts\">func SearchInts  </h2> <pre data-language=\"go\">func SearchInts(a []int, x int) int</pre> <p> SearchInts searches for x in a sorted slice of ints and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order. </p> <h2 id=\"SearchStrings\">func SearchStrings  </h2> <pre data-language=\"go\">func SearchStrings(a []string, x string) int</pre> <p> SearchStrings searches for x in a sorted slice of strings and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order. </p> <h2 id=\"Sort\">func Sort  </h2> <pre data-language=\"go\">func Sort(data Interface)</pre> <p> Sort sorts data. It makes one call to data.Len to determine n, and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable. </p> <h2 id=\"Stable\">func Stable  </h2> <pre data-language=\"go\">func Stable(data Interface)</pre> <p> Stable sorts data while keeping the original order of equal elements. </p> <p> It makes one call to data.Len to determine n, O(n*log(n)) calls to data.Less and O(n*log(n)*log(n)) calls to data.Swap. </p> <h2 id=\"Strings\">func Strings  </h2> <pre data-language=\"go\">func Strings(a []string)</pre> <p> Strings sorts a slice of strings in increasing order. </p> <h2 id=\"StringsAreSorted\">func StringsAreSorted  </h2> <pre data-language=\"go\">func StringsAreSorted(a []string) bool</pre> <p> StringsAreSorted tests whether a slice of strings is sorted in increasing order. </p> <h2 id=\"Float64Slice\">type Float64Slice  </h2> <pre data-language=\"go\">type Float64Slice []float64</pre> <p> Float64Slice attaches the methods of Interface to []float64, sorting in increasing order. </p> <h3 id=\"Float64Slice.Len\">func (Float64Slice) <a href=\"https://golang.org/src/sort/sort.go?s=6709:6740#L257\">Len</a>  </h3> <pre data-language=\"go\">func (p Float64Slice) Len() int</pre> <h3 id=\"Float64Slice.Less\">func (Float64Slice) <a href=\"https://golang.org/src/sort/sort.go?s=6769:6810#L258\">Less</a>  </h3> <pre data-language=\"go\">func (p Float64Slice) Less(i, j int) bool</pre> <h3 id=\"Float64Slice.Search\">func (Float64Slice) <a href=\"https://golang.org/src/sort/search.go?s=4004:4047#L99\">Search</a>  </h3> <pre data-language=\"go\">func (p Float64Slice) Search(x float64) int</pre> <p> Search returns the result of applying SearchFloat64s to the receiver and x. </p> <h3 id=\"Float64Slice.Sort\">func (Float64Slice) <a href=\"https://golang.org/src/sort/sort.go?s=7092:7120#L267\">Sort</a>  </h3> <pre data-language=\"go\">func (p Float64Slice) Sort()</pre> <p> Sort is a convenience method. </p> <h3 id=\"Float64Slice.Swap\">func (Float64Slice) <a href=\"https://golang.org/src/sort/sort.go?s=6865:6901#L259\">Swap</a>  </h3> <pre data-language=\"go\">func (p Float64Slice) Swap(i, j int)</pre> <h2 id=\"IntSlice\">type IntSlice  </h2> <pre data-language=\"go\">type IntSlice []int</pre> <p> IntSlice attaches the methods of Interface to []int, sorting in increasing order. </p> <h3 id=\"IntSlice.Len\">func (IntSlice) <a href=\"https://golang.org/src/sort/sort.go?s=6332:6359#L247\">Len</a>  </h3> <pre data-language=\"go\">func (p IntSlice) Len() int</pre> <h3 id=\"IntSlice.Less\">func (IntSlice) <a href=\"https://golang.org/src/sort/sort.go?s=6388:6425#L248\">Less</a>  </h3> <pre data-language=\"go\">func (p IntSlice) Less(i, j int) bool</pre> <h3 id=\"IntSlice.Search\">func (IntSlice) <a href=\"https://golang.org/src/sort/search.go?s=3860:3895#L96\">Search</a>  </h3> <pre data-language=\"go\">func (p IntSlice) Search(x int) int</pre> <p> Search returns the result of applying SearchInts to the receiver and x. </p> <h3 id=\"IntSlice.Sort\">func (IntSlice) <a href=\"https://golang.org/src/sort/sort.go?s=6549:6573#L252\">Sort</a>  </h3> <pre data-language=\"go\">func (p IntSlice) Sort()</pre> <p> Sort is a convenience method. </p> <h3 id=\"IntSlice.Swap\">func (IntSlice) <a href=\"https://golang.org/src/sort/sort.go?s=6449:6481#L249\">Swap</a>  </h3> <pre data-language=\"go\">func (p IntSlice) Swap(i, j int)</pre> <h2 id=\"Interface\">type Interface  </h2> <pre data-language=\"go\">type Interface interface {\n        // Len is the number of elements in the collection.\n        Len() int\n        // Less reports whether the element with\n        // index i should sort before the element with index j.\n        Less(i, j int) bool\n        // Swap swaps the elements with indexes i and j.\n        Swap(i, j int)\n}</pre> <p> A type, typically a collection, that satisfies sort.Interface can be sorted by the routines in this package. The methods require that the elements of the collection be enumerated by an integer index. </p> <h3 id=\"Reverse\">func <a href=\"https://golang.org/src/sort/sort.go?s=5928:5966#L227\">Reverse</a>  </h3> <pre data-language=\"go\">func Reverse(data Interface) Interface</pre> <p> Reverse returns the reverse order for data. </p> <div id=\"example_Reverse\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc main() {\n\ts := []int{5, 2, 6, 3, 1, 4} // unsorted\n\tsort.Sort(sort.Reverse(sort.IntSlice(s)))\n\tfmt.Println(s)\n}\n</pre> </div> </div> <h2 id=\"StringSlice\">type StringSlice  </h2> <pre data-language=\"go\">type StringSlice []string</pre> <p> StringSlice attaches the methods of Interface to []string, sorting in increasing order. </p> <h3 id=\"StringSlice.Len\">func (StringSlice) <a href=\"https://golang.org/src/sort/sort.go?s=7252:7282#L272\">Len</a>  </h3> <pre data-language=\"go\">func (p StringSlice) Len() int</pre> <h3 id=\"StringSlice.Less\">func (StringSlice) <a href=\"https://golang.org/src/sort/sort.go?s=7311:7351#L273\">Less</a>  </h3> <pre data-language=\"go\">func (p StringSlice) Less(i, j int) bool</pre> <h3 id=\"StringSlice.Search\">func (StringSlice) <a href=\"https://golang.org/src/sort/search.go?s=4159:4200#L102\">Search</a>  </h3> <pre data-language=\"go\">func (p StringSlice) Search(x string) int</pre> <p> Search returns the result of applying SearchStrings to the receiver and x. </p> <h3 id=\"StringSlice.Sort\">func (StringSlice) <a href=\"https://golang.org/src/sort/sort.go?s=7478:7505#L277\">Sort</a>  </h3> <pre data-language=\"go\">func (p StringSlice) Sort()</pre> <p> Sort is a convenience method. </p> <h3 id=\"StringSlice.Swap\">func (StringSlice) <a href=\"https://golang.org/src/sort/sort.go?s=7375:7410#L274\">Swap</a>  </h3> <pre data-language=\"go\">func (p StringSlice) Swap(i, j int)</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/sort/\" class=\"_attribution-link\">https://golang.org/pkg/sort/</a>\n  </p>\n</div>\n","sync/index":"<h1>Package sync</h1>     <ul id=\"short-nav\">\n<li><code>import \"sync\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the Once and WaitGroup types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication. </p> <p> Values containing the types defined in this package should not be copied. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Cond\">type Cond</a></li>\n<li> <a href=\"#NewCond\">func NewCond(l Locker) *Cond</a>\n</li>\n<li> <a href=\"#Cond.Broadcast\">func (c *Cond) Broadcast()</a>\n</li>\n<li> <a href=\"#Cond.Signal\">func (c *Cond) Signal()</a>\n</li>\n<li> <a href=\"#Cond.Wait\">func (c *Cond) Wait()</a>\n</li>\n<li><a href=\"#Locker\">type Locker</a></li>\n<li><a href=\"#Mutex\">type Mutex</a></li>\n<li> <a href=\"#Mutex.Lock\">func (m *Mutex) Lock()</a>\n</li>\n<li> <a href=\"#Mutex.Unlock\">func (m *Mutex) Unlock()</a>\n</li>\n<li><a href=\"#Once\">type Once</a></li>\n<li> <a href=\"#Once.Do\">func (o *Once) Do(f func())</a>\n</li>\n<li><a href=\"#Pool\">type Pool</a></li>\n<li> <a href=\"#Pool.Get\">func (p *Pool) Get() interface{}</a>\n</li>\n<li> <a href=\"#Pool.Put\">func (p *Pool) Put(x interface{})</a>\n</li>\n<li><a href=\"#RWMutex\">type RWMutex</a></li>\n<li> <a href=\"#RWMutex.Lock\">func (rw *RWMutex) Lock()</a>\n</li>\n<li> <a href=\"#RWMutex.RLock\">func (rw *RWMutex) RLock()</a>\n</li>\n<li> <a href=\"#RWMutex.RLocker\">func (rw *RWMutex) RLocker() Locker</a>\n</li>\n<li> <a href=\"#RWMutex.RUnlock\">func (rw *RWMutex) RUnlock()</a>\n</li>\n<li> <a href=\"#RWMutex.Unlock\">func (rw *RWMutex) Unlock()</a>\n</li>\n<li><a href=\"#WaitGroup\">type WaitGroup</a></li>\n<li> <a href=\"#WaitGroup.Add\">func (wg *WaitGroup) Add(delta int)</a>\n</li>\n<li> <a href=\"#WaitGroup.Done\">func (wg *WaitGroup) Done()</a>\n</li>\n<li> <a href=\"#WaitGroup.Wait\">func (wg *WaitGroup) Wait()</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Once\">Once</a></dd> <dd><a class=\"exampleLink\" href=\"#example_WaitGroup\">WaitGroup</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/sync/cond.go\">cond.go</a> <a href=\"https://golang.org/src/sync/mutex.go\">mutex.go</a> <a href=\"https://golang.org/src/sync/once.go\">once.go</a> <a href=\"https://golang.org/src/sync/pool.go\">pool.go</a> <a href=\"https://golang.org/src/sync/runtime.go\">runtime.go</a> <a href=\"https://golang.org/src/sync/rwmutex.go\">rwmutex.go</a> <a href=\"https://golang.org/src/sync/waitgroup.go\">waitgroup.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Cond\">type Cond  </h2> <pre data-language=\"go\">type Cond struct {\n\n        // L is held while observing or changing the condition\n        L Locker\n        // contains filtered or unexported fields\n}</pre> <p> Cond implements a condition variable, a rendezvous point for goroutines waiting for or announcing the occurrence of an event. </p> <p> Each Cond has an associated Locker L (often a *Mutex or *RWMutex), which must be held when changing the condition and when calling the Wait method. </p> <p> A Cond can be created as part of other structures. A Cond must not be copied after first use. </p> <h3 id=\"NewCond\">func <a href=\"https://golang.org/src/sync/cond.go?s=800:828#L23\">NewCond</a>  </h3> <pre data-language=\"go\">func NewCond(l Locker) *Cond</pre> <p> NewCond returns a new Cond with Locker l. </p> <h3 id=\"Cond.Broadcast\">func (*Cond) <a href=\"https://golang.org/src/sync/cond.go?s=1921:1947#L64\">Broadcast</a>  </h3> <pre data-language=\"go\">func (c *Cond) Broadcast()</pre> <p> Broadcast wakes all goroutines waiting on c. </p> <p> It is allowed but not required for the caller to hold c.L during the call. </p> <h3 id=\"Cond.Signal\">func (*Cond) <a href=\"https://golang.org/src/sync/cond.go?s=1701:1724#L55\">Signal</a>  </h3> <pre data-language=\"go\">func (c *Cond) Signal()</pre> <p> Signal wakes one goroutine waiting on c, if there is any. </p> <p> It is allowed but not required for the caller to hold c.L during the call. </p> <h3 id=\"Cond.Wait\">func (*Cond) <a href=\"https://golang.org/src/sync/cond.go?s=1407:1428#L43\">Wait</a>  </h3> <pre data-language=\"go\">func (c *Cond) Wait()</pre> <p> Wait atomically unlocks c.L and suspends execution of the calling goroutine. After later resuming execution, Wait locks c.L before returning. Unlike in other systems, Wait cannot return unless awoken by Broadcast or Signal. </p> <p> Because c.L is not locked when Wait first resumes, the caller typically cannot assume that the condition is true when Wait returns. Instead, the caller should Wait in a loop: </p> <pre data-language=\"go\">c.L.Lock()\nfor !condition() {\n    c.Wait()\n}\n... make use of condition ...\nc.L.Unlock()\n</pre> <h2 id=\"Locker\">type Locker  </h2> <pre data-language=\"go\">type Locker interface {\n        Lock()\n        Unlock()\n}</pre> <p> A Locker represents an object that can be locked and unlocked. </p> <h2 id=\"Mutex\">type Mutex  </h2> <pre data-language=\"go\">type Mutex struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Mutex is a mutual exclusion lock. Mutexes can be created as part of other structures; the zero value for a Mutex is an unlocked mutex. </p> <p> A Mutex must not be copied after first use. </p> <h3 id=\"Mutex.Lock\">func (*Mutex) <a href=\"https://golang.org/src/sync/mutex.go?s=1143:1165#L34\">Lock</a>  </h3> <pre data-language=\"go\">func (m *Mutex) Lock()</pre> <p> Lock locks m. If the lock is already in use, the calling goroutine blocks until the mutex is available. </p> <h3 id=\"Mutex.Unlock\">func (*Mutex) <a href=\"https://golang.org/src/sync/mutex.go?s=2550:2574#L92\">Unlock</a>  </h3> <pre data-language=\"go\">func (m *Mutex) Unlock()</pre> <p> Unlock unlocks m. It is a run-time error if m is not locked on entry to Unlock. </p> <p> A locked Mutex is not associated with a particular goroutine. It is allowed for one goroutine to lock a Mutex and then arrange for another goroutine to unlock it. </p> <h2 id=\"Once\">type Once  </h2> <pre data-language=\"go\">type Once struct {\n        // contains filtered or unexported fields\n}</pre> <p> Once is an object that will perform exactly one action. </p> <div id=\"example_Once\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar once sync.Once\n\tonceBody := func() {\n\t\tfmt.Println(\"Only once\")\n\t}\n\tdone := make(chan bool)\n\tfor i := 0; i &lt; 10; i++ {\n\t\tgo func() {\n\t\t\tonce.Do(onceBody)\n\t\t\tdone &lt;- true\n\t\t}()\n\t}\n\tfor i := 0; i &lt; 10; i++ {\n\t\t&lt;-done\n\t}\n}\n</pre> </div> </div> <h3 id=\"Once.Do\">func (*Once) <a href=\"https://golang.org/src/sync/once.go?s=1137:1164#L25\">Do</a>  </h3> <pre data-language=\"go\">func (o *Once) Do(f func())</pre> <p> Do calls the function f if and only if Do is being called for the first time for this instance of Once. In other words, given </p> <pre data-language=\"go\">var once Once\n</pre> <p> if once.Do(f) is called multiple times, only the first call will invoke f, even if f has a different value in each invocation. A new instance of Once is required for each function to execute. </p> <p> Do is intended for initialization that must be run exactly once. Since f is niladic, it may be necessary to use a function literal to capture the arguments to a function to be invoked by Do: </p> <pre data-language=\"go\">config.once.Do(func() { config.init(filename) })\n</pre> <p> Because no call to Do returns until the one call to f returns, if f causes Do to be called, it will deadlock. </p> <p> If f panics, Do considers it to have returned; future calls of Do return without calling f. </p> <h2 id=\"Pool\">type Pool  </h2> <pre data-language=\"go\">type Pool struct {\n\n        // New optionally specifies a function to generate\n        // a value when Get would otherwise return nil.\n        // It may not be changed concurrently with calls to Get.\n        New func() interface{}\n        // contains filtered or unexported fields\n}</pre> <p> A Pool is a set of temporary objects that may be individually saved and retrieved. </p> <p> Any item stored in the Pool may be removed automatically at any time without notification. If the Pool holds the only reference when this happens, the item might be deallocated. </p> <p> A Pool is safe for use by multiple goroutines simultaneously. </p> <p> Pool's purpose is to cache allocated but unused items for later reuse, relieving pressure on the garbage collector. That is, it makes it easy to build efficient, thread-safe free lists. However, it is not suitable for all free lists. </p> <p> An appropriate use of a Pool is to manage a group of temporary items silently shared among and potentially reused by concurrent independent clients of a package. Pool provides a way to amortize allocation overhead across many clients. </p> <p> An example of good use of a Pool is in the fmt package, which maintains a dynamically-sized store of temporary output buffers. The store scales under load (when many goroutines are actively printing) and shrinks when quiescent. </p> <p> On the other hand, a free list maintained as part of a short-lived object is not a suitable use for a Pool, since the overhead does not amortize well in that scenario. It is more efficient to have such objects implement their own free list. </p> <p> A Pool must not be copied after first use. </p> <h3 id=\"Pool.Get\">func (*Pool) <a href=\"https://golang.org/src/sync/pool.go?s=3103:3135#L87\">Get</a>  </h3> <pre data-language=\"go\">func (p *Pool) Get() interface{}</pre> <p> Get selects an arbitrary item from the Pool, removes it from the Pool, and returns it to the caller. Get may choose to ignore the pool and treat it as empty. Callers should not assume any relation between values passed to Put and the values returned by Get. </p> <p> If Get would otherwise return nil and p.New is non-nil, Get returns the result of calling p.New. </p> <h3 id=\"Pool.Put\">func (*Pool) <a href=\"https://golang.org/src/sync/pool.go?s=2283:2316#L55\">Put</a>  </h3> <pre data-language=\"go\">func (p *Pool) Put(x interface{})</pre> <p> Put adds x to the pool. </p> <h2 id=\"RWMutex\">type RWMutex  </h2> <pre data-language=\"go\">type RWMutex struct {\n        // contains filtered or unexported fields\n}</pre> <p> An RWMutex is a reader/writer mutual exclusion lock. The lock can be held by an arbitrary number of readers or a single writer. RWMutexes can be created as part of other structures; the zero value for a RWMutex is an unlocked mutex. </p> <p> An RWMutex must not be copied after first use. </p> <p> If a goroutine holds a RWMutex for reading, it must not expect this or any other goroutine to be able to also take the read lock until the first read lock is released. In particular, this prohibits recursive read locking. This is to ensure that the lock eventually becomes available; a blocked Lock call excludes new readers from acquiring the lock. </p> <h3 id=\"RWMutex.Lock\">func (*RWMutex) <a href=\"https://golang.org/src/sync/rwmutex.go?s=2399:2424#L70\">Lock</a>  </h3> <pre data-language=\"go\">func (rw *RWMutex) Lock()</pre> <p> Lock locks rw for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available. </p> <h3 id=\"RWMutex.RLock\">func (*RWMutex) <a href=\"https://golang.org/src/sync/rwmutex.go?s=1294:1320#L26\">RLock</a>  </h3> <pre data-language=\"go\">func (rw *RWMutex) RLock()</pre> <p> RLock locks rw for reading. </p> <h3 id=\"RWMutex.RLocker\">func (*RWMutex) <a href=\"https://golang.org/src/sync/rwmutex.go?s=3944:3979#L123\">RLocker</a>  </h3> <pre data-language=\"go\">func (rw *RWMutex) RLocker() Locker</pre> <p> RLocker returns a Locker interface that implements the Lock and Unlock methods by calling rw.RLock and rw.RUnlock. </p> <h3 id=\"RWMutex.RUnlock\">func (*RWMutex) <a href=\"https://golang.org/src/sync/rwmutex.go?s=1761:1789#L45\">RUnlock</a>  </h3> <pre data-language=\"go\">func (rw *RWMutex) RUnlock()</pre> <p> RUnlock undoes a single RLock call; it does not affect other simultaneous readers. It is a run-time error if rw is not locked for reading on entry to RUnlock. </p> <h3 id=\"RWMutex.Unlock\">func (*RWMutex) <a href=\"https://golang.org/src/sync/rwmutex.go?s=3244:3271#L96\">Unlock</a>  </h3> <pre data-language=\"go\">func (rw *RWMutex) Unlock()</pre> <p> Unlock unlocks rw for writing. It is a run-time error if rw is not locked for writing on entry to Unlock. </p> <p> As with Mutexes, a locked RWMutex is not associated with a particular goroutine. One goroutine may RLock (Lock) an RWMutex and then arrange for another goroutine to RUnlock (Unlock) it. </p> <h2 id=\"WaitGroup\">type WaitGroup  </h2> <pre data-language=\"go\">type WaitGroup struct {\n        // contains filtered or unexported fields\n}</pre> <p> A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished. </p> <p> A WaitGroup must not be copied after first use. </p> <div id=\"example_WaitGroup\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>This example fetches several URLs concurrently, using a WaitGroup to block until all the fetches are complete. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    var wg sync.WaitGroup\n    var urls = []string{\n            \"http://www.golang.org/\",\n            \"http://www.google.com/\",\n            \"http://www.somestupidname.com/\",\n    }\n    for _, url := range urls {\n            // Increment the WaitGroup counter.\n            wg.Add(1)\n            // Launch a goroutine to fetch the URL.\n            go func(url string) {\n                    // Decrement the counter when the goroutine completes.\n                    defer wg.Done()\n                    // Fetch the URL.\n                    http.Get(url)\n            }(url)\n    }\n    // Wait for all HTTP fetches to complete.\n    wg.Wait()\n</pre> </div> </div> <h3 id=\"WaitGroup.Add\">func (*WaitGroup) <a href=\"https://golang.org/src/sync/waitgroup.go?s=1857:1892#L42\">Add</a>  </h3> <pre data-language=\"go\">func (wg *WaitGroup) Add(delta int)</pre> <p> Add adds delta, which may be negative, to the WaitGroup counter. If the counter becomes zero, all goroutines blocked on Wait are released. If the counter goes negative, Add panics. </p> <p> Note that calls with a positive delta that occur when the counter is zero must happen before a Wait. Calls with a negative delta, or calls with a positive delta that start when the counter is greater than zero, may happen at any time. Typically this means the calls to Add should execute before the statement creating the goroutine or other event to be waited for. If a WaitGroup is reused to wait for several independent sets of events, new Add calls must happen after all previous Wait calls have returned. See the WaitGroup example. </p> <h3 id=\"WaitGroup.Done\">func (*WaitGroup) <a href=\"https://golang.org/src/sync/waitgroup.go?s=3232:3259#L89\">Done</a>  </h3> <pre data-language=\"go\">func (wg *WaitGroup) Done()</pre> <p> Done decrements the WaitGroup counter. </p> <h3 id=\"WaitGroup.Wait\">func (*WaitGroup) <a href=\"https://golang.org/src/sync/waitgroup.go?s=3329:3356#L94\">Wait</a>  </h3> <pre data-language=\"go\">func (wg *WaitGroup) Wait()</pre> <p> Wait blocks until the WaitGroup counter is zero. </p> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"atomic/index\">atomic</a> </td> <td class=\"pkg-synopsis\"> Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/sync/\" class=\"_attribution-link\">https://golang.org/pkg/sync/</a>\n  </p>\n</div>\n","regexp/index":"<h1>Package regexp</h1>     <ul id=\"short-nav\">\n<li><code>import \"regexp\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package regexp implements regular expression search. </p> <p> The syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at <a href=\"https://golang.org/s/re2syntax\">https://golang.org/s/re2syntax</a>, except for \\C. For an overview of the syntax, run </p> <pre data-language=\"go\">go doc regexp/syntax\n</pre> <p> The regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see </p> <pre data-language=\"go\">http://swtch.com/~rsc/regexp/regexp1.html\n</pre> <p> or any book about automata theory. </p> <p> All characters are UTF-8-encoded code points. </p> <p> There are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression: </p> <pre data-language=\"go\">Find(All)?(String)?(Submatch)?(Index)?\n</pre> <p> If 'All' is present, the routine matches successive non-overlapping matches of the entire expression. Empty matches abutting a preceding match are ignored. The return value is a slice containing the successive return values of the corresponding non-'All' routine. These routines take an extra integer argument, n; if n &gt;= 0, the function returns at most n matches/submatches. </p> <p> If 'String' is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate. </p> <p> If 'Submatch' is present, the return value is a slice identifying the successive submatches of the expression. Submatches are matches of parenthesized subexpressions (also known as capturing groups) within the regular expression, numbered from left to right in order of opening parenthesis. Submatch 0 is the match of the entire expression, submatch 1 the match of the first parenthesized subexpression, and so on. </p> <p> If 'Index' is present, matches and submatches are identified by byte index pairs within the input string: result[2*n:2*n+1] identifies the indexes of the nth submatch. The pair for n==0 identifies the match of the entire expression. If 'Index' is not present, the match is identified by the text of the match/submatch. If an index is negative, it means that subexpression did not match any string in the input. </p> <p> There is also a subset of the methods that can be applied to text read from a RuneReader: </p> <pre data-language=\"go\">MatchReader, FindReaderIndex, FindReaderSubmatchIndex\n</pre> <p> This set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from a RuneReader may read arbitrarily far into the input before returning. </p> <p> (There are a few other methods that do not match this pattern.) </p> </div> </div> <div id=\"example_\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\t// Compile the expression once, usually at init time.\n\t// Use raw strings to avoid having to quote the backslashes.\n\tvar validID = regexp.MustCompile(`^[a-z]+\\[[0-9]+\\]$`)\n\n\tfmt.Println(validID.MatchString(\"adam[23]\"))\n\tfmt.Println(validID.MatchString(\"eve[7]\"))\n\tfmt.Println(validID.MatchString(\"Job[48]\"))\n\tfmt.Println(validID.MatchString(\"snakey\"))\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Match\">func Match(pattern string, b []byte) (matched bool, err error)</a></li>\n<li><a href=\"#MatchReader\">func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)</a></li>\n<li><a href=\"#MatchString\">func MatchString(pattern string, s string) (matched bool, err error)</a></li>\n<li><a href=\"#QuoteMeta\">func QuoteMeta(s string) string</a></li>\n<li><a href=\"#Regexp\">type Regexp</a></li>\n<li> <a href=\"#Compile\">func Compile(expr string) (*Regexp, error)</a>\n</li>\n<li> <a href=\"#CompilePOSIX\">func CompilePOSIX(expr string) (*Regexp, error)</a>\n</li>\n<li> <a href=\"#MustCompile\">func MustCompile(str string) *Regexp</a>\n</li>\n<li> <a href=\"#MustCompilePOSIX\">func MustCompilePOSIX(str string) *Regexp</a>\n</li>\n<li> <a href=\"#Regexp.Copy\">func (re *Regexp) Copy() *Regexp</a>\n</li>\n<li> <a href=\"#Regexp.Expand\">func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte</a>\n</li>\n<li> <a href=\"#Regexp.ExpandString\">func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte</a>\n</li>\n<li> <a href=\"#Regexp.Find\">func (re *Regexp) Find(b []byte) []byte</a>\n</li>\n<li> <a href=\"#Regexp.FindAll\">func (re *Regexp) FindAll(b []byte, n int) [][]byte</a>\n</li>\n<li> <a href=\"#Regexp.FindAllIndex\">func (re *Regexp) FindAllIndex(b []byte, n int) [][]int</a>\n</li>\n<li> <a href=\"#Regexp.FindAllString\">func (re *Regexp) FindAllString(s string, n int) []string</a>\n</li>\n<li> <a href=\"#Regexp.FindAllStringIndex\">func (re *Regexp) FindAllStringIndex(s string, n int) [][]int</a>\n</li>\n<li> <a href=\"#Regexp.FindAllStringSubmatch\">func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string</a>\n</li>\n<li> <a href=\"#Regexp.FindAllStringSubmatchIndex\">func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int</a>\n</li>\n<li> <a href=\"#Regexp.FindAllSubmatch\">func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte</a>\n</li>\n<li> <a href=\"#Regexp.FindAllSubmatchIndex\">func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int</a>\n</li>\n<li> <a href=\"#Regexp.FindIndex\">func (re *Regexp) FindIndex(b []byte) (loc []int)</a>\n</li>\n<li> <a href=\"#Regexp.FindReaderIndex\">func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)</a>\n</li>\n<li> <a href=\"#Regexp.FindReaderSubmatchIndex\">func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int</a>\n</li>\n<li> <a href=\"#Regexp.FindString\">func (re *Regexp) FindString(s string) string</a>\n</li>\n<li> <a href=\"#Regexp.FindStringIndex\">func (re *Regexp) FindStringIndex(s string) (loc []int)</a>\n</li>\n<li> <a href=\"#Regexp.FindStringSubmatch\">func (re *Regexp) FindStringSubmatch(s string) []string</a>\n</li>\n<li> <a href=\"#Regexp.FindStringSubmatchIndex\">func (re *Regexp) FindStringSubmatchIndex(s string) []int</a>\n</li>\n<li> <a href=\"#Regexp.FindSubmatch\">func (re *Regexp) FindSubmatch(b []byte) [][]byte</a>\n</li>\n<li> <a href=\"#Regexp.FindSubmatchIndex\">func (re *Regexp) FindSubmatchIndex(b []byte) []int</a>\n</li>\n<li> <a href=\"#Regexp.LiteralPrefix\">func (re *Regexp) LiteralPrefix() (prefix string, complete bool)</a>\n</li>\n<li> <a href=\"#Regexp.Longest\">func (re *Regexp) Longest()</a>\n</li>\n<li> <a href=\"#Regexp.Match\">func (re *Regexp) Match(b []byte) bool</a>\n</li>\n<li> <a href=\"#Regexp.MatchReader\">func (re *Regexp) MatchReader(r io.RuneReader) bool</a>\n</li>\n<li> <a href=\"#Regexp.MatchString\">func (re *Regexp) MatchString(s string) bool</a>\n</li>\n<li> <a href=\"#Regexp.NumSubexp\">func (re *Regexp) NumSubexp() int</a>\n</li>\n<li> <a href=\"#Regexp.ReplaceAll\">func (re *Regexp) ReplaceAll(src, repl []byte) []byte</a>\n</li>\n<li> <a href=\"#Regexp.ReplaceAllFunc\">func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte</a>\n</li>\n<li> <a href=\"#Regexp.ReplaceAllLiteral\">func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte</a>\n</li>\n<li> <a href=\"#Regexp.ReplaceAllLiteralString\">func (re *Regexp) ReplaceAllLiteralString(src, repl string) string</a>\n</li>\n<li> <a href=\"#Regexp.ReplaceAllString\">func (re *Regexp) ReplaceAllString(src, repl string) string</a>\n</li>\n<li> <a href=\"#Regexp.ReplaceAllStringFunc\">func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string</a>\n</li>\n<li> <a href=\"#Regexp.Split\">func (re *Regexp) Split(s string, n int) []string</a>\n</li>\n<li> <a href=\"#Regexp.String\">func (re *Regexp) String() string</a>\n</li>\n<li> <a href=\"#Regexp.SubexpNames\">func (re *Regexp) SubexpNames() []string</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_\">Package</a></dd> <dd><a class=\"exampleLink\" href=\"#example_MatchString\">MatchString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Regexp_FindAllString\">Regexp.FindAllString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Regexp_FindAllStringSubmatch\">Regexp.FindAllStringSubmatch</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Regexp_FindAllStringSubmatchIndex\">Regexp.FindAllStringSubmatchIndex</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Regexp_FindString\">Regexp.FindString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Regexp_FindStringIndex\">Regexp.FindStringIndex</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Regexp_FindStringSubmatch\">Regexp.FindStringSubmatch</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Regexp_ReplaceAllLiteralString\">Regexp.ReplaceAllLiteralString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Regexp_ReplaceAllString\">Regexp.ReplaceAllString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Regexp_Split\">Regexp.Split</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Regexp_SubexpNames\">Regexp.SubexpNames</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/regexp/backtrack.go\">backtrack.go</a> <a href=\"https://golang.org/src/regexp/exec.go\">exec.go</a> <a href=\"https://golang.org/src/regexp/onepass.go\">onepass.go</a> <a href=\"https://golang.org/src/regexp/regexp.go\">regexp.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Match\">func Match  </h2> <pre data-language=\"go\">func Match(pattern string, b []byte) (matched bool, err error)</pre> <p> Match checks whether a textual regular expression matches a byte slice. More complicated queries need to use Compile and the full Regexp interface. </p> <h2 id=\"MatchReader\">func MatchReader  </h2> <pre data-language=\"go\">func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)</pre> <p> MatchReader checks whether a textual regular expression matches the text read by the RuneReader. More complicated queries need to use Compile and the full Regexp interface. </p> <h2 id=\"MatchString\">func MatchString  </h2> <pre data-language=\"go\">func MatchString(pattern string, s string) (matched bool, err error)</pre> <p> MatchString checks whether a textual regular expression matches a string. More complicated queries need to use Compile and the full Regexp interface. </p> <div id=\"example_MatchString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tmatched, err := regexp.MatchString(\"foo.*\", \"seafood\")\n\tfmt.Println(matched, err)\n\tmatched, err = regexp.MatchString(\"bar.*\", \"seafood\")\n\tfmt.Println(matched, err)\n\tmatched, err = regexp.MatchString(\"a(b\", \"seafood\")\n\tfmt.Println(matched, err)\n}\n</pre> </div> </div> <h2 id=\"QuoteMeta\">func QuoteMeta  </h2> <pre data-language=\"go\">func QuoteMeta(s string) string</pre> <p> QuoteMeta returns a string that quotes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text. For example, QuoteMeta(`[foo]`) returns `\\[foo\\]`. </p> <h2 id=\"Regexp\">type Regexp  </h2> <pre data-language=\"go\">type Regexp struct {\n        // contains filtered or unexported fields\n}</pre> <p> Regexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines. </p> <h3 id=\"Compile\">func <a href=\"https://golang.org/src/regexp/regexp.go?s=5090:5132#L121\">Compile</a>  </h3> <pre data-language=\"go\">func Compile(expr string) (*Regexp, error)</pre> <p> Compile parses a regular expression and returns, if successful, a Regexp object that can be used to match against text. </p> <p> When matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses the one that a backtracking search would have found first. This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking. For POSIX leftmost-longest matching, see CompilePOSIX. </p> <h3 id=\"CompilePOSIX\">func <a href=\"https://golang.org/src/regexp/regexp.go?s=6251:6298#L144\">CompilePOSIX</a>  </h3> <pre data-language=\"go\">func CompilePOSIX(expr string) (*Regexp, error)</pre> <p> CompilePOSIX is like Compile but restricts the regular expression to POSIX ERE (egrep) syntax and changes the match semantics to leftmost-longest. </p> <p> That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This so-called leftmost-longest matching is the same semantics that early regular expression implementations used and that POSIX specifies. </p> <p> However, there can be multiple leftmost-longest matches, with different submatch choices, and here this package diverges from POSIX. Among the possible leftmost-longest matches, this package chooses the one that a backtracking search would have found first, while POSIX specifies that the match be chosen to maximize the length of the first subexpression, then the second, and so on from left to right. The POSIX rule is computationally prohibitive and not even well-defined. See <a href=\"http://swtch.com/~rsc/regexp/regexp2.html#posix\">http://swtch.com/~rsc/regexp/regexp2.html#posix</a> for details. </p> <h3 id=\"MustCompile\">func <a href=\"https://golang.org/src/regexp/regexp.go?s=8527:8563#L224\">MustCompile</a>  </h3> <pre data-language=\"go\">func MustCompile(str string) *Regexp</pre> <p> MustCompile is like Compile but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions. </p> <h3 id=\"MustCompilePOSIX\">func <a href=\"https://golang.org/src/regexp/regexp.go?s=8888:8929#L235\">MustCompilePOSIX</a>  </h3> <pre data-language=\"go\">func MustCompilePOSIX(str string) *Regexp</pre> <p> MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions. </p> <h3 id=\"Regexp.Copy\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=4340:4372#L103\">Copy</a>  </h3> <pre data-language=\"go\">func (re *Regexp) Copy() *Regexp</pre> <p> Copy returns a new Regexp object copied from re. </p> <p> When using a Regexp in multiple goroutines, giving each goroutine its own copy helps to avoid lock contention. </p> <h3 id=\"Regexp.Expand\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=24201:24286#L767\">Expand</a>  </h3> <pre data-language=\"go\">func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte</pre> <p> Expand appends template to dst and returns the result; during the append, Expand replaces variables in the template with corresponding matches drawn from src. The match slice should have been returned by FindSubmatchIndex. </p> <p> In the template, a variable is denoted by a substring of the form $name or ${name}, where name is a non-empty sequence of letters, digits, and underscores. A purely numeric name like $1 refers to the submatch with the corresponding index; other names refer to capturing parentheses named with the (?P&lt;name&gt;...) syntax. A reference to an out of range or unmatched index or a name that is not present in the regular expression is replaced with an empty slice. </p> <p> In the $name form, name is taken to be as long as possible: $1x is equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0. </p> <p> To insert a literal $ in the output, use $$ in the template. </p> <h3 id=\"Regexp.ExpandString\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=24525:24616#L774\">ExpandString</a>  </h3> <pre data-language=\"go\">func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte</pre> <p> ExpandString is like Expand but the template and source are strings. It appends to and returns a byte slice in order to give the calling code control over allocation. </p> <h3 id=\"Regexp.Find\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=20893:20932#L673\">Find</a>  </h3> <pre data-language=\"go\">func (re *Regexp) Find(b []byte) []byte</pre> <p> Find returns a slice holding the text of the leftmost match in b of the regular expression. A return value of nil indicates no match. </p> <h3 id=\"Regexp.FindAll\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=29029:29080#L930\">FindAll</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindAll(b []byte, n int) [][]byte</pre> <p> FindAll is the 'All' version of Find; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <h3 id=\"Regexp.FindAllIndex\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=29535:29590#L948\">FindAllIndex</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindAllIndex(b []byte, n int) [][]int</pre> <p> FindAllIndex is the 'All' version of FindIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <h3 id=\"Regexp.FindAllString\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=30036:30093#L966\">FindAllString</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindAllString(s string, n int) []string</pre> <p> FindAllString is the 'All' version of FindString; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <div id=\"example_Regexp_FindAllString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tre := regexp.MustCompile(\"a.\")\n\tfmt.Println(re.FindAllString(\"paranormal\", -1))\n\tfmt.Println(re.FindAllString(\"paranormal\", 2))\n\tfmt.Println(re.FindAllString(\"graal\", -1))\n\tfmt.Println(re.FindAllString(\"none\", -1))\n}\n</pre> </div> </div> <h3 id=\"Regexp.FindAllStringIndex\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=30561:30622#L984\">FindAllStringIndex</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindAllStringIndex(s string, n int) [][]int</pre> <p> FindAllStringIndex is the 'All' version of FindStringIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <h3 id=\"Regexp.FindAllStringSubmatch\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=32252:32319#L1044\">FindAllStringSubmatch</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string</pre> <p> FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <div id=\"example_Regexp_FindAllStringSubmatch\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tre := regexp.MustCompile(\"a(x*)b\")\n\tfmt.Printf(\"%q\\n\", re.FindAllStringSubmatch(\"-ab-\", -1))\n\tfmt.Printf(\"%q\\n\", re.FindAllStringSubmatch(\"-axxb-\", -1))\n\tfmt.Printf(\"%q\\n\", re.FindAllStringSubmatch(\"-ab-axb-\", -1))\n\tfmt.Printf(\"%q\\n\", re.FindAllStringSubmatch(\"-axxb-ab-\", -1))\n}\n</pre> </div> </div> <h3 id=\"Regexp.FindAllStringSubmatchIndex\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=32933:33002#L1069\">FindAllStringSubmatchIndex</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int</pre> <p> FindAllStringSubmatchIndex is the 'All' version of FindStringSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <div id=\"example_Regexp_FindAllStringSubmatchIndex\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tre := regexp.MustCompile(\"a(x*)b\")\n\t// Indices:\n\t//    01234567   012345678\n\t//    -ab-axb-   -axxb-ab-\n\tfmt.Println(re.FindAllStringSubmatchIndex(\"-ab-\", -1))\n\tfmt.Println(re.FindAllStringSubmatchIndex(\"-axxb-\", -1))\n\tfmt.Println(re.FindAllStringSubmatchIndex(\"-ab-axb-\", -1))\n\tfmt.Println(re.FindAllStringSubmatchIndex(\"-axxb-ab-\", -1))\n\tfmt.Println(re.FindAllStringSubmatchIndex(\"-foo-\", -1))\n}\n</pre> </div> </div> <h3 id=\"Regexp.FindAllSubmatch\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=31073:31134#L1002\">FindAllSubmatch</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte</pre> <p> FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <h3 id=\"Regexp.FindAllSubmatchIndex\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=31732:31795#L1026\">FindAllSubmatchIndex</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int</pre> <p> FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <h3 id=\"Regexp.FindIndex\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=21248:21297#L685\">FindIndex</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindIndex(b []byte) (loc []int)</pre> <p> FindIndex returns a two-element slice of integers defining the location of the leftmost match in b of the regular expression. The match itself is at b[loc[0]:loc[1]]. A return value of nil indicates no match. </p> <h3 id=\"Regexp.FindReaderIndex\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=22552:22614#L723\">FindReaderIndex</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)</pre> <p> FindReaderIndex returns a two-element slice of integers defining the location of the leftmost match of the regular expression in text read from the RuneReader. The match text was found in the input stream at byte offset loc[0] through loc[1]-1. A return value of nil indicates no match. </p> <h3 id=\"Regexp.FindReaderSubmatchIndex\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=28600:28664#L920\">FindReaderSubmatchIndex</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int</pre> <p> FindReaderSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression of text read by the RuneReader, and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. </p> <h3 id=\"Regexp.FindString\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=21738:21783#L698\">FindString</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindString(s string) string</pre> <p> FindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use FindStringIndex or FindStringSubmatch if it is necessary to distinguish these cases. </p> <div id=\"example_Regexp_FindString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tre := regexp.MustCompile(\"fo.?\")\n\tfmt.Printf(\"%q\\n\", re.FindString(\"seafood\"))\n\tfmt.Printf(\"%q\\n\", re.FindString(\"meat\"))\n}\n</pre> </div> </div> <h3 id=\"Regexp.FindStringIndex\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=22105:22160#L710\">FindStringIndex</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindStringIndex(s string) (loc []int)</pre> <p> FindStringIndex returns a two-element slice of integers defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match. </p> <div id=\"example_Regexp_FindStringIndex\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tre := regexp.MustCompile(\"ab?\")\n\tfmt.Println(re.FindStringIndex(\"tablett\"))\n\tfmt.Println(re.FindStringIndex(\"foo\") == nil)\n}\n</pre> </div> </div> <h3 id=\"Regexp.FindStringSubmatch\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=27542:27597#L892\">FindStringSubmatch</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindStringSubmatch(s string) []string</pre> <p> FindStringSubmatch returns a slice of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' description in the package comment. A return value of nil indicates no match. </p> <div id=\"example_Regexp_FindStringSubmatch\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tre := regexp.MustCompile(\"a(x*)b(y|z)c\")\n\tfmt.Printf(\"%q\\n\", re.FindStringSubmatch(\"-axxxbyc-\"))\n\tfmt.Printf(\"%q\\n\", re.FindStringSubmatch(\"-abzc-\"))\n}\n</pre> </div> </div> <h3 id=\"Regexp.FindStringSubmatchIndex\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=28140:28197#L911\">FindStringSubmatchIndex</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindStringSubmatchIndex(s string) []int</pre> <p> FindStringSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. </p> <h3 id=\"Regexp.FindSubmatch\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=22983:23032#L736\">FindSubmatch</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindSubmatch(b []byte) [][]byte</pre> <p> FindSubmatch returns a slice of slices holding the text of the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' descriptions in the package comment. A return value of nil indicates no match. </p> <h3 id=\"Regexp.FindSubmatchIndex\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=27139:27190#L883\">FindSubmatchIndex</a>  </h3> <pre data-language=\"go\">func (re *Regexp) FindSubmatchIndex(b []byte) []int</pre> <p> FindSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. </p> <h3 id=\"Regexp.LiteralPrefix\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=12573:12637#L394\">LiteralPrefix</a>  </h3> <pre data-language=\"go\">func (re *Regexp) LiteralPrefix() (prefix string, complete bool)</pre> <p> LiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression. </p> <h3 id=\"Regexp.Longest\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=6609:6636#L152\">Longest</a>  </h3> <pre data-language=\"go\">func (re *Regexp) Longest()</pre> <p> Longest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. </p> <h3 id=\"Regexp.Match\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=13092:13130#L410\">Match</a>  </h3> <pre data-language=\"go\">func (re *Regexp) Match(b []byte) bool</pre> <p> Match reports whether the Regexp matches the byte slice b. </p> <h3 id=\"Regexp.MatchReader\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=12766:12817#L400\">MatchReader</a>  </h3> <pre data-language=\"go\">func (re *Regexp) MatchReader(r io.RuneReader) bool</pre> <p> MatchReader reports whether the Regexp matches the text read by the RuneReader. </p> <h3 id=\"Regexp.MatchString\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=12933:12977#L405\">MatchString</a>  </h3> <pre data-language=\"go\">func (re *Regexp) MatchString(s string) bool</pre> <p> MatchString reports whether the Regexp matches the string s. </p> <h3 id=\"Regexp.NumSubexp\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=9272:9305#L251\">NumSubexp</a>  </h3> <pre data-language=\"go\">func (re *Regexp) NumSubexp() int</pre> <p> NumSubexp returns the number of parenthesized subexpressions in this Regexp. </p> <h3 id=\"Regexp.ReplaceAll\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=17515:17568#L548\">ReplaceAll</a>  </h3> <pre data-language=\"go\">func (re *Regexp) ReplaceAll(src, repl []byte) []byte</pre> <p> ReplaceAll returns a copy of src, replacing matches of the Regexp with the replacement text repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch. </p> <h3 id=\"Regexp.ReplaceAllFunc\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=18467:18544#L576\">ReplaceAllFunc</a>  </h3> <pre data-language=\"go\">func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte</pre> <p> ReplaceAllFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched byte slice. The replacement returned by repl is substituted directly, without using Expand. </p> <h3 id=\"Regexp.ReplaceAllLiteral\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=18039:18099#L566\">ReplaceAllLiteral</a>  </h3> <pre data-language=\"go\">func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte</pre> <p> ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp with the replacement bytes repl. The replacement repl is substituted directly, without using Expand. </p> <h3 id=\"Regexp.ReplaceAllLiteralString\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=14895:14961#L464\">ReplaceAllLiteralString</a>  </h3> <pre data-language=\"go\">func (re *Regexp) ReplaceAllLiteralString(src, repl string) string</pre> <p> ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp with the replacement string repl. The replacement repl is substituted directly, without using Expand. </p> <div id=\"example_Regexp_ReplaceAllLiteralString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tre := regexp.MustCompile(\"a(x*)b\")\n\tfmt.Println(re.ReplaceAllLiteralString(\"-ab-axxb-\", \"T\"))\n\tfmt.Println(re.ReplaceAllLiteralString(\"-ab-axxb-\", \"$1\"))\n\tfmt.Println(re.ReplaceAllLiteralString(\"-ab-axxb-\", \"${1}\"))\n}\n</pre> </div> </div> <h3 id=\"Regexp.ReplaceAllString\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=14425:14484#L450\">ReplaceAllString</a>  </h3> <pre data-language=\"go\">func (re *Regexp) ReplaceAllString(src, repl string) string</pre> <p> ReplaceAllString returns a copy of src, replacing matches of the Regexp with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch. </p> <div id=\"example_Regexp_ReplaceAllString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tre := regexp.MustCompile(\"a(x*)b\")\n\tfmt.Println(re.ReplaceAllString(\"-ab-axxb-\", \"T\"))\n\tfmt.Println(re.ReplaceAllString(\"-ab-axxb-\", \"$1\"))\n\tfmt.Println(re.ReplaceAllString(\"-ab-axxb-\", \"$1W\"))\n\tfmt.Println(re.ReplaceAllString(\"-ab-axxb-\", \"${1}W\"))\n}\n</pre> </div> </div> <h3 id=\"Regexp.ReplaceAllStringFunc\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=15343:15426#L474\">ReplaceAllStringFunc</a>  </h3> <pre data-language=\"go\">func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string</pre> <p> ReplaceAllStringFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched substring. The replacement returned by repl is substituted directly, without using Expand. </p> <h3 id=\"Regexp.Split\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=33929:33978#L1098\">Split</a>  </h3> <pre data-language=\"go\">func (re *Regexp) Split(s string, n int) []string</pre> <p> Split slices s into substrings separated by the expression and returns a slice of the substrings between those expression matches. </p> <p> The slice returned by this method consists of all the substrings of s not contained in the slice returned by FindAllString. When called on an expression that contains no metacharacters, it is equivalent to strings.SplitN. </p> <p> Example: </p> <pre data-language=\"go\">s := regexp.MustCompile(\"a*\").Split(\"abaabaccadaaae\", 5)\n// s: [\"\", \"b\", \"b\", \"c\", \"cadaaae\"]\n</pre> <p> The count determines the number of substrings to return: </p> <pre data-language=\"go\">n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.\nn == 0: the result is nil (zero substrings)\nn &lt; 0: all substrings\n</pre> <div id=\"example_Regexp_Split\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\ta := regexp.MustCompile(\"a\")\n\tfmt.Println(a.Split(\"banana\", -1))\n\tfmt.Println(a.Split(\"banana\", 0))\n\tfmt.Println(a.Split(\"banana\", 1))\n\tfmt.Println(a.Split(\"banana\", 2))\n\tzp := regexp.MustCompile(\"z+\")\n\tfmt.Println(zp.Split(\"pizza\", -1))\n\tfmt.Println(zp.Split(\"pizza\", 0))\n\tfmt.Println(zp.Split(\"pizza\", 1))\n\tfmt.Println(zp.Split(\"pizza\", 2))\n}\n</pre> </div> </div> <h3 id=\"Regexp.String\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=4113:4146#L95\">String</a>  </h3> <pre data-language=\"go\">func (re *Regexp) String() string</pre> <p> String returns the source text used to compile the regular expression. </p> <h3 id=\"Regexp.SubexpNames\">func (*Regexp) <a href=\"https://golang.org/src/regexp/regexp.go?s=9666:9706#L260\">SubexpNames</a>  </h3> <pre data-language=\"go\">func (re *Regexp) SubexpNames() []string</pre> <p> SubexpNames returns the names of the parenthesized subexpressions in this Regexp. The name for the first sub-expression is names[1], so that if m is a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a whole cannot be named, names[0] is always the empty string. The slice should not be modified. </p> <div id=\"example_Regexp_SubexpNames\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tre := regexp.MustCompile(\"(?P&lt;first&gt;[a-zA-Z]+) (?P&lt;last&gt;[a-zA-Z]+)\")\n\tfmt.Println(re.MatchString(\"Alan Turing\"))\n\tfmt.Printf(\"%q\\n\", re.SubexpNames())\n\treversed := fmt.Sprintf(\"${%s} ${%s}\", re.SubexpNames()[2], re.SubexpNames()[1])\n\tfmt.Println(reversed)\n\tfmt.Println(re.ReplaceAllString(\"Alan Turing\", reversed))\n}\n</pre> </div> </div> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"syntax/index\">syntax</a> </td> <td class=\"pkg-synopsis\"> Package syntax parses regular expressions into parse trees and compiles parse trees into programs. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/regexp/\" class=\"_attribution-link\">https://golang.org/pkg/regexp/</a>\n  </p>\n</div>\n","sync/atomic/index":"<h1>Package atomic</h1>     <ul id=\"short-nav\">\n<li><code>import \"sync/atomic\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms. </p> <p> These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory. </p> <p> The swap operation, implemented by the SwapT functions, is the atomic equivalent of: </p> <pre data-language=\"go\">old = *addr\n*addr = new\nreturn old\n</pre> <p> The compare-and-swap operation, implemented by the CompareAndSwapT functions, is the atomic equivalent of: </p> <pre data-language=\"go\">if *addr == old {\n\t*addr = new\n\treturn true\n}\nreturn false\n</pre> <p> The add operation, implemented by the AddT functions, is the atomic equivalent of: </p> <pre data-language=\"go\">*addr += delta\nreturn *addr\n</pre> <p> The load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of \"return *addr\" and \"*addr = val\". </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#AddInt32\">func AddInt32(addr *int32, delta int32) (new int32)</a></li>\n<li><a href=\"#AddInt64\">func AddInt64(addr *int64, delta int64) (new int64)</a></li>\n<li><a href=\"#AddUint32\">func AddUint32(addr *uint32, delta uint32) (new uint32)</a></li>\n<li><a href=\"#AddUint64\">func AddUint64(addr *uint64, delta uint64) (new uint64)</a></li>\n<li><a href=\"#AddUintptr\">func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</a></li>\n<li><a href=\"#CompareAndSwapInt32\">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</a></li>\n<li><a href=\"#CompareAndSwapInt64\">func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</a></li>\n<li><a href=\"#CompareAndSwapPointer\">func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</a></li>\n<li><a href=\"#CompareAndSwapUint32\">func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</a></li>\n<li><a href=\"#CompareAndSwapUint64\">func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</a></li>\n<li><a href=\"#CompareAndSwapUintptr\">func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</a></li>\n<li><a href=\"#LoadInt32\">func LoadInt32(addr *int32) (val int32)</a></li>\n<li><a href=\"#LoadInt64\">func LoadInt64(addr *int64) (val int64)</a></li>\n<li><a href=\"#LoadPointer\">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</a></li>\n<li><a href=\"#LoadUint32\">func LoadUint32(addr *uint32) (val uint32)</a></li>\n<li><a href=\"#LoadUint64\">func LoadUint64(addr *uint64) (val uint64)</a></li>\n<li><a href=\"#LoadUintptr\">func LoadUintptr(addr *uintptr) (val uintptr)</a></li>\n<li><a href=\"#StoreInt32\">func StoreInt32(addr *int32, val int32)</a></li>\n<li><a href=\"#StoreInt64\">func StoreInt64(addr *int64, val int64)</a></li>\n<li><a href=\"#StorePointer\">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</a></li>\n<li><a href=\"#StoreUint32\">func StoreUint32(addr *uint32, val uint32)</a></li>\n<li><a href=\"#StoreUint64\">func StoreUint64(addr *uint64, val uint64)</a></li>\n<li><a href=\"#StoreUintptr\">func StoreUintptr(addr *uintptr, val uintptr)</a></li>\n<li><a href=\"#SwapInt32\">func SwapInt32(addr *int32, new int32) (old int32)</a></li>\n<li><a href=\"#SwapInt64\">func SwapInt64(addr *int64, new int64) (old int64)</a></li>\n<li><a href=\"#SwapPointer\">func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</a></li>\n<li><a href=\"#SwapUint32\">func SwapUint32(addr *uint32, new uint32) (old uint32)</a></li>\n<li><a href=\"#SwapUint64\">func SwapUint64(addr *uint64, new uint64) (old uint64)</a></li>\n<li><a href=\"#SwapUintptr\">func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</a></li>\n<li><a href=\"#Value\">type Value</a></li>\n<li> <a href=\"#Value.Load\">func (v *Value) Load() (x interface{})</a>\n</li>\n<li> <a href=\"#Value.Store\">func (v *Value) Store(x interface{})</a>\n</li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Value_config\">Value (Config)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Value_readMostly\">Value (ReadMostly)</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/sync/atomic/doc.go\">doc.go</a> <a href=\"https://golang.org/src/sync/atomic/value.go\">value.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"AddInt32\">func AddInt32  </h2> <pre data-language=\"go\">func AddInt32(addr *int32, delta int32) (new int32)</pre> <p> AddInt32 atomically adds delta to *addr and returns the new value. </p> <h2 id=\"AddInt64\">func AddInt64  </h2> <pre data-language=\"go\">func AddInt64(addr *int64, delta int64) (new int64)</pre> <p> AddInt64 atomically adds delta to *addr and returns the new value. </p> <h2 id=\"AddUint32\">func AddUint32  </h2> <pre data-language=\"go\">func AddUint32(addr *uint32, delta uint32) (new uint32)</pre> <p> AddUint32 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint32(&amp;x, ^uint32(c-1)). In particular, to decrement x, do AddUint32(&amp;x, ^uint32(0)). </p> <h2 id=\"AddUint64\">func AddUint64  </h2> <pre data-language=\"go\">func AddUint64(addr *uint64, delta uint64) (new uint64)</pre> <p> AddUint64 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint64(&amp;x, ^uint64(c-1)). In particular, to decrement x, do AddUint64(&amp;x, ^uint64(0)). </p> <h2 id=\"AddUintptr\">func AddUintptr  </h2> <pre data-language=\"go\">func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</pre> <p> AddUintptr atomically adds delta to *addr and returns the new value. </p> <h2 id=\"CompareAndSwapInt32\">func CompareAndSwapInt32  </h2> <pre data-language=\"go\">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</pre> <p> CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value. </p> <h2 id=\"CompareAndSwapInt64\">func CompareAndSwapInt64  </h2> <pre data-language=\"go\">func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</pre> <p> CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value. </p> <h2 id=\"CompareAndSwapPointer\">func CompareAndSwapPointer  </h2> <pre data-language=\"go\">func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</pre> <p> CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value. </p> <h2 id=\"CompareAndSwapUint32\">func CompareAndSwapUint32  </h2> <pre data-language=\"go\">func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</pre> <p> CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value. </p> <h2 id=\"CompareAndSwapUint64\">func CompareAndSwapUint64  </h2> <pre data-language=\"go\">func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</pre> <p> CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value. </p> <h2 id=\"CompareAndSwapUintptr\">func CompareAndSwapUintptr  </h2> <pre data-language=\"go\">func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</pre> <p> CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value. </p> <h2 id=\"LoadInt32\">func LoadInt32  </h2> <pre data-language=\"go\">func LoadInt32(addr *int32) (val int32)</pre> <p> LoadInt32 atomically loads *addr. </p> <h2 id=\"LoadInt64\">func LoadInt64  </h2> <pre data-language=\"go\">func LoadInt64(addr *int64) (val int64)</pre> <p> LoadInt64 atomically loads *addr. </p> <h2 id=\"LoadPointer\">func LoadPointer  </h2> <pre data-language=\"go\">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</pre> <p> LoadPointer atomically loads *addr. </p> <h2 id=\"LoadUint32\">func LoadUint32  </h2> <pre data-language=\"go\">func LoadUint32(addr *uint32) (val uint32)</pre> <p> LoadUint32 atomically loads *addr. </p> <h2 id=\"LoadUint64\">func LoadUint64  </h2> <pre data-language=\"go\">func LoadUint64(addr *uint64) (val uint64)</pre> <p> LoadUint64 atomically loads *addr. </p> <h2 id=\"LoadUintptr\">func LoadUintptr  </h2> <pre data-language=\"go\">func LoadUintptr(addr *uintptr) (val uintptr)</pre> <p> LoadUintptr atomically loads *addr. </p> <h2 id=\"StoreInt32\">func StoreInt32  </h2> <pre data-language=\"go\">func StoreInt32(addr *int32, val int32)</pre> <p> StoreInt32 atomically stores val into *addr. </p> <h2 id=\"StoreInt64\">func StoreInt64  </h2> <pre data-language=\"go\">func StoreInt64(addr *int64, val int64)</pre> <p> StoreInt64 atomically stores val into *addr. </p> <h2 id=\"StorePointer\">func StorePointer  </h2> <pre data-language=\"go\">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</pre> <p> StorePointer atomically stores val into *addr. </p> <h2 id=\"StoreUint32\">func StoreUint32  </h2> <pre data-language=\"go\">func StoreUint32(addr *uint32, val uint32)</pre> <p> StoreUint32 atomically stores val into *addr. </p> <h2 id=\"StoreUint64\">func StoreUint64  </h2> <pre data-language=\"go\">func StoreUint64(addr *uint64, val uint64)</pre> <p> StoreUint64 atomically stores val into *addr. </p> <h2 id=\"StoreUintptr\">func StoreUintptr  </h2> <pre data-language=\"go\">func StoreUintptr(addr *uintptr, val uintptr)</pre> <p> StoreUintptr atomically stores val into *addr. </p> <h2 id=\"SwapInt32\">func SwapInt32  </h2> <pre data-language=\"go\">func SwapInt32(addr *int32, new int32) (old int32)</pre> <p> SwapInt32 atomically stores new into *addr and returns the previous *addr value. </p> <h2 id=\"SwapInt64\">func SwapInt64  </h2> <pre data-language=\"go\">func SwapInt64(addr *int64, new int64) (old int64)</pre> <p> SwapInt64 atomically stores new into *addr and returns the previous *addr value. </p> <h2 id=\"SwapPointer\">func SwapPointer  </h2> <pre data-language=\"go\">func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</pre> <p> SwapPointer atomically stores new into *addr and returns the previous *addr value. </p> <h2 id=\"SwapUint32\">func SwapUint32  </h2> <pre data-language=\"go\">func SwapUint32(addr *uint32, new uint32) (old uint32)</pre> <p> SwapUint32 atomically stores new into *addr and returns the previous *addr value. </p> <h2 id=\"SwapUint64\">func SwapUint64  </h2> <pre data-language=\"go\">func SwapUint64(addr *uint64, new uint64) (old uint64)</pre> <p> SwapUint64 atomically stores new into *addr and returns the previous *addr value. </p> <h2 id=\"SwapUintptr\">func SwapUintptr  </h2> <pre data-language=\"go\">func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</pre> <p> SwapUintptr atomically stores new into *addr and returns the previous *addr value. </p> <h2 id=\"Value\">type Value  </h2> <pre data-language=\"go\">type Value struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Value provides an atomic load and store of a consistently typed value. Values can be created as part of other data structures. The zero value for a Value returns nil from Load. Once Store has been called, a Value must not be copied. </p> <p> A Value must not be copied after first use. </p> <div id=\"example_Value_config\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Config)</h2> <p>The following example shows how to use Value for periodic program config updates and propagation of the changes to worker goroutines. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    var config Value // holds current server configuration\n    // Create initial config value and store into config.\n    config.Store(loadConfig())\n    go func() {\n            // Reload config every 10 seconds\n            // and update config value with the new version.\n            for {\n                    time.Sleep(10 * time.Second)\n                    config.Store(loadConfig())\n            }\n    }()\n    // Create worker goroutines that handle incoming requests\n    // using the latest config value.\n    for i := 0; i &lt; 10; i++ {\n            go func() {\n                    for r := range requests() {\n                            c := config.Load()\n                            // Handle request r using config c.\n                            _, _ = r, c\n                    }\n            }()\n    }\n</pre> </div> </div> <div id=\"example_Value_readMostly\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (ReadMostly)</h2> <p>The following example shows how to maintain a scalable frequently read, but infrequently updated data structure using copy-on-write idiom. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    type Map map[string]string\n    var m Value\n    m.Store(make(Map))\n    var mu sync.Mutex // used only by writers\n    // read function can be used to read the data without further synchronization\n    read := func(key string) (val string) {\n            m1 := m.Load().(Map)\n            return m1[key]\n    }\n    // insert function can be used to update the data without further synchronization\n    insert := func(key, val string) {\n            mu.Lock() // synchronize with other potential writers\n            defer mu.Unlock()\n            m1 := m.Load().(Map) // load current value of the data structure\n            m2 := make(Map)      // create a new value\n            for k, v := range m1 {\n                    m2[k] = v // copy all data from the current object to the new one\n            }\n            m2[key] = val // do the update that we need\n            m.Store(m2)   // atomically replace the current object with the new one\n            // At this point all new readers start working with the new version.\n            // The old version will be garbage collected once the existing readers\n            // (if any) are done with it.\n    }\n    _, _ = read, insert\n</pre> </div> </div> <h3 id=\"Value.Load\">func (*Value) <a href=\"https://golang.org/src/sync/atomic/value.go?s=798:836#L21\">Load</a>  </h3> <pre data-language=\"go\">func (v *Value) Load() (x interface{})</pre> <p> Load returns the value set by the most recent Store. It returns nil if there has been no call to Store for this Value. </p> <h3 id=\"Value.Store\">func (*Value) <a href=\"https://golang.org/src/sync/atomic/value.go?s=1308:1344#L38\">Store</a>  </h3> <pre data-language=\"go\">func (v *Value) Store(x interface{})</pre> <p> Store sets the value of the Value to x. All calls to Store for a given Value must use values of the same concrete type. Store of an inconsistent type panics, as does Store(nil). </p> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/sync/atomic/doc.go?s=1206:1655#L36\" style=\"float: left;\">☞</a> <p> On x86-32, the 64-bit functions use instructions unavailable before the Pentium MMX. </p> <p> On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core. </p> <p> On both ARM and x86-32, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a global variable or in an allocated struct or slice can be relied upon to be 64-bit aligned. </p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/sync/atomic/\" class=\"_attribution-link\">https://golang.org/pkg/sync/atomic/</a>\n  </p>\n</div>\n","text/scanner/index":"<h1>Package scanner</h1>     <ul id=\"short-nav\">\n<li><code>import \"text/scanner\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package scanner provides a scanner and tokenizer for UTF-8-encoded text. It takes an io.Reader providing the source, which then can be tokenized through repeated calls to the Scan function. For compatibility with existing tools, the NUL character is not allowed. If the first character in the source is a UTF-8 encoded byte order mark (BOM), it is discarded. </p> <p> By default, a Scanner skips white space and Go comments and recognizes all literals as defined by the Go language specification. It may be customized to recognize only a subset of those literals and to recognize different identifier and white space characters. </p> </div> </div> <div id=\"example_\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"text/scanner\"\n)\n\nfunc main() {\n\tconst src = `\n\t// This is scanned code.\n\tif a &gt; 10 {\n\t\tsomeParsable = text\n\t}`\n\tvar s scanner.Scanner\n\ts.Filename = \"example\"\n\ts.Init(strings.NewReader(src))\n\tvar tok rune\n\tfor tok != scanner.EOF {\n\t\ttok = s.Scan()\n\t\tfmt.Println(\"At position\", s.Pos(), \":\", s.TokenText())\n\t}\n\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#TokenString\">func TokenString(tok rune) string</a></li>\n<li><a href=\"#Position\">type Position</a></li>\n<li> <a href=\"#Position.IsValid\">func (pos *Position) IsValid() bool</a>\n</li>\n<li> <a href=\"#Position.String\">func (pos Position) String() string</a>\n</li>\n<li><a href=\"#Scanner\">type Scanner</a></li>\n<li> <a href=\"#Scanner.Init\">func (s *Scanner) Init(src io.Reader) *Scanner</a>\n</li>\n<li> <a href=\"#Scanner.Next\">func (s *Scanner) Next() rune</a>\n</li>\n<li> <a href=\"#Scanner.Peek\">func (s *Scanner) Peek() rune</a>\n</li>\n<li> <a href=\"#Scanner.Pos\">func (s *Scanner) Pos() (pos Position)</a>\n</li>\n<li> <a href=\"#Scanner.Scan\">func (s *Scanner) Scan() rune</a>\n</li>\n<li> <a href=\"#Scanner.TokenText\">func (s *Scanner) TokenText() string</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_\">Package</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/text/scanner/scanner.go\">scanner.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        ScanIdents     = 1 &lt;&lt; -Ident\n        ScanInts       = 1 &lt;&lt; -Int\n        ScanFloats     = 1 &lt;&lt; -Float // includes Ints\n        ScanChars      = 1 &lt;&lt; -Char\n        ScanStrings    = 1 &lt;&lt; -String\n        ScanRawStrings = 1 &lt;&lt; -RawString\n        ScanComments   = 1 &lt;&lt; -Comment\n        SkipComments   = 1 &lt;&lt; -skipComment // if set with ScanComments, comments become white space\n        GoTokens       = ScanIdents | ScanFloats | ScanChars | ScanStrings | ScanRawStrings | ScanComments | SkipComments\n)</pre> <p> Predefined mode bits to control recognition of tokens. For instance, to configure a Scanner such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to: </p> <pre data-language=\"go\">ScanIdents | ScanInts | SkipComments\n</pre> <p> With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string \"foo\" is scanned as the token sequence '\"' Ident '\"'. </p> <pre data-language=\"go\">const (\n        EOF = -(iota + 1)\n        Ident\n        Int\n        Float\n        Char\n        String\n        RawString\n        Comment\n)</pre> <p> The result of Scan is one of these tokens or a Unicode character. </p> <pre data-language=\"go\">const GoWhitespace = 1&lt;&lt;'\\t' | 1&lt;&lt;'\\n' | 1&lt;&lt;'\\r' | 1&lt;&lt;' '</pre> <p> GoWhitespace is the default value for the Scanner's Whitespace field. Its value selects Go's white space characters. </p> <h2 id=\"TokenString\">func TokenString  </h2> <pre data-language=\"go\">func TokenString(tok rune) string</pre> <p> TokenString returns a printable string for a token or Unicode character. </p> <h2 id=\"Position\">type Position  </h2> <pre data-language=\"go\">type Position struct {\n        Filename string // filename, if any\n        Offset   int    // byte offset, starting at 0\n        Line     int    // line number, starting at 1\n        Column   int    // column number, starting at 1 (character count per line)\n}</pre> <p> A source position is represented by a Position value. A position is valid if Line &gt; 0. </p> <h3 id=\"Position.IsValid\">func (*Position) <a href=\"https://golang.org/src/text/scanner/scanner.go?s=1270:1305#L26\">IsValid</a>  </h3> <pre data-language=\"go\">func (pos *Position) IsValid() bool</pre> <p> IsValid reports whether the position is valid. </p> <h3 id=\"Position.String\">func (Position) <a href=\"https://golang.org/src/text/scanner/scanner.go?s=1331:1366#L28\">String</a>  </h3> <pre data-language=\"go\">func (pos Position) String() string</pre> <h2 id=\"Scanner\">type Scanner  </h2> <pre data-language=\"go\">type Scanner struct {\n\n        // Error is called for each error encountered. If no Error\n        // function is set, the error is reported to os.Stderr.\n        Error func(s *Scanner, msg string)\n\n        // ErrorCount is incremented by one for each error encountered.\n        ErrorCount int\n\n        // The Mode field controls which tokens are recognized. For instance,\n        // to recognize Ints, set the ScanInts bit in Mode. The field may be\n        // changed at any time.\n        Mode uint\n\n        // The Whitespace field controls which characters are recognized\n        // as white space. To recognize a character ch &lt;= ' ' as white space,\n        // set the ch'th bit in Whitespace (the Scanner's behavior is undefined\n        // for values ch &gt; ' '). The field may be changed at any time.\n        Whitespace uint64\n\n        // IsIdentRune is a predicate controlling the characters accepted\n        // as the ith rune in an identifier. The set of valid characters\n        // must not intersect with the set of white space characters.\n        // If no IsIdentRune function is set, regular Go identifiers are\n        // accepted instead. The field may be changed at any time.\n        IsIdentRune func(ch rune, i int) bool\n\n        // Start position of most recently scanned token; set by Scan.\n        // Calling Init or Next invalidates the position (Line == 0).\n        // The Filename field is always left untouched by the Scanner.\n        // If an error is reported (via Error) and Position is invalid,\n        // the scanner is not inside a token. Call Pos to obtain an error\n        // position in that case.\n        Position\n        // contains filtered or unexported fields\n}</pre> <p> A Scanner implements reading of Unicode characters and tokens from an io.Reader. </p> <h3 id=\"Scanner.Init\">func (*Scanner) <a href=\"https://golang.org/src/text/scanner/scanner.go?s=6096:6142#L166\">Init</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Init(src io.Reader) *Scanner</pre> <p> Init initializes a Scanner with a new source and returns s. Error is set to nil, ErrorCount is set to 0, Mode is set to GoTokens, and Whitespace is set to GoWhitespace. </p> <h3 id=\"Scanner.Next\">func (*Scanner) <a href=\"https://golang.org/src/text/scanner/scanner.go?s=9407:9436#L289\">Next</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Next() rune</pre> <p> Next reads and returns the next Unicode character. It returns EOF at the end of the source. It reports a read error by calling s.Error, if not nil; otherwise it prints an error message to os.Stderr. Next does not update the Scanner's Position field; use Pos() to get the current position. </p> <h3 id=\"Scanner.Peek\">func (*Scanner) <a href=\"https://golang.org/src/text/scanner/scanner.go?s=9768:9797#L302\">Peek</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Peek() rune</pre> <p> Peek returns the next Unicode character in the source without advancing the scanner. It returns EOF if the scanner's position is at the last character of the source. </p> <h3 id=\"Scanner.Pos\">func (*Scanner) <a href=\"https://golang.org/src/text/scanner/scanner.go?s=16361:16399#L630\">Pos</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Pos() (pos Position)</pre> <p> Pos returns the position of the character immediately after the character or token returned by the last call to Next or Scan. </p> <h3 id=\"Scanner.Scan\">func (*Scanner) <a href=\"https://golang.org/src/text/scanner/scanner.go?s=14320:14349#L528\">Scan</a>  </h3> <pre data-language=\"go\">func (s *Scanner) Scan() rune</pre> <p> Scan reads the next token or Unicode character from source and returns it. It only recognizes tokens t for which the respective Mode bit (1&lt;&lt;-t) is set. It returns EOF at the end of the source. It reports scanner errors (read and token errors) by calling s.Error, if not nil; otherwise it prints an error message to os.Stderr. </p> <h3 id=\"Scanner.TokenText\">func (*Scanner) <a href=\"https://golang.org/src/text/scanner/scanner.go?s=16921:16957#L652\">TokenText</a>  </h3> <pre data-language=\"go\">func (s *Scanner) TokenText() string</pre> <p> TokenText returns the string corresponding to the most recently scanned token. Valid after calling Scan(). </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/text/scanner/\" class=\"_attribution-link\">https://golang.org/pkg/text/scanner/</a>\n  </p>\n</div>\n","text/tabwriter/index":"<h1>Package tabwriter</h1>     <ul id=\"short-nav\">\n<li><code>import \"text/tabwriter\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package tabwriter implements a write filter (tabwriter.Writer) that translates tabbed columns in input into properly aligned text. </p> <p> The package is using the Elastic Tabstops algorithm described at <a href=\"http://nickgravgaard.com/elastictabstops/index.html\">http://nickgravgaard.com/elastictabstops/index.html</a>. </p> </div> </div> <div id=\"example__elastic\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Elastic)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"text/tabwriter\"\n)\n\nfunc main() {\n\t// Observe how the b's and the d's, despite appearing in the\n\t// second cell of each line, belong to different columns.\n\tw := tabwriter.NewWriter(os.Stdout, 0, 0, 1, '.', tabwriter.AlignRight|tabwriter.Debug)\n\tfmt.Fprintln(w, \"a\\tb\\tc\")\n\tfmt.Fprintln(w, \"aa\\tbb\\tcc\")\n\tfmt.Fprintln(w, \"aaa\\t\") // trailing tab\n\tfmt.Fprintln(w, \"aaaa\\tdddd\\teeee\")\n\tw.Flush()\n\n}\n</pre> </div> </div> <div id=\"example__trailingTab\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (TrailingTab)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"text/tabwriter\"\n)\n\nfunc main() {\n\t// Observe that the third line has no trailing tab,\n\t// so its final cell is not part of an aligned column.\n\tconst padding = 3\n\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, '-', tabwriter.AlignRight|tabwriter.Debug)\n\tfmt.Fprintln(w, \"a\\tb\\taligned\\t\")\n\tfmt.Fprintln(w, \"aa\\tbb\\taligned\\t\")\n\tfmt.Fprintln(w, \"aaa\\tbbb\\tunaligned\") // no trailing tab\n\tfmt.Fprintln(w, \"aaaa\\tbbbb\\taligned\\t\")\n\tw.Flush()\n\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#Writer\">type Writer</a></li>\n<li> <a href=\"#NewWriter\">func NewWriter(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer</a>\n</li>\n<li> <a href=\"#Writer.Flush\">func (b *Writer) Flush() error</a>\n</li>\n<li> <a href=\"#Writer.Init\">func (b *Writer) Init(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer</a>\n</li>\n<li> <a href=\"#Writer.Write\">func (b *Writer) Write(buf []byte) (n int, err error)</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Writer_Init\">Writer.Init</a></dd> <dd><a class=\"exampleLink\" href=\"#example__elastic\">Package (Elastic)</a></dd> <dd><a class=\"exampleLink\" href=\"#example__trailingTab\">Package (TrailingTab)</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/text/tabwriter/tabwriter.go\">tabwriter.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        // Ignore html tags and treat entities (starting with '&amp;'\n        // and ending in ';') as single characters (width = 1).\n        FilterHTML uint = 1 &lt;&lt; iota\n\n        // Strip Escape characters bracketing escaped text segments\n        // instead of passing them through unchanged with the text.\n        StripEscape\n\n        // Force right-alignment of cell content.\n        // Default is left-alignment.\n        AlignRight\n\n        // Handle empty columns as if they were not present in\n        // the input in the first place.\n        DiscardEmptyColumns\n\n        // Always use tabs for indentation columns (i.e., padding of\n        // leading empty cells on the left) independent of padchar.\n        TabIndent\n\n        // Print a vertical bar ('|') between columns (after formatting).\n        // Discarded columns appear as zero-width columns (\"||\").\n        Debug\n)</pre> <p> Formatting can be controlled with these flags. </p> <pre data-language=\"go\">const Escape = '\\xff'</pre> <p> To escape a text segment, bracket it with Escape characters. For instance, the tab in this string \"Ignore this tab: \\xff\\t\\xff\" does not terminate a cell and constitutes a single character of width one for formatting purposes. </p> <p> The value 0xff was chosen because it cannot appear in a valid UTF-8 sequence. </p> <h2 id=\"Writer\">type Writer  </h2> <pre data-language=\"go\">type Writer struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Writer is a filter that inserts padding around tab-delimited columns in its input to align them in the output. </p> <p> The Writer treats incoming bytes as UTF-8-encoded text consisting of cells terminated by horizontal ('\\t') or vertical ('\\v') tabs, and newline ('\\n') or formfeed ('\\f') characters; both newline and formfeed act as line breaks. </p> <p> Tab-terminated cells in contiguous lines constitute a column. The Writer inserts padding as needed to make all cells in a column have the same width, effectively aligning the columns. It assumes that all characters have the same width, except for tabs for which a tabwidth must be specified. Column cells must be tab-terminated, not tab-separated: non-tab terminated trailing text at the end of a line forms a cell but that cell is not part of an aligned column. For instance, in this example (where | stands for a horizontal tab): </p> <pre data-language=\"go\">aaaa|bbb|d\naa  |b  |dd\na   |\naa  |cccc|eee\n</pre> <p> the b and c are in distinct columns (the b column is not contiguous all the way). The d and e are not in a column at all (there's no terminating tab, nor would the column be contiguous). </p> <p> The Writer assumes that all Unicode code points have the same width; this may not be true in some fonts or if the string contains combining characters. </p> <p> If DiscardEmptyColumns is set, empty columns that are terminated entirely by vertical (or \"soft\") tabs are discarded. Columns terminated by horizontal (or \"hard\") tabs are not affected by this flag. </p> <p> If a Writer is configured to filter HTML, HTML tags and entities are passed through. The widths of tags and entities are assumed to be zero (tags) and one (entities) for formatting purposes. </p> <p> A segment of text may be escaped by bracketing it with Escape characters. The tabwriter passes escaped text segments through unchanged. In particular, it does not interpret any tabs or line breaks within the segment. If the StripEscape flag is set, the Escape characters are stripped from the output; otherwise they are passed through as well. For the purpose of formatting, the width of the escaped text is always computed excluding the Escape characters. </p> <p> The formfeed character acts like a newline but it also terminates all columns in the current line (effectively calling Flush). Tab- terminated cells in the next line start new columns. Unless found inside an HTML tag or inside an escaped text segment, formfeed characters appear as newlines in the output. </p> <p> The Writer must buffer input internally, because proper spacing of one line may depend on the cells in future lines. Clients must call Flush when done calling Write. </p> <h3 id=\"NewWriter\">func <a href=\"https://golang.org/src/text/tabwriter/tabwriter.go?s=16847:16946#L562\">NewWriter</a>  </h3> <pre data-language=\"go\">func NewWriter(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer</pre> <p> NewWriter allocates and initializes a new tabwriter.Writer. The parameters are the same as for the Init function. </p> <h3 id=\"Writer.Flush\">func (*Writer) <a href=\"https://golang.org/src/text/tabwriter/tabwriter.go?s=14443:14473#L455\">Flush</a>  </h3> <pre data-language=\"go\">func (b *Writer) Flush() error</pre> <p> Flush should be called after the last call to Write to ensure that any data buffered in the Writer is written to output. Any incomplete escape sequence at the end is considered complete for formatting purposes. </p> <h3 id=\"Writer.Init\">func (*Writer) <a href=\"https://golang.org/src/text/tabwriter/tabwriter.go?s=7410:7516#L176\">Init</a>  </h3> <pre data-language=\"go\">func (b *Writer) Init(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer</pre> <p> A Writer must be initialized with a call to Init. The first parameter (output) specifies the filter output. The remaining parameters control the formatting: </p> <pre data-language=\"go\">minwidth\tminimal cell width including any padding\ntabwidth\twidth of tab characters (equivalent number of spaces)\npadding\t\tpadding added to a cell before computing its width\npadchar\t\tASCII char used for padding\n\t\tif padchar == '\\t', the Writer will assume that the\n\t\twidth of a '\\t' in the formatted output is tabwidth,\n\t\tand cells are left-aligned independent of align_left\n\t\t(for correct-looking results, tabwidth must correspond\n\t\tto the tab width in the viewer displaying the result)\nflags\t\tformatting control\n</pre> <div id=\"example_Writer_Init\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"text/tabwriter\"\n)\n\nfunc main() {\n\tw := new(tabwriter.Writer)\n\n\t// Format in tab-separated columns with a tab stop of 8.\n\tw.Init(os.Stdout, 0, 8, 0, '\\t', 0)\n\tfmt.Fprintln(w, \"a\\tb\\tc\\td\\t.\")\n\tfmt.Fprintln(w, \"123\\t12345\\t1234567\\t123456789\\t.\")\n\tfmt.Fprintln(w)\n\tw.Flush()\n\n\t// Format right-aligned in space-separated columns of minimal width 5\n\t// and at least one blank of padding (so wider column entries do not\n\t// touch each other).\n\tw.Init(os.Stdout, 5, 0, 1, ' ', tabwriter.AlignRight)\n\tfmt.Fprintln(w, \"a\\tb\\tc\\td\\t.\")\n\tfmt.Fprintln(w, \"123\\t12345\\t1234567\\t123456789\\t.\")\n\tfmt.Fprintln(w)\n\tw.Flush()\n\n}\n</pre> </div> </div> <h3 id=\"Writer.Write\">func (*Writer) <a href=\"https://golang.org/src/text/tabwriter/tabwriter.go?s=15046:15099#L483\">Write</a>  </h3> <pre data-language=\"go\">func (b *Writer) Write(buf []byte) (n int, err error)</pre> <p> Write writes buf to the writer b. The only errors returned are ones encountered while writing to the underlying output stream. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/text/tabwriter/\" class=\"_attribution-link\">https://golang.org/pkg/text/tabwriter/</a>\n  </p>\n</div>\n","testing/quick/index":"<h1>Package quick</h1>     <ul id=\"short-nav\">\n<li><code>import \"testing/quick\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package quick implements utility functions to help with black box testing. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Check\">func Check(f interface{}, config *Config) error</a></li>\n<li><a href=\"#CheckEqual\">func CheckEqual(f, g interface{}, config *Config) error</a></li>\n<li><a href=\"#Value\">func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool)</a></li>\n<li><a href=\"#CheckEqualError\">type CheckEqualError</a></li>\n<li> <a href=\"#CheckEqualError.Error\">func (s *CheckEqualError) Error() string</a>\n</li>\n<li><a href=\"#CheckError\">type CheckError</a></li>\n<li> <a href=\"#CheckError.Error\">func (s *CheckError) Error() string</a>\n</li>\n<li><a href=\"#Config\">type Config</a></li>\n<li><a href=\"#Generator\">type Generator</a></li>\n<li><a href=\"#SetupError\">type SetupError</a></li>\n<li> <a href=\"#SetupError.Error\">func (s SetupError) Error() string</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/testing/quick/quick.go\">quick.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Check\">func Check  </h2> <pre data-language=\"go\">func Check(f interface{}, config *Config) error</pre> <p> Check looks for an input to f, any function that returns bool, such that f returns false. It calls f repeatedly, with arbitrary values for each argument. If f returns false on a given input, Check returns that input as a *CheckError. For example: </p> <pre data-language=\"go\">func TestOddMultipleOfThree(t *testing.T) {\n\tf := func(x int) bool {\n\t\ty := OddMultipleOfThree(x)\n\t\treturn y%2 == 1 &amp;&amp; y%3 == 0\n\t}\n\tif err := quick.Check(f, nil); err != nil {\n\t\tt.Error(err)\n\t}\n}\n</pre> <h2 id=\"CheckEqual\">func CheckEqual  </h2> <pre data-language=\"go\">func CheckEqual(f, g interface{}, config *Config) error</pre> <p> CheckEqual looks for an input on which f and g return different results. It calls f and g repeatedly with arbitrary values for each argument. If f and g return different answers, CheckEqual returns a *CheckEqualError describing the input and the outputs. </p> <h2 id=\"Value\">func Value  </h2> <pre data-language=\"go\">func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool)</pre> <p> Value returns an arbitrary value of the given type. If the type implements the Generator interface, that will be used. Note: To create arbitrary values for structs, all the fields must be exported. </p> <h2 id=\"CheckEqualError\">type CheckEqualError  </h2> <pre data-language=\"go\">type CheckEqualError struct {\n        CheckError\n        Out1 []interface{}\n        Out2 []interface{}\n}</pre> <p> A CheckEqualError is the result CheckEqual finding an error. </p> <h3 id=\"CheckEqualError.Error\">func (*CheckEqualError) <a href=\"https://golang.org/src/testing/quick/quick.go?s=6690:6730#L227\">Error</a>  </h3> <pre data-language=\"go\">func (s *CheckEqualError) Error() string</pre> <h2 id=\"CheckError\">type CheckError  </h2> <pre data-language=\"go\">type CheckError struct {\n        Count int\n        In    []interface{}\n}</pre> <p> A CheckError is the result of Check finding an error. </p> <h3 id=\"CheckError.Error\">func (*CheckError) <a href=\"https://golang.org/src/testing/quick/quick.go?s=6428:6463#L216\">Error</a>  </h3> <pre data-language=\"go\">func (s *CheckError) Error() string</pre> <h2 id=\"Config\">type Config  </h2> <pre data-language=\"go\">type Config struct {\n        // MaxCount sets the maximum number of iterations. If zero,\n        // MaxCountScale is used.\n        MaxCount int\n        // MaxCountScale is a non-negative scale factor applied to the default\n        // maximum. If zero, the default is unchanged.\n        MaxCountScale float64\n        // If non-nil, rand is a source of random numbers. Otherwise a default\n        // pseudo-random source will be used.\n        Rand *rand.Rand\n        // If non-nil, the Values function generates a slice of arbitrary\n        // reflect.Values that are congruent with the arguments to the function\n        // being tested. Otherwise, the top-level Value function is used\n        // to generate them.\n        Values func([]reflect.Value, *rand.Rand)\n}</pre> <p> A Config structure contains options for running a test. </p> <h2 id=\"Generator\">type Generator  </h2> <pre data-language=\"go\">type Generator interface {\n        // Generate returns a random instance of the type on which it is a\n        // method using the size as a size hint.\n        Generate(rand *rand.Rand, size int) reflect.Value\n}</pre> <p> A Generator can generate random values of its own type. </p> <h2 id=\"SetupError\">type SetupError  </h2> <pre data-language=\"go\">type SetupError string</pre> <p> A SetupError is the result of an error in the way that check is being used, independent of the functions being tested. </p> <h3 id=\"SetupError.Error\">func (SetupError) <a href=\"https://golang.org/src/testing/quick/quick.go?s=6254:6288#L208\">Error</a>  </h3> <pre data-language=\"go\">func (s SetupError) Error() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/testing/quick/\" class=\"_attribution-link\">https://golang.org/pkg/testing/quick/</a>\n  </p>\n</div>\n","unicode/utf16/index":"<h1>Package utf16</h1>     <ul id=\"short-nav\">\n<li><code>import \"unicode/utf16\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package utf16 implements encoding and decoding of UTF-16 sequences. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Decode\">func Decode(s []uint16) []rune</a></li>\n<li><a href=\"#DecodeRune\">func DecodeRune(r1, r2 rune) rune</a></li>\n<li><a href=\"#Encode\">func Encode(s []rune) []uint16</a></li>\n<li><a href=\"#EncodeRune\">func EncodeRune(r rune) (r1, r2 rune)</a></li>\n<li><a href=\"#IsSurrogate\">func IsSurrogate(r rune) bool</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/unicode/utf16/utf16.go\">utf16.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Decode\">func Decode  </h2> <pre data-language=\"go\">func Decode(s []uint16) []rune</pre> <p> Decode returns the Unicode code point sequence represented by the UTF-16 encoding s. </p> <h2 id=\"DecodeRune\">func DecodeRune  </h2> <pre data-language=\"go\">func DecodeRune(r1, r2 rune) rune</pre> <p> DecodeRune returns the UTF-16 decoding of a surrogate pair. If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns the Unicode replacement code point U+FFFD. </p> <h2 id=\"Encode\">func Encode  </h2> <pre data-language=\"go\">func Encode(s []rune) []uint16</pre> <p> Encode returns the UTF-16 encoding of the Unicode code point sequence s. </p> <h2 id=\"EncodeRune\">func EncodeRune  </h2> <pre data-language=\"go\">func EncodeRune(r rune) (r1, r2 rune)</pre> <p> EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune. If the rune is not a valid Unicode code point or does not need encoding, EncodeRune returns U+FFFD, U+FFFD. </p> <h2 id=\"IsSurrogate\">func IsSurrogate  </h2> <pre data-language=\"go\">func IsSurrogate(r rune) bool</pre> <p> IsSurrogate reports whether the specified Unicode code point can appear in a surrogate pair. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/unicode/utf16/\" class=\"_attribution-link\">https://golang.org/pkg/unicode/utf16/</a>\n  </p>\n</div>\n","go/types/index":"<h1>Package types</h1>     <ul id=\"short-nav\">\n<li><code>import \"go/types\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package types declares the data types and implements the algorithms for type-checking of Go packages. Use Config.Check to invoke the type checker for a package. Alternatively, create a new type checked with NewChecker and invoke it incrementally by calling Checker.Files. </p> <p> Type-checking consists of several interdependent phases: </p> <p> Name resolution maps each identifier (ast.Ident) in the program to the language object (Object) it denotes. Use Info.{Defs,Uses,Implicits} for the results of name resolution. </p> <p> Constant folding computes the exact constant value (constant.Value) for every expression (ast.Expr) that is a compile-time constant. Use Info.Types[expr].Value for the results of constant folding. </p> <p> Type inference computes the type (Type) of every expression (ast.Expr) and checks for compliance with the language specification. Use Info.Types[expr].Type for the results of type inference. </p> <p> For a tutorial, see <a href=\"https://golang.org/s/types-tutorial\">https://golang.org/s/types-tutorial</a>. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#AssertableTo\">func AssertableTo(V *Interface, T Type) bool</a></li>\n<li><a href=\"#AssignableTo\">func AssignableTo(V, T Type) bool</a></li>\n<li><a href=\"#Comparable\">func Comparable(T Type) bool</a></li>\n<li><a href=\"#ConvertibleTo\">func ConvertibleTo(V, T Type) bool</a></li>\n<li><a href=\"#DefPredeclaredTestFuncs\">func DefPredeclaredTestFuncs()</a></li>\n<li><a href=\"#ExprString\">func ExprString(x ast.Expr) string</a></li>\n<li><a href=\"#Id\">func Id(pkg *Package, name string) string</a></li>\n<li><a href=\"#Identical\">func Identical(x, y Type) bool</a></li>\n<li><a href=\"#Implements\">func Implements(V Type, T *Interface) bool</a></li>\n<li><a href=\"#IsInterface\">func IsInterface(typ Type) bool</a></li>\n<li><a href=\"#ObjectString\">func ObjectString(obj Object, qf Qualifier) string</a></li>\n<li><a href=\"#SelectionString\">func SelectionString(s *Selection, qf Qualifier) string</a></li>\n<li><a href=\"#TypeString\">func TypeString(typ Type, qf Qualifier) string</a></li>\n<li><a href=\"#WriteExpr\">func WriteExpr(buf *bytes.Buffer, x ast.Expr)</a></li>\n<li><a href=\"#WriteSignature\">func WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier)</a></li>\n<li><a href=\"#WriteType\">func WriteType(buf *bytes.Buffer, typ Type, qf Qualifier)</a></li>\n<li><a href=\"#Array\">type Array</a></li>\n<li> <a href=\"#NewArray\">func NewArray(elem Type, len int64) *Array</a>\n</li>\n<li> <a href=\"#Array.Elem\">func (a *Array) Elem() Type</a>\n</li>\n<li> <a href=\"#Array.Len\">func (a *Array) Len() int64</a>\n</li>\n<li> <a href=\"#Array.String\">func (t *Array) String() string</a>\n</li>\n<li> <a href=\"#Array.Underlying\">func (t *Array) Underlying() Type</a>\n</li>\n<li><a href=\"#Basic\">type Basic</a></li>\n<li> <a href=\"#Basic.Info\">func (b *Basic) Info() BasicInfo</a>\n</li>\n<li> <a href=\"#Basic.Kind\">func (b *Basic) Kind() BasicKind</a>\n</li>\n<li> <a href=\"#Basic.Name\">func (b *Basic) Name() string</a>\n</li>\n<li> <a href=\"#Basic.String\">func (t *Basic) String() string</a>\n</li>\n<li> <a href=\"#Basic.Underlying\">func (t *Basic) Underlying() Type</a>\n</li>\n<li><a href=\"#BasicInfo\">type BasicInfo</a></li>\n<li><a href=\"#BasicKind\">type BasicKind</a></li>\n<li><a href=\"#Builtin\">type Builtin</a></li>\n<li> <a href=\"#Builtin.Exported\">func (obj *Builtin) Exported() bool</a>\n</li>\n<li> <a href=\"#Builtin.Id\">func (obj *Builtin) Id() string</a>\n</li>\n<li> <a href=\"#Builtin.Name\">func (obj *Builtin) Name() string</a>\n</li>\n<li> <a href=\"#Builtin.Parent\">func (obj *Builtin) Parent() *Scope</a>\n</li>\n<li> <a href=\"#Builtin.Pkg\">func (obj *Builtin) Pkg() *Package</a>\n</li>\n<li> <a href=\"#Builtin.Pos\">func (obj *Builtin) Pos() token.Pos</a>\n</li>\n<li> <a href=\"#Builtin.String\">func (obj *Builtin) String() string</a>\n</li>\n<li> <a href=\"#Builtin.Type\">func (obj *Builtin) Type() Type</a>\n</li>\n<li><a href=\"#Chan\">type Chan</a></li>\n<li> <a href=\"#NewChan\">func NewChan(dir ChanDir, elem Type) *Chan</a>\n</li>\n<li> <a href=\"#Chan.Dir\">func (c *Chan) Dir() ChanDir</a>\n</li>\n<li> <a href=\"#Chan.Elem\">func (c *Chan) Elem() Type</a>\n</li>\n<li> <a href=\"#Chan.String\">func (t *Chan) String() string</a>\n</li>\n<li> <a href=\"#Chan.Underlying\">func (t *Chan) Underlying() Type</a>\n</li>\n<li><a href=\"#ChanDir\">type ChanDir</a></li>\n<li><a href=\"#Checker\">type Checker</a></li>\n<li> <a href=\"#NewChecker\">func NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker</a>\n</li>\n<li> <a href=\"#Checker.Files\">func (check *Checker) Files(files []*ast.File) error</a>\n</li>\n<li><a href=\"#Config\">type Config</a></li>\n<li> <a href=\"#Config.Check\">func (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, info *Info) (*Package, error)</a>\n</li>\n<li><a href=\"#Const\">type Const</a></li>\n<li> <a href=\"#NewConst\">func NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const</a>\n</li>\n<li> <a href=\"#Const.Exported\">func (obj *Const) Exported() bool</a>\n</li>\n<li> <a href=\"#Const.Id\">func (obj *Const) Id() string</a>\n</li>\n<li> <a href=\"#Const.Name\">func (obj *Const) Name() string</a>\n</li>\n<li> <a href=\"#Const.Parent\">func (obj *Const) Parent() *Scope</a>\n</li>\n<li> <a href=\"#Const.Pkg\">func (obj *Const) Pkg() *Package</a>\n</li>\n<li> <a href=\"#Const.Pos\">func (obj *Const) Pos() token.Pos</a>\n</li>\n<li> <a href=\"#Const.String\">func (obj *Const) String() string</a>\n</li>\n<li> <a href=\"#Const.Type\">func (obj *Const) Type() Type</a>\n</li>\n<li> <a href=\"#Const.Val\">func (obj *Const) Val() constant.Value</a>\n</li>\n<li><a href=\"#Error\">type Error</a></li>\n<li> <a href=\"#Error.Error\">func (err Error) Error() string</a>\n</li>\n<li><a href=\"#Func\">type Func</a></li>\n<li> <a href=\"#MissingMethod\">func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)</a>\n</li>\n<li> <a href=\"#NewFunc\">func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func</a>\n</li>\n<li> <a href=\"#Func.Exported\">func (obj *Func) Exported() bool</a>\n</li>\n<li> <a href=\"#Func.FullName\">func (obj *Func) FullName() string</a>\n</li>\n<li> <a href=\"#Func.Id\">func (obj *Func) Id() string</a>\n</li>\n<li> <a href=\"#Func.Name\">func (obj *Func) Name() string</a>\n</li>\n<li> <a href=\"#Func.Parent\">func (obj *Func) Parent() *Scope</a>\n</li>\n<li> <a href=\"#Func.Pkg\">func (obj *Func) Pkg() *Package</a>\n</li>\n<li> <a href=\"#Func.Pos\">func (obj *Func) Pos() token.Pos</a>\n</li>\n<li> <a href=\"#Func.Scope\">func (obj *Func) Scope() *Scope</a>\n</li>\n<li> <a href=\"#Func.String\">func (obj *Func) String() string</a>\n</li>\n<li> <a href=\"#Func.Type\">func (obj *Func) Type() Type</a>\n</li>\n<li><a href=\"#ImportMode\">type ImportMode</a></li>\n<li><a href=\"#Importer\">type Importer</a></li>\n<li><a href=\"#ImporterFrom\">type ImporterFrom</a></li>\n<li><a href=\"#Info\">type Info</a></li>\n<li> <a href=\"#Info.ObjectOf\">func (info *Info) ObjectOf(id *ast.Ident) Object</a>\n</li>\n<li> <a href=\"#Info.TypeOf\">func (info *Info) TypeOf(e ast.Expr) Type</a>\n</li>\n<li><a href=\"#Initializer\">type Initializer</a></li>\n<li> <a href=\"#Initializer.String\">func (init *Initializer) String() string</a>\n</li>\n<li><a href=\"#Interface\">type Interface</a></li>\n<li> <a href=\"#NewInterface\">func NewInterface(methods []*Func, embeddeds []*Named) *Interface</a>\n</li>\n<li> <a href=\"#Interface.Complete\">func (t *Interface) Complete() *Interface</a>\n</li>\n<li> <a href=\"#Interface.Embedded\">func (t *Interface) Embedded(i int) *Named</a>\n</li>\n<li> <a href=\"#Interface.Empty\">func (t *Interface) Empty() bool</a>\n</li>\n<li> <a href=\"#Interface.ExplicitMethod\">func (t *Interface) ExplicitMethod(i int) *Func</a>\n</li>\n<li> <a href=\"#Interface.Method\">func (t *Interface) Method(i int) *Func</a>\n</li>\n<li> <a href=\"#Interface.NumEmbeddeds\">func (t *Interface) NumEmbeddeds() int</a>\n</li>\n<li> <a href=\"#Interface.NumExplicitMethods\">func (t *Interface) NumExplicitMethods() int</a>\n</li>\n<li> <a href=\"#Interface.NumMethods\">func (t *Interface) NumMethods() int</a>\n</li>\n<li> <a href=\"#Interface.String\">func (t *Interface) String() string</a>\n</li>\n<li> <a href=\"#Interface.Underlying\">func (t *Interface) Underlying() Type</a>\n</li>\n<li><a href=\"#Label\">type Label</a></li>\n<li> <a href=\"#NewLabel\">func NewLabel(pos token.Pos, pkg *Package, name string) *Label</a>\n</li>\n<li> <a href=\"#Label.Exported\">func (obj *Label) Exported() bool</a>\n</li>\n<li> <a href=\"#Label.Id\">func (obj *Label) Id() string</a>\n</li>\n<li> <a href=\"#Label.Name\">func (obj *Label) Name() string</a>\n</li>\n<li> <a href=\"#Label.Parent\">func (obj *Label) Parent() *Scope</a>\n</li>\n<li> <a href=\"#Label.Pkg\">func (obj *Label) Pkg() *Package</a>\n</li>\n<li> <a href=\"#Label.Pos\">func (obj *Label) Pos() token.Pos</a>\n</li>\n<li> <a href=\"#Label.String\">func (obj *Label) String() string</a>\n</li>\n<li> <a href=\"#Label.Type\">func (obj *Label) Type() Type</a>\n</li>\n<li><a href=\"#Map\">type Map</a></li>\n<li> <a href=\"#NewMap\">func NewMap(key, elem Type) *Map</a>\n</li>\n<li> <a href=\"#Map.Elem\">func (m *Map) Elem() Type</a>\n</li>\n<li> <a href=\"#Map.Key\">func (m *Map) Key() Type</a>\n</li>\n<li> <a href=\"#Map.String\">func (t *Map) String() string</a>\n</li>\n<li> <a href=\"#Map.Underlying\">func (t *Map) Underlying() Type</a>\n</li>\n<li><a href=\"#MethodSet\">type MethodSet</a></li>\n<li> <a href=\"#NewMethodSet\">func NewMethodSet(T Type) *MethodSet</a>\n</li>\n<li> <a href=\"#MethodSet.At\">func (s *MethodSet) At(i int) *Selection</a>\n</li>\n<li> <a href=\"#MethodSet.Len\">func (s *MethodSet) Len() int</a>\n</li>\n<li> <a href=\"#MethodSet.Lookup\">func (s *MethodSet) Lookup(pkg *Package, name string) *Selection</a>\n</li>\n<li> <a href=\"#MethodSet.String\">func (s *MethodSet) String() string</a>\n</li>\n<li><a href=\"#Named\">type Named</a></li>\n<li> <a href=\"#NewNamed\">func NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named</a>\n</li>\n<li> <a href=\"#Named.AddMethod\">func (t *Named) AddMethod(m *Func)</a>\n</li>\n<li> <a href=\"#Named.Method\">func (t *Named) Method(i int) *Func</a>\n</li>\n<li> <a href=\"#Named.NumMethods\">func (t *Named) NumMethods() int</a>\n</li>\n<li> <a href=\"#Named.Obj\">func (t *Named) Obj() *TypeName</a>\n</li>\n<li> <a href=\"#Named.SetUnderlying\">func (t *Named) SetUnderlying(underlying Type)</a>\n</li>\n<li> <a href=\"#Named.String\">func (t *Named) String() string</a>\n</li>\n<li> <a href=\"#Named.Underlying\">func (t *Named) Underlying() Type</a>\n</li>\n<li><a href=\"#Nil\">type Nil</a></li>\n<li> <a href=\"#Nil.Exported\">func (obj *Nil) Exported() bool</a>\n</li>\n<li> <a href=\"#Nil.Id\">func (obj *Nil) Id() string</a>\n</li>\n<li> <a href=\"#Nil.Name\">func (obj *Nil) Name() string</a>\n</li>\n<li> <a href=\"#Nil.Parent\">func (obj *Nil) Parent() *Scope</a>\n</li>\n<li> <a href=\"#Nil.Pkg\">func (obj *Nil) Pkg() *Package</a>\n</li>\n<li> <a href=\"#Nil.Pos\">func (obj *Nil) Pos() token.Pos</a>\n</li>\n<li> <a href=\"#Nil.String\">func (obj *Nil) String() string</a>\n</li>\n<li> <a href=\"#Nil.Type\">func (obj *Nil) Type() Type</a>\n</li>\n<li><a href=\"#Object\">type Object</a></li>\n<li> <a href=\"#LookupFieldOrMethod\">func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)</a>\n</li>\n<li><a href=\"#Package\">type Package</a></li>\n<li> <a href=\"#NewPackage\">func NewPackage(path, name string) *Package</a>\n</li>\n<li> <a href=\"#Package.Complete\">func (pkg *Package) Complete() bool</a>\n</li>\n<li> <a href=\"#Package.Imports\">func (pkg *Package) Imports() []*Package</a>\n</li>\n<li> <a href=\"#Package.MarkComplete\">func (pkg *Package) MarkComplete()</a>\n</li>\n<li> <a href=\"#Package.Name\">func (pkg *Package) Name() string</a>\n</li>\n<li> <a href=\"#Package.Path\">func (pkg *Package) Path() string</a>\n</li>\n<li> <a href=\"#Package.Scope\">func (pkg *Package) Scope() *Scope</a>\n</li>\n<li> <a href=\"#Package.SetImports\">func (pkg *Package) SetImports(list []*Package)</a>\n</li>\n<li> <a href=\"#Package.SetName\">func (pkg *Package) SetName(name string)</a>\n</li>\n<li> <a href=\"#Package.String\">func (pkg *Package) String() string</a>\n</li>\n<li><a href=\"#PkgName\">type PkgName</a></li>\n<li> <a href=\"#NewPkgName\">func NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName</a>\n</li>\n<li> <a href=\"#PkgName.Exported\">func (obj *PkgName) Exported() bool</a>\n</li>\n<li> <a href=\"#PkgName.Id\">func (obj *PkgName) Id() string</a>\n</li>\n<li> <a href=\"#PkgName.Imported\">func (obj *PkgName) Imported() *Package</a>\n</li>\n<li> <a href=\"#PkgName.Name\">func (obj *PkgName) Name() string</a>\n</li>\n<li> <a href=\"#PkgName.Parent\">func (obj *PkgName) Parent() *Scope</a>\n</li>\n<li> <a href=\"#PkgName.Pkg\">func (obj *PkgName) Pkg() *Package</a>\n</li>\n<li> <a href=\"#PkgName.Pos\">func (obj *PkgName) Pos() token.Pos</a>\n</li>\n<li> <a href=\"#PkgName.String\">func (obj *PkgName) String() string</a>\n</li>\n<li> <a href=\"#PkgName.Type\">func (obj *PkgName) Type() Type</a>\n</li>\n<li><a href=\"#Pointer\">type Pointer</a></li>\n<li> <a href=\"#NewPointer\">func NewPointer(elem Type) *Pointer</a>\n</li>\n<li> <a href=\"#Pointer.Elem\">func (p *Pointer) Elem() Type</a>\n</li>\n<li> <a href=\"#Pointer.String\">func (t *Pointer) String() string</a>\n</li>\n<li> <a href=\"#Pointer.Underlying\">func (t *Pointer) Underlying() Type</a>\n</li>\n<li><a href=\"#Qualifier\">type Qualifier</a></li>\n<li> <a href=\"#RelativeTo\">func RelativeTo(pkg *Package) Qualifier</a>\n</li>\n<li><a href=\"#Scope\">type Scope</a></li>\n<li> <a href=\"#NewScope\">func NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope</a>\n</li>\n<li> <a href=\"#Scope.Child\">func (s *Scope) Child(i int) *Scope</a>\n</li>\n<li> <a href=\"#Scope.Contains\">func (s *Scope) Contains(pos token.Pos) bool</a>\n</li>\n<li> <a href=\"#Scope.End\">func (s *Scope) End() token.Pos</a>\n</li>\n<li> <a href=\"#Scope.Innermost\">func (s *Scope) Innermost(pos token.Pos) *Scope</a>\n</li>\n<li> <a href=\"#Scope.Insert\">func (s *Scope) Insert(obj Object) Object</a>\n</li>\n<li> <a href=\"#Scope.Len\">func (s *Scope) Len() int</a>\n</li>\n<li> <a href=\"#Scope.Lookup\">func (s *Scope) Lookup(name string) Object</a>\n</li>\n<li> <a href=\"#Scope.LookupParent\">func (s *Scope) LookupParent(name string, pos token.Pos) (*Scope, Object)</a>\n</li>\n<li> <a href=\"#Scope.Names\">func (s *Scope) Names() []string</a>\n</li>\n<li> <a href=\"#Scope.NumChildren\">func (s *Scope) NumChildren() int</a>\n</li>\n<li> <a href=\"#Scope.Parent\">func (s *Scope) Parent() *Scope</a>\n</li>\n<li> <a href=\"#Scope.Pos\">func (s *Scope) Pos() token.Pos</a>\n</li>\n<li> <a href=\"#Scope.String\">func (s *Scope) String() string</a>\n</li>\n<li> <a href=\"#Scope.WriteTo\">func (s *Scope) WriteTo(w io.Writer, n int, recurse bool)</a>\n</li>\n<li><a href=\"#Selection\">type Selection</a></li>\n<li> <a href=\"#Selection.Index\">func (s *Selection) Index() []int</a>\n</li>\n<li> <a href=\"#Selection.Indirect\">func (s *Selection) Indirect() bool</a>\n</li>\n<li> <a href=\"#Selection.Kind\">func (s *Selection) Kind() SelectionKind</a>\n</li>\n<li> <a href=\"#Selection.Obj\">func (s *Selection) Obj() Object</a>\n</li>\n<li> <a href=\"#Selection.Recv\">func (s *Selection) Recv() Type</a>\n</li>\n<li> <a href=\"#Selection.String\">func (s *Selection) String() string</a>\n</li>\n<li> <a href=\"#Selection.Type\">func (s *Selection) Type() Type</a>\n</li>\n<li><a href=\"#SelectionKind\">type SelectionKind</a></li>\n<li><a href=\"#Signature\">type Signature</a></li>\n<li> <a href=\"#NewSignature\">func NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature</a>\n</li>\n<li> <a href=\"#Signature.Params\">func (s *Signature) Params() *Tuple</a>\n</li>\n<li> <a href=\"#Signature.Recv\">func (s *Signature) Recv() *Var</a>\n</li>\n<li> <a href=\"#Signature.Results\">func (s *Signature) Results() *Tuple</a>\n</li>\n<li> <a href=\"#Signature.String\">func (t *Signature) String() string</a>\n</li>\n<li> <a href=\"#Signature.Underlying\">func (t *Signature) Underlying() Type</a>\n</li>\n<li> <a href=\"#Signature.Variadic\">func (s *Signature) Variadic() bool</a>\n</li>\n<li><a href=\"#Sizes\">type Sizes</a></li>\n<li><a href=\"#Slice\">type Slice</a></li>\n<li> <a href=\"#NewSlice\">func NewSlice(elem Type) *Slice</a>\n</li>\n<li> <a href=\"#Slice.Elem\">func (s *Slice) Elem() Type</a>\n</li>\n<li> <a href=\"#Slice.String\">func (t *Slice) String() string</a>\n</li>\n<li> <a href=\"#Slice.Underlying\">func (t *Slice) Underlying() Type</a>\n</li>\n<li><a href=\"#StdSizes\">type StdSizes</a></li>\n<li> <a href=\"#StdSizes.Alignof\">func (s *StdSizes) Alignof(T Type) int64</a>\n</li>\n<li> <a href=\"#StdSizes.Offsetsof\">func (s *StdSizes) Offsetsof(fields []*Var) []int64</a>\n</li>\n<li> <a href=\"#StdSizes.Sizeof\">func (s *StdSizes) Sizeof(T Type) int64</a>\n</li>\n<li><a href=\"#Struct\">type Struct</a></li>\n<li> <a href=\"#NewStruct\">func NewStruct(fields []*Var, tags []string) *Struct</a>\n</li>\n<li> <a href=\"#Struct.Field\">func (s *Struct) Field(i int) *Var</a>\n</li>\n<li> <a href=\"#Struct.NumFields\">func (s *Struct) NumFields() int</a>\n</li>\n<li> <a href=\"#Struct.String\">func (t *Struct) String() string</a>\n</li>\n<li> <a href=\"#Struct.Tag\">func (s *Struct) Tag(i int) string</a>\n</li>\n<li> <a href=\"#Struct.Underlying\">func (t *Struct) Underlying() Type</a>\n</li>\n<li><a href=\"#Tuple\">type Tuple</a></li>\n<li> <a href=\"#NewTuple\">func NewTuple(x ...*Var) *Tuple</a>\n</li>\n<li> <a href=\"#Tuple.At\">func (t *Tuple) At(i int) *Var</a>\n</li>\n<li> <a href=\"#Tuple.Len\">func (t *Tuple) Len() int</a>\n</li>\n<li> <a href=\"#Tuple.String\">func (t *Tuple) String() string</a>\n</li>\n<li> <a href=\"#Tuple.Underlying\">func (t *Tuple) Underlying() Type</a>\n</li>\n<li><a href=\"#Type\">type Type</a></li>\n<li><a href=\"#TypeAndValue\">type TypeAndValue</a></li>\n<li> <a href=\"#Eval\">func Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (TypeAndValue, error)</a>\n</li>\n<li> <a href=\"#TypeAndValue.Addressable\">func (tv TypeAndValue) Addressable() bool</a>\n</li>\n<li> <a href=\"#TypeAndValue.Assignable\">func (tv TypeAndValue) Assignable() bool</a>\n</li>\n<li> <a href=\"#TypeAndValue.HasOk\">func (tv TypeAndValue) HasOk() bool</a>\n</li>\n<li> <a href=\"#TypeAndValue.IsBuiltin\">func (tv TypeAndValue) IsBuiltin() bool</a>\n</li>\n<li> <a href=\"#TypeAndValue.IsNil\">func (tv TypeAndValue) IsNil() bool</a>\n</li>\n<li> <a href=\"#TypeAndValue.IsType\">func (tv TypeAndValue) IsType() bool</a>\n</li>\n<li> <a href=\"#TypeAndValue.IsValue\">func (tv TypeAndValue) IsValue() bool</a>\n</li>\n<li> <a href=\"#TypeAndValue.IsVoid\">func (tv TypeAndValue) IsVoid() bool</a>\n</li>\n<li><a href=\"#TypeName\">type TypeName</a></li>\n<li> <a href=\"#NewTypeName\">func NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName</a>\n</li>\n<li> <a href=\"#TypeName.Exported\">func (obj *TypeName) Exported() bool</a>\n</li>\n<li> <a href=\"#TypeName.Id\">func (obj *TypeName) Id() string</a>\n</li>\n<li> <a href=\"#TypeName.Name\">func (obj *TypeName) Name() string</a>\n</li>\n<li> <a href=\"#TypeName.Parent\">func (obj *TypeName) Parent() *Scope</a>\n</li>\n<li> <a href=\"#TypeName.Pkg\">func (obj *TypeName) Pkg() *Package</a>\n</li>\n<li> <a href=\"#TypeName.Pos\">func (obj *TypeName) Pos() token.Pos</a>\n</li>\n<li> <a href=\"#TypeName.String\">func (obj *TypeName) String() string</a>\n</li>\n<li> <a href=\"#TypeName.Type\">func (obj *TypeName) Type() Type</a>\n</li>\n<li><a href=\"#Var\">type Var</a></li>\n<li> <a href=\"#NewField\">func NewField(pos token.Pos, pkg *Package, name string, typ Type, anonymous bool) *Var</a>\n</li>\n<li> <a href=\"#NewParam\">func NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var</a>\n</li>\n<li> <a href=\"#NewVar\">func NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var</a>\n</li>\n<li> <a href=\"#Var.Anonymous\">func (obj *Var) Anonymous() bool</a>\n</li>\n<li> <a href=\"#Var.Exported\">func (obj *Var) Exported() bool</a>\n</li>\n<li> <a href=\"#Var.Id\">func (obj *Var) Id() string</a>\n</li>\n<li> <a href=\"#Var.IsField\">func (obj *Var) IsField() bool</a>\n</li>\n<li> <a href=\"#Var.Name\">func (obj *Var) Name() string</a>\n</li>\n<li> <a href=\"#Var.Parent\">func (obj *Var) Parent() *Scope</a>\n</li>\n<li> <a href=\"#Var.Pkg\">func (obj *Var) Pkg() *Package</a>\n</li>\n<li> <a href=\"#Var.Pos\">func (obj *Var) Pos() token.Pos</a>\n</li>\n<li> <a href=\"#Var.String\">func (obj *Var) String() string</a>\n</li>\n<li> <a href=\"#Var.Type\">func (obj *Var) Type() Type</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Info\">Info</a></dd> <dd><a class=\"exampleLink\" href=\"#example_MethodSet\">MethodSet</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Scope\">Scope</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/go/types/api.go\">api.go</a> <a href=\"https://golang.org/src/go/types/assignments.go\">assignments.go</a> <a href=\"https://golang.org/src/go/types/builtins.go\">builtins.go</a> <a href=\"https://golang.org/src/go/types/call.go\">call.go</a> <a href=\"https://golang.org/src/go/types/check.go\">check.go</a> <a href=\"https://golang.org/src/go/types/conversions.go\">conversions.go</a> <a href=\"https://golang.org/src/go/types/decl.go\">decl.go</a> <a href=\"https://golang.org/src/go/types/errors.go\">errors.go</a> <a href=\"https://golang.org/src/go/types/eval.go\">eval.go</a> <a href=\"https://golang.org/src/go/types/expr.go\">expr.go</a> <a href=\"https://golang.org/src/go/types/exprstring.go\">exprstring.go</a> <a href=\"https://golang.org/src/go/types/initorder.go\">initorder.go</a> <a href=\"https://golang.org/src/go/types/labels.go\">labels.go</a> <a href=\"https://golang.org/src/go/types/lookup.go\">lookup.go</a> <a href=\"https://golang.org/src/go/types/methodset.go\">methodset.go</a> <a href=\"https://golang.org/src/go/types/object.go\">object.go</a> <a href=\"https://golang.org/src/go/types/objset.go\">objset.go</a> <a href=\"https://golang.org/src/go/types/operand.go\">operand.go</a> <a href=\"https://golang.org/src/go/types/ordering.go\">ordering.go</a> <a href=\"https://golang.org/src/go/types/package.go\">package.go</a> <a href=\"https://golang.org/src/go/types/predicates.go\">predicates.go</a> <a href=\"https://golang.org/src/go/types/resolver.go\">resolver.go</a> <a href=\"https://golang.org/src/go/types/return.go\">return.go</a> <a href=\"https://golang.org/src/go/types/scope.go\">scope.go</a> <a href=\"https://golang.org/src/go/types/selection.go\">selection.go</a> <a href=\"https://golang.org/src/go/types/sizes.go\">sizes.go</a> <a href=\"https://golang.org/src/go/types/stmt.go\">stmt.go</a> <a href=\"https://golang.org/src/go/types/type.go\">type.go</a> <a href=\"https://golang.org/src/go/types/typestring.go\">typestring.go</a> <a href=\"https://golang.org/src/go/types/typexpr.go\">typexpr.go</a> <a href=\"https://golang.org/src/go/types/universe.go\">universe.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        Universe *Scope\n        Unsafe   *Package\n)</pre> <pre data-language=\"go\">var Typ = []*Basic{\n        Invalid: {Invalid, 0, \"invalid type\"},\n\n        Bool:          {Bool, IsBoolean, \"bool\"},\n        Int:           {Int, IsInteger, \"int\"},\n        Int8:          {Int8, IsInteger, \"int8\"},\n        Int16:         {Int16, IsInteger, \"int16\"},\n        Int32:         {Int32, IsInteger, \"int32\"},\n        Int64:         {Int64, IsInteger, \"int64\"},\n        Uint:          {Uint, IsInteger | IsUnsigned, \"uint\"},\n        Uint8:         {Uint8, IsInteger | IsUnsigned, \"uint8\"},\n        Uint16:        {Uint16, IsInteger | IsUnsigned, \"uint16\"},\n        Uint32:        {Uint32, IsInteger | IsUnsigned, \"uint32\"},\n        Uint64:        {Uint64, IsInteger | IsUnsigned, \"uint64\"},\n        Uintptr:       {Uintptr, IsInteger | IsUnsigned, \"uintptr\"},\n        Float32:       {Float32, IsFloat, \"float32\"},\n        Float64:       {Float64, IsFloat, \"float64\"},\n        Complex64:     {Complex64, IsComplex, \"complex64\"},\n        Complex128:    {Complex128, IsComplex, \"complex128\"},\n        String:        {String, IsString, \"string\"},\n        UnsafePointer: {UnsafePointer, 0, \"Pointer\"},\n\n        UntypedBool:    {UntypedBool, IsBoolean | IsUntyped, \"untyped bool\"},\n        UntypedInt:     {UntypedInt, IsInteger | IsUntyped, \"untyped int\"},\n        UntypedRune:    {UntypedRune, IsInteger | IsUntyped, \"untyped rune\"},\n        UntypedFloat:   {UntypedFloat, IsFloat | IsUntyped, \"untyped float\"},\n        UntypedComplex: {UntypedComplex, IsComplex | IsUntyped, \"untyped complex\"},\n        UntypedString:  {UntypedString, IsString | IsUntyped, \"untyped string\"},\n        UntypedNil:     {UntypedNil, IsUntyped, \"untyped nil\"},\n}</pre> <h2 id=\"AssertableTo\">func AssertableTo  </h2> <pre data-language=\"go\">func AssertableTo(V *Interface, T Type) bool</pre> <p> AssertableTo reports whether a value of type V can be asserted to have type T. </p> <h2 id=\"AssignableTo\">func AssignableTo  </h2> <pre data-language=\"go\">func AssignableTo(V, T Type) bool</pre> <p> AssignableTo reports whether a value of type V is assignable to a variable of type T. </p> <h2 id=\"Comparable\">func Comparable  </h2> <pre data-language=\"go\">func Comparable(T Type) bool</pre> <p> Comparable reports whether values of type T are comparable. </p> <h2 id=\"ConvertibleTo\">func ConvertibleTo  </h2> <pre data-language=\"go\">func ConvertibleTo(V, T Type) bool</pre> <p> ConvertibleTo reports whether a value of type V is convertible to a value of type T. </p> <h2 id=\"DefPredeclaredTestFuncs\">func DefPredeclaredTestFuncs  </h2> <pre data-language=\"go\">func DefPredeclaredTestFuncs()</pre> <p> DefPredeclaredTestFuncs defines the assert and trace built-ins. These built-ins are intended for debugging and testing of this package only. </p> <h2 id=\"ExprString\">func ExprString  </h2> <pre data-language=\"go\">func ExprString(x ast.Expr) string</pre> <p> ExprString returns the (possibly simplified) string representation for x. </p> <h2 id=\"Id\">func Id  </h2> <pre data-language=\"go\">func Id(pkg *Package, name string) string</pre> <p> Id returns name if it is exported, otherwise it returns the name qualified with the package path. </p> <h2 id=\"Identical\">func Identical  </h2> <pre data-language=\"go\">func Identical(x, y Type) bool</pre> <p> Identical reports whether x and y are identical. </p> <h2 id=\"Implements\">func Implements  </h2> <pre data-language=\"go\">func Implements(V Type, T *Interface) bool</pre> <p> Implements reports whether type V implements interface T. </p> <h2 id=\"IsInterface\">func IsInterface  </h2> <pre data-language=\"go\">func IsInterface(typ Type) bool</pre> <p> IsInterface reports whether typ is an interface type. </p> <h2 id=\"ObjectString\">func ObjectString  </h2> <pre data-language=\"go\">func ObjectString(obj Object, qf Qualifier) string</pre> <p> ObjectString returns the string form of obj. The Qualifier controls the printing of package-level objects, and may be nil. </p> <h2 id=\"SelectionString\">func SelectionString  </h2> <pre data-language=\"go\">func SelectionString(s *Selection, qf Qualifier) string</pre> <p> SelectionString returns the string form of s. The Qualifier controls the printing of package-level objects, and may be nil. </p> <p> Examples: </p> <pre data-language=\"go\">\"field (T) f int\"\n\"method (T) f(X) Y\"\n\"method expr (T) f(X) Y\"\n</pre> <h2 id=\"TypeString\">func TypeString  </h2> <pre data-language=\"go\">func TypeString(typ Type, qf Qualifier) string</pre> <p> TypeString returns the string representation of typ. The Qualifier controls the printing of package-level objects, and may be nil. </p> <h2 id=\"WriteExpr\">func WriteExpr  </h2> <pre data-language=\"go\">func WriteExpr(buf *bytes.Buffer, x ast.Expr)</pre> <p> WriteExpr writes the (possibly simplified) string representation for x to buf. </p> <h2 id=\"WriteSignature\">func WriteSignature  </h2> <pre data-language=\"go\">func WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier)</pre> <p> WriteSignature writes the representation of the signature sig to buf, without a leading \"func\" keyword. The Qualifier controls the printing of package-level objects, and may be nil. </p> <h2 id=\"WriteType\">func WriteType  </h2> <pre data-language=\"go\">func WriteType(buf *bytes.Buffer, typ Type, qf Qualifier)</pre> <p> WriteType writes the string representation of typ to buf. The Qualifier controls the printing of package-level objects, and may be nil. </p> <h2 id=\"Array\">type Array  </h2> <pre data-language=\"go\">type Array struct {\n        // contains filtered or unexported fields\n}</pre> <p> An Array represents an array type. </p> <h3 id=\"NewArray\">func <a href=\"https://golang.org/src/go/types/type.go?s=1844:1886#L93\">NewArray</a>  </h3> <pre data-language=\"go\">func NewArray(elem Type, len int64) *Array</pre> <p> NewArray returns a new array type for the given element type and length. </p> <h3 id=\"Array.Elem\">func (*Array) <a href=\"https://golang.org/src/go/types/type.go?s=2042:2069#L99\">Elem</a>  </h3> <pre data-language=\"go\">func (a *Array) Elem() Type</pre> <p> Elem returns element type of array a. </p> <h3 id=\"Array.Len\">func (*Array) <a href=\"https://golang.org/src/go/types/type.go?s=1955:1982#L96\">Len</a>  </h3> <pre data-language=\"go\">func (a *Array) Len() int64</pre> <p> Len returns the length of array a. </p> <h3 id=\"Array.String\">func (*Array) <a href=\"https://golang.org/src/go/types/type.go?s=13552:13583#L436\">String</a>  </h3> <pre data-language=\"go\">func (t *Array) String() string</pre> <h3 id=\"Array.Underlying\">func (*Array) <a href=\"https://golang.org/src/go/types/type.go?s=12964:12997#L424\">Underlying</a>  </h3> <pre data-language=\"go\">func (t *Array) Underlying() Type</pre> <h2 id=\"Basic\">type Basic  </h2> <pre data-language=\"go\">type Basic struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Basic represents a basic type. </p> <h3 id=\"Basic.Info\">func (*Basic) <a href=\"https://golang.org/src/go/types/type.go?s=1541:1573#L81\">Info</a>  </h3> <pre data-language=\"go\">func (b *Basic) Info() BasicInfo</pre> <p> Info returns information about properties of basic type b. </p> <h3 id=\"Basic.Kind\">func (*Basic) <a href=\"https://golang.org/src/go/types/type.go?s=1427:1459#L78\">Kind</a>  </h3> <pre data-language=\"go\">func (b *Basic) Kind() BasicKind</pre> <p> Kind returns the kind of basic type b. </p> <h3 id=\"Basic.Name\">func (*Basic) <a href=\"https://golang.org/src/go/types/type.go?s=1635:1664#L84\">Name</a>  </h3> <pre data-language=\"go\">func (b *Basic) Name() string</pre> <p> Name returns the name of basic type b. </p> <h3 id=\"Basic.String\">func (*Basic) <a href=\"https://golang.org/src/go/types/type.go?s=13486:13517#L435\">String</a>  </h3> <pre data-language=\"go\">func (t *Basic) String() string</pre> <h3 id=\"Basic.Underlying\">func (*Basic) <a href=\"https://golang.org/src/go/types/type.go?s=12913:12946#L423\">Underlying</a>  </h3> <pre data-language=\"go\">func (t *Basic) Underlying() Type</pre> <h2 id=\"BasicInfo\">type BasicInfo  </h2> <pre data-language=\"go\">type BasicInfo int</pre> <p> BasicInfo is a set of flags describing properties of a basic type. </p> <pre data-language=\"go\">const (\n        IsBoolean BasicInfo = 1 &lt;&lt; iota\n        IsInteger\n        IsUnsigned\n        IsFloat\n        IsComplex\n        IsString\n        IsUntyped\n\n        IsOrdered   = IsInteger | IsFloat | IsString\n        IsNumeric   = IsInteger | IsFloat | IsComplex\n        IsConstType = IsBoolean | IsNumeric | IsString\n)</pre> <p> Properties of basic types. </p> <h2 id=\"BasicKind\">type BasicKind  </h2> <pre data-language=\"go\">type BasicKind int</pre> <p> BasicKind describes the kind of basic type. </p> <pre data-language=\"go\">const (\n        Invalid BasicKind = iota // type is invalid\n\n        // predeclared types\n        Bool\n        Int\n        Int8\n        Int16\n        Int32\n        Int64\n        Uint\n        Uint8\n        Uint16\n        Uint32\n        Uint64\n        Uintptr\n        Float32\n        Float64\n        Complex64\n        Complex128\n        String\n        UnsafePointer\n\n        // types for untyped values\n        UntypedBool\n        UntypedInt\n        UntypedRune\n        UntypedFloat\n        UntypedComplex\n        UntypedString\n        UntypedNil\n\n        // aliases\n        Byte = Uint8\n        Rune = Int32\n)</pre> <h2 id=\"Builtin\">type Builtin  </h2> <pre data-language=\"go\">type Builtin struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Builtin represents a built-in function. Builtins don't have a valid type. </p> <h3 id=\"Builtin.Exported\">func (*Builtin) <a href=\"https://golang.org/src/go/types/object.go?s=2973:3007#L86\">Exported</a>  </h3> <pre data-language=\"go\">func (obj *Builtin) Exported() bool</pre> <h3 id=\"Builtin.Id\">func (*Builtin) <a href=\"https://golang.org/src/go/types/object.go?s=3049:3079#L87\">Id</a>  </h3> <pre data-language=\"go\">func (obj *Builtin) Id() string</pre> <h3 id=\"Builtin.Name\">func (*Builtin) <a href=\"https://golang.org/src/go/types/object.go?s=2854:2886#L84\">Name</a>  </h3> <pre data-language=\"go\">func (obj *Builtin) Name() string</pre> <h3 id=\"Builtin.Parent\">func (*Builtin) <a href=\"https://golang.org/src/go/types/object.go?s=2674:2708#L81\">Parent</a>  </h3> <pre data-language=\"go\">func (obj *Builtin) Parent() *Scope</pre> <h3 id=\"Builtin.Pkg\">func (*Builtin) <a href=\"https://golang.org/src/go/types/object.go?s=2795:2828#L83\">Pkg</a>  </h3> <pre data-language=\"go\">func (obj *Builtin) Pkg() *Package</pre> <h3 id=\"Builtin.Pos\">func (*Builtin) <a href=\"https://golang.org/src/go/types/object.go?s=2736:2770#L82\">Pos</a>  </h3> <pre data-language=\"go\">func (obj *Builtin) Pos() token.Pos</pre> <h3 id=\"Builtin.String\">func (*Builtin) <a href=\"https://golang.org/src/go/types/object.go?s=9704:9739#L326\">String</a>  </h3> <pre data-language=\"go\">func (obj *Builtin) String() string</pre> <h3 id=\"Builtin.Type\">func (*Builtin) <a href=\"https://golang.org/src/go/types/object.go?s=2914:2944#L85\">Type</a>  </h3> <pre data-language=\"go\">func (obj *Builtin) Type() Type</pre> <h2 id=\"Chan\">type Chan  </h2> <pre data-language=\"go\">type Chan struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Chan represents a channel type. </p> <h3 id=\"NewChan\">func <a href=\"https://golang.org/src/go/types/type.go?s=10760:10802#L362\">NewChan</a>  </h3> <pre data-language=\"go\">func NewChan(dir ChanDir, elem Type) *Chan</pre> <p> NewChan returns a new channel type for the given direction and element type. </p> <h3 id=\"Chan.Dir\">func (*Chan) <a href=\"https://golang.org/src/go/types/type.go?s=10876:10904#L367\">Dir</a>  </h3> <pre data-language=\"go\">func (c *Chan) Dir() ChanDir</pre> <p> Dir returns the direction of channel c. </p> <h3 id=\"Chan.Elem\">func (*Chan) <a href=\"https://golang.org/src/go/types/type.go?s=10970:10996#L370\">Elem</a>  </h3> <pre data-language=\"go\">func (c *Chan) Elem() Type</pre> <p> Elem returns the element type of channel c. </p> <h3 id=\"Chan.String\">func (*Chan) <a href=\"https://golang.org/src/go/types/type.go?s=14080:14110#L444\">String</a>  </h3> <pre data-language=\"go\">func (t *Chan) String() string</pre> <h3 id=\"Chan.Underlying\">func (*Chan) <a href=\"https://golang.org/src/go/types/type.go?s=13372:13404#L432\">Underlying</a>  </h3> <pre data-language=\"go\">func (t *Chan) Underlying() Type</pre> <h2 id=\"ChanDir\">type ChanDir  </h2> <pre data-language=\"go\">type ChanDir int</pre> <p> A ChanDir value indicates a channel direction. </p> <pre data-language=\"go\">const (\n        SendRecv ChanDir = iota\n        SendOnly\n        RecvOnly\n)</pre> <p> The direction of a channel is indicated by one of these constants. </p> <h2 id=\"Checker\">type Checker  </h2> <pre data-language=\"go\">type Checker struct {\n        *Info\n        // contains filtered or unexported fields\n}</pre> <p> A Checker maintains the state of the type checker. It must be created with NewChecker. </p> <h3 id=\"NewChecker\">func <a href=\"https://golang.org/src/go/types/check.go?s=5077:5162#L138\">NewChecker</a>  </h3> <pre data-language=\"go\">func NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker</pre> <p> NewChecker returns a new Checker instance for a given package. Package files may be added incrementally via checker.Files. </p> <h3 id=\"Checker.Files\">func (*Checker) <a href=\"https://golang.org/src/go/types/check.go?s=6655:6707#L208\">Files</a>  </h3> <pre data-language=\"go\">func (check *Checker) Files(files []*ast.File) error</pre> <p> Files checks the provided files as part of the checker's package. </p> <h2 id=\"Config\">type Config  </h2> <pre data-language=\"go\">type Config struct {\n        // If IgnoreFuncBodies is set, function bodies are not\n        // type-checked.\n        IgnoreFuncBodies bool\n\n        // If FakeImportC is set, `import \"C\"` (for packages requiring Cgo)\n        // declares an empty \"C\" package and errors are omitted for qualified\n        // identifiers referring to package C (which won't find an object).\n        // This feature is intended for the standard library cmd/api tool.\n        //\n        // Caution: Effects may be unpredictable due to follow-up errors.\n        //          Do not use casually!\n        FakeImportC bool\n\n        // If Error != nil, it is called with each error found\n        // during type checking; err has dynamic type Error.\n        // Secondary errors (for instance, to enumerate all types\n        // involved in an invalid recursive type declaration) have\n        // error strings that start with a '\\t' character.\n        // If Error == nil, type-checking stops with the first\n        // error found.\n        Error func(err error)\n\n        // An importer is used to import packages referred to from\n        // import declarations.\n        // If the installed importer implements ImporterFrom, the type\n        // checker calls ImportFrom instead of Import.\n        // The type checker reports an error if an importer is needed\n        // but none was installed.\n        Importer Importer\n\n        // If Sizes != nil, it provides the sizing functions for package unsafe.\n        // Otherwise &amp;StdSizes{WordSize: 8, MaxAlign: 8} is used instead.\n        Sizes Sizes\n\n        // If DisableUnusedImportCheck is set, packages are not checked\n        // for unused imports.\n        DisableUnusedImportCheck bool\n}</pre> <p> A Config specifies the configuration for type checking. The zero value for Config is a ready-to-use default configuration. </p> <h3 id=\"Config.Check\">func (*Config) <a href=\"https://golang.org/src/go/types/api.go?s=12156:12264#L332\">Check</a>  </h3> <pre data-language=\"go\">func (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, info *Info) (*Package, error)</pre> <p> Check type-checks a package and returns the resulting package object and the first error if any. Additionally, if info != nil, Check populates each of the non-nil maps in the Info struct. </p> <p> The package is marked as complete if no errors occurred, otherwise it is incomplete. See Config.Error for controlling behavior in the presence of errors. </p> <p> The package is specified by a list of *ast.Files and corresponding file set, and the package path the package is identified with. The clean path must not be empty or dot (\".\"). </p> <h2 id=\"Const\">type Const  </h2> <pre data-language=\"go\">type Const struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Const represents a declared constant. </p> <h3 id=\"NewConst\">func <a href=\"https://golang.org/src/go/types/object.go?s=4840:4932#L140\">NewConst</a>  </h3> <pre data-language=\"go\">func NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const</pre> <h3 id=\"Const.Exported\">func (*Const) <a href=\"https://golang.org/src/go/types/object.go?s=2973:3007#L86\">Exported</a>  </h3> <pre data-language=\"go\">func (obj *Const) Exported() bool</pre> <h3 id=\"Const.Id\">func (*Const) <a href=\"https://golang.org/src/go/types/object.go?s=3049:3079#L87\">Id</a>  </h3> <pre data-language=\"go\">func (obj *Const) Id() string</pre> <h3 id=\"Const.Name\">func (*Const) <a href=\"https://golang.org/src/go/types/object.go?s=2854:2886#L84\">Name</a>  </h3> <pre data-language=\"go\">func (obj *Const) Name() string</pre> <h3 id=\"Const.Parent\">func (*Const) <a href=\"https://golang.org/src/go/types/object.go?s=2674:2708#L81\">Parent</a>  </h3> <pre data-language=\"go\">func (obj *Const) Parent() *Scope</pre> <h3 id=\"Const.Pkg\">func (*Const) <a href=\"https://golang.org/src/go/types/object.go?s=2795:2828#L83\">Pkg</a>  </h3> <pre data-language=\"go\">func (obj *Const) Pkg() *Package</pre> <h3 id=\"Const.Pos\">func (*Const) <a href=\"https://golang.org/src/go/types/object.go?s=2736:2770#L82\">Pos</a>  </h3> <pre data-language=\"go\">func (obj *Const) Pos() token.Pos</pre> <h3 id=\"Const.String\">func (*Const) <a href=\"https://golang.org/src/go/types/object.go?s=9349:9382#L321\">String</a>  </h3> <pre data-language=\"go\">func (obj *Const) String() string</pre> <h3 id=\"Const.Type\">func (*Const) <a href=\"https://golang.org/src/go/types/object.go?s=2914:2944#L85\">Type</a>  </h3> <pre data-language=\"go\">func (obj *Const) Type() Type</pre> <h3 id=\"Const.Val\">func (*Const) <a href=\"https://golang.org/src/go/types/object.go?s=5015:5053#L144\">Val</a>  </h3> <pre data-language=\"go\">func (obj *Const) Val() constant.Value</pre> <h2 id=\"Error\">type Error  </h2> <pre data-language=\"go\">type Error struct {\n        Fset *token.FileSet // file set for interpretation of Pos\n        Pos  token.Pos      // error position\n        Msg  string         // error message\n        Soft bool           // if set, error is \"soft\"\n}</pre> <p> An Error describes a type-checking error; it implements the error interface. A \"soft\" error is an error that still permits a valid interpretation of a package (such as \"unused variable\"); \"hard\" errors may lead to unpredictable behavior if ignored. </p> <h3 id=\"Error.Error\">func (Error) <a href=\"https://golang.org/src/go/types/api.go?s=1832:1863#L40\">Error</a>  </h3> <pre data-language=\"go\">func (err Error) Error() string</pre> <p> Error returns an error string formatted as follows: filename:line:column: message </p> <h2 id=\"Func\">type Func  </h2> <pre data-language=\"go\">type Func struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Func represents a declared function, concrete method, or abstract (interface) method. Its Type() is always a *Signature. An abstract method may belong to many interfaces due to embedding. </p> <h3 id=\"MissingMethod\">func <a href=\"https://golang.org/src/go/types/lookup.go?s=8488:8572#L227\">MissingMethod</a>  </h3> <pre data-language=\"go\">func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)</pre> <p> MissingMethod returns (nil, false) if V implements T, otherwise it returns a missing method required by T and whether it is missing or just has the wrong type. </p> <p> For non-interface types V, or if static is set, V implements T if all methods of T are present in V. Otherwise (V is an interface and static is not set), MissingMethod only checks that methods of T which are also present in V have matching types (e.g., for a type assertion x.(T) where x is of interface type V). </p> <h3 id=\"NewFunc\">func <a href=\"https://golang.org/src/go/types/object.go?s=6556:6632#L187\">NewFunc</a>  </h3> <pre data-language=\"go\">func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func</pre> <h3 id=\"Func.Exported\">func (*Func) <a href=\"https://golang.org/src/go/types/object.go?s=2973:3007#L86\">Exported</a>  </h3> <pre data-language=\"go\">func (obj *Func) Exported() bool</pre> <h3 id=\"Func.FullName\">func (*Func) <a href=\"https://golang.org/src/go/types/object.go?s=6875:6909#L198\">FullName</a>  </h3> <pre data-language=\"go\">func (obj *Func) FullName() string</pre> <p> FullName returns the package- or receiver-type-qualified name of function or method obj. </p> <h3 id=\"Func.Id\">func (*Func) <a href=\"https://golang.org/src/go/types/object.go?s=3049:3079#L87\">Id</a>  </h3> <pre data-language=\"go\">func (obj *Func) Id() string</pre> <h3 id=\"Func.Name\">func (*Func) <a href=\"https://golang.org/src/go/types/object.go?s=2854:2886#L84\">Name</a>  </h3> <pre data-language=\"go\">func (obj *Func) Name() string</pre> <h3 id=\"Func.Parent\">func (*Func) <a href=\"https://golang.org/src/go/types/object.go?s=2674:2708#L81\">Parent</a>  </h3> <pre data-language=\"go\">func (obj *Func) Parent() *Scope</pre> <h3 id=\"Func.Pkg\">func (*Func) <a href=\"https://golang.org/src/go/types/object.go?s=2795:2828#L83\">Pkg</a>  </h3> <pre data-language=\"go\">func (obj *Func) Pkg() *Package</pre> <h3 id=\"Func.Pos\">func (*Func) <a href=\"https://golang.org/src/go/types/object.go?s=2736:2770#L82\">Pos</a>  </h3> <pre data-language=\"go\">func (obj *Func) Pos() token.Pos</pre> <h3 id=\"Func.Scope\">func (*Func) <a href=\"https://golang.org/src/go/types/object.go?s=6989:7020#L204\">Scope</a>  </h3> <pre data-language=\"go\">func (obj *Func) Scope() *Scope</pre> <h3 id=\"Func.String\">func (*Func) <a href=\"https://golang.org/src/go/types/object.go?s=9562:9594#L324\">String</a>  </h3> <pre data-language=\"go\">func (obj *Func) String() string</pre> <h3 id=\"Func.Type\">func (*Func) <a href=\"https://golang.org/src/go/types/object.go?s=2914:2944#L85\">Type</a>  </h3> <pre data-language=\"go\">func (obj *Func) Type() Type</pre> <h2 id=\"ImportMode\">type ImportMode  </h2> <pre data-language=\"go\">type ImportMode int</pre> <p> ImportMode is reserved for future use. </p> <h2 id=\"Importer\">type Importer  </h2> <pre data-language=\"go\">type Importer interface {\n        // Import returns the imported package for the given import\n        // path, or an error if the package couldn't be imported.\n        // Two calls to Import with the same path return the same\n        // package.\n        Import(path string) (*Package, error)\n}</pre> <p> An Importer resolves import paths to Packages. </p> <p> CAUTION: This interface does not support the import of locally vendored packages. See <a href=\"https://golang.org/s/go15vendor\">https://golang.org/s/go15vendor</a>. If possible, external implementations should implement ImporterFrom. </p> <h2 id=\"ImporterFrom\">type ImporterFrom  </h2> <pre data-language=\"go\">type ImporterFrom interface {\n        // Importer is present for backward-compatibility. Calling\n        // Import(path) is the same as calling ImportFrom(path, \"\", 0);\n        // i.e., locally vendored packages may not be found.\n        // The types package does not call Import if an ImporterFrom\n        // is present.\n        Importer\n\n        // ImportFrom returns the imported package for the given import\n        // path when imported by the package in srcDir, or an error\n        // if the package couldn't be imported. The mode value must\n        // be 0; it is reserved for future use.\n        // Two calls to ImportFrom with the same path and srcDir return\n        // the same package.\n        ImportFrom(path, srcDir string, mode ImportMode) (*Package, error)\n}</pre> <p> An ImporterFrom resolves import paths to packages; it supports vendoring per <a href=\"https://golang.org/s/go15vendor\">https://golang.org/s/go15vendor</a>. Use go/importer to obtain an ImporterFrom implementation. </p> <h2 id=\"Info\">type Info  </h2> <pre data-language=\"go\">type Info struct {\n        // Types maps expressions to their types, and for constant\n        // expressions, their values. Invalid expressions are omitted.\n        //\n        // For (possibly parenthesized) identifiers denoting built-in\n        // functions, the recorded signatures are call-site specific:\n        // if the call result is not a constant, the recorded type is\n        // an argument-specific signature. Otherwise, the recorded type\n        // is invalid.\n        //\n        // Identifiers on the lhs of declarations (i.e., the identifiers\n        // which are being declared) are collected in the Defs map.\n        // Identifiers denoting packages are collected in the Uses maps.\n        Types map[ast.Expr]TypeAndValue\n\n        // Defs maps identifiers to the objects they define (including\n        // package names, dots \".\" of dot-imports, and blank \"_\" identifiers).\n        // For identifiers that do not denote objects (e.g., the package name\n        // in package clauses, or symbolic variables t in t := x.(type) of\n        // type switch headers), the corresponding objects are nil.\n        //\n        // For an anonymous field, Defs returns the field *Var it defines.\n        //\n        // Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos()\n        Defs map[*ast.Ident]Object\n\n        // Uses maps identifiers to the objects they denote.\n        //\n        // For an anonymous field, Uses returns the *TypeName it denotes.\n        //\n        // Invariant: Uses[id].Pos() != id.Pos()\n        Uses map[*ast.Ident]Object\n\n        // Implicits maps nodes to their implicitly declared objects, if any.\n        // The following node and object types may appear:\n        //\n        //\tnode               declared object\n        //\n        //\t*ast.ImportSpec    *PkgName for dot-imports and imports without renames\n        //\t*ast.CaseClause    type-specific *Var for each type switch case clause (incl. default)\n        //      *ast.Field         anonymous parameter *Var\n        //\n        Implicits map[ast.Node]Object\n\n        // Selections maps selector expressions (excluding qualified identifiers)\n        // to their corresponding selections.\n        Selections map[*ast.SelectorExpr]*Selection\n\n        // Scopes maps ast.Nodes to the scopes they define. Package scopes are not\n        // associated with a specific node but with all files belonging to a package.\n        // Thus, the package scope can be found in the type-checked Package object.\n        // Scopes nest, with the Universe scope being the outermost scope, enclosing\n        // the package scope, which contains (one or more) files scopes, which enclose\n        // function scopes which in turn enclose statement and function literal scopes.\n        // Note that even though package-level functions are declared in the package\n        // scope, the function scopes are embedded in the file scope of the file\n        // containing the function declaration.\n        //\n        // The following node types may appear in Scopes:\n        //\n        //\t*ast.File\n        //\t*ast.FuncType\n        //\t*ast.BlockStmt\n        //\t*ast.IfStmt\n        //\t*ast.SwitchStmt\n        //\t*ast.TypeSwitchStmt\n        //\t*ast.CaseClause\n        //\t*ast.CommClause\n        //\t*ast.ForStmt\n        //\t*ast.RangeStmt\n        //\n        Scopes map[ast.Node]*Scope\n\n        // InitOrder is the list of package-level initializers in the order in which\n        // they must be executed. Initializers referring to variables related by an\n        // initialization dependency appear in topological order, the others appear\n        // in source order. Variables without an initialization expression do not\n        // appear in this list.\n        InitOrder []*Initializer\n}</pre> <p> Info holds result type information for a type-checked package. Only the information for which a map is provided is collected. If the package has type errors, the collected information may be incomplete. </p> <div id=\"example_Info\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>ExampleInfo prints various facts recorded by the type checker in a types.Info struct: definitions of and references to each named object, and the type, value, and mode of every expression in the package. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// Parse a single source file.\n    const input = `\npackage fib\n\ntype S string\n\nvar a, b, c = len(b), S(c), \"hello\"\n\nfunc fib(x int) int {\n    if x &lt; 2 {\n            return x\n    }\n    return fib(x-1) - fib(x-2)\n}`\n    fset := token.NewFileSet()\n    f, err := parser.ParseFile(fset, \"fib.go\", input, 0)\n    if err != nil {\n            log.Fatal(err)\n    }\n\n    // Type-check the package.\n    // We create an empty map for each kind of input\n    // we're interested in, and Check populates them.\n    info := types.Info{\n            Types: make(map[ast.Expr]types.TypeAndValue),\n            Defs:  make(map[*ast.Ident]types.Object),\n            Uses:  make(map[*ast.Ident]types.Object),\n    }\n    var conf types.Config\n    pkg, err := conf.Check(\"fib\", fset, []*ast.File{f}, &amp;info)\n    if err != nil {\n            log.Fatal(err)\n    }\n\n    // Print package-level variables in initialization order.\n    fmt.Printf(\"InitOrder: %v\\n\\n\", info.InitOrder)\n\n    // For each named object, print the line and\n    // column of its definition and each of its uses.\n    fmt.Println(\"Defs and Uses of each named object:\")\n    usesByObj := make(map[types.Object][]string)\n    for id, obj := range info.Uses {\n            posn := fset.Position(id.Pos())\n            lineCol := fmt.Sprintf(\"%d:%d\", posn.Line, posn.Column)\n            usesByObj[obj] = append(usesByObj[obj], lineCol)\n    }\n    var items []string\n    for obj, uses := range usesByObj {\n            sort.Strings(uses)\n            item := fmt.Sprintf(\"%s:\\n  defined at %s\\n  used at %s\",\n                    types.ObjectString(obj, types.RelativeTo(pkg)),\n                    fset.Position(obj.Pos()),\n                    strings.Join(uses, \", \"))\n            items = append(items, item)\n    }\n    sort.Strings(items) // sort by line:col, in effect\n    fmt.Println(strings.Join(items, \"\\n\"))\n    fmt.Println()\n\n    fmt.Println(\"Types and Values of each expression:\")\n    items = nil\n    for expr, tv := range info.Types {\n            var buf bytes.Buffer\n            posn := fset.Position(expr.Pos())\n            tvstr := tv.Type.String()\n            if tv.Value != nil {\n                    tvstr += \" = \" + tv.Value.String()\n            }\n            // line:col | expr | mode : type = value\n            fmt.Fprintf(&amp;buf, \"%2d:%2d | %-19s | %-7s : %s\",\n                    posn.Line, posn.Column, exprString(fset, expr),\n                    mode(tv), tvstr)\n            items = append(items, buf.String())\n    }\n    sort.Strings(items)\n    fmt.Println(strings.Join(items, \"\\n\"))\n\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">InitOrder: [c = \"hello\" b = S(c) a = len(b)]\n\nDefs and Uses of each named object:\nbuiltin len:\n  defined at -\n  used at 6:15\nfunc fib(x int) int:\n  defined at fib.go:8:6\n  used at 12:20, 12:9\ntype S string:\n  defined at fib.go:4:6\n  used at 6:23\ntype int int:\n  defined at -\n  used at 8:12, 8:17\ntype string string:\n  defined at -\n  used at 4:8\nvar b S:\n  defined at fib.go:6:8\n  used at 6:19\nvar c string:\n  defined at fib.go:6:11\n  used at 6:25\nvar x int:\n  defined at fib.go:8:10\n  used at 10:10, 12:13, 12:24, 9:5\n\nTypes and Values of each expression:\n 4: 8 | string              | type    : string\n 6:15 | len                 | builtin : func(string) int\n 6:15 | len(b)              | value   : int\n 6:19 | b                   | var     : fib.S\n 6:23 | S                   | type    : fib.S\n 6:23 | S(c)                | value   : fib.S\n 6:25 | c                   | var     : string\n 6:29 | \"hello\"             | value   : string = \"hello\"\n 8:12 | int                 | type    : int\n 8:17 | int                 | type    : int\n 9: 5 | x                   | var     : int\n 9: 5 | x &lt; 2               | value   : untyped bool\n 9: 9 | 2                   | value   : int = 2\n10:10 | x                   | var     : int\n12: 9 | fib                 | value   : func(x int) int\n12: 9 | fib(x - 1)          | value   : int\n12: 9 | fib(x-1) - fib(x-2) | value   : int\n12:13 | x                   | var     : int\n12:13 | x - 1               | value   : int\n12:15 | 1                   | value   : int = 1\n12:20 | fib                 | value   : func(x int) int\n12:20 | fib(x - 2)          | value   : int\n12:24 | x                   | var     : int\n12:24 | x - 2               | value   : int\n12:26 | 2                   | value   : int = 2\n</pre> </div> </div> <h3 id=\"Info.ObjectOf\">func (*Info) <a href=\"https://golang.org/src/go/types/api.go?s=9062:9110#L230\">ObjectOf</a>  </h3> <pre data-language=\"go\">func (info *Info) ObjectOf(id *ast.Ident) Object</pre> <p> ObjectOf returns the object denoted by the specified id, or nil if not found. </p> <p> If id is an anonymous struct field, ObjectOf returns the field (*Var) it uses, not the type (*TypeName) it defines. </p> <p> Precondition: the Uses and Defs maps are populated. </p> <h3 id=\"Info.TypeOf\">func (*Info) <a href=\"https://golang.org/src/go/types/api.go?s=8568:8609#L210\">TypeOf</a>  </h3> <pre data-language=\"go\">func (info *Info) TypeOf(e ast.Expr) Type</pre> <p> TypeOf returns the type of expression e, or nil if not found. Precondition: the Types, Uses and Defs maps are populated. </p> <h2 id=\"Initializer\">type Initializer  </h2> <pre data-language=\"go\">type Initializer struct {\n        Lhs []*Var // var Lhs = Rhs\n        Rhs ast.Expr\n}</pre> <p> An Initializer describes a package-level variable, or a list of variables in case of a multi-valued initialization expression, and the corresponding initialization expression. </p> <h3 id=\"Initializer.String\">func (*Initializer) <a href=\"https://golang.org/src/go/types/api.go?s=11357:11397#L308\">String</a>  </h3> <pre data-language=\"go\">func (init *Initializer) String() string</pre> <h2 id=\"Interface\">type Interface  </h2> <pre data-language=\"go\">type Interface struct {\n        // contains filtered or unexported fields\n}</pre> <p> An Interface represents an interface type. </p> <h3 id=\"NewInterface\">func <a href=\"https://golang.org/src/go/types/type.go?s=7208:7273#L244\">NewInterface</a>  </h3> <pre data-language=\"go\">func NewInterface(methods []*Func, embeddeds []*Named) *Interface</pre> <p> NewInterface returns a new interface for the given methods and embedded types. </p> <h3 id=\"Interface.Complete\">func (*Interface) <a href=\"https://golang.org/src/go/types/type.go?s=9284:9325#L296\">Complete</a>  </h3> <pre data-language=\"go\">func (t *Interface) Complete() *Interface</pre> <p> Complete computes the interface's method set. It must be called by users of NewInterface after the interface's embedded types are fully defined and before using the interface type in any way other than to form other types. Complete returns the receiver. </p> <h3 id=\"Interface.Embedded\">func (*Interface) <a href=\"https://golang.org/src/go/types/type.go?s=8503:8545#L280\">Embedded</a>  </h3> <pre data-language=\"go\">func (t *Interface) Embedded(i int) *Named</pre> <p> Embedded returns the i'th embedded type of interface t for 0 &lt;= i &lt; t.NumEmbeddeds(). The types are ordered by the corresponding TypeName's unique Id. </p> <h3 id=\"Interface.Empty\">func (*Interface) <a href=\"https://golang.org/src/go/types/type.go?s=8950:8982#L290\">Empty</a>  </h3> <pre data-language=\"go\">func (t *Interface) Empty() bool</pre> <p> Empty returns true if t is the empty interface. </p> <h3 id=\"Interface.ExplicitMethod\">func (*Interface) <a href=\"https://golang.org/src/go/types/type.go?s=8136:8183#L273\">ExplicitMethod</a>  </h3> <pre data-language=\"go\">func (t *Interface) ExplicitMethod(i int) *Func</pre> <p> ExplicitMethod returns the i'th explicitly declared method of interface t for 0 &lt;= i &lt; t.NumExplicitMethods(). The methods are ordered by their unique Id. </p> <h3 id=\"Interface.Method\">func (*Interface) <a href=\"https://golang.org/src/go/types/type.go?s=8831:8870#L287\">Method</a>  </h3> <pre data-language=\"go\">func (t *Interface) Method(i int) *Func</pre> <p> Method returns the i'th method of interface t for 0 &lt;= i &lt; t.NumMethods(). The methods are ordered by their unique Id. </p> <h3 id=\"Interface.NumEmbeddeds\">func (*Interface) <a href=\"https://golang.org/src/go/types/type.go?s=8278:8316#L276\">NumEmbeddeds</a>  </h3> <pre data-language=\"go\">func (t *Interface) NumEmbeddeds() int</pre> <p> NumEmbeddeds returns the number of embedded types in interface t. </p> <h3 id=\"Interface.NumExplicitMethods\">func (*Interface) <a href=\"https://golang.org/src/go/types/type.go?s=7903:7947#L269\">NumExplicitMethods</a>  </h3> <pre data-language=\"go\">func (t *Interface) NumExplicitMethods() int</pre> <p> NumExplicitMethods returns the number of explicitly declared methods of interface t. </p> <h3 id=\"Interface.NumMethods\">func (*Interface) <a href=\"https://golang.org/src/go/types/type.go?s=8639:8675#L283\">NumMethods</a>  </h3> <pre data-language=\"go\">func (t *Interface) NumMethods() int</pre> <p> NumMethods returns the total number of methods of interface t. </p> <h3 id=\"Interface.String\">func (*Interface) <a href=\"https://golang.org/src/go/types/type.go?s=13948:13983#L442\">String</a>  </h3> <pre data-language=\"go\">func (t *Interface) String() string</pre> <h3 id=\"Interface.Underlying\">func (*Interface) <a href=\"https://golang.org/src/go/types/type.go?s=13270:13307#L430\">Underlying</a>  </h3> <pre data-language=\"go\">func (t *Interface) Underlying() Type</pre> <h2 id=\"Label\">type Label  </h2> <pre data-language=\"go\">type Label struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Label represents a declared label. </p> <h3 id=\"NewLabel\">func <a href=\"https://golang.org/src/go/types/object.go?s=7172:7234#L214\">NewLabel</a>  </h3> <pre data-language=\"go\">func NewLabel(pos token.Pos, pkg *Package, name string) *Label</pre> <h3 id=\"Label.Exported\">func (*Label) <a href=\"https://golang.org/src/go/types/object.go?s=2973:3007#L86\">Exported</a>  </h3> <pre data-language=\"go\">func (obj *Label) Exported() bool</pre> <h3 id=\"Label.Id\">func (*Label) <a href=\"https://golang.org/src/go/types/object.go?s=3049:3079#L87\">Id</a>  </h3> <pre data-language=\"go\">func (obj *Label) Id() string</pre> <h3 id=\"Label.Name\">func (*Label) <a href=\"https://golang.org/src/go/types/object.go?s=2854:2886#L84\">Name</a>  </h3> <pre data-language=\"go\">func (obj *Label) Name() string</pre> <h3 id=\"Label.Parent\">func (*Label) <a href=\"https://golang.org/src/go/types/object.go?s=2674:2708#L81\">Parent</a>  </h3> <pre data-language=\"go\">func (obj *Label) Parent() *Scope</pre> <h3 id=\"Label.Pkg\">func (*Label) <a href=\"https://golang.org/src/go/types/object.go?s=2795:2828#L83\">Pkg</a>  </h3> <pre data-language=\"go\">func (obj *Label) Pkg() *Package</pre> <h3 id=\"Label.Pos\">func (*Label) <a href=\"https://golang.org/src/go/types/object.go?s=2736:2770#L82\">Pos</a>  </h3> <pre data-language=\"go\">func (obj *Label) Pos() token.Pos</pre> <h3 id=\"Label.String\">func (*Label) <a href=\"https://golang.org/src/go/types/object.go?s=9633:9666#L325\">String</a>  </h3> <pre data-language=\"go\">func (obj *Label) String() string</pre> <h3 id=\"Label.Type\">func (*Label) <a href=\"https://golang.org/src/go/types/object.go?s=2914:2944#L85\">Type</a>  </h3> <pre data-language=\"go\">func (obj *Label) Type() Type</pre> <h2 id=\"Map\">type Map  </h2> <pre data-language=\"go\">type Map struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Map represents a map type. </p> <h3 id=\"NewMap\">func <a href=\"https://golang.org/src/go/types/type.go?s=10171:10203#L335\">NewMap</a>  </h3> <pre data-language=\"go\">func NewMap(key, elem Type) *Map</pre> <p> NewMap returns a new map for the given key and element types. </p> <h3 id=\"Map.Elem\">func (*Map) <a href=\"https://golang.org/src/go/types/type.go?s=10357:10382#L343\">Elem</a>  </h3> <pre data-language=\"go\">func (m *Map) Elem() Type</pre> <p> Elem returns the element type of map m. </p> <h3 id=\"Map.Key\">func (*Map) <a href=\"https://golang.org/src/go/types/type.go?s=10271:10295#L340\">Key</a>  </h3> <pre data-language=\"go\">func (m *Map) Key() Type</pre> <p> Key returns the key type of map m. </p> <h3 id=\"Map.String\">func (*Map) <a href=\"https://golang.org/src/go/types/type.go?s=14014:14043#L443\">String</a>  </h3> <pre data-language=\"go\">func (t *Map) String() string</pre> <h3 id=\"Map.Underlying\">func (*Map) <a href=\"https://golang.org/src/go/types/type.go?s=13321:13352#L431\">Underlying</a>  </h3> <pre data-language=\"go\">func (t *Map) Underlying() Type</pre> <h2 id=\"MethodSet\">type MethodSet  </h2> <pre data-language=\"go\">type MethodSet struct {\n        // contains filtered or unexported fields\n}</pre> <p> A MethodSet is an ordered set of concrete or abstract (interface) methods; a method is a MethodVal selection, and they are ordered by ascending m.Obj().Id(). The zero value for a MethodSet is a ready-to-use empty method set. </p> <div id=\"example_MethodSet\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>ExampleMethodSet prints the method sets of various types. </p> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/importer\"\n\t\"go/parser\"\n\t\"go/token\"\n\t\"go/types\"\n\t\"log\"\n)\n\nfunc main() {\n\t// Parse a single source file.\n\tconst input = `\npackage temperature\nimport \"fmt\"\ntype Celsius float64\nfunc (c Celsius) String() string  { return fmt.Sprintf(\"%g°C\", c) }\nfunc (c *Celsius) SetF(f float64) { *c = Celsius(f - 32 / 9 * 5) }\n`\n\tfset := token.NewFileSet()\n\tf, err := parser.ParseFile(fset, \"celsius.go\", input, 0)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Type-check a package consisting of this file.\n\t// Type information for the imported packages\n\t// comes from $GOROOT/pkg/$GOOS_$GOOARCH/fmt.a.\n\tconf := types.Config{Importer: importer.Default()}\n\tpkg, err := conf.Check(\"temperature\", fset, []*ast.File{f}, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Print the method sets of Celsius and *Celsius.\n\tcelsius := pkg.Scope().Lookup(\"Celsius\").Type()\n\tfor _, t := range []types.Type{celsius, types.NewPointer(celsius)} {\n\t\tfmt.Printf(\"Method set of %s:\\n\", t)\n\t\tmset := types.NewMethodSet(t)\n\t\tfor i := 0; i &lt; mset.Len(); i++ {\n\t\t\tfmt.Println(mset.At(i))\n\t\t}\n\t\tfmt.Println()\n\t}\n\n}\n</pre> </div> </div> <h3 id=\"NewMethodSet\">func <a href=\"https://golang.org/src/go/types/methodset.go?s=1587:1623#L57\">NewMethodSet</a>  </h3> <pre data-language=\"go\">func NewMethodSet(T Type) *MethodSet</pre> <p> NewMethodSet returns the method set for the given type T. It always returns a non-nil method set, even if it is empty. </p> <h3 id=\"MethodSet.At\">func (*MethodSet) <a href=\"https://golang.org/src/go/types/methodset.go?s=938:978#L30\">At</a>  </h3> <pre data-language=\"go\">func (s *MethodSet) At(i int) *Selection</pre> <p> At returns the i'th method in s for 0 &lt;= i &lt; s.Len(). </p> <h3 id=\"MethodSet.Len\">func (*MethodSet) <a href=\"https://golang.org/src/go/types/methodset.go?s=827:856#L27\">Len</a>  </h3> <pre data-language=\"go\">func (s *MethodSet) Len() int</pre> <p> Len returns the number of methods in s. </p> <h3 id=\"MethodSet.Lookup\">func (*MethodSet) <a href=\"https://golang.org/src/go/types/methodset.go?s=1083:1147#L33\">Lookup</a>  </h3> <pre data-language=\"go\">func (s *MethodSet) Lookup(pkg *Package, name string) *Selection</pre> <p> Lookup returns the method with matching package and name, or nil if not found. </p> <h3 id=\"MethodSet.String\">func (*MethodSet) <a href=\"https://golang.org/src/go/types/methodset.go?s=529:564#L12\">String</a>  </h3> <pre data-language=\"go\">func (s *MethodSet) String() string</pre> <h2 id=\"Named\">type Named  </h2> <pre data-language=\"go\">type Named struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Named represents a named type. </p> <h3 id=\"NewNamed\">func <a href=\"https://golang.org/src/go/types/type.go?s=11463:11532#L381\">NewNamed</a>  </h3> <pre data-language=\"go\">func NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named</pre> <p> NewNamed returns a new named type for the given type name, underlying type, and associated methods. The underlying type must not be a *Named. </p> <h3 id=\"Named.AddMethod\">func (*Named) <a href=\"https://golang.org/src/go/types/type.go?s=12737:12771#L415\">AddMethod</a>  </h3> <pre data-language=\"go\">func (t *Named) AddMethod(m *Func)</pre> <p> AddMethod adds method m unless it is already in the method list. TODO(gri) find a better solution instead of providing this function </p> <h3 id=\"Named.Method\">func (*Named) <a href=\"https://golang.org/src/go/types/type.go?s=12091:12126#L399\">Method</a>  </h3> <pre data-language=\"go\">func (t *Named) Method(i int) *Func</pre> <p> Method returns the i'th method of named type t for 0 &lt;= i &lt; t.NumMethods(). </p> <h3 id=\"Named.NumMethods\">func (*Named) <a href=\"https://golang.org/src/go/types/type.go?s=11952:11984#L396\">NumMethods</a>  </h3> <pre data-language=\"go\">func (t *Named) NumMethods() int</pre> <p> NumMethods returns the number of explicit methods whose receiver is named type t. </p> <h3 id=\"Named.Obj\">func (*Named) <a href=\"https://golang.org/src/go/types/type.go?s=11817:11848#L393\">Obj</a>  </h3> <pre data-language=\"go\">func (t *Named) Obj() *TypeName</pre> <p> TypeName returns the type name for the named type t. </p> <h3 id=\"Named.SetUnderlying\">func (*Named) <a href=\"https://golang.org/src/go/types/type.go?s=12307:12353#L403\">SetUnderlying</a>  </h3> <pre data-language=\"go\">func (t *Named) SetUnderlying(underlying Type)</pre> <p> SetUnderlying sets the underlying type and marks t as complete. TODO(gri) determine if there's a better solution rather than providing this function </p> <h3 id=\"Named.String\">func (*Named) <a href=\"https://golang.org/src/go/types/type.go?s=14146:14177#L445\">String</a>  </h3> <pre data-language=\"go\">func (t *Named) String() string</pre> <h3 id=\"Named.Underlying\">func (*Named) <a href=\"https://golang.org/src/go/types/type.go?s=13423:13456#L433\">Underlying</a>  </h3> <pre data-language=\"go\">func (t *Named) Underlying() Type</pre> <h2 id=\"Nil\">type Nil  </h2> <pre data-language=\"go\">type Nil struct {\n        // contains filtered or unexported fields\n}</pre> <p> Nil represents the predeclared value nil. </p> <h3 id=\"Nil.Exported\">func (*Nil) <a href=\"https://golang.org/src/go/types/object.go?s=2973:3007#L86\">Exported</a>  </h3> <pre data-language=\"go\">func (obj *Nil) Exported() bool</pre> <h3 id=\"Nil.Id\">func (*Nil) <a href=\"https://golang.org/src/go/types/object.go?s=3049:3079#L87\">Id</a>  </h3> <pre data-language=\"go\">func (obj *Nil) Id() string</pre> <h3 id=\"Nil.Name\">func (*Nil) <a href=\"https://golang.org/src/go/types/object.go?s=2854:2886#L84\">Name</a>  </h3> <pre data-language=\"go\">func (obj *Nil) Name() string</pre> <h3 id=\"Nil.Parent\">func (*Nil) <a href=\"https://golang.org/src/go/types/object.go?s=2674:2708#L81\">Parent</a>  </h3> <pre data-language=\"go\">func (obj *Nil) Parent() *Scope</pre> <h3 id=\"Nil.Pkg\">func (*Nil) <a href=\"https://golang.org/src/go/types/object.go?s=2795:2828#L83\">Pkg</a>  </h3> <pre data-language=\"go\">func (obj *Nil) Pkg() *Package</pre> <h3 id=\"Nil.Pos\">func (*Nil) <a href=\"https://golang.org/src/go/types/object.go?s=2736:2770#L82\">Pos</a>  </h3> <pre data-language=\"go\">func (obj *Nil) Pos() token.Pos</pre> <h3 id=\"Nil.String\">func (*Nil) <a href=\"https://golang.org/src/go/types/object.go?s=9775:9806#L327\">String</a>  </h3> <pre data-language=\"go\">func (obj *Nil) String() string</pre> <h3 id=\"Nil.Type\">func (*Nil) <a href=\"https://golang.org/src/go/types/object.go?s=2914:2944#L85\">Type</a>  </h3> <pre data-language=\"go\">func (obj *Nil) Type() Type</pre> <h2 id=\"Object\">type Object  </h2> <pre data-language=\"go\">type Object interface {\n        Parent() *Scope // scope in which this object is declared\n        Pos() token.Pos // position of object identifier in declaration\n        Pkg() *Package  // nil for objects in the Universe scope and labels\n        Name() string   // package local object name\n        Type() Type     // object type\n        Exported() bool // reports whether the name starts with a capital letter\n        Id() string     // object id (see Id below)\n\n        // String returns a human-readable string of the object.\n        String() string\n        // contains filtered or unexported methods\n}</pre> <p> An Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label. All objects implement the Object interface. </p> <h3 id=\"LookupFieldOrMethod\">func <a href=\"https://golang.org/src/go/types/lookup.go?s=1550:1668#L25\">LookupFieldOrMethod</a>  </h3> <pre data-language=\"go\">func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)</pre> <p> LookupFieldOrMethod looks up a field or method with given package and name in T and returns the corresponding *Var or *Func, an index sequence, and a bool indicating if there were any pointer indirections on the path to the field or method. If addressable is set, T is the type of an addressable variable (only matters for method lookups). </p> <p> The last index entry is the field or method index in the (possibly embedded) type where the entry was found, either: </p> <pre data-language=\"go\">1) the list of declared methods of a named type; or\n2) the list of all methods (method set) of an interface type; or\n3) the list of fields of a struct type.\n</pre> <p> The earlier index entries are the indices of the anonymous struct fields traversed to get to the found entry, starting at depth 0. </p> <p> If no entry is found, a nil object is returned. In this case, the returned index and indirect values have the following meaning: </p> <pre data-language=\"go\">\t- If index != nil, the index sequence points to an ambiguous entry\n\t(the same name appeared more than once at the same embedding level).\n\n\t- If indirect is set, a method with a pointer receiver type was found\n     but there was no pointer on the path from the actual receiver type to\n\tthe method's formal receiver base type, nor was the receiver addressable.\n</pre> <h2 id=\"Package\">type Package  </h2> <pre data-language=\"go\">type Package struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Package describes a Go package. </p> <h3 id=\"NewPackage\">func <a href=\"https://golang.org/src/go/types/package.go?s=637:680#L15\">NewPackage</a>  </h3> <pre data-language=\"go\">func NewPackage(path, name string) *Package</pre> <p> NewPackage returns a new Package for the given package path and name; the name must not be the blank identifier. The package is not complete and contains no explicit imports. </p> <h3 id=\"Package.Complete\">func (*Package) <a href=\"https://golang.org/src/go/types/package.go?s=1476:1511#L39\">Complete</a>  </h3> <pre data-language=\"go\">func (pkg *Package) Complete() bool</pre> <p> A package is complete if its scope contains (at least) all exported objects; otherwise it is incomplete. </p> <h3 id=\"Package.Imports\">func (*Package) <a href=\"https://golang.org/src/go/types/package.go?s=1986:2026#L50\">Imports</a>  </h3> <pre data-language=\"go\">func (pkg *Package) Imports() []*Package</pre> <p> Imports returns the list of packages directly imported by pkg; the list is in source order. Package unsafe is excluded. </p> <p> If pkg was loaded from export data, Imports includes packages that provide package-level objects referenced by pkg. This may be more or less than the set of packages directly imported by pkg's source code. </p> <h3 id=\"Package.MarkComplete\">func (*Package) <a href=\"https://golang.org/src/go/types/package.go?s=1582:1616#L42\">MarkComplete</a>  </h3> <pre data-language=\"go\">func (pkg *Package) MarkComplete()</pre> <p> MarkComplete marks a package as complete. </p> <h3 id=\"Package.Name\">func (*Package) <a href=\"https://golang.org/src/go/types/package.go?s=1007:1040#L27\">Name</a>  </h3> <pre data-language=\"go\">func (pkg *Package) Name() string</pre> <p> Name returns the package name. </p> <h3 id=\"Package.Path\">func (*Package) <a href=\"https://golang.org/src/go/types/package.go?s=918:951#L24\">Path</a>  </h3> <pre data-language=\"go\">func (pkg *Package) Path() string</pre> <p> Path returns the package path. </p> <h3 id=\"Package.Scope\">func (*Package) <a href=\"https://golang.org/src/go/types/package.go?s=1308:1342#L35\">Scope</a>  </h3> <pre data-language=\"go\">func (pkg *Package) Scope() *Scope</pre> <p> Scope returns the (complete or incomplete) package scope holding the objects declared at package level (TypeNames, Consts, Vars, and Funcs). </p> <h3 id=\"Package.SetImports\">func (*Package) <a href=\"https://golang.org/src/go/types/package.go?s=2196:2243#L54\">SetImports</a>  </h3> <pre data-language=\"go\">func (pkg *Package) SetImports(list []*Package)</pre> <p> SetImports sets the list of explicitly imported packages to list. It is the caller's responsibility to make sure list elements are unique. </p> <h3 id=\"Package.SetName\">func (*Package) <a href=\"https://golang.org/src/go/types/package.go?s=1096:1136#L30\">SetName</a>  </h3> <pre data-language=\"go\">func (pkg *Package) SetName(name string)</pre> <p> SetName sets the package name. </p> <h3 id=\"Package.String\">func (*Package) <a href=\"https://golang.org/src/go/types/package.go?s=2268:2303#L56\">String</a>  </h3> <pre data-language=\"go\">func (pkg *Package) String() string</pre> <h2 id=\"PkgName\">type PkgName  </h2> <pre data-language=\"go\">type PkgName struct {\n        // contains filtered or unexported fields\n}</pre> <p> A PkgName represents an imported Go package. </p> <h3 id=\"NewPkgName\">func <a href=\"https://golang.org/src/go/types/object.go?s=4306:4391#L125\">NewPkgName</a>  </h3> <pre data-language=\"go\">func NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName</pre> <h3 id=\"PkgName.Exported\">func (*PkgName) <a href=\"https://golang.org/src/go/types/object.go?s=2973:3007#L86\">Exported</a>  </h3> <pre data-language=\"go\">func (obj *PkgName) Exported() bool</pre> <h3 id=\"PkgName.Id\">func (*PkgName) <a href=\"https://golang.org/src/go/types/object.go?s=3049:3079#L87\">Id</a>  </h3> <pre data-language=\"go\">func (obj *PkgName) Id() string</pre> <h3 id=\"PkgName.Imported\">func (*PkgName) <a href=\"https://golang.org/src/go/types/object.go?s=4625:4664#L131\">Imported</a>  </h3> <pre data-language=\"go\">func (obj *PkgName) Imported() *Package</pre> <p> Imported returns the package that was imported. It is distinct from Pkg(), which is the package containing the import statement. </p> <h3 id=\"PkgName.Name\">func (*PkgName) <a href=\"https://golang.org/src/go/types/object.go?s=2854:2886#L84\">Name</a>  </h3> <pre data-language=\"go\">func (obj *PkgName) Name() string</pre> <h3 id=\"PkgName.Parent\">func (*PkgName) <a href=\"https://golang.org/src/go/types/object.go?s=2674:2708#L81\">Parent</a>  </h3> <pre data-language=\"go\">func (obj *PkgName) Parent() *Scope</pre> <h3 id=\"PkgName.Pkg\">func (*PkgName) <a href=\"https://golang.org/src/go/types/object.go?s=2795:2828#L83\">Pkg</a>  </h3> <pre data-language=\"go\">func (obj *PkgName) Pkg() *Package</pre> <h3 id=\"PkgName.Pos\">func (*PkgName) <a href=\"https://golang.org/src/go/types/object.go?s=2736:2770#L82\">Pos</a>  </h3> <pre data-language=\"go\">func (obj *PkgName) Pos() token.Pos</pre> <h3 id=\"PkgName.String\">func (*PkgName) <a href=\"https://golang.org/src/go/types/object.go?s=9278:9313#L320\">String</a>  </h3> <pre data-language=\"go\">func (obj *PkgName) String() string</pre> <h3 id=\"PkgName.Type\">func (*PkgName) <a href=\"https://golang.org/src/go/types/object.go?s=2914:2944#L85\">Type</a>  </h3> <pre data-language=\"go\">func (obj *PkgName) Type() Type</pre> <h2 id=\"Pointer\">type Pointer  </h2> <pre data-language=\"go\">type Pointer struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Pointer represents a pointer type. </p> <h3 id=\"NewPointer\">func <a href=\"https://golang.org/src/go/types/type.go?s=3865:3900#L157\">NewPointer</a>  </h3> <pre data-language=\"go\">func NewPointer(elem Type) *Pointer</pre> <p> NewPointer returns a new pointer type for the given element (base) type. </p> <h3 id=\"Pointer.Elem\">func (*Pointer) <a href=\"https://golang.org/src/go/types/type.go?s=3992:4021#L160\">Elem</a>  </h3> <pre data-language=\"go\">func (p *Pointer) Elem() Type</pre> <p> Elem returns the element type for the given pointer p. </p> <h3 id=\"Pointer.String\">func (*Pointer) <a href=\"https://golang.org/src/go/types/type.go?s=13750:13783#L439\">String</a>  </h3> <pre data-language=\"go\">func (t *Pointer) String() string</pre> <h3 id=\"Pointer.Underlying\">func (*Pointer) <a href=\"https://golang.org/src/go/types/type.go?s=13117:13152#L427\">Underlying</a>  </h3> <pre data-language=\"go\">func (t *Pointer) Underlying() Type</pre> <h2 id=\"Qualifier\">type Qualifier  </h2> <pre data-language=\"go\">type Qualifier func(*Package) string</pre> <p> A Qualifier controls how named package-level objects are printed in calls to TypeString, ObjectString, and SelectionString. </p> <p> These three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed. </p> <p> Using a nil Qualifier is equivalent to using (*Package).Path: the object is qualified by the import path, e.g., \"encoding/json.Marshal\". </p> <h3 id=\"RelativeTo\">func <a href=\"https://golang.org/src/go/types/typestring.go?s=922:961#L19\">RelativeTo</a>  </h3> <pre data-language=\"go\">func RelativeTo(pkg *Package) Qualifier</pre> <p> RelativeTo(pkg) returns a Qualifier that fully qualifies members of all packages other than pkg. </p> <h2 id=\"Scope\">type Scope  </h2> <pre data-language=\"go\">type Scope struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Scope maintains a set of objects and links to its containing (parent) and contained (children) scopes. Objects may be inserted and looked up by name. The zero value for Scope is a ready-to-use empty scope. </p> <div id=\"example_Scope\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>ExampleScope prints the tree of Scopes of a package created from a set of parsed files. </p> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/importer\"\n\t\"go/parser\"\n\t\"go/token\"\n\t\"go/types\"\n\t\"log\"\n\t\"regexp\"\n)\n\nfunc main() {\n\t// Parse the source files for a package.\n\tfset := token.NewFileSet()\n\tvar files []*ast.File\n\tfor _, file := range []struct{ name, input string }{\n\t\t{\"main.go\", `\npackage main\nimport \"fmt\"\nfunc main() {\n\tfreezing := FToC(-18)\n\tfmt.Println(freezing, Boiling) }\n`},\n\t\t{\"celsius.go\", `\npackage main\nimport \"fmt\"\ntype Celsius float64\nfunc (c Celsius) String() string { return fmt.Sprintf(\"%g°C\", c) }\nfunc FToC(f float64) Celsius { return Celsius(f - 32 / 9 * 5) }\nconst Boiling Celsius = 100\n`},\n\t} {\n\t\tf, err := parser.ParseFile(fset, file.name, file.input, 0)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfiles = append(files, f)\n\t}\n\n\t// Type-check a package consisting of these files.\n\t// Type information for the imported \"fmt\" package\n\t// comes from $GOROOT/pkg/$GOOS_$GOOARCH/fmt.a.\n\tconf := types.Config{Importer: importer.Default()}\n\tpkg, err := conf.Check(\"temperature\", fset, files, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Print the tree of scopes.\n\t// For determinism, we redact addresses.\n\tvar buf bytes.Buffer\n\tpkg.Scope().WriteTo(&amp;buf, 0, true)\n\trx := regexp.MustCompile(` 0x[a-fA-F0-9]*`)\n\tfmt.Println(rx.ReplaceAllString(buf.String(), \"\"))\n\n}\n</pre> </div> </div> <h3 id=\"NewScope\">func <a href=\"https://golang.org/src/go/types/scope.go?s=967:1038#L25\">NewScope</a>  </h3> <pre data-language=\"go\">func NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope</pre> <p> NewScope returns a new, empty scope contained in the given parent scope, if any. The comment is for debugging only. </p> <h3 id=\"Scope.Child\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=1869:1904#L56\">Child</a>  </h3> <pre data-language=\"go\">func (s *Scope) Child(i int) *Scope</pre> <p> Child returns the i'th child scope for 0 &lt;= i &lt; NumChildren(). </p> <h3 id=\"Scope.Contains\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=4034:4078#L113\">Contains</a>  </h3> <pre data-language=\"go\">func (s *Scope) Contains(pos token.Pos) bool</pre> <p> Contains returns true if pos is within the scope's extent. The result is guaranteed to be valid only if the type-checked AST has complete position information. </p> <h3 id=\"Scope.End\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=3815:3846#L108\">End</a>  </h3> <pre data-language=\"go\">func (s *Scope) End() token.Pos</pre> <h3 id=\"Scope.Innermost\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=4396:4443#L122\">Innermost</a>  </h3> <pre data-language=\"go\">func (s *Scope) Innermost(pos token.Pos) *Scope</pre> <p> Innermost returns the innermost (child) scope containing pos. If pos is not within any scope, the result is nil. The result is also nil for the Universe scope. The result is guaranteed to be valid only if the type-checked AST has complete position information. </p> <h3 id=\"Scope.Insert\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=3267:3308#L88\">Insert</a>  </h3> <pre data-language=\"go\">func (s *Scope) Insert(obj Object) Object</pre> <p> Insert attempts to insert an object obj into scope s. If s already contains an alternative object alt with the same name, Insert leaves s unchanged and returns alt. Otherwise it inserts obj, sets the object's parent scope if not already set, and returns nil. </p> <h3 id=\"Scope.Len\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=1395:1420#L38\">Len</a>  </h3> <pre data-language=\"go\">func (s *Scope) Len() int</pre> <p> Len() returns the number of scope elements. </p> <h3 id=\"Scope.Lookup\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=2049:2091#L60\">Lookup</a>  </h3> <pre data-language=\"go\">func (s *Scope) Lookup(name string) Object</pre> <p> Lookup returns the object in scope s with the given name if such an object exists; otherwise the result is nil. </p> <h3 id=\"Scope.LookupParent\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=2756:2829#L74\">LookupParent</a>  </h3> <pre data-language=\"go\">func (s *Scope) LookupParent(name string, pos token.Pos) (*Scope, Object)</pre> <p> LookupParent follows the parent chain of scopes starting with s until it finds a scope where Lookup(name) returns a non-nil object, and then returns that scope and object. If a valid position pos is provided, only objects that were declared at or before pos are considered. If no such scope and object exists, the result is (nil, nil). </p> <p> Note that obj.Parent() may be different from the returned scope if the object was inserted into the scope and already had a parent at that time (see Insert, below). This can only happen for dot-imported objects whose scope is the scope of the package that exported them. </p> <h3 id=\"Scope.Names\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=1506:1538#L41\">Names</a>  </h3> <pre data-language=\"go\">func (s *Scope) Names() []string</pre> <p> Names returns the scope's element names in sorted order. </p> <h3 id=\"Scope.NumChildren\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=1741:1774#L53\">NumChildren</a>  </h3> <pre data-language=\"go\">func (s *Scope) NumChildren() int</pre> <p> NumChildren() returns the number of scopes nested in s. </p> <h3 id=\"Scope.Parent\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=1295:1326#L35\">Parent</a>  </h3> <pre data-language=\"go\">func (s *Scope) Parent() *Scope</pre> <p> Parent returns the scope's containing (parent) scope. </p> <h3 id=\"Scope.Pos\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=3766:3797#L107\">Pos</a>  </h3> <pre data-language=\"go\">func (s *Scope) Pos() token.Pos</pre> <p> Pos and End describe the scope's source code extent [pos, end). The results are guaranteed to be valid only if the type-checked AST has complete position information. The extent is undefined for Universe and package scopes. </p> <h3 id=\"Scope.String\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=5657:5688#L176\">String</a>  </h3> <pre data-language=\"go\">func (s *Scope) String() string</pre> <p> String returns a string representation of the scope, for debugging. </p> <h3 id=\"Scope.WriteTo\">func (*Scope) <a href=\"https://golang.org/src/go/types/scope.go?s=5097:5154#L149\">WriteTo</a>  </h3> <pre data-language=\"go\">func (s *Scope) WriteTo(w io.Writer, n int, recurse bool)</pre> <p> WriteTo writes a string representation of the scope to w, with the scope elements sorted by name. The level of indentation is controlled by n &gt;= 0, with n == 0 for no indentation. If recurse is set, it also writes nested (children) scopes. </p> <h2 id=\"Selection\">type Selection  </h2> <pre data-language=\"go\">type Selection struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Selection describes a selector expression x.f. For the declarations: </p> <pre data-language=\"go\">type T struct{ x int; E }\ntype E struct{}\nfunc (e E) m() {}\nvar p *T\n</pre> <p> the following relations exist: </p> <pre data-language=\"go\">Selector    Kind          Recv    Obj    Type               Index     Indirect\n\np.x         FieldVal      T       x      int                {0}       true\np.m         MethodVal     *T      m      func (e *T) m()    {1, 0}    true\nT.m         MethodExpr    T       m      func m(_ T)        {1, 0}    false\n</pre> <h3 id=\"Selection.Index\">func (*Selection) <a href=\"https://golang.org/src/go/types/selection.go?s=3090:3123#L92\">Index</a>  </h3> <pre data-language=\"go\">func (s *Selection) Index() []int</pre> <p> Index describes the path from x to f in x.f. The last index entry is the field or method index of the type declaring f; either: </p> <pre data-language=\"go\">1) the list of declared methods of a named type; or\n2) the list of methods of an interface type; or\n3) the list of fields of a struct type.\n</pre> <p> The earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0. </p> <h3 id=\"Selection.Indirect\">func (*Selection) <a href=\"https://golang.org/src/go/types/selection.go?s=3239:3274#L96\">Indirect</a>  </h3> <pre data-language=\"go\">func (s *Selection) Indirect() bool</pre> <p> Indirect reports whether any pointer indirection was required to get from x to f in x.f. </p> <h3 id=\"Selection.Kind\">func (*Selection) <a href=\"https://golang.org/src/go/types/selection.go?s=1364:1404#L39\">Kind</a>  </h3> <pre data-language=\"go\">func (s *Selection) Kind() SelectionKind</pre> <p> Kind returns the selection kind. </p> <h3 id=\"Selection.Obj\">func (*Selection) <a href=\"https://golang.org/src/go/types/selection.go?s=1620:1652#L46\">Obj</a>  </h3> <pre data-language=\"go\">func (s *Selection) Obj() Object</pre> <p> Obj returns the object denoted by x.f; a *Var for a field selection, and a *Func in all other cases. </p> <h3 id=\"Selection.Recv\">func (*Selection) <a href=\"https://golang.org/src/go/types/selection.go?s=1462:1493#L42\">Recv</a>  </h3> <pre data-language=\"go\">func (s *Selection) Recv() Type</pre> <p> Recv returns the type of x in x.f. </p> <h3 id=\"Selection.String\">func (*Selection) <a href=\"https://golang.org/src/go/types/selection.go?s=3298:3333#L98\">String</a>  </h3> <pre data-language=\"go\">func (s *Selection) String() string</pre> <h3 id=\"Selection.Type\">func (*Selection) <a href=\"https://golang.org/src/go/types/selection.go?s=1786:1817#L50\">Type</a>  </h3> <pre data-language=\"go\">func (s *Selection) Type() Type</pre> <p> Type returns the type of x.f, which may be different from the type of f. See Selection for more information. </p> <h2 id=\"SelectionKind\">type SelectionKind  </h2> <pre data-language=\"go\">type SelectionKind int</pre> <p> SelectionKind describes the kind of a selector expression x.f (excluding qualified identifiers). </p> <pre data-language=\"go\">const (\n        FieldVal   SelectionKind = iota // x.f is a struct field selector\n        MethodVal                       // x.f is a method selector\n        MethodExpr                      // x.f is a method expression\n)</pre> <h2 id=\"Signature\">type Signature  </h2> <pre data-language=\"go\">type Signature struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Signature represents a (non-builtin) function or method type. </p> <h3 id=\"NewSignature\">func <a href=\"https://golang.org/src/go/types/type.go?s=5696:5774#L205\">NewSignature</a>  </h3> <pre data-language=\"go\">func NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature</pre> <p> NewSignature returns a new function type for the given receiver, parameters, and results, either of which may be nil. If variadic is set, the function is variadic, it must have at least one parameter, and the last parameter must be of unnamed slice type. </p> <h3 id=\"Signature.Params\">func (*Signature) <a href=\"https://golang.org/src/go/types/type.go?s=6511:6546#L227\">Params</a>  </h3> <pre data-language=\"go\">func (s *Signature) Params() *Tuple</pre> <p> Params returns the parameters of signature s, or nil. </p> <h3 id=\"Signature.Recv\">func (*Signature) <a href=\"https://golang.org/src/go/types/type.go?s=6403:6434#L224\">Recv</a>  </h3> <pre data-language=\"go\">func (s *Signature) Recv() *Var</pre> <p> Recv returns the receiver of signature s (if a method), or nil if a function. </p> <p> For an abstract method, Recv returns the enclosing interface either as a *Named or an *Interface. Due to embedding, an interface may contain methods whose receiver type is a different interface. </p> <h3 id=\"Signature.Results\">func (*Signature) <a href=\"https://golang.org/src/go/types/type.go?s=6623:6659#L230\">Results</a>  </h3> <pre data-language=\"go\">func (s *Signature) Results() *Tuple</pre> <p> Results returns the results of signature s, or nil. </p> <h3 id=\"Signature.String\">func (*Signature) <a href=\"https://golang.org/src/go/types/type.go?s=13882:13917#L441\">String</a>  </h3> <pre data-language=\"go\">func (t *Signature) String() string</pre> <h3 id=\"Signature.Underlying\">func (*Signature) <a href=\"https://golang.org/src/go/types/type.go?s=13219:13256#L429\">Underlying</a>  </h3> <pre data-language=\"go\">func (t *Signature) Underlying() Type</pre> <h3 id=\"Signature.Variadic\">func (*Signature) <a href=\"https://golang.org/src/go/types/type.go?s=6739:6774#L233\">Variadic</a>  </h3> <pre data-language=\"go\">func (s *Signature) Variadic() bool</pre> <p> Variadic reports whether the signature s is variadic. </p> <h2 id=\"Sizes\">type Sizes  </h2> <pre data-language=\"go\">type Sizes interface {\n        // Alignof returns the alignment of a variable of type T.\n        // Alignof must implement the alignment guarantees required by the spec.\n        Alignof(T Type) int64\n\n        // Offsetsof returns the offsets of the given struct fields, in bytes.\n        // Offsetsof must implement the offset guarantees required by the spec.\n        Offsetsof(fields []*Var) []int64\n\n        // Sizeof returns the size of a variable of type T.\n        // Sizeof must implement the size guarantees required by the spec.\n        Sizeof(T Type) int64\n}</pre> <p> Sizes defines the sizing functions for package unsafe. </p> <h2 id=\"Slice\">type Slice  </h2> <pre data-language=\"go\">type Slice struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Slice represents a slice type. </p> <h3 id=\"NewSlice\">func <a href=\"https://golang.org/src/go/types/type.go?s=2224:2255#L107\">NewSlice</a>  </h3> <pre data-language=\"go\">func NewSlice(elem Type) *Slice</pre> <p> NewSlice returns a new slice type for the given element type. </p> <h3 id=\"Slice.Elem\">func (*Slice) <a href=\"https://golang.org/src/go/types/type.go?s=2326:2353#L110\">Elem</a>  </h3> <pre data-language=\"go\">func (s *Slice) Elem() Type</pre> <p> Elem returns the element type of slice s. </p> <h3 id=\"Slice.String\">func (*Slice) <a href=\"https://golang.org/src/go/types/type.go?s=13618:13649#L437\">String</a>  </h3> <pre data-language=\"go\">func (t *Slice) String() string</pre> <h3 id=\"Slice.Underlying\">func (*Slice) <a href=\"https://golang.org/src/go/types/type.go?s=13015:13048#L425\">Underlying</a>  </h3> <pre data-language=\"go\">func (t *Slice) Underlying() Type</pre> <h2 id=\"StdSizes\">type StdSizes  </h2> <pre data-language=\"go\">type StdSizes struct {\n        WordSize int64 // word size in bytes - must be &gt;= 4 (32bits)\n        MaxAlign int64 // maximum alignment in bytes - must be &gt;= 1\n}</pre> <p> StdSizes is a convenience type for creating commonly used Sizes. It makes the following simplifying assumptions: </p> <pre data-language=\"go\">\t- The size of explicitly sized basic types (int16, etc.) is the\n\t  specified size.\n\t- The size of strings and interfaces is 2*WordSize.\n\t- The size of slices is 3*WordSize.\n\t- The size of an array of n elements corresponds to the size of\n\t  a struct of n consecutive fields of the array's element type.\n     - The size of a struct is the offset of the last field plus that\n\t  field's size. As with all element types, if the struct is used\n\t  in an array its size must first be aligned to a multiple of the\n\t  struct's alignment.\n\t- All other types have size WordSize.\n\t- Arrays and structs are aligned per spec definition; all other\n\t  types are naturally aligned with a maximum alignment MaxAlign.\n</pre> <p> *StdSizes implements Sizes. </p> <h3 id=\"StdSizes.Alignof\">func (*StdSizes) <a href=\"https://golang.org/src/go/types/sizes.go?s=1806:1846#L38\">Alignof</a>  </h3> <pre data-language=\"go\">func (s *StdSizes) Alignof(T Type) int64</pre> <h3 id=\"StdSizes.Offsetsof\">func (*StdSizes) <a href=\"https://golang.org/src/go/types/sizes.go?s=2655:2706#L69\">Offsetsof</a>  </h3> <pre data-language=\"go\">func (s *StdSizes) Offsetsof(fields []*Var) []int64</pre> <h3 id=\"StdSizes.Sizeof\">func (*StdSizes) <a href=\"https://golang.org/src/go/types/sizes.go?s=3133:3172#L97\">Sizeof</a>  </h3> <pre data-language=\"go\">func (s *StdSizes) Sizeof(T Type) int64</pre> <h2 id=\"Struct\">type Struct  </h2> <pre data-language=\"go\">type Struct struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Struct represents a struct type. </p> <h3 id=\"NewStruct\">func <a href=\"https://golang.org/src/go/types/type.go?s=2957:3009#L124\">NewStruct</a>  </h3> <pre data-language=\"go\">func NewStruct(fields []*Var, tags []string) *Struct</pre> <p> NewStruct returns a new struct with the given fields and corresponding field tags. If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be only as long as required to hold the tag with the largest index i. Consequently, if no field has a tag, tags may be nil. </p> <h3 id=\"Struct.Field\">func (*Struct) <a href=\"https://golang.org/src/go/types/type.go?s=3483:3517#L141\">Field</a>  </h3> <pre data-language=\"go\">func (s *Struct) Field(i int) *Var</pre> <p> Field returns the i'th field for 0 &lt;= i &lt; NumFields(). </p> <h3 id=\"Struct.NumFields\">func (*Struct) <a href=\"https://golang.org/src/go/types/type.go?s=3366:3398#L138\">NumFields</a>  </h3> <pre data-language=\"go\">func (s *Struct) NumFields() int</pre> <p> NumFields returns the number of fields in the struct (including blank and anonymous fields). </p> <h3 id=\"Struct.String\">func (*Struct) <a href=\"https://golang.org/src/go/types/type.go?s=13684:13716#L438\">String</a>  </h3> <pre data-language=\"go\">func (t *Struct) String() string</pre> <h3 id=\"Struct.Tag\">func (*Struct) <a href=\"https://golang.org/src/go/types/type.go?s=3602:3636#L144\">Tag</a>  </h3> <pre data-language=\"go\">func (s *Struct) Tag(i int) string</pre> <p> Tag returns the i'th field tag for 0 &lt;= i &lt; NumFields(). </p> <h3 id=\"Struct.Underlying\">func (*Struct) <a href=\"https://golang.org/src/go/types/type.go?s=13066:13100#L426\">Underlying</a>  </h3> <pre data-language=\"go\">func (t *Struct) Underlying() Type</pre> <h2 id=\"Tuple\">type Tuple  </h2> <pre data-language=\"go\">type Tuple struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple. Tuples are used as components of signatures and to represent the type of multiple assignments; they are not first class types of Go. </p> <h3 id=\"NewTuple\">func <a href=\"https://golang.org/src/go/types/type.go?s=4364:4395#L170\">NewTuple</a>  </h3> <pre data-language=\"go\">func NewTuple(x ...*Var) *Tuple</pre> <p> NewTuple returns a new tuple for the given variables. </p> <h3 id=\"Tuple.At\">func (*Tuple) <a href=\"https://golang.org/src/go/types/type.go?s=4624:4654#L186\">At</a>  </h3> <pre data-language=\"go\">func (t *Tuple) At(i int) *Var</pre> <p> At returns the i'th variable of tuple t. </p> <h3 id=\"Tuple.Len\">func (*Tuple) <a href=\"https://golang.org/src/go/types/type.go?s=4500:4525#L178\">Len</a>  </h3> <pre data-language=\"go\">func (t *Tuple) Len() int</pre> <p> Len returns the number variables of tuple t. </p> <h3 id=\"Tuple.String\">func (*Tuple) <a href=\"https://golang.org/src/go/types/type.go?s=13816:13847#L440\">String</a>  </h3> <pre data-language=\"go\">func (t *Tuple) String() string</pre> <h3 id=\"Tuple.Underlying\">func (*Tuple) <a href=\"https://golang.org/src/go/types/type.go?s=13168:13201#L428\">Underlying</a>  </h3> <pre data-language=\"go\">func (t *Tuple) Underlying() Type</pre> <h2 id=\"Type\">type Type  </h2> <pre data-language=\"go\">type Type interface {\n        // Underlying returns the underlying type of a type.\n        Underlying() Type\n\n        // String returns a string representation of a type.\n        String() string\n}</pre> <p> A Type represents a type of Go. All types implement the Type interface. </p> <h2 id=\"TypeAndValue\">type TypeAndValue  </h2> <pre data-language=\"go\">type TypeAndValue struct {\n        Type  Type\n        Value constant.Value\n        // contains filtered or unexported fields\n}</pre> <p> TypeAndValue reports the type and value (for constants) of the corresponding expression. </p> <h3 id=\"Eval\">func <a href=\"https://golang.org/src/go/types/eval.go?s=1291:1385#L27\">Eval</a>  </h3> <pre data-language=\"go\">func Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (TypeAndValue, error)</pre> <p> Eval returns the type and, if constant, the value for the expression expr, evaluated at position pos of package pkg, which must have been derived from type-checking an AST with complete position information relative to the provided file set. </p> <p> If the expression contains function literals, their bodies are ignored (i.e., the bodies are not type-checked). </p> <p> If pkg == nil, the Universe scope is used and the provided position pos is ignored. If pkg != nil, and pos is invalid, the package scope is used. Otherwise, pos must belong to the package. </p> <p> An error is returned if pos is not within the package or if the node cannot be evaluated. </p> <p> Note: Eval should not be used instead of running Check to compute types and values, but in addition to Check. Eval will re-evaluate its argument each time, and it also does not know about the context in which an expression is used (e.g., an assignment). Thus, top- level untyped constants will return an untyped type rather then the respective context-specific type. </p> <h3 id=\"TypeAndValue.Addressable\">func (TypeAndValue) <a href=\"https://golang.org/src/go/types/api.go?s=10614:10655#L284\">Addressable</a>  </h3> <pre data-language=\"go\">func (tv TypeAndValue) Addressable() bool</pre> <p> Addressable reports whether the corresponding expression is addressable (<a href=\"https://golang.org/ref/spec#Address_operators\">https://golang.org/ref/spec#Address_operators</a>). </p> <h3 id=\"TypeAndValue.Assignable\">func (TypeAndValue) <a href=\"https://golang.org/src/go/types/api.go?s=10806:10846#L290\">Assignable</a>  </h3> <pre data-language=\"go\">func (tv TypeAndValue) Assignable() bool</pre> <p> Assignable reports whether the corresponding expression is assignable to (provided a value of the right type). </p> <h3 id=\"TypeAndValue.HasOk\">func (TypeAndValue) <a href=\"https://golang.org/src/go/types/api.go?s=11009:11044#L296\">HasOk</a>  </h3> <pre data-language=\"go\">func (tv TypeAndValue) HasOk() bool</pre> <p> HasOk reports whether the corresponding expression may be used on the lhs of a comma-ok assignment. </p> <h3 id=\"TypeAndValue.IsBuiltin\">func (TypeAndValue) <a href=\"https://golang.org/src/go/types/api.go?s=9933:9972#L261\">IsBuiltin</a>  </h3> <pre data-language=\"go\">func (tv TypeAndValue) IsBuiltin() bool</pre> <p> IsBuiltin reports whether the corresponding expression denotes a (possibly parenthesized) built-in function. </p> <h3 id=\"TypeAndValue.IsNil\">func (TypeAndValue) <a href=\"https://golang.org/src/go/types/api.go?s=10391:10426#L278\">IsNil</a>  </h3> <pre data-language=\"go\">func (tv TypeAndValue) IsNil() bool</pre> <p> IsNil reports whether the corresponding expression denotes the predeclared value nil. </p> <h3 id=\"TypeAndValue.IsType\">func (TypeAndValue) <a href=\"https://golang.org/src/go/types/api.go?s=9749:9785#L255\">IsType</a>  </h3> <pre data-language=\"go\">func (tv TypeAndValue) IsType() bool</pre> <p> IsType reports whether the corresponding expression specifies a type. </p> <h3 id=\"TypeAndValue.IsValue\">func (TypeAndValue) <a href=\"https://golang.org/src/go/types/api.go?s=10154:10191#L268\">IsValue</a>  </h3> <pre data-language=\"go\">func (tv TypeAndValue) IsValue() bool</pre> <p> IsValue reports whether the corresponding expression is a value. Builtins are not considered values. Constant values have a non- nil Value. </p> <h3 id=\"TypeAndValue.IsVoid\">func (TypeAndValue) <a href=\"https://golang.org/src/go/types/api.go?s=9607:9643#L250\">IsVoid</a>  </h3> <pre data-language=\"go\">func (tv TypeAndValue) IsVoid() bool</pre> <p> IsVoid reports whether the corresponding expression is a function call without results. </p> <h2 id=\"TypeName\">type TypeName  </h2> <pre data-language=\"go\">type TypeName struct {\n        // contains filtered or unexported fields\n}</pre> <p> A TypeName represents a declared type. </p> <h3 id=\"NewTypeName\">func <a href=\"https://golang.org/src/go/types/object.go?s=5150:5228#L151\">NewTypeName</a>  </h3> <pre data-language=\"go\">func NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName</pre> <h3 id=\"TypeName.Exported\">func (*TypeName) <a href=\"https://golang.org/src/go/types/object.go?s=2973:3007#L86\">Exported</a>  </h3> <pre data-language=\"go\">func (obj *TypeName) Exported() bool</pre> <h3 id=\"TypeName.Id\">func (*TypeName) <a href=\"https://golang.org/src/go/types/object.go?s=3049:3079#L87\">Id</a>  </h3> <pre data-language=\"go\">func (obj *TypeName) Id() string</pre> <h3 id=\"TypeName.Name\">func (*TypeName) <a href=\"https://golang.org/src/go/types/object.go?s=2854:2886#L84\">Name</a>  </h3> <pre data-language=\"go\">func (obj *TypeName) Name() string</pre> <h3 id=\"TypeName.Parent\">func (*TypeName) <a href=\"https://golang.org/src/go/types/object.go?s=2674:2708#L81\">Parent</a>  </h3> <pre data-language=\"go\">func (obj *TypeName) Parent() *Scope</pre> <h3 id=\"TypeName.Pkg\">func (*TypeName) <a href=\"https://golang.org/src/go/types/object.go?s=2795:2828#L83\">Pkg</a>  </h3> <pre data-language=\"go\">func (obj *TypeName) Pkg() *Package</pre> <h3 id=\"TypeName.Pos\">func (*TypeName) <a href=\"https://golang.org/src/go/types/object.go?s=2736:2770#L82\">Pos</a>  </h3> <pre data-language=\"go\">func (obj *TypeName) Pos() token.Pos</pre> <h3 id=\"TypeName.String\">func (*TypeName) <a href=\"https://golang.org/src/go/types/object.go?s=9420:9456#L322\">String</a>  </h3> <pre data-language=\"go\">func (obj *TypeName) String() string</pre> <h3 id=\"TypeName.Type\">func (*TypeName) <a href=\"https://golang.org/src/go/types/object.go?s=2914:2944#L85\">Type</a>  </h3> <pre data-language=\"go\">func (obj *TypeName) Type() Type</pre> <h2 id=\"Var\">type Var  </h2> <pre data-language=\"go\">type Var struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Variable represents a declared variable (including function parameters and results, and struct fields). </p> <h3 id=\"NewField\">func <a href=\"https://golang.org/src/go/types/object.go?s=6013:6099#L172\">NewField</a>  </h3> <pre data-language=\"go\">func NewField(pos token.Pos, pkg *Package, name string, typ Type, anonymous bool) *Var</pre> <h3 id=\"NewParam\">func <a href=\"https://golang.org/src/go/types/object.go?s=5822:5892#L168\">NewParam</a>  </h3> <pre data-language=\"go\">func NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var</pre> <h3 id=\"NewVar\">func <a href=\"https://golang.org/src/go/types/object.go?s=5677:5745#L164\">NewVar</a>  </h3> <pre data-language=\"go\">func NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var</pre> <h3 id=\"Var.Anonymous\">func (*Var) <a href=\"https://golang.org/src/go/types/object.go?s=6213:6245#L176\">Anonymous</a>  </h3> <pre data-language=\"go\">func (obj *Var) Anonymous() bool</pre> <h3 id=\"Var.Exported\">func (*Var) <a href=\"https://golang.org/src/go/types/object.go?s=2973:3007#L86\">Exported</a>  </h3> <pre data-language=\"go\">func (obj *Var) Exported() bool</pre> <h3 id=\"Var.Id\">func (*Var) <a href=\"https://golang.org/src/go/types/object.go?s=3049:3079#L87\">Id</a>  </h3> <pre data-language=\"go\">func (obj *Var) Id() string</pre> <h3 id=\"Var.IsField\">func (*Var) <a href=\"https://golang.org/src/go/types/object.go?s=6272:6302#L178\">IsField</a>  </h3> <pre data-language=\"go\">func (obj *Var) IsField() bool</pre> <h3 id=\"Var.Name\">func (*Var) <a href=\"https://golang.org/src/go/types/object.go?s=2854:2886#L84\">Name</a>  </h3> <pre data-language=\"go\">func (obj *Var) Name() string</pre> <h3 id=\"Var.Parent\">func (*Var) <a href=\"https://golang.org/src/go/types/object.go?s=2674:2708#L81\">Parent</a>  </h3> <pre data-language=\"go\">func (obj *Var) Parent() *Scope</pre> <h3 id=\"Var.Pkg\">func (*Var) <a href=\"https://golang.org/src/go/types/object.go?s=2795:2828#L83\">Pkg</a>  </h3> <pre data-language=\"go\">func (obj *Var) Pkg() *Package</pre> <h3 id=\"Var.Pos\">func (*Var) <a href=\"https://golang.org/src/go/types/object.go?s=2736:2770#L82\">Pos</a>  </h3> <pre data-language=\"go\">func (obj *Var) Pos() token.Pos</pre> <h3 id=\"Var.String\">func (*Var) <a href=\"https://golang.org/src/go/types/object.go?s=9491:9522#L323\">String</a>  </h3> <pre data-language=\"go\">func (obj *Var) String() string</pre> <h3 id=\"Var.Type\">func (*Var) <a href=\"https://golang.org/src/go/types/object.go?s=2914:2944#L85\">Type</a>  </h3> <pre data-language=\"go\">func (obj *Var) Type() Type</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/go/types/\" class=\"_attribution-link\">https://golang.org/pkg/go/types/</a>\n  </p>\n</div>\n","strconv/index":"<h1>Package strconv</h1>     <ul id=\"short-nav\">\n<li><code>import \"strconv\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package strconv implements conversions to and from string representations of basic data types. </p> <h3 id=\"hdr-Numeric_Conversions\">Numeric Conversions</h3> <p> The most common numeric conversions are Atoi (string to int) and Itoa (int to string). </p> <pre data-language=\"go\">i, err := strconv.Atoi(\"-42\")\ns := strconv.Itoa(-42)\n</pre> <p> These assume decimal and the Go int type. </p> <p> ParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values: </p> <pre data-language=\"go\">b, err := strconv.ParseBool(\"true\")\nf, err := strconv.ParseFloat(\"3.1415\", 64)\ni, err := strconv.ParseInt(\"-42\", 10, 64)\nu, err := strconv.ParseUint(\"42\", 10, 64)\n</pre> <p> The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss: </p> <pre data-language=\"go\">s := \"2147483647\" // biggest int32\ni64, err := strconv.ParseInt(s, 10, 32)\n...\ni := int32(i64)\n</pre> <p> FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings: </p> <pre data-language=\"go\">s := strconv.FormatBool(true)\ns := strconv.FormatFloat(3.1415, 'E', -1, 64)\ns := strconv.FormatInt(-42, 16)\ns := strconv.FormatUint(42, 16)\n</pre> <p> AppendBool, AppendFloat, AppendInt, and AppendUint are similar but append the formatted value to a destination slice. </p> <h3 id=\"hdr-String_Conversions\">String Conversions</h3> <p> Quote and QuoteToASCII convert strings to quoted Go string literals. The latter guarantees that the result is an ASCII string, by escaping any non-ASCII Unicode with \\u: </p> <pre data-language=\"go\">q := Quote(\"Hello, 世界\")\nq := QuoteToASCII(\"Hello, 世界\")\n</pre> <p> QuoteRune and QuoteRuneToASCII are similar but accept runes and return quoted Go rune literals. </p> <p> Unquote and UnquoteChar unquote Go string and rune literals. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#AppendBool\">func AppendBool(dst []byte, b bool) []byte</a></li>\n<li><a href=\"#AppendFloat\">func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte</a></li>\n<li><a href=\"#AppendInt\">func AppendInt(dst []byte, i int64, base int) []byte</a></li>\n<li><a href=\"#AppendQuote\">func AppendQuote(dst []byte, s string) []byte</a></li>\n<li><a href=\"#AppendQuoteRune\">func AppendQuoteRune(dst []byte, r rune) []byte</a></li>\n<li><a href=\"#AppendQuoteRuneToASCII\">func AppendQuoteRuneToASCII(dst []byte, r rune) []byte</a></li>\n<li><a href=\"#AppendQuoteRuneToGraphic\">func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte</a></li>\n<li><a href=\"#AppendQuoteToASCII\">func AppendQuoteToASCII(dst []byte, s string) []byte</a></li>\n<li><a href=\"#AppendQuoteToGraphic\">func AppendQuoteToGraphic(dst []byte, s string) []byte</a></li>\n<li><a href=\"#AppendUint\">func AppendUint(dst []byte, i uint64, base int) []byte</a></li>\n<li><a href=\"#Atoi\">func Atoi(s string) (int, error)</a></li>\n<li><a href=\"#CanBackquote\">func CanBackquote(s string) bool</a></li>\n<li><a href=\"#FormatBool\">func FormatBool(b bool) string</a></li>\n<li><a href=\"#FormatFloat\">func FormatFloat(f float64, fmt byte, prec, bitSize int) string</a></li>\n<li><a href=\"#FormatInt\">func FormatInt(i int64, base int) string</a></li>\n<li><a href=\"#FormatUint\">func FormatUint(i uint64, base int) string</a></li>\n<li><a href=\"#IsGraphic\">func IsGraphic(r rune) bool</a></li>\n<li><a href=\"#IsPrint\">func IsPrint(r rune) bool</a></li>\n<li><a href=\"#Itoa\">func Itoa(i int) string</a></li>\n<li><a href=\"#ParseBool\">func ParseBool(str string) (bool, error)</a></li>\n<li><a href=\"#ParseFloat\">func ParseFloat(s string, bitSize int) (float64, error)</a></li>\n<li><a href=\"#ParseInt\">func ParseInt(s string, base int, bitSize int) (i int64, err error)</a></li>\n<li><a href=\"#ParseUint\">func ParseUint(s string, base int, bitSize int) (uint64, error)</a></li>\n<li><a href=\"#Quote\">func Quote(s string) string</a></li>\n<li><a href=\"#QuoteRune\">func QuoteRune(r rune) string</a></li>\n<li><a href=\"#QuoteRuneToASCII\">func QuoteRuneToASCII(r rune) string</a></li>\n<li><a href=\"#QuoteRuneToGraphic\">func QuoteRuneToGraphic(r rune) string</a></li>\n<li><a href=\"#QuoteToASCII\">func QuoteToASCII(s string) string</a></li>\n<li><a href=\"#QuoteToGraphic\">func QuoteToGraphic(s string) string</a></li>\n<li><a href=\"#Unquote\">func Unquote(s string) (string, error)</a></li>\n<li><a href=\"#UnquoteChar\">func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)</a></li>\n<li><a href=\"#NumError\">type NumError</a></li>\n<li> <a href=\"#NumError.Error\">func (e *NumError) Error() string</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_AppendBool\">AppendBool</a></dd> <dd><a class=\"exampleLink\" href=\"#example_AppendFloat\">AppendFloat</a></dd> <dd><a class=\"exampleLink\" href=\"#example_AppendInt\">AppendInt</a></dd> <dd><a class=\"exampleLink\" href=\"#example_AppendQuote\">AppendQuote</a></dd> <dd><a class=\"exampleLink\" href=\"#example_AppendQuoteRune\">AppendQuoteRune</a></dd> <dd><a class=\"exampleLink\" href=\"#example_AppendQuoteRuneToASCII\">AppendQuoteRuneToASCII</a></dd> <dd><a class=\"exampleLink\" href=\"#example_AppendQuoteToASCII\">AppendQuoteToASCII</a></dd> <dd><a class=\"exampleLink\" href=\"#example_AppendUint\">AppendUint</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Atoi\">Atoi</a></dd> <dd><a class=\"exampleLink\" href=\"#example_CanBackquote\">CanBackquote</a></dd> <dd><a class=\"exampleLink\" href=\"#example_FormatBool\">FormatBool</a></dd> <dd><a class=\"exampleLink\" href=\"#example_FormatFloat\">FormatFloat</a></dd> <dd><a class=\"exampleLink\" href=\"#example_FormatInt\">FormatInt</a></dd> <dd><a class=\"exampleLink\" href=\"#example_FormatUint\">FormatUint</a></dd> <dd><a class=\"exampleLink\" href=\"#example_IsPrint\">IsPrint</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Itoa\">Itoa</a></dd> <dd><a class=\"exampleLink\" href=\"#example_NumError\">NumError</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ParseBool\">ParseBool</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ParseFloat\">ParseFloat</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ParseInt\">ParseInt</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ParseUint\">ParseUint</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Quote\">Quote</a></dd> <dd><a class=\"exampleLink\" href=\"#example_QuoteRune\">QuoteRune</a></dd> <dd><a class=\"exampleLink\" href=\"#example_QuoteRuneToASCII\">QuoteRuneToASCII</a></dd> <dd><a class=\"exampleLink\" href=\"#example_QuoteToASCII\">QuoteToASCII</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Unquote\">Unquote</a></dd> <dd><a class=\"exampleLink\" href=\"#example_UnquoteChar\">UnquoteChar</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/strconv/atob.go\">atob.go</a> <a href=\"https://golang.org/src/strconv/atof.go\">atof.go</a> <a href=\"https://golang.org/src/strconv/atoi.go\">atoi.go</a> <a href=\"https://golang.org/src/strconv/decimal.go\">decimal.go</a> <a href=\"https://golang.org/src/strconv/doc.go\">doc.go</a> <a href=\"https://golang.org/src/strconv/extfloat.go\">extfloat.go</a> <a href=\"https://golang.org/src/strconv/ftoa.go\">ftoa.go</a> <a href=\"https://golang.org/src/strconv/isprint.go\">isprint.go</a> <a href=\"https://golang.org/src/strconv/itoa.go\">itoa.go</a> <a href=\"https://golang.org/src/strconv/quote.go\">quote.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const IntSize = intSize</pre> <p> IntSize is the size in bits of an int or uint value. </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrRange = errors.New(\"value out of range\")</pre> <p> ErrRange indicates that a value is out of range for the target type. </p> <pre data-language=\"go\">var ErrSyntax = errors.New(\"invalid syntax\")</pre> <p> ErrSyntax indicates that a value does not have the right syntax for the target type. </p> <h2 id=\"AppendBool\">func AppendBool  </h2> <pre data-language=\"go\">func AppendBool(dst []byte, b bool) []byte</pre> <p> AppendBool appends \"true\" or \"false\", according to the value of b, to dst and returns the extended buffer. </p> <div id=\"example_AppendBool\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tb := []byte(\"bool:\")\n\tb = strconv.AppendBool(b, true)\n\tfmt.Println(string(b))\n\n}\n</pre> </div> </div> <h2 id=\"AppendFloat\">func AppendFloat  </h2> <pre data-language=\"go\">func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte</pre> <p> AppendFloat appends the string form of the floating-point number f, as generated by FormatFloat, to dst and returns the extended buffer. </p> <div id=\"example_AppendFloat\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tb32 := []byte(\"float32:\")\n\tb32 = strconv.AppendFloat(b32, 3.1415926535, 'E', -1, 32)\n\tfmt.Println(string(b32))\n\n\tb64 := []byte(\"float64:\")\n\tb64 = strconv.AppendFloat(b64, 3.1415926535, 'E', -1, 64)\n\tfmt.Println(string(b64))\n\n}\n</pre> </div> </div> <h2 id=\"AppendInt\">func AppendInt  </h2> <pre data-language=\"go\">func AppendInt(dst []byte, i int64, base int) []byte</pre> <p> AppendInt appends the string form of the integer i, as generated by FormatInt, to dst and returns the extended buffer. </p> <div id=\"example_AppendInt\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tb10 := []byte(\"int (base 10):\")\n\tb10 = strconv.AppendInt(b10, -42, 10)\n\tfmt.Println(string(b10))\n\n\tb16 := []byte(\"int (base 16):\")\n\tb16 = strconv.AppendInt(b16, -42, 16)\n\tfmt.Println(string(b16))\n\n}\n</pre> </div> </div> <h2 id=\"AppendQuote\">func AppendQuote  </h2> <pre data-language=\"go\">func AppendQuote(dst []byte, s string) []byte</pre> <p> AppendQuote appends a double-quoted Go string literal representing s, as generated by Quote, to dst and returns the extended buffer. </p> <div id=\"example_AppendQuote\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tb := []byte(\"quote:\")\n\tb = strconv.AppendQuote(b, `\"Fran &amp; Freddie's Diner\"`)\n\tfmt.Println(string(b))\n\n}\n</pre> </div> </div> <h2 id=\"AppendQuoteRune\">func AppendQuoteRune  </h2> <pre data-language=\"go\">func AppendQuoteRune(dst []byte, r rune) []byte</pre> <p> AppendQuoteRune appends a single-quoted Go character literal representing the rune, as generated by QuoteRune, to dst and returns the extended buffer. </p> <div id=\"example_AppendQuoteRune\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tb := []byte(\"rune:\")\n\tb = strconv.AppendQuoteRune(b, '☺')\n\tfmt.Println(string(b))\n\n}\n</pre> </div> </div> <h2 id=\"AppendQuoteRuneToASCII\">func AppendQuoteRuneToASCII  </h2> <pre data-language=\"go\">func AppendQuoteRuneToASCII(dst []byte, r rune) []byte</pre> <p> AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToASCII, to dst and returns the extended buffer. </p> <div id=\"example_AppendQuoteRuneToASCII\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tb := []byte(\"rune (ascii):\")\n\tb = strconv.AppendQuoteRuneToASCII(b, '☺')\n\tfmt.Println(string(b))\n\n}\n</pre> </div> </div> <h2 id=\"AppendQuoteRuneToGraphic\">func AppendQuoteRuneToGraphic  </h2> <pre data-language=\"go\">func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte</pre> <p> AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToGraphic, to dst and returns the extended buffer. </p> <h2 id=\"AppendQuoteToASCII\">func AppendQuoteToASCII  </h2> <pre data-language=\"go\">func AppendQuoteToASCII(dst []byte, s string) []byte</pre> <p> AppendQuoteToASCII appends a double-quoted Go string literal representing s, as generated by QuoteToASCII, to dst and returns the extended buffer. </p> <div id=\"example_AppendQuoteToASCII\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tb := []byte(\"quote (ascii):\")\n\tb = strconv.AppendQuoteToASCII(b, `\"Fran &amp; Freddie's Diner\"`)\n\tfmt.Println(string(b))\n\n}\n</pre> </div> </div> <h2 id=\"AppendQuoteToGraphic\">func AppendQuoteToGraphic  </h2> <pre data-language=\"go\">func AppendQuoteToGraphic(dst []byte, s string) []byte</pre> <p> AppendQuoteToGraphic appends a double-quoted Go string literal representing s, as generated by QuoteToGraphic, to dst and returns the extended buffer. </p> <h2 id=\"AppendUint\">func AppendUint  </h2> <pre data-language=\"go\">func AppendUint(dst []byte, i uint64, base int) []byte</pre> <p> AppendUint appends the string form of the unsigned integer i, as generated by FormatUint, to dst and returns the extended buffer. </p> <div id=\"example_AppendUint\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tb10 := []byte(\"uint (base 10):\")\n\tb10 = strconv.AppendUint(b10, 42, 10)\n\tfmt.Println(string(b10))\n\n\tb16 := []byte(\"uint (base 16):\")\n\tb16 = strconv.AppendUint(b16, 42, 16)\n\tfmt.Println(string(b16))\n\n}\n</pre> </div> </div> <h2 id=\"Atoi\">func Atoi  </h2> <pre data-language=\"go\">func Atoi(s string) (int, error)</pre> <p> Atoi returns the result of ParseInt(s, 10, 0) converted to type int. </p> <div id=\"example_Atoi\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tv := \"10\"\n\tif s, err := strconv.Atoi(v); err == nil {\n\t\tfmt.Printf(\"%T, %v\", s, s)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"CanBackquote\">func CanBackquote  </h2> <pre data-language=\"go\">func CanBackquote(s string) bool</pre> <p> CanBackquote reports whether the string s can be represented unchanged as a single-line backquoted string without control characters other than tab. </p> <div id=\"example_CanBackquote\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tfmt.Println(strconv.CanBackquote(\"Fran &amp; Freddie's Diner ☺\"))\n\tfmt.Println(strconv.CanBackquote(\"`can't backquote this`\"))\n\n}\n</pre> </div> </div> <h2 id=\"FormatBool\">func FormatBool  </h2> <pre data-language=\"go\">func FormatBool(b bool) string</pre> <p> FormatBool returns \"true\" or \"false\" according to the value of b </p> <div id=\"example_FormatBool\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tv := true\n\ts := strconv.FormatBool(v)\n\tfmt.Printf(\"%T, %v\\n\", s, s)\n\n}\n</pre> </div> </div> <h2 id=\"FormatFloat\">func FormatFloat  </h2> <pre data-language=\"go\">func FormatFloat(f float64, fmt byte, prec, bitSize int) string</pre> <p> FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64). </p> <p> The format fmt is one of 'b' (-ddddp±ddd, a binary exponent), 'e' (-d.dddde±dd, a decimal exponent), 'E' (-d.ddddE±dd, a decimal exponent), 'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise), or 'G' ('E' for large exponents, 'f' otherwise). </p> <p> The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', and 'G' formats. For 'e', 'E', and 'f' it is the number of digits after the decimal point. For 'g' and 'G' it is the total number of digits. The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly. </p> <div id=\"example_FormatFloat\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tv := 3.1415926535\n\n\ts32 := strconv.FormatFloat(v, 'E', -1, 32)\n\tfmt.Printf(\"%T, %v\\n\", s32, s32)\n\n\ts64 := strconv.FormatFloat(v, 'E', -1, 64)\n\tfmt.Printf(\"%T, %v\\n\", s64, s64)\n\n}\n</pre> </div> </div> <h2 id=\"FormatInt\">func FormatInt  </h2> <pre data-language=\"go\">func FormatInt(i int64, base int) string</pre> <p> FormatInt returns the string representation of i in the given base, for 2 &lt;= base &lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &gt;= 10. </p> <div id=\"example_FormatInt\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tv := int64(-42)\n\n\ts10 := strconv.FormatInt(v, 10)\n\tfmt.Printf(\"%T, %v\\n\", s10, s10)\n\n\ts16 := strconv.FormatInt(v, 16)\n\tfmt.Printf(\"%T, %v\\n\", s16, s16)\n\n}\n</pre> </div> </div> <h2 id=\"FormatUint\">func FormatUint  </h2> <pre data-language=\"go\">func FormatUint(i uint64, base int) string</pre> <p> FormatUint returns the string representation of i in the given base, for 2 &lt;= base &lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &gt;= 10. </p> <div id=\"example_FormatUint\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tv := uint64(42)\n\n\ts10 := strconv.FormatUint(v, 10)\n\tfmt.Printf(\"%T, %v\\n\", s10, s10)\n\n\ts16 := strconv.FormatUint(v, 16)\n\tfmt.Printf(\"%T, %v\\n\", s16, s16)\n\n}\n</pre> </div> </div> <h2 id=\"IsGraphic\">func IsGraphic  </h2> <pre data-language=\"go\">func IsGraphic(r rune) bool</pre> <p> IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs. </p> <h2 id=\"IsPrint\">func IsPrint  </h2> <pre data-language=\"go\">func IsPrint(r rune) bool</pre> <p> IsPrint reports whether the rune is defined as printable by Go, with the same definition as unicode.IsPrint: letters, numbers, punctuation, symbols and ASCII space. </p> <div id=\"example_IsPrint\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tc := strconv.IsPrint('\\u263a')\n\tfmt.Println(c)\n\n\tbel := strconv.IsPrint('\\007')\n\tfmt.Println(bel)\n\n}\n</pre> </div> </div> <h2 id=\"Itoa\">func Itoa  </h2> <pre data-language=\"go\">func Itoa(i int) string</pre> <p> Itoa is shorthand for FormatInt(int64(i), 10). </p> <div id=\"example_Itoa\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\ti := 10\n\ts := strconv.Itoa(i)\n\tfmt.Printf(\"%T, %v\\n\", s, s)\n\n}\n</pre> </div> </div> <h2 id=\"ParseBool\">func ParseBool  </h2> <pre data-language=\"go\">func ParseBool(str string) (bool, error)</pre> <p> ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error. </p> <div id=\"example_ParseBool\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tv := \"true\"\n\tif s, err := strconv.ParseBool(v); err == nil {\n\t\tfmt.Printf(\"%T, %v\\n\", s, s)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"ParseFloat\">func ParseFloat  </h2> <pre data-language=\"go\">func ParseFloat(s string, bitSize int) (float64, error)</pre> <p> ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value. </p> <p> If s is well-formed and near a valid floating point number, ParseFloat returns the nearest floating point number rounded using IEEE754 unbiased rounding. </p> <p> The errors that ParseFloat returns have concrete type *NumError and include err.Num = s. </p> <p> If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax. </p> <p> If s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = ±Inf, err.Err = ErrRange. </p> <div id=\"example_ParseFloat\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tv := \"3.1415926535\"\n\tif s, err := strconv.ParseFloat(v, 32); err == nil {\n\t\tfmt.Printf(\"%T, %v\\n\", s, s)\n\t}\n\tif s, err := strconv.ParseFloat(v, 64); err == nil {\n\t\tfmt.Printf(\"%T, %v\\n\", s, s)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"ParseInt\">func ParseInt  </h2> <pre data-language=\"go\">func ParseInt(s string, base int, bitSize int) (i int64, err error)</pre> <p> ParseInt interprets a string s in the given base (2 to 36) and returns the corresponding value i. If base == 0, the base is implied by the string's prefix: base 16 for \"0x\", base 8 for \"0\", and base 10 otherwise. </p> <p> The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. </p> <p> The errors that ParseInt returns have concrete type *NumError and include err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the appropriate bitSize and sign. </p> <div id=\"example_ParseInt\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tv32 := \"-354634382\"\n\tif s, err := strconv.ParseInt(v32, 10, 32); err == nil {\n\t\tfmt.Printf(\"%T, %v\\n\", s, s)\n\t}\n\tif s, err := strconv.ParseInt(v32, 16, 32); err == nil {\n\t\tfmt.Printf(\"%T, %v\\n\", s, s)\n\t}\n\n\tv64 := \"-3546343826724305832\"\n\tif s, err := strconv.ParseInt(v64, 10, 64); err == nil {\n\t\tfmt.Printf(\"%T, %v\\n\", s, s)\n\t}\n\tif s, err := strconv.ParseInt(v64, 16, 64); err == nil {\n\t\tfmt.Printf(\"%T, %v\\n\", s, s)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"ParseUint\">func ParseUint  </h2> <pre data-language=\"go\">func ParseUint(s string, base int, bitSize int) (uint64, error)</pre> <p> ParseUint is like ParseInt but for unsigned numbers. </p> <div id=\"example_ParseUint\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tv := \"42\"\n\tif s, err := strconv.ParseUint(v, 10, 32); err == nil {\n\t\tfmt.Printf(\"%T, %v\\n\", s, s)\n\t}\n\tif s, err := strconv.ParseUint(v, 10, 64); err == nil {\n\t\tfmt.Printf(\"%T, %v\\n\", s, s)\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"Quote\">func Quote  </h2> <pre data-language=\"go\">func Quote(s string) string</pre> <p> Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by IsPrint. </p> <div id=\"example_Quote\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\ts := strconv.Quote(`\"Fran &amp; Freddie's Diner\t☺\"`)\n\tfmt.Println(s)\n\n}\n</pre> </div> </div> <h2 id=\"QuoteRune\">func QuoteRune  </h2> <pre data-language=\"go\">func QuoteRune(r rune) string</pre> <p> QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by IsPrint. </p> <div id=\"example_QuoteRune\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\ts := strconv.QuoteRune('☺')\n\tfmt.Println(s)\n\n}\n</pre> </div> </div> <h2 id=\"QuoteRuneToASCII\">func QuoteRuneToASCII  </h2> <pre data-language=\"go\">func QuoteRuneToASCII(r rune) string</pre> <p> QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsPrint. </p> <div id=\"example_QuoteRuneToASCII\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\ts := strconv.QuoteRuneToASCII('☺')\n\tfmt.Println(s)\n\n}\n</pre> </div> </div> <h2 id=\"QuoteRuneToGraphic\">func QuoteRuneToGraphic  </h2> <pre data-language=\"go\">func QuoteRuneToGraphic(r rune) string</pre> <p> QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic. </p> <h2 id=\"QuoteToASCII\">func QuoteToASCII  </h2> <pre data-language=\"go\">func QuoteToASCII(s string) string</pre> <p> QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsPrint. </p> <div id=\"example_QuoteToASCII\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\ts := strconv.QuoteToASCII(`\"Fran &amp; Freddie's Diner\t☺\"`)\n\tfmt.Println(s)\n\n}\n</pre> </div> </div> <h2 id=\"QuoteToGraphic\">func QuoteToGraphic  </h2> <pre data-language=\"go\">func QuoteToGraphic(s string) string</pre> <p> QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic. </p> <h2 id=\"Unquote\">func Unquote  </h2> <pre data-language=\"go\">func Unquote(s string) (string, error)</pre> <p> Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string.) </p> <div id=\"example_Unquote\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\ttest := func(s string) {\n\t\tt, err := strconv.Unquote(s)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Unquote(%#v): %v\\n\", s, err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Unquote(%#v) = %v\\n\", s, t)\n\t\t}\n\t}\n\n\ts := `\\\"Fran &amp; Freddie's Diner\\t\\u263a\\\"\\\"`\n\t// If the string doesn't have quotes, it can't be unquoted.\n\ttest(s) // invalid syntax\n\ttest(\"`\" + s + \"`\")\n\ttest(`\"` + s + `\"`)\n\ttest(`'\\u263a'`)\n\n}\n</pre> </div> </div> <h2 id=\"UnquoteChar\">func UnquoteChar  </h2> <pre data-language=\"go\">func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)</pre> <p> UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values: </p> <pre data-language=\"go\">1) value, the decoded Unicode code point or byte value;\n2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\n3) tail, the remainder of the string after the character; and\n4) an error that will be nil if the character is syntactically valid.\n</pre> <p> The second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \\' and disallows unescaped '. If set to a double quote, it permits \\\" and disallows unescaped \". If set to zero, it does not permit either escape and allows both quote characters to appear unescaped. </p> <div id=\"example_UnquoteChar\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tv, mb, t, err := strconv.UnquoteChar(`\\\"Fran &amp; Freddie's Diner\\\"`, '\"')\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"value:\", string(v))\n\tfmt.Println(\"multibyte:\", mb)\n\tfmt.Println(\"tail:\", t)\n\n}\n</pre> </div> </div> <h2 id=\"NumError\">type NumError  </h2> <pre data-language=\"go\">type NumError struct {\n        Func string // the failing function (ParseBool, ParseInt, ParseUint, ParseFloat)\n        Num  string // the input\n        Err  error  // the reason the conversion failed (ErrRange, ErrSyntax)\n}</pre> <p> A NumError records a failed conversion. </p> <div id=\"example_NumError\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tstr := \"Not a number\"\n\tif _, err := strconv.ParseFloat(str, 64); err != nil {\n\t\te := err.(*strconv.NumError)\n\t\tfmt.Println(\"Func:\", e.Func)\n\t\tfmt.Println(\"Num:\", e.Num)\n\t\tfmt.Println(\"Err:\", e.Err)\n\t\tfmt.Println(err)\n\t}\n\n}\n</pre> </div> </div> <h3 id=\"NumError.Error\">func (*NumError) <a href=\"https://golang.org/src/strconv/atoi.go?s=697:730#L12\">Error</a>  </h3> <pre data-language=\"go\">func (e *NumError) Error() string</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/strconv/\" class=\"_attribution-link\">https://golang.org/pkg/strconv/</a>\n  </p>\n</div>\n","unsafe/index":"<h1>Package unsafe</h1>     <ul id=\"short-nav\">\n<li><code>import \"unsafe\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package unsafe contains operations that step around the type safety of Go programs. </p> <p> Packages that import unsafe may be non-portable and are not protected by the Go 1 compatibility guidelines. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Alignof\">func Alignof(x ArbitraryType) uintptr</a></li>\n<li><a href=\"#Offsetof\">func Offsetof(x ArbitraryType) uintptr</a></li>\n<li><a href=\"#Sizeof\">func Sizeof(x ArbitraryType) uintptr</a></li>\n<li><a href=\"#ArbitraryType\">type ArbitraryType</a></li>\n<li><a href=\"#Pointer\">type Pointer</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/unsafe/unsafe.go\">unsafe.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Alignof\">func Alignof  </h2> <pre data-language=\"go\">func Alignof(x ArbitraryType) uintptr</pre> <p> Alignof takes an expression x of any type and returns the required alignment of a hypothetical variable v as if v was declared via var v = x. It is the largest value m such that the address of v is always zero mod m. It is the same as the value returned by reflect.TypeOf(x).Align(). As a special case, if a variable s is of struct type and f is a field within that struct, then Alignof(s.f) will return the required alignment of a field of that type within a struct. This case is the same as the value returned by reflect.TypeOf(s.f).FieldAlign(). </p> <h2 id=\"Offsetof\">func Offsetof  </h2> <pre data-language=\"go\">func Offsetof(x ArbitraryType) uintptr</pre> <p> Offsetof returns the offset within the struct of the field represented by x, which must be of the form structValue.field. In other words, it returns the number of bytes between the start of the struct and the start of the field. </p> <h2 id=\"Sizeof\">func Sizeof  </h2> <pre data-language=\"go\">func Sizeof(x ArbitraryType) uintptr</pre> <p> Sizeof takes an expression x of any type and returns the size in bytes of a hypothetical variable v as if v was declared via var v = x. The size does not include any memory possibly referenced by x. For instance, if x is a slice, Sizeof returns the size of the slice descriptor, not the size of the memory referenced by the slice. </p> <h2 id=\"ArbitraryType\">type ArbitraryType  </h2> <pre data-language=\"go\">type ArbitraryType int</pre> <p> ArbitraryType is here for the purposes of documentation only and is not actually part of the unsafe package. It represents the type of an arbitrary Go expression. </p> <h2 id=\"Pointer\">type Pointer  </h2> <pre data-language=\"go\">type Pointer *ArbitraryType</pre> <p> Pointer represents a pointer to an arbitrary type. There are four special operations available for type Pointer that are not available for other types: </p> <pre data-language=\"go\">- A pointer value of any type can be converted to a Pointer.\n- A Pointer can be converted to a pointer value of any type.\n- A uintptr can be converted to a Pointer.\n- A Pointer can be converted to a uintptr.\n</pre> <p> Pointer therefore allows a program to defeat the type system and read and write arbitrary memory. It should be used with extreme care. </p> <p> The following patterns involving Pointer are valid. Code not using these patterns is likely to be invalid today or to become invalid in the future. Even the valid patterns below come with important caveats. </p> <p> Running \"go vet\" can help find uses of Pointer that do not conform to these patterns, but silence from \"go vet\" is not a guarantee that the code is valid. </p> <p> (1) Conversion of a *T1 to Pointer to *T2. </p> <p> Provided that T2 is no larger than T1 and that the two share an equivalent memory layout, this conversion allows reinterpreting data of one type as data of another type. An example is the implementation of math.Float64bits: </p> <pre data-language=\"go\">func Float64bits(f float64) uint64 {\n\treturn *(*uint64)(unsafe.Pointer(&amp;f))\n}\n</pre> <p> (2) Conversion of a Pointer to a uintptr (but not back to Pointer). </p> <p> Converting a Pointer to a uintptr produces the memory address of the value pointed at, as an integer. The usual use for such a uintptr is to print it. </p> <p> Conversion of a uintptr back to Pointer is not valid in general. </p> <p> A uintptr is an integer, not a reference. Converting a Pointer to a uintptr creates an integer value with no pointer semantics. Even if a uintptr holds the address of some object, the garbage collector will not update that uintptr's value if the object moves, nor will that uintptr keep the object from being reclaimed. </p> <p> The remaining patterns enumerate the only valid conversions from uintptr to Pointer. </p> <p> (3) Conversion of a Pointer to a uintptr and back, with arithmetic. </p> <p> If p points into an allocated object, it can be advanced through the object by conversion to uintptr, addition of an offset, and conversion back to Pointer. </p> <pre data-language=\"go\">p = unsafe.Pointer(uintptr(p) + offset)\n</pre> <p> The most common use of this pattern is to access fields in a struct or elements of an array: </p> <pre data-language=\"go\">// equivalent to f := unsafe.Pointer(&amp;s.f)\nf := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))\n\n// equivalent to e := unsafe.Pointer(&amp;x[i])\ne := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;x[0])) + i*unsafe.Sizeof(x[0]))\n</pre> <p> It is valid both to add and to subtract offsets from a pointer in this way, but the result must continue to point into the original allocated object. Unlike in C, it is not valid to advance a pointer just beyond the end of its original allocation: </p> <pre data-language=\"go\">// INVALID: end points outside allocated space.\nvar s thing\nend = unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + unsafe.Sizeof(s))\n\n// INVALID: end points outside allocated space.\nb := make([]byte, n)\nend = unsafe.Pointer(uintptr(unsafe.Pointer(&amp;b[0])) + uintptr(n))\n</pre> <p> Note that both conversions must appear in the same expression, with only the intervening arithmetic between them: </p> <pre data-language=\"go\">// INVALID: uintptr cannot be stored in variable\n// before conversion back to Pointer.\nu := uintptr(p)\np = unsafe.Pointer(u + offset)\n</pre> <p> (4) Conversion of a Pointer to a uintptr when calling syscall.Syscall. </p> <p> The Syscall functions in package syscall pass their uintptr arguments directly to the operating system, which then may, depending on the details of the call, reinterpret some of them as pointers. That is, the system call implementation is implicitly converting certain arguments back from uintptr to pointer. </p> <p> If a pointer argument must be converted to uintptr for use as an argument, that conversion must appear in the call expression itself: </p> <pre data-language=\"go\">syscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n))\n</pre> <p> The compiler handles a Pointer converted to a uintptr in the argument list of a call to a function implemented in assembly by arranging that the referenced allocated object, if any, is retained and not moved until the call completes, even though from the types alone it would appear that the object is no longer needed during the call. </p> <p> For the compiler to recognize this pattern, the conversion must appear in the argument list: </p> <pre data-language=\"go\">// INVALID: uintptr cannot be stored in variable\n// before implicit conversion back to Pointer during system call.\nu := uintptr(unsafe.Pointer(p))\nsyscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n))\n</pre> <p> (5) Conversion of the result of reflect.Value.Pointer or reflect.Value.UnsafeAddr from uintptr to Pointer. </p> <p> Package reflect's Value methods named Pointer and UnsafeAddr return type uintptr instead of unsafe.Pointer to keep callers from changing the result to an arbitrary type without first importing \"unsafe\". However, this means that the result is fragile and must be converted to Pointer immediately after making the call, in the same expression: </p> <pre data-language=\"go\">p := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))\n</pre> <p> As in the cases above, it is invalid to store the result before the conversion: </p> <pre data-language=\"go\">// INVALID: uintptr cannot be stored in variable\n// before conversion back to Pointer.\nu := reflect.ValueOf(new(int)).Pointer()\np := (*int)(unsafe.Pointer(u))\n</pre> <p> (6) Conversion of a reflect.SliceHeader or reflect.StringHeader Data field to or from Pointer. </p> <p> As in the previous case, the reflect data structures SliceHeader and StringHeader declare the field Data as a uintptr to keep callers from changing the result to an arbitrary type without first importing \"unsafe\". However, this means that SliceHeader and StringHeader are only valid when interpreting the content of an actual slice or string value. </p> <pre data-language=\"go\">var s string\nhdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) // case 1\nhdr.Data = uintptr(unsafe.Pointer(p))              // case 6 (this case)\nhdr.Len = uintptr(n)\n</pre> <p> In this usage hdr.Data is really an alternate way to refer to the underlying pointer in the slice header, not a uintptr variable itself. </p> <p> In general, reflect.SliceHeader and reflect.StringHeader should be used only as *reflect.SliceHeader and *reflect.StringHeader pointing at actual slices or strings, never as plain structs. A program should not declare or allocate variables of these struct types. </p> <pre data-language=\"go\">// INVALID: a directly-declared header will not hold Data as a reference.\nvar hdr reflect.StringHeader\nhdr.Data = uintptr(unsafe.Pointer(p))\nhdr.Len = uintptr(n)\ns := *(*string)(unsafe.Pointer(&amp;hdr)) // p possibly already lost\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/unsafe/\" class=\"_attribution-link\">https://golang.org/pkg/unsafe/</a>\n  </p>\n</div>\n","reflect/index":"<h1>Package reflect</h1>     <ul id=\"short-nav\">\n<li><code>import \"reflect\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. The typical use is to take a value with static type interface{} and extract its dynamic type information by calling TypeOf, which returns a Type. </p> <p> A call to ValueOf returns a Value representing the run-time data. Zero takes a Type and returns a Value representing a zero value for that type. </p> <p> See \"The Laws of Reflection\" for an introduction to reflection in Go: <a href=\"https://golang.org/doc/articles/laws_of_reflection.html\">https://golang.org/doc/articles/laws_of_reflection.html</a> </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Copy\">func Copy(dst, src Value) int</a></li>\n<li><a href=\"#DeepEqual\">func DeepEqual(x, y interface{}) bool</a></li>\n<li><a href=\"#Select\">func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</a></li>\n<li><a href=\"#ChanDir\">type ChanDir</a></li>\n<li> <a href=\"#ChanDir.String\">func (d ChanDir) String() string</a>\n</li>\n<li><a href=\"#Kind\">type Kind</a></li>\n<li> <a href=\"#Kind.String\">func (k Kind) String() string</a>\n</li>\n<li><a href=\"#Method\">type Method</a></li>\n<li><a href=\"#SelectCase\">type SelectCase</a></li>\n<li><a href=\"#SelectDir\">type SelectDir</a></li>\n<li><a href=\"#SliceHeader\">type SliceHeader</a></li>\n<li><a href=\"#StringHeader\">type StringHeader</a></li>\n<li><a href=\"#StructField\">type StructField</a></li>\n<li><a href=\"#StructTag\">type StructTag</a></li>\n<li> <a href=\"#StructTag.Get\">func (tag StructTag) Get(key string) string</a>\n</li>\n<li> <a href=\"#StructTag.Lookup\">func (tag StructTag) Lookup(key string) (value string, ok bool)</a>\n</li>\n<li><a href=\"#Type\">type Type</a></li>\n<li> <a href=\"#ArrayOf\">func ArrayOf(count int, elem Type) Type</a>\n</li>\n<li> <a href=\"#ChanOf\">func ChanOf(dir ChanDir, t Type) Type</a>\n</li>\n<li> <a href=\"#FuncOf\">func FuncOf(in, out []Type, variadic bool) Type</a>\n</li>\n<li> <a href=\"#MapOf\">func MapOf(key, elem Type) Type</a>\n</li>\n<li> <a href=\"#PtrTo\">func PtrTo(t Type) Type</a>\n</li>\n<li> <a href=\"#SliceOf\">func SliceOf(t Type) Type</a>\n</li>\n<li> <a href=\"#StructOf\">func StructOf(fields []StructField) Type</a>\n</li>\n<li> <a href=\"#TypeOf\">func TypeOf(i interface{}) Type</a>\n</li>\n<li><a href=\"#Value\">type Value</a></li>\n<li> <a href=\"#Append\">func Append(s Value, x ...Value) Value</a>\n</li>\n<li> <a href=\"#AppendSlice\">func AppendSlice(s, t Value) Value</a>\n</li>\n<li> <a href=\"#Indirect\">func Indirect(v Value) Value</a>\n</li>\n<li> <a href=\"#MakeChan\">func MakeChan(typ Type, buffer int) Value</a>\n</li>\n<li> <a href=\"#MakeFunc\">func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value</a>\n</li>\n<li> <a href=\"#MakeMap\">func MakeMap(typ Type) Value</a>\n</li>\n<li> <a href=\"#MakeSlice\">func MakeSlice(typ Type, len, cap int) Value</a>\n</li>\n<li> <a href=\"#New\">func New(typ Type) Value</a>\n</li>\n<li> <a href=\"#NewAt\">func NewAt(typ Type, p unsafe.Pointer) Value</a>\n</li>\n<li> <a href=\"#ValueOf\">func ValueOf(i interface{}) Value</a>\n</li>\n<li> <a href=\"#Zero\">func Zero(typ Type) Value</a>\n</li>\n<li> <a href=\"#Value.Addr\">func (v Value) Addr() Value</a>\n</li>\n<li> <a href=\"#Value.Bool\">func (v Value) Bool() bool</a>\n</li>\n<li> <a href=\"#Value.Bytes\">func (v Value) Bytes() []byte</a>\n</li>\n<li> <a href=\"#Value.Call\">func (v Value) Call(in []Value) []Value</a>\n</li>\n<li> <a href=\"#Value.CallSlice\">func (v Value) CallSlice(in []Value) []Value</a>\n</li>\n<li> <a href=\"#Value.CanAddr\">func (v Value) CanAddr() bool</a>\n</li>\n<li> <a href=\"#Value.CanInterface\">func (v Value) CanInterface() bool</a>\n</li>\n<li> <a href=\"#Value.CanSet\">func (v Value) CanSet() bool</a>\n</li>\n<li> <a href=\"#Value.Cap\">func (v Value) Cap() int</a>\n</li>\n<li> <a href=\"#Value.Close\">func (v Value) Close()</a>\n</li>\n<li> <a href=\"#Value.Complex\">func (v Value) Complex() complex128</a>\n</li>\n<li> <a href=\"#Value.Convert\">func (v Value) Convert(t Type) Value</a>\n</li>\n<li> <a href=\"#Value.Elem\">func (v Value) Elem() Value</a>\n</li>\n<li> <a href=\"#Value.Field\">func (v Value) Field(i int) Value</a>\n</li>\n<li> <a href=\"#Value.FieldByIndex\">func (v Value) FieldByIndex(index []int) Value</a>\n</li>\n<li> <a href=\"#Value.FieldByName\">func (v Value) FieldByName(name string) Value</a>\n</li>\n<li> <a href=\"#Value.FieldByNameFunc\">func (v Value) FieldByNameFunc(match func(string) bool) Value</a>\n</li>\n<li> <a href=\"#Value.Float\">func (v Value) Float() float64</a>\n</li>\n<li> <a href=\"#Value.Index\">func (v Value) Index(i int) Value</a>\n</li>\n<li> <a href=\"#Value.Int\">func (v Value) Int() int64</a>\n</li>\n<li> <a href=\"#Value.Interface\">func (v Value) Interface() (i interface{})</a>\n</li>\n<li> <a href=\"#Value.InterfaceData\">func (v Value) InterfaceData() [2]uintptr</a>\n</li>\n<li> <a href=\"#Value.IsNil\">func (v Value) IsNil() bool</a>\n</li>\n<li> <a href=\"#Value.IsValid\">func (v Value) IsValid() bool</a>\n</li>\n<li> <a href=\"#Value.Kind\">func (v Value) Kind() Kind</a>\n</li>\n<li> <a href=\"#Value.Len\">func (v Value) Len() int</a>\n</li>\n<li> <a href=\"#Value.MapIndex\">func (v Value) MapIndex(key Value) Value</a>\n</li>\n<li> <a href=\"#Value.MapKeys\">func (v Value) MapKeys() []Value</a>\n</li>\n<li> <a href=\"#Value.Method\">func (v Value) Method(i int) Value</a>\n</li>\n<li> <a href=\"#Value.MethodByName\">func (v Value) MethodByName(name string) Value</a>\n</li>\n<li> <a href=\"#Value.NumField\">func (v Value) NumField() int</a>\n</li>\n<li> <a href=\"#Value.NumMethod\">func (v Value) NumMethod() int</a>\n</li>\n<li> <a href=\"#Value.OverflowComplex\">func (v Value) OverflowComplex(x complex128) bool</a>\n</li>\n<li> <a href=\"#Value.OverflowFloat\">func (v Value) OverflowFloat(x float64) bool</a>\n</li>\n<li> <a href=\"#Value.OverflowInt\">func (v Value) OverflowInt(x int64) bool</a>\n</li>\n<li> <a href=\"#Value.OverflowUint\">func (v Value) OverflowUint(x uint64) bool</a>\n</li>\n<li> <a href=\"#Value.Pointer\">func (v Value) Pointer() uintptr</a>\n</li>\n<li> <a href=\"#Value.Recv\">func (v Value) Recv() (x Value, ok bool)</a>\n</li>\n<li> <a href=\"#Value.Send\">func (v Value) Send(x Value)</a>\n</li>\n<li> <a href=\"#Value.Set\">func (v Value) Set(x Value)</a>\n</li>\n<li> <a href=\"#Value.SetBool\">func (v Value) SetBool(x bool)</a>\n</li>\n<li> <a href=\"#Value.SetBytes\">func (v Value) SetBytes(x []byte)</a>\n</li>\n<li> <a href=\"#Value.SetCap\">func (v Value) SetCap(n int)</a>\n</li>\n<li> <a href=\"#Value.SetComplex\">func (v Value) SetComplex(x complex128)</a>\n</li>\n<li> <a href=\"#Value.SetFloat\">func (v Value) SetFloat(x float64)</a>\n</li>\n<li> <a href=\"#Value.SetInt\">func (v Value) SetInt(x int64)</a>\n</li>\n<li> <a href=\"#Value.SetLen\">func (v Value) SetLen(n int)</a>\n</li>\n<li> <a href=\"#Value.SetMapIndex\">func (v Value) SetMapIndex(key, val Value)</a>\n</li>\n<li> <a href=\"#Value.SetPointer\">func (v Value) SetPointer(x unsafe.Pointer)</a>\n</li>\n<li> <a href=\"#Value.SetString\">func (v Value) SetString(x string)</a>\n</li>\n<li> <a href=\"#Value.SetUint\">func (v Value) SetUint(x uint64)</a>\n</li>\n<li> <a href=\"#Value.Slice\">func (v Value) Slice(i, j int) Value</a>\n</li>\n<li> <a href=\"#Value.Slice3\">func (v Value) Slice3(i, j, k int) Value</a>\n</li>\n<li> <a href=\"#Value.String\">func (v Value) String() string</a>\n</li>\n<li> <a href=\"#Value.TryRecv\">func (v Value) TryRecv() (x Value, ok bool)</a>\n</li>\n<li> <a href=\"#Value.TrySend\">func (v Value) TrySend(x Value) bool</a>\n</li>\n<li> <a href=\"#Value.Type\">func (v Value) Type() Type</a>\n</li>\n<li> <a href=\"#Value.Uint\">func (v Value) Uint() uint64</a>\n</li>\n<li> <a href=\"#Value.UnsafeAddr\">func (v Value) UnsafeAddr() uintptr</a>\n</li>\n<li><a href=\"#ValueError\">type ValueError</a></li>\n<li> <a href=\"#ValueError.Error\">func (e *ValueError) Error() string</a>\n</li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_MakeFunc\">MakeFunc</a></dd> <dd><a class=\"exampleLink\" href=\"#example_StructTag\">StructTag</a></dd> <dd><a class=\"exampleLink\" href=\"#example_StructTag_Lookup\">StructTag.Lookup</a></dd> <dd><a class=\"exampleLink\" href=\"#example_TypeOf\">TypeOf</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/reflect/deepequal.go\">deepequal.go</a> <a href=\"https://golang.org/src/reflect/makefunc.go\">makefunc.go</a> <a href=\"https://golang.org/src/reflect/type.go\">type.go</a> <a href=\"https://golang.org/src/reflect/value.go\">value.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Copy\">func Copy  </h2> <pre data-language=\"go\">func Copy(dst, src Value) int</pre> <p> Copy copies the contents of src into dst until either dst has been filled or src has been exhausted. It returns the number of elements copied. Dst and src each must have kind Slice or Array, and dst and src must have the same element type. </p> <h2 id=\"DeepEqual\">func DeepEqual  </h2> <pre data-language=\"go\">func DeepEqual(x, y interface{}) bool</pre> <p> DeepEqual reports whether x and y are “deeply equal,” defined as follows. Two values of identical type are deeply equal if one of the following cases applies. Values of distinct types are never deeply equal. </p> <p> Array values are deeply equal when their corresponding elements are deeply equal. </p> <p> Struct values are deeply equal if their corresponding fields, both exported and unexported, are deeply equal. </p> <p> Func values are deeply equal if both are nil; otherwise they are not deeply equal. </p> <p> Interface values are deeply equal if they hold deeply equal concrete values. </p> <p> Map values are deeply equal if they are the same map object or if they have the same length and their corresponding keys (matched using Go equality) map to deeply equal values. </p> <p> Pointer values are deeply equal if they are equal using Go's == operator or if they point to deeply equal values. </p> <p> Slice values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they point to the same initial entry of the same underlying array (that is, &amp;x[0] == &amp;y[0]) or their corresponding elements (up to length) are deeply equal. Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil)) are not deeply equal. </p> <p> Other values - numbers, bools, strings, and channels - are deeply equal if they are equal using Go's == operator. </p> <p> In general DeepEqual is a recursive relaxation of Go's == operator. However, this idea is impossible to implement without some inconsistency. Specifically, it is possible for a value to be unequal to itself, either because it is of func type (uncomparable in general) or because it is a floating-point NaN value (not equal to itself in floating-point comparison), or because it is an array, struct, or interface containing such a value. On the other hand, pointer values are always equal to themselves, even if they point at or contain such problematic values, because they compare equal using Go's == operator, and that is a sufficient condition to be deeply equal, regardless of content. DeepEqual has been defined so that the same short-cut applies to slices and maps: if x and y are the same slice or the same map, they are deeply equal regardless of content. </p> <h2 id=\"Select\">func Select  </h2> <pre data-language=\"go\">func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</pre> <p> Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed). </p> <h2 id=\"ChanDir\">type ChanDir  </h2> <pre data-language=\"go\">type ChanDir int</pre> <p> ChanDir represents a channel type's direction. </p> <pre data-language=\"go\">const (\n        RecvDir ChanDir             = 1 &lt;&lt; iota // &lt;-chan\n        SendDir                                 // chan&lt;-\n        BothDir = RecvDir | SendDir             // chan\n)</pre> <h3 id=\"ChanDir.String\">func (ChanDir) <a href=\"https://golang.org/src/reflect/type.go?s=28226:28258#L1044\">String</a>  </h3> <pre data-language=\"go\">func (d ChanDir) String() string</pre> <h2 id=\"Kind\">type Kind  </h2> <pre data-language=\"go\">type Kind uint</pre> <p> A Kind represents the specific kind of type that a Type represents. The zero Kind is not a valid kind. </p> <pre data-language=\"go\">const (\n        Invalid Kind = iota\n        Bool\n        Int\n        Int8\n        Int16\n        Int32\n        Int64\n        Uint\n        Uint8\n        Uint16\n        Uint32\n        Uint64\n        Uintptr\n        Float32\n        Float64\n        Complex64\n        Complex128\n        Array\n        Chan\n        Func\n        Interface\n        Map\n        Ptr\n        Slice\n        String\n        Struct\n        UnsafePointer\n)</pre> <h3 id=\"Kind.String\">func (Kind) <a href=\"https://golang.org/src/reflect/type.go?s=17070:17099#L568\">String</a>  </h3> <pre data-language=\"go\">func (k Kind) String() string</pre> <h2 id=\"Method\">type Method  </h2> <pre data-language=\"go\">type Method struct {\n        // Name is the method name.\n        // PkgPath is the package path that qualifies a lower case (unexported)\n        // method name. It is empty for upper case (exported) method names.\n        // The combination of PkgPath and Name uniquely identifies a method\n        // in a method set.\n        // See https://golang.org/ref/spec#Uniqueness_of_identifiers\n        Name    string\n        PkgPath string\n\n        Type  Type  // method type\n        Func  Value // func with receiver as first argument\n        Index int   // index for Type.Method\n}</pre> <p> Method represents a single method. </p> <h2 id=\"SelectCase\">type SelectCase  </h2> <pre data-language=\"go\">type SelectCase struct {\n        Dir  SelectDir // direction of case\n        Chan Value     // channel to use (for send or receive)\n        Send Value     // value to send (for send)\n}</pre> <p> A SelectCase describes a single case in a select operation. The kind of case depends on Dir, the communication direction. </p> <p> If Dir is SelectDefault, the case represents a default case. Chan and Send must be zero Values. </p> <p> If Dir is SelectSend, the case represents a send operation. Normally Chan's underlying value must be a channel, and Send's underlying value must be assignable to the channel's element type. As a special case, if Chan is a zero Value, then the case is ignored, and the field Send will also be ignored and may be either zero or non-zero. </p> <p> If Dir is SelectRecv, the case represents a receive operation. Normally Chan's underlying value must be a channel and Send must be a zero Value. If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value. When a receive operation is selected, the received Value is returned by Select. </p> <h2 id=\"SelectDir\">type SelectDir  </h2> <pre data-language=\"go\">type SelectDir int</pre> <p> A SelectDir describes the communication direction of a select case. </p> <pre data-language=\"go\">const (\n        SelectSend    SelectDir // case Chan &lt;- Send\n        SelectRecv              // case &lt;-Chan:\n        SelectDefault           // default\n)</pre> <h2 id=\"SliceHeader\">type SliceHeader  </h2> <pre data-language=\"go\">type SliceHeader struct {\n        Data uintptr\n        Len  int\n        Cap  int\n}</pre> <p> SliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data. </p> <h2 id=\"StringHeader\">type StringHeader  </h2> <pre data-language=\"go\">type StringHeader struct {\n        Data uintptr\n        Len  int\n}</pre> <p> StringHeader is the runtime representation of a string. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data. </p> <h2 id=\"StructField\">type StructField  </h2> <pre data-language=\"go\">type StructField struct {\n        // Name is the field name.\n        Name string\n        // PkgPath is the package path that qualifies a lower case (unexported)\n        // field name. It is empty for upper case (exported) field names.\n        // See https://golang.org/ref/spec#Uniqueness_of_identifiers\n        PkgPath string\n\n        Type      Type      // field type\n        Tag       StructTag // field tag string\n        Offset    uintptr   // offset within struct, in bytes\n        Index     []int     // index sequence for Type.FieldByIndex\n        Anonymous bool      // is an embedded field\n}</pre> <p> A StructField describes a single field in a struct. </p> <h2 id=\"StructTag\">type StructTag  </h2> <pre data-language=\"go\">type StructTag string</pre> <p> A StructTag is the tag string in a struct field. </p> <p> By convention, tag strings are a concatenation of optionally space-separated key:\"value\" pairs. Each key is a non-empty string consisting of non-control characters other than space (U+0020 ' '), quote (U+0022 '\"'), and colon (U+003A ':'). Each value is quoted using U+0022 '\"' characters and Go string literal syntax. </p> <div id=\"example_StructTag\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc main() {\n\ttype S struct {\n\t\tF string `species:\"gopher\" color:\"blue\"`\n\t}\n\n\ts := S{}\n\tst := reflect.TypeOf(s)\n\tfield := st.Field(0)\n\tfmt.Println(field.Tag.Get(\"color\"), field.Tag.Get(\"species\"))\n\n}\n</pre> </div> </div> <h3 id=\"StructTag.Get\">func (StructTag) <a href=\"https://golang.org/src/reflect/type.go?s=30595:30638#L1124\">Get</a>  </h3> <pre data-language=\"go\">func (tag StructTag) Get(key string) string</pre> <p> Get returns the value associated with key in the tag string. If there is no such key in the tag, Get returns the empty string. If the tag does not have the conventional format, the value returned by Get is unspecified. To determine whether a tag is explicitly set to the empty string, use Lookup. </p> <h3 id=\"StructTag.Lookup\">func (StructTag) <a href=\"https://golang.org/src/reflect/type.go?s=31072:31135#L1135\">Lookup</a>  </h3> <pre data-language=\"go\">func (tag StructTag) Lookup(key string) (value string, ok bool)</pre> <p> Lookup returns the value associated with key in the tag string. If the key is present in the tag the value (which may be empty) is returned. Otherwise the returned value will be the empty string. The ok return value reports whether the value was explicitly set in the tag string. If the tag does not have the conventional format, the value returned by Lookup is unspecified. </p> <div id=\"example_StructTag_Lookup\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc main() {\n\ttype S struct {\n\t\tF0 string `alias:\"field_0\"`\n\t\tF1 string `alias:\"\"`\n\t\tF2 string\n\t}\n\n\ts := S{}\n\tst := reflect.TypeOf(s)\n\tfor i := 0; i &lt; st.NumField(); i++ {\n\t\tfield := st.Field(i)\n\t\tif alias, ok := field.Tag.Lookup(\"alias\"); ok {\n\t\t\tif alias == \"\" {\n\t\t\t\tfmt.Println(\"(blank)\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(alias)\n\t\t\t}\n\t\t} else {\n\t\t\tfmt.Println(\"(not specified)\")\n\t\t}\n\t}\n\n}\n</pre> </div> </div> <h2 id=\"Type\">type Type  </h2> <pre data-language=\"go\">type Type interface {\n\n        // Align returns the alignment in bytes of a value of\n        // this type when allocated in memory.\n        Align() int\n\n        // FieldAlign returns the alignment in bytes of a value of\n        // this type when used as a field in a struct.\n        FieldAlign() int\n\n        // Method returns the i'th method in the type's method set.\n        // It panics if i is not in the range [0, NumMethod()).\n        //\n        // For a non-interface type T or *T, the returned Method's Type and Func\n        // fields describe a function whose first argument is the receiver.\n        //\n        // For an interface type, the returned Method's Type field gives the\n        // method signature, without a receiver, and the Func field is nil.\n        Method(int) Method\n\n        // MethodByName returns the method with that name in the type's\n        // method set and a boolean indicating if the method was found.\n        //\n        // For a non-interface type T or *T, the returned Method's Type and Func\n        // fields describe a function whose first argument is the receiver.\n        //\n        // For an interface type, the returned Method's Type field gives the\n        // method signature, without a receiver, and the Func field is nil.\n        MethodByName(string) (Method, bool)\n\n        // NumMethod returns the number of methods in the type's method set.\n        NumMethod() int\n\n        // Name returns the type's name within its package.\n        // It returns an empty string for unnamed types.\n        Name() string\n\n        // PkgPath returns a named type's package path, that is, the import path\n        // that uniquely identifies the package, such as \"encoding/base64\".\n        // If the type was predeclared (string, error) or unnamed (*T, struct{}, []int),\n        // the package path will be the empty string.\n        PkgPath() string\n\n        // Size returns the number of bytes needed to store\n        // a value of the given type; it is analogous to unsafe.Sizeof.\n        Size() uintptr\n\n        // String returns a string representation of the type.\n        // The string representation may use shortened package names\n        // (e.g., base64 instead of \"encoding/base64\") and is not\n        // guaranteed to be unique among types. To test for equality,\n        // compare the Types directly.\n        String() string\n\n        // Kind returns the specific kind of this type.\n        Kind() Kind\n\n        // Implements reports whether the type implements the interface type u.\n        Implements(u Type) bool\n\n        // AssignableTo reports whether a value of the type is assignable to type u.\n        AssignableTo(u Type) bool\n\n        // ConvertibleTo reports whether a value of the type is convertible to type u.\n        ConvertibleTo(u Type) bool\n\n        // Comparable reports whether values of this type are comparable.\n        Comparable() bool\n\n        // Bits returns the size of the type in bits.\n        // It panics if the type's Kind is not one of the\n        // sized or unsized Int, Uint, Float, or Complex kinds.\n        Bits() int\n\n        // ChanDir returns a channel type's direction.\n        // It panics if the type's Kind is not Chan.\n        ChanDir() ChanDir\n\n        // IsVariadic reports whether a function type's final input parameter\n        // is a \"...\" parameter. If so, t.In(t.NumIn() - 1) returns the parameter's\n        // implicit actual type []T.\n        //\n        // For concreteness, if t represents func(x int, y ... float64), then\n        //\n        //\tt.NumIn() == 2\n        //\tt.In(0) is the reflect.Type for \"int\"\n        //\tt.In(1) is the reflect.Type for \"[]float64\"\n        //\tt.IsVariadic() == true\n        //\n        // IsVariadic panics if the type's Kind is not Func.\n        IsVariadic() bool\n\n        // Elem returns a type's element type.\n        // It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice.\n        Elem() Type\n\n        // Field returns a struct type's i'th field.\n        // It panics if the type's Kind is not Struct.\n        // It panics if i is not in the range [0, NumField()).\n        Field(i int) StructField\n\n        // FieldByIndex returns the nested field corresponding\n        // to the index sequence. It is equivalent to calling Field\n        // successively for each index i.\n        // It panics if the type's Kind is not Struct.\n        FieldByIndex(index []int) StructField\n\n        // FieldByName returns the struct field with the given name\n        // and a boolean indicating if the field was found.\n        FieldByName(name string) (StructField, bool)\n\n        // FieldByNameFunc returns the first struct field with a name\n        // that satisfies the match function and a boolean indicating if\n        // the field was found.\n        FieldByNameFunc(match func(string) bool) (StructField, bool)\n\n        // In returns the type of a function type's i'th input parameter.\n        // It panics if the type's Kind is not Func.\n        // It panics if i is not in the range [0, NumIn()).\n        In(i int) Type\n\n        // Key returns a map type's key type.\n        // It panics if the type's Kind is not Map.\n        Key() Type\n\n        // Len returns an array type's length.\n        // It panics if the type's Kind is not Array.\n        Len() int\n\n        // NumField returns a struct type's field count.\n        // It panics if the type's Kind is not Struct.\n        NumField() int\n\n        // NumIn returns a function type's input parameter count.\n        // It panics if the type's Kind is not Func.\n        NumIn() int\n\n        // NumOut returns a function type's output parameter count.\n        // It panics if the type's Kind is not Func.\n        NumOut() int\n\n        // Out returns the type of a function type's i'th output parameter.\n        // It panics if the type's Kind is not Func.\n        // It panics if i is not in the range [0, NumOut()).\n        Out(i int) Type\n        // contains filtered or unexported methods\n}</pre> <p> Type is the representation of a Go type. </p> <p> Not all methods apply to all kinds of types. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of type before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run-time panic. </p> <h3 id=\"ArrayOf\">func <a href=\"https://golang.org/src/reflect/type.go?s=75762:75801#L2790\">ArrayOf</a>  </h3> <pre data-language=\"go\">func ArrayOf(count int, elem Type) Type</pre> <p> ArrayOf returns the array type with the given count and element type. For example, if t represents int, ArrayOf(5, t) represents [5]int. </p> <p> If the resulting type would be larger than the available address space, ArrayOf panics. </p> <h3 id=\"ChanOf\">func <a href=\"https://golang.org/src/reflect/type.go?s=49168:49205#L1800\">ChanOf</a>  </h3> <pre data-language=\"go\">func ChanOf(dir ChanDir, t Type) Type</pre> <p> ChanOf returns the channel type with the given direction and element type. For example, if t represents int, ChanOf(RecvDir, t) represents &lt;-chan int. </p> <p> The gc runtime imposes a limit of 64 kB on channel element types. If t's size is equal to or exceeds this limit, ChanOf panics. </p> <h3 id=\"FuncOf\">func <a href=\"https://golang.org/src/reflect/type.go?s=52765:52812#L1943\">FuncOf</a>  </h3> <pre data-language=\"go\">func FuncOf(in, out []Type, variadic bool) Type</pre> <p> FuncOf returns the function type with the given argument and result types. For example if k represents int and e represents string, FuncOf([]Type{k}, []Type{e}, false) represents func(int) string. </p> <p> The variadic argument controls whether the function is variadic. FuncOf panics if the in[len(in)-1] does not represent a slice and variadic is true. </p> <h3 id=\"MapOf\">func <a href=\"https://golang.org/src/reflect/type.go?s=50681:50712#L1857\">MapOf</a>  </h3> <pre data-language=\"go\">func MapOf(key, elem Type) Type</pre> <p> MapOf returns the map type with the given key and element types. For example, if k represents int and e represents string, MapOf(k, e) represents map[int]string. </p> <p> If the key type is not a valid map key type (that is, if it does not implement Go's == operator), MapOf panics. </p> <h3 id=\"PtrTo\">func <a href=\"https://golang.org/src/reflect/type.go?s=38855:38878#L1400\">PtrTo</a>  </h3> <pre data-language=\"go\">func PtrTo(t Type) Type</pre> <p> PtrTo returns the pointer type with element t. For example, if t represents type Foo, PtrTo(t) represents *Foo. </p> <h3 id=\"SliceOf\">func <a href=\"https://golang.org/src/reflect/type.go?s=61392:61417#L2249\">SliceOf</a>  </h3> <pre data-language=\"go\">func SliceOf(t Type) Type</pre> <p> SliceOf returns the slice type with element type t. For example, if t represents int, SliceOf(t) represents []int. </p> <h3 id=\"StructOf\">func <a href=\"https://golang.org/src/reflect/type.go?s=63647:63687#L2338\">StructOf</a>  </h3> <pre data-language=\"go\">func StructOf(fields []StructField) Type</pre> <p> StructOf returns the struct type containing fields. The Offset and Index fields are ignored and computed as they would be by the compiler. </p> <p> StructOf currently does not generate wrapper methods for embedded fields. This limitation may be lifted in a future version. </p> <h3 id=\"TypeOf\">func <a href=\"https://golang.org/src/reflect/type.go?s=38531:38562#L1387\">TypeOf</a>  </h3> <pre data-language=\"go\">func TypeOf(i interface{}) Type</pre> <p> TypeOf returns the reflection Type that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil. </p> <div id=\"example_TypeOf\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"reflect\"\n)\n\nfunc main() {\n\t// As interface types are only used for static typing, a\n\t// common idiom to find the reflection Type for an interface\n\t// type Foo is to use a *Foo value.\n\twriterType := reflect.TypeOf((*io.Writer)(nil)).Elem()\n\n\tfileType := reflect.TypeOf((*os.File)(nil))\n\tfmt.Println(fileType.Implements(writerType))\n\n}\n</pre> </div> </div> <h2 id=\"Value\">type Value  </h2> <pre data-language=\"go\">type Value struct {\n        // contains filtered or unexported fields\n}</pre> <p> Value is the reflection interface to a Go value. </p> <p> Not all methods apply to all kinds of values. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of value before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run time panic. </p> <p> The zero Value represents no value. Its IsValid method returns false, its Kind method returns Invalid, its String method returns \"&lt;invalid Value&gt;\", and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly. </p> <p> A Value can be used concurrently by multiple goroutines provided that the underlying Go value can be used concurrently for the equivalent direct operations. </p> <p> Using == on two Values does not compare the underlying values they represent, but rather the contents of the Value structs. To compare two Values, compare the results of the Interface method. </p> <h3 id=\"Append\">func <a href=\"https://golang.org/src/reflect/value.go?s=53593:53631#L1802\">Append</a>  </h3> <pre data-language=\"go\">func Append(s Value, x ...Value) Value</pre> <p> Append appends the values x to a slice s and returns the resulting slice. As in Go, each x's value must be assignable to the slice's element type. </p> <h3 id=\"AppendSlice\">func <a href=\"https://golang.org/src/reflect/value.go?s=53900:53934#L1813\">AppendSlice</a>  </h3> <pre data-language=\"go\">func AppendSlice(s, t Value) Value</pre> <p> AppendSlice appends a slice t to a slice s and returns the resulting slice. The slices s and t must have the same element type. </p> <h3 id=\"Indirect\">func <a href=\"https://golang.org/src/reflect/value.go?s=61339:61367#L2064\">Indirect</a>  </h3> <pre data-language=\"go\">func Indirect(v Value) Value</pre> <p> Indirect returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v. </p> <h3 id=\"MakeChan\">func <a href=\"https://golang.org/src/reflect/value.go?s=60591:60632#L2038\">MakeChan</a>  </h3> <pre data-language=\"go\">func MakeChan(typ Type, buffer int) Value</pre> <p> MakeChan creates a new channel with the specified type and buffer size. </p> <h3 id=\"MakeFunc\">func <a href=\"https://golang.org/src/reflect/makefunc.go?s=1481:1551#L34\">MakeFunc</a>  </h3> <pre data-language=\"go\">func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value</pre> <p> MakeFunc returns a new function of the given Type that wraps the function fn. When called, that new function does the following: </p> <pre data-language=\"go\">- converts its arguments to a slice of Values.\n- runs results := fn(args).\n- returns the results as a slice of Values, one per formal result.\n</pre> <p> The implementation fn can assume that the argument Value slice has the number and type of arguments given by typ. If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. The result Value slice returned by fn must have the number and type of results given by typ. </p> <p> The Value.Call method allows the caller to invoke a typed function in terms of Values; in contrast, MakeFunc allows the caller to implement a typed function in terms of Values. </p> <p> The Examples section of the documentation includes an illustration of how to use MakeFunc to build a swap function for different types. </p> <div id=\"example_MakeFunc\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc main() {\n\t// swap is the implementation passed to MakeFunc.\n\t// It must work in terms of reflect.Values so that it is possible\n\t// to write code without knowing beforehand what the types\n\t// will be.\n\tswap := func(in []reflect.Value) []reflect.Value {\n\t\treturn []reflect.Value{in[1], in[0]}\n\t}\n\n\t// makeSwap expects fptr to be a pointer to a nil function.\n\t// It sets that pointer to a new function created with MakeFunc.\n\t// When the function is invoked, reflect turns the arguments\n\t// into Values, calls swap, and then turns swap's result slice\n\t// into the values returned by the new function.\n\tmakeSwap := func(fptr interface{}) {\n\t\t// fptr is a pointer to a function.\n\t\t// Obtain the function value itself (likely nil) as a reflect.Value\n\t\t// so that we can query its type and then set the value.\n\t\tfn := reflect.ValueOf(fptr).Elem()\n\n\t\t// Make a function of the right type.\n\t\tv := reflect.MakeFunc(fn.Type(), swap)\n\n\t\t// Assign it to the value fn represents.\n\t\tfn.Set(v)\n\t}\n\n\t// Make and call a swap function for ints.\n\tvar intSwap func(int, int) (int, int)\n\tmakeSwap(&amp;intSwap)\n\tfmt.Println(intSwap(0, 1))\n\n\t// Make and call a swap function for float64s.\n\tvar floatSwap func(float64, float64) (float64, float64)\n\tmakeSwap(&amp;floatSwap)\n\tfmt.Println(floatSwap(2.72, 3.14))\n\n}\n</pre> </div> </div> <h3 id=\"MakeMap\">func <a href=\"https://golang.org/src/reflect/value.go?s=61014:61042#L2053\">MakeMap</a>  </h3> <pre data-language=\"go\">func MakeMap(typ Type) Value</pre> <p> MakeMap creates a new map of the specified type. </p> <h3 id=\"MakeSlice\">func <a href=\"https://golang.org/src/reflect/value.go?s=60066:60110#L2019\">MakeSlice</a>  </h3> <pre data-language=\"go\">func MakeSlice(typ Type, len, cap int) Value</pre> <p> MakeSlice creates a new zero-initialized slice value for the specified slice type, length, and capacity. </p> <h3 id=\"New\">func <a href=\"https://golang.org/src/reflect/value.go?s=62568:62592#L2106\">New</a>  </h3> <pre data-language=\"go\">func New(typ Type) Value</pre> <p> New returns a Value representing a pointer to a new zero value for the specified type. That is, the returned Value's Type is PtrTo(typ). </p> <h3 id=\"NewAt\">func <a href=\"https://golang.org/src/reflect/value.go?s=62852:62896#L2117\">NewAt</a>  </h3> <pre data-language=\"go\">func NewAt(typ Type, p unsafe.Pointer) Value</pre> <p> NewAt returns a Value representing a pointer to a value of the specified type, using p as that pointer. </p> <h3 id=\"ValueOf\">func <a href=\"https://golang.org/src/reflect/value.go?s=61558:61591#L2073\">ValueOf</a>  </h3> <pre data-language=\"go\">func ValueOf(i interface{}) Value</pre> <p> ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value. </p> <h3 id=\"Zero\">func <a href=\"https://golang.org/src/reflect/value.go?s=62194:62219#L2092\">Zero</a>  </h3> <pre data-language=\"go\">func Zero(typ Type) Value</pre> <p> Zero returns a Value representing the zero value for the specified type. The result is different from the zero value of the Value struct, which represents no value at all. For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0. The returned value is neither addressable nor settable. </p> <h3 id=\"Value.Addr\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=7432:7459#L227\">Addr</a>  </h3> <pre data-language=\"go\">func (v Value) Addr() Value</pre> <p> Addr returns a pointer value representing the address of v. It panics if CanAddr() returns false. Addr is typically used to obtain a pointer to a struct field or slice element in order to call a method that requires a pointer receiver. </p> <h3 id=\"Value.Bool\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=7691:7717#L236\">Bool</a>  </h3> <pre data-language=\"go\">func (v Value) Bool() bool</pre> <p> Bool returns v's underlying value. It panics if v's kind is not Bool. </p> <h3 id=\"Value.Bytes\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=7864:7893#L243\">Bytes</a>  </h3> <pre data-language=\"go\">func (v Value) Bytes() []byte</pre> <p> Bytes returns v's underlying value. It panics if v's underlying value is not a slice of bytes. </p> <h3 id=\"Value.Call\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=9654:9693#L289\">Call</a>  </h3> <pre data-language=\"go\">func (v Value) Call(in []Value) []Value</pre> <p> Call calls the function v with the input arguments in. For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]). Call panics if v's Kind is not Func. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function's corresponding input parameter. If v is a variadic function, Call creates the variadic slice parameter itself, copying in the corresponding values. </p> <h3 id=\"Value.CallSlice\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=10231:10275#L302\">CallSlice</a>  </h3> <pre data-language=\"go\">func (v Value) CallSlice(in []Value) []Value</pre> <p> CallSlice calls the variadic function v with the input arguments in, assigning the slice in[len(in)-1] to v's final variadic argument. For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...). CallSlice panics if v's Kind is not Func or if v is not variadic. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function's corresponding input parameter. </p> <h3 id=\"Value.CanAddr\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=8760:8789#L268\">CanAddr</a>  </h3> <pre data-language=\"go\">func (v Value) CanAddr() bool</pre> <p> CanAddr reports whether the value's address can be obtained with Addr. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling Addr will panic. </p> <h3 id=\"Value.CanInterface\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=27124:27158#L884\">CanInterface</a>  </h3> <pre data-language=\"go\">func (v Value) CanInterface() bool</pre> <p> CanInterface reports whether Interface can be used without panicking. </p> <h3 id=\"Value.CanSet\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=9104:9132#L277\">CanSet</a>  </h3> <pre data-language=\"go\">func (v Value) CanSet() bool</pre> <p> CanSet reports whether the value of v can be changed. A Value can be changed only if it is addressable and was not obtained by the use of unexported struct fields. If CanSet returns false, calling Set or any type-specific setter (e.g., SetBool, SetInt) will panic. </p> <h3 id=\"Value.Cap\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=20848:20872#L653\">Cap</a>  </h3> <pre data-language=\"go\">func (v Value) Cap() int</pre> <p> Cap returns v's capacity. It panics if v's Kind is not Array, Chan, or Slice. </p> <h3 id=\"Value.Close\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=21211:21233#L669\">Close</a>  </h3> <pre data-language=\"go\">func (v Value) Close()</pre> <p> Close closes the channel v. It panics if v's Kind is not Chan. </p> <h3 id=\"Value.Complex\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=21413:21448#L677\">Complex</a>  </h3> <pre data-language=\"go\">func (v Value) Complex() complex128</pre> <p> Complex returns v's underlying value, as a complex128. It panics if v's Kind is not Complex64 or Complex128 </p> <h3 id=\"Value.Convert\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=64111:64147#L2159\">Convert</a>  </h3> <pre data-language=\"go\">func (v Value) Convert(t Type) Value</pre> <p> Convert returns the value v converted to type t. If the usual Go conversion rules do not allow conversion of the value v to type t, Convert panics. </p> <h3 id=\"Value.Elem\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=21831:21858#L692\">Elem</a>  </h3> <pre data-language=\"go\">func (v Value) Elem() Value</pre> <p> Elem returns the value that the interface v contains or that the pointer v points to. It panics if v's Kind is not Interface or Ptr. It returns the zero Value if v is nil. </p> <h3 id=\"Value.Field\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=22665:22698#L729\">Field</a>  </h3> <pre data-language=\"go\">func (v Value) Field(i int) Value</pre> <p> Field returns the i'th field of the struct v. It panics if v's Kind is not Struct or i is out of range. </p> <h3 id=\"Value.FieldByIndex\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=23707:23753#L761\">FieldByIndex</a>  </h3> <pre data-language=\"go\">func (v Value) FieldByIndex(index []int) Value</pre> <p> FieldByIndex returns the nested field corresponding to index. It panics if v's Kind is not struct. </p> <h3 id=\"Value.FieldByName\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=24234:24279#L783\">FieldByName</a>  </h3> <pre data-language=\"go\">func (v Value) FieldByName(name string) Value</pre> <p> FieldByName returns the struct field with the given name. It returns the zero Value if no field was found. It panics if v's Kind is not struct. </p> <h3 id=\"Value.FieldByNameFunc\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=24584:24645#L795\">FieldByNameFunc</a>  </h3> <pre data-language=\"go\">func (v Value) FieldByNameFunc(match func(string) bool) Value</pre> <p> FieldByNameFunc returns the struct field with a name that satisfies the match function. It panics if v's Kind is not struct. It returns the zero Value if no field was found. </p> <h3 id=\"Value.Float\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=24855:24885#L804\">Float</a>  </h3> <pre data-language=\"go\">func (v Value) Float() float64</pre> <p> Float returns v's underlying value, as a float64. It panics if v's Kind is not Float32 or Float64 </p> <h3 id=\"Value.Index\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=25225:25258#L819\">Index</a>  </h3> <pre data-language=\"go\">func (v Value) Index(i int) Value</pre> <p> Index returns v's i'th element. It panics if v's Kind is not Array, Slice, or String or i is out of range. </p> <h3 id=\"Value.Int\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=26729:26755#L865\">Int</a>  </h3> <pre data-language=\"go\">func (v Value) Int() int64</pre> <p> Int returns v's underlying value, as an int64. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64. </p> <h3 id=\"Value.Interface\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=27481:27523#L896\">Interface</a>  </h3> <pre data-language=\"go\">func (v Value) Interface() (i interface{})</pre> <p> Interface returns v's current value as an interface{}. It is equivalent to: </p> <pre data-language=\"go\">var i interface{} = (v's underlying value)\n</pre> <p> It panics if the Value was obtained by accessing unexported struct fields. </p> <h3 id=\"Value.InterfaceData\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=28571:28612#L932\">InterfaceData</a>  </h3> <pre data-language=\"go\">func (v Value) InterfaceData() [2]uintptr</pre> <p> InterfaceData returns the interface v's value as a uintptr pair. It panics if v's Kind is not Interface. </p> <h3 id=\"Value.IsNil\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=29358:29385#L950\">IsNil</a>  </h3> <pre data-language=\"go\">func (v Value) IsNil() bool</pre> <p> IsNil reports whether its argument v is nil. The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value. </p> <h3 id=\"Value.IsValid\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=30126:30155#L975\">IsValid</a>  </h3> <pre data-language=\"go\">func (v Value) IsValid() bool</pre> <p> IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly. </p> <h3 id=\"Value.Kind\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=30280:30306#L981\">Kind</a>  </h3> <pre data-language=\"go\">func (v Value) Kind() Kind</pre> <p> Kind returns v's Kind. If v is the zero Value (IsValid returns false), Kind returns Invalid. </p> <h3 id=\"Value.Len\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=30424:30448#L987\">Len</a>  </h3> <pre data-language=\"go\">func (v Value) Len() int</pre> <p> Len returns v's length. It panics if v's Kind is not Array, Chan, Map, Slice, or String. </p> <h3 id=\"Value.MapIndex\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=31160:31200#L1011\">MapIndex</a>  </h3> <pre data-language=\"go\">func (v Value) MapIndex(key Value) Value</pre> <p> MapIndex returns the value associated with key in the map v. It panics if v's Kind is not Map. It returns the zero Value if key is not found in the map or if v represents a nil map. As in Go, the key's value must be assignable to the map's key type. </p> <h3 id=\"Value.MapKeys\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=32392:32424#L1052\">MapKeys</a>  </h3> <pre data-language=\"go\">func (v Value) MapKeys() []Value</pre> <p> MapKeys returns a slice containing all the keys present in the map, in unspecified order. It panics if v's Kind is not Map. It returns an empty slice if v represents a nil map. </p> <h3 id=\"Value.Method\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=33517:33551#L1093\">Method</a>  </h3> <pre data-language=\"go\">func (v Value) Method(i int) Value</pre> <p> Method returns a function value corresponding to v's i'th method. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. Method panics if i is out of range or if v is a nil interface value. </p> <h3 id=\"Value.MethodByName\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=34554:34600#L1125\">MethodByName</a>  </h3> <pre data-language=\"go\">func (v Value) MethodByName(name string) Value</pre> <p> MethodByName returns a function value corresponding to the method of v with the given name. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. It returns the zero Value if no method was found. </p> <h3 id=\"Value.NumField\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=34926:34955#L1141\">NumField</a>  </h3> <pre data-language=\"go\">func (v Value) NumField() int</pre> <p> NumField returns the number of fields in the struct v. It panics if v's Kind is not Struct. </p> <h3 id=\"Value.NumMethod\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=34076:34106#L1110\">NumMethod</a>  </h3> <pre data-language=\"go\">func (v Value) NumMethod() int</pre> <p> NumMethod returns the number of methods in the value's method set. </p> <h3 id=\"Value.OverflowComplex\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=35190:35239#L1149\">OverflowComplex</a>  </h3> <pre data-language=\"go\">func (v Value) OverflowComplex(x complex128) bool</pre> <p> OverflowComplex reports whether the complex128 x cannot be represented by v's type. It panics if v's Kind is not Complex64 or Complex128. </p> <h3 id=\"Value.OverflowFloat\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=35584:35628#L1162\">OverflowFloat</a>  </h3> <pre data-language=\"go\">func (v Value) OverflowFloat(x float64) bool</pre> <p> OverflowFloat reports whether the float64 x cannot be represented by v's type. It panics if v's Kind is not Float32 or Float64. </p> <h3 id=\"Value.OverflowInt\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=36061:36101#L1182\">OverflowInt</a>  </h3> <pre data-language=\"go\">func (v Value) OverflowInt(x int64) bool</pre> <p> OverflowInt reports whether the int64 x cannot be represented by v's type. It panics if v's Kind is not Int, Int8, int16, Int32, or Int64. </p> <h3 id=\"Value.OverflowUint\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=36494:36536#L1195\">OverflowUint</a>  </h3> <pre data-language=\"go\">func (v Value) OverflowUint(x uint64) bool</pre> <p> OverflowUint reports whether the uint64 x cannot be represented by v's type. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64. </p> <h3 id=\"Value.Pointer\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=37507:37539#L1220\">Pointer</a>  </h3> <pre data-language=\"go\">func (v Value) Pointer() uintptr</pre> <p> Pointer returns v's value as a uintptr. It returns uintptr instead of unsafe.Pointer so that code using reflect cannot obtain unsafe.Pointers without importing the unsafe package explicitly. It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer. </p> <p> If v's Kind is Func, the returned pointer is an underlying code pointer, but not necessarily enough to identify a single function uniquely. The only guarantee is that the result is zero if and only if v is a nil func Value. </p> <p> If v's Kind is Slice, the returned pointer is to the first element of the slice. If the slice is nil the returned value is 0. If the slice is empty but non-nil the return value is non-zero. </p> <h3 id=\"Value.Recv\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=38715:38755#L1256\">Recv</a>  </h3> <pre data-language=\"go\">func (v Value) Recv() (x Value, ok bool)</pre> <p> Recv receives and returns a value from the channel v. It panics if v's Kind is not Chan. The receive blocks until a value is ready. The boolean value ok is true if the value x corresponds to a send on the channel, false if it is a zero value received because the channel is closed. </p> <h3 id=\"Value.Send\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=39569:39597#L1289\">Send</a>  </h3> <pre data-language=\"go\">func (v Value) Send(x Value)</pre> <p> Send sends x on the channel v. It panics if v's kind is not Chan or if x's type is not the same type as v's element type. As in Go, x's value must be assignable to the channel's element type. </p> <h3 id=\"Value.Set\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=40260:40287#L1316\">Set</a>  </h3> <pre data-language=\"go\">func (v Value) Set(x Value)</pre> <p> Set assigns x to the value v. It panics if CanSet returns false. As in Go, x's value must be assignable to v's type. </p> <h3 id=\"Value.SetBool\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=40701:40731#L1333\">SetBool</a>  </h3> <pre data-language=\"go\">func (v Value) SetBool(x bool)</pre> <p> SetBool sets v's underlying value. It panics if v's Kind is not Bool or if CanSet() is false. </p> <h3 id=\"Value.SetBytes\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=40897:40930#L1341\">SetBytes</a>  </h3> <pre data-language=\"go\">func (v Value) SetBytes(x []byte)</pre> <p> SetBytes sets v's underlying value. It panics if v's underlying value is not a slice of bytes. </p> <h3 id=\"Value.SetCap\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=43127:43155#L1425\">SetCap</a>  </h3> <pre data-language=\"go\">func (v Value) SetCap(n int)</pre> <p> SetCap sets v's capacity to n. It panics if v's Kind is not Slice or if n is smaller than the length or greater than the capacity of the slice. </p> <h3 id=\"Value.SetComplex\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=41517:41556#L1363\">SetComplex</a>  </h3> <pre data-language=\"go\">func (v Value) SetComplex(x complex128)</pre> <p> SetComplex sets v's underlying value to x. It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false. </p> <h3 id=\"Value.SetFloat\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=41905:41939#L1377\">SetFloat</a>  </h3> <pre data-language=\"go\">func (v Value) SetFloat(x float64)</pre> <p> SetFloat sets v's underlying value to x. It panics if v's Kind is not Float32 or Float64, or if CanSet() is false. </p> <h3 id=\"Value.SetInt\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=42287:42317#L1391\">SetInt</a>  </h3> <pre data-language=\"go\">func (v Value) SetInt(x int64)</pre> <p> SetInt sets v's underlying value to x. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false. </p> <h3 id=\"Value.SetLen\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=42775:42803#L1412\">SetLen</a>  </h3> <pre data-language=\"go\">func (v Value) SetLen(n int)</pre> <p> SetLen sets v's length to n. It panics if v's Kind is not Slice or if n is negative or greater than the capacity of the slice. </p> <h3 id=\"Value.SetMapIndex\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=43697:43739#L1441\">SetMapIndex</a>  </h3> <pre data-language=\"go\">func (v Value) SetMapIndex(key, val Value)</pre> <p> SetMapIndex sets the value associated with key in the map v to val. It panics if v's Kind is not Map. If val is the zero Value, SetMapIndex deletes the key from the map. Otherwise if v holds a nil map, SetMapIndex will panic. As in Go, key's value must be assignable to the map's key type, and val's value must be assignable to the map's value type. </p> <h3 id=\"Value.SetPointer\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=44981:45024#L1492\">SetPointer</a>  </h3> <pre data-language=\"go\">func (v Value) SetPointer(x unsafe.Pointer)</pre> <p> SetPointer sets the unsafe.Pointer value v to x. It panics if v's Kind is not UnsafePointer. </p> <h3 id=\"Value.SetString\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=45217:45251#L1500\">SetString</a>  </h3> <pre data-language=\"go\">func (v Value) SetString(x string)</pre> <p> SetString sets v's underlying value to x. It panics if v's Kind is not String or if CanSet() is false. </p> <h3 id=\"Value.SetUint\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=44464:44496#L1470\">SetUint</a>  </h3> <pre data-language=\"go\">func (v Value) SetUint(x uint64)</pre> <p> SetUint sets v's underlying value to x. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false. </p> <h3 id=\"Value.Slice\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=45476:45512#L1509\">Slice</a>  </h3> <pre data-language=\"go\">func (v Value) Slice(i, j int) Value</pre> <p> Slice returns v[i:j]. It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array, or if the indexes are out of bounds. </p> <h3 id=\"Value.Slice3\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=47030:47070#L1568\">Slice3</a>  </h3> <pre data-language=\"go\">func (v Value) Slice3(i, j, k int) Value</pre> <p> Slice3 is the 3-index form of the slice operation: it returns v[i:j:k]. It panics if v's Kind is not Array or Slice, or if v is an unaddressable array, or if the indexes are out of bounds. </p> <h3 id=\"Value.String\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=48601:48631#L1623\">String</a>  </h3> <pre data-language=\"go\">func (v Value) String() string</pre> <p> String returns the string v's underlying value, as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Kind is not String. Instead, it returns a string of the form \"&lt;T value&gt;\" where T is v's type. The fmt package treats Values specially. It does not call their String method implicitly but instead prints the concrete values they hold. </p> <h3 id=\"Value.TryRecv\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=49301:49344#L1640\">TryRecv</a>  </h3> <pre data-language=\"go\">func (v Value) TryRecv() (x Value, ok bool)</pre> <p> TryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false. </p> <h3 id=\"Value.TrySend\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=49627:49663#L1650\">TrySend</a>  </h3> <pre data-language=\"go\">func (v Value) TrySend(x Value) bool</pre> <p> TrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not Chan. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type. </p> <h3 id=\"Value.Type\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=49755:49781#L1657\">Type</a>  </h3> <pre data-language=\"go\">func (v Value) Type() Type</pre> <p> Type returns v's type. </p> <h3 id=\"Value.Uint\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=50642:50670#L1690\">Uint</a>  </h3> <pre data-language=\"go\">func (v Value) Uint() uint64</pre> <p> Uint returns v's underlying value, as a uint64. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64. </p> <h3 id=\"Value.UnsafeAddr\">func (Value) <a href=\"https://golang.org/src/reflect/value.go?s=51180:51215#L1713\">UnsafeAddr</a>  </h3> <pre data-language=\"go\">func (v Value) UnsafeAddr() uintptr</pre> <p> UnsafeAddr returns a pointer to v's data. It is for advanced clients that also import the \"unsafe\" package. It panics if v is not addressable. </p> <h2 id=\"ValueError\">type ValueError  </h2> <pre data-language=\"go\">type ValueError struct {\n        Method string\n        Kind   Kind\n}</pre> <p> A ValueError occurs when a Value method is invoked on a Value that does not support it. Such cases are documented in the description of each method. </p> <h3 id=\"ValueError.Error\">func (*ValueError) <a href=\"https://golang.org/src/reflect/value.go?s=4999:5034#L145\">Error</a>  </h3> <pre data-language=\"go\">func (e *ValueError) Error() string</pre> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/reflect/type.go?s=6705:7210#L185\" style=\"float: left;\">☞</a> <p> FieldByName and related functions consider struct field names to be equal if the names are equal, even if they are unexported names originating in different packages. The practical effect of this is that the result of t.FieldByName(\"x\") is not well defined if the struct type t contains multiple fields named x (embedded from different packages). FieldByName may return one of the fields named x or may report that there are none. See golang.org/issue/4876 for more details. </p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/reflect/\" class=\"_attribution-link\">https://golang.org/pkg/reflect/</a>\n  </p>\n</div>\n","runtime/index":"<h1>Package runtime</h1>     <ul id=\"short-nav\">\n<li><code>import \"runtime\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package runtime contains operations that interact with Go's runtime system, such as functions to control goroutines. It also includes the low-level type information used by the reflect package; see reflect's documentation for the programmable interface to the run-time type system. </p> <h3 id=\"hdr-Environment_Variables\">Environment Variables</h3> <p> The following environment variables ($name or %name%, depending on the host operating system) control the run-time behavior of Go programs. The meanings and use may change from release to release. </p> <p> The GOGC variable sets the initial garbage collection target percentage. A collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. The default is GOGC=100. Setting GOGC=off disables the garbage collector entirely. The runtime/debug package's SetGCPercent function allows changing this percentage at run time. See <a href=\"debug/index#SetGCPercent\">https://golang.org/pkg/runtime/debug/#SetGCPercent</a>. </p> <p> The GODEBUG variable controls debugging variables within the runtime. It is a comma-separated list of name=val pairs setting these named variables: </p> <pre data-language=\"go\">allocfreetrace: setting allocfreetrace=1 causes every allocation to be\nprofiled and a stack trace printed on each object's allocation and free.\n\ncgocheck: setting cgocheck=0 disables all checks for packages\nusing cgo to incorrectly pass Go pointers to non-Go code.\nSetting cgocheck=1 (the default) enables relatively cheap\nchecks that may miss some errors.  Setting cgocheck=2 enables\nexpensive checks that should not miss any errors, but will\ncause your program to run slower.\n\nefence: setting efence=1 causes the allocator to run in a mode\nwhere each object is allocated on a unique page and addresses are\nnever recycled.\n\ngccheckmark: setting gccheckmark=1 enables verification of the\ngarbage collector's concurrent mark phase by performing a\nsecond mark pass while the world is stopped.  If the second\npass finds a reachable object that was not found by concurrent\nmark, the garbage collector will panic.\n\ngcpacertrace: setting gcpacertrace=1 causes the garbage collector to\nprint information about the internal state of the concurrent pacer.\n\ngcshrinkstackoff: setting gcshrinkstackoff=1 disables moving goroutines\nonto smaller stacks. In this mode, a goroutine's stack can only grow.\n\ngcstackbarrieroff: setting gcstackbarrieroff=1 disables the use of stack barriers\nthat allow the garbage collector to avoid repeating a stack scan during the\nmark termination phase.\n\ngcstackbarrierall: setting gcstackbarrierall=1 installs stack barriers\nin every stack frame, rather than in exponentially-spaced frames.\n\ngcstoptheworld: setting gcstoptheworld=1 disables concurrent garbage collection,\nmaking every garbage collection a stop-the-world event. Setting gcstoptheworld=2\nalso disables concurrent sweeping after the garbage collection finishes.\n\ngctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard\nerror at each collection, summarizing the amount of memory collected and the\nlength of the pause. Setting gctrace=2 emits the same summary but also\nrepeats each collection. The format of this line is subject to change.\nCurrently, it is:\n\tgc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-&gt;#-&gt;# MB, # MB goal, # P\nwhere the fields are as follows:\n\tgc #        the GC number, incremented at each GC\n\t@#s         time in seconds since program start\n\t#%          percentage of time spent in GC since program start\n\t#+...+#     wall-clock/CPU times for the phases of the GC\n\t#-&gt;#-&gt;# MB  heap size at GC start, at GC end, and live heap\n\t# MB goal   goal heap size\n\t# P         number of processors used\nThe phases are stop-the-world (STW) sweep termination, concurrent\nmark and scan, and STW mark termination. The CPU times\nfor mark/scan are broken down in to assist time (GC performed in\nline with allocation), background GC time, and idle GC time.\nIf the line ends with \"(forced)\", this GC was forced by a\nruntime.GC() call and all phases are STW.\n\nSetting gctrace to any value &gt; 0 also causes the garbage collector\nto emit a summary when memory is released back to the system.\nThis process of returning memory to the system is called scavenging.\nThe format of this summary is subject to change.\nCurrently it is:\n\tscvg#: # MB released  printed only if non-zero\n\tscvg#: inuse: # idle: # sys: # released: # consumed: # (MB)\nwhere the fields are as follows:\n\tscvg#        the scavenge cycle number, incremented at each scavenge\n\tinuse: #     MB used or partially used spans\n\tidle: #      MB spans pending scavenging\n\tsys: #       MB mapped from the system\n\treleased: #  MB released to the system\n\tconsumed: #  MB allocated from the system\n\nmemprofilerate: setting memprofilerate=X will update the value of runtime.MemProfileRate.\nWhen set to 0 memory profiling is disabled.  Refer to the description of\nMemProfileRate for the default value.\n\ninvalidptr: defaults to invalidptr=1, causing the garbage collector and stack\ncopier to crash the program if an invalid pointer value (for example, 1)\nis found in a pointer-typed location. Setting invalidptr=0 disables this check.\nThis should only be used as a temporary workaround to diagnose buggy code.\nThe real fix is to not store integers in pointer-typed locations.\n\nsbrk: setting sbrk=1 replaces the memory allocator and garbage collector\nwith a trivial allocator that obtains memory from the operating system and\nnever reclaims any memory.\n\nscavenge: scavenge=1 enables debugging mode of heap scavenger.\n\nscheddetail: setting schedtrace=X and scheddetail=1 causes the scheduler to emit\ndetailed multiline info every X milliseconds, describing state of the scheduler,\nprocessors, threads and goroutines.\n\nschedtrace: setting schedtrace=X causes the scheduler to emit a single line to standard\nerror every X milliseconds, summarizing the scheduler state.\n</pre> <p> The net and net/http packages also refer to debugging variables in GODEBUG. See the documentation for those packages for details. </p> <p> The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes the limit. </p> <p> The GOTRACEBACK variable controls the amount of output generated when a Go program fails due to an unrecovered panic or an unexpected runtime condition. By default, a failure prints a stack trace for the current goroutine, eliding functions internal to the run-time system, and then exits with exit code 2. The failure prints stack traces for all goroutines if there is no current goroutine or the failure is internal to the run-time. GOTRACEBACK=none omits the goroutine stack traces entirely. GOTRACEBACK=single (the default) behaves as described above. GOTRACEBACK=all adds stack traces for all user-created goroutines. GOTRACEBACK=system is like “all” but adds stack frames for run-time functions and shows goroutines created internally by the run-time. GOTRACEBACK=crash is like “system” but crashes in an operating system-specific manner instead of exiting. For example, on Unix systems, the crash raises SIGABRT to trigger a core dump. For historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for none, all, and system, respectively. The runtime/debug package's SetTraceback function allows increasing the amount of output at run time, but it cannot reduce the amount below that specified by the environment variable. See <a href=\"debug/index#SetTraceback\">https://golang.org/pkg/runtime/debug/#SetTraceback</a>. </p> <p> The GOARCH, GOOS, GOPATH, and GOROOT environment variables complete the set of Go environment variables. They influence the building of Go programs (see <a href=\"https://golang.org/cmd/go\">https://golang.org/cmd/go</a> and <a href=\"../go/build/index\">https://golang.org/pkg/go/build</a>). GOARCH, GOOS, and GOROOT are recorded at compile time and made available by constants or functions in this package, but they do not influence the execution of the run-time system. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#BlockProfile\">func BlockProfile(p []BlockProfileRecord) (n int, ok bool)</a></li>\n<li><a href=\"#Breakpoint\">func Breakpoint()</a></li>\n<li><a href=\"#CPUProfile\">func CPUProfile() []byte</a></li>\n<li><a href=\"#Caller\">func Caller(skip int) (pc uintptr, file string, line int, ok bool)</a></li>\n<li><a href=\"#Callers\">func Callers(skip int, pc []uintptr) int</a></li>\n<li><a href=\"#GC\">func GC()</a></li>\n<li><a href=\"#GOMAXPROCS\">func GOMAXPROCS(n int) int</a></li>\n<li><a href=\"#GOROOT\">func GOROOT() string</a></li>\n<li><a href=\"#Goexit\">func Goexit()</a></li>\n<li><a href=\"#GoroutineProfile\">func GoroutineProfile(p []StackRecord) (n int, ok bool)</a></li>\n<li><a href=\"#Gosched\">func Gosched()</a></li>\n<li><a href=\"#KeepAlive\">func KeepAlive(interface{})</a></li>\n<li><a href=\"#LockOSThread\">func LockOSThread()</a></li>\n<li><a href=\"#MemProfile\">func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)</a></li>\n<li><a href=\"#NumCPU\">func NumCPU() int</a></li>\n<li><a href=\"#NumCgoCall\">func NumCgoCall() int64</a></li>\n<li><a href=\"#NumGoroutine\">func NumGoroutine() int</a></li>\n<li><a href=\"#ReadMemStats\">func ReadMemStats(m *MemStats)</a></li>\n<li><a href=\"#ReadTrace\">func ReadTrace() []byte</a></li>\n<li><a href=\"#SetBlockProfileRate\">func SetBlockProfileRate(rate int)</a></li>\n<li><a href=\"#SetCPUProfileRate\">func SetCPUProfileRate(hz int)</a></li>\n<li><a href=\"#SetCgoTraceback\">func SetCgoTraceback(version int, traceback, context, symbolizer unsafe.Pointer)</a></li>\n<li><a href=\"#SetFinalizer\">func SetFinalizer(obj interface{}, finalizer interface{})</a></li>\n<li><a href=\"#Stack\">func Stack(buf []byte, all bool) int</a></li>\n<li><a href=\"#StartTrace\">func StartTrace() error</a></li>\n<li><a href=\"#StopTrace\">func StopTrace()</a></li>\n<li><a href=\"#ThreadCreateProfile\">func ThreadCreateProfile(p []StackRecord) (n int, ok bool)</a></li>\n<li><a href=\"#UnlockOSThread\">func UnlockOSThread()</a></li>\n<li><a href=\"#Version\">func Version() string</a></li>\n<li><a href=\"#BlockProfileRecord\">type BlockProfileRecord</a></li>\n<li><a href=\"#Error\">type Error</a></li>\n<li><a href=\"#Frame\">type Frame</a></li>\n<li><a href=\"#Frames\">type Frames</a></li>\n<li> <a href=\"#CallersFrames\">func CallersFrames(callers []uintptr) *Frames</a>\n</li>\n<li> <a href=\"#Frames.Next\">func (ci *Frames) Next() (frame Frame, more bool)</a>\n</li>\n<li><a href=\"#Func\">type Func</a></li>\n<li> <a href=\"#FuncForPC\">func FuncForPC(pc uintptr) *Func</a>\n</li>\n<li> <a href=\"#Func.Entry\">func (f *Func) Entry() uintptr</a>\n</li>\n<li> <a href=\"#Func.FileLine\">func (f *Func) FileLine(pc uintptr) (file string, line int)</a>\n</li>\n<li> <a href=\"#Func.Name\">func (f *Func) Name() string</a>\n</li>\n<li><a href=\"#MemProfileRecord\">type MemProfileRecord</a></li>\n<li> <a href=\"#MemProfileRecord.InUseBytes\">func (r *MemProfileRecord) InUseBytes() int64</a>\n</li>\n<li> <a href=\"#MemProfileRecord.InUseObjects\">func (r *MemProfileRecord) InUseObjects() int64</a>\n</li>\n<li> <a href=\"#MemProfileRecord.Stack\">func (r *MemProfileRecord) Stack() []uintptr</a>\n</li>\n<li><a href=\"#MemStats\">type MemStats</a></li>\n<li><a href=\"#StackRecord\">type StackRecord</a></li>\n<li> <a href=\"#StackRecord.Stack\">func (r *StackRecord) Stack() []uintptr</a>\n</li>\n<li><a href=\"#TypeAssertionError\">type TypeAssertionError</a></li>\n<li> <a href=\"#TypeAssertionError.Error\">func (e *TypeAssertionError) Error() string</a>\n</li>\n<li> <a href=\"#TypeAssertionError.RuntimeError\">func (*TypeAssertionError) RuntimeError()</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/runtime/alg.go\">alg.go</a> <a href=\"https://golang.org/src/runtime/atomic_pointer.go\">atomic_pointer.go</a> <a href=\"https://golang.org/src/runtime/cgo.go\">cgo.go</a> <a href=\"https://golang.org/src/runtime/cgo_mmap.go\">cgo_mmap.go</a> <a href=\"https://golang.org/src/runtime/cgocall.go\">cgocall.go</a> <a href=\"https://golang.org/src/runtime/cgocallback.go\">cgocallback.go</a> <a href=\"https://golang.org/src/runtime/cgocheck.go\">cgocheck.go</a> <a href=\"https://golang.org/src/runtime/chan.go\">chan.go</a> <a href=\"https://golang.org/src/runtime/compiler.go\">compiler.go</a> <a href=\"https://golang.org/src/runtime/complex.go\">complex.go</a> <a href=\"https://golang.org/src/runtime/cpuprof.go\">cpuprof.go</a> <a href=\"https://golang.org/src/runtime/cputicks.go\">cputicks.go</a> <a href=\"https://golang.org/src/runtime/debug.go\">debug.go</a> <a href=\"https://golang.org/src/runtime/defs_linux_amd64.go\">defs_linux_amd64.go</a> <a href=\"https://golang.org/src/runtime/env_posix.go\">env_posix.go</a> <a href=\"https://golang.org/src/runtime/error.go\">error.go</a> <a href=\"https://golang.org/src/runtime/extern.go\">extern.go</a> <a href=\"https://golang.org/src/runtime/fastlog2.go\">fastlog2.go</a> <a href=\"https://golang.org/src/runtime/fastlog2table.go\">fastlog2table.go</a> <a href=\"https://golang.org/src/runtime/hash64.go\">hash64.go</a> <a href=\"https://golang.org/src/runtime/hashmap.go\">hashmap.go</a> <a href=\"https://golang.org/src/runtime/hashmap_fast.go\">hashmap_fast.go</a> <a href=\"https://golang.org/src/runtime/heapdump.go\">heapdump.go</a> <a href=\"https://golang.org/src/runtime/iface.go\">iface.go</a> <a href=\"https://golang.org/src/runtime/lfstack.go\">lfstack.go</a> <a href=\"https://golang.org/src/runtime/lfstack_64bit.go\">lfstack_64bit.go</a> <a href=\"https://golang.org/src/runtime/lock_futex.go\">lock_futex.go</a> <a href=\"https://golang.org/src/runtime/malloc.go\">malloc.go</a> <a href=\"https://golang.org/src/runtime/mbarrier.go\">mbarrier.go</a> <a href=\"https://golang.org/src/runtime/mbitmap.go\">mbitmap.go</a> <a href=\"https://golang.org/src/runtime/mcache.go\">mcache.go</a> <a href=\"https://golang.org/src/runtime/mcentral.go\">mcentral.go</a> <a href=\"https://golang.org/src/runtime/mem_linux.go\">mem_linux.go</a> <a href=\"https://golang.org/src/runtime/mfinal.go\">mfinal.go</a> <a href=\"https://golang.org/src/runtime/mfixalloc.go\">mfixalloc.go</a> <a href=\"https://golang.org/src/runtime/mgc.go\">mgc.go</a> <a href=\"https://golang.org/src/runtime/mgcmark.go\">mgcmark.go</a> <a href=\"https://golang.org/src/runtime/mgcsweep.go\">mgcsweep.go</a> <a href=\"https://golang.org/src/runtime/mgcwork.go\">mgcwork.go</a> <a href=\"https://golang.org/src/runtime/mheap.go\">mheap.go</a> <a href=\"https://golang.org/src/runtime/mprof.go\">mprof.go</a> <a href=\"https://golang.org/src/runtime/msan0.go\">msan0.go</a> <a href=\"https://golang.org/src/runtime/msize.go\">msize.go</a> <a href=\"https://golang.org/src/runtime/mstats.go\">mstats.go</a> <a href=\"https://golang.org/src/runtime/mstkbar.go\">mstkbar.go</a> <a href=\"https://golang.org/src/runtime/netpoll.go\">netpoll.go</a> <a href=\"https://golang.org/src/runtime/netpoll_epoll.go\">netpoll_epoll.go</a> <a href=\"https://golang.org/src/runtime/os_linux.go\">os_linux.go</a> <a href=\"https://golang.org/src/runtime/os_linux_generic.go\">os_linux_generic.go</a> <a href=\"https://golang.org/src/runtime/panic.go\">panic.go</a> <a href=\"https://golang.org/src/runtime/print.go\">print.go</a> <a href=\"https://golang.org/src/runtime/proc.go\">proc.go</a> <a href=\"https://golang.org/src/runtime/race0.go\">race0.go</a> <a href=\"https://golang.org/src/runtime/rdebug.go\">rdebug.go</a> <a href=\"https://golang.org/src/runtime/rune.go\">rune.go</a> <a href=\"https://golang.org/src/runtime/runtime.go\">runtime.go</a> <a href=\"https://golang.org/src/runtime/runtime1.go\">runtime1.go</a> <a href=\"https://golang.org/src/runtime/runtime2.go\">runtime2.go</a> <a href=\"https://golang.org/src/runtime/select.go\">select.go</a> <a href=\"https://golang.org/src/runtime/sema.go\">sema.go</a> <a href=\"https://golang.org/src/runtime/signal1_unix.go\">signal1_unix.go</a> <a href=\"https://golang.org/src/runtime/signal2_unix.go\">signal2_unix.go</a> <a href=\"https://golang.org/src/runtime/signal_amd64x.go\">signal_amd64x.go</a> <a href=\"https://golang.org/src/runtime/signal_linux_amd64.go\">signal_linux_amd64.go</a> <a href=\"https://golang.org/src/runtime/signal_sigtramp.go\">signal_sigtramp.go</a> <a href=\"https://golang.org/src/runtime/signal_unix.go\">signal_unix.go</a> <a href=\"https://golang.org/src/runtime/sigpanic_unix.go\">sigpanic_unix.go</a> <a href=\"https://golang.org/src/runtime/sigqueue.go\">sigqueue.go</a> <a href=\"https://golang.org/src/runtime/sigtab_linux_generic.go\">sigtab_linux_generic.go</a> <a href=\"https://golang.org/src/runtime/slice.go\">slice.go</a> <a href=\"https://golang.org/src/runtime/softfloat64.go\">softfloat64.go</a> <a href=\"https://golang.org/src/runtime/sqrt.go\">sqrt.go</a> <a href=\"https://golang.org/src/runtime/stack.go\">stack.go</a> <a href=\"https://golang.org/src/runtime/string.go\">string.go</a> <a href=\"https://golang.org/src/runtime/stubs.go\">stubs.go</a> <a href=\"https://golang.org/src/runtime/stubs2.go\">stubs2.go</a> <a href=\"https://golang.org/src/runtime/symtab.go\">symtab.go</a> <a href=\"https://golang.org/src/runtime/sys_nonppc64x.go\">sys_nonppc64x.go</a> <a href=\"https://golang.org/src/runtime/sys_x86.go\">sys_x86.go</a> <a href=\"https://golang.org/src/runtime/time.go\">time.go</a> <a href=\"https://golang.org/src/runtime/trace.go\">trace.go</a> <a href=\"https://golang.org/src/runtime/traceback.go\">traceback.go</a> <a href=\"https://golang.org/src/runtime/type.go\">type.go</a> <a href=\"https://golang.org/src/runtime/typekind.go\">typekind.go</a> <a href=\"https://golang.org/src/runtime/unaligned1.go\">unaligned1.go</a> <a href=\"https://golang.org/src/runtime/vdso_linux_amd64.go\">vdso_linux_amd64.go</a> <a href=\"https://golang.org/src/runtime/write_err.go\">write_err.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const Compiler = \"gc\"</pre> <p> Compiler is the name of the compiler toolchain that built the running binary. Known toolchains are: </p> <pre data-language=\"go\">gc      Also known as cmd/compile.\ngccgo   The gccgo front end, part of the GCC compiler suite.\n</pre> <pre data-language=\"go\">const GOARCH string = sys.GOARCH</pre> <p> GOARCH is the running program's architecture target: 386, amd64, arm, or s390x. </p> <pre data-language=\"go\">const GOOS string = sys.GOOS</pre> <p> GOOS is the running program's operating system target: one of darwin, freebsd, linux, and so on. </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var MemProfileRate int = 512 * 1024</pre> <p> MemProfileRate controls the fraction of memory allocations that are recorded and reported in the memory profile. The profiler aims to sample an average of one allocation per MemProfileRate bytes allocated. </p> <p> To include every allocated block in the profile, set MemProfileRate to 1. To turn off profiling entirely, set MemProfileRate to 0. </p> <p> The tools that process the memory profiles assume that the profile rate is constant across the lifetime of the program and equal to the current value. Programs that change the memory profiling rate should do so just once, as early as possible in the execution of the program (for example, at the beginning of main). </p> <h2 id=\"BlockProfile\">func BlockProfile  </h2> <pre data-language=\"go\">func BlockProfile(p []BlockProfileRecord) (n int, ok bool)</pre> <p> BlockProfile returns n, the number of records in the current blocking profile. If len(p) &gt;= n, BlockProfile copies the profile into p and returns n, true. If len(p) &lt; n, BlockProfile does not change p and returns n, false. </p> <p> Most clients should use the runtime/pprof package or the testing package's -test.blockprofile flag instead of calling BlockProfile directly. </p> <h2 id=\"Breakpoint\">func Breakpoint  </h2> <pre data-language=\"go\">func Breakpoint()</pre> <p> Breakpoint executes a breakpoint trap. </p> <h2 id=\"CPUProfile\">func CPUProfile  </h2> <pre data-language=\"go\">func CPUProfile() []byte</pre> <p> CPUProfile returns the next chunk of binary CPU profiling stack trace data, blocking until data is available. If profiling is turned off and all the profile data accumulated while it was on has been returned, CPUProfile returns nil. The caller must save the returned data before calling CPUProfile again. </p> <p> Most clients should use the runtime/pprof package or the testing package's -test.cpuprofile flag instead of calling CPUProfile directly. </p> <h2 id=\"Caller\">func Caller  </h2> <pre data-language=\"go\">func Caller(skip int) (pc uintptr, file string, line int, ok bool)</pre> <p> Caller reports file and line number information about function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to ascend, with 0 identifying the caller of Caller. (For historical reasons the meaning of skip differs between Caller and Callers.) The return values report the program counter, file name, and line number within the file of the corresponding call. The boolean ok is false if it was not possible to recover the information. </p> <h2 id=\"Callers\">func Callers  </h2> <pre data-language=\"go\">func Callers(skip int, pc []uintptr) int</pre> <p> Callers fills the slice pc with the return program counters of function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to skip before recording in pc, with 0 identifying the frame for Callers itself and 1 identifying the caller of Callers. It returns the number of entries written to pc. </p> <p> Note that since each slice entry pc[i] is a return program counter, looking up the file and line for pc[i] (for example, using (*Func).FileLine) will normally return the file and line number of the instruction immediately following the call. To easily look up file/line information for the call sequence, use Frames. </p> <h2 id=\"GC\">func GC  </h2> <pre data-language=\"go\">func GC()</pre> <p> GC runs a garbage collection and blocks the caller until the garbage collection is complete. It may also block the entire program. </p> <h2 id=\"GOMAXPROCS\">func GOMAXPROCS  </h2> <pre data-language=\"go\">func GOMAXPROCS(n int) int</pre> <p> GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n &lt; 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves. </p> <h2 id=\"GOROOT\">func GOROOT  </h2> <pre data-language=\"go\">func GOROOT() string</pre> <p> GOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set, or else the root used during the Go build. </p> <h2 id=\"Goexit\">func Goexit  </h2> <pre data-language=\"go\">func Goexit()</pre> <p> Goexit terminates the goroutine that calls it. No other goroutine is affected. Goexit runs all deferred calls before terminating the goroutine. Because Goexit is not panic, however, any recover calls in those deferred functions will return nil. </p> <p> Calling Goexit from the main goroutine terminates that goroutine without func main returning. Since func main has not returned, the program continues execution of other goroutines. If all other goroutines exit, the program crashes. </p> <h2 id=\"GoroutineProfile\">func GoroutineProfile  </h2> <pre data-language=\"go\">func GoroutineProfile(p []StackRecord) (n int, ok bool)</pre> <p> GoroutineProfile returns n, the number of records in the active goroutine stack profile. If len(p) &gt;= n, GoroutineProfile copies the profile into p and returns n, true. If len(p) &lt; n, GoroutineProfile does not change p and returns n, false. </p> <p> Most clients should use the runtime/pprof package instead of calling GoroutineProfile directly. </p> <h2 id=\"Gosched\">func Gosched  </h2> <pre data-language=\"go\">func Gosched()</pre> <p> Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically. </p> <h2 id=\"KeepAlive\">func KeepAlive  </h2> <pre data-language=\"go\">func KeepAlive(interface{})</pre> <p> KeepAlive marks its argument as currently reachable. This ensures that the object is not freed, and its finalizer is not run, before the point in the program where KeepAlive is called. </p> <p> A very simplified example showing where KeepAlive is required: </p> <pre data-language=\"go\">type File struct { d int }\nd, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)\n// ... do something if err != nil ...\np := &amp;File{d}\nruntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\nvar buf [10]byte\nn, err := syscall.Read(p.d, buf[:])\n// Ensure p is not finalized until Read returns.\nruntime.KeepAlive(p)\n// No more uses of p after this point.\n</pre> <p> Without the KeepAlive call, the finalizer could run at the start of syscall.Read, closing the file descriptor before syscall.Read makes the actual system call. </p> <h2 id=\"LockOSThread\">func LockOSThread  </h2> <pre data-language=\"go\">func LockOSThread()</pre> <p> LockOSThread wires the calling goroutine to its current operating system thread. Until the calling goroutine exits or calls UnlockOSThread, it will always execute in that thread, and no other goroutine can. </p> <h2 id=\"MemProfile\">func MemProfile  </h2> <pre data-language=\"go\">func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)</pre> <p> MemProfile returns a profile of memory allocated and freed per allocation site. </p> <p> MemProfile returns n, the number of records in the current memory profile. If len(p) &gt;= n, MemProfile copies the profile into p and returns n, true. If len(p) &lt; n, MemProfile does not change p and returns n, false. </p> <p> If inuseZero is true, the profile includes allocation records where r.AllocBytes &gt; 0 but r.AllocBytes == r.FreeBytes. These are sites where memory was allocated, but it has all been released back to the runtime. </p> <p> The returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector. </p> <p> Most clients should use the runtime/pprof package or the testing package's -test.memprofile flag instead of calling MemProfile directly. </p> <h2 id=\"NumCPU\">func NumCPU  </h2> <pre data-language=\"go\">func NumCPU() int</pre> <p> NumCPU returns the number of logical CPUs usable by the current process. </p> <p> The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected. </p> <h2 id=\"NumCgoCall\">func NumCgoCall  </h2> <pre data-language=\"go\">func NumCgoCall() int64</pre> <p> NumCgoCall returns the number of cgo calls made by the current process. </p> <h2 id=\"NumGoroutine\">func NumGoroutine  </h2> <pre data-language=\"go\">func NumGoroutine() int</pre> <p> NumGoroutine returns the number of goroutines that currently exist. </p> <h2 id=\"ReadMemStats\">func ReadMemStats  </h2> <pre data-language=\"go\">func ReadMemStats(m *MemStats)</pre> <p> ReadMemStats populates m with memory allocator statistics. </p> <h2 id=\"ReadTrace\">func ReadTrace  </h2> <pre data-language=\"go\">func ReadTrace() []byte</pre> <p> ReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time. </p> <h2 id=\"SetBlockProfileRate\">func SetBlockProfileRate  </h2> <pre data-language=\"go\">func SetBlockProfileRate(rate int)</pre> <p> SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked. </p> <p> To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate &lt;= 0. </p> <h2 id=\"SetCPUProfileRate\">func SetCPUProfileRate  </h2> <pre data-language=\"go\">func SetCPUProfileRate(hz int)</pre> <p> SetCPUProfileRate sets the CPU profiling rate to hz samples per second. If hz &lt;= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the rate cannot be changed without first turning it off. </p> <p> Most clients should use the runtime/pprof package or the testing package's -test.cpuprofile flag instead of calling SetCPUProfileRate directly. </p> <h2 id=\"SetCgoTraceback\">func SetCgoTraceback  </h2> <pre data-language=\"go\">func SetCgoTraceback(version int, traceback, context, symbolizer unsafe.Pointer)</pre> <p> SetCgoTraceback records three C functions to use to gather traceback information from C code and to convert that traceback information into symbolic information. These are used when printing stack traces for a program that uses cgo. </p> <p> The traceback and context functions may be called from a signal handler, and must therefore use only async-signal safe functions. The symbolizer function may be called while the program is crashing, and so must be cautious about using memory. None of the functions may call back into Go. </p> <p> The context function will be called with a single argument, a pointer to a struct: </p> <pre data-language=\"go\">struct {\n\tContext uintptr\n}\n</pre> <p> In C syntax, this struct will be </p> <pre data-language=\"go\">struct {\n\tuintptr_t Context;\n};\n</pre> <p> If the Context field is 0, the context function is being called to record the current traceback context. It should record in the Context field whatever information is needed about the current point of execution to later produce a stack trace, probably the stack pointer and PC. In this case the context function will be called from C code. </p> <p> If the Context field is not 0, then it is a value returned by a previous call to the context function. This case is called when the context is no longer needed; that is, when the Go code is returning to its C code caller. This permits the context function to release any associated resources. </p> <p> While it would be correct for the context function to record a complete a stack trace whenever it is called, and simply copy that out in the traceback function, in a typical program the context function will be called many times without ever recording a traceback for that context. Recording a complete stack trace in a call to the context function is likely to be inefficient. </p> <p> The traceback function will be called with a single argument, a pointer to a struct: </p> <pre data-language=\"go\">struct {\n\tContext    uintptr\n\tSigContext uintptr\n\tBuf        *uintptr\n\tMax        uintptr\n}\n</pre> <p> In C syntax, this struct will be </p> <pre data-language=\"go\">struct {\n\tuintptr_t  Context;\n\tuintptr_t  SigContext;\n\tuintptr_t* Buf;\n\tuintptr_t  Max;\n};\n</pre> <p> The Context field will be zero to gather a traceback from the current program execution point. In this case, the traceback function will be called from C code. </p> <p> Otherwise Context will be a value previously returned by a call to the context function. The traceback function should gather a stack trace from that saved point in the program execution. The traceback function may be called from an execution thread other than the one that recorded the context, but only when the context is known to be valid and unchanging. The traceback function may also be called deeper in the call stack on the same thread that recorded the context. The traceback function may be called multiple times with the same Context value; it will usually be appropriate to cache the result, if possible, the first time this is called for a specific context value. </p> <p> If the traceback function is called from a signal handler on a Unix system, SigContext will be the signal context argument passed to the signal handler (a C ucontext_t* cast to uintptr_t). This may be used to start tracing at the point where the signal occurred. If the traceback function is not called from a signal handler, SigContext will be zero. </p> <p> Buf is where the traceback information should be stored. It should be PC values, such that Buf[0] is the PC of the caller, Buf[1] is the PC of that function's caller, and so on. Max is the maximum number of entries to store. The function should store a zero to indicate the top of the stack, or that the caller is on a different stack, presumably a Go stack. </p> <p> Unlike runtime.Callers, the PC values returned should, when passed to the symbolizer function, return the file/line of the call instruction. No additional subtraction is required or appropriate. </p> <p> The symbolizer function will be called with a single argument, a pointer to a struct: </p> <pre data-language=\"go\">struct {\n\tPC      uintptr // program counter to fetch information for\n\tFile    *byte   // file name (NUL terminated)\n\tLineno  uintptr // line number\n\tFunc    *byte   // function name (NUL terminated)\n\tEntry   uintptr // function entry point\n\tMore    uintptr // set non-zero if more info for this PC\n\tData    uintptr // unused by runtime, available for function\n}\n</pre> <p> In C syntax, this struct will be </p> <pre data-language=\"go\">struct {\n\tuintptr_t PC;\n\tchar*     File;\n\tuintptr_t Lineno;\n\tchar*     Func;\n\tuintptr_t Entry;\n\tuintptr_t More;\n\tuintptr_t Data;\n};\n</pre> <p> The PC field will be a value returned by a call to the traceback function. </p> <p> The first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls. </p> <p> When calling SetCgoTraceback, the version argument is the version number of the structs that the functions expect to receive. Currently this must be zero. </p> <p> The symbolizer function may be nil, in which case the results of the traceback function will be displayed as numbers. If the traceback function is nil, the symbolizer function will never be called. The context function may be nil, in which case the traceback function will only be called with the context field set to zero. If the context function is nil, then calls from Go to C to Go will not show a traceback for the C portion of the call stack. </p> <p> SetCgoTraceback should be called only once, ideally from an init function. </p> <h2 id=\"SetFinalizer\">func SetFinalizer  </h2> <pre data-language=\"go\">func SetFinalizer(obj interface{}, finalizer interface{})</pre> <p> SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again, but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj. </p> <p> SetFinalizer(obj, nil) clears any finalizer associated with obj. </p> <p> The argument obj must be a pointer to an object allocated by calling new or by taking the address of a composite literal. The argument finalizer must be a function that takes a single argument to which obj's type can be assigned, and can have arbitrary ignored return values. If either of these is not true, SetFinalizer aborts the program. </p> <p> Finalizers are run in dependency order: if A points at B, both have finalizers, and they are otherwise unreachable, only the finalizer for A runs; once A is freed, the finalizer for B can run. If a cyclic structure includes a block with a finalizer, that cycle is not guaranteed to be garbage collected and the finalizer is not guaranteed to run, because there is no ordering that respects the dependencies. </p> <p> The finalizer for obj is scheduled to run at some arbitrary time after obj becomes unreachable. There is no guarantee that finalizers will run before a program exits, so typically they are useful only for releasing non-memory resources associated with an object during a long-running program. For example, an os.File object could use a finalizer to close the associated operating system file descriptor when a program discards an os.File without calling Close, but it would be a mistake to depend on a finalizer to flush an in-memory I/O buffer such as a bufio.Writer, because the buffer would not be flushed at program exit. </p> <p> It is not guaranteed that a finalizer will run if the size of *obj is zero bytes. </p> <p> It is not guaranteed that a finalizer will run for objects allocated in initializers for package-level variables. Such objects may be linker-allocated, not heap-allocated. </p> <p> A finalizer may run as soon as an object becomes unreachable. In order to use finalizers correctly, the program must ensure that the object is reachable until it is no longer required. Objects stored in global variables, or that can be found by tracing pointers from a global variable, are reachable. For other objects, pass the object to a call of the KeepAlive function to mark the last point in the function where the object must be reachable. </p> <p> For example, if p points to a struct that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write. </p> <p> A single goroutine runs all finalizers for a program, sequentially. If a finalizer must run for a long time, it should do so by starting a new goroutine. </p> <h2 id=\"Stack\">func Stack  </h2> <pre data-language=\"go\">func Stack(buf []byte, all bool) int</pre> <p> Stack formats a stack trace of the calling goroutine into buf and returns the number of bytes written to buf. If all is true, Stack formats stack traces of all other goroutines into buf after the trace for the current goroutine. </p> <h2 id=\"StartTrace\">func StartTrace  </h2> <pre data-language=\"go\">func StartTrace() error</pre> <p> StartTrace enables tracing for the current process. While tracing, the data will be buffered and available via ReadTrace. StartTrace returns an error if tracing is already enabled. Most clients should use the runtime/trace package or the testing package's -test.trace flag instead of calling StartTrace directly. </p> <h2 id=\"StopTrace\">func StopTrace  </h2> <pre data-language=\"go\">func StopTrace()</pre> <p> StopTrace stops tracing, if it was previously enabled. StopTrace only returns after all the reads for the trace have completed. </p> <h2 id=\"ThreadCreateProfile\">func ThreadCreateProfile  </h2> <pre data-language=\"go\">func ThreadCreateProfile(p []StackRecord) (n int, ok bool)</pre> <p> ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) &gt;= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) &lt; n, ThreadCreateProfile does not change p and returns n, false. </p> <p> Most clients should use the runtime/pprof package instead of calling ThreadCreateProfile directly. </p> <h2 id=\"UnlockOSThread\">func UnlockOSThread  </h2> <pre data-language=\"go\">func UnlockOSThread()</pre> <p> UnlockOSThread unwires the calling goroutine from its fixed operating system thread. If the calling goroutine has not called LockOSThread, UnlockOSThread is a no-op. </p> <h2 id=\"Version\">func Version  </h2> <pre data-language=\"go\">func Version() string</pre> <p> Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like \"go1.3\". </p> <h2 id=\"BlockProfileRecord\">type BlockProfileRecord  </h2> <pre data-language=\"go\">type BlockProfileRecord struct {\n        Count  int64\n        Cycles int64\n        StackRecord\n}</pre> <p> BlockProfileRecord describes blocking events originated at a particular call sequence (stack trace). </p> <h2 id=\"Error\">type Error  </h2> <pre data-language=\"go\">type Error interface {\n        error\n\n        // RuntimeError is a no-op function but\n        // serves to distinguish types that are run time\n        // errors from ordinary errors: a type is a\n        // run time error if it has a RuntimeError method.\n        RuntimeError()\n}</pre> <p> The Error interface identifies a run time error. </p> <h2 id=\"Frame\">type Frame  </h2> <pre data-language=\"go\">type Frame struct {\n        // Program counter for this frame; multiple frames may have\n        // the same PC value.\n        PC uintptr\n\n        // Func for this frame; may be nil for non-Go code or fully\n        // inlined functions.\n        Func *Func\n\n        // Function name, file name, and line number for this call frame.\n        // May be the empty string or zero if not known.\n        // If Func is not nil then Function == Func.Name().\n        Function string\n        File     string\n        Line     int\n\n        // Entry point for the function; may be zero if not known.\n        // If Func is not nil then Entry == Func.Entry().\n        Entry uintptr\n}</pre> <p> Frame is the information returned by Frames for each call frame. </p> <h2 id=\"Frames\">type Frames  </h2> <pre data-language=\"go\">type Frames struct {\n        // contains filtered or unexported fields\n}</pre> <p> Frames may be used to get function/file/line information for a slice of PC values returned by Callers. </p> <h3 id=\"CallersFrames\">func <a href=\"https://golang.org/src/runtime/symtab.go?s=1476:1521#L42\">CallersFrames</a>  </h3> <pre data-language=\"go\">func CallersFrames(callers []uintptr) *Frames</pre> <p> CallersFrames takes a slice of PC values returned by Callers and prepares to return function/file/line information. Do not change the slice until you are done with the Frames. </p> <h3 id=\"Frames.Next\">func (*Frames) <a href=\"https://golang.org/src/runtime/symtab.go?s=1691:1740#L48\">Next</a>  </h3> <pre data-language=\"go\">func (ci *Frames) Next() (frame Frame, more bool)</pre> <p> Next returns frame information for the next caller. If more is false, there are no more callers (the Frame value is valid). </p> <h2 id=\"Func\">type Func  </h2> <pre data-language=\"go\">type Func struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Func represents a Go function in the running binary. </p> <h3 id=\"FuncForPC\">func <a href=\"https://golang.org/src/runtime/symtab.go?s=9543:9575#L313\">FuncForPC</a>  </h3> <pre data-language=\"go\">func FuncForPC(pc uintptr) *Func</pre> <p> FuncForPC returns a *Func describing the function that contains the given program counter address, or else nil. </p> <h3 id=\"Func.Entry\">func (*Func) <a href=\"https://golang.org/src/runtime/symtab.go?s=9781:9811#L323\">Entry</a>  </h3> <pre data-language=\"go\">func (f *Func) Entry() uintptr</pre> <p> Entry returns the entry address of the function. </p> <h3 id=\"Func.FileLine\">func (*Func) <a href=\"https://golang.org/src/runtime/symtab.go?s=10031:10090#L331\">FileLine</a>  </h3> <pre data-language=\"go\">func (f *Func) FileLine(pc uintptr) (file string, line int)</pre> <p> FileLine returns the file name and line number of the source code corresponding to the program counter pc. The result will not be accurate if pc is not a program counter within f. </p> <h3 id=\"Func.Name\">func (*Func) <a href=\"https://golang.org/src/runtime/symtab.go?s=9669:9697#L318\">Name</a>  </h3> <pre data-language=\"go\">func (f *Func) Name() string</pre> <p> Name returns the name of the function. </p> <h2 id=\"MemProfileRecord\">type MemProfileRecord  </h2> <pre data-language=\"go\">type MemProfileRecord struct {\n        AllocBytes, FreeBytes     int64       // number of bytes allocated, freed\n        AllocObjects, FreeObjects int64       // number of objects allocated, freed\n        Stack0                    [32]uintptr // stack trace for this record; ends at first 0 entry\n}</pre> <p> A MemProfileRecord describes the live objects allocated by a particular call sequence (stack trace). </p> <h3 id=\"MemProfileRecord.InUseBytes\">func (*MemProfileRecord) <a href=\"https://golang.org/src/runtime/mprof.go?s=9491:9536#L343\">InUseBytes</a>  </h3> <pre data-language=\"go\">func (r *MemProfileRecord) InUseBytes() int64</pre> <p> InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes). </p> <h3 id=\"MemProfileRecord.InUseObjects\">func (*MemProfileRecord) <a href=\"https://golang.org/src/runtime/mprof.go?s=9659:9706#L346\">InUseObjects</a>  </h3> <pre data-language=\"go\">func (r *MemProfileRecord) InUseObjects() int64</pre> <p> InUseObjects returns the number of objects in use (AllocObjects - FreeObjects). </p> <h3 id=\"MemProfileRecord.Stack\">func (*MemProfileRecord) <a href=\"https://golang.org/src/runtime/mprof.go?s=9837:9881#L352\">Stack</a>  </h3> <pre data-language=\"go\">func (r *MemProfileRecord) Stack() []uintptr</pre> <p> Stack returns the stack trace associated with the record, a prefix of r.Stack0. </p> <h2 id=\"MemStats\">type MemStats  </h2> <pre data-language=\"go\">type MemStats struct {\n        // General statistics.\n        Alloc      uint64 // bytes allocated and not yet freed\n        TotalAlloc uint64 // bytes allocated (even if freed)\n        Sys        uint64 // bytes obtained from system (sum of XxxSys below)\n        Lookups    uint64 // number of pointer lookups\n        Mallocs    uint64 // number of mallocs\n        Frees      uint64 // number of frees\n\n        // Main allocation heap statistics.\n        HeapAlloc    uint64 // bytes allocated and not yet freed (same as Alloc above)\n        HeapSys      uint64 // bytes obtained from system\n        HeapIdle     uint64 // bytes in idle spans\n        HeapInuse    uint64 // bytes in non-idle span\n        HeapReleased uint64 // bytes released to the OS\n        HeapObjects  uint64 // total number of allocated objects\n\n        // Low-level fixed-size structure allocator statistics.\n        //\tInuse is bytes used now.\n        //\tSys is bytes obtained from system.\n        StackInuse  uint64 // bytes used by stack allocator\n        StackSys    uint64\n        MSpanInuse  uint64 // mspan structures\n        MSpanSys    uint64\n        MCacheInuse uint64 // mcache structures\n        MCacheSys   uint64\n        BuckHashSys uint64 // profiling bucket hash table\n        GCSys       uint64 // GC metadata\n        OtherSys    uint64 // other system allocations\n\n        // Garbage collector statistics.\n        NextGC        uint64 // next collection will happen when HeapAlloc ≥ this amount\n        LastGC        uint64 // end time of last collection (nanoseconds since 1970)\n        PauseTotalNs  uint64\n        PauseNs       [256]uint64 // circular buffer of recent GC pause durations, most recent at [(NumGC+255)%256]\n        PauseEnd      [256]uint64 // circular buffer of recent GC pause end times\n        NumGC         uint32\n        GCCPUFraction float64 // fraction of CPU time used by GC\n        EnableGC      bool\n        DebugGC       bool\n\n        // Per-size allocation statistics.\n        // 61 is NumSizeClasses in the C code.\n        BySize [61]struct {\n                Size    uint32\n                Mallocs uint64\n                Frees   uint64\n        }\n}</pre> <p> A MemStats records statistics about the memory allocator. </p> <h2 id=\"StackRecord\">type StackRecord  </h2> <pre data-language=\"go\">type StackRecord struct {\n        Stack0 [32]uintptr // stack trace for this record; ends at first 0 entry\n}</pre> <p> A StackRecord describes a single execution stack. </p> <h3 id=\"StackRecord.Stack\">func (*StackRecord) <a href=\"https://golang.org/src/runtime/mprof.go?s=8157:8196#L309\">Stack</a>  </h3> <pre data-language=\"go\">func (r *StackRecord) Stack() []uintptr</pre> <p> Stack returns the stack trace associated with the record, a prefix of r.Stack0. </p> <h2 id=\"TypeAssertionError\">type TypeAssertionError  </h2> <pre data-language=\"go\">type TypeAssertionError struct {\n        // contains filtered or unexported fields\n}</pre> <p> A TypeAssertionError explains a failed type assertion. </p> <h3 id=\"TypeAssertionError.Error\">func (*TypeAssertionError) <a href=\"https://golang.org/src/runtime/error.go?s=760:803#L18\">Error</a>  </h3> <pre data-language=\"go\">func (e *TypeAssertionError) Error() string</pre> <h3 id=\"TypeAssertionError.RuntimeError\">func (*TypeAssertionError) <a href=\"https://golang.org/src/runtime/error.go?s=714:755#L16\">RuntimeError</a>  </h3> <pre data-language=\"go\">func (*TypeAssertionError) RuntimeError()</pre> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"cgo/index\">cgo</a> </td> <td class=\"pkg-synopsis\"> Package cgo contains runtime support for code generated by the cgo tool. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"debug/index\">debug</a> </td> <td class=\"pkg-synopsis\"> Package debug contains facilities for programs to debug themselves while they are running. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"msan/index\">msan</a> </td> <td class=\"pkg-synopsis\"> </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"pprof/index\">pprof</a> </td> <td class=\"pkg-synopsis\"> Package pprof writes runtime profiling data in the format expected by the pprof visualization tool. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"race/index\">race</a> </td> <td class=\"pkg-synopsis\"> Package race implements data race detection logic. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"trace/index\">trace</a> </td> <td class=\"pkg-synopsis\"> Go execution tracer. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/runtime/\" class=\"_attribution-link\">https://golang.org/pkg/runtime/</a>\n  </p>\n</div>\n","net/http/internal/index":"<h1>Package internal</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/http/internal\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package internal contains HTTP internals shared by net/http and net/http/httputil. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#NewChunkedReader\">func NewChunkedReader(r io.Reader) io.Reader</a></li>\n<li><a href=\"#NewChunkedWriter\">func NewChunkedWriter(w io.Writer) io.WriteCloser</a></li>\n<li><a href=\"#FlushAfterChunkWriter\">type FlushAfterChunkWriter</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/http/internal/chunked.go\">chunked.go</a> <a href=\"https://golang.org/src/net/http/internal/testcert.go\">testcert.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var ErrLineTooLong = errors.New(\"header line too long\")</pre> <pre data-language=\"go\">var LocalhostCert = []byte(`-----BEGIN CERTIFICATE-----\nMIICEzCCAXygAwIBAgIQMIMChMLGrR+QvmQvpwAU6zANBgkqhkiG9w0BAQsFADAS\nMRAwDgYDVQQKEwdBY21lIENvMCAXDTcwMDEwMTAwMDAwMFoYDzIwODQwMTI5MTYw\nMDAwWjASMRAwDgYDVQQKEwdBY21lIENvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQDuLnQAI3mDgey3VBzWnB2L39JUU4txjeVE6myuDqkM/uGlfjb9SjY1bIw4\niA5sBBZzHi3z0h1YV8QPuxEbi4nW91IJm2gsvvZhIrCHS3l6afab4pZBl2+XsDul\nrKBxKKtD1rGxlG4LjncdabFn9gvLZad2bSysqz/qTAUStTvqJQIDAQABo2gwZjAO\nBgNVHQ8BAf8EBAMCAqQwEwYDVR0lBAwwCgYIKwYBBQUHAwEwDwYDVR0TAQH/BAUw\nAwEB/zAuBgNVHREEJzAlggtleGFtcGxlLmNvbYcEfwAAAYcQAAAAAAAAAAAAAAAA\nAAAAATANBgkqhkiG9w0BAQsFAAOBgQCEcetwO59EWk7WiJsG4x8SY+UIAA+flUI9\ntyC4lNhbcF2Idq9greZwbYCqTTTr2XiRNSMLCOjKyI7ukPoPjo16ocHj+P3vZGfs\nh1fIw3cSS2OolhloGw/XM6RWPWtPAlGykKLciQrBru5NAPvCMsb/I1DAceTiotQM\nfblo6RBxUQ==\n-----END CERTIFICATE-----`)</pre> <p> LocalhostCert is a PEM-encoded TLS cert with SAN IPs \"127.0.0.1\" and \"[::1]\", expiring at Jan 29 16:00:00 2084 GMT. generated from src/crypto/tls: go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1,::1,example.com --ca --start-date \"Jan 1 00:00:00 1970\" --duration=1000000h </p> <pre data-language=\"go\">var LocalhostKey = []byte(`-----BEGIN RSA PRIVATE KEY-----\nMIICXgIBAAKBgQDuLnQAI3mDgey3VBzWnB2L39JUU4txjeVE6myuDqkM/uGlfjb9\nSjY1bIw4iA5sBBZzHi3z0h1YV8QPuxEbi4nW91IJm2gsvvZhIrCHS3l6afab4pZB\nl2+XsDulrKBxKKtD1rGxlG4LjncdabFn9gvLZad2bSysqz/qTAUStTvqJQIDAQAB\nAoGAGRzwwir7XvBOAy5tM/uV6e+Zf6anZzus1s1Y1ClbjbE6HXbnWWF/wbZGOpet\n3Zm4vD6MXc7jpTLryzTQIvVdfQbRc6+MUVeLKwZatTXtdZrhu+Jk7hx0nTPy8Jcb\nuJqFk541aEw+mMogY/xEcfbWd6IOkp+4xqjlFLBEDytgbIECQQDvH/E6nk+hgN4H\nqzzVtxxr397vWrjrIgPbJpQvBsafG7b0dA4AFjwVbFLmQcj2PprIMmPcQrooz8vp\njy4SHEg1AkEA/v13/5M47K9vCxmb8QeD/asydfsgS5TeuNi8DoUBEmiSJwma7FXY\nfFUtxuvL7XvjwjN5B30pNEbc6Iuyt7y4MQJBAIt21su4b3sjXNueLKH85Q+phy2U\nfQtuUE9txblTu14q3N7gHRZB4ZMhFYyDy8CKrN2cPg/Fvyt0Xlp/DoCzjA0CQQDU\ny2ptGsuSmgUtWj3NM9xuwYPm+Z/F84K6+ARYiZ6PYj013sovGKUFfYAqVXVlxtIX\nqyUBnu3X9ps8ZfjLZO7BAkEAlT4R5Yl6cGhaJQYZHOde3JEMhNRcVFMO8dJDaFeo\nf9Oeos0UUothgiDktdQHxdNEwLjQf7lJJBzV+5OtwswCWA==\n-----END RSA PRIVATE KEY-----`)</pre> <p> LocalhostKey is the private key for localhostCert. </p> <h2 id=\"NewChunkedReader\">func NewChunkedReader  </h2> <pre data-language=\"go\">func NewChunkedReader(r io.Reader) io.Reader</pre> <p> NewChunkedReader returns a new chunkedReader that translates the data read from r out of HTTP \"chunked\" format before returning it. The chunkedReader returns io.EOF when the final 0-length chunk is read. </p> <p> NewChunkedReader is not needed by normal applications. The http package automatically decodes chunking when reading response bodies. </p> <h2 id=\"NewChunkedWriter\">func NewChunkedWriter  </h2> <pre data-language=\"go\">func NewChunkedWriter(w io.Writer) io.WriteCloser</pre> <p> NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP \"chunked\" format before writing them to w. Closing the returned chunkedWriter sends the final 0-length chunk that marks the end of the stream. </p> <p> NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using newChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong. </p> <h2 id=\"FlushAfterChunkWriter\">type FlushAfterChunkWriter  </h2> <pre data-language=\"go\">type FlushAfterChunkWriter struct {\n        *bufio.Writer\n}</pre> <p> FlushAfterChunkWriter signals from the caller of NewChunkedWriter that each chunk should be followed by a flush. It is used by the http.Transport code to keep the buffering behavior for headers and trailers, but flush out chunks aggressively in the middle for request bodies which may be generated slowly. See Issue 6574. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/http/internal/\" class=\"_attribution-link\">https://golang.org/pkg/net/http/internal/</a>\n  </p>\n</div>\n","testing/index":"<h1>Package testing</h1>     <ul id=\"short-nav\">\n<li><code>import \"testing\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package testing provides support for automated testing of Go packages. It is intended to be used in concert with the “go test” command, which automates execution of any function of the form </p> <pre data-language=\"go\">func TestXxx(*testing.T)\n</pre> <p> where Xxx can be any alphanumeric string (but the first letter must not be in [a-z]) and serves to identify the test routine. </p> <p> Within these functions, use the Error, Fail or related methods to signal failure. </p> <p> To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the “go test” command is run. For more detail, run “go help test” and “go help testflag”. </p> <p> Tests and benchmarks may be skipped if not applicable with a call to the Skip method of *T and *B: </p> <pre data-language=\"go\">func TestTimeConsuming(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"skipping test in short mode.\")\n    }\n    ...\n}\n</pre> <h3 id=\"hdr-Benchmarks\">Benchmarks</h3> <p> Functions of the form </p> <pre data-language=\"go\">func BenchmarkXxx(*testing.B)\n</pre> <p> are considered benchmarks, and are executed by the \"go test\" command when its -bench flag is provided. Benchmarks are run sequentially. </p> <p> For a description of the testing flags, see <a href=\"https://golang.org/cmd/go/#hdr-Description_of_testing_flags\">https://golang.org/cmd/go/#hdr-Description_of_testing_flags</a>. </p> <p> A sample benchmark function looks like this: </p> <pre data-language=\"go\">func BenchmarkHello(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        fmt.Sprintf(\"hello\")\n    }\n}\n</pre> <p> The benchmark function must run the target code b.N times. During benchmark execution, b.N is adjusted until the benchmark function lasts long enough to be timed reliably. The output </p> <pre data-language=\"go\">BenchmarkHello    10000000    282 ns/op\n</pre> <p> means that the loop ran 10000000 times at a speed of 282 ns per loop. </p> <p> If a benchmark needs some expensive setup before running, the timer may be reset: </p> <pre data-language=\"go\">func BenchmarkBigLen(b *testing.B) {\n    big := NewBig()\n    b.ResetTimer()\n    for i := 0; i &lt; b.N; i++ {\n        big.Len()\n    }\n}\n</pre> <p> If a benchmark needs to test performance in a parallel setting, it may use the RunParallel helper function; such benchmarks are intended to be used with the go test -cpu flag: </p> <pre data-language=\"go\">func BenchmarkTemplateParallel(b *testing.B) {\n    templ := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\"))\n    b.RunParallel(func(pb *testing.PB) {\n        var buf bytes.Buffer\n        for pb.Next() {\n            buf.Reset()\n            templ.Execute(&amp;buf, \"World\")\n        }\n    })\n}\n</pre> <h3 id=\"hdr-Examples\">Examples</h3> <p> The package also runs and verifies example code. Example functions may include a concluding line comment that begins with \"Output:\" and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.) These are examples of an example: </p> <pre data-language=\"go\">func ExampleHello() {\n        fmt.Println(\"hello\")\n        // Output: hello\n}\n\nfunc ExampleSalutations() {\n        fmt.Println(\"hello, and\")\n        fmt.Println(\"goodbye\")\n        // Output:\n        // hello, and\n        // goodbye\n}\n</pre> <p> Example functions without output comments are compiled but not executed. </p> <p> The naming convention to declare examples for the package, a function F, a type T and method M on type T are: </p> <pre data-language=\"go\">func Example() { ... }\nfunc ExampleF() { ... }\nfunc ExampleT() { ... }\nfunc ExampleT_M() { ... }\n</pre> <p> Multiple example functions for a package/type/function/method may be provided by appending a distinct suffix to the name. The suffix must start with a lower-case letter. </p> <pre data-language=\"go\">func Example_suffix() { ... }\nfunc ExampleF_suffix() { ... }\nfunc ExampleT_suffix() { ... }\nfunc ExampleT_M_suffix() { ... }\n</pre> <p> The entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions. </p> <h3 id=\"hdr-Subtests_and_Sub_benchmarks\">Subtests and Sub-benchmarks</h3> <p> The Run methods of T and B allow defining subtests and sub-benchmarks, without having to define separate functions for each. This enables uses like table-driven benchmarks and creating hierarchical tests. It also provides a way to share common setup and tear-down code: </p> <pre data-language=\"go\">func TestFoo(t *testing.T) {\n    // &lt;setup code&gt;\n    t.Run(\"A=1\", func(t *testing.T) { ... })\n    t.Run(\"A=2\", func(t *testing.T) { ... })\n    t.Run(\"B=1\", func(t *testing.T) { ... })\n    // &lt;tear-down code&gt;\n}\n</pre> <p> Each subtest and sub-benchmark has a unique name: the combination of the name of the top-level test and the sequence of names passed to Run, separated by slashes, with an optional trailing sequence number for disambiguation. </p> <p> The argument to the -run and -bench command-line flags is a slash-separated list of regular expressions that match each name element in turn. For example: </p> <pre data-language=\"go\">go test -run Foo     # Run top-level tests matching \"Foo\".\ngo test -run Foo/A=  # Run subtests of Foo matching \"A=\".\ngo test -run /A=1    # Run all subtests of a top-level test matching \"A=1\".\n</pre> <p> Subtests can also be used to control parallelism. A parent test will only complete once all of its subtests complete. In this example, all tests are run in parallel with each other, and only with each other, regardless of other top-level tests that may be defined: </p> <pre data-language=\"go\">func TestGroupedParallel(t *testing.T) {\n    for _, tc := range tests {\n        tc := tc // capture range variable\n        t.Run(tc.Name, func(t *testing.T) {\n            t.Parallel()\n            ...\n        })\n    }\n}\n</pre> <p> Run does not return until parallel subtests have completed, providing a way to clean up after a group of parallel tests: </p> <pre data-language=\"go\">func TestTeardownParallel(t *testing.T) {\n    // This Run will not return until the parallel tests finish.\n    t.Run(\"group\", func(t *testing.T) {\n        t.Run(\"Test1\", parallelTest1)\n        t.Run(\"Test2\", parallelTest2)\n        t.Run(\"Test3\", parallelTest3)\n    })\n    // &lt;tear-down code&gt;\n}\n</pre> <h3 id=\"hdr-Main\">Main</h3> <p> It is sometimes necessary for a test program to do extra setup or teardown before or after testing. It is also sometimes necessary for a test to control which code runs on the main thread. To support these and other cases, if a test file contains a function: </p> <pre data-language=\"go\">func TestMain(m *testing.M)\n</pre> <p> then the generated test will call TestMain(m) instead of running the tests directly. TestMain runs in the main goroutine and can do whatever setup and teardown is necessary around a call to m.Run. It should then call os.Exit with the result of m.Run. When TestMain is called, flag.Parse has not been run. If TestMain depends on command-line flags, including those of the testing package, it should call flag.Parse explicitly. </p> <p> A simple implementation of TestMain is: </p> <pre data-language=\"go\">func TestMain(m *testing.M) {\n\tflag.Parse()\n\tos.Exit(m.Run())\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#AllocsPerRun\">func AllocsPerRun(runs int, f func()) (avg float64)</a></li>\n<li><a href=\"#Coverage\">func Coverage() float64</a></li>\n<li><a href=\"#Main\">func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)</a></li>\n<li><a href=\"#RegisterCover\">func RegisterCover(c Cover)</a></li>\n<li><a href=\"#RunBenchmarks\">func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)</a></li>\n<li><a href=\"#RunExamples\">func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)</a></li>\n<li><a href=\"#RunTests\">func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)</a></li>\n<li><a href=\"#Short\">func Short() bool</a></li>\n<li><a href=\"#Verbose\">func Verbose() bool</a></li>\n<li><a href=\"#B\">type B</a></li>\n<li> <a href=\"#B.Error\">func (c *B) Error(args ...interface{})</a>\n</li>\n<li> <a href=\"#B.Errorf\">func (c *B) Errorf(format string, args ...interface{})</a>\n</li>\n<li> <a href=\"#B.Fail\">func (c *B) Fail()</a>\n</li>\n<li> <a href=\"#B.FailNow\">func (c *B) FailNow()</a>\n</li>\n<li> <a href=\"#B.Failed\">func (c *B) Failed() bool</a>\n</li>\n<li> <a href=\"#B.Fatal\">func (c *B) Fatal(args ...interface{})</a>\n</li>\n<li> <a href=\"#B.Fatalf\">func (c *B) Fatalf(format string, args ...interface{})</a>\n</li>\n<li> <a href=\"#B.Log\">func (c *B) Log(args ...interface{})</a>\n</li>\n<li> <a href=\"#B.Logf\">func (c *B) Logf(format string, args ...interface{})</a>\n</li>\n<li> <a href=\"#B.ReportAllocs\">func (b *B) ReportAllocs()</a>\n</li>\n<li> <a href=\"#B.ResetTimer\">func (b *B) ResetTimer()</a>\n</li>\n<li> <a href=\"#B.Run\">func (b *B) Run(name string, f func(b *B)) bool</a>\n</li>\n<li> <a href=\"#B.RunParallel\">func (b *B) RunParallel(body func(*PB))</a>\n</li>\n<li> <a href=\"#B.SetBytes\">func (b *B) SetBytes(n int64)</a>\n</li>\n<li> <a href=\"#B.SetParallelism\">func (b *B) SetParallelism(p int)</a>\n</li>\n<li> <a href=\"#B.Skip\">func (c *B) Skip(args ...interface{})</a>\n</li>\n<li> <a href=\"#B.SkipNow\">func (c *B) SkipNow()</a>\n</li>\n<li> <a href=\"#B.Skipf\">func (c *B) Skipf(format string, args ...interface{})</a>\n</li>\n<li> <a href=\"#B.Skipped\">func (c *B) Skipped() bool</a>\n</li>\n<li> <a href=\"#B.StartTimer\">func (b *B) StartTimer()</a>\n</li>\n<li> <a href=\"#B.StopTimer\">func (b *B) StopTimer()</a>\n</li>\n<li><a href=\"#BenchmarkResult\">type BenchmarkResult</a></li>\n<li> <a href=\"#Benchmark\">func Benchmark(f func(b *B)) BenchmarkResult</a>\n</li>\n<li> <a href=\"#BenchmarkResult.AllocedBytesPerOp\">func (r BenchmarkResult) AllocedBytesPerOp() int64</a>\n</li>\n<li> <a href=\"#BenchmarkResult.AllocsPerOp\">func (r BenchmarkResult) AllocsPerOp() int64</a>\n</li>\n<li> <a href=\"#BenchmarkResult.MemString\">func (r BenchmarkResult) MemString() string</a>\n</li>\n<li> <a href=\"#BenchmarkResult.NsPerOp\">func (r BenchmarkResult) NsPerOp() int64</a>\n</li>\n<li> <a href=\"#BenchmarkResult.String\">func (r BenchmarkResult) String() string</a>\n</li>\n<li><a href=\"#Cover\">type Cover</a></li>\n<li><a href=\"#CoverBlock\">type CoverBlock</a></li>\n<li><a href=\"#InternalBenchmark\">type InternalBenchmark</a></li>\n<li><a href=\"#InternalExample\">type InternalExample</a></li>\n<li><a href=\"#InternalTest\">type InternalTest</a></li>\n<li><a href=\"#M\">type M</a></li>\n<li> <a href=\"#MainStart\">func MainStart(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) *M</a>\n</li>\n<li> <a href=\"#M.Run\">func (m *M) Run() int</a>\n</li>\n<li><a href=\"#PB\">type PB</a></li>\n<li> <a href=\"#PB.Next\">func (pb *PB) Next() bool</a>\n</li>\n<li><a href=\"#T\">type T</a></li>\n<li> <a href=\"#T.Error\">func (c *T) Error(args ...interface{})</a>\n</li>\n<li> <a href=\"#T.Errorf\">func (c *T) Errorf(format string, args ...interface{})</a>\n</li>\n<li> <a href=\"#T.Fail\">func (c *T) Fail()</a>\n</li>\n<li> <a href=\"#T.FailNow\">func (c *T) FailNow()</a>\n</li>\n<li> <a href=\"#T.Failed\">func (c *T) Failed() bool</a>\n</li>\n<li> <a href=\"#T.Fatal\">func (c *T) Fatal(args ...interface{})</a>\n</li>\n<li> <a href=\"#T.Fatalf\">func (c *T) Fatalf(format string, args ...interface{})</a>\n</li>\n<li> <a href=\"#T.Log\">func (c *T) Log(args ...interface{})</a>\n</li>\n<li> <a href=\"#T.Logf\">func (c *T) Logf(format string, args ...interface{})</a>\n</li>\n<li> <a href=\"#T.Parallel\">func (t *T) Parallel()</a>\n</li>\n<li> <a href=\"#T.Run\">func (t *T) Run(name string, f func(t *T)) bool</a>\n</li>\n<li> <a href=\"#T.Skip\">func (c *T) Skip(args ...interface{})</a>\n</li>\n<li> <a href=\"#T.SkipNow\">func (c *T) SkipNow()</a>\n</li>\n<li> <a href=\"#T.Skipf\">func (c *T) Skipf(format string, args ...interface{})</a>\n</li>\n<li> <a href=\"#T.Skipped\">func (c *T) Skipped() bool</a>\n</li>\n<li><a href=\"#TB\">type TB</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_B_RunParallel\">B.RunParallel</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/testing/allocs.go\">allocs.go</a> <a href=\"https://golang.org/src/testing/benchmark.go\">benchmark.go</a> <a href=\"https://golang.org/src/testing/cover.go\">cover.go</a> <a href=\"https://golang.org/src/testing/example.go\">example.go</a> <a href=\"https://golang.org/src/testing/match.go\">match.go</a> <a href=\"https://golang.org/src/testing/testing.go\">testing.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"AllocsPerRun\">func AllocsPerRun  </h2> <pre data-language=\"go\">func AllocsPerRun(runs int, f func()) (avg float64)</pre> <p> AllocsPerRun returns the average number of allocations during calls to f. Although the return value has type float64, it will always be an integral value. </p> <p> To compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned. </p> <p> AllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore it before returning. </p> <h2 id=\"Coverage\">func Coverage  </h2> <pre data-language=\"go\">func Coverage() float64</pre> <p> Coverage reports the current code coverage as a fraction in the range [0, 1]. If coverage is not enabled, Coverage returns 0. </p> <p> When running a large set of sequential test cases, checking Coverage after each one can be useful for identifying which test cases exercise new code paths. It is not a replacement for the reports generated by 'go test -cover' and 'go tool cover'. </p> <h2 id=\"Main\">func Main  </h2> <pre data-language=\"go\">func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)</pre> <p> An internal function but exported because it is cross-package; part of the implementation of the \"go test\" command. </p> <h2 id=\"RegisterCover\">func RegisterCover  </h2> <pre data-language=\"go\">func RegisterCover(c Cover)</pre> <p> RegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines. </p> <h2 id=\"RunBenchmarks\">func RunBenchmarks  </h2> <pre data-language=\"go\">func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)</pre> <p> An internal function but exported because it is cross-package; part of the implementation of the \"go test\" command. </p> <h2 id=\"RunExamples\">func RunExamples  </h2> <pre data-language=\"go\">func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)</pre> <h2 id=\"RunTests\">func RunTests  </h2> <pre data-language=\"go\">func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)</pre> <h2 id=\"Short\">func Short  </h2> <pre data-language=\"go\">func Short() bool</pre> <p> Short reports whether the -test.short flag is set. </p> <h2 id=\"Verbose\">func Verbose  </h2> <pre data-language=\"go\">func Verbose() bool</pre> <p> Verbose reports whether the -test.v flag is set. </p> <h2 id=\"B\">type B  </h2> <pre data-language=\"go\">type B struct {\n        N int\n        // contains filtered or unexported fields\n}</pre> <p> B is a type passed to Benchmark functions to manage benchmark timing and to specify the number of iterations to run. </p> <p> A benchmark ends when its Benchmark function returns or calls any of the methods FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods must be called only from the goroutine running the Benchmark function. The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines. </p> <p> Like in tests, benchmark logs are accumulated during execution and dumped to standard error when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results. </p> <h3 id=\"B.Error\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=17340:17383#L466\">Error</a>  </h3> <pre data-language=\"go\">func (c *B) Error(args ...interface{})</pre> <p> Error is equivalent to Log followed by Fail. </p> <h3 id=\"B.Errorf\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=17479:17538#L472\">Errorf</a>  </h3> <pre data-language=\"go\">func (c *B) Errorf(format string, args ...interface{})</pre> <p> Errorf is equivalent to Logf followed by Fail. </p> <h3 id=\"B.Fail\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=14580:14603#L394\">Fail</a>  </h3> <pre data-language=\"go\">func (c *B) Fail()</pre> <p> Fail marks the function as having failed but continues execution. </p> <h3 id=\"B.FailNow\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=15331:15357#L420\">FailNow</a>  </h3> <pre data-language=\"go\">func (c *B) FailNow()</pre> <p> FailNow marks the function as having failed and stops its execution. Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines. </p> <h3 id=\"B.Failed\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=14913:14943#L408\">Failed</a>  </h3> <pre data-language=\"go\">func (c *B) Failed() bool</pre> <p> Failed reports whether the function has failed. </p> <h3 id=\"B.Fatal\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=17642:17685#L478\">Fatal</a>  </h3> <pre data-language=\"go\">func (c *B) Fatal(args ...interface{})</pre> <p> Fatal is equivalent to Log followed by FailNow. </p> <h3 id=\"B.Fatalf\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=17787:17846#L484\">Fatalf</a>  </h3> <pre data-language=\"go\">func (c *B) Fatalf(format string, args ...interface{})</pre> <p> Fatalf is equivalent to Logf followed by FailNow. </p> <h3 id=\"B.Log\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=16794:16835#L457\">Log</a>  </h3> <pre data-language=\"go\">func (c *B) Log(args ...interface{})</pre> <p> Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. </p> <h3 id=\"B.Logf\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=17193:17250#L463\">Logf</a>  </h3> <pre data-language=\"go\">func (c *B) Logf(format string, args ...interface{})</pre> <p> Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. </p> <h3 id=\"B.ReportAllocs\">func (*B) <a href=\"https://golang.org/src/testing/benchmark.go?s=3906:3932#L107\">ReportAllocs</a>  </h3> <pre data-language=\"go\">func (b *B) ReportAllocs()</pre> <p> ReportAllocs enables malloc statistics for this benchmark. It is equivalent to setting -test.benchmem, but it only affects the benchmark function that calls ReportAllocs. </p> <h3 id=\"B.ResetTimer\">func (*B) <a href=\"https://golang.org/src/testing/benchmark.go?s=3315:3339#L88\">ResetTimer</a>  </h3> <pre data-language=\"go\">func (b *B) ResetTimer()</pre> <p> ResetTimer zeros the elapsed benchmark time and memory allocation counters. It does not affect whether the timer is running. </p> <h3 id=\"B.Run\">func (*B) <a href=\"https://golang.org/src/testing/benchmark.go?s=12650:12697#L449\">Run</a>  </h3> <pre data-language=\"go\">func (b *B) Run(name string, f func(b *B)) bool</pre> <p> Run benchmarks f as a subbenchmark with the given name. It reports whether there were any failures. </p> <p> A subbenchmark is like any other benchmark. A benchmark that calls Run at least once will not be measured itself and will be called once with N=1. </p> <h3 id=\"B.RunParallel\">func (*B) <a href=\"https://golang.org/src/testing/benchmark.go?s=15936:15975#L556\">RunParallel</a>  </h3> <pre data-language=\"go\">func (b *B) RunParallel(body func(*PB))</pre> <p> RunParallel runs a benchmark in parallel. It creates multiple goroutines and distributes b.N iterations among them. The number of goroutines defaults to GOMAXPROCS. To increase parallelism for non-CPU-bound benchmarks, call SetParallelism before RunParallel. RunParallel is usually used with the go test -cpu flag. </p> <p> The body function will be run in each goroutine. It should set up any goroutine-local state and then iterate until pb.Next returns false. It should not use the StartTimer, StopTimer, or ResetTimer functions, because they have global effect. It should also not call Run. </p> <div id=\"example_B_RunParallel\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\t\"text/template\"\n)\n\nfunc main() {\n\t// Parallel benchmark for text/template.Template.Execute on a single object.\n\ttesting.Benchmark(func(b *testing.B) {\n\t\ttempl := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\"))\n\t\t// RunParallel will create GOMAXPROCS goroutines\n\t\t// and distribute work among them.\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\t// Each goroutine has its own bytes.Buffer.\n\t\t\tvar buf bytes.Buffer\n\t\t\tfor pb.Next() {\n\t\t\t\t// The loop body is executed b.N times total across all goroutines.\n\t\t\t\tbuf.Reset()\n\t\t\t\ttempl.Execute(&amp;buf, \"World\")\n\t\t\t}\n\t\t})\n\t})\n}\n</pre> </div> </div> <h3 id=\"B.SetBytes\">func (*B) <a href=\"https://golang.org/src/testing/benchmark.go?s=3679:3708#L102\">SetBytes</a>  </h3> <pre data-language=\"go\">func (b *B) SetBytes(n int64)</pre> <p> SetBytes records the number of bytes processed in a single operation. If this is called, the benchmark will report ns/op and MB/s. </p> <h3 id=\"B.SetParallelism\">func (*B) <a href=\"https://golang.org/src/testing/benchmark.go?s=17143:17176#L600\">SetParallelism</a>  </h3> <pre data-language=\"go\">func (b *B) SetParallelism(p int)</pre> <p> SetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound benchmarks. If p is less than 1, this call will have no effect. </p> <h3 id=\"B.Skip\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=17952:17994#L490\">Skip</a>  </h3> <pre data-language=\"go\">func (c *B) Skip(args ...interface{})</pre> <p> Skip is equivalent to Log followed by SkipNow. </p> <h3 id=\"B.SkipNow\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=18533:18559#L506\">SkipNow</a>  </h3> <pre data-language=\"go\">func (c *B) SkipNow()</pre> <p> SkipNow marks the test as having been skipped and stops its execution. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines. </p> <h3 id=\"B.Skipf\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=18095:18153#L496\">Skipf</a>  </h3> <pre data-language=\"go\">func (c *B) Skipf(format string, args ...interface{})</pre> <p> Skipf is equivalent to Logf followed by SkipNow. </p> <h3 id=\"B.Skipped\">func (*B) <a href=\"https://golang.org/src/testing/testing.go?s=18742:18773#L519\">Skipped</a>  </h3> <pre data-language=\"go\">func (c *B) Skipped() bool</pre> <p> Skipped reports whether the test was skipped. </p> <h3 id=\"B.StartTimer\">func (*B) <a href=\"https://golang.org/src/testing/benchmark.go?s=2595:2619#L63\">StartTimer</a>  </h3> <pre data-language=\"go\">func (b *B) StartTimer()</pre> <p> StartTimer starts timing a test. This function is called automatically before a benchmark starts, but it can also used to resume timing after a call to StopTimer. </p> <h3 id=\"B.StopTimer\">func (*B) <a href=\"https://golang.org/src/testing/benchmark.go?s=2941:2964#L76\">StopTimer</a>  </h3> <pre data-language=\"go\">func (b *B) StopTimer()</pre> <p> StopTimer stops timing a test. This can be used to pause the timer while performing complex initialization that you don't want to measure. </p> <h2 id=\"BenchmarkResult\">type BenchmarkResult  </h2> <pre data-language=\"go\">type BenchmarkResult struct {\n        N         int           // The number of iterations.\n        T         time.Duration // The total time taken.\n        Bytes     int64         // Bytes processed in one iteration.\n        MemAllocs uint64        // The total number of memory allocations.\n        MemBytes  uint64        // The total number of bytes allocated.\n}</pre> <p> The results of a benchmark run. </p> <h3 id=\"Benchmark\">func <a href=\"https://golang.org/src/testing/benchmark.go?s=17485:17529#L611\">Benchmark</a>  </h3> <pre data-language=\"go\">func Benchmark(f func(b *B)) BenchmarkResult</pre> <p> Benchmark benchmarks a single function. Useful for creating custom benchmarks that do not use the \"go test\" command. </p> <p> If f calls Run, the result will be an estimate of running all its subbenchmarks that don't call Run in sequence in a single benchmark. </p> <h3 id=\"BenchmarkResult.AllocedBytesPerOp\">func (BenchmarkResult) <a href=\"https://golang.org/src/testing/benchmark.go?s=8448:8498#L302\">AllocedBytesPerOp</a>  </h3> <pre data-language=\"go\">func (r BenchmarkResult) AllocedBytesPerOp() int64</pre> <h3 id=\"BenchmarkResult.AllocsPerOp\">func (BenchmarkResult) <a href=\"https://golang.org/src/testing/benchmark.go?s=8329:8373#L295\">AllocsPerOp</a>  </h3> <pre data-language=\"go\">func (r BenchmarkResult) AllocsPerOp() int64</pre> <h3 id=\"BenchmarkResult.MemString\">func (BenchmarkResult) <a href=\"https://golang.org/src/testing/benchmark.go?s=9138:9181#L329\">MemString</a>  </h3> <pre data-language=\"go\">func (r BenchmarkResult) MemString() string</pre> <h3 id=\"BenchmarkResult.NsPerOp\">func (BenchmarkResult) <a href=\"https://golang.org/src/testing/benchmark.go?s=8045:8085#L281\">NsPerOp</a>  </h3> <pre data-language=\"go\">func (r BenchmarkResult) NsPerOp() int64</pre> <h3 id=\"BenchmarkResult.String\">func (BenchmarkResult) <a href=\"https://golang.org/src/testing/benchmark.go?s=8572:8612#L309\">String</a>  </h3> <pre data-language=\"go\">func (r BenchmarkResult) String() string</pre> <h2 id=\"Cover\">type Cover  </h2> <pre data-language=\"go\">type Cover struct {\n        Mode            string\n        Counters        map[string][]uint32\n        Blocks          map[string][]CoverBlock\n        CoveredPackages string\n}</pre> <p> Cover records information about test coverage checking. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines. </p> <h2 id=\"CoverBlock\">type CoverBlock  </h2> <pre data-language=\"go\">type CoverBlock struct {\n        Line0 uint32\n        Col0  uint16\n        Line1 uint32\n        Col1  uint16\n        Stmts uint16\n}</pre> <p> CoverBlock records the coverage data for a single basic block. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines. </p> <h2 id=\"InternalBenchmark\">type InternalBenchmark  </h2> <pre data-language=\"go\">type InternalBenchmark struct {\n        Name string\n        F    func(b *B)\n}</pre> <p> An internal type but exported because it is cross-package; part of the implementation of the \"go test\" command. </p> <h2 id=\"InternalExample\">type InternalExample  </h2> <pre data-language=\"go\">type InternalExample struct {\n        Name      string\n        F         func()\n        Output    string\n        Unordered bool\n}</pre> <h2 id=\"InternalTest\">type InternalTest  </h2> <pre data-language=\"go\">type InternalTest struct {\n        Name string\n        F    func(*T)\n}</pre> <p> An internal type but exported because it is cross-package; part of the implementation of the \"go test\" command. </p> <h2 id=\"M\">type M  </h2> <pre data-language=\"go\">type M struct {\n        // contains filtered or unexported fields\n}</pre> <p> M is a type passed to a TestMain function to run the actual tests. </p> <h3 id=\"MainStart\">func <a href=\"https://golang.org/src/testing/testing.go?s=24221:24369#L712\">MainStart</a>  </h3> <pre data-language=\"go\">func MainStart(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) *M</pre> <p> MainStart is meant for use by tests generated by 'go test'. It is not meant to be called directly and is not subject to the Go 1 compatibility document. It may change signature from release to release. </p> <h3 id=\"M.Run\">func (*M) <a href=\"https://golang.org/src/testing/testing.go?s=24559:24580#L722\">Run</a>  </h3> <pre data-language=\"go\">func (m *M) Run() int</pre> <p> Run runs the tests. It returns an exit code to pass to os.Exit. </p> <h2 id=\"PB\">type PB  </h2> <pre data-language=\"go\">type PB struct {\n        // contains filtered or unexported fields\n}</pre> <p> A PB is used by RunParallel for running parallel benchmarks. </p> <h3 id=\"PB.Next\">func (*PB) <a href=\"https://golang.org/src/testing/benchmark.go?s=15056:15081#L531\">Next</a>  </h3> <pre data-language=\"go\">func (pb *PB) Next() bool</pre> <p> Next reports whether there are more iterations to execute. </p> <h2 id=\"T\">type T  </h2> <pre data-language=\"go\">type T struct {\n        // contains filtered or unexported fields\n}</pre> <p> T is a type passed to Test functions to manage test state and support formatted test logs. Logs are accumulated during execution and dumped to standard output when done. </p> <p> A test ends when its Test function returns or calls any of the methods FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as the Parallel method, must be called only from the goroutine running the Test function. </p> <p> The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines. </p> <h3 id=\"T.Error\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=17340:17383#L466\">Error</a>  </h3> <pre data-language=\"go\">func (c *T) Error(args ...interface{})</pre> <p> Error is equivalent to Log followed by Fail. </p> <h3 id=\"T.Errorf\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=17479:17538#L472\">Errorf</a>  </h3> <pre data-language=\"go\">func (c *T) Errorf(format string, args ...interface{})</pre> <p> Errorf is equivalent to Logf followed by Fail. </p> <h3 id=\"T.Fail\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=14580:14603#L394\">Fail</a>  </h3> <pre data-language=\"go\">func (c *T) Fail()</pre> <p> Fail marks the function as having failed but continues execution. </p> <h3 id=\"T.FailNow\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=15331:15357#L420\">FailNow</a>  </h3> <pre data-language=\"go\">func (c *T) FailNow()</pre> <p> FailNow marks the function as having failed and stops its execution. Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines. </p> <h3 id=\"T.Failed\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=14913:14943#L408\">Failed</a>  </h3> <pre data-language=\"go\">func (c *T) Failed() bool</pre> <p> Failed reports whether the function has failed. </p> <h3 id=\"T.Fatal\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=17642:17685#L478\">Fatal</a>  </h3> <pre data-language=\"go\">func (c *T) Fatal(args ...interface{})</pre> <p> Fatal is equivalent to Log followed by FailNow. </p> <h3 id=\"T.Fatalf\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=17787:17846#L484\">Fatalf</a>  </h3> <pre data-language=\"go\">func (c *T) Fatalf(format string, args ...interface{})</pre> <p> Fatalf is equivalent to Logf followed by FailNow. </p> <h3 id=\"T.Log\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=16794:16835#L457\">Log</a>  </h3> <pre data-language=\"go\">func (c *T) Log(args ...interface{})</pre> <p> Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. </p> <h3 id=\"T.Logf\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=17193:17250#L463\">Logf</a>  </h3> <pre data-language=\"go\">func (c *T) Logf(format string, args ...interface{})</pre> <p> Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. </p> <h3 id=\"T.Parallel\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=18939:18961#L527\">Parallel</a>  </h3> <pre data-language=\"go\">func (t *T) Parallel()</pre> <p> Parallel signals that this test is to be run in parallel with (and only with) other parallel tests. </p> <h3 id=\"T.Run\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=21235:21282#L606\">Run</a>  </h3> <pre data-language=\"go\">func (t *T) Run(name string, f func(t *T)) bool</pre> <p> Run runs f as a subtest of t called name. It reports whether f succeeded. Run will block until all its parallel subtests have completed. </p> <h3 id=\"T.Skip\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=17952:17994#L490\">Skip</a>  </h3> <pre data-language=\"go\">func (c *T) Skip(args ...interface{})</pre> <p> Skip is equivalent to Log followed by SkipNow. </p> <h3 id=\"T.SkipNow\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=18533:18559#L506\">SkipNow</a>  </h3> <pre data-language=\"go\">func (c *T) SkipNow()</pre> <p> SkipNow marks the test as having been skipped and stops its execution. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines. </p> <h3 id=\"T.Skipf\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=18095:18153#L496\">Skipf</a>  </h3> <pre data-language=\"go\">func (c *T) Skipf(format string, args ...interface{})</pre> <p> Skipf is equivalent to Logf followed by SkipNow. </p> <h3 id=\"T.Skipped\">func (*T) <a href=\"https://golang.org/src/testing/testing.go?s=18742:18773#L519\">Skipped</a>  </h3> <pre data-language=\"go\">func (c *T) Skipped() bool</pre> <p> Skipped reports whether the test was skipped. </p> <h2 id=\"TB\">type TB  </h2> <pre data-language=\"go\">type TB interface {\n        Error(args ...interface{})\n        Errorf(format string, args ...interface{})\n        Fail()\n        FailNow()\n        Failed() bool\n        Fatal(args ...interface{})\n        Fatalf(format string, args ...interface{})\n        Log(args ...interface{})\n        Logf(format string, args ...interface{})\n        Skip(args ...interface{})\n        SkipNow()\n        Skipf(format string, args ...interface{})\n        Skipped() bool\n        // contains filtered or unexported methods\n}</pre> <p> TB is the interface common to T and B. </p> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"iotest/index\">iotest</a> </td> <td class=\"pkg-synopsis\"> Package iotest implements Readers and Writers useful mainly for testing. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"quick/index\">quick</a> </td> <td class=\"pkg-synopsis\"> Package quick implements utility functions to help with black box testing. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/testing/\" class=\"_attribution-link\">https://golang.org/pkg/testing/</a>\n  </p>\n</div>\n","strings/index":"<h1>Package strings</h1>     <ul id=\"short-nav\">\n<li><code>import \"strings\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package strings implements simple functions to manipulate UTF-8 encoded strings. </p> <p> For information about UTF-8 strings in Go, see <a href=\"https://blog.golang.org/strings\">https://blog.golang.org/strings</a>. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#Compare\">func Compare(a, b string) int</a></li>\n<li><a href=\"#Contains\">func Contains(s, substr string) bool</a></li>\n<li><a href=\"#ContainsAny\">func ContainsAny(s, chars string) bool</a></li>\n<li><a href=\"#ContainsRune\">func ContainsRune(s string, r rune) bool</a></li>\n<li><a href=\"#Count\">func Count(s, sep string) int</a></li>\n<li><a href=\"#EqualFold\">func EqualFold(s, t string) bool</a></li>\n<li><a href=\"#Fields\">func Fields(s string) []string</a></li>\n<li><a href=\"#FieldsFunc\">func FieldsFunc(s string, f func(rune) bool) []string</a></li>\n<li><a href=\"#HasPrefix\">func HasPrefix(s, prefix string) bool</a></li>\n<li><a href=\"#HasSuffix\">func HasSuffix(s, suffix string) bool</a></li>\n<li><a href=\"#Index\">func Index(s, sep string) int</a></li>\n<li><a href=\"#IndexAny\">func IndexAny(s, chars string) int</a></li>\n<li><a href=\"#IndexByte\">func IndexByte(s string, c byte) int</a></li>\n<li><a href=\"#IndexFunc\">func IndexFunc(s string, f func(rune) bool) int</a></li>\n<li><a href=\"#IndexRune\">func IndexRune(s string, r rune) int</a></li>\n<li><a href=\"#Join\">func Join(a []string, sep string) string</a></li>\n<li><a href=\"#LastIndex\">func LastIndex(s, sep string) int</a></li>\n<li><a href=\"#LastIndexAny\">func LastIndexAny(s, chars string) int</a></li>\n<li><a href=\"#LastIndexByte\">func LastIndexByte(s string, c byte) int</a></li>\n<li><a href=\"#LastIndexFunc\">func LastIndexFunc(s string, f func(rune) bool) int</a></li>\n<li><a href=\"#Map\">func Map(mapping func(rune) rune, s string) string</a></li>\n<li><a href=\"#Repeat\">func Repeat(s string, count int) string</a></li>\n<li><a href=\"#Replace\">func Replace(s, old, new string, n int) string</a></li>\n<li><a href=\"#Split\">func Split(s, sep string) []string</a></li>\n<li><a href=\"#SplitAfter\">func SplitAfter(s, sep string) []string</a></li>\n<li><a href=\"#SplitAfterN\">func SplitAfterN(s, sep string, n int) []string</a></li>\n<li><a href=\"#SplitN\">func SplitN(s, sep string, n int) []string</a></li>\n<li><a href=\"#Title\">func Title(s string) string</a></li>\n<li><a href=\"#ToLower\">func ToLower(s string) string</a></li>\n<li><a href=\"#ToLowerSpecial\">func ToLowerSpecial(_case unicode.SpecialCase, s string) string</a></li>\n<li><a href=\"#ToTitle\">func ToTitle(s string) string</a></li>\n<li><a href=\"#ToTitleSpecial\">func ToTitleSpecial(_case unicode.SpecialCase, s string) string</a></li>\n<li><a href=\"#ToUpper\">func ToUpper(s string) string</a></li>\n<li><a href=\"#ToUpperSpecial\">func ToUpperSpecial(_case unicode.SpecialCase, s string) string</a></li>\n<li><a href=\"#Trim\">func Trim(s string, cutset string) string</a></li>\n<li><a href=\"#TrimFunc\">func TrimFunc(s string, f func(rune) bool) string</a></li>\n<li><a href=\"#TrimLeft\">func TrimLeft(s string, cutset string) string</a></li>\n<li><a href=\"#TrimLeftFunc\">func TrimLeftFunc(s string, f func(rune) bool) string</a></li>\n<li><a href=\"#TrimPrefix\">func TrimPrefix(s, prefix string) string</a></li>\n<li><a href=\"#TrimRight\">func TrimRight(s string, cutset string) string</a></li>\n<li><a href=\"#TrimRightFunc\">func TrimRightFunc(s string, f func(rune) bool) string</a></li>\n<li><a href=\"#TrimSpace\">func TrimSpace(s string) string</a></li>\n<li><a href=\"#TrimSuffix\">func TrimSuffix(s, suffix string) string</a></li>\n<li><a href=\"#Reader\">type Reader</a></li>\n<li> <a href=\"#NewReader\">func NewReader(s string) *Reader</a>\n</li>\n<li> <a href=\"#Reader.Len\">func (r *Reader) Len() int</a>\n</li>\n<li> <a href=\"#Reader.Read\">func (r *Reader) Read(b []byte) (n int, err error)</a>\n</li>\n<li> <a href=\"#Reader.ReadAt\">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</a>\n</li>\n<li> <a href=\"#Reader.ReadByte\">func (r *Reader) ReadByte() (byte, error)</a>\n</li>\n<li> <a href=\"#Reader.ReadRune\">func (r *Reader) ReadRune() (ch rune, size int, err error)</a>\n</li>\n<li> <a href=\"#Reader.Reset\">func (r *Reader) Reset(s string)</a>\n</li>\n<li> <a href=\"#Reader.Seek\">func (r *Reader) Seek(offset int64, whence int) (int64, error)</a>\n</li>\n<li> <a href=\"#Reader.Size\">func (r *Reader) Size() int64</a>\n</li>\n<li> <a href=\"#Reader.UnreadByte\">func (r *Reader) UnreadByte() error</a>\n</li>\n<li> <a href=\"#Reader.UnreadRune\">func (r *Reader) UnreadRune() error</a>\n</li>\n<li> <a href=\"#Reader.WriteTo\">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</a>\n</li>\n<li><a href=\"#Replacer\">type Replacer</a></li>\n<li> <a href=\"#NewReplacer\">func NewReplacer(oldnew ...string) *Replacer</a>\n</li>\n<li> <a href=\"#Replacer.Replace\">func (r *Replacer) Replace(s string) string</a>\n</li>\n<li> <a href=\"#Replacer.WriteString\">func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)</a>\n</li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Contains\">Contains</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ContainsAny\">ContainsAny</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Count\">Count</a></dd> <dd><a class=\"exampleLink\" href=\"#example_EqualFold\">EqualFold</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Fields\">Fields</a></dd> <dd><a class=\"exampleLink\" href=\"#example_FieldsFunc\">FieldsFunc</a></dd> <dd><a class=\"exampleLink\" href=\"#example_HasPrefix\">HasPrefix</a></dd> <dd><a class=\"exampleLink\" href=\"#example_HasSuffix\">HasSuffix</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Index\">Index</a></dd> <dd><a class=\"exampleLink\" href=\"#example_IndexAny\">IndexAny</a></dd> <dd><a class=\"exampleLink\" href=\"#example_IndexFunc\">IndexFunc</a></dd> <dd><a class=\"exampleLink\" href=\"#example_IndexRune\">IndexRune</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Join\">Join</a></dd> <dd><a class=\"exampleLink\" href=\"#example_LastIndex\">LastIndex</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Map\">Map</a></dd> <dd><a class=\"exampleLink\" href=\"#example_NewReplacer\">NewReplacer</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Repeat\">Repeat</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Replace\">Replace</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Split\">Split</a></dd> <dd><a class=\"exampleLink\" href=\"#example_SplitAfter\">SplitAfter</a></dd> <dd><a class=\"exampleLink\" href=\"#example_SplitAfterN\">SplitAfterN</a></dd> <dd><a class=\"exampleLink\" href=\"#example_SplitN\">SplitN</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Title\">Title</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ToLower\">ToLower</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ToTitle\">ToTitle</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ToUpper\">ToUpper</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Trim\">Trim</a></dd> <dd><a class=\"exampleLink\" href=\"#example_TrimPrefix\">TrimPrefix</a></dd> <dd><a class=\"exampleLink\" href=\"#example_TrimSpace\">TrimSpace</a></dd> <dd><a class=\"exampleLink\" href=\"#example_TrimSuffix\">TrimSuffix</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/strings/compare.go\">compare.go</a> <a href=\"https://golang.org/src/strings/reader.go\">reader.go</a> <a href=\"https://golang.org/src/strings/replace.go\">replace.go</a> <a href=\"https://golang.org/src/strings/search.go\">search.go</a> <a href=\"https://golang.org/src/strings/strings.go\">strings.go</a> <a href=\"https://golang.org/src/strings/strings_amd64.go\">strings_amd64.go</a> <a href=\"https://golang.org/src/strings/strings_decl.go\">strings_decl.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"Compare\">func Compare  </h2> <pre data-language=\"go\">func Compare(a, b string) int</pre> <p> Compare returns an integer comparing two strings lexicographically. The result will be 0 if a==b, -1 if a &lt; b, and +1 if a &gt; b. </p> <p> Compare is included only for symmetry with package bytes. It is usually clearer and always faster to use the built-in string comparison operators ==, &lt;, &gt;, and so on. </p> <h2 id=\"Contains\">func Contains  </h2> <pre data-language=\"go\">func Contains(s, substr string) bool</pre> <p> Contains reports whether substr is within s. </p> <div id=\"example_Contains\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.Contains(\"seafood\", \"foo\"))\n\tfmt.Println(strings.Contains(\"seafood\", \"bar\"))\n\tfmt.Println(strings.Contains(\"seafood\", \"\"))\n\tfmt.Println(strings.Contains(\"\", \"\"))\n}\n</pre> </div> </div> <h2 id=\"ContainsAny\">func ContainsAny  </h2> <pre data-language=\"go\">func ContainsAny(s, chars string) bool</pre> <p> ContainsAny reports whether any Unicode code points in chars are within s. </p> <div id=\"example_ContainsAny\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.ContainsAny(\"team\", \"i\"))\n\tfmt.Println(strings.ContainsAny(\"failure\", \"u &amp; i\"))\n\tfmt.Println(strings.ContainsAny(\"foo\", \"\"))\n\tfmt.Println(strings.ContainsAny(\"\", \"\"))\n}\n</pre> </div> </div> <h2 id=\"ContainsRune\">func ContainsRune  </h2> <pre data-language=\"go\">func ContainsRune(s string, r rune) bool</pre> <p> ContainsRune reports whether the Unicode code point r is within s. </p> <h2 id=\"Count\">func Count  </h2> <pre data-language=\"go\">func Count(s, sep string) int</pre> <p> Count counts the number of non-overlapping instances of sep in s. If sep is an empty string, Count returns 1 + the number of Unicode code points in s. </p> <div id=\"example_Count\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.Count(\"cheese\", \"e\"))\n\tfmt.Println(strings.Count(\"five\", \"\")) // before &amp; after each rune\n}\n</pre> </div> </div> <h2 id=\"EqualFold\">func EqualFold  </h2> <pre data-language=\"go\">func EqualFold(s, t string) bool</pre> <p> EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under Unicode case-folding. </p> <div id=\"example_EqualFold\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.EqualFold(\"Go\", \"go\"))\n}\n</pre> </div> </div> <h2 id=\"Fields\">func Fields  </h2> <pre data-language=\"go\">func Fields(s string) []string</pre> <p> Fields splits the string s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning an array of substrings of s or an empty list if s contains only white space. </p> <div id=\"example_Fields\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Printf(\"Fields are: %q\", strings.Fields(\"  foo bar  baz   \"))\n}\n</pre> </div> </div> <h2 id=\"FieldsFunc\">func FieldsFunc  </h2> <pre data-language=\"go\">func FieldsFunc(s string, f func(rune) bool) []string</pre> <p> FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c) and returns an array of slices of s. If all code points in s satisfy f(c) or the string is empty, an empty slice is returned. FieldsFunc makes no guarantees about the order in which it calls f(c). If f does not return consistent results for a given c, FieldsFunc may crash. </p> <div id=\"example_FieldsFunc\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc main() {\n\tf := func(c rune) bool {\n\t\treturn !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)\n\t}\n\tfmt.Printf(\"Fields are: %q\", strings.FieldsFunc(\"  foo1;bar2,baz3...\", f))\n}\n</pre> </div> </div> <h2 id=\"HasPrefix\">func HasPrefix  </h2> <pre data-language=\"go\">func HasPrefix(s, prefix string) bool</pre> <p> HasPrefix tests whether the string s begins with prefix. </p> <div id=\"example_HasPrefix\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.HasPrefix(\"Gopher\", \"Go\"))\n\tfmt.Println(strings.HasPrefix(\"Gopher\", \"C\"))\n\tfmt.Println(strings.HasPrefix(\"Gopher\", \"\"))\n}\n</pre> </div> </div> <h2 id=\"HasSuffix\">func HasSuffix  </h2> <pre data-language=\"go\">func HasSuffix(s, suffix string) bool</pre> <p> HasSuffix tests whether the string s ends with suffix. </p> <div id=\"example_HasSuffix\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.HasSuffix(\"Amigo\", \"go\"))\n\tfmt.Println(strings.HasSuffix(\"Amigo\", \"O\"))\n\tfmt.Println(strings.HasSuffix(\"Amigo\", \"Ami\"))\n\tfmt.Println(strings.HasSuffix(\"Amigo\", \"\"))\n}\n</pre> </div> </div> <h2 id=\"Index\">func Index  </h2> <pre data-language=\"go\">func Index(s, sep string) int</pre> <p> Index returns the index of the first instance of sep in s, or -1 if sep is not present in s. </p> <div id=\"example_Index\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.Index(\"chicken\", \"ken\"))\n\tfmt.Println(strings.Index(\"chicken\", \"dmr\"))\n}\n</pre> </div> </div> <h2 id=\"IndexAny\">func IndexAny  </h2> <pre data-language=\"go\">func IndexAny(s, chars string) int</pre> <p> IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s. </p> <div id=\"example_IndexAny\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.IndexAny(\"chicken\", \"aeiouy\"))\n\tfmt.Println(strings.IndexAny(\"crwth\", \"aeiouy\"))\n}\n</pre> </div> </div> <h2 id=\"IndexByte\">func IndexByte  </h2> <pre data-language=\"go\">func IndexByte(s string, c byte) int</pre> <p> IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s. </p> <h2 id=\"IndexFunc\">func IndexFunc  </h2> <pre data-language=\"go\">func IndexFunc(s string, f func(rune) bool) int</pre> <p> IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or -1 if none do. </p> <div id=\"example_IndexFunc\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc main() {\n\tf := func(c rune) bool {\n\t\treturn unicode.Is(unicode.Han, c)\n\t}\n\tfmt.Println(strings.IndexFunc(\"Hello, 世界\", f))\n\tfmt.Println(strings.IndexFunc(\"Hello, world\", f))\n}\n</pre> </div> </div> <h2 id=\"IndexRune\">func IndexRune  </h2> <pre data-language=\"go\">func IndexRune(s string, r rune) int</pre> <p> IndexRune returns the index of the first instance of the Unicode code point r, or -1 if rune is not present in s. </p> <div id=\"example_IndexRune\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.IndexRune(\"chicken\", 'k'))\n\tfmt.Println(strings.IndexRune(\"chicken\", 'd'))\n}\n</pre> </div> </div> <h2 id=\"Join\">func Join  </h2> <pre data-language=\"go\">func Join(a []string, sep string) string</pre> <p> Join concatenates the elements of a to create a single string. The separator string sep is placed between elements in the resulting string. </p> <div id=\"example_Join\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\ts := []string{\"foo\", \"bar\", \"baz\"}\n\tfmt.Println(strings.Join(s, \", \"))\n}\n</pre> </div> </div> <h2 id=\"LastIndex\">func LastIndex  </h2> <pre data-language=\"go\">func LastIndex(s, sep string) int</pre> <p> LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s. </p> <div id=\"example_LastIndex\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.Index(\"go gopher\", \"go\"))\n\tfmt.Println(strings.LastIndex(\"go gopher\", \"go\"))\n\tfmt.Println(strings.LastIndex(\"go gopher\", \"rodent\"))\n}\n</pre> </div> </div> <h2 id=\"LastIndexAny\">func LastIndexAny  </h2> <pre data-language=\"go\">func LastIndexAny(s, chars string) int</pre> <p> LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s. </p> <h2 id=\"LastIndexByte\">func LastIndexByte  </h2> <pre data-language=\"go\">func LastIndexByte(s string, c byte) int</pre> <p> LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s. </p> <h2 id=\"LastIndexFunc\">func LastIndexFunc  </h2> <pre data-language=\"go\">func LastIndexFunc(s string, f func(rune) bool) int</pre> <p> LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or -1 if none do. </p> <h2 id=\"Map\">func Map  </h2> <pre data-language=\"go\">func Map(mapping func(rune) rune, s string) string</pre> <p> Map returns a copy of the string s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement. </p> <div id=\"example_Map\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\trot13 := func(r rune) rune {\n\t\tswitch {\n\t\tcase r &gt;= 'A' &amp;&amp; r &lt;= 'Z':\n\t\t\treturn 'A' + (r-'A'+13)%26\n\t\tcase r &gt;= 'a' &amp;&amp; r &lt;= 'z':\n\t\t\treturn 'a' + (r-'a'+13)%26\n\t\t}\n\t\treturn r\n\t}\n\tfmt.Println(strings.Map(rot13, \"'Twas brillig and the slithy gopher...\"))\n}\n</pre> </div> </div> <h2 id=\"Repeat\">func Repeat  </h2> <pre data-language=\"go\">func Repeat(s string, count int) string</pre> <p> Repeat returns a new string consisting of count copies of the string s. </p> <div id=\"example_Repeat\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(\"ba\" + strings.Repeat(\"na\", 2))\n}\n</pre> </div> </div> <h2 id=\"Replace\">func Replace  </h2> <pre data-language=\"go\">func Replace(s, old, new string, n int) string</pre> <p> Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n &lt; 0, there is no limit on the number of replacements. </p> <div id=\"example_Replace\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.Replace(\"oink oink oink\", \"k\", \"ky\", 2))\n\tfmt.Println(strings.Replace(\"oink oink oink\", \"oink\", \"moo\", -1))\n}\n</pre> </div> </div> <h2 id=\"Split\">func Split  </h2> <pre data-language=\"go\">func Split(s, sep string) []string</pre> <p> Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1. </p> <div id=\"example_Split\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Printf(\"%q\\n\", strings.Split(\"a,b,c\", \",\"))\n\tfmt.Printf(\"%q\\n\", strings.Split(\"a man a plan a canal panama\", \"a \"))\n\tfmt.Printf(\"%q\\n\", strings.Split(\" xyz \", \"\"))\n\tfmt.Printf(\"%q\\n\", strings.Split(\"\", \"Bernardo O'Higgins\"))\n}\n</pre> </div> </div> <h2 id=\"SplitAfter\">func SplitAfter  </h2> <pre data-language=\"go\">func SplitAfter(s, sep string) []string</pre> <p> SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1. </p> <div id=\"example_SplitAfter\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Printf(\"%q\\n\", strings.SplitAfter(\"a,b,c\", \",\"))\n}\n</pre> </div> </div> <h2 id=\"SplitAfterN\">func SplitAfterN  </h2> <pre data-language=\"go\">func SplitAfterN(s, sep string, n int) []string</pre> <p> SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of substrings to return: </p> <pre data-language=\"go\">n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.\nn == 0: the result is nil (zero substrings)\nn &lt; 0: all substrings\n</pre> <div id=\"example_SplitAfterN\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Printf(\"%q\\n\", strings.SplitAfterN(\"a,b,c\", \",\", 2))\n}\n</pre> </div> </div> <h2 id=\"SplitN\">func SplitN  </h2> <pre data-language=\"go\">func SplitN(s, sep string, n int) []string</pre> <p> SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of substrings to return: </p> <pre data-language=\"go\">n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.\nn == 0: the result is nil (zero substrings)\nn &lt; 0: all substrings\n</pre> <div id=\"example_SplitN\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Printf(\"%q\\n\", strings.SplitN(\"a,b,c\", \",\", 2))\n\tz := strings.SplitN(\"a,b,c\", \",\", 0)\n\tfmt.Printf(\"%q (nil = %v)\\n\", z, z == nil)\n}\n</pre> </div> </div> <h2 id=\"Title\">func Title  </h2> <pre data-language=\"go\">func Title(s string) string</pre> <p> Title returns a copy of the string s with all Unicode letters that begin words mapped to their title case. </p> <p> BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly. </p> <div id=\"example_Title\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.Title(\"her royal highness\"))\n}\n</pre> </div> </div> <h2 id=\"ToLower\">func ToLower  </h2> <pre data-language=\"go\">func ToLower(s string) string</pre> <p> ToLower returns a copy of the string s with all Unicode letters mapped to their lower case. </p> <div id=\"example_ToLower\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.ToLower(\"Gopher\"))\n}\n</pre> </div> </div> <h2 id=\"ToLowerSpecial\">func ToLowerSpecial  </h2> <pre data-language=\"go\">func ToLowerSpecial(_case unicode.SpecialCase, s string) string</pre> <p> ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case, giving priority to the special casing rules. </p> <h2 id=\"ToTitle\">func ToTitle  </h2> <pre data-language=\"go\">func ToTitle(s string) string</pre> <p> ToTitle returns a copy of the string s with all Unicode letters mapped to their title case. </p> <div id=\"example_ToTitle\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.ToTitle(\"loud noises\"))\n\tfmt.Println(strings.ToTitle(\"хлеб\"))\n}\n</pre> </div> </div> <h2 id=\"ToTitleSpecial\">func ToTitleSpecial  </h2> <pre data-language=\"go\">func ToTitleSpecial(_case unicode.SpecialCase, s string) string</pre> <p> ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their title case, giving priority to the special casing rules. </p> <h2 id=\"ToUpper\">func ToUpper  </h2> <pre data-language=\"go\">func ToUpper(s string) string</pre> <p> ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case. </p> <div id=\"example_ToUpper\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.ToUpper(\"Gopher\"))\n}\n</pre> </div> </div> <h2 id=\"ToUpperSpecial\">func ToUpperSpecial  </h2> <pre data-language=\"go\">func ToUpperSpecial(_case unicode.SpecialCase, s string) string</pre> <p> ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case, giving priority to the special casing rules. </p> <h2 id=\"Trim\">func Trim  </h2> <pre data-language=\"go\">func Trim(s string, cutset string) string</pre> <p> Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed. </p> <div id=\"example_Trim\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Printf(\"[%q]\", strings.Trim(\" !!! Achtung! Achtung! !!! \", \"! \"))\n}\n</pre> </div> </div> <h2 id=\"TrimFunc\">func TrimFunc  </h2> <pre data-language=\"go\">func TrimFunc(s string, f func(rune) bool) string</pre> <p> TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed. </p> <h2 id=\"TrimLeft\">func TrimLeft  </h2> <pre data-language=\"go\">func TrimLeft(s string, cutset string) string</pre> <p> TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed. </p> <h2 id=\"TrimLeftFunc\">func TrimLeftFunc  </h2> <pre data-language=\"go\">func TrimLeftFunc(s string, f func(rune) bool) string</pre> <p> TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed. </p> <h2 id=\"TrimPrefix\">func TrimPrefix  </h2> <pre data-language=\"go\">func TrimPrefix(s, prefix string) string</pre> <p> TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged. </p> <div id=\"example_TrimPrefix\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar s = \"Goodbye,, world!\"\n\ts = strings.TrimPrefix(s, \"Goodbye,\")\n\ts = strings.TrimPrefix(s, \"Howdy,\")\n\tfmt.Print(\"Hello\" + s)\n}\n</pre> </div> </div> <h2 id=\"TrimRight\">func TrimRight  </h2> <pre data-language=\"go\">func TrimRight(s string, cutset string) string</pre> <p> TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed. </p> <h2 id=\"TrimRightFunc\">func TrimRightFunc  </h2> <pre data-language=\"go\">func TrimRightFunc(s string, f func(rune) bool) string</pre> <p> TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed. </p> <h2 id=\"TrimSpace\">func TrimSpace  </h2> <pre data-language=\"go\">func TrimSpace(s string) string</pre> <p> TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode. </p> <div id=\"example_TrimSpace\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.TrimSpace(\" \\t\\n a lone gopher \\n\\t\\r\\n\"))\n}\n</pre> </div> </div> <h2 id=\"TrimSuffix\">func TrimSuffix  </h2> <pre data-language=\"go\">func TrimSuffix(s, suffix string) string</pre> <p> TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged. </p> <div id=\"example_TrimSuffix\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar s = \"Hello, goodbye, etc!\"\n\ts = strings.TrimSuffix(s, \"goodbye, etc!\")\n\ts = strings.TrimSuffix(s, \"planet\")\n\tfmt.Print(s, \"world!\")\n}\n</pre> </div> </div> <h2 id=\"Reader\">type Reader  </h2> <pre data-language=\"go\">type Reader struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Reader implements the io.Reader, io.ReaderAt, io.Seeker, io.WriterTo, io.ByteScanner, and io.RuneScanner interfaces by reading from a string. </p> <h3 id=\"NewReader\">func <a href=\"https://golang.org/src/strings/reader.go?s=3404:3436#L140\">NewReader</a>  </h3> <pre data-language=\"go\">func NewReader(s string) *Reader</pre> <p> NewReader returns a new Reader reading from s. It is similar to bytes.NewBufferString but more efficient and read-only. </p> <h3 id=\"Reader.Len\">func (*Reader) <a href=\"https://golang.org/src/strings/reader.go?s=581:607#L14\">Len</a>  </h3> <pre data-language=\"go\">func (r *Reader) Len() int</pre> <p> Len returns the number of bytes of the unread portion of the string. </p> <h3 id=\"Reader.Read\">func (*Reader) <a href=\"https://golang.org/src/strings/reader.go?s=970:1020#L27\">Read</a>  </h3> <pre data-language=\"go\">func (r *Reader) Read(b []byte) (n int, err error)</pre> <h3 id=\"Reader.ReadAt\">func (*Reader) <a href=\"https://golang.org/src/strings/reader.go?s=1143:1206#L37\">ReadAt</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</pre> <h3 id=\"Reader.ReadByte\">func (*Reader) <a href=\"https://golang.org/src/strings/reader.go?s=1454:1495#L52\">ReadByte</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadByte() (byte, error)</pre> <h3 id=\"Reader.ReadRune\">func (*Reader) <a href=\"https://golang.org/src/strings/reader.go?s=1774:1832#L71\">ReadRune</a>  </h3> <pre data-language=\"go\">func (r *Reader) ReadRune() (ch rune, size int, err error)</pre> <h3 id=\"Reader.Reset\">func (*Reader) <a href=\"https://golang.org/src/strings/reader.go?s=3218:3250#L136\">Reset</a>  </h3> <pre data-language=\"go\">func (r *Reader) Reset(s string)</pre> <p> Reset resets the Reader to be reading from s. </p> <h3 id=\"Reader.Seek\">func (*Reader) <a href=\"https://golang.org/src/strings/reader.go?s=2332:2394#L96\">Seek</a>  </h3> <pre data-language=\"go\">func (r *Reader) Seek(offset int64, whence int) (int64, error)</pre> <p> Seek implements the io.Seeker interface. </p> <h3 id=\"Reader.Size\">func (*Reader) <a href=\"https://golang.org/src/strings/reader.go?s=912:941#L25\">Size</a>  </h3> <pre data-language=\"go\">func (r *Reader) Size() int64</pre> <p> Size returns the original length of the underlying string. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method. </p> <h3 id=\"Reader.UnreadByte\">func (*Reader) <a href=\"https://golang.org/src/strings/reader.go?s=1606:1641#L62\">UnreadByte</a>  </h3> <pre data-language=\"go\">func (r *Reader) UnreadByte() error</pre> <h3 id=\"Reader.UnreadRune\">func (*Reader) <a href=\"https://golang.org/src/strings/reader.go?s=2083:2118#L86\">UnreadRune</a>  </h3> <pre data-language=\"go\">func (r *Reader) UnreadRune() error</pre> <h3 id=\"Reader.WriteTo\">func (*Reader) <a href=\"https://golang.org/src/strings/reader.go?s=2812:2870#L117\">WriteTo</a>  </h3> <pre data-language=\"go\">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</pre> <p> WriteTo implements the io.WriterTo interface. </p> <h2 id=\"Replacer\">type Replacer  </h2> <pre data-language=\"go\">type Replacer struct {\n        // contains filtered or unexported fields\n}</pre> <p> Replacer replaces a list of strings with replacements. It is safe for concurrent use by multiple goroutines. </p> <h3 id=\"NewReplacer\">func <a href=\"https://golang.org/src/strings/replace.go?s=676:720#L13\">NewReplacer</a>  </h3> <pre data-language=\"go\">func NewReplacer(oldnew ...string) *Replacer</pre> <p> NewReplacer returns a new Replacer from a list of old, new string pairs. Replacements are performed in order, without overlapping matches. </p> <div id=\"example_NewReplacer\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReplacer(\"&lt;\", \"&amp;lt;\", \"&gt;\", \"&amp;gt;\")\n\tfmt.Println(r.Replace(\"This is &lt;b&gt;HTML&lt;/b&gt;!\"))\n}\n</pre> </div> </div> <h3 id=\"Replacer.Replace\">func (*Replacer) <a href=\"https://golang.org/src/strings/replace.go?s=1777:1820#L59\">Replace</a>  </h3> <pre data-language=\"go\">func (r *Replacer) Replace(s string) string</pre> <p> Replace returns a copy of s with all replacements performed. </p> <h3 id=\"Replacer.WriteString\">func (*Replacer) <a href=\"https://golang.org/src/strings/replace.go?s=1911:1983#L64\">WriteString</a>  </h3> <pre data-language=\"go\">func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)</pre> <p> WriteString writes s to w with all replacements performed. </p> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/strings/strings.go?s=13026:13124#L474\" style=\"float: left;\">☞</a> <p> The rule Title uses for word boundaries does not handle Unicode punctuation properly. </p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/strings/\" class=\"_attribution-link\">https://golang.org/pkg/strings/</a>\n  </p>\n</div>\n","unicode/utf8/index":"<h1>Package utf8</h1>     <ul id=\"short-nav\">\n<li><code>import \"unicode/utf8\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package utf8 implements functions and constants to support text encoded in UTF-8. It includes functions to translate between runes and UTF-8 byte sequences. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#DecodeLastRune\">func DecodeLastRune(p []byte) (r rune, size int)</a></li>\n<li><a href=\"#DecodeLastRuneInString\">func DecodeLastRuneInString(s string) (r rune, size int)</a></li>\n<li><a href=\"#DecodeRune\">func DecodeRune(p []byte) (r rune, size int)</a></li>\n<li><a href=\"#DecodeRuneInString\">func DecodeRuneInString(s string) (r rune, size int)</a></li>\n<li><a href=\"#EncodeRune\">func EncodeRune(p []byte, r rune) int</a></li>\n<li><a href=\"#FullRune\">func FullRune(p []byte) bool</a></li>\n<li><a href=\"#FullRuneInString\">func FullRuneInString(s string) bool</a></li>\n<li><a href=\"#RuneCount\">func RuneCount(p []byte) int</a></li>\n<li><a href=\"#RuneCountInString\">func RuneCountInString(s string) (n int)</a></li>\n<li><a href=\"#RuneLen\">func RuneLen(r rune) int</a></li>\n<li><a href=\"#RuneStart\">func RuneStart(b byte) bool</a></li>\n<li><a href=\"#Valid\">func Valid(p []byte) bool</a></li>\n<li><a href=\"#ValidRune\">func ValidRune(r rune) bool</a></li>\n<li><a href=\"#ValidString\">func ValidString(s string) bool</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_DecodeLastRune\">DecodeLastRune</a></dd> <dd><a class=\"exampleLink\" href=\"#example_DecodeLastRuneInString\">DecodeLastRuneInString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_DecodeRune\">DecodeRune</a></dd> <dd><a class=\"exampleLink\" href=\"#example_DecodeRuneInString\">DecodeRuneInString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_EncodeRune\">EncodeRune</a></dd> <dd><a class=\"exampleLink\" href=\"#example_FullRune\">FullRune</a></dd> <dd><a class=\"exampleLink\" href=\"#example_FullRuneInString\">FullRuneInString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_RuneCount\">RuneCount</a></dd> <dd><a class=\"exampleLink\" href=\"#example_RuneCountInString\">RuneCountInString</a></dd> <dd><a class=\"exampleLink\" href=\"#example_RuneLen\">RuneLen</a></dd> <dd><a class=\"exampleLink\" href=\"#example_RuneStart\">RuneStart</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Valid\">Valid</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ValidRune\">ValidRune</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ValidString\">ValidString</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/unicode/utf8/utf8.go\">utf8.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        RuneError = '\\uFFFD'     // the \"error\" Rune or \"Unicode replacement character\"\n        RuneSelf  = 0x80         // characters below Runeself are represented as themselves in a single byte.\n        MaxRune   = '\\U0010FFFF' // Maximum valid Unicode code point.\n        UTFMax    = 4            // maximum number of bytes of a UTF-8 encoded Unicode character.\n)</pre> <p> Numbers fundamental to the encoding. </p> <h2 id=\"DecodeLastRune\">func DecodeLastRune  </h2> <pre data-language=\"go\">func DecodeLastRune(p []byte) (r rune, size int)</pre> <p> DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8. </p> <p> An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed. </p> <div id=\"example_DecodeLastRune\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tb := []byte(\"Hello, 世界\")\n\n\tfor len(b) &gt; 0 {\n\t\tr, size := utf8.DecodeLastRune(b)\n\t\tfmt.Printf(\"%c %v\\n\", r, size)\n\n\t\tb = b[:len(b)-size]\n\t}\n}\n</pre> </div> </div> <h2 id=\"DecodeLastRuneInString\">func DecodeLastRuneInString  </h2> <pre data-language=\"go\">func DecodeLastRuneInString(s string) (r rune, size int)</pre> <p> DecodeLastRuneInString is like DecodeLastRune but its input is a string. If s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8. </p> <p> An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed. </p> <div id=\"example_DecodeLastRuneInString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tstr := \"Hello, 世界\"\n\n\tfor len(str) &gt; 0 {\n\t\tr, size := utf8.DecodeLastRuneInString(str)\n\t\tfmt.Printf(\"%c %v\\n\", r, size)\n\n\t\tstr = str[:len(str)-size]\n\t}\n}\n</pre> </div> </div> <h2 id=\"DecodeRune\">func DecodeRune  </h2> <pre data-language=\"go\">func DecodeRune(p []byte) (r rune, size int)</pre> <p> DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8. </p> <p> An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed. </p> <div id=\"example_DecodeRune\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tb := []byte(\"Hello, 世界\")\n\n\tfor len(b) &gt; 0 {\n\t\tr, size := utf8.DecodeRune(b)\n\t\tfmt.Printf(\"%c %v\\n\", r, size)\n\n\t\tb = b[size:]\n\t}\n}\n</pre> </div> </div> <h2 id=\"DecodeRuneInString\">func DecodeRuneInString  </h2> <pre data-language=\"go\">func DecodeRuneInString(s string) (r rune, size int)</pre> <p> DecodeRuneInString is like DecodeRune but its input is a string. If s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8. </p> <p> An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed. </p> <div id=\"example_DecodeRuneInString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tstr := \"Hello, 世界\"\n\n\tfor len(str) &gt; 0 {\n\t\tr, size := utf8.DecodeRuneInString(str)\n\t\tfmt.Printf(\"%c %v\\n\", r, size)\n\n\t\tstr = str[size:]\n\t}\n}\n</pre> </div> </div> <h2 id=\"EncodeRune\">func EncodeRune  </h2> <pre data-language=\"go\">func EncodeRune(p []byte, r rune) int</pre> <p> EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune. It returns the number of bytes written. </p> <div id=\"example_EncodeRune\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tr := '世'\n\tbuf := make([]byte, 3)\n\n\tn := utf8.EncodeRune(buf, r)\n\n\tfmt.Println(buf)\n\tfmt.Println(n)\n}\n</pre> </div> </div> <h2 id=\"FullRune\">func FullRune  </h2> <pre data-language=\"go\">func FullRune(p []byte) bool</pre> <p> FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune. An invalid encoding is considered a full Rune since it will convert as a width-1 error rune. </p> <div id=\"example_FullRune\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tbuf := []byte{228, 184, 150} // 世\n\tfmt.Println(utf8.FullRune(buf))\n\tfmt.Println(utf8.FullRune(buf[:2]))\n}\n</pre> </div> </div> <h2 id=\"FullRuneInString\">func FullRuneInString  </h2> <pre data-language=\"go\">func FullRuneInString(s string) bool</pre> <p> FullRuneInString is like FullRune but its input is a string. </p> <div id=\"example_FullRuneInString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tstr := \"世\"\n\tfmt.Println(utf8.FullRuneInString(str))\n\tfmt.Println(utf8.FullRuneInString(str[:2]))\n}\n</pre> </div> </div> <h2 id=\"RuneCount\">func RuneCount  </h2> <pre data-language=\"go\">func RuneCount(p []byte) int</pre> <p> RuneCount returns the number of runes in p. Erroneous and short encodings are treated as single runes of width 1 byte. </p> <div id=\"example_RuneCount\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tbuf := []byte(\"Hello, 世界\")\n\tfmt.Println(\"bytes =\", len(buf))\n\tfmt.Println(\"runes =\", utf8.RuneCount(buf))\n}\n</pre> </div> </div> <h2 id=\"RuneCountInString\">func RuneCountInString  </h2> <pre data-language=\"go\">func RuneCountInString(s string) (n int)</pre> <p> RuneCountInString is like RuneCount but its input is a string. </p> <div id=\"example_RuneCountInString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tstr := \"Hello, 世界\"\n\tfmt.Println(\"bytes =\", len(str))\n\tfmt.Println(\"runes =\", utf8.RuneCountInString(str))\n}\n</pre> </div> </div> <h2 id=\"RuneLen\">func RuneLen  </h2> <pre data-language=\"go\">func RuneLen(r rune) int</pre> <p> RuneLen returns the number of bytes required to encode the rune. It returns -1 if the rune is not a valid value to encode in UTF-8. </p> <div id=\"example_RuneLen\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tfmt.Println(utf8.RuneLen('a'))\n\tfmt.Println(utf8.RuneLen('界'))\n}\n</pre> </div> </div> <h2 id=\"RuneStart\">func RuneStart  </h2> <pre data-language=\"go\">func RuneStart(b byte) bool</pre> <p> RuneStart reports whether the byte could be the first byte of an encoded, possibly invalid rune. Second and subsequent bytes always have the top two bits set to 10. </p> <div id=\"example_RuneStart\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tbuf := []byte(\"a界\")\n\tfmt.Println(utf8.RuneStart(buf[0]))\n\tfmt.Println(utf8.RuneStart(buf[1]))\n\tfmt.Println(utf8.RuneStart(buf[2]))\n}\n</pre> </div> </div> <h2 id=\"Valid\">func Valid  </h2> <pre data-language=\"go\">func Valid(p []byte) bool</pre> <p> Valid reports whether p consists entirely of valid UTF-8-encoded runes. </p> <div id=\"example_Valid\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tvalid := []byte(\"Hello, 世界\")\n\tinvalid := []byte{0xff, 0xfe, 0xfd}\n\n\tfmt.Println(utf8.Valid(valid))\n\tfmt.Println(utf8.Valid(invalid))\n}\n</pre> </div> </div> <h2 id=\"ValidRune\">func ValidRune  </h2> <pre data-language=\"go\">func ValidRune(r rune) bool</pre> <p> ValidRune reports whether r can be legally encoded as UTF-8. Code points that are out of range or a surrogate half are illegal. </p> <div id=\"example_ValidRune\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tvalid := 'a'\n\tinvalid := rune(0xfffffff)\n\n\tfmt.Println(utf8.ValidRune(valid))\n\tfmt.Println(utf8.ValidRune(invalid))\n}\n</pre> </div> </div> <h2 id=\"ValidString\">func ValidString  </h2> <pre data-language=\"go\">func ValidString(s string) bool</pre> <p> ValidString reports whether s consists entirely of valid UTF-8-encoded runes. </p> <div id=\"example_ValidString\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\tvalid := \"Hello, 世界\"\n\tinvalid := string([]byte{0xff, 0xfe, 0xfd})\n\n\tfmt.Println(utf8.ValidString(valid))\n\tfmt.Println(utf8.ValidString(invalid))\n}\n</pre> </div> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/unicode/utf8/\" class=\"_attribution-link\">https://golang.org/pkg/unicode/utf8/</a>\n  </p>\n</div>\n","runtime/internal/sys/index":"<h1>Package sys</h1>     <ul id=\"short-nav\">\n<li><code>import \"runtime/internal/sys\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> package sys contains system- and configuration- and architecture-specific constants used by the runtime. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#Bswap32\">func Bswap32(x uint32) uint32</a></li>\n<li><a href=\"#Bswap64\">func Bswap64(x uint64) uint64</a></li>\n<li><a href=\"#Ctz16\">func Ctz16(x uint16) uint16</a></li>\n<li><a href=\"#Ctz32\">func Ctz32(x uint32) uint32</a></li>\n<li><a href=\"#Ctz64\">func Ctz64(x uint64) uint64</a></li>\n<li><a href=\"#Ctz8\">func Ctz8(x uint8) uint8</a></li>\n<li><a href=\"#ArchFamilyType\">type ArchFamilyType</a></li>\n<li><a href=\"#Uintreg\">type Uintreg</a></li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/runtime/internal/sys/arch.go\">arch.go</a> <a href=\"https://golang.org/src/runtime/internal/sys/arch_amd64.go\">arch_amd64.go</a> <a href=\"https://golang.org/src/runtime/internal/sys/intrinsics.go\">intrinsics.go</a> <a href=\"https://golang.org/src/runtime/internal/sys/stubs.go\">stubs.go</a> <a href=\"https://golang.org/src/runtime/internal/sys/sys.go\">sys.go</a> <a href=\"https://golang.org/src/runtime/internal/sys/zgoarch_amd64.go\">zgoarch_amd64.go</a> <a href=\"https://golang.org/src/runtime/internal/sys/zgoos_linux.go\">zgoos_linux.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        ArchFamily    = AMD64\n        BigEndian     = 0\n        CacheLineSize = 64\n        PhysPageSize  = 4096\n        PCQuantum     = 1\n        Int64Align    = 8\n        HugePageSize  = 1 &lt;&lt; 21\n        MinFrameSize  = 0\n)</pre> <pre data-language=\"go\">const GOARCH = `amd64`</pre> <pre data-language=\"go\">const GOOS = `linux`</pre> <pre data-language=\"go\">const Goarch386 = 0</pre> <pre data-language=\"go\">const GoarchAmd64 = 1</pre> <pre data-language=\"go\">const GoarchAmd64p32 = 0</pre> <pre data-language=\"go\">const GoarchArm = 0</pre> <pre data-language=\"go\">const GoarchArm64 = 0</pre> <pre data-language=\"go\">const GoarchArm64be = 0</pre> <pre data-language=\"go\">const GoarchArmbe = 0</pre> <pre data-language=\"go\">const GoarchMips = 0</pre> <pre data-language=\"go\">const GoarchMips64 = 0</pre> <pre data-language=\"go\">const GoarchMips64le = 0</pre> <pre data-language=\"go\">const GoarchMips64p32 = 0</pre> <pre data-language=\"go\">const GoarchMips64p32le = 0</pre> <pre data-language=\"go\">const GoarchMipsle = 0</pre> <pre data-language=\"go\">const GoarchPpc = 0</pre> <pre data-language=\"go\">const GoarchPpc64 = 0</pre> <pre data-language=\"go\">const GoarchPpc64le = 0</pre> <pre data-language=\"go\">const GoarchS390 = 0</pre> <pre data-language=\"go\">const GoarchS390x = 0</pre> <pre data-language=\"go\">const GoarchSparc = 0</pre> <pre data-language=\"go\">const GoarchSparc64 = 0</pre> <pre data-language=\"go\">const GoosAndroid = 0</pre> <pre data-language=\"go\">const GoosDarwin = 0</pre> <pre data-language=\"go\">const GoosDragonfly = 0</pre> <pre data-language=\"go\">const GoosFreebsd = 0</pre> <pre data-language=\"go\">const GoosLinux = 1</pre> <pre data-language=\"go\">const GoosNacl = 0</pre> <pre data-language=\"go\">const GoosNetbsd = 0</pre> <pre data-language=\"go\">const GoosOpenbsd = 0</pre> <pre data-language=\"go\">const GoosPlan9 = 0</pre> <pre data-language=\"go\">const GoosSolaris = 0</pre> <pre data-language=\"go\">const GoosWindows = 0</pre> <pre data-language=\"go\">const PtrSize = 4 &lt;&lt; (^uintptr(0) &gt;&gt; 63) // unsafe.Sizeof(uintptr(0)) but an ideal const\n</pre> <pre data-language=\"go\">const RegSize = 4 &lt;&lt; (^Uintreg(0) &gt;&gt; 63) // unsafe.Sizeof(uintreg(0)) but an ideal const\n</pre> <pre data-language=\"go\">const SpAlign = 1*(1-GoarchArm64) + 16*GoarchArm64</pre> <h2 id=\"Bswap32\">func Bswap32  </h2> <pre data-language=\"go\">func Bswap32(x uint32) uint32</pre> <p> Bswap32 returns its input with byte order reversed 0x01020304 -&gt; 0x04030201 </p> <h2 id=\"Bswap64\">func Bswap64  </h2> <pre data-language=\"go\">func Bswap64(x uint64) uint64</pre> <p> Bswap64 returns its input with byte order reversed 0x0102030405060708 -&gt; 0x0807060504030201 </p> <h2 id=\"Ctz16\">func Ctz16  </h2> <pre data-language=\"go\">func Ctz16(x uint16) uint16</pre> <p> Ctz16 counts trailing (low-order) zeroes, and if all are zero, then 16. </p> <h2 id=\"Ctz32\">func Ctz32  </h2> <pre data-language=\"go\">func Ctz32(x uint32) uint32</pre> <p> Ctz32 counts trailing (low-order) zeroes, and if all are zero, then 32. </p> <h2 id=\"Ctz64\">func Ctz64  </h2> <pre data-language=\"go\">func Ctz64(x uint64) uint64</pre> <p> Ctz64 counts trailing (low-order) zeroes, and if all are zero, then 64. </p> <h2 id=\"Ctz8\">func Ctz8  </h2> <pre data-language=\"go\">func Ctz8(x uint8) uint8</pre> <p> Ctz8 counts trailing (low-order) zeroes, and if all are zero, then 8. </p> <h2 id=\"ArchFamilyType\">type ArchFamilyType  </h2> <pre data-language=\"go\">type ArchFamilyType int</pre> <pre data-language=\"go\">const (\n        AMD64 ArchFamilyType = iota\n        ARM\n        ARM64\n        I386\n        MIPS64\n        PPC64\n        S390X\n)</pre> <h2 id=\"Uintreg\">type Uintreg  </h2> <pre data-language=\"go\">type Uintreg uint64</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/runtime/internal/sys/\" class=\"_attribution-link\">https://golang.org/pkg/runtime/internal/sys/</a>\n  </p>\n</div>\n","net/index":"<h1>Package net</h1>     <ul id=\"short-nav\">\n<li><code>import \"net\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets. </p> <p> Although the package provides access to low-level networking primitives, most clients will need only the basic interface provided by the Dial, Listen, and Accept functions and the associated Conn and Listener interfaces. The crypto/tls package uses the same interfaces and similar Dial and Listen functions. </p> <p> The Dial function connects to a server: </p> <pre data-language=\"go\">conn, err := net.Dial(\"tcp\", \"golang.org:80\")\nif err != nil {\n\t// handle error\n}\nfmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\nstatus, err := bufio.NewReader(conn).ReadString('\\n')\n// ...\n</pre> <p> The Listen function creates servers: </p> <pre data-language=\"go\">ln, err := net.Listen(\"tcp\", \":8080\")\nif err != nil {\n\t// handle error\n}\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\t// handle error\n\t}\n\tgo handleConnection(conn)\n}\n</pre> <h3 id=\"hdr-Name_Resolution\">Name Resolution</h3> <p> The method for resolving domain names, whether indirectly with functions like Dial or directly with functions like LookupHost and LookupAddr, varies by operating system. </p> <p> On Unix systems, the resolver has two options for resolving names. It can use a pure Go resolver that sends DNS requests directly to the servers listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C library routines such as getaddrinfo and getnameinfo. </p> <p> By default the pure Go resolver is used, because a blocked DNS request consumes only a goroutine, while a blocked C call consumes an operating system thread. When cgo is available, the cgo-based resolver is used instead under a variety of conditions: on systems that do not let programs make direct DNS requests (OS X), when the LOCALDOMAIN environment variable is present (even if empty), when the RES_OPTIONS or HOSTALIASES environment variable is non-empty, when the ASR_CONFIG environment variable is non-empty (OpenBSD only), when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the Go resolver does not implement, and when the name being looked up ends in .local or is an mDNS name. </p> <p> The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in: </p> <pre data-language=\"go\">export GODEBUG=netdns=go    # force pure Go resolver\nexport GODEBUG=netdns=cgo   # force cgo resolver\n</pre> <p> The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag. </p> <p> A numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver to print debugging information about its decisions. To force a particular resolver while also printing debugging information, join the two settings by a plus sign, as in GODEBUG=netdns=go+1. </p> <p> On Plan 9, the resolver always accesses /net/cs and /net/dns. </p> <p> On Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#InterfaceAddrs\">func InterfaceAddrs() ([]Addr, error)</a></li>\n<li><a href=\"#Interfaces\">func Interfaces() ([]Interface, error)</a></li>\n<li><a href=\"#JoinHostPort\">func JoinHostPort(host, port string) string</a></li>\n<li><a href=\"#LookupAddr\">func LookupAddr(addr string) (names []string, err error)</a></li>\n<li><a href=\"#LookupCNAME\">func LookupCNAME(name string) (cname string, err error)</a></li>\n<li><a href=\"#LookupHost\">func LookupHost(host string) (addrs []string, err error)</a></li>\n<li><a href=\"#LookupIP\">func LookupIP(host string) (ips []IP, err error)</a></li>\n<li><a href=\"#LookupMX\">func LookupMX(name string) (mxs []*MX, err error)</a></li>\n<li><a href=\"#LookupNS\">func LookupNS(name string) (nss []*NS, err error)</a></li>\n<li><a href=\"#LookupPort\">func LookupPort(network, service string) (port int, err error)</a></li>\n<li><a href=\"#LookupSRV\">func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</a></li>\n<li><a href=\"#LookupTXT\">func LookupTXT(name string) (txts []string, err error)</a></li>\n<li><a href=\"#SplitHostPort\">func SplitHostPort(hostport string) (host, port string, err error)</a></li>\n<li><a href=\"#Addr\">type Addr</a></li>\n<li><a href=\"#AddrError\">type AddrError</a></li>\n<li> <a href=\"#AddrError.Error\">func (e *AddrError) Error() string</a>\n</li>\n<li> <a href=\"#AddrError.Temporary\">func (e *AddrError) Temporary() bool</a>\n</li>\n<li> <a href=\"#AddrError.Timeout\">func (e *AddrError) Timeout() bool</a>\n</li>\n<li><a href=\"#Conn\">type Conn</a></li>\n<li> <a href=\"#Dial\">func Dial(network, address string) (Conn, error)</a>\n</li>\n<li> <a href=\"#DialTimeout\">func DialTimeout(network, address string, timeout time.Duration) (Conn, error)</a>\n</li>\n<li> <a href=\"#FileConn\">func FileConn(f *os.File) (c Conn, err error)</a>\n</li>\n<li> <a href=\"#Pipe\">func Pipe() (Conn, Conn)</a>\n</li>\n<li><a href=\"#DNSConfigError\">type DNSConfigError</a></li>\n<li> <a href=\"#DNSConfigError.Error\">func (e *DNSConfigError) Error() string</a>\n</li>\n<li> <a href=\"#DNSConfigError.Temporary\">func (e *DNSConfigError) Temporary() bool</a>\n</li>\n<li> <a href=\"#DNSConfigError.Timeout\">func (e *DNSConfigError) Timeout() bool</a>\n</li>\n<li><a href=\"#DNSError\">type DNSError</a></li>\n<li> <a href=\"#DNSError.Error\">func (e *DNSError) Error() string</a>\n</li>\n<li> <a href=\"#DNSError.Temporary\">func (e *DNSError) Temporary() bool</a>\n</li>\n<li> <a href=\"#DNSError.Timeout\">func (e *DNSError) Timeout() bool</a>\n</li>\n<li><a href=\"#Dialer\">type Dialer</a></li>\n<li> <a href=\"#Dialer.Dial\">func (d *Dialer) Dial(network, address string) (Conn, error)</a>\n</li>\n<li> <a href=\"#Dialer.DialContext\">func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)</a>\n</li>\n<li><a href=\"#Error\">type Error</a></li>\n<li><a href=\"#Flags\">type Flags</a></li>\n<li> <a href=\"#Flags.String\">func (f Flags) String() string</a>\n</li>\n<li><a href=\"#HardwareAddr\">type HardwareAddr</a></li>\n<li> <a href=\"#ParseMAC\">func ParseMAC(s string) (hw HardwareAddr, err error)</a>\n</li>\n<li> <a href=\"#HardwareAddr.String\">func (a HardwareAddr) String() string</a>\n</li>\n<li><a href=\"#IP\">type IP</a></li>\n<li> <a href=\"#IPv4\">func IPv4(a, b, c, d byte) IP</a>\n</li>\n<li> <a href=\"#ParseCIDR\">func ParseCIDR(s string) (IP, *IPNet, error)</a>\n</li>\n<li> <a href=\"#ParseIP\">func ParseIP(s string) IP</a>\n</li>\n<li> <a href=\"#IP.DefaultMask\">func (ip IP) DefaultMask() IPMask</a>\n</li>\n<li> <a href=\"#IP.Equal\">func (ip IP) Equal(x IP) bool</a>\n</li>\n<li> <a href=\"#IP.IsGlobalUnicast\">func (ip IP) IsGlobalUnicast() bool</a>\n</li>\n<li> <a href=\"#IP.IsInterfaceLocalMulticast\">func (ip IP) IsInterfaceLocalMulticast() bool</a>\n</li>\n<li> <a href=\"#IP.IsLinkLocalMulticast\">func (ip IP) IsLinkLocalMulticast() bool</a>\n</li>\n<li> <a href=\"#IP.IsLinkLocalUnicast\">func (ip IP) IsLinkLocalUnicast() bool</a>\n</li>\n<li> <a href=\"#IP.IsLoopback\">func (ip IP) IsLoopback() bool</a>\n</li>\n<li> <a href=\"#IP.IsMulticast\">func (ip IP) IsMulticast() bool</a>\n</li>\n<li> <a href=\"#IP.IsUnspecified\">func (ip IP) IsUnspecified() bool</a>\n</li>\n<li> <a href=\"#IP.MarshalText\">func (ip IP) MarshalText() ([]byte, error)</a>\n</li>\n<li> <a href=\"#IP.Mask\">func (ip IP) Mask(mask IPMask) IP</a>\n</li>\n<li> <a href=\"#IP.String\">func (ip IP) String() string</a>\n</li>\n<li> <a href=\"#IP.To16\">func (ip IP) To16() IP</a>\n</li>\n<li> <a href=\"#IP.To4\">func (ip IP) To4() IP</a>\n</li>\n<li> <a href=\"#IP.UnmarshalText\">func (ip *IP) UnmarshalText(text []byte) error</a>\n</li>\n<li><a href=\"#IPAddr\">type IPAddr</a></li>\n<li> <a href=\"#ResolveIPAddr\">func ResolveIPAddr(net, addr string) (*IPAddr, error)</a>\n</li>\n<li> <a href=\"#IPAddr.Network\">func (a *IPAddr) Network() string</a>\n</li>\n<li> <a href=\"#IPAddr.String\">func (a *IPAddr) String() string</a>\n</li>\n<li><a href=\"#IPConn\">type IPConn</a></li>\n<li> <a href=\"#DialIP\">func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)</a>\n</li>\n<li> <a href=\"#ListenIP\">func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)</a>\n</li>\n<li> <a href=\"#IPConn.Close\">func (c *IPConn) Close() error</a>\n</li>\n<li> <a href=\"#IPConn.File\">func (c *IPConn) File() (f *os.File, err error)</a>\n</li>\n<li> <a href=\"#IPConn.LocalAddr\">func (c *IPConn) LocalAddr() Addr</a>\n</li>\n<li> <a href=\"#IPConn.Read\">func (c *IPConn) Read(b []byte) (int, error)</a>\n</li>\n<li> <a href=\"#IPConn.ReadFrom\">func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</a>\n</li>\n<li> <a href=\"#IPConn.ReadFromIP\">func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</a>\n</li>\n<li> <a href=\"#IPConn.ReadMsgIP\">func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)</a>\n</li>\n<li> <a href=\"#IPConn.RemoteAddr\">func (c *IPConn) RemoteAddr() Addr</a>\n</li>\n<li> <a href=\"#IPConn.SetDeadline\">func (c *IPConn) SetDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#IPConn.SetReadBuffer\">func (c *IPConn) SetReadBuffer(bytes int) error</a>\n</li>\n<li> <a href=\"#IPConn.SetReadDeadline\">func (c *IPConn) SetReadDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#IPConn.SetWriteBuffer\">func (c *IPConn) SetWriteBuffer(bytes int) error</a>\n</li>\n<li> <a href=\"#IPConn.SetWriteDeadline\">func (c *IPConn) SetWriteDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#IPConn.Write\">func (c *IPConn) Write(b []byte) (int, error)</a>\n</li>\n<li> <a href=\"#IPConn.WriteMsgIP\">func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)</a>\n</li>\n<li> <a href=\"#IPConn.WriteTo\">func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</a>\n</li>\n<li> <a href=\"#IPConn.WriteToIP\">func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</a>\n</li>\n<li><a href=\"#IPMask\">type IPMask</a></li>\n<li> <a href=\"#CIDRMask\">func CIDRMask(ones, bits int) IPMask</a>\n</li>\n<li> <a href=\"#IPv4Mask\">func IPv4Mask(a, b, c, d byte) IPMask</a>\n</li>\n<li> <a href=\"#IPMask.Size\">func (m IPMask) Size() (ones, bits int)</a>\n</li>\n<li> <a href=\"#IPMask.String\">func (m IPMask) String() string</a>\n</li>\n<li><a href=\"#IPNet\">type IPNet</a></li>\n<li> <a href=\"#IPNet.Contains\">func (n *IPNet) Contains(ip IP) bool</a>\n</li>\n<li> <a href=\"#IPNet.Network\">func (n *IPNet) Network() string</a>\n</li>\n<li> <a href=\"#IPNet.String\">func (n *IPNet) String() string</a>\n</li>\n<li><a href=\"#Interface\">type Interface</a></li>\n<li> <a href=\"#InterfaceByIndex\">func InterfaceByIndex(index int) (*Interface, error)</a>\n</li>\n<li> <a href=\"#InterfaceByName\">func InterfaceByName(name string) (*Interface, error)</a>\n</li>\n<li> <a href=\"#Interface.Addrs\">func (ifi *Interface) Addrs() ([]Addr, error)</a>\n</li>\n<li> <a href=\"#Interface.MulticastAddrs\">func (ifi *Interface) MulticastAddrs() ([]Addr, error)</a>\n</li>\n<li><a href=\"#InvalidAddrError\">type InvalidAddrError</a></li>\n<li> <a href=\"#InvalidAddrError.Error\">func (e InvalidAddrError) Error() string</a>\n</li>\n<li> <a href=\"#InvalidAddrError.Temporary\">func (e InvalidAddrError) Temporary() bool</a>\n</li>\n<li> <a href=\"#InvalidAddrError.Timeout\">func (e InvalidAddrError) Timeout() bool</a>\n</li>\n<li><a href=\"#Listener\">type Listener</a></li>\n<li> <a href=\"#FileListener\">func FileListener(f *os.File) (ln Listener, err error)</a>\n</li>\n<li> <a href=\"#Listen\">func Listen(net, laddr string) (Listener, error)</a>\n</li>\n<li><a href=\"#MX\">type MX</a></li>\n<li><a href=\"#NS\">type NS</a></li>\n<li><a href=\"#OpError\">type OpError</a></li>\n<li> <a href=\"#OpError.Error\">func (e *OpError) Error() string</a>\n</li>\n<li> <a href=\"#OpError.Temporary\">func (e *OpError) Temporary() bool</a>\n</li>\n<li> <a href=\"#OpError.Timeout\">func (e *OpError) Timeout() bool</a>\n</li>\n<li><a href=\"#PacketConn\">type PacketConn</a></li>\n<li> <a href=\"#FilePacketConn\">func FilePacketConn(f *os.File) (c PacketConn, err error)</a>\n</li>\n<li> <a href=\"#ListenPacket\">func ListenPacket(net, laddr string) (PacketConn, error)</a>\n</li>\n<li><a href=\"#ParseError\">type ParseError</a></li>\n<li> <a href=\"#ParseError.Error\">func (e *ParseError) Error() string</a>\n</li>\n<li><a href=\"#SRV\">type SRV</a></li>\n<li><a href=\"#TCPAddr\">type TCPAddr</a></li>\n<li> <a href=\"#ResolveTCPAddr\">func ResolveTCPAddr(net, addr string) (*TCPAddr, error)</a>\n</li>\n<li> <a href=\"#TCPAddr.Network\">func (a *TCPAddr) Network() string</a>\n</li>\n<li> <a href=\"#TCPAddr.String\">func (a *TCPAddr) String() string</a>\n</li>\n<li><a href=\"#TCPConn\">type TCPConn</a></li>\n<li> <a href=\"#DialTCP\">func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error)</a>\n</li>\n<li> <a href=\"#TCPConn.Close\">func (c *TCPConn) Close() error</a>\n</li>\n<li> <a href=\"#TCPConn.CloseRead\">func (c *TCPConn) CloseRead() error</a>\n</li>\n<li> <a href=\"#TCPConn.CloseWrite\">func (c *TCPConn) CloseWrite() error</a>\n</li>\n<li> <a href=\"#TCPConn.File\">func (c *TCPConn) File() (f *os.File, err error)</a>\n</li>\n<li> <a href=\"#TCPConn.LocalAddr\">func (c *TCPConn) LocalAddr() Addr</a>\n</li>\n<li> <a href=\"#TCPConn.Read\">func (c *TCPConn) Read(b []byte) (int, error)</a>\n</li>\n<li> <a href=\"#TCPConn.ReadFrom\">func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</a>\n</li>\n<li> <a href=\"#TCPConn.RemoteAddr\">func (c *TCPConn) RemoteAddr() Addr</a>\n</li>\n<li> <a href=\"#TCPConn.SetDeadline\">func (c *TCPConn) SetDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#TCPConn.SetKeepAlive\">func (c *TCPConn) SetKeepAlive(keepalive bool) error</a>\n</li>\n<li> <a href=\"#TCPConn.SetKeepAlivePeriod\">func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error</a>\n</li>\n<li> <a href=\"#TCPConn.SetLinger\">func (c *TCPConn) SetLinger(sec int) error</a>\n</li>\n<li> <a href=\"#TCPConn.SetNoDelay\">func (c *TCPConn) SetNoDelay(noDelay bool) error</a>\n</li>\n<li> <a href=\"#TCPConn.SetReadBuffer\">func (c *TCPConn) SetReadBuffer(bytes int) error</a>\n</li>\n<li> <a href=\"#TCPConn.SetReadDeadline\">func (c *TCPConn) SetReadDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#TCPConn.SetWriteBuffer\">func (c *TCPConn) SetWriteBuffer(bytes int) error</a>\n</li>\n<li> <a href=\"#TCPConn.SetWriteDeadline\">func (c *TCPConn) SetWriteDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#TCPConn.Write\">func (c *TCPConn) Write(b []byte) (int, error)</a>\n</li>\n<li><a href=\"#TCPListener\">type TCPListener</a></li>\n<li> <a href=\"#ListenTCP\">func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error)</a>\n</li>\n<li> <a href=\"#TCPListener.Accept\">func (l *TCPListener) Accept() (Conn, error)</a>\n</li>\n<li> <a href=\"#TCPListener.AcceptTCP\">func (l *TCPListener) AcceptTCP() (*TCPConn, error)</a>\n</li>\n<li> <a href=\"#TCPListener.Addr\">func (l *TCPListener) Addr() Addr</a>\n</li>\n<li> <a href=\"#TCPListener.Close\">func (l *TCPListener) Close() error</a>\n</li>\n<li> <a href=\"#TCPListener.File\">func (l *TCPListener) File() (f *os.File, err error)</a>\n</li>\n<li> <a href=\"#TCPListener.SetDeadline\">func (l *TCPListener) SetDeadline(t time.Time) error</a>\n</li>\n<li><a href=\"#UDPAddr\">type UDPAddr</a></li>\n<li> <a href=\"#ResolveUDPAddr\">func ResolveUDPAddr(net, addr string) (*UDPAddr, error)</a>\n</li>\n<li> <a href=\"#UDPAddr.Network\">func (a *UDPAddr) Network() string</a>\n</li>\n<li> <a href=\"#UDPAddr.String\">func (a *UDPAddr) String() string</a>\n</li>\n<li><a href=\"#UDPConn\">type UDPConn</a></li>\n<li> <a href=\"#DialUDP\">func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)</a>\n</li>\n<li> <a href=\"#ListenMulticastUDP\">func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</a>\n</li>\n<li> <a href=\"#ListenUDP\">func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error)</a>\n</li>\n<li> <a href=\"#UDPConn.Close\">func (c *UDPConn) Close() error</a>\n</li>\n<li> <a href=\"#UDPConn.File\">func (c *UDPConn) File() (f *os.File, err error)</a>\n</li>\n<li> <a href=\"#UDPConn.LocalAddr\">func (c *UDPConn) LocalAddr() Addr</a>\n</li>\n<li> <a href=\"#UDPConn.Read\">func (c *UDPConn) Read(b []byte) (int, error)</a>\n</li>\n<li> <a href=\"#UDPConn.ReadFrom\">func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</a>\n</li>\n<li> <a href=\"#UDPConn.ReadFromUDP\">func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error)</a>\n</li>\n<li> <a href=\"#UDPConn.ReadMsgUDP\">func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)</a>\n</li>\n<li> <a href=\"#UDPConn.RemoteAddr\">func (c *UDPConn) RemoteAddr() Addr</a>\n</li>\n<li> <a href=\"#UDPConn.SetDeadline\">func (c *UDPConn) SetDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#UDPConn.SetReadBuffer\">func (c *UDPConn) SetReadBuffer(bytes int) error</a>\n</li>\n<li> <a href=\"#UDPConn.SetReadDeadline\">func (c *UDPConn) SetReadDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#UDPConn.SetWriteBuffer\">func (c *UDPConn) SetWriteBuffer(bytes int) error</a>\n</li>\n<li> <a href=\"#UDPConn.SetWriteDeadline\">func (c *UDPConn) SetWriteDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#UDPConn.Write\">func (c *UDPConn) Write(b []byte) (int, error)</a>\n</li>\n<li> <a href=\"#UDPConn.WriteMsgUDP\">func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)</a>\n</li>\n<li> <a href=\"#UDPConn.WriteTo\">func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</a>\n</li>\n<li> <a href=\"#UDPConn.WriteToUDP\">func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</a>\n</li>\n<li><a href=\"#UnixAddr\">type UnixAddr</a></li>\n<li> <a href=\"#ResolveUnixAddr\">func ResolveUnixAddr(net, addr string) (*UnixAddr, error)</a>\n</li>\n<li> <a href=\"#UnixAddr.Network\">func (a *UnixAddr) Network() string</a>\n</li>\n<li> <a href=\"#UnixAddr.String\">func (a *UnixAddr) String() string</a>\n</li>\n<li><a href=\"#UnixConn\">type UnixConn</a></li>\n<li> <a href=\"#DialUnix\">func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)</a>\n</li>\n<li> <a href=\"#ListenUnixgram\">func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error)</a>\n</li>\n<li> <a href=\"#UnixConn.Close\">func (c *UnixConn) Close() error</a>\n</li>\n<li> <a href=\"#UnixConn.CloseRead\">func (c *UnixConn) CloseRead() error</a>\n</li>\n<li> <a href=\"#UnixConn.CloseWrite\">func (c *UnixConn) CloseWrite() error</a>\n</li>\n<li> <a href=\"#UnixConn.File\">func (c *UnixConn) File() (f *os.File, err error)</a>\n</li>\n<li> <a href=\"#UnixConn.LocalAddr\">func (c *UnixConn) LocalAddr() Addr</a>\n</li>\n<li> <a href=\"#UnixConn.Read\">func (c *UnixConn) Read(b []byte) (int, error)</a>\n</li>\n<li> <a href=\"#UnixConn.ReadFrom\">func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)</a>\n</li>\n<li> <a href=\"#UnixConn.ReadFromUnix\">func (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)</a>\n</li>\n<li> <a href=\"#UnixConn.ReadMsgUnix\">func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)</a>\n</li>\n<li> <a href=\"#UnixConn.RemoteAddr\">func (c *UnixConn) RemoteAddr() Addr</a>\n</li>\n<li> <a href=\"#UnixConn.SetDeadline\">func (c *UnixConn) SetDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#UnixConn.SetReadBuffer\">func (c *UnixConn) SetReadBuffer(bytes int) error</a>\n</li>\n<li> <a href=\"#UnixConn.SetReadDeadline\">func (c *UnixConn) SetReadDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#UnixConn.SetWriteBuffer\">func (c *UnixConn) SetWriteBuffer(bytes int) error</a>\n</li>\n<li> <a href=\"#UnixConn.SetWriteDeadline\">func (c *UnixConn) SetWriteDeadline(t time.Time) error</a>\n</li>\n<li> <a href=\"#UnixConn.Write\">func (c *UnixConn) Write(b []byte) (int, error)</a>\n</li>\n<li> <a href=\"#UnixConn.WriteMsgUnix\">func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)</a>\n</li>\n<li> <a href=\"#UnixConn.WriteTo\">func (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)</a>\n</li>\n<li> <a href=\"#UnixConn.WriteToUnix\">func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)</a>\n</li>\n<li><a href=\"#UnixListener\">type UnixListener</a></li>\n<li> <a href=\"#ListenUnix\">func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)</a>\n</li>\n<li> <a href=\"#UnixListener.Accept\">func (l *UnixListener) Accept() (Conn, error)</a>\n</li>\n<li> <a href=\"#UnixListener.AcceptUnix\">func (l *UnixListener) AcceptUnix() (*UnixConn, error)</a>\n</li>\n<li> <a href=\"#UnixListener.Addr\">func (l *UnixListener) Addr() Addr</a>\n</li>\n<li> <a href=\"#UnixListener.Close\">func (l *UnixListener) Close() error</a>\n</li>\n<li> <a href=\"#UnixListener.File\">func (l *UnixListener) File() (f *os.File, err error)</a>\n</li>\n<li> <a href=\"#UnixListener.SetDeadline\">func (l *UnixListener) SetDeadline(t time.Time) error</a>\n</li>\n<li><a href=\"#UnknownNetworkError\">type UnknownNetworkError</a></li>\n<li> <a href=\"#UnknownNetworkError.Error\">func (e UnknownNetworkError) Error() string</a>\n</li>\n<li> <a href=\"#UnknownNetworkError.Temporary\">func (e UnknownNetworkError) Temporary() bool</a>\n</li>\n<li> <a href=\"#UnknownNetworkError.Timeout\">func (e UnknownNetworkError) Timeout() bool</a>\n</li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Listener\">Listener</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/addrselect.go\">addrselect.go</a> <a href=\"https://golang.org/src/net/cgo_linux.go\">cgo_linux.go</a> <a href=\"https://golang.org/src/net/cgo_resnew.go\">cgo_resnew.go</a> <a href=\"https://golang.org/src/net/cgo_socknew.go\">cgo_socknew.go</a> <a href=\"https://golang.org/src/net/cgo_unix.go\">cgo_unix.go</a> <a href=\"https://golang.org/src/net/conf.go\">conf.go</a> <a href=\"https://golang.org/src/net/dial.go\">dial.go</a> <a href=\"https://golang.org/src/net/dnsclient.go\">dnsclient.go</a> <a href=\"https://golang.org/src/net/dnsclient_unix.go\">dnsclient_unix.go</a> <a href=\"https://golang.org/src/net/dnsconfig_unix.go\">dnsconfig_unix.go</a> <a href=\"https://golang.org/src/net/dnsmsg.go\">dnsmsg.go</a> <a href=\"https://golang.org/src/net/fd_mutex.go\">fd_mutex.go</a> <a href=\"https://golang.org/src/net/fd_poll_runtime.go\">fd_poll_runtime.go</a> <a href=\"https://golang.org/src/net/fd_posix.go\">fd_posix.go</a> <a href=\"https://golang.org/src/net/fd_unix.go\">fd_unix.go</a> <a href=\"https://golang.org/src/net/file.go\">file.go</a> <a href=\"https://golang.org/src/net/file_unix.go\">file_unix.go</a> <a href=\"https://golang.org/src/net/hook.go\">hook.go</a> <a href=\"https://golang.org/src/net/hook_cloexec.go\">hook_cloexec.go</a> <a href=\"https://golang.org/src/net/hook_unix.go\">hook_unix.go</a> <a href=\"https://golang.org/src/net/hosts.go\">hosts.go</a> <a href=\"https://golang.org/src/net/interface.go\">interface.go</a> <a href=\"https://golang.org/src/net/interface_linux.go\">interface_linux.go</a> <a href=\"https://golang.org/src/net/ip.go\">ip.go</a> <a href=\"https://golang.org/src/net/iprawsock.go\">iprawsock.go</a> <a href=\"https://golang.org/src/net/iprawsock_posix.go\">iprawsock_posix.go</a> <a href=\"https://golang.org/src/net/ipsock.go\">ipsock.go</a> <a href=\"https://golang.org/src/net/ipsock_posix.go\">ipsock_posix.go</a> <a href=\"https://golang.org/src/net/lookup.go\">lookup.go</a> <a href=\"https://golang.org/src/net/lookup_unix.go\">lookup_unix.go</a> <a href=\"https://golang.org/src/net/mac.go\">mac.go</a> <a href=\"https://golang.org/src/net/net.go\">net.go</a> <a href=\"https://golang.org/src/net/nss.go\">nss.go</a> <a href=\"https://golang.org/src/net/parse.go\">parse.go</a> <a href=\"https://golang.org/src/net/pipe.go\">pipe.go</a> <a href=\"https://golang.org/src/net/port.go\">port.go</a> <a href=\"https://golang.org/src/net/port_unix.go\">port_unix.go</a> <a href=\"https://golang.org/src/net/sendfile_linux.go\">sendfile_linux.go</a> <a href=\"https://golang.org/src/net/sock_cloexec.go\">sock_cloexec.go</a> <a href=\"https://golang.org/src/net/sock_linux.go\">sock_linux.go</a> <a href=\"https://golang.org/src/net/sock_posix.go\">sock_posix.go</a> <a href=\"https://golang.org/src/net/sockopt_linux.go\">sockopt_linux.go</a> <a href=\"https://golang.org/src/net/sockopt_posix.go\">sockopt_posix.go</a> <a href=\"https://golang.org/src/net/sockoptip_linux.go\">sockoptip_linux.go</a> <a href=\"https://golang.org/src/net/sockoptip_posix.go\">sockoptip_posix.go</a> <a href=\"https://golang.org/src/net/tcpsock.go\">tcpsock.go</a> <a href=\"https://golang.org/src/net/tcpsock_posix.go\">tcpsock_posix.go</a> <a href=\"https://golang.org/src/net/tcpsockopt_posix.go\">tcpsockopt_posix.go</a> <a href=\"https://golang.org/src/net/tcpsockopt_unix.go\">tcpsockopt_unix.go</a> <a href=\"https://golang.org/src/net/udpsock.go\">udpsock.go</a> <a href=\"https://golang.org/src/net/udpsock_posix.go\">udpsock_posix.go</a> <a href=\"https://golang.org/src/net/unixsock.go\">unixsock.go</a> <a href=\"https://golang.org/src/net/unixsock_posix.go\">unixsock_posix.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        IPv4len = 4\n        IPv6len = 16\n)</pre> <p> IP address lengths (bytes). </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        IPv4bcast     = IPv4(255, 255, 255, 255) // broadcast\n        IPv4allsys    = IPv4(224, 0, 0, 1)       // all systems\n        IPv4allrouter = IPv4(224, 0, 0, 2)       // all routers\n        IPv4zero      = IPv4(0, 0, 0, 0)         // all zeros\n)</pre> <p> Well-known IPv4 addresses </p> <pre data-language=\"go\">var (\n        IPv6zero                   = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n        IPv6unspecified            = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n        IPv6loopback               = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}\n        IPv6interfacelocalallnodes = IP{0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}\n        IPv6linklocalallnodes      = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}\n        IPv6linklocalallrouters    = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02}\n)</pre> <p> Well-known IPv6 addresses </p> <pre data-language=\"go\">var (\n        ErrWriteToConnected = errors.New(\"use of WriteTo with pre-connected connection\")\n)</pre> <p> Various errors contained in OpError. </p> <h2 id=\"InterfaceAddrs\">func InterfaceAddrs  </h2> <pre data-language=\"go\">func InterfaceAddrs() ([]Addr, error)</pre> <p> InterfaceAddrs returns a list of the system's network interface addresses. </p> <h2 id=\"Interfaces\">func Interfaces  </h2> <pre data-language=\"go\">func Interfaces() ([]Interface, error)</pre> <p> Interfaces returns a list of the system's network interfaces. </p> <h2 id=\"JoinHostPort\">func JoinHostPort  </h2> <pre data-language=\"go\">func JoinHostPort(host, port string) string</pre> <p> JoinHostPort combines host and port into a network address of the form \"host:port\" or, if host contains a colon or a percent sign, \"[host]:port\". </p> <h2 id=\"LookupAddr\">func LookupAddr  </h2> <pre data-language=\"go\">func LookupAddr(addr string) (names []string, err error)</pre> <p> LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address. </p> <h2 id=\"LookupCNAME\">func LookupCNAME  </h2> <pre data-language=\"go\">func LookupCNAME(name string) (cname string, err error)</pre> <p> LookupCNAME returns the canonical DNS host for the given name. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup. </p> <h2 id=\"LookupHost\">func LookupHost  </h2> <pre data-language=\"go\">func LookupHost(host string) (addrs []string, err error)</pre> <p> LookupHost looks up the given host using the local resolver. It returns an array of that host's addresses. </p> <h2 id=\"LookupIP\">func LookupIP  </h2> <pre data-language=\"go\">func LookupIP(host string) (ips []IP, err error)</pre> <p> LookupIP looks up host using the local resolver. It returns an array of that host's IPv4 and IPv6 addresses. </p> <h2 id=\"LookupMX\">func LookupMX  </h2> <pre data-language=\"go\">func LookupMX(name string) (mxs []*MX, err error)</pre> <p> LookupMX returns the DNS MX records for the given domain name sorted by preference. </p> <h2 id=\"LookupNS\">func LookupNS  </h2> <pre data-language=\"go\">func LookupNS(name string) (nss []*NS, err error)</pre> <p> LookupNS returns the DNS NS records for the given domain name. </p> <h2 id=\"LookupPort\">func LookupPort  </h2> <pre data-language=\"go\">func LookupPort(network, service string) (port int, err error)</pre> <p> LookupPort looks up the port for the given network and service. </p> <h2 id=\"LookupSRV\">func LookupSRV  </h2> <pre data-language=\"go\">func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</pre> <p> LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is \"tcp\" or \"udp\". The returned records are sorted by priority and randomized by weight within a priority. </p> <p> LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly. </p> <h2 id=\"LookupTXT\">func LookupTXT  </h2> <pre data-language=\"go\">func LookupTXT(name string) (txts []string, err error)</pre> <p> LookupTXT returns the DNS TXT records for the given domain name. </p> <h2 id=\"SplitHostPort\">func SplitHostPort  </h2> <pre data-language=\"go\">func SplitHostPort(hostport string) (host, port string, err error)</pre> <p> SplitHostPort splits a network address of the form \"host:port\", \"[host]:port\" or \"[ipv6-host%zone]:port\" into host or ipv6-host%zone and port. A literal address or host name for IPv6 must be enclosed in square brackets, as in \"[::1]:80\", \"[ipv6-host]:http\" or \"[ipv6-host%zone]:80\". </p> <h2 id=\"Addr\">type Addr  </h2> <pre data-language=\"go\">type Addr interface {\n        Network() string // name of the network\n        String() string  // string form of address\n}</pre> <p> Addr represents a network end point address. </p> <h2 id=\"AddrError\">type AddrError  </h2> <pre data-language=\"go\">type AddrError struct {\n        Err  string\n        Addr string\n}</pre> <h3 id=\"AddrError.Error\">func (*AddrError) <a href=\"https://golang.org/src/net/net.go?s=15300:15334#L499\">Error</a>  </h3> <pre data-language=\"go\">func (e *AddrError) Error() string</pre> <h3 id=\"AddrError.Temporary\">func (*AddrError) <a href=\"https://golang.org/src/net/net.go?s=15493:15529#L511\">Temporary</a>  </h3> <pre data-language=\"go\">func (e *AddrError) Temporary() bool</pre> <h3 id=\"AddrError.Timeout\">func (*AddrError) <a href=\"https://golang.org/src/net/net.go?s=15439:15473#L510\">Timeout</a>  </h3> <pre data-language=\"go\">func (e *AddrError) Timeout() bool</pre> <h2 id=\"Conn\">type Conn  </h2> <pre data-language=\"go\">type Conn interface {\n        // Read reads data from the connection.\n        // Read can be made to time out and return a Error with Timeout() == true\n        // after a fixed time limit; see SetDeadline and SetReadDeadline.\n        Read(b []byte) (n int, err error)\n\n        // Write writes data to the connection.\n        // Write can be made to time out and return a Error with Timeout() == true\n        // after a fixed time limit; see SetDeadline and SetWriteDeadline.\n        Write(b []byte) (n int, err error)\n\n        // Close closes the connection.\n        // Any blocked Read or Write operations will be unblocked and return errors.\n        Close() error\n\n        // LocalAddr returns the local network address.\n        LocalAddr() Addr\n\n        // RemoteAddr returns the remote network address.\n        RemoteAddr() Addr\n\n        // SetDeadline sets the read and write deadlines associated\n        // with the connection. It is equivalent to calling both\n        // SetReadDeadline and SetWriteDeadline.\n        //\n        // A deadline is an absolute time after which I/O operations\n        // fail with a timeout (see type Error) instead of\n        // blocking. The deadline applies to all future I/O, not just\n        // the immediately following call to Read or Write.\n        //\n        // An idle timeout can be implemented by repeatedly extending\n        // the deadline after successful Read or Write calls.\n        //\n        // A zero value for t means I/O operations will not time out.\n        SetDeadline(t time.Time) error\n\n        // SetReadDeadline sets the deadline for future Read calls.\n        // A zero value for t means Read will not time out.\n        SetReadDeadline(t time.Time) error\n\n        // SetWriteDeadline sets the deadline for future Write calls.\n        // Even if write times out, it may return n &gt; 0, indicating that\n        // some of the data was successfully written.\n        // A zero value for t means Write will not time out.\n        SetWriteDeadline(t time.Time) error\n}</pre> <p> Conn is a generic stream-oriented network connection. </p> <p> Multiple goroutines may invoke methods on a Conn simultaneously. </p> <h3 id=\"Dial\">func <a href=\"https://golang.org/src/net/dial.go?s=7517:7565#L249\">Dial</a>  </h3> <pre data-language=\"go\">func Dial(network, address string) (Conn, error)</pre> <p> Dial connects to the address on the named network. </p> <p> Known networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only), \"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\" (IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and \"unixpacket\". </p> <p> For TCP and UDP networks, addresses have the form host:port. If host is a literal IPv6 address it must be enclosed in square brackets as in \"[::1]:80\" or \"[ipv6-host%zone]:80\". The functions JoinHostPort and SplitHostPort manipulate addresses in this form. If the host is empty, as in \":80\", the local system is assumed. </p> <p> Examples: </p> <pre data-language=\"go\">Dial(\"tcp\", \"192.0.2.1:80\")\nDial(\"tcp\", \"golang.org:http\")\nDial(\"tcp\", \"[2001:db8::1]:http\")\nDial(\"tcp\", \"[fe80::1%lo0]:80\")\nDial(\"tcp\", \":80\")\n</pre> <p> For IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed by a colon and a protocol number or name and the addr must be a literal IP address. </p> <p> Examples: </p> <pre data-language=\"go\">Dial(\"ip4:1\", \"192.0.2.1\")\nDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n</pre> <p> For Unix networks, the address must be a file system path. </p> <h3 id=\"DialTimeout\">func <a href=\"https://golang.org/src/net/dial.go?s=7723:7801#L256\">DialTimeout</a>  </h3> <pre data-language=\"go\">func DialTimeout(network, address string, timeout time.Duration) (Conn, error)</pre> <p> DialTimeout acts like Dial but takes a timeout. The timeout includes name resolution, if required. </p> <h3 id=\"FileConn\">func <a href=\"https://golang.org/src/net/file.go?s=538:583#L8\">FileConn</a>  </h3> <pre data-language=\"go\">func FileConn(f *os.File) (c Conn, err error)</pre> <p> FileConn returns a copy of the network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p> <h3 id=\"Pipe\">func <a href=\"https://golang.org/src/net/pipe.go?s=461:485#L8\">Pipe</a>  </h3> <pre data-language=\"go\">func Pipe() (Conn, Conn)</pre> <p> Pipe creates a synchronous, in-memory, full duplex network connection; both ends implement the Conn interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering. </p> <h2 id=\"DNSConfigError\">type DNSConfigError  </h2> <pre data-language=\"go\">type DNSConfigError struct {\n        Err error\n}</pre> <p> DNSConfigError represents an error reading the machine's DNS configuration. (No longer used; kept for compatibility.) </p> <h3 id=\"DNSConfigError.Error\">func (*DNSConfigError) <a href=\"https://golang.org/src/net/net.go?s=16178:16217#L531\">Error</a>  </h3> <pre data-language=\"go\">func (e *DNSConfigError) Error() string</pre> <h3 id=\"DNSConfigError.Temporary\">func (*DNSConfigError) <a href=\"https://golang.org/src/net/net.go?s=16335:16376#L533\">Temporary</a>  </h3> <pre data-language=\"go\">func (e *DNSConfigError) Temporary() bool</pre> <h3 id=\"DNSConfigError.Timeout\">func (*DNSConfigError) <a href=\"https://golang.org/src/net/net.go?s=16276:16315#L532\">Timeout</a>  </h3> <pre data-language=\"go\">func (e *DNSConfigError) Timeout() bool</pre> <h2 id=\"DNSError\">type DNSError  </h2> <pre data-language=\"go\">type DNSError struct {\n        Err         string // description of the error\n        Name        string // name looked for\n        Server      string // server used\n        IsTimeout   bool   // if true, timed out; not all timeouts set this\n        IsTemporary bool   // if true, error is temporary; not all errors set this\n}</pre> <p> DNSError represents a DNS lookup error. </p> <h3 id=\"DNSError.Error\">func (*DNSError) <a href=\"https://golang.org/src/net/net.go?s=16825:16858#L549\">Error</a>  </h3> <pre data-language=\"go\">func (e *DNSError) Error() string</pre> <h3 id=\"DNSError.Temporary\">func (*DNSError) <a href=\"https://golang.org/src/net/net.go?s=17461:17496#L569\">Temporary</a>  </h3> <pre data-language=\"go\">func (e *DNSError) Temporary() bool</pre> <p> Temporary reports whether the DNS error is known to be temporary. This is not always known; a DNS lookup may fail due to a temporary error and return a DNSError for which Temporary returns false. </p> <h3 id=\"DNSError.Timeout\">func (*DNSError) <a href=\"https://golang.org/src/net/net.go?s=17198:17231#L564\">Timeout</a>  </h3> <pre data-language=\"go\">func (e *DNSError) Timeout() bool</pre> <p> Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false. </p> <h2 id=\"Dialer\">type Dialer  </h2> <pre data-language=\"go\">type Dialer struct {\n        // Timeout is the maximum amount of time a dial will wait for\n        // a connect to complete. If Deadline is also set, it may fail\n        // earlier.\n        //\n        // The default is no timeout.\n        //\n        // When dialing a name with multiple IP addresses, the timeout\n        // may be divided between them.\n        //\n        // With or without a timeout, the operating system may impose\n        // its own earlier timeout. For instance, TCP timeouts are\n        // often around 3 minutes.\n        Timeout time.Duration\n\n        // Deadline is the absolute point in time after which dials\n        // will fail. If Timeout is set, it may fail earlier.\n        // Zero means no deadline, or dependent on the operating system\n        // as with the Timeout option.\n        Deadline time.Time\n\n        // LocalAddr is the local address to use when dialing an\n        // address. The address must be of a compatible type for the\n        // network being dialed.\n        // If nil, a local address is automatically chosen.\n        LocalAddr Addr\n\n        // DualStack enables RFC 6555-compliant \"Happy Eyeballs\" dialing\n        // when the network is \"tcp\" and the destination is a host name\n        // with both IPv4 and IPv6 addresses. This allows a client to\n        // tolerate networks where one address family is silently broken.\n        DualStack bool\n\n        // FallbackDelay specifies the length of time to wait before\n        // spawning a fallback connection, when DualStack is enabled.\n        // If zero, a default delay of 300ms is used.\n        FallbackDelay time.Duration\n\n        // KeepAlive specifies the keep-alive period for an active\n        // network connection.\n        // If zero, keep-alives are not enabled. Network protocols\n        // that do not support keep-alives ignore this field.\n        KeepAlive time.Duration\n\n        // Cancel is an optional channel whose closure indicates that\n        // the dial should be canceled. Not all types of dials support\n        // cancelation.\n        //\n        // Deprecated: Use DialContext instead.\n        Cancel &lt;-chan struct{}\n}</pre> <p> A Dialer contains options for connecting to an address. </p> <p> The zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function. </p> <h3 id=\"Dialer.Dial\">func (*Dialer) <a href=\"https://golang.org/src/net/dial.go?s=8126:8186#L271\">Dial</a>  </h3> <pre data-language=\"go\">func (d *Dialer) Dial(network, address string) (Conn, error)</pre> <p> Dial connects to the address on the named network. </p> <p> See func Dial for a description of the network and address parameters. </p> <h3 id=\"Dialer.DialContext\">func (*Dialer) <a href=\"https://golang.org/src/net/dial.go?s=8649:8737#L285\">DialContext</a>  </h3> <pre data-language=\"go\">func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)</pre> <p> DialContext connects to the address on the named network using the provided context. </p> <p> The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection. </p> <p> See func Dial for a description of the network and address parameters. </p> <h2 id=\"Error\">type Error  </h2> <pre data-language=\"go\">type Error interface {\n        error\n        Timeout() bool   // Is the error a timeout?\n        Temporary() bool // Is the error temporary?\n}</pre> <p> An Error represents a network error. </p> <h2 id=\"Flags\">type Flags  </h2> <pre data-language=\"go\">type Flags uint</pre> <pre data-language=\"go\">const (\n        FlagUp           Flags = 1 &lt;&lt; iota // interface is up\n        FlagBroadcast                      // interface supports broadcast access capability\n        FlagLoopback                       // interface is a loopback interface\n        FlagPointToPoint                   // interface belongs to a point-to-point link\n        FlagMulticast                      // interface supports multicast access capability\n)</pre> <h3 id=\"Flags.String\">func (Flags) <a href=\"https://golang.org/src/net/interface.go?s=1609:1639#L40\">String</a>  </h3> <pre data-language=\"go\">func (f Flags) String() string</pre> <h2 id=\"HardwareAddr\">type HardwareAddr  </h2> <pre data-language=\"go\">type HardwareAddr []byte</pre> <p> A HardwareAddr represents a physical hardware address. </p> <h3 id=\"ParseMAC\">func <a href=\"https://golang.org/src/net/mac.go?s=1053:1105#L28\">ParseMAC</a>  </h3> <pre data-language=\"go\">func ParseMAC(s string) (hw HardwareAddr, err error)</pre> <p> ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats: </p> <pre data-language=\"go\">01:23:45:67:89:ab\n01:23:45:67:89:ab:cd:ef\n01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n01-23-45-67-89-ab\n01-23-45-67-89-ab-cd-ef\n01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n0123.4567.89ab\n0123.4567.89ab.cdef\n0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n</pre> <h3 id=\"HardwareAddr.String\">func (HardwareAddr) <a href=\"https://golang.org/src/net/mac.go?s=294:331#L2\">String</a>  </h3> <pre data-language=\"go\">func (a HardwareAddr) String() string</pre> <h2 id=\"IP\">type IP  </h2> <pre data-language=\"go\">type IP []byte</pre> <p> An IP is a single IP address, a slice of bytes. Functions in this package accept either 4-byte (IPv4) or 16-byte (IPv6) slices as input. </p> <p> Note that in this documentation, referring to an IP address as an IPv4 address or an IPv6 address is a semantic property of the address, not just the length of the byte slice: a 16-byte slice can still be an IPv4 address. </p> <h3 id=\"IPv4\">func <a href=\"https://golang.org/src/net/ip.go?s=1189:1218#L33\">IPv4</a>  </h3> <pre data-language=\"go\">func IPv4(a, b, c, d byte) IP</pre> <p> IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d. </p> <h3 id=\"ParseCIDR\">func <a href=\"https://golang.org/src/net/ip.go?s=15249:15293#L658\">ParseCIDR</a>  </h3> <pre data-language=\"go\">func ParseCIDR(s string) (IP, *IPNet, error)</pre> <p> ParseCIDR parses s as a CIDR notation IP address and mask, like \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in RFC 4632 and RFC 4291. </p> <p> It returns the IP address and the network implied by the IP and mask. For example, ParseCIDR(\"198.51.100.1/24\") returns the IP address 198.51.100.1 and the network 198.51.100.0/24. </p> <h3 id=\"ParseIP\">func <a href=\"https://golang.org/src/net/ip.go?s=14722:14747#L638\">ParseIP</a>  </h3> <pre data-language=\"go\">func ParseIP(s string) IP</pre> <p> ParseIP parses s as an IP address, returning the result. The string s can be in dotted decimal (\"192.0.2.1\") or IPv6 (\"2001:db8::68\") form. If s is not a valid textual representation of an IP address, ParseIP returns nil. </p> <h3 id=\"IP.DefaultMask\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=5567:5600#L202\">DefaultMask</a>  </h3> <pre data-language=\"go\">func (ip IP) DefaultMask() IPMask</pre> <p> DefaultMask returns the default IP mask for the IP address ip. Only IPv4 addresses have default masks; DefaultMask returns nil if ip is not a valid IPv4 address. </p> <h3 id=\"IP.Equal\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=8947:8976#L355\">Equal</a>  </h3> <pre data-language=\"go\">func (ip IP) Equal(x IP) bool</pre> <p> Equal reports whether ip and x are the same IP address. An IPv4 address and that same address in IPv6 form are considered to be equal. </p> <h3 id=\"IP.IsGlobalUnicast\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=4290:4325#L146\">IsGlobalUnicast</a>  </h3> <pre data-language=\"go\">func (ip IP) IsGlobalUnicast() bool</pre> <p> IsGlobalUnicast reports whether ip is a global unicast address. </p> <h3 id=\"IP.IsInterfaceLocalMulticast\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=3556:3601#L122\">IsInterfaceLocalMulticast</a>  </h3> <pre data-language=\"go\">func (ip IP) IsInterfaceLocalMulticast() bool</pre> <p> IsInterfaceLocalMulticast reports whether ip is an interface-local multicast address. </p> <h3 id=\"IP.IsLinkLocalMulticast\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=3754:3794#L128\">IsLinkLocalMulticast</a>  </h3> <pre data-language=\"go\">func (ip IP) IsLinkLocalMulticast() bool</pre> <p> IsLinkLocalMulticast reports whether ip is a link-local multicast address. </p> <h3 id=\"IP.IsLinkLocalUnicast\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=4033:4071#L137\">IsLinkLocalUnicast</a>  </h3> <pre data-language=\"go\">func (ip IP) IsLinkLocalUnicast() bool</pre> <p> IsLinkLocalUnicast reports whether ip is a link-local unicast address. </p> <h3 id=\"IP.IsLoopback\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=3132:3162#L105\">IsLoopback</a>  </h3> <pre data-language=\"go\">func (ip IP) IsLoopback() bool</pre> <p> IsLoopback reports whether ip is a loopback address. </p> <h3 id=\"IP.IsMulticast\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=3317:3348#L113\">IsMulticast</a>  </h3> <pre data-language=\"go\">func (ip IP) IsMulticast() bool</pre> <p> IsMulticast reports whether ip is a multicast address. </p> <h3 id=\"IP.IsUnspecified\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=2981:3014#L100\">IsUnspecified</a>  </h3> <pre data-language=\"go\">func (ip IP) IsUnspecified() bool</pre> <p> IsUnspecified reports whether ip is an unspecified address. </p> <h3 id=\"IP.MarshalText\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=8197:8239#L326\">MarshalText</a>  </h3> <pre data-language=\"go\">func (ip IP) MarshalText() ([]byte, error)</pre> <p> MarshalText implements the encoding.TextMarshaler interface. The encoding is the same as returned by String. </p> <h3 id=\"IP.Mask\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=5955:5988#L226\">Mask</a>  </h3> <pre data-language=\"go\">func (ip IP) Mask(mask IPMask) IP</pre> <p> Mask returns the result of masking the IP address ip with mask. </p> <h3 id=\"IP.String\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=6669:6697#L250\">String</a>  </h3> <pre data-language=\"go\">func (ip IP) String() string</pre> <p> String returns the string form of the IP address ip. It returns one of 4 forms: </p> <pre data-language=\"go\">- \"&lt;nil&gt;\", if ip has length 0\n- dotted decimal (\"192.0.2.1\"), if ip is an IPv4 or IP4-mapped IPv6 address\n- IPv6 (\"2001:db8::1\"), if ip is a valid IPv6 address\n- the hexadecimal form of ip, without punctuation, if no other cases apply\n</pre> <h3 id=\"IP.To16\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=5081:5103#L182\">To16</a>  </h3> <pre data-language=\"go\">func (ip IP) To16() IP</pre> <p> To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil. </p> <h3 id=\"IP.To4\">func (IP) <a href=\"https://golang.org/src/net/ip.go?s=4754:4775#L167\">To4</a>  </h3> <pre data-language=\"go\">func (ip IP) To4() IP</pre> <p> To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil. </p> <h3 id=\"IP.UnmarshalText\">func (*IP) <a href=\"https://golang.org/src/net/ip.go?s=8577:8623#L338\">UnmarshalText</a>  </h3> <pre data-language=\"go\">func (ip *IP) UnmarshalText(text []byte) error</pre> <p> UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by ParseIP. </p> <h2 id=\"IPAddr\">type IPAddr  </h2> <pre data-language=\"go\">type IPAddr struct {\n        IP   IP\n        Zone string // IPv6 scoped addressing zone\n}</pre> <p> IPAddr represents the address of an IP end point. </p> <h3 id=\"ResolveIPAddr\">func <a href=\"https://golang.org/src/net/iprawsock.go?s=970:1023#L39\">ResolveIPAddr</a>  </h3> <pre data-language=\"go\">func ResolveIPAddr(net, addr string) (*IPAddr, error)</pre> <p> ResolveIPAddr parses addr as an IP address of the form \"host\" or \"ipv6-host%zone\" and resolves the domain name on the network net, which must be \"ip\", \"ip4\" or \"ip6\". </p> <h3 id=\"IPAddr.Network\">func (*IPAddr) <a href=\"https://golang.org/src/net/iprawsock.go?s=390:423#L9\">Network</a>  </h3> <pre data-language=\"go\">func (a *IPAddr) Network() string</pre> <p> Network returns the address's network name, \"ip\". </p> <h3 id=\"IPAddr.String\">func (*IPAddr) <a href=\"https://golang.org/src/net/iprawsock.go?s=441:473#L11\">String</a>  </h3> <pre data-language=\"go\">func (a *IPAddr) String() string</pre> <h2 id=\"IPConn\">type IPConn  </h2> <pre data-language=\"go\">type IPConn struct {\n        // contains filtered or unexported fields\n}</pre> <p> IPConn is the implementation of the Conn and PacketConn interfaces for IP network connections. </p> <h3 id=\"DialIP\">func <a href=\"https://golang.org/src/net/iprawsock.go?s=4889:4956#L166\">DialIP</a>  </h3> <pre data-language=\"go\">func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)</pre> <p> DialIP connects to the remote address raddr on the network protocol netProto, which must be \"ip\", \"ip4\", or \"ip6\" followed by a colon and a protocol number or name. </p> <h3 id=\"ListenIP\">func <a href=\"https://golang.org/src/net/iprawsock.go?s=5384:5446#L178\">ListenIP</a>  </h3> <pre data-language=\"go\">func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)</pre> <p> ListenIP listens for incoming IP packets addressed to the local address laddr. The returned connection's ReadFrom and WriteTo methods can be used to receive and send IP packets with per-packet addressing. </p> <h3 id=\"IPConn.Close\">func (*IPConn) <a href=\"https://golang.org/src/net/net.go?s=6341:6369#L183\">Close</a>  </h3> <pre data-language=\"go\">func (c *IPConn) Close() error</pre> <p> Close closes the connection. </p> <h3 id=\"IPConn.File\">func (*IPConn) <a href=\"https://golang.org/src/net/net.go?s=9025:9070#L278\">File</a>  </h3> <pre data-language=\"go\">func (c *IPConn) File() (f *os.File, err error)</pre> <p> File sets the underlying os.File to blocking mode and returns a copy. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p> <p> The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p> <h3 id=\"IPConn.LocalAddr\">func (*IPConn) <a href=\"https://golang.org/src/net/net.go?s=6698:6729#L197\">LocalAddr</a>  </h3> <pre data-language=\"go\">func (c *IPConn) LocalAddr() Addr</pre> <p> LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. </p> <h3 id=\"IPConn.Read\">func (*IPConn) <a href=\"https://golang.org/src/net/net.go?s=5760:5802#L159\">Read</a>  </h3> <pre data-language=\"go\">func (c *IPConn) Read(b []byte) (int, error)</pre> <p> Read implements the Conn Read method. </p> <h3 id=\"IPConn.ReadFrom\">func (*IPConn) <a href=\"https://golang.org/src/net/iprawsock.go?s=2235:2289#L84\">ReadFrom</a>  </h3> <pre data-language=\"go\">func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</pre> <p> ReadFrom implements the PacketConn ReadFrom method. </p> <h3 id=\"IPConn.ReadFromIP\">func (*IPConn) <a href=\"https://golang.org/src/net/iprawsock.go?s=1902:1961#L72\">ReadFromIP</a>  </h3> <pre data-language=\"go\">func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</pre> <p> ReadFromIP reads an IP packet from c, copying the payload into b. It returns the number of bytes copied into b and the return address that was on the packet. </p> <p> ReadFromIP can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline. </p> <h3 id=\"IPConn.ReadMsgIP\">func (*IPConn) <a href=\"https://golang.org/src/net/iprawsock.go?s=2827:2914#L102\">ReadMsgIP</a>  </h3> <pre data-language=\"go\">func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)</pre> <p> ReadMsgIP reads a packet from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the packet and the source address of the packet. </p> <h3 id=\"IPConn.RemoteAddr\">func (*IPConn) <a href=\"https://golang.org/src/net/net.go?s=6923:6955#L207\">RemoteAddr</a>  </h3> <pre data-language=\"go\">func (c *IPConn) RemoteAddr() Addr</pre> <p> RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. </p> <h3 id=\"IPConn.SetDeadline\">func (*IPConn) <a href=\"https://golang.org/src/net/net.go?s=7065:7110#L215\">SetDeadline</a>  </h3> <pre data-language=\"go\">func (c *IPConn) SetDeadline(t time.Time) error</pre> <p> SetDeadline implements the Conn SetDeadline method. </p> <h3 id=\"IPConn.SetReadBuffer\">func (*IPConn) <a href=\"https://golang.org/src/net/net.go?s=8029:8074#L249\">SetReadBuffer</a>  </h3> <pre data-language=\"go\">func (c *IPConn) SetReadBuffer(bytes int) error</pre> <p> SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. </p> <h3 id=\"IPConn.SetReadDeadline\">func (*IPConn) <a href=\"https://golang.org/src/net/net.go?s=7365:7414#L226\">SetReadDeadline</a>  </h3> <pre data-language=\"go\">func (c *IPConn) SetReadDeadline(t time.Time) error</pre> <p> SetReadDeadline implements the Conn SetReadDeadline method. </p> <h3 id=\"IPConn.SetWriteBuffer\">func (*IPConn) <a href=\"https://golang.org/src/net/net.go?s=8382:8428#L261\">SetWriteBuffer</a>  </h3> <pre data-language=\"go\">func (c *IPConn) SetWriteBuffer(bytes int) error</pre> <p> SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. </p> <h3 id=\"IPConn.SetWriteDeadline\">func (*IPConn) <a href=\"https://golang.org/src/net/net.go?s=7675:7725#L237\">SetWriteDeadline</a>  </h3> <pre data-language=\"go\">func (c *IPConn) SetWriteDeadline(t time.Time) error</pre> <p> SetWriteDeadline implements the Conn SetWriteDeadline method. </p> <h3 id=\"IPConn.Write\">func (*IPConn) <a href=\"https://golang.org/src/net/net.go?s=6063:6106#L171\">Write</a>  </h3> <pre data-language=\"go\">func (c *IPConn) Write(b []byte) (int, error)</pre> <p> Write implements the Conn Write method. </p> <h3 id=\"IPConn.WriteMsgIP\">func (*IPConn) <a href=\"https://golang.org/src/net/iprawsock.go?s=4352:4433#L150\">WriteMsgIP</a>  </h3> <pre data-language=\"go\">func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)</pre> <p> WriteMsgIP writes a packet to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written. </p> <h3 id=\"IPConn.WriteTo\">func (*IPConn) <a href=\"https://golang.org/src/net/iprawsock.go?s=3761:3819#L132\">WriteTo</a>  </h3> <pre data-language=\"go\">func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</pre> <p> WriteTo implements the PacketConn WriteTo method. </p> <h3 id=\"IPConn.WriteToIP\">func (*IPConn) <a href=\"https://golang.org/src/net/iprawsock.go?s=3434:3497#L120\">WriteToIP</a>  </h3> <pre data-language=\"go\">func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</pre> <p> WriteToIP writes an IP packet to addr via c, copying the payload from b. </p> <p> WriteToIP can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetWriteDeadline. On packet-oriented connections, write timeouts are rare. </p> <h2 id=\"IPMask\">type IPMask  </h2> <pre data-language=\"go\">type IPMask []byte</pre> <p> An IP mask is an IP address. </p> <h3 id=\"CIDRMask\">func <a href=\"https://golang.org/src/net/ip.go?s=1774:1810#L59\">CIDRMask</a>  </h3> <pre data-language=\"go\">func CIDRMask(ones, bits int) IPMask</pre> <p> CIDRMask returns an IPMask consisting of `ones' 1 bits followed by 0s up to a total length of `bits' bits. For a mask of this form, CIDRMask is the inverse of IPMask.Size. </p> <h3 id=\"IPv4Mask\">func <a href=\"https://golang.org/src/net/ip.go?s=1472:1509#L47\">IPv4Mask</a>  </h3> <pre data-language=\"go\">func IPv4Mask(a, b, c, d byte) IPMask</pre> <p> IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d. </p> <h3 id=\"IPMask.Size\">func (IPMask) <a href=\"https://golang.org/src/net/ip.go?s=10220:10259#L416\">Size</a>  </h3> <pre data-language=\"go\">func (m IPMask) Size() (ones, bits int)</pre> <p> Size returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0. </p> <h3 id=\"IPMask.String\">func (IPMask) <a href=\"https://golang.org/src/net/ip.go?s=10417:10448#L425\">String</a>  </h3> <pre data-language=\"go\">func (m IPMask) String() string</pre> <p> String returns the hexadecimal form of m, with no punctuation. </p> <h2 id=\"IPNet\">type IPNet  </h2> <pre data-language=\"go\">type IPNet struct {\n        IP   IP     // network number\n        Mask IPMask // network mask\n}</pre> <p> An IPNet represents an IP network. </p> <h3 id=\"IPNet.Contains\">func (*IPNet) <a href=\"https://golang.org/src/net/ip.go?s=10913:10949#L456\">Contains</a>  </h3> <pre data-language=\"go\">func (n *IPNet) Contains(ip IP) bool</pre> <p> Contains reports whether the network includes ip. </p> <h3 id=\"IPNet.Network\">func (*IPNet) <a href=\"https://golang.org/src/net/ip.go?s=11233:11265#L474\">Network</a>  </h3> <pre data-language=\"go\">func (n *IPNet) Network() string</pre> <p> Network returns the address's network name, \"ip+net\". </p> <h3 id=\"IPNet.String\">func (*IPNet) <a href=\"https://golang.org/src/net/ip.go?s=11637:11668#L482\">String</a>  </h3> <pre data-language=\"go\">func (n *IPNet) String() string</pre> <p> String returns the CIDR notation of n like \"192.0.2.1/24\" or \"2001:db8::/48\" as defined in RFC 4632 and RFC 4291. If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like \"198.51.100.1/c000ff00\". </p> <h2 id=\"Interface\">type Interface  </h2> <pre data-language=\"go\">type Interface struct {\n        Index        int          // positive integer that starts at one, zero is never used\n        MTU          int          // maximum transmission unit\n        Name         string       // e.g., \"en0\", \"lo0\", \"eth0.100\"\n        HardwareAddr HardwareAddr // IEEE MAC-48, EUI-48 and EUI-64 form\n        Flags        Flags        // e.g., FlagUp, FlagLoopback, FlagMulticast\n}</pre> <p> Interface represents a mapping between network interface name and index. It also represents network interface facility information. </p> <h3 id=\"InterfaceByIndex\">func <a href=\"https://golang.org/src/net/interface.go?s=3280:3332#L104\">InterfaceByIndex</a>  </h3> <pre data-language=\"go\">func InterfaceByIndex(index int) (*Interface, error)</pre> <p> InterfaceByIndex returns the interface specified by index. </p> <h3 id=\"InterfaceByName\">func <a href=\"https://golang.org/src/net/interface.go?s=4009:4062#L129\">InterfaceByName</a>  </h3> <pre data-language=\"go\">func InterfaceByName(name string) (*Interface, error)</pre> <p> InterfaceByName returns the interface specified by name. </p> <h3 id=\"Interface.Addrs\">func (*Interface) <a href=\"https://golang.org/src/net/interface.go?s=1869:1914#L57\">Addrs</a>  </h3> <pre data-language=\"go\">func (ifi *Interface) Addrs() ([]Addr, error)</pre> <p> Addrs returns interface addresses for a specific interface. </p> <h3 id=\"Interface.MulticastAddrs\">func (*Interface) <a href=\"https://golang.org/src/net/interface.go?s=2285:2339#L70\">MulticastAddrs</a>  </h3> <pre data-language=\"go\">func (ifi *Interface) MulticastAddrs() ([]Addr, error)</pre> <p> MulticastAddrs returns multicast, joined group addresses for a specific interface. </p> <h2 id=\"InvalidAddrError\">type InvalidAddrError  </h2> <pre data-language=\"go\">type InvalidAddrError string</pre> <h3 id=\"InvalidAddrError.Error\">func (InvalidAddrError) <a href=\"https://golang.org/src/net/net.go?s=15826:15866#L521\">Error</a>  </h3> <pre data-language=\"go\">func (e InvalidAddrError) Error() string</pre> <h3 id=\"InvalidAddrError.Temporary\">func (InvalidAddrError) <a href=\"https://golang.org/src/net/net.go?s=15950:15992#L523\">Temporary</a>  </h3> <pre data-language=\"go\">func (e InvalidAddrError) Temporary() bool</pre> <h3 id=\"InvalidAddrError.Timeout\">func (InvalidAddrError) <a href=\"https://golang.org/src/net/net.go?s=15890:15930#L522\">Timeout</a>  </h3> <pre data-language=\"go\">func (e InvalidAddrError) Timeout() bool</pre> <h2 id=\"Listener\">type Listener  </h2> <pre data-language=\"go\">type Listener interface {\n        // Accept waits for and returns the next connection to the listener.\n        Accept() (Conn, error)\n\n        // Close closes the listener.\n        // Any blocked Accept operations will be unblocked and return errors.\n        Close() error\n\n        // Addr returns the listener's network address.\n        Addr() Addr\n}</pre> <p> A Listener is a generic network listener for stream-oriented protocols. </p> <p> Multiple goroutines may invoke methods on a Listener simultaneously. </p> <div id=\"example_Listener\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"net\"\n)\n\nfunc main() {\n\t// Listen on TCP port 2000 on all interfaces.\n\tl, err := net.Listen(\"tcp\", \":2000\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer l.Close()\n\tfor {\n\t\t// Wait for a connection.\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\t// Handle the connection in a new goroutine.\n\t\t// The loop then returns to accepting, so that\n\t\t// multiple connections may be served concurrently.\n\t\tgo func(c net.Conn) {\n\t\t\t// Echo all incoming data.\n\t\t\tio.Copy(c, c)\n\t\t\t// Shut down the connection.\n\t\t\tc.Close()\n\t\t}(conn)\n\t}\n}\n</pre> </div> </div> <h3 id=\"FileListener\">func <a href=\"https://golang.org/src/net/file.go?s=957:1011#L20\">FileListener</a>  </h3> <pre data-language=\"go\">func FileListener(f *os.File) (ln Listener, err error)</pre> <p> FileListener returns a copy of the network listener corresponding to the open file f. It is the caller's responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln. </p> <h3 id=\"Listen\">func <a href=\"https://golang.org/src/net/dial.go?s=15045:15093#L517\">Listen</a>  </h3> <pre data-language=\"go\">func Listen(net, laddr string) (Listener, error)</pre> <p> Listen announces on the local network address laddr. The network net must be a stream-oriented network: \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\". For TCP and UDP, the syntax of laddr is \"host:port\", like \"127.0.0.1:8080\". If host is omitted, as in \":8080\", Listen listens on all available interfaces instead of just the interface with the given host address. See Dial for more details about address syntax. </p> <h2 id=\"MX\">type MX  </h2> <pre data-language=\"go\">type MX struct {\n        Host string\n        Pref uint16\n}</pre> <p> An MX represents a single DNS MX record. </p> <h2 id=\"NS\">type NS  </h2> <pre data-language=\"go\">type NS struct {\n        Host string\n}</pre> <p> An NS represents a single DNS NS record. </p> <h2 id=\"OpError\">type OpError  </h2> <pre data-language=\"go\">type OpError struct {\n        // Op is the operation which caused the error, such as\n        // \"read\" or \"write\".\n        Op string\n\n        // Net is the network type on which this error occurred,\n        // such as \"tcp\" or \"udp6\".\n        Net string\n\n        // For operations involving a remote network connection, like\n        // Dial, Read, or Write, Source is the corresponding local\n        // network address.\n        Source Addr\n\n        // Addr is the network address for which this error occurred.\n        // For local operations, like Listen or SetDeadline, Addr is\n        // the address of the local endpoint being manipulated.\n        // For operations involving a remote network connection, like\n        // Dial, Read, or Write, Addr is the remote address of that\n        // connection.\n        Addr Addr\n\n        // Err is the error that occurred during the operation.\n        Err error\n}</pre> <p> OpError is the error type usually returned by functions in the net package. It describes the operation, network type, and address of an error. </p> <h3 id=\"OpError.Error\">func (*OpError) <a href=\"https://golang.org/src/net/net.go?s=13564:13596#L416\">Error</a>  </h3> <pre data-language=\"go\">func (e *OpError) Error() string</pre> <h3 id=\"OpError.Temporary\">func (*OpError) <a href=\"https://golang.org/src/net/net.go?s=14498:14532#L467\">Temporary</a>  </h3> <pre data-language=\"go\">func (e *OpError) Temporary() bool</pre> <h3 id=\"OpError.Timeout\">func (*OpError) <a href=\"https://golang.org/src/net/net.go?s=14257:14289#L454\">Timeout</a>  </h3> <pre data-language=\"go\">func (e *OpError) Timeout() bool</pre> <h2 id=\"PacketConn\">type PacketConn  </h2> <pre data-language=\"go\">type PacketConn interface {\n        // ReadFrom reads a packet from the connection,\n        // copying the payload into b. It returns the number of\n        // bytes copied into b and the return address that\n        // was on the packet.\n        // ReadFrom can be made to time out and return\n        // an error with Timeout() == true after a fixed time limit;\n        // see SetDeadline and SetReadDeadline.\n        ReadFrom(b []byte) (n int, addr Addr, err error)\n\n        // WriteTo writes a packet with payload b to addr.\n        // WriteTo can be made to time out and return\n        // an error with Timeout() == true after a fixed time limit;\n        // see SetDeadline and SetWriteDeadline.\n        // On packet-oriented connections, write timeouts are rare.\n        WriteTo(b []byte, addr Addr) (n int, err error)\n\n        // Close closes the connection.\n        // Any blocked ReadFrom or WriteTo operations will be unblocked and return errors.\n        Close() error\n\n        // LocalAddr returns the local network address.\n        LocalAddr() Addr\n\n        // SetDeadline sets the read and write deadlines associated\n        // with the connection.\n        SetDeadline(t time.Time) error\n\n        // SetReadDeadline sets the deadline for future Read calls.\n        // If the deadline is reached, Read will fail with a timeout\n        // (see type Error) instead of blocking.\n        // A zero value for t means Read will not time out.\n        SetReadDeadline(t time.Time) error\n\n        // SetWriteDeadline sets the deadline for future Write calls.\n        // If the deadline is reached, Write will fail with a timeout\n        // (see type Error) instead of blocking.\n        // A zero value for t means Write will not time out.\n        // Even if write times out, it may return n &gt; 0, indicating that\n        // some of the data was successfully written.\n        SetWriteDeadline(t time.Time) error\n}</pre> <p> PacketConn is a generic packet-oriented network connection. </p> <p> Multiple goroutines may invoke methods on a PacketConn simultaneously. </p> <h3 id=\"FilePacketConn\">func <a href=\"https://golang.org/src/net/file.go?s=1398:1455#L32\">FilePacketConn</a>  </h3> <pre data-language=\"go\">func FilePacketConn(f *os.File) (c PacketConn, err error)</pre> <p> FilePacketConn returns a copy of the packet network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p> <h3 id=\"ListenPacket\">func <a href=\"https://golang.org/src/net/dial.go?s=16121:16177#L544\">ListenPacket</a>  </h3> <pre data-language=\"go\">func ListenPacket(net, laddr string) (PacketConn, error)</pre> <p> ListenPacket announces on the local network address laddr. The network net must be a packet-oriented network: \"udp\", \"udp4\", \"udp6\", \"ip\", \"ip4\", \"ip6\" or \"unixgram\". For TCP and UDP, the syntax of laddr is \"host:port\", like \"127.0.0.1:8080\". If host is omitted, as in \":8080\", ListenPacket listens on all available interfaces instead of just the interface with the given host address. See Dial for the syntax of laddr. </p> <h2 id=\"ParseError\">type ParseError  </h2> <pre data-language=\"go\">type ParseError struct {\n        // Type is the type of string that was expected, such as\n        // \"IP address\", \"CIDR address\".\n        Type string\n\n        // Text is the malformed text string.\n        Text string\n}</pre> <p> A ParseError is the error type of literal network address parsers. </p> <h3 id=\"ParseError.Error\">func (*ParseError) <a href=\"https://golang.org/src/net/net.go?s=15163:15198#L492\">Error</a>  </h3> <pre data-language=\"go\">func (e *ParseError) Error() string</pre> <h2 id=\"SRV\">type SRV  </h2> <pre data-language=\"go\">type SRV struct {\n        Target   string\n        Port     uint16\n        Priority uint16\n        Weight   uint16\n}</pre> <p> An SRV represents a single DNS SRV record. </p> <h2 id=\"TCPAddr\">type TCPAddr  </h2> <pre data-language=\"go\">type TCPAddr struct {\n        IP   IP\n        Port int\n        Zone string // IPv6 scoped addressing zone\n}</pre> <p> TCPAddr represents the address of a TCP end point. </p> <h3 id=\"ResolveTCPAddr\">func <a href=\"https://golang.org/src/net/tcpsock.go?s=1246:1301#L46\">ResolveTCPAddr</a>  </h3> <pre data-language=\"go\">func ResolveTCPAddr(net, addr string) (*TCPAddr, error)</pre> <p> ResolveTCPAddr parses addr as a TCP address of the form \"host:port\" or \"[ipv6-host%zone]:port\" and resolves a pair of domain name and port name on the network net, which must be \"tcp\", \"tcp4\" or \"tcp6\". A literal address or host name for IPv6 must be enclosed in square brackets, as in \"[::1]:80\", \"[ipv6-host]:http\" or \"[ipv6-host%zone]:80\". </p> <h3 id=\"TCPAddr.Network\">func (*TCPAddr) <a href=\"https://golang.org/src/net/tcpsock.go?s=423:457#L13\">Network</a>  </h3> <pre data-language=\"go\">func (a *TCPAddr) Network() string</pre> <p> Network returns the address's network name, \"tcp\". </p> <h3 id=\"TCPAddr.String\">func (*TCPAddr) <a href=\"https://golang.org/src/net/tcpsock.go?s=476:509#L15\">String</a>  </h3> <pre data-language=\"go\">func (a *TCPAddr) String() string</pre> <h2 id=\"TCPConn\">type TCPConn  </h2> <pre data-language=\"go\">type TCPConn struct {\n        // contains filtered or unexported fields\n}</pre> <p> TCPConn is an implementation of the Conn interface for TCP network connections. </p> <h3 id=\"DialTCP\">func <a href=\"https://golang.org/src/net/tcpsock.go?s=4946:5011#L171\">DialTCP</a>  </h3> <pre data-language=\"go\">func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error)</pre> <p> DialTCP connects to the remote address raddr on the network net, which must be \"tcp\", \"tcp4\", or \"tcp6\". If laddr is not nil, it is used as the local address for the connection. </p> <h3 id=\"TCPConn.Close\">func (*TCPConn) <a href=\"https://golang.org/src/net/net.go?s=6341:6369#L183\">Close</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) Close() error</pre> <p> Close closes the connection. </p> <h3 id=\"TCPConn.CloseRead\">func (*TCPConn) <a href=\"https://golang.org/src/net/tcpsock.go?s=2176:2211#L81\">CloseRead</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) CloseRead() error</pre> <p> CloseRead shuts down the reading side of the TCP connection. Most callers should just use Close. </p> <h3 id=\"TCPConn.CloseWrite\">func (*TCPConn) <a href=\"https://golang.org/src/net/tcpsock.go?s=2513:2549#L93\">CloseWrite</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) CloseWrite() error</pre> <p> CloseWrite shuts down the writing side of the TCP connection. Most callers should just use Close. </p> <h3 id=\"TCPConn.File\">func (*TCPConn) <a href=\"https://golang.org/src/net/net.go?s=9025:9070#L278\">File</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) File() (f *os.File, err error)</pre> <p> File sets the underlying os.File to blocking mode and returns a copy. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p> <p> The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p> <h3 id=\"TCPConn.LocalAddr\">func (*TCPConn) <a href=\"https://golang.org/src/net/net.go?s=6698:6729#L197\">LocalAddr</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) LocalAddr() Addr</pre> <p> LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. </p> <h3 id=\"TCPConn.Read\">func (*TCPConn) <a href=\"https://golang.org/src/net/net.go?s=5760:5802#L159\">Read</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) Read(b []byte) (int, error)</pre> <p> Read implements the Conn Read method. </p> <h3 id=\"TCPConn.ReadFrom\">func (*TCPConn) <a href=\"https://golang.org/src/net/tcpsock.go?s=1800:1854#L68\">ReadFrom</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</pre> <p> ReadFrom implements the io.ReaderFrom ReadFrom method. </p> <h3 id=\"TCPConn.RemoteAddr\">func (*TCPConn) <a href=\"https://golang.org/src/net/net.go?s=6923:6955#L207\">RemoteAddr</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) RemoteAddr() Addr</pre> <p> RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. </p> <h3 id=\"TCPConn.SetDeadline\">func (*TCPConn) <a href=\"https://golang.org/src/net/net.go?s=7065:7110#L215\">SetDeadline</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) SetDeadline(t time.Time) error</pre> <p> SetDeadline implements the Conn SetDeadline method. </p> <h3 id=\"TCPConn.SetKeepAlive\">func (*TCPConn) <a href=\"https://golang.org/src/net/tcpsock.go?s=3580:3632#L127\">SetKeepAlive</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) SetKeepAlive(keepalive bool) error</pre> <p> SetKeepAlive sets whether the operating system should send keepalive messages on the connection. </p> <h3 id=\"TCPConn.SetKeepAlivePeriod\">func (*TCPConn) <a href=\"https://golang.org/src/net/tcpsock.go?s=3896:3955#L138\">SetKeepAlivePeriod</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error</pre> <p> SetKeepAlivePeriod sets period between keep alives. </p> <h3 id=\"TCPConn.SetLinger\">func (*TCPConn) <a href=\"https://golang.org/src/net/tcpsock.go?s=3235:3277#L115\">SetLinger</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) SetLinger(sec int) error</pre> <p> SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged. </p> <p> If sec &lt; 0 (the default), the operating system finishes sending the data in the background. </p> <p> If sec == 0, the operating system discards any unsent or unacknowledged data. </p> <p> If sec &gt; 0, the data is sent in the background as with sec &lt; 0. On some operating systems after sec seconds have elapsed any remaining unsent data may be discarded. </p> <h3 id=\"TCPConn.SetNoDelay\">func (*TCPConn) <a href=\"https://golang.org/src/net/tcpsock.go?s=4405:4453#L152\">SetNoDelay</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) SetNoDelay(noDelay bool) error</pre> <p> SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm). The default is true (no delay), meaning that data is sent as soon as possible after a Write. </p> <h3 id=\"TCPConn.SetReadBuffer\">func (*TCPConn) <a href=\"https://golang.org/src/net/net.go?s=8029:8074#L249\">SetReadBuffer</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) SetReadBuffer(bytes int) error</pre> <p> SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. </p> <h3 id=\"TCPConn.SetReadDeadline\">func (*TCPConn) <a href=\"https://golang.org/src/net/net.go?s=7365:7414#L226\">SetReadDeadline</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) SetReadDeadline(t time.Time) error</pre> <p> SetReadDeadline implements the Conn SetReadDeadline method. </p> <h3 id=\"TCPConn.SetWriteBuffer\">func (*TCPConn) <a href=\"https://golang.org/src/net/net.go?s=8382:8428#L261\">SetWriteBuffer</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) SetWriteBuffer(bytes int) error</pre> <p> SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. </p> <h3 id=\"TCPConn.SetWriteDeadline\">func (*TCPConn) <a href=\"https://golang.org/src/net/net.go?s=7675:7725#L237\">SetWriteDeadline</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) SetWriteDeadline(t time.Time) error</pre> <p> SetWriteDeadline implements the Conn SetWriteDeadline method. </p> <h3 id=\"TCPConn.Write\">func (*TCPConn) <a href=\"https://golang.org/src/net/net.go?s=6063:6106#L171\">Write</a>  </h3> <pre data-language=\"go\">func (c *TCPConn) Write(b []byte) (int, error)</pre> <p> Write implements the Conn Write method. </p> <h2 id=\"TCPListener\">type TCPListener  </h2> <pre data-language=\"go\">type TCPListener struct {\n        // contains filtered or unexported fields\n}</pre> <p> TCPListener is a TCP network listener. Clients should typically use variables of type Listener instead of assuming TCP. </p> <h3 id=\"ListenTCP\">func <a href=\"https://golang.org/src/net/tcpsock.go?s=8159:8223#L270\">ListenTCP</a>  </h3> <pre data-language=\"go\">func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error)</pre> <p> ListenTCP announces on the TCP address laddr and returns a TCP listener. Net must be \"tcp\", \"tcp4\", or \"tcp6\". If laddr has a port of 0, ListenTCP will choose an available port. The caller can use the Addr method of TCPListener to retrieve the chosen address. </p> <h3 id=\"TCPListener.Accept\">func (*TCPListener) <a href=\"https://golang.org/src/net/tcpsock.go?s=6139:6183#L208\">Accept</a>  </h3> <pre data-language=\"go\">func (l *TCPListener) Accept() (Conn, error)</pre> <p> Accept implements the Accept method in the Listener interface; it waits for the next call and returns a generic Conn. </p> <h3 id=\"TCPListener.AcceptTCP\">func (*TCPListener) <a href=\"https://golang.org/src/net/tcpsock.go?s=5762:5813#L195\">AcceptTCP</a>  </h3> <pre data-language=\"go\">func (l *TCPListener) AcceptTCP() (*TCPConn, error)</pre> <p> AcceptTCP accepts the next incoming call and returns the new connection. </p> <h3 id=\"TCPListener.Addr\">func (*TCPListener) <a href=\"https://golang.org/src/net/tcpsock.go?s=6840:6873#L234\">Addr</a>  </h3> <pre data-language=\"go\">func (l *TCPListener) Addr() Addr</pre> <p> Addr returns the listener's network address, a *TCPAddr. The Addr returned is shared by all invocations of Addr, so do not modify it. </p> <h3 id=\"TCPListener.Close\">func (*TCPListener) <a href=\"https://golang.org/src/net/tcpsock.go?s=6478:6513#L221\">Close</a>  </h3> <pre data-language=\"go\">func (l *TCPListener) Close() error</pre> <p> Close stops listening on the TCP address. Already Accepted connections are not closed. </p> <h3 id=\"TCPListener.File\">func (*TCPListener) <a href=\"https://golang.org/src/net/tcpsock.go?s=7644:7696#L255\">File</a>  </h3> <pre data-language=\"go\">func (l *TCPListener) File() (f *os.File, err error)</pre> <p> File returns a copy of the underlying os.File, set to blocking mode. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l. </p> <p> The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p> <h3 id=\"TCPListener.SetDeadline\">func (*TCPListener) <a href=\"https://golang.org/src/net/tcpsock.go?s=7004:7056#L238\">SetDeadline</a>  </h3> <pre data-language=\"go\">func (l *TCPListener) SetDeadline(t time.Time) error</pre> <p> SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline. </p> <h2 id=\"UDPAddr\">type UDPAddr  </h2> <pre data-language=\"go\">type UDPAddr struct {\n        IP   IP\n        Port int\n        Zone string // IPv6 scoped addressing zone\n}</pre> <p> UDPAddr represents the address of a UDP end point. </p> <h3 id=\"ResolveUDPAddr\">func <a href=\"https://golang.org/src/net/udpsock.go?s=1226:1281#L43\">ResolveUDPAddr</a>  </h3> <pre data-language=\"go\">func ResolveUDPAddr(net, addr string) (*UDPAddr, error)</pre> <p> ResolveUDPAddr parses addr as a UDP address of the form \"host:port\" or \"[ipv6-host%zone]:port\" and resolves a pair of domain name and port name on the network net, which must be \"udp\", \"udp4\" or \"udp6\". A literal address or host name for IPv6 must be enclosed in square brackets, as in \"[::1]:80\", \"[ipv6-host]:http\" or \"[ipv6-host%zone]:80\". </p> <h3 id=\"UDPAddr.Network\">func (*UDPAddr) <a href=\"https://golang.org/src/net/udpsock.go?s=403:437#L10\">Network</a>  </h3> <pre data-language=\"go\">func (a *UDPAddr) Network() string</pre> <p> Network returns the address's network name, \"udp\". </p> <h3 id=\"UDPAddr.String\">func (*UDPAddr) <a href=\"https://golang.org/src/net/udpsock.go?s=456:489#L12\">String</a>  </h3> <pre data-language=\"go\">func (a *UDPAddr) String() string</pre> <h2 id=\"UDPConn\">type UDPConn  </h2> <pre data-language=\"go\">type UDPConn struct {\n        // contains filtered or unexported fields\n}</pre> <p> UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections. </p> <h3 id=\"DialUDP\">func <a href=\"https://golang.org/src/net/udpsock.go?s=5216:5281#L168\">DialUDP</a>  </h3> <pre data-language=\"go\">func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)</pre> <p> DialUDP connects to the remote address raddr on the network net, which must be \"udp\", \"udp4\", or \"udp6\". If laddr is not nil, it is used as the local address for the connection. </p> <h3 id=\"ListenMulticastUDP\">func <a href=\"https://golang.org/src/net/udpsock.go?s=7235:7324#L218\">ListenMulticastUDP</a>  </h3> <pre data-language=\"go\">func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</pre> <p> ListenMulticastUDP listens for incoming multicast UDP packets addressed to the group address gaddr on the interface ifi. Network must be \"udp\", \"udp4\" or \"udp6\". ListenMulticastUDP uses the system-assigned multicast interface when ifi is nil, although this is not recommended because the assignment depends on platforms and sometimes it might require routing configuration. </p> <p> ListenMulticastUDP is just for convenience of simple, small applications. There are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for general purpose uses. </p> <h3 id=\"ListenUDP\">func <a href=\"https://golang.org/src/net/udpsock.go?s=6201:6261#L191\">ListenUDP</a>  </h3> <pre data-language=\"go\">func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error)</pre> <p> ListenUDP listens for incoming UDP packets addressed to the local address laddr. Net must be \"udp\", \"udp4\", or \"udp6\". If laddr has a port of 0, ListenUDP will choose an available port. The LocalAddr method of the returned UDPConn can be used to discover the port. The returned connection's ReadFrom and WriteTo methods can be used to receive and send UDP packets with per-packet addressing. </p> <h3 id=\"UDPConn.Close\">func (*UDPConn) <a href=\"https://golang.org/src/net/net.go?s=6341:6369#L183\">Close</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) Close() error</pre> <p> Close closes the connection. </p> <h3 id=\"UDPConn.File\">func (*UDPConn) <a href=\"https://golang.org/src/net/net.go?s=9025:9070#L278\">File</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) File() (f *os.File, err error)</pre> <p> File sets the underlying os.File to blocking mode and returns a copy. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p> <p> The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p> <h3 id=\"UDPConn.LocalAddr\">func (*UDPConn) <a href=\"https://golang.org/src/net/net.go?s=6698:6729#L197\">LocalAddr</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) LocalAddr() Addr</pre> <p> LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. </p> <h3 id=\"UDPConn.Read\">func (*UDPConn) <a href=\"https://golang.org/src/net/net.go?s=5760:5802#L159\">Read</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) Read(b []byte) (int, error)</pre> <p> Read implements the Conn Read method. </p> <h3 id=\"UDPConn.ReadFrom\">func (*UDPConn) <a href=\"https://golang.org/src/net/udpsock.go?s=2397:2452#L83\">ReadFrom</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</pre> <p> ReadFrom implements the PacketConn ReadFrom method. </p> <h3 id=\"UDPConn.ReadFromUDP\">func (*UDPConn) <a href=\"https://golang.org/src/net/udpsock.go?s=2061:2123#L71\">ReadFromUDP</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error)</pre> <p> ReadFromUDP reads a UDP packet from c, copying the payload into b. It returns the number of bytes copied into b and the return address that was on the packet. </p> <p> ReadFromUDP can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline. </p> <h3 id=\"UDPConn.ReadMsgUDP\">func (*UDPConn) <a href=\"https://golang.org/src/net/udpsock.go?s=2994:3084#L102\">ReadMsgUDP</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)</pre> <p> ReadMsgUDP reads a packet from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the packet and the source address of the packet. </p> <h3 id=\"UDPConn.RemoteAddr\">func (*UDPConn) <a href=\"https://golang.org/src/net/net.go?s=6923:6955#L207\">RemoteAddr</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) RemoteAddr() Addr</pre> <p> RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. </p> <h3 id=\"UDPConn.SetDeadline\">func (*UDPConn) <a href=\"https://golang.org/src/net/net.go?s=7065:7110#L215\">SetDeadline</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) SetDeadline(t time.Time) error</pre> <p> SetDeadline implements the Conn SetDeadline method. </p> <h3 id=\"UDPConn.SetReadBuffer\">func (*UDPConn) <a href=\"https://golang.org/src/net/net.go?s=8029:8074#L249\">SetReadBuffer</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) SetReadBuffer(bytes int) error</pre> <p> SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. </p> <h3 id=\"UDPConn.SetReadDeadline\">func (*UDPConn) <a href=\"https://golang.org/src/net/net.go?s=7365:7414#L226\">SetReadDeadline</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) SetReadDeadline(t time.Time) error</pre> <p> SetReadDeadline implements the Conn SetReadDeadline method. </p> <h3 id=\"UDPConn.SetWriteBuffer\">func (*UDPConn) <a href=\"https://golang.org/src/net/net.go?s=8382:8428#L261\">SetWriteBuffer</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) SetWriteBuffer(bytes int) error</pre> <p> SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. </p> <h3 id=\"UDPConn.SetWriteDeadline\">func (*UDPConn) <a href=\"https://golang.org/src/net/net.go?s=7675:7725#L237\">SetWriteDeadline</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) SetWriteDeadline(t time.Time) error</pre> <p> SetWriteDeadline implements the Conn SetWriteDeadline method. </p> <h3 id=\"UDPConn.Write\">func (*UDPConn) <a href=\"https://golang.org/src/net/net.go?s=6063:6106#L171\">Write</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) Write(b []byte) (int, error)</pre> <p> Write implements the Conn Write method. </p> <h3 id=\"UDPConn.WriteMsgUDP\">func (*UDPConn) <a href=\"https://golang.org/src/net/udpsock.go?s=4659:4743#L152\">WriteMsgUDP</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)</pre> <p> WriteMsgUDP writes a packet to addr via c if c isn't connected, or to c's remote destination address if c is connected (in which case addr must be nil). The payload is copied from b and the associated out-of-band data is copied from oob. It returns the number of payload and out-of-band bytes written. </p> <h3 id=\"UDPConn.WriteTo\">func (*UDPConn) <a href=\"https://golang.org/src/net/udpsock.go?s=3936:3995#L132\">WriteTo</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</pre> <p> WriteTo implements the PacketConn WriteTo method. </p> <h3 id=\"UDPConn.WriteToUDP\">func (*UDPConn) <a href=\"https://golang.org/src/net/udpsock.go?s=3606:3672#L120\">WriteToUDP</a>  </h3> <pre data-language=\"go\">func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</pre> <p> WriteToUDP writes a UDP packet to addr via c, copying the payload from b. </p> <p> WriteToUDP can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetWriteDeadline. On packet-oriented connections, write timeouts are rare. </p> <h2 id=\"UnixAddr\">type UnixAddr  </h2> <pre data-language=\"go\">type UnixAddr struct {\n        Name string\n        Net  string\n}</pre> <p> UnixAddr represents the address of a Unix domain socket end point. </p> <h3 id=\"ResolveUnixAddr\">func <a href=\"https://golang.org/src/net/unixsock.go?s=873:930#L37\">ResolveUnixAddr</a>  </h3> <pre data-language=\"go\">func ResolveUnixAddr(net, addr string) (*UnixAddr, error)</pre> <p> ResolveUnixAddr parses addr as a Unix domain socket address. The string net gives the network name, \"unix\", \"unixgram\" or \"unixpacket\". </p> <h3 id=\"UnixAddr.Network\">func (*UnixAddr) <a href=\"https://golang.org/src/net/unixsock.go?s=429:464#L12\">Network</a>  </h3> <pre data-language=\"go\">func (a *UnixAddr) Network() string</pre> <p> Network returns the address's network name, \"unix\", \"unixgram\" or \"unixpacket\". </p> <h3 id=\"UnixAddr.String\">func (*UnixAddr) <a href=\"https://golang.org/src/net/unixsock.go?s=484:518#L16\">String</a>  </h3> <pre data-language=\"go\">func (a *UnixAddr) String() string</pre> <h2 id=\"UnixConn\">type UnixConn  </h2> <pre data-language=\"go\">type UnixConn struct {\n        // contains filtered or unexported fields\n}</pre> <p> UnixConn is an implementation of the Conn interface for connections to Unix domain sockets. </p> <h3 id=\"DialUnix\">func <a href=\"https://golang.org/src/net/unixsock.go?s=5272:5340#L176\">DialUnix</a>  </h3> <pre data-language=\"go\">func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)</pre> <p> DialUnix connects to the remote address raddr on the network net, which must be \"unix\", \"unixgram\" or \"unixpacket\". If laddr is not nil, it is used as the local address for the connection. </p> <h3 id=\"ListenUnixgram\">func <a href=\"https://golang.org/src/net/unixsock.go?s=9175:9242#L295\">ListenUnixgram</a>  </h3> <pre data-language=\"go\">func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error)</pre> <p> ListenUnixgram listens for incoming Unix datagram packets addressed to the local address laddr. The network net must be \"unixgram\". The returned connection's ReadFrom and WriteTo methods can be used to receive and send packets with per-packet addressing. </p> <h3 id=\"UnixConn.Close\">func (*UnixConn) <a href=\"https://golang.org/src/net/net.go?s=6341:6369#L183\">Close</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) Close() error</pre> <p> Close closes the connection. </p> <h3 id=\"UnixConn.CloseRead\">func (*UnixConn) <a href=\"https://golang.org/src/net/unixsock.go?s=1329:1365#L54\">CloseRead</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) CloseRead() error</pre> <p> CloseRead shuts down the reading side of the Unix domain connection. Most callers should just use Close. </p> <h3 id=\"UnixConn.CloseWrite\">func (*UnixConn) <a href=\"https://golang.org/src/net/unixsock.go?s=1675:1712#L66\">CloseWrite</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) CloseWrite() error</pre> <p> CloseWrite shuts down the writing side of the Unix domain connection. Most callers should just use Close. </p> <h3 id=\"UnixConn.File\">func (*UnixConn) <a href=\"https://golang.org/src/net/net.go?s=9025:9070#L278\">File</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) File() (f *os.File, err error)</pre> <p> File sets the underlying os.File to blocking mode and returns a copy. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p> <p> The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p> <h3 id=\"UnixConn.LocalAddr\">func (*UnixConn) <a href=\"https://golang.org/src/net/net.go?s=6698:6729#L197\">LocalAddr</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) LocalAddr() Addr</pre> <p> LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. </p> <h3 id=\"UnixConn.Read\">func (*UnixConn) <a href=\"https://golang.org/src/net/net.go?s=5760:5802#L159\">Read</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) Read(b []byte) (int, error)</pre> <p> Read implements the Conn Read method. </p> <h3 id=\"UnixConn.ReadFrom\">func (*UnixConn) <a href=\"https://golang.org/src/net/unixsock.go?s=2561:2617#L95\">ReadFrom</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)</pre> <p> ReadFrom implements the PacketConn ReadFrom method. </p> <h3 id=\"UnixConn.ReadFromUnix\">func (*UnixConn) <a href=\"https://golang.org/src/net/unixsock.go?s=2222:2287#L83\">ReadFromUnix</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)</pre> <p> ReadFromUnix reads a packet from c, copying the payload into b. It returns the number of bytes copied into b and the source address of the packet. </p> <p> ReadFromUnix can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline. </p> <h3 id=\"UnixConn.ReadMsgUnix\">func (*UnixConn) <a href=\"https://golang.org/src/net/unixsock.go?s=3158:3251#L113\">ReadMsgUnix</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)</pre> <p> ReadMsgUnix reads a packet from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the packet, and the source address of the packet. </p> <h3 id=\"UnixConn.RemoteAddr\">func (*UnixConn) <a href=\"https://golang.org/src/net/net.go?s=6923:6955#L207\">RemoteAddr</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) RemoteAddr() Addr</pre> <p> RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. </p> <h3 id=\"UnixConn.SetDeadline\">func (*UnixConn) <a href=\"https://golang.org/src/net/net.go?s=7065:7110#L215\">SetDeadline</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) SetDeadline(t time.Time) error</pre> <p> SetDeadline implements the Conn SetDeadline method. </p> <h3 id=\"UnixConn.SetReadBuffer\">func (*UnixConn) <a href=\"https://golang.org/src/net/net.go?s=8029:8074#L249\">SetReadBuffer</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) SetReadBuffer(bytes int) error</pre> <p> SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. </p> <h3 id=\"UnixConn.SetReadDeadline\">func (*UnixConn) <a href=\"https://golang.org/src/net/net.go?s=7365:7414#L226\">SetReadDeadline</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) SetReadDeadline(t time.Time) error</pre> <p> SetReadDeadline implements the Conn SetReadDeadline method. </p> <h3 id=\"UnixConn.SetWriteBuffer\">func (*UnixConn) <a href=\"https://golang.org/src/net/net.go?s=8382:8428#L261\">SetWriteBuffer</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) SetWriteBuffer(bytes int) error</pre> <p> SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. </p> <h3 id=\"UnixConn.SetWriteDeadline\">func (*UnixConn) <a href=\"https://golang.org/src/net/net.go?s=7675:7725#L237\">SetWriteDeadline</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) SetWriteDeadline(t time.Time) error</pre> <p> SetWriteDeadline implements the Conn SetWriteDeadline method. </p> <h3 id=\"UnixConn.Write\">func (*UnixConn) <a href=\"https://golang.org/src/net/net.go?s=6063:6106#L171\">Write</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) Write(b []byte) (int, error)</pre> <p> Write implements the Conn Write method. </p> <h3 id=\"UnixConn.WriteMsgUnix\">func (*UnixConn) <a href=\"https://golang.org/src/net/unixsock.go?s=4698:4785#L160\">WriteMsgUnix</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)</pre> <p> WriteMsgUnix writes a packet to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written. </p> <h3 id=\"UnixConn.WriteTo\">func (*UnixConn) <a href=\"https://golang.org/src/net/unixsock.go?s=4101:4161#L142\">WriteTo</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)</pre> <p> WriteTo implements the PacketConn WriteTo method. </p> <h3 id=\"UnixConn.WriteToUnix\">func (*UnixConn) <a href=\"https://golang.org/src/net/unixsock.go?s=3768:3837#L130\">WriteToUnix</a>  </h3> <pre data-language=\"go\">func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)</pre> <p> WriteToUnix writes a packet to addr via c, copying the payload from b. </p> <p> WriteToUnix can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetWriteDeadline. On packet-oriented connections, write timeouts are rare. </p> <h2 id=\"UnixListener\">type UnixListener  </h2> <pre data-language=\"go\">type UnixListener struct {\n        // contains filtered or unexported fields\n}</pre> <p> UnixListener is a Unix domain socket listener. Clients should typically use variables of type Listener instead of assuming Unix domain sockets. </p> <h3 id=\"ListenUnix\">func <a href=\"https://golang.org/src/net/unixsock.go?s=8354:8421#L275\">ListenUnix</a>  </h3> <pre data-language=\"go\">func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)</pre> <p> ListenUnix announces on the Unix domain socket laddr and returns a Unix listener. The network net must be \"unix\" or \"unixpacket\". </p> <h3 id=\"UnixListener.Accept\">func (*UnixListener) <a href=\"https://golang.org/src/net/unixsock.go?s=6483:6528#L215\">Accept</a>  </h3> <pre data-language=\"go\">func (l *UnixListener) Accept() (Conn, error)</pre> <p> Accept implements the Accept method in the Listener interface. Returned connections will be of type *UnixConn. </p> <h3 id=\"UnixListener.AcceptUnix\">func (*UnixListener) <a href=\"https://golang.org/src/net/unixsock.go?s=6110:6164#L202\">AcceptUnix</a>  </h3> <pre data-language=\"go\">func (l *UnixListener) AcceptUnix() (*UnixConn, error)</pre> <p> AcceptUnix accepts the next incoming call and returns the new connection. </p> <h3 id=\"UnixListener.Addr\">func (*UnixListener) <a href=\"https://golang.org/src/net/unixsock.go?s=7175:7209#L241\">Addr</a>  </h3> <pre data-language=\"go\">func (l *UnixListener) Addr() Addr</pre> <p> Addr returns the listener's network address. The Addr returned is shared by all invocations of Addr, so do not modify it. </p> <h3 id=\"UnixListener.Close\">func (*UnixListener) <a href=\"https://golang.org/src/net/unixsock.go?s=6824:6860#L228\">Close</a>  </h3> <pre data-language=\"go\">func (l *UnixListener) Close() error</pre> <p> Close stops listening on the Unix address. Already accepted connections are not closed. </p> <h3 id=\"UnixListener.File\">func (*UnixListener) <a href=\"https://golang.org/src/net/unixsock.go?s=7981:8034#L262\">File</a>  </h3> <pre data-language=\"go\">func (l *UnixListener) File() (f *os.File, err error)</pre> <p> File returns a copy of the underlying os.File, set to blocking mode. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l. </p> <p> The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p> <h3 id=\"UnixListener.SetDeadline\">func (*UnixListener) <a href=\"https://golang.org/src/net/unixsock.go?s=7340:7393#L245\">SetDeadline</a>  </h3> <pre data-language=\"go\">func (l *UnixListener) SetDeadline(t time.Time) error</pre> <p> SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline. </p> <h2 id=\"UnknownNetworkError\">type UnknownNetworkError  </h2> <pre data-language=\"go\">type UnknownNetworkError string</pre> <h3 id=\"UnknownNetworkError.Error\">func (UnknownNetworkError) <a href=\"https://golang.org/src/net/net.go?s=15581:15624#L515\">Error</a>  </h3> <pre data-language=\"go\">func (e UnknownNetworkError) Error() string</pre> <h3 id=\"UnknownNetworkError.Temporary\">func (UnknownNetworkError) <a href=\"https://golang.org/src/net/net.go?s=15732:15777#L517\">Temporary</a>  </h3> <pre data-language=\"go\">func (e UnknownNetworkError) Temporary() bool</pre> <h3 id=\"UnknownNetworkError.Timeout\">func (UnknownNetworkError) <a href=\"https://golang.org/src/net/net.go?s=15669:15712#L516\">Timeout</a>  </h3> <pre data-language=\"go\">func (e UnknownNetworkError) Timeout() bool</pre> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/net/iprawsock_posix.go?s=285:852#L4\" style=\"float: left;\">☞</a> <p> On every POSIX platform, reads from the \"ip4\" network using the ReadFrom or ReadFromIP method might not return a complete IPv4 packet, including its header, even if there is space available. This can occur even in cases where Read or ReadMsgIP could return a complete packet. For this reason, it is recommended that you do not uses these methods if it is important to receive a full packet. </p> <p> The Go 1 compatibility guidelines make it impossible for us to change the behavior of these methods; use Read or ReadMsgIP instead. </p> </li> <li>\n<a href=\"https://golang.org/src/net/ipsock_posix.go?s=296:640#L5\" style=\"float: left;\">☞</a> <p> On DragonFly BSD and OpenBSD, listening on the \"tcp\" and \"udp\" networks does not listen for both IPv4 and IPv6 connections. This is due to the fact that IPv4 traffic will not be routed to an IPv6 socket - two separate sockets are required if both address families are to be supported. See inet6(4) for details. </p> </li> </ul> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"http/index\">http</a> </td> <td class=\"pkg-synopsis\"> Package http provides HTTP client and server implementations. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"http/cgi/index\">cgi</a> </td> <td class=\"pkg-synopsis\"> Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"http/cookiejar/index\">cookiejar</a> </td> <td class=\"pkg-synopsis\"> Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"http/fcgi/index\">fcgi</a> </td> <td class=\"pkg-synopsis\"> Package fcgi implements the FastCGI protocol. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"http/httptest/index\">httptest</a> </td> <td class=\"pkg-synopsis\"> Package httptest provides utilities for HTTP testing. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"http/httptrace/index\">httptrace</a> </td> <td class=\"pkg-synopsis\"> Package httptrace provides mechanisms to trace the events within HTTP client requests. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"http/httputil/index\">httputil</a> </td> <td class=\"pkg-synopsis\"> Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"http/pprof/index\">pprof</a> </td> <td class=\"pkg-synopsis\"> Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"mail/index\">mail</a> </td> <td class=\"pkg-synopsis\"> Package mail implements parsing of mail messages. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"rpc/index\">rpc</a> </td> <td class=\"pkg-synopsis\"> Package rpc provides access to the exported methods of an object across a network or other I/O connection. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"rpc/jsonrpc/index\">jsonrpc</a> </td> <td class=\"pkg-synopsis\"> Package jsonrpc implements a JSON-RPC ClientCodec and ServerCodec for the rpc package. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"smtp/index\">smtp</a> </td> <td class=\"pkg-synopsis\"> Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"textproto/index\">textproto</a> </td> <td class=\"pkg-synopsis\"> Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"url/index\">url</a> </td> <td class=\"pkg-synopsis\"> Package url parses URLs and implements query escaping. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/\" class=\"_attribution-link\">https://golang.org/pkg/net/</a>\n  </p>\n</div>\n","text/template/parse/index":"<h1>Package parse</h1>     <ul id=\"short-nav\">\n<li><code>import \"text/template/parse\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package parse builds parse trees for templates as defined by text/template and html/template. Clients should use those packages to construct templates rather than this one, which provides shared internal data structures not intended for general use. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#IsEmptyTree\">func IsEmptyTree(n Node) bool</a></li>\n<li><a href=\"#Parse\">func Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]interface{}) (map[string]*Tree, error)</a></li>\n<li><a href=\"#ActionNode\">type ActionNode</a></li>\n<li> <a href=\"#ActionNode.Copy\">func (a *ActionNode) Copy() Node</a>\n</li>\n<li> <a href=\"#ActionNode.String\">func (a *ActionNode) String() string</a>\n</li>\n<li><a href=\"#BoolNode\">type BoolNode</a></li>\n<li> <a href=\"#BoolNode.Copy\">func (b *BoolNode) Copy() Node</a>\n</li>\n<li> <a href=\"#BoolNode.String\">func (b *BoolNode) String() string</a>\n</li>\n<li><a href=\"#BranchNode\">type BranchNode</a></li>\n<li> <a href=\"#BranchNode.Copy\">func (b *BranchNode) Copy() Node</a>\n</li>\n<li> <a href=\"#BranchNode.String\">func (b *BranchNode) String() string</a>\n</li>\n<li><a href=\"#ChainNode\">type ChainNode</a></li>\n<li> <a href=\"#ChainNode.Add\">func (c *ChainNode) Add(field string)</a>\n</li>\n<li> <a href=\"#ChainNode.Copy\">func (c *ChainNode) Copy() Node</a>\n</li>\n<li> <a href=\"#ChainNode.String\">func (c *ChainNode) String() string</a>\n</li>\n<li><a href=\"#CommandNode\">type CommandNode</a></li>\n<li> <a href=\"#CommandNode.Copy\">func (c *CommandNode) Copy() Node</a>\n</li>\n<li> <a href=\"#CommandNode.String\">func (c *CommandNode) String() string</a>\n</li>\n<li><a href=\"#DotNode\">type DotNode</a></li>\n<li> <a href=\"#DotNode.Copy\">func (d *DotNode) Copy() Node</a>\n</li>\n<li> <a href=\"#DotNode.String\">func (d *DotNode) String() string</a>\n</li>\n<li> <a href=\"#DotNode.Type\">func (d *DotNode) Type() NodeType</a>\n</li>\n<li><a href=\"#FieldNode\">type FieldNode</a></li>\n<li> <a href=\"#FieldNode.Copy\">func (f *FieldNode) Copy() Node</a>\n</li>\n<li> <a href=\"#FieldNode.String\">func (f *FieldNode) String() string</a>\n</li>\n<li><a href=\"#IdentifierNode\">type IdentifierNode</a></li>\n<li> <a href=\"#NewIdentifier\">func NewIdentifier(ident string) *IdentifierNode</a>\n</li>\n<li> <a href=\"#IdentifierNode.Copy\">func (i *IdentifierNode) Copy() Node</a>\n</li>\n<li> <a href=\"#IdentifierNode.SetPos\">func (i *IdentifierNode) SetPos(pos Pos) *IdentifierNode</a>\n</li>\n<li> <a href=\"#IdentifierNode.SetTree\">func (i *IdentifierNode) SetTree(t *Tree) *IdentifierNode</a>\n</li>\n<li> <a href=\"#IdentifierNode.String\">func (i *IdentifierNode) String() string</a>\n</li>\n<li><a href=\"#IfNode\">type IfNode</a></li>\n<li> <a href=\"#IfNode.Copy\">func (i *IfNode) Copy() Node</a>\n</li>\n<li><a href=\"#ListNode\">type ListNode</a></li>\n<li> <a href=\"#ListNode.Copy\">func (l *ListNode) Copy() Node</a>\n</li>\n<li> <a href=\"#ListNode.CopyList\">func (l *ListNode) CopyList() *ListNode</a>\n</li>\n<li> <a href=\"#ListNode.String\">func (l *ListNode) String() string</a>\n</li>\n<li><a href=\"#NilNode\">type NilNode</a></li>\n<li> <a href=\"#NilNode.Copy\">func (n *NilNode) Copy() Node</a>\n</li>\n<li> <a href=\"#NilNode.String\">func (n *NilNode) String() string</a>\n</li>\n<li> <a href=\"#NilNode.Type\">func (n *NilNode) Type() NodeType</a>\n</li>\n<li><a href=\"#Node\">type Node</a></li>\n<li><a href=\"#NodeType\">type NodeType</a></li>\n<li> <a href=\"#NodeType.Type\">func (t NodeType) Type() NodeType</a>\n</li>\n<li><a href=\"#NumberNode\">type NumberNode</a></li>\n<li> <a href=\"#NumberNode.Copy\">func (n *NumberNode) Copy() Node</a>\n</li>\n<li> <a href=\"#NumberNode.String\">func (n *NumberNode) String() string</a>\n</li>\n<li><a href=\"#PipeNode\">type PipeNode</a></li>\n<li> <a href=\"#PipeNode.Copy\">func (p *PipeNode) Copy() Node</a>\n</li>\n<li> <a href=\"#PipeNode.CopyPipe\">func (p *PipeNode) CopyPipe() *PipeNode</a>\n</li>\n<li> <a href=\"#PipeNode.String\">func (p *PipeNode) String() string</a>\n</li>\n<li><a href=\"#Pos\">type Pos</a></li>\n<li> <a href=\"#Pos.Position\">func (p Pos) Position() Pos</a>\n</li>\n<li><a href=\"#RangeNode\">type RangeNode</a></li>\n<li> <a href=\"#RangeNode.Copy\">func (r *RangeNode) Copy() Node</a>\n</li>\n<li><a href=\"#StringNode\">type StringNode</a></li>\n<li> <a href=\"#StringNode.Copy\">func (s *StringNode) Copy() Node</a>\n</li>\n<li> <a href=\"#StringNode.String\">func (s *StringNode) String() string</a>\n</li>\n<li><a href=\"#TemplateNode\">type TemplateNode</a></li>\n<li> <a href=\"#TemplateNode.Copy\">func (t *TemplateNode) Copy() Node</a>\n</li>\n<li> <a href=\"#TemplateNode.String\">func (t *TemplateNode) String() string</a>\n</li>\n<li><a href=\"#TextNode\">type TextNode</a></li>\n<li> <a href=\"#TextNode.Copy\">func (t *TextNode) Copy() Node</a>\n</li>\n<li> <a href=\"#TextNode.String\">func (t *TextNode) String() string</a>\n</li>\n<li><a href=\"#Tree\">type Tree</a></li>\n<li> <a href=\"#New\">func New(name string, funcs ...map[string]interface{}) *Tree</a>\n</li>\n<li> <a href=\"#Tree.Copy\">func (t *Tree) Copy() *Tree</a>\n</li>\n<li> <a href=\"#Tree.ErrorContext\">func (t *Tree) ErrorContext(n Node) (location, context string)</a>\n</li>\n<li> <a href=\"#Tree.Parse\">func (t *Tree) Parse(text, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]interface{}) (tree *Tree, err error)</a>\n</li>\n<li><a href=\"#VariableNode\">type VariableNode</a></li>\n<li> <a href=\"#VariableNode.Copy\">func (v *VariableNode) Copy() Node</a>\n</li>\n<li> <a href=\"#VariableNode.String\">func (v *VariableNode) String() string</a>\n</li>\n<li><a href=\"#WithNode\">type WithNode</a></li>\n<li> <a href=\"#WithNode.Copy\">func (w *WithNode) Copy() Node</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/text/template/parse/lex.go\">lex.go</a> <a href=\"https://golang.org/src/text/template/parse/node.go\">node.go</a> <a href=\"https://golang.org/src/text/template/parse/parse.go\">parse.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"IsEmptyTree\">func IsEmptyTree  </h2> <pre data-language=\"go\">func IsEmptyTree(n Node) bool</pre> <p> IsEmptyTree reports whether this tree (node) is empty of everything but space. </p> <h2 id=\"Parse\">func Parse  </h2> <pre data-language=\"go\">func Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]interface{}) (map[string]*Tree, error)</pre> <p> Parse returns a map from template name to parse.Tree, created by parsing the templates described in the argument string. The top-level template will be given the specified name. If an error is encountered, parsing stops and an empty map is returned with the error. </p> <h2 id=\"ActionNode\">type ActionNode  </h2> <pre data-language=\"go\">type ActionNode struct {\n        NodeType\n        Pos\n\n        Line int       // The line number in the input. Deprecated: Kept for compatibility.\n        Pipe *PipeNode // The pipeline in the action.\n        // contains filtered or unexported fields\n}</pre> <p> ActionNode holds an action (something bounded by delimiters). Control actions have their own nodes; ActionNode represents simple ones such as field evaluations and parenthesized pipelines. </p> <h3 id=\"ActionNode.Copy\">func (*ActionNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=5726:5758#L218\">Copy</a>  </h3> <pre data-language=\"go\">func (a *ActionNode) Copy() Node</pre> <h3 id=\"ActionNode.String\">func (*ActionNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=5593:5629#L209\">String</a>  </h3> <pre data-language=\"go\">func (a *ActionNode) String() string</pre> <h2 id=\"BoolNode\">type BoolNode  </h2> <pre data-language=\"go\">type BoolNode struct {\n        NodeType\n        Pos\n\n        True bool // The value of the boolean constant.\n        // contains filtered or unexported fields\n}</pre> <p> BoolNode holds a boolean constant. </p> <h3 id=\"BoolNode.Copy\">func (*BoolNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=11896:11926#L501\">Copy</a>  </h3> <pre data-language=\"go\">func (b *BoolNode) Copy() Node</pre> <h3 id=\"BoolNode.String\">func (*BoolNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=11758:11792#L490\">String</a>  </h3> <pre data-language=\"go\">func (b *BoolNode) String() string</pre> <h2 id=\"BranchNode\">type BranchNode  </h2> <pre data-language=\"go\">type BranchNode struct {\n        NodeType\n        Pos\n\n        Line     int       // The line number in the input. Deprecated: Kept for compatibility.\n        Pipe     *PipeNode // The pipeline to be evaluated.\n        List     *ListNode // What to execute if the value is non-empty.\n        ElseList *ListNode // What to execute if the value is empty (nil if absent).\n        // contains filtered or unexported fields\n}</pre> <p> BranchNode is the common representation of if, range, and with. </p> <h3 id=\"BranchNode.Copy\">func (*BranchNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=18242:18274#L750\">Copy</a>  </h3> <pre data-language=\"go\">func (b *BranchNode) Copy() Node</pre> <h3 id=\"BranchNode.String\">func (*BranchNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=17799:17835#L728\">String</a>  </h3> <pre data-language=\"go\">func (b *BranchNode) String() string</pre> <h2 id=\"ChainNode\">type ChainNode  </h2> <pre data-language=\"go\">type ChainNode struct {\n        NodeType\n        Pos\n\n        Node  Node\n        Field []string // The identifiers in lexical order.\n        // contains filtered or unexported fields\n}</pre> <p> ChainNode holds a term followed by a chain of field accesses (identifier starting with '.'). The names may be chained ('.x.y'). The periods are dropped from each ident. </p> <h3 id=\"ChainNode.Add\">func (*ChainNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=10867:10904#L448\">Add</a>  </h3> <pre data-language=\"go\">func (c *ChainNode) Add(field string)</pre> <p> Add adds the named field (which should start with a period) to the end of the chain. </p> <h3 id=\"ChainNode.Copy\">func (*ChainNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=11341:11372#L474\">Copy</a>  </h3> <pre data-language=\"go\">func (c *ChainNode) Copy() Node</pre> <h3 id=\"ChainNode.String\">func (*ChainNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=11101:11136#L459\">String</a>  </h3> <pre data-language=\"go\">func (c *ChainNode) String() string</pre> <h2 id=\"CommandNode\">type CommandNode  </h2> <pre data-language=\"go\">type CommandNode struct {\n        NodeType\n        Pos\n\n        Args []Node // Arguments in lexical order: Identifier, field, or constant.\n        // contains filtered or unexported fields\n}</pre> <p> CommandNode holds a command (a pipeline inside an evaluating action). </p> <h3 id=\"CommandNode.Copy\">func (*CommandNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=6499:6532#L258\">Copy</a>  </h3> <pre data-language=\"go\">func (c *CommandNode) Copy() Node</pre> <h3 id=\"CommandNode.String\">func (*CommandNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=6215:6252#L239\">String</a>  </h3> <pre data-language=\"go\">func (c *CommandNode) String() string</pre> <h2 id=\"DotNode\">type DotNode  </h2> <pre data-language=\"go\">type DotNode struct {\n        NodeType\n        Pos\n        // contains filtered or unexported fields\n}</pre> <p> DotNode holds the special identifier '.'. </p> <h3 id=\"DotNode.Copy\">func (*DotNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=8949:8978#L368\">Copy</a>  </h3> <pre data-language=\"go\">func (d *DotNode) Copy() Node</pre> <h3 id=\"DotNode.String\">func (*DotNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=8849:8882#L360\">String</a>  </h3> <pre data-language=\"go\">func (d *DotNode) String() string</pre> <h3 id=\"DotNode.Type\">func (*DotNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=8638:8671#L353\">Type</a>  </h3> <pre data-language=\"go\">func (d *DotNode) Type() NodeType</pre> <h2 id=\"FieldNode\">type FieldNode  </h2> <pre data-language=\"go\">type FieldNode struct {\n        NodeType\n        Pos\n\n        Ident []string // The identifiers in lexical order.\n        // contains filtered or unexported fields\n}</pre> <p> FieldNode holds a field (identifier starting with '.'). The names may be chained ('.x.y'). The period is dropped from each ident. </p> <h3 id=\"FieldNode.Copy\">func (*FieldNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=10214:10245#L428\">Copy</a>  </h3> <pre data-language=\"go\">func (f *FieldNode) Copy() Node</pre> <h3 id=\"FieldNode.String\">func (*FieldNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=10054:10089#L416\">String</a>  </h3> <pre data-language=\"go\">func (f *FieldNode) String() string</pre> <h2 id=\"IdentifierNode\">type IdentifierNode  </h2> <pre data-language=\"go\">type IdentifierNode struct {\n        NodeType\n        Pos\n\n        Ident string // The identifier's name.\n        // contains filtered or unexported fields\n}</pre> <p> IdentifierNode holds an identifier. </p> <h3 id=\"NewIdentifier\">func <a href=\"https://golang.org/src/text/template/parse/node.go?s=6875:6923#L278\">NewIdentifier</a>  </h3> <pre data-language=\"go\">func NewIdentifier(ident string) *IdentifierNode</pre> <p> NewIdentifier returns a new IdentifierNode with the given identifier name. </p> <h3 id=\"IdentifierNode.Copy\">func (*IdentifierNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=7588:7624#L306\">Copy</a>  </h3> <pre data-language=\"go\">func (i *IdentifierNode) Copy() Node</pre> <h3 id=\"IdentifierNode.SetPos\">func (*IdentifierNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=7139:7195#L285\">SetPos</a>  </h3> <pre data-language=\"go\">func (i *IdentifierNode) SetPos(pos Pos) *IdentifierNode</pre> <p> SetPos sets the position. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day? </p> <h3 id=\"IdentifierNode.SetTree\">func (*IdentifierNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=7387:7444#L293\">SetTree</a>  </h3> <pre data-language=\"go\">func (i *IdentifierNode) SetTree(t *Tree) *IdentifierNode</pre> <p> SetTree sets the parent tree for the node. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day? </p> <h3 id=\"IdentifierNode.String\">func (*IdentifierNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=7470:7510#L298\">String</a>  </h3> <pre data-language=\"go\">func (i *IdentifierNode) String() string</pre> <h2 id=\"IfNode\">type IfNode  </h2> <pre data-language=\"go\">type IfNode struct {\n        BranchNode\n}</pre> <p> IfNode represents an {{if}} action and its commands. </p> <h3 id=\"IfNode.Copy\">func (*IfNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=18892:18920#L772\">Copy</a>  </h3> <pre data-language=\"go\">func (i *IfNode) Copy() Node</pre> <h2 id=\"ListNode\">type ListNode  </h2> <pre data-language=\"go\">type ListNode struct {\n        NodeType\n        Pos\n\n        Nodes []Node // The element nodes in lexical order.\n        // contains filtered or unexported fields\n}</pre> <p> ListNode holds a sequence of nodes. </p> <h3 id=\"ListNode.Copy\">func (*ListNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=3228:3258#L105\">Copy</a>  </h3> <pre data-language=\"go\">func (l *ListNode) Copy() Node</pre> <h3 id=\"ListNode.CopyList\">func (*ListNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=3059:3098#L94\">CopyList</a>  </h3> <pre data-language=\"go\">func (l *ListNode) CopyList() *ListNode</pre> <h3 id=\"ListNode.String\">func (*ListNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=2925:2959#L86\">String</a>  </h3> <pre data-language=\"go\">func (l *ListNode) String() string</pre> <h2 id=\"NilNode\">type NilNode  </h2> <pre data-language=\"go\">type NilNode struct {\n        NodeType\n        Pos\n        // contains filtered or unexported fields\n}</pre> <p> NilNode holds the special identifier 'nil' representing an untyped nil constant. </p> <h3 id=\"NilNode.Copy\">func (*NilNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=9556:9585#L398\">Copy</a>  </h3> <pre data-language=\"go\">func (n *NilNode) Copy() Node</pre> <h3 id=\"NilNode.String\">func (*NilNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=9454:9487#L390\">String</a>  </h3> <pre data-language=\"go\">func (n *NilNode) String() string</pre> <h3 id=\"NilNode.Type\">func (*NilNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=9243:9276#L383\">Type</a>  </h3> <pre data-language=\"go\">func (n *NilNode) Type() NodeType</pre> <h2 id=\"Node\">type Node  </h2> <pre data-language=\"go\">type Node interface {\n        Type() NodeType\n        String() string\n        // Copy does a deep copy of the Node and all its components.\n        // To avoid type assertions, some XxxNodes also have specialized\n        // CopyXxx methods that return *XxxNode.\n        Copy() Node\n        Position() Pos // byte position of start of node in full original input string\n        // contains filtered or unexported methods\n}</pre> <p> A Node is an element in the parse tree. The interface is trivial. The interface contains an unexported method so that only types local to this package can satisfy it. </p> <h2 id=\"NodeType\">type NodeType  </h2> <pre data-language=\"go\">type NodeType int</pre> <p> NodeType identifies the type of a parse tree node. </p> <pre data-language=\"go\">const (\n        NodeText    NodeType = iota // Plain text.\n        NodeAction                  // A non-control action such as a field evaluation.\n        NodeBool                    // A boolean constant.\n        NodeChain                   // A sequence of field accesses.\n        NodeCommand                 // An element of a pipeline.\n        NodeDot                     // The cursor, dot.\n\n        NodeField      // A field or method name.\n        NodeIdentifier // An identifier; always a function name.\n        NodeIf         // An if action.\n        NodeList       // A list of Nodes.\n        NodeNil        // An untyped nil constant.\n        NodeNumber     // A numerical constant.\n        NodePipe       // A pipeline of commands.\n        NodeRange      // A range action.\n        NodeString     // A string constant.\n        NodeTemplate   // A template invocation action.\n        NodeVariable   // A $ variable.\n        NodeWith       // A with action.\n)</pre> <h3 id=\"NodeType.Type\">func (NodeType) <a href=\"https://golang.org/src/text/template/parse/node.go?s=1305:1338#L37\">Type</a>  </h3> <pre data-language=\"go\">func (t NodeType) Type() NodeType</pre> <p> Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes. </p> <h2 id=\"NumberNode\">type NumberNode  </h2> <pre data-language=\"go\">type NumberNode struct {\n        NodeType\n        Pos\n\n        IsInt      bool       // Number has an integral value.\n        IsUint     bool       // Number has an unsigned integral value.\n        IsFloat    bool       // Number has a floating-point value.\n        IsComplex  bool       // Number is complex.\n        Int64      int64      // The signed integer value.\n        Uint64     uint64     // The unsigned integer value.\n        Float64    float64    // The floating-point value.\n        Complex128 complex128 // The complex value.\n        Text       string     // The original textual representation from the input.\n        // contains filtered or unexported fields\n}</pre> <p> NumberNode holds a number: signed or unsigned integer, float, or complex. The value is parsed and stored under all the types that can represent the value. This simulates in a small amount of code the behavior of Go's ideal constants. </p> <h3 id=\"NumberNode.Copy\">func (*NumberNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=15708:15740#L634\">Copy</a>  </h3> <pre data-language=\"go\">func (n *NumberNode) Copy() Node</pre> <h3 id=\"NumberNode.String\">func (*NumberNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=15599:15635#L626\">String</a>  </h3> <pre data-language=\"go\">func (n *NumberNode) String() string</pre> <h2 id=\"PipeNode\">type PipeNode  </h2> <pre data-language=\"go\">type PipeNode struct {\n        NodeType\n        Pos\n\n        Line int             // The line number in the input. Deprecated: Kept for compatibility.\n        Decl []*VariableNode // Variable declarations in lexical order.\n        Cmds []*CommandNode  // The commands in lexical order.\n        // contains filtered or unexported fields\n}</pre> <p> PipeNode holds a pipeline with optional declaration </p> <h3 id=\"PipeNode.Copy\">func (*PipeNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=4991:5021#L190\">Copy</a>  </h3> <pre data-language=\"go\">func (p *PipeNode) Copy() Node</pre> <h3 id=\"PipeNode.CopyPipe\">func (*PipeNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=4691:4730#L175\">CopyPipe</a>  </h3> <pre data-language=\"go\">func (p *PipeNode) CopyPipe() *PipeNode</pre> <h3 id=\"PipeNode.String\">func (*PipeNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=4378:4412#L151\">String</a>  </h3> <pre data-language=\"go\">func (p *PipeNode) String() string</pre> <h2 id=\"Pos\">type Pos  </h2> <pre data-language=\"go\">type Pos int</pre> <p> Pos represents a byte position in the original input text from which this template was parsed. </p> <h3 id=\"Pos.Position\">func (Pos) <a href=\"https://golang.org/src/text/template/parse/node.go?s=1132:1159#L31\">Position</a>  </h3> <pre data-language=\"go\">func (p Pos) Position() Pos</pre> <h2 id=\"RangeNode\">type RangeNode  </h2> <pre data-language=\"go\">type RangeNode struct {\n        BranchNode\n}</pre> <p> RangeNode represents a {{range}} action and its commands. </p> <h3 id=\"RangeNode.Copy\">func (*RangeNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=19347:19378#L785\">Copy</a>  </h3> <pre data-language=\"go\">func (r *RangeNode) Copy() Node</pre> <h2 id=\"StringNode\">type StringNode  </h2> <pre data-language=\"go\">type StringNode struct {\n        NodeType\n        Pos\n\n        Quoted string // The original text of the string, with quotes.\n        Text   string // The string, after quote processing.\n        // contains filtered or unexported fields\n}</pre> <p> StringNode holds a string constant. The value has been \"unquoted\". </p> <h3 id=\"StringNode.Copy\">func (*StringNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=16325:16357#L661\">Copy</a>  </h3> <pre data-language=\"go\">func (s *StringNode) Copy() Node</pre> <h3 id=\"StringNode.String\">func (*StringNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=16214:16250#L653\">String</a>  </h3> <pre data-language=\"go\">func (s *StringNode) String() string</pre> <h2 id=\"TemplateNode\">type TemplateNode  </h2> <pre data-language=\"go\">type TemplateNode struct {\n        NodeType\n        Pos\n\n        Line int       // The line number in the input. Deprecated: Kept for compatibility.\n        Name string    // The name of the template (unquoted).\n        Pipe *PipeNode // The command to evaluate as dot for the template.\n        // contains filtered or unexported fields\n}</pre> <p> TemplateNode represents a {{template}} action. </p> <h3 id=\"TemplateNode.Copy\">func (*TemplateNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=20670:20704#L827\">Copy</a>  </h3> <pre data-language=\"go\">func (t *TemplateNode) Copy() Node</pre> <h3 id=\"TemplateNode.String\">func (*TemplateNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=20443:20481#L816\">String</a>  </h3> <pre data-language=\"go\">func (t *TemplateNode) String() string</pre> <h2 id=\"TextNode\">type TextNode  </h2> <pre data-language=\"go\">type TextNode struct {\n        NodeType\n        Pos\n\n        Text []byte // The text; may span newlines.\n        // contains filtered or unexported fields\n}</pre> <p> TextNode holds plain text. </p> <h3 id=\"TextNode.Copy\">func (*TextNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=3678:3708#L129\">Copy</a>  </h3> <pre data-language=\"go\">func (t *TextNode) Copy() Node</pre> <h3 id=\"TextNode.String\">func (*TextNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=3548:3582#L121\">String</a>  </h3> <pre data-language=\"go\">func (t *TextNode) String() string</pre> <h2 id=\"Tree\">type Tree  </h2> <pre data-language=\"go\">type Tree struct {\n        Name      string    // name of the template represented by the tree.\n        ParseName string    // name of the top-level template during parsing, for error messages.\n        Root      *ListNode // top-level root of the tree.\n        // contains filtered or unexported fields\n}</pre> <p> Tree is the representation of a single parsed template. </p> <h3 id=\"New\">func <a href=\"https://golang.org/src/text/template/parse/parse.go?s=3234:3294#L115\">New</a>  </h3> <pre data-language=\"go\">func New(name string, funcs ...map[string]interface{}) *Tree</pre> <p> New allocates a new parse tree with the given name. </p> <h3 id=\"Tree.Copy\">func (*Tree) <a href=\"https://golang.org/src/text/template/parse/parse.go?s=1183:1210#L25\">Copy</a>  </h3> <pre data-language=\"go\">func (t *Tree) Copy() *Tree</pre> <p> Copy returns a copy of the Tree. Any parsing state is discarded. </p> <h3 id=\"Tree.ErrorContext\">func (*Tree) <a href=\"https://golang.org/src/text/template/parse/parse.go?s=3564:3626#L125\">ErrorContext</a>  </h3> <pre data-language=\"go\">func (t *Tree) ErrorContext(n Node) (location, context string)</pre> <p> ErrorContext returns a textual representation of the location of the node in the input text. The receiver is only used when the node does not have a pointer to the tree inside, which can occur in old code. </p> <h3 id=\"Tree.Parse\">func (*Tree) <a href=\"https://golang.org/src/text/template/parse/parse.go?s=6102:6241#L219\">Parse</a>  </h3> <pre data-language=\"go\">func (t *Tree) Parse(text, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]interface{}) (tree *Tree, err error)</pre> <p> Parse parses the template definition string to construct a representation of the template for execution. If either action delimiter string is empty, the default (\"{{\" or \"}}\") is used. Embedded template definitions are added to the treeSet map. </p> <h2 id=\"VariableNode\">type VariableNode  </h2> <pre data-language=\"go\">type VariableNode struct {\n        NodeType\n        Pos\n\n        Ident []string // Variable name and fields in lexical order.\n        // contains filtered or unexported fields\n}</pre> <p> VariableNode holds a list of variable names, possibly with chained field accesses. The dollar sign is part of the (first) name. </p> <h3 id=\"VariableNode.Copy\">func (*VariableNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=8298:8332#L338\">Copy</a>  </h3> <pre data-language=\"go\">func (v *VariableNode) Copy() Node</pre> <h3 id=\"VariableNode.String\">func (*VariableNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=8109:8147#L323\">String</a>  </h3> <pre data-language=\"go\">func (v *VariableNode) String() string</pre> <h2 id=\"WithNode\">type WithNode  </h2> <pre data-language=\"go\">type WithNode struct {\n        BranchNode\n}</pre> <p> WithNode represents a {{with}} action and its commands. </p> <h3 id=\"WithNode.Copy\">func (*WithNode) <a href=\"https://golang.org/src/text/template/parse/node.go?s=19801:19831#L798\">Copy</a>  </h3> <pre data-language=\"go\">func (w *WithNode) Copy() Node</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/text/template/parse/\" class=\"_attribution-link\">https://golang.org/pkg/text/template/parse/</a>\n  </p>\n</div>\n","text/template/index":"<h1>Package template</h1>     <ul id=\"short-nav\">\n<li><code>import \"text/template\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package template implements data-driven templates for generating textual output. </p> <p> To generate HTML output, see package html/template, which has the same interface as this package but automatically secures HTML output against certain attacks. </p> <p> Templates are executed by applying them to a data structure. Annotations in the template refer to elements of the data structure (typically a field of a struct or a key in a map) to control execution and derive values to be displayed. Execution of the template walks the structure and sets the cursor, represented by a period '.' and called \"dot\", to the value at the current location in the structure as execution proceeds. </p> <p> The input text for a template is UTF-8-encoded text in any format. \"Actions\"--data evaluations or control structures--are delimited by \"{{\" and \"}}\"; all text outside actions is copied to the output unchanged. Except for raw strings, actions may not span newlines, although comments can. </p> <p> Once parsed, a template may be executed safely in parallel. </p> <p> Here is a trivial example that prints \"17 items are made of wool\". </p> <pre data-language=\"go\">type Inventory struct {\n\tMaterial string\n\tCount    uint\n}\nsweaters := Inventory{\"wool\", 17}\ntmpl, err := template.New(\"test\").Parse(\"{{.Count}} items are made of {{.Material}}\")\nif err != nil { panic(err) }\nerr = tmpl.Execute(os.Stdout, sweaters)\nif err != nil { panic(err) }\n</pre> <p> More intricate examples appear below. </p> <h3 id=\"hdr-Text_and_spaces\">Text and spaces</h3> <p> By default, all text between actions is copied verbatim when the template is executed. For example, the string \" items are made of \" in the example above appears on standard output when the program is run. </p> <p> However, to aid in formatting template source code, if an action's left delimiter (by default \"{{\") is followed immediately by a minus sign and ASCII space character (\"{{- \"), all trailing white space is trimmed from the immediately preceding text. Similarly, if the right delimiter (\"}}\") is preceded by a space and minus sign (\" -}}\"), all leading white space is trimmed from the immediately following text. In these trim markers, the ASCII space must be present; \"{{-3}}\" parses as an action containing the number -3. </p> <p> For instance, when executing the template whose source is </p> <pre data-language=\"go\">\"{{23 -}} &lt; {{- 45}}\"\n</pre> <p> the generated output would be </p> <pre data-language=\"go\">\"23&lt;45\"\n</pre> <p> For this trimming, the definition of white space characters is the same as in Go: space, horizontal tab, carriage return, and newline. </p> <h3 id=\"hdr-Actions\">Actions</h3> <p> Here is the list of actions. \"Arguments\" and \"pipelines\" are evaluations of data, defined in detail in the corresponding sections that follow. </p> <pre data-language=\"go\">{{/* a comment */}}\n\tA comment; discarded. May contain newlines.\n\tComments do not nest and must start and end at the\n\tdelimiters, as shown here.\n\n{{pipeline}}\n\tThe default textual representation (the same as would be\n\tprinted by fmt.Print) of the value of the pipeline is copied\n\tto the output.\n\n{{if pipeline}} T1 {{end}}\n\tIf the value of the pipeline is empty, no output is generated;\n\totherwise, T1 is executed.  The empty values are false, 0, any\n\tnil pointer or interface value, and any array, slice, map, or\n\tstring of length zero.\n\tDot is unaffected.\n\n{{if pipeline}} T1 {{else}} T0 {{end}}\n\tIf the value of the pipeline is empty, T0 is executed;\n\totherwise, T1 is executed.  Dot is unaffected.\n\n{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}\n\tTo simplify the appearance of if-else chains, the else action\n\tof an if may include another if directly; the effect is exactly\n\tthe same as writing\n\t\t{{if pipeline}} T1 {{else}}{{if pipeline}} T0 {{end}}{{end}}\n\n{{range pipeline}} T1 {{end}}\n\tThe value of the pipeline must be an array, slice, map, or channel.\n\tIf the value of the pipeline has length zero, nothing is output;\n\totherwise, dot is set to the successive elements of the array,\n\tslice, or map and T1 is executed. If the value is a map and the\n\tkeys are of basic type with a defined order (\"comparable\"), the\n\telements will be visited in sorted key order.\n\n{{range pipeline}} T1 {{else}} T0 {{end}}\n\tThe value of the pipeline must be an array, slice, map, or channel.\n\tIf the value of the pipeline has length zero, dot is unaffected and\n\tT0 is executed; otherwise, dot is set to the successive elements\n\tof the array, slice, or map and T1 is executed.\n\n{{template \"name\"}}\n\tThe template with the specified name is executed with nil data.\n\n{{template \"name\" pipeline}}\n\tThe template with the specified name is executed with dot set\n\tto the value of the pipeline.\n\n{{block \"name\" pipeline}} T1 {{end}}\n\tA block is shorthand for defining a template\n\t\t{{define \"name\"}} T1 {{end}}\n\tand then executing it in place\n\t\t{{template \"name\" .}}\n\tThe typical use is to define a set of root templates that are\n\tthen customized by redefining the block templates within.\n\n{{with pipeline}} T1 {{end}}\n\tIf the value of the pipeline is empty, no output is generated;\n\totherwise, dot is set to the value of the pipeline and T1 is\n\texecuted.\n\n{{with pipeline}} T1 {{else}} T0 {{end}}\n\tIf the value of the pipeline is empty, dot is unaffected and T0\n\tis executed; otherwise, dot is set to the value of the pipeline\n\tand T1 is executed.\n</pre> <h3 id=\"hdr-Arguments\">Arguments</h3> <p> An argument is a simple value, denoted by one of the following. </p> <pre data-language=\"go\">- A boolean, string, character, integer, floating-point, imaginary\n  or complex constant in Go syntax. These behave like Go's untyped\n  constants.\n- The keyword nil, representing an untyped Go nil.\n- The character '.' (period):\n\t.\n  The result is the value of dot.\n- A variable name, which is a (possibly empty) alphanumeric string\n  preceded by a dollar sign, such as\n\t$piOver2\n  or\n\t$\n  The result is the value of the variable.\n  Variables are described below.\n- The name of a field of the data, which must be a struct, preceded\n  by a period, such as\n\t.Field\n  The result is the value of the field. Field invocations may be\n  chained:\n    .Field1.Field2\n  Fields can also be evaluated on variables, including chaining:\n    $x.Field1.Field2\n- The name of a key of the data, which must be a map, preceded\n  by a period, such as\n\t.Key\n  The result is the map element value indexed by the key.\n  Key invocations may be chained and combined with fields to any\n  depth:\n    .Field1.Key1.Field2.Key2\n  Although the key must be an alphanumeric identifier, unlike with\n  field names they do not need to start with an upper case letter.\n  Keys can also be evaluated on variables, including chaining:\n    $x.key1.key2\n- The name of a niladic method of the data, preceded by a period,\n  such as\n\t.Method\n  The result is the value of invoking the method with dot as the\n  receiver, dot.Method(). Such a method must have one return value (of\n  any type) or two return values, the second of which is an error.\n  If it has two and the returned error is non-nil, execution terminates\n  and an error is returned to the caller as the value of Execute.\n  Method invocations may be chained and combined with fields and keys\n  to any depth:\n    .Field1.Key1.Method1.Field2.Key2.Method2\n  Methods can also be evaluated on variables, including chaining:\n    $x.Method1.Field\n- The name of a niladic function, such as\n\tfun\n  The result is the value of invoking the function, fun(). The return\n  types and values behave as in methods. Functions and function\n  names are described below.\n- A parenthesized instance of one the above, for grouping. The result\n  may be accessed by a field or map key invocation.\n\tprint (.F1 arg1) (.F2 arg2)\n\t(.StructValuedMethod \"arg\").Field\n</pre> <p> Arguments may evaluate to any type; if they are pointers the implementation automatically indirects to the base type when required. If an evaluation yields a function value, such as a function-valued field of a struct, the function is not invoked automatically, but it can be used as a truth value for an if action and the like. To invoke it, use the call function, defined below. </p> <h3 id=\"hdr-Pipelines\">Pipelines</h3> <p> A pipeline is a possibly chained sequence of \"commands\". A command is a simple value (argument) or a function or method call, possibly with multiple arguments: </p> <pre data-language=\"go\">Argument\n\tThe result is the value of evaluating the argument.\n.Method [Argument...]\n\tThe method can be alone or the last element of a chain but,\n\tunlike methods in the middle of a chain, it can take arguments.\n\tThe result is the value of calling the method with the\n\targuments:\n\t\tdot.Method(Argument1, etc.)\nfunctionName [Argument...]\n\tThe result is the value of calling the function associated\n\twith the name:\n\t\tfunction(Argument1, etc.)\n\tFunctions and function names are described below.\n</pre> <p> A pipeline may be \"chained\" by separating a sequence of commands with pipeline characters '|'. In a chained pipeline, the result of each command is passed as the last argument of the following command. The output of the final command in the pipeline is the value of the pipeline. </p> <p> The output of a command will be either one value or two values, the second of which has type error. If that second value is present and evaluates to non-nil, execution terminates and the error is returned to the caller of Execute. </p> <h3 id=\"hdr-Variables\">Variables</h3> <p> A pipeline inside an action may initialize a variable to capture the result. The initialization has syntax </p> <pre data-language=\"go\">$variable := pipeline\n</pre> <p> where $variable is the name of the variable. An action that declares a variable produces no output. </p> <p> If a \"range\" action initializes a variable, the variable is set to the successive elements of the iteration. Also, a \"range\" may declare two variables, separated by a comma: </p> <pre data-language=\"go\">range $index, $element := pipeline\n</pre> <p> in which case $index and $element are set to the successive values of the array/slice index or map key and element, respectively. Note that if there is only one variable, it is assigned the element; this is opposite to the convention in Go range clauses. </p> <p> A variable's scope extends to the \"end\" action of the control structure (\"if\", \"with\", or \"range\") in which it is declared, or to the end of the template if there is no such control structure. A template invocation does not inherit variables from the point of its invocation. </p> <p> When execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot. </p> <h3 id=\"hdr-Examples\">Examples</h3> <p> Here are some example one-line templates demonstrating pipelines and variables. All produce the quoted word \"output\": </p> <pre data-language=\"go\">{{\"\\\"output\\\"\"}}\n\tA string constant.\n{{`\"output\"`}}\n\tA raw string constant.\n{{printf \"%q\" \"output\"}}\n\tA function call.\n{{\"output\" | printf \"%q\"}}\n\tA function call whose final argument comes from the previous\n\tcommand.\n{{printf \"%q\" (print \"out\" \"put\")}}\n\tA parenthesized argument.\n{{\"put\" | printf \"%s%s\" \"out\" | printf \"%q\"}}\n\tA more elaborate call.\n{{\"output\" | printf \"%s\" | printf \"%q\"}}\n\tA longer chain.\n{{with \"output\"}}{{printf \"%q\" .}}{{end}}\n\tA with action using dot.\n{{with $x := \"output\" | printf \"%q\"}}{{$x}}{{end}}\n\tA with action that creates and uses a variable.\n{{with $x := \"output\"}}{{printf \"%q\" $x}}{{end}}\n\tA with action that uses the variable in another action.\n{{with $x := \"output\"}}{{$x | printf \"%q\"}}{{end}}\n\tThe same, but pipelined.\n</pre> <h3 id=\"hdr-Functions\">Functions</h3> <p> During execution functions are found in two function maps: first in the template, then in the global function map. By default, no functions are defined in the template but the Funcs method can be used to add them. </p> <p> Predefined global functions are named as follows. </p> <pre data-language=\"go\">and\n\tReturns the boolean AND of its arguments by returning the\n\tfirst empty argument or the last argument, that is,\n\t\"and x y\" behaves as \"if x then y else x\". All the\n\targuments are evaluated.\ncall\n\tReturns the result of calling the first argument, which\n\tmust be a function, with the remaining arguments as parameters.\n\tThus \"call .X.Y 1 2\" is, in Go notation, dot.X.Y(1, 2) where\n\tY is a func-valued field, map entry, or the like.\n\tThe first argument must be the result of an evaluation\n\tthat yields a value of function type (as distinct from\n\ta predefined function such as print). The function must\n\treturn either one or two result values, the second of which\n\tis of type error. If the arguments don't match the function\n\tor the returned error value is non-nil, execution stops.\nhtml\n\tReturns the escaped HTML equivalent of the textual\n\trepresentation of its arguments.\nindex\n\tReturns the result of indexing its first argument by the\n\tfollowing arguments. Thus \"index x 1 2 3\" is, in Go syntax,\n\tx[1][2][3]. Each indexed item must be a map, slice, or array.\njs\n\tReturns the escaped JavaScript equivalent of the textual\n\trepresentation of its arguments.\nlen\n\tReturns the integer length of its argument.\nnot\n\tReturns the boolean negation of its single argument.\nor\n\tReturns the boolean OR of its arguments by returning the\n\tfirst non-empty argument or the last argument, that is,\n\t\"or x y\" behaves as \"if x then x else y\". All the\n\targuments are evaluated.\nprint\n\tAn alias for fmt.Sprint\nprintf\n\tAn alias for fmt.Sprintf\nprintln\n\tAn alias for fmt.Sprintln\nurlquery\n\tReturns the escaped value of the textual representation of\n\tits arguments in a form suitable for embedding in a URL query.\n</pre> <p> The boolean functions take any zero value to be false and a non-zero value to be true. </p> <p> There is also a set of binary comparison operators defined as functions: </p> <pre data-language=\"go\">eq\n\tReturns the boolean truth of arg1 == arg2\nne\n\tReturns the boolean truth of arg1 != arg2\nlt\n\tReturns the boolean truth of arg1 &lt; arg2\nle\n\tReturns the boolean truth of arg1 &lt;= arg2\ngt\n\tReturns the boolean truth of arg1 &gt; arg2\nge\n\tReturns the boolean truth of arg1 &gt;= arg2\n</pre> <p> For simpler multi-way equality tests, eq (only) accepts two or more arguments and compares the second and subsequent to the first, returning in effect </p> <pre data-language=\"go\">arg1==arg2 || arg1==arg3 || arg1==arg4 ...\n</pre> <p> (Unlike with || in Go, however, eq is a function call and all the arguments will be evaluated.) </p> <p> The comparison functions work on basic types only (or named basic types, such as \"type Celsius float32\"). They implement the Go rules for comparison of values, except that size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on. </p> <h3 id=\"hdr-Associated_templates\">Associated templates</h3> <p> Each template is named by a string specified when it is created. Also, each template is associated with zero or more other templates that it may invoke by name; such associations are transitive and form a name space of templates. </p> <p> A template may use a template invocation to instantiate another associated template; see the explanation of the \"template\" action above. The name must be that of a template associated with the template that contains the invocation. </p> <h3 id=\"hdr-Nested_template_definitions\">Nested template definitions</h3> <p> When parsing a template, another template may be defined and associated with the template being parsed. Template definitions must appear at the top level of the template, much like global variables in a Go program. </p> <p> The syntax of such definitions is to surround each template declaration with a \"define\" and \"end\" action. </p> <p> The define action names the template being created by providing a string constant. Here is a simple example: </p> <pre data-language=\"go\">`{{define \"T1\"}}ONE{{end}}\n{{define \"T2\"}}TWO{{end}}\n{{define \"T3\"}}{{template \"T1\"}} {{template \"T2\"}}{{end}}\n{{template \"T3\"}}`\n</pre> <p> This defines two templates, T1 and T2, and a third T3 that invokes the other two when it is executed. Finally it invokes T3. If executed this template will produce the text </p> <pre data-language=\"go\">ONE TWO\n</pre> <p> By construction, a template may reside in only one association. If it's necessary to have a template addressable from multiple associations, the template definition must be parsed multiple times to create distinct *Template values, or must be copied with the Clone or AddParseTree method. </p> <p> Parse may be called multiple times to assemble the various associated templates; see the ParseFiles and ParseGlob functions and methods for simple ways to parse related templates stored in files. </p> <p> A template may be executed directly or through ExecuteTemplate, which executes an associated template identified by name. To invoke our example above, we might write, </p> <pre data-language=\"go\">err := tmpl.Execute(os.Stdout, \"no data needed\")\nif err != nil {\n\tlog.Fatalf(\"execution failed: %s\", err)\n}\n</pre> <p> or to invoke a particular template explicitly by name, </p> <pre data-language=\"go\">err := tmpl.ExecuteTemplate(os.Stdout, \"T2\", \"no data needed\")\nif err != nil {\n\tlog.Fatalf(\"execution failed: %s\", err)\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#HTMLEscape\">func HTMLEscape(w io.Writer, b []byte)</a></li>\n<li><a href=\"#HTMLEscapeString\">func HTMLEscapeString(s string) string</a></li>\n<li><a href=\"#HTMLEscaper\">func HTMLEscaper(args ...interface{}) string</a></li>\n<li><a href=\"#IsTrue\">func IsTrue(val interface{}) (truth, ok bool)</a></li>\n<li><a href=\"#JSEscape\">func JSEscape(w io.Writer, b []byte)</a></li>\n<li><a href=\"#JSEscapeString\">func JSEscapeString(s string) string</a></li>\n<li><a href=\"#JSEscaper\">func JSEscaper(args ...interface{}) string</a></li>\n<li><a href=\"#URLQueryEscaper\">func URLQueryEscaper(args ...interface{}) string</a></li>\n<li><a href=\"#ExecError\">type ExecError</a></li>\n<li> <a href=\"#ExecError.Error\">func (e ExecError) Error() string</a>\n</li>\n<li><a href=\"#FuncMap\">type FuncMap</a></li>\n<li><a href=\"#Template\">type Template</a></li>\n<li> <a href=\"#Must\">func Must(t *Template, err error) *Template</a>\n</li>\n<li> <a href=\"#New\">func New(name string) *Template</a>\n</li>\n<li> <a href=\"#ParseFiles\">func ParseFiles(filenames ...string) (*Template, error)</a>\n</li>\n<li> <a href=\"#ParseGlob\">func ParseGlob(pattern string) (*Template, error)</a>\n</li>\n<li> <a href=\"#Template.AddParseTree\">func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)</a>\n</li>\n<li> <a href=\"#Template.Clone\">func (t *Template) Clone() (*Template, error)</a>\n</li>\n<li> <a href=\"#Template.DefinedTemplates\">func (t *Template) DefinedTemplates() string</a>\n</li>\n<li> <a href=\"#Template.Delims\">func (t *Template) Delims(left, right string) *Template</a>\n</li>\n<li> <a href=\"#Template.Execute\">func (t *Template) Execute(wr io.Writer, data interface{}) error</a>\n</li>\n<li> <a href=\"#Template.ExecuteTemplate\">func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error</a>\n</li>\n<li> <a href=\"#Template.Funcs\">func (t *Template) Funcs(funcMap FuncMap) *Template</a>\n</li>\n<li> <a href=\"#Template.Lookup\">func (t *Template) Lookup(name string) *Template</a>\n</li>\n<li> <a href=\"#Template.Name\">func (t *Template) Name() string</a>\n</li>\n<li> <a href=\"#Template.New\">func (t *Template) New(name string) *Template</a>\n</li>\n<li> <a href=\"#Template.Option\">func (t *Template) Option(opt ...string) *Template</a>\n</li>\n<li> <a href=\"#Template.Parse\">func (t *Template) Parse(text string) (*Template, error)</a>\n</li>\n<li> <a href=\"#Template.ParseFiles\">func (t *Template) ParseFiles(filenames ...string) (*Template, error)</a>\n</li>\n<li> <a href=\"#Template.ParseGlob\">func (t *Template) ParseGlob(pattern string) (*Template, error)</a>\n</li>\n<li> <a href=\"#Template.Templates\">func (t *Template) Templates() []*Template</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_Template\">Template</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Template_block\">Template (Block)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Template_func\">Template (Func)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Template_glob\">Template (Glob)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Template_helpers\">Template (Helpers)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Template_share\">Template (Share)</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/text/template/doc.go\">doc.go</a> <a href=\"https://golang.org/src/text/template/exec.go\">exec.go</a> <a href=\"https://golang.org/src/text/template/funcs.go\">funcs.go</a> <a href=\"https://golang.org/src/text/template/helper.go\">helper.go</a> <a href=\"https://golang.org/src/text/template/option.go\">option.go</a> <a href=\"https://golang.org/src/text/template/template.go\">template.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"HTMLEscape\">func HTMLEscape  </h2> <pre data-language=\"go\">func HTMLEscape(w io.Writer, b []byte)</pre> <p> HTMLEscape writes to w the escaped HTML equivalent of the plain text data b. </p> <h2 id=\"HTMLEscapeString\">func HTMLEscapeString  </h2> <pre data-language=\"go\">func HTMLEscapeString(s string) string</pre> <p> HTMLEscapeString returns the escaped HTML equivalent of the plain text data s. </p> <h2 id=\"HTMLEscaper\">func HTMLEscaper  </h2> <pre data-language=\"go\">func HTMLEscaper(args ...interface{}) string</pre> <p> HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments. </p> <h2 id=\"IsTrue\">func IsTrue  </h2> <pre data-language=\"go\">func IsTrue(val interface{}) (truth, ok bool)</pre> <p> IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions. </p> <h2 id=\"JSEscape\">func JSEscape  </h2> <pre data-language=\"go\">func JSEscape(w io.Writer, b []byte)</pre> <p> JSEscape writes to w the escaped JavaScript equivalent of the plain text data b. </p> <h2 id=\"JSEscapeString\">func JSEscapeString  </h2> <pre data-language=\"go\">func JSEscapeString(s string) string</pre> <p> JSEscapeString returns the escaped JavaScript equivalent of the plain text data s. </p> <h2 id=\"JSEscaper\">func JSEscaper  </h2> <pre data-language=\"go\">func JSEscaper(args ...interface{}) string</pre> <p> JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments. </p> <h2 id=\"URLQueryEscaper\">func URLQueryEscaper  </h2> <pre data-language=\"go\">func URLQueryEscaper(args ...interface{}) string</pre> <p> URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query. </p> <h2 id=\"ExecError\">type ExecError  </h2> <pre data-language=\"go\">type ExecError struct {\n        Name string // Name of template.\n        Err  error  // Pre-formatted error.\n}</pre> <p> ExecError is the custom error type returned when Execute has an error evaluating its template. (If a write error occurs, the actual error is returned; it will not be of type ExecError.) </p> <h3 id=\"ExecError.Error\">func (ExecError) <a href=\"https://golang.org/src/text/template/exec.go?s=2733:2766#L90\">Error</a>  </h3> <pre data-language=\"go\">func (e ExecError) Error() string</pre> <h2 id=\"FuncMap\">type FuncMap  </h2> <pre data-language=\"go\">type FuncMap map[string]interface{}</pre> <p> FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) return value evaluates to non-nil during execution, execution terminates and Execute returns that error. </p> <h2 id=\"Template\">type Template  </h2> <pre data-language=\"go\">type Template struct {\n        *parse.Tree\n        // contains filtered or unexported fields\n}</pre> <p> Template is the representation of a parsed template. The *parse.Tree field is exported only for use by html/template and should be treated as unexported by all other clients. </p> <div id=\"example_Template\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"text/template\"\n)\n\nfunc main() {\n\t// Define a template.\n\tconst letter = `\nDear {{.Name}},\n{{if .Attended}}\nIt was a pleasure to see you at the wedding.\n{{- else}}\nIt is a shame you couldn't make it to the wedding.\n{{- end}}\n{{with .Gift -}}\nThank you for the lovely {{.}}.\n{{end}}\nBest wishes,\nJosie\n`\n\n\t// Prepare some data to insert into the template.\n\ttype Recipient struct {\n\t\tName, Gift string\n\t\tAttended   bool\n\t}\n\tvar recipients = []Recipient{\n\t\t{\"Aunt Mildred\", \"bone china tea set\", true},\n\t\t{\"Uncle John\", \"moleskin pants\", false},\n\t\t{\"Cousin Rodney\", \"\", false},\n\t}\n\n\t// Create a new template and parse the letter into it.\n\tt := template.Must(template.New(\"letter\").Parse(letter))\n\n\t// Execute the template for each recipient.\n\tfor _, r := range recipients {\n\t\terr := t.Execute(os.Stdout, r)\n\t\tif err != nil {\n\t\t\tlog.Println(\"executing template:\", err)\n\t\t}\n\t}\n\n}\n</pre> </div> </div> <div id=\"example_Template_block\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Block)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"text/template\"\n)\n\nfunc main() {\n\tconst (\n\t\tmaster  = `Names:{{block \"list\" .}}{{\"\\n\"}}{{range .}}{{println \"-\" .}}{{end}}{{end}}`\n\t\toverlay = `{{define \"list\"}} {{join . \", \"}}{{end}} `\n\t)\n\tvar (\n\t\tfuncs     = template.FuncMap{\"join\": strings.Join}\n\t\tguardians = []string{\"Gamora\", \"Groot\", \"Nebula\", \"Rocket\", \"Star-Lord\"}\n\t)\n\tmasterTmpl, err := template.New(\"master\").Funcs(funcs).Parse(master)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\toverlayTmpl, err := template.Must(masterTmpl.Clone()).Parse(overlay)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := masterTmpl.Execute(os.Stdout, guardians); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := overlayTmpl.Execute(os.Stdout, guardians); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n</pre> </div> </div> <div id=\"example_Template_func\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Func)</h2> <p>This example demonstrates a custom function to process template text. It installs the strings.Title function and uses it to Make Title Text Look Good In Our Template's Output. </p> <pre class=\"play\">package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"text/template\"\n)\n\nfunc main() {\n\t// First we create a FuncMap with which to register the function.\n\tfuncMap := template.FuncMap{\n\t\t// The name \"title\" is what the function will be called in the template text.\n\t\t\"title\": strings.Title,\n\t}\n\n\t// A simple template definition to test our function.\n\t// We print the input text several ways:\n\t// - the original\n\t// - title-cased\n\t// - title-cased and then printed with %q\n\t// - printed with %q and then title-cased.\n\tconst templateText = `\nInput: {{printf \"%q\" .}}\nOutput 0: {{title .}}\nOutput 1: {{title . | printf \"%q\"}}\nOutput 2: {{printf \"%q\" . | title}}\n`\n\n\t// Create a template, add the function map, and parse the text.\n\ttmpl, err := template.New(\"titleTest\").Funcs(funcMap).Parse(templateText)\n\tif err != nil {\n\t\tlog.Fatalf(\"parsing: %s\", err)\n\t}\n\n\t// Run the template to verify the output.\n\terr = tmpl.Execute(os.Stdout, \"the go programming language\")\n\tif err != nil {\n\t\tlog.Fatalf(\"execution: %s\", err)\n\t}\n\n}\n</pre> </div> </div> <div id=\"example_Template_glob\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Glob)</h2> <p>Here we demonstrate loading a set of templates from a directory. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// Here we create a temporary directory and populate it with our sample\n    // template definition files; usually the template files would already\n    // exist in some location known to the program.\n    dir := createTestDir([]templateFile{\n            // T0.tmpl is a plain template file that just invokes T1.\n            {\"T0.tmpl\", `T0 invokes T1: ({{template \"T1\"}})`},\n            // T1.tmpl defines a template, T1 that invokes T2.\n            {\"T1.tmpl\", `{{define \"T1\"}}T1 invokes T2: ({{template \"T2\"}}){{end}}`},\n            // T2.tmpl defines a template T2.\n            {\"T2.tmpl\", `{{define \"T2\"}}This is T2{{end}}`},\n    })\n    // Clean up after the test; another quirk of running as an example.\n    defer os.RemoveAll(dir)\n\n    // pattern is the glob pattern used to find all the template files.\n    pattern := filepath.Join(dir, \"*.tmpl\")\n\n    // Here starts the example proper.\n    // T0.tmpl is the first name matched, so it becomes the starting template,\n    // the value returned by ParseGlob.\n    tmpl := template.Must(template.ParseGlob(pattern))\n\n    err := tmpl.Execute(os.Stdout, nil)\n    if err != nil {\n            log.Fatalf(\"template execution: %s\", err)\n    }\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">T0 invokes T1: (T1 invokes T2: (This is T2))\n</pre> </div> </div> <div id=\"example_Template_helpers\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Helpers)</h2> <p>This example demonstrates one way to share some templates and use them in different contexts. In this variant we add multiple driver templates by hand to an existing bundle of templates. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// Here we create a temporary directory and populate it with our sample\n    // template definition files; usually the template files would already\n    // exist in some location known to the program.\n    dir := createTestDir([]templateFile{\n            // T1.tmpl defines a template, T1 that invokes T2.\n            {\"T1.tmpl\", `{{define \"T1\"}}T1 invokes T2: ({{template \"T2\"}}){{end}}`},\n            // T2.tmpl defines a template T2.\n            {\"T2.tmpl\", `{{define \"T2\"}}This is T2{{end}}`},\n    })\n    // Clean up after the test; another quirk of running as an example.\n    defer os.RemoveAll(dir)\n\n    // pattern is the glob pattern used to find all the template files.\n    pattern := filepath.Join(dir, \"*.tmpl\")\n\n    // Here starts the example proper.\n    // Load the helpers.\n    templates := template.Must(template.ParseGlob(pattern))\n    // Add one driver template to the bunch; we do this with an explicit template definition.\n    _, err := templates.Parse(\"{{define `driver1`}}Driver 1 calls T1: ({{template `T1`}})\\n{{end}}\")\n    if err != nil {\n            log.Fatal(\"parsing driver1: \", err)\n    }\n    // Add another driver template.\n    _, err = templates.Parse(\"{{define `driver2`}}Driver 2 calls T2: ({{template `T2`}})\\n{{end}}\")\n    if err != nil {\n            log.Fatal(\"parsing driver2: \", err)\n    }\n    // We load all the templates before execution. This package does not require\n    // that behavior but html/template's escaping does, so it's a good habit.\n    err = templates.ExecuteTemplate(os.Stdout, \"driver1\", nil)\n    if err != nil {\n            log.Fatalf(\"driver1 execution: %s\", err)\n    }\n    err = templates.ExecuteTemplate(os.Stdout, \"driver2\", nil)\n    if err != nil {\n            log.Fatalf(\"driver2 execution: %s\", err)\n    }\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">Driver 1 calls T1: (T1 invokes T2: (This is T2))\nDriver 2 calls T2: (This is T2)\n</pre> </div> </div> <div id=\"example_Template_share\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Share)</h2> <p>This example demonstrates how to use one group of driver templates with distinct sets of helper templates. </p> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// Here we create a temporary directory and populate it with our sample\n    // template definition files; usually the template files would already\n    // exist in some location known to the program.\n    dir := createTestDir([]templateFile{\n            // T0.tmpl is a plain template file that just invokes T1.\n            {\"T0.tmpl\", \"T0 ({{.}} version) invokes T1: ({{template `T1`}})\\n\"},\n            // T1.tmpl defines a template, T1 that invokes T2. Note T2 is not defined\n            {\"T1.tmpl\", `{{define \"T1\"}}T1 invokes T2: ({{template \"T2\"}}){{end}}`},\n    })\n    // Clean up after the test; another quirk of running as an example.\n    defer os.RemoveAll(dir)\n\n    // pattern is the glob pattern used to find all the template files.\n    pattern := filepath.Join(dir, \"*.tmpl\")\n\n    // Here starts the example proper.\n    // Load the drivers.\n    drivers := template.Must(template.ParseGlob(pattern))\n\n    // We must define an implementation of the T2 template. First we clone\n    // the drivers, then add a definition of T2 to the template name space.\n\n    // 1. Clone the helper set to create a new name space from which to run them.\n    first, err := drivers.Clone()\n    if err != nil {\n            log.Fatal(\"cloning helpers: \", err)\n    }\n    // 2. Define T2, version A, and parse it.\n    _, err = first.Parse(\"{{define `T2`}}T2, version A{{end}}\")\n    if err != nil {\n            log.Fatal(\"parsing T2: \", err)\n    }\n\n    // Now repeat the whole thing, using a different version of T2.\n    // 1. Clone the drivers.\n    second, err := drivers.Clone()\n    if err != nil {\n            log.Fatal(\"cloning drivers: \", err)\n    }\n    // 2. Define T2, version B, and parse it.\n    _, err = second.Parse(\"{{define `T2`}}T2, version B{{end}}\")\n    if err != nil {\n            log.Fatal(\"parsing T2: \", err)\n    }\n\n    // Execute the templates in the reverse order to verify the\n    // first is unaffected by the second.\n    err = second.ExecuteTemplate(os.Stdout, \"T0.tmpl\", \"second\")\n    if err != nil {\n            log.Fatalf(\"second execution: %s\", err)\n    }\n    err = first.ExecuteTemplate(os.Stdout, \"T0.tmpl\", \"first\")\n    if err != nil {\n            log.Fatalf(\"first: execution: %s\", err)\n    }\n\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">T0 (second version) invokes T1: (T1 invokes T2: (T2, version B))\nT0 (first version) invokes T1: (T1 invokes T2: (T2, version A))\n</pre> </div> </div> <h3 id=\"Must\">func <a href=\"https://golang.org/src/text/template/helper.go?s=576:619#L11\">Must</a>  </h3> <pre data-language=\"go\">func Must(t *Template, err error) *Template</pre> <p> Must is a helper that wraps a call to a function returning (*Template, error) and panics if the error is non-nil. It is intended for use in variable initializations such as </p> <pre data-language=\"go\">var t = template.Must(template.New(\"name\").Parse(\"text\"))\n</pre> <h3 id=\"New\">func <a href=\"https://golang.org/src/text/template/template.go?s=1022:1053#L27\">New</a>  </h3> <pre data-language=\"go\">func New(name string) *Template</pre> <p> New allocates a new, undefined template with the given name. </p> <h3 id=\"ParseFiles\">func <a href=\"https://golang.org/src/text/template/helper.go?s=1224:1279#L27\">ParseFiles</a>  </h3> <pre data-language=\"go\">func ParseFiles(filenames ...string) (*Template, error)</pre> <p> ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the base name and parsed contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil. </p> <p> When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template named \"foo\", while \"a/foo\" is unavailable. </p> <h3 id=\"ParseGlob\">func <a href=\"https://golang.org/src/text/template/helper.go?s=3728:3777#L92\">ParseGlob</a>  </h3> <pre data-language=\"go\">func ParseGlob(pattern string) (*Template, error)</pre> <p> ParseGlob creates a new Template and parses the template definitions from the files identified by the pattern, which must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling ParseFiles with the list of files matched by the pattern. </p> <p> When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. </p> <h3 id=\"Template.AddParseTree\">func (*Template) <a href=\"https://golang.org/src/text/template/template.go?s=3255:3336#L110\">AddParseTree</a>  </h3> <pre data-language=\"go\">func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)</pre> <p> AddParseTree adds parse tree for template with given name and associates it with t. If the template does not already exist, it will create a new one. If the template does exist, it will be replaced. </p> <h3 id=\"Template.Clone\">func (*Template) <a href=\"https://golang.org/src/text/template/template.go?s=2306:2351#L71\">Clone</a>  </h3> <pre data-language=\"go\">func (t *Template) Clone() (*Template, error)</pre> <p> Clone returns a duplicate of the template, including all associated templates. The actual representation is not copied, but the name space of associated templates is, so further calls to Parse in the copy will add templates to the copy but not to the original. Clone can be used to prepare common templates and use them with variant definitions for other templates by adding the variants after the clone is made. </p> <h3 id=\"Template.DefinedTemplates\">func (*Template) <a href=\"https://golang.org/src/text/template/exec.go?s=5715:5759#L187\">DefinedTemplates</a>  </h3> <pre data-language=\"go\">func (t *Template) DefinedTemplates() string</pre> <p> DefinedTemplates returns a string listing the defined templates, prefixed by the string \"; defined templates are: \". If there are none, it returns the empty string. For generating an error message here and in html/template. </p> <h3 id=\"Template.Delims\">func (*Template) <a href=\"https://golang.org/src/text/template/template.go?s=4298:4353#L144\">Delims</a>  </h3> <pre data-language=\"go\">func (t *Template) Delims(left, right string) *Template</pre> <p> Delims sets the action delimiters to the specified strings, to be used in subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template definitions will inherit the settings. An empty delimiter stands for the corresponding default: {{ or }}. The return value is the template, so calls can be chained. </p> <h3 id=\"Template.Execute\">func (*Template) <a href=\"https://golang.org/src/text/template/exec.go?s=5006:5070#L164\">Execute</a>  </h3> <pre data-language=\"go\">func (t *Template) Execute(wr io.Writer, data interface{}) error</pre> <p> Execute applies a parsed template to the specified data object, and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel. </p> <h3 id=\"Template.ExecuteTemplate\">func (*Template) <a href=\"https://golang.org/src/text/template/exec.go?s=4394:4479#L147\">ExecuteTemplate</a>  </h3> <pre data-language=\"go\">func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error</pre> <p> ExecuteTemplate applies the template associated with t that has the given name to the specified data object and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel. </p> <h3 id=\"Template.Funcs\">func (*Template) <a href=\"https://golang.org/src/text/template/template.go?s=4769:4820#L156\">Funcs</a>  </h3> <pre data-language=\"go\">func (t *Template) Funcs(funcMap FuncMap) *Template</pre> <p> Funcs adds the elements of the argument map to the template's function map. It panics if a value in the map is not a function with appropriate return type or if the name cannot be used syntactically as a function in a template. It is legal to overwrite elements of the map. The return value is the template, so calls can be chained. </p> <h3 id=\"Template.Lookup\">func (*Template) <a href=\"https://golang.org/src/text/template/template.go?s=5120:5168#L167\">Lookup</a>  </h3> <pre data-language=\"go\">func (t *Template) Lookup(name string) *Template</pre> <p> Lookup returns the template with the given name that is associated with t. It returns nil if there is no such template or the template has no definition. </p> <h3 id=\"Template.Name\">func (*Template) <a href=\"https://golang.org/src/text/template/template.go?s=1155:1187#L36\">Name</a>  </h3> <pre data-language=\"go\">func (t *Template) Name() string</pre> <p> Name returns the name of the template. </p> <h3 id=\"Template.New\">func (*Template) <a href=\"https://golang.org/src/text/template/template.go?s=1421:1466#L43\">New</a>  </h3> <pre data-language=\"go\">func (t *Template) New(name string) *Template</pre> <p> New allocates a new, undefined template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action. </p> <h3 id=\"Template.Option\">func (*Template) <a href=\"https://golang.org/src/text/template/option.go?s=1400:1450#L32\">Option</a>  </h3> <pre data-language=\"go\">func (t *Template) Option(opt ...string) *Template</pre> <p> Option sets options for the template. Options are described by strings, either a simple string or \"key=value\". There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics. </p> <p> Known options: </p> <p> missingkey: Control the behavior during execution if a map is indexed with a key that is not present in the map. </p> <pre data-language=\"go\">\"missingkey=default\" or \"missingkey=invalid\"\n\tThe default behavior: Do nothing and continue execution.\n\tIf printed, the result of the index operation is the string\n\t\"&lt;no value&gt;\".\n\"missingkey=zero\"\n\tThe operation returns the zero value for the map type's element.\n\"missingkey=error\"\n\tExecution stops immediately with an error.\n</pre> <h3 id=\"Template.Parse\">func (*Template) <a href=\"https://golang.org/src/text/template/template.go?s=5458:5514#L177\">Parse</a>  </h3> <pre data-language=\"go\">func (t *Template) Parse(text string) (*Template, error)</pre> <p> Parse defines the template by parsing the text. Nested template definitions will be associated with the top-level template t. Parse may be called multiple times to parse definitions of templates to associate with t. </p> <h3 id=\"Template.ParseFiles\">func (*Template) <a href=\"https://golang.org/src/text/template/helper.go?s=2001:2070#L42\">ParseFiles</a>  </h3> <pre data-language=\"go\">func (t *Template) ParseFiles(filenames ...string) (*Template, error)</pre> <p> ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file. Since the templates created by ParseFiles are named by the base names of the argument files, t should usually have the name of one of the (base) names of the files. If it does not, depending on t's contents before calling ParseFiles, t.Execute may fail. In that case use t.ExecuteTemplate to execute a valid template. </p> <p> When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. </p> <h3 id=\"Template.ParseGlob\">func (*Template) <a href=\"https://golang.org/src/text/template/helper.go?s=4264:4327#L104\">ParseGlob</a>  </h3> <pre data-language=\"go\">func (t *Template) ParseGlob(pattern string) (*Template, error)</pre> <p> ParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The pattern is processed by filepath.Glob and must match at least one file. ParseGlob is equivalent to calling t.ParseFiles with the list of files matched by the pattern. </p> <p> When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. </p> <h3 id=\"Template.Templates\">func (*Template) <a href=\"https://golang.org/src/text/template/template.go?s=3742:3784#L127\">Templates</a>  </h3> <pre data-language=\"go\">func (t *Template) Templates() []*Template</pre> <p> Templates returns a slice of defined templates associated with t. </p> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"parse/index\">parse</a> </td> <td class=\"pkg-synopsis\"> Package parse builds parse trees for templates as defined by text/template and html/template. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/text/template/\" class=\"_attribution-link\">https://golang.org/pkg/text/template/</a>\n  </p>\n</div>\n","time/index":"<h1>Package time</h1>     <ul id=\"short-nav\">\n<li><code>import \"time\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package time provides functionality for measuring and displaying time. </p> <p> The calendrical calculations always assume a Gregorian calendar. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#After\">func After(d Duration) &lt;-chan Time</a></li>\n<li><a href=\"#Sleep\">func Sleep(d Duration)</a></li>\n<li><a href=\"#Tick\">func Tick(d Duration) &lt;-chan Time</a></li>\n<li><a href=\"#Duration\">type Duration</a></li>\n<li> <a href=\"#ParseDuration\">func ParseDuration(s string) (Duration, error)</a>\n</li>\n<li> <a href=\"#Since\">func Since(t Time) Duration</a>\n</li>\n<li> <a href=\"#Duration.Hours\">func (d Duration) Hours() float64</a>\n</li>\n<li> <a href=\"#Duration.Minutes\">func (d Duration) Minutes() float64</a>\n</li>\n<li> <a href=\"#Duration.Nanoseconds\">func (d Duration) Nanoseconds() int64</a>\n</li>\n<li> <a href=\"#Duration.Seconds\">func (d Duration) Seconds() float64</a>\n</li>\n<li> <a href=\"#Duration.String\">func (d Duration) String() string</a>\n</li>\n<li><a href=\"#Location\">type Location</a></li>\n<li> <a href=\"#FixedZone\">func FixedZone(name string, offset int) *Location</a>\n</li>\n<li> <a href=\"#LoadLocation\">func LoadLocation(name string) (*Location, error)</a>\n</li>\n<li> <a href=\"#Location.String\">func (l *Location) String() string</a>\n</li>\n<li><a href=\"#Month\">type Month</a></li>\n<li> <a href=\"#Month.String\">func (m Month) String() string</a>\n</li>\n<li><a href=\"#ParseError\">type ParseError</a></li>\n<li> <a href=\"#ParseError.Error\">func (e *ParseError) Error() string</a>\n</li>\n<li><a href=\"#Ticker\">type Ticker</a></li>\n<li> <a href=\"#NewTicker\">func NewTicker(d Duration) *Ticker</a>\n</li>\n<li> <a href=\"#Ticker.Stop\">func (t *Ticker) Stop()</a>\n</li>\n<li><a href=\"#Time\">type Time</a></li>\n<li> <a href=\"#Date\">func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</a>\n</li>\n<li> <a href=\"#Now\">func Now() Time</a>\n</li>\n<li> <a href=\"#Parse\">func Parse(layout, value string) (Time, error)</a>\n</li>\n<li> <a href=\"#ParseInLocation\">func ParseInLocation(layout, value string, loc *Location) (Time, error)</a>\n</li>\n<li> <a href=\"#Unix\">func Unix(sec int64, nsec int64) Time</a>\n</li>\n<li> <a href=\"#Time.Add\">func (t Time) Add(d Duration) Time</a>\n</li>\n<li> <a href=\"#Time.AddDate\">func (t Time) AddDate(years int, months int, days int) Time</a>\n</li>\n<li> <a href=\"#Time.After\">func (t Time) After(u Time) bool</a>\n</li>\n<li> <a href=\"#Time.AppendFormat\">func (t Time) AppendFormat(b []byte, layout string) []byte</a>\n</li>\n<li> <a href=\"#Time.Before\">func (t Time) Before(u Time) bool</a>\n</li>\n<li> <a href=\"#Time.Clock\">func (t Time) Clock() (hour, min, sec int)</a>\n</li>\n<li> <a href=\"#Time.Date\">func (t Time) Date() (year int, month Month, day int)</a>\n</li>\n<li> <a href=\"#Time.Day\">func (t Time) Day() int</a>\n</li>\n<li> <a href=\"#Time.Equal\">func (t Time) Equal(u Time) bool</a>\n</li>\n<li> <a href=\"#Time.Format\">func (t Time) Format(layout string) string</a>\n</li>\n<li> <a href=\"#Time.GobDecode\">func (t *Time) GobDecode(data []byte) error</a>\n</li>\n<li> <a href=\"#Time.GobEncode\">func (t Time) GobEncode() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Time.Hour\">func (t Time) Hour() int</a>\n</li>\n<li> <a href=\"#Time.ISOWeek\">func (t Time) ISOWeek() (year, week int)</a>\n</li>\n<li> <a href=\"#Time.In\">func (t Time) In(loc *Location) Time</a>\n</li>\n<li> <a href=\"#Time.IsZero\">func (t Time) IsZero() bool</a>\n</li>\n<li> <a href=\"#Time.Local\">func (t Time) Local() Time</a>\n</li>\n<li> <a href=\"#Time.Location\">func (t Time) Location() *Location</a>\n</li>\n<li> <a href=\"#Time.MarshalBinary\">func (t Time) MarshalBinary() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Time.MarshalJSON\">func (t Time) MarshalJSON() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Time.MarshalText\">func (t Time) MarshalText() ([]byte, error)</a>\n</li>\n<li> <a href=\"#Time.Minute\">func (t Time) Minute() int</a>\n</li>\n<li> <a href=\"#Time.Month\">func (t Time) Month() Month</a>\n</li>\n<li> <a href=\"#Time.Nanosecond\">func (t Time) Nanosecond() int</a>\n</li>\n<li> <a href=\"#Time.Round\">func (t Time) Round(d Duration) Time</a>\n</li>\n<li> <a href=\"#Time.Second\">func (t Time) Second() int</a>\n</li>\n<li> <a href=\"#Time.String\">func (t Time) String() string</a>\n</li>\n<li> <a href=\"#Time.Sub\">func (t Time) Sub(u Time) Duration</a>\n</li>\n<li> <a href=\"#Time.Truncate\">func (t Time) Truncate(d Duration) Time</a>\n</li>\n<li> <a href=\"#Time.UTC\">func (t Time) UTC() Time</a>\n</li>\n<li> <a href=\"#Time.Unix\">func (t Time) Unix() int64</a>\n</li>\n<li> <a href=\"#Time.UnixNano\">func (t Time) UnixNano() int64</a>\n</li>\n<li> <a href=\"#Time.UnmarshalBinary\">func (t *Time) UnmarshalBinary(data []byte) error</a>\n</li>\n<li> <a href=\"#Time.UnmarshalJSON\">func (t *Time) UnmarshalJSON(data []byte) error</a>\n</li>\n<li> <a href=\"#Time.UnmarshalText\">func (t *Time) UnmarshalText(data []byte) error</a>\n</li>\n<li> <a href=\"#Time.Weekday\">func (t Time) Weekday() Weekday</a>\n</li>\n<li> <a href=\"#Time.Year\">func (t Time) Year() int</a>\n</li>\n<li> <a href=\"#Time.YearDay\">func (t Time) YearDay() int</a>\n</li>\n<li> <a href=\"#Time.Zone\">func (t Time) Zone() (name string, offset int)</a>\n</li>\n<li><a href=\"#Timer\">type Timer</a></li>\n<li> <a href=\"#AfterFunc\">func AfterFunc(d Duration, f func()) *Timer</a>\n</li>\n<li> <a href=\"#NewTimer\">func NewTimer(d Duration) *Timer</a>\n</li>\n<li> <a href=\"#Timer.Reset\">func (t *Timer) Reset(d Duration) bool</a>\n</li>\n<li> <a href=\"#Timer.Stop\">func (t *Timer) Stop() bool</a>\n</li>\n<li><a href=\"#Weekday\">type Weekday</a></li>\n<li> <a href=\"#Weekday.String\">func (d Weekday) String() string</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_After\">After</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Date\">Date</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Duration\">Duration</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Month\">Month</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Parse\">Parse</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ParseInLocation\">ParseInLocation</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Sleep\">Sleep</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Tick\">Tick</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Time_Format\">Time.Format</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Time_Round\">Time.Round</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Time_Truncate\">Time.Truncate</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/time/format.go\">format.go</a> <a href=\"https://golang.org/src/time/sleep.go\">sleep.go</a> <a href=\"https://golang.org/src/time/sys_unix.go\">sys_unix.go</a> <a href=\"https://golang.org/src/time/tick.go\">tick.go</a> <a href=\"https://golang.org/src/time/time.go\">time.go</a> <a href=\"https://golang.org/src/time/zoneinfo.go\">zoneinfo.go</a> <a href=\"https://golang.org/src/time/zoneinfo_read.go\">zoneinfo_read.go</a> <a href=\"https://golang.org/src/time/zoneinfo_unix.go\">zoneinfo_unix.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        ANSIC       = \"Mon Jan _2 15:04:05 2006\"\n        UnixDate    = \"Mon Jan _2 15:04:05 MST 2006\"\n        RubyDate    = \"Mon Jan 02 15:04:05 -0700 2006\"\n        RFC822      = \"02 Jan 06 15:04 MST\"\n        RFC822Z     = \"02 Jan 06 15:04 -0700\" // RFC822 with numeric zone\n        RFC850      = \"Monday, 02-Jan-06 15:04:05 MST\"\n        RFC1123     = \"Mon, 02 Jan 2006 15:04:05 MST\"\n        RFC1123Z    = \"Mon, 02 Jan 2006 15:04:05 -0700\" // RFC1123 with numeric zone\n        RFC3339     = \"2006-01-02T15:04:05Z07:00\"\n        RFC3339Nano = \"2006-01-02T15:04:05.999999999Z07:00\"\n        Kitchen     = \"3:04PM\"\n        // Handy time stamps.\n        Stamp      = \"Jan _2 15:04:05\"\n        StampMilli = \"Jan _2 15:04:05.000\"\n        StampMicro = \"Jan _2 15:04:05.000000\"\n        StampNano  = \"Jan _2 15:04:05.000000000\"\n)</pre> <p> These are predefined layouts for use in Time.Format and Time.Parse. The reference time used in the layouts is the specific time: </p> <pre data-language=\"go\">Mon Jan 2 15:04:05 MST 2006\n</pre> <p> which is Unix time 1136239445. Since MST is GMT-0700, the reference time can be thought of as </p> <pre data-language=\"go\">01/02 03:04:05PM '06 -0700\n</pre> <p> To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. </p> <p> Within the format string, an underscore _ represents a space that may be replaced by a digit if the following number (a day) has two digits; for compatibility with fixed-width Unix time formats. </p> <p> A decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. When parsing (only), the input may contain a fractional second field immediately after the seconds field, even if the layout does not signify its presence. In that case a decimal point followed by a maximal series of digits is parsed as a fractional second. </p> <p> Numeric time zone offsets format as follows: </p> <pre data-language=\"go\">-0700  ±hhmm\n-07:00 ±hh:mm\n-07    ±hh\n</pre> <p> Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: </p> <pre data-language=\"go\">Z0700  Z or ±hhmm\nZ07:00 Z or ±hh:mm\nZ07    Z or ±hh\n</pre> <p> The executable example for time.Format demonstrates the working of the layout string in detail and is a good reference. </p> <p> Note that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs. </p> <h2 id=\"After\">func After  </h2> <pre data-language=\"go\">func After(d Duration) &lt;-chan Time</pre> <p> After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not recovered by the garbage collector until the timer fires. If efficiency is a concern, use NewTimer instead and call Timer.Stop if the timer is no longer needed. </p> <div id=\"example_After\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    select {\n    case m := &lt;-c:\n            handle(m)\n    case &lt;-time.After(5 * time.Minute):\n            fmt.Println(\"timed out\")\n    }\n</pre> </div> </div> <h2 id=\"Sleep\">func Sleep  </h2> <pre data-language=\"go\">func Sleep(d Duration)</pre> <p> Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately. </p> <div id=\"example_Sleep\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"time\"\n)\n\nfunc main() {\n\ttime.Sleep(100 * time.Millisecond)\n}\n</pre> </div> </div> <h2 id=\"Tick\">func Tick  </h2> <pre data-language=\"go\">func Tick(d Duration) &lt;-chan Time</pre> <p> Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it \"leaks\". Unlike NewTicker, Tick will return nil if d &lt;= 0. </p> <div id=\"example_Tick\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    c := time.Tick(1 * time.Minute)\n    for now := range c {\n            fmt.Printf(\"%v %s\\n\", now, statusUpdate())\n    }\n</pre> </div> </div> <h2 id=\"Duration\">type Duration  </h2> <pre data-language=\"go\">type Duration int64</pre> <p> A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years. </p> <pre data-language=\"go\">const (\n        Nanosecond  Duration = 1\n        Microsecond          = 1000 * Nanosecond\n        Millisecond          = 1000 * Microsecond\n        Second               = 1000 * Millisecond\n        Minute               = 60 * Second\n        Hour                 = 60 * Minute\n)</pre> <p> Common durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions. </p> <p> To count the number of units in a Duration, divide: </p> <pre data-language=\"go\">second := time.Second\nfmt.Print(int64(second/time.Millisecond)) // prints 1000\n</pre> <p> To convert an integer number of units to a Duration, multiply: </p> <pre data-language=\"go\">seconds := 10\nfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n</pre> <div id=\"example_Duration\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    t0 := time.Now()\n    expensiveCall()\n    t1 := time.Now()\n    fmt.Printf(\"The call took %v to run.\\n\", t1.Sub(t0))\n</pre> </div> </div> <h3 id=\"ParseDuration\">func <a href=\"https://golang.org/src/time/format.go?s=35310:35356#L1182\">ParseDuration</a>  </h3> <pre data-language=\"go\">func ParseDuration(s string) (Duration, error)</pre> <p> ParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\". </p> <h3 id=\"Since\">func <a href=\"https://golang.org/src/time/time.go?s=19158:19185#L629\">Since</a>  </h3> <pre data-language=\"go\">func Since(t Time) Duration</pre> <p> Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t). </p> <h3 id=\"Duration.Hours\">func (Duration) <a href=\"https://golang.org/src/time/time.go?s=18135:18168#L589\">Hours</a>  </h3> <pre data-language=\"go\">func (d Duration) Hours() float64</pre> <p> Hours returns the duration as a floating point number of hours. </p> <h3 id=\"Duration.Minutes\">func (Duration) <a href=\"https://golang.org/src/time/time.go?s=17941:17976#L582\">Minutes</a>  </h3> <pre data-language=\"go\">func (d Duration) Minutes() float64</pre> <p> Minutes returns the duration as a floating point number of minutes. </p> <h3 id=\"Duration.Nanoseconds\">func (Duration) <a href=\"https://golang.org/src/time/time.go?s=17155:17192#L563\">Nanoseconds</a>  </h3> <pre data-language=\"go\">func (d Duration) Nanoseconds() int64</pre> <p> Nanoseconds returns the duration as an integer nanosecond count. </p> <h3 id=\"Duration.Seconds\">func (Duration) <a href=\"https://golang.org/src/time/time.go?s=17748:17783#L575\">Seconds</a>  </h3> <pre data-language=\"go\">func (d Duration) Seconds() float64</pre> <p> Seconds returns the duration as a floating point number of seconds. </p> <h3 id=\"Duration.String\">func (Duration) <a href=\"https://golang.org/src/time/time.go?s=14992:15025#L448\">String</a>  </h3> <pre data-language=\"go\">func (d Duration) String() string</pre> <p> String returns a string representing the duration in the form \"72h3m0.5s\". Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s. </p> <h2 id=\"Location\">type Location  </h2> <pre data-language=\"go\">type Location struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Location maps time instants to the zone in use at that time. Typically, the Location represents the collection of time offsets in use in a geographical area, such as CEST and CET for central Europe. </p> <pre data-language=\"go\">var Local *Location = &amp;localLoc</pre> <p> Local represents the system's local time zone. </p> <pre data-language=\"go\">var UTC *Location = &amp;utcLoc</pre> <p> UTC represents Universal Coordinated Time (UTC). </p> <h3 id=\"FixedZone\">func <a href=\"https://golang.org/src/time/zoneinfo.go?s=2522:2571#L79\">FixedZone</a>  </h3> <pre data-language=\"go\">func FixedZone(name string, offset int) *Location</pre> <p> FixedZone returns a Location that always uses the given zone name and offset (seconds east of UTC). </p> <h3 id=\"LoadLocation\">func <a href=\"https://golang.org/src/time/zoneinfo.go?s=7498:7547#L263\">LoadLocation</a>  </h3> <pre data-language=\"go\">func LoadLocation(name string) (*Location, error)</pre> <p> LoadLocation returns the Location with the given name. </p> <p> If the name is \"\" or \"UTC\", LoadLocation returns UTC. If the name is \"Local\", LoadLocation returns Local. </p> <p> Otherwise, the name is taken to be a location name corresponding to a file in the IANA Time Zone database, such as \"America/New_York\". </p> <p> The time zone database needed by LoadLocation may not be present on all systems, especially non-Unix systems. LoadLocation looks in the directory or uncompressed zip file named by the ZONEINFO environment variable, if any, then looks in known installation locations on Unix systems, and finally looks in $GOROOT/lib/time/zoneinfo.zip. </p> <h3 id=\"Location.String\">func (*Location) <a href=\"https://golang.org/src/time/zoneinfo.go?s=2355:2389#L73\">String</a>  </h3> <pre data-language=\"go\">func (l *Location) String() string</pre> <p> String returns a descriptive name for the time zone information, corresponding to the argument to LoadLocation. </p> <h2 id=\"Month\">type Month  </h2> <pre data-language=\"go\">type Month int</pre> <p> A Month specifies a month of the year (January = 1, ...). </p> <pre data-language=\"go\">const (\n        January Month = 1 + iota\n        February\n        March\n        April\n        May\n        June\n        July\n        August\n        September\n        October\n        November\n        December\n)</pre> <div id=\"example_Month\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t_, month, day := time.Now().Date()\n\tif month == time.November &amp;&amp; day == 10 {\n\t\tfmt.Println(\"Happy Go day!\")\n\t}\n}\n</pre> </div> </div> <h3 id=\"Month.String\">func (Month) <a href=\"https://golang.org/src/time/time.go?s=3481:3511#L100\">String</a>  </h3> <pre data-language=\"go\">func (m Month) String() string</pre> <p> String returns the English name of the month (\"January\", \"February\", ...). </p> <h2 id=\"ParseError\">type ParseError  </h2> <pre data-language=\"go\">type ParseError struct {\n        Layout     string\n        Value      string\n        LayoutElem string\n        ValueElem  string\n        Message    string\n}</pre> <p> ParseError describes a problem parsing a time string. </p> <h3 id=\"ParseError.Error\">func (*ParseError) <a href=\"https://golang.org/src/time/format.go?s=18639:18674#L617\">Error</a>  </h3> <pre data-language=\"go\">func (e *ParseError) Error() string</pre> <p> Error returns the string representation of a ParseError. </p> <h2 id=\"Ticker\">type Ticker  </h2> <pre data-language=\"go\">type Ticker struct {\n        C &lt;-chan Time // The channel on which the ticks are delivered.\n        // contains filtered or unexported fields\n}</pre> <p> A Ticker holds a channel that delivers `ticks' of a clock at intervals. </p> <h3 id=\"NewTicker\">func <a href=\"https://golang.org/src/time/tick.go?s=706:740#L11\">NewTicker</a>  </h3> <pre data-language=\"go\">func NewTicker(d Duration) *Ticker</pre> <p> NewTicker returns a new Ticker containing a channel that will send the time with a period specified by the duration argument. It adjusts the intervals or drops ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources. </p> <h3 id=\"Ticker.Stop\">func (*Ticker) <a href=\"https://golang.org/src/time/tick.go?s=1318:1341#L35\">Stop</a>  </h3> <pre data-language=\"go\">func (t *Ticker) Stop()</pre> <p> Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a read from the channel succeeding incorrectly. </p> <h2 id=\"Time\">type Time  </h2> <pre data-language=\"go\">type Time struct {\n        // contains filtered or unexported fields\n}</pre> <p> A Time represents an instant in time with nanosecond precision. </p> <p> Programs using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time. A Time value can be used by multiple goroutines simultaneously. </p> <p> Time instants can be compared using the Before, After, and Equal methods. The Sub method subtracts two instants, producing a Duration. The Add method adds a Time and a Duration, producing a Time. </p> <p> The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the IsZero method gives a simple way of detecting a time that has not been initialized explicitly. </p> <p> Each Time has associated with it a Location, consulted when computing the presentation form of the time, such as in the Format, Hour, and Year methods. The methods Local, UTC, and In return a Time with a specific location. Changing the location in this way changes only the presentation; it does not change the instant in time being denoted and therefore does not affect the computations described in earlier paragraphs. </p> <p> Note that the Go == operator compares not just the time instant but also the Location. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method. </p> <h3 id=\"Date\">func <a href=\"https://golang.org/src/time/time.go?s=29994:30077#L1016\">Date</a>  </h3> <pre data-language=\"go\">func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</pre> <p> Date returns the Time corresponding to </p> <pre data-language=\"go\">yyyy-mm-dd hh:mm:ss + nsec nanoseconds\n</pre> <p> in the appropriate zone for that time in the given location. </p> <p> The month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1. </p> <p> A daylight savings time transition skips or repeats times. For example, in the United States, March 13, 2011 2:15am never occurred, while November 6, 2011 1:15am occurred twice. In such cases, the choice of time zone, and therefore the time, is not well-defined. Date returns a time that is correct in one of the two zones involved in the transition, but it does not guarantee which. </p> <p> Date panics if loc is nil. </p> <div id=\"example_Date\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tt := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)\n\tfmt.Printf(\"Go launched at %s\\n\", t.Local())\n}\n</pre> </div> </div> <h3 id=\"Now\">func <a href=\"https://golang.org/src/time/time.go?s=22750:22765#L767\">Now</a>  </h3> <pre data-language=\"go\">func Now() Time</pre> <p> Now returns the current local time. </p> <h3 id=\"Parse\">func <a href=\"https://golang.org/src/time/format.go?s=22597:22643#L725\">Parse</a>  </h3> <pre data-language=\"go\">func Parse(layout, value string) (Time, error)</pre> <p> Parse parses a formatted string and returns the time value it represents. The layout defines the format by showing how the reference time, defined to be </p> <pre data-language=\"go\">Mon Jan 2 15:04:05 -0700 MST 2006\n</pre> <p> would be interpreted if it were the value; it serves as an example of the input format. The same interpretation will then be made to the input string. </p> <p> Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package. Also, the executable example for time.Format demonstrates the working of the layout string in detail and is a good reference. </p> <p> Elements omitted from the value are assumed to be zero or, when zero is impossible, one, so parsing \"3:04pm\" returns the time corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is 0, this time is before the zero Time). Years must be in the range 0000..9999. The day of the week is checked for syntax but it is otherwise ignored. </p> <p> In the absence of a time zone indicator, Parse returns a time in UTC. </p> <p> When parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (Local), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset. </p> <p> No checking is done that the day of the month is within the month's valid dates; any one- or two-digit value is accepted. For example February 31 and even February 99 are valid dates, specifying dates in March and May. This behavior is consistent with time.Date. </p> <p> When parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation \"UTC\" is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use ParseInLocation. </p> <div id=\"example_Parse\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">// See the example for time.Format for a thorough description of how\n    // to define the layout string to parse a time.Time value; Parse and\n    // Format use the same model to describe their input and output.\n\n    // longForm shows by example how the reference time would be represented in\n    // the desired layout.\n    const longForm = \"Jan 2, 2006 at 3:04pm (MST)\"\n    t, _ := time.Parse(longForm, \"Feb 3, 2013 at 7:54pm (PST)\")\n    fmt.Println(t)\n\n    // shortForm is another way the reference time would be represented\n    // in the desired layout; it has no time zone present.\n    // Note: without explicit zone, returns time in UTC.\n    const shortForm = \"2006-Jan-02\"\n    t, _ = time.Parse(shortForm, \"2013-Feb-03\")\n    fmt.Println(t)\n\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">2013-02-03 19:54:00 -0800 PST\n2013-02-03 00:00:00 +0000 UTC\n</pre> </div> </div> <h3 id=\"ParseInLocation\">func <a href=\"https://golang.org/src/time/format.go?s=23055:23126#L734\">ParseInLocation</a>  </h3> <pre data-language=\"go\">func ParseInLocation(layout, value string, loc *Location) (Time, error)</pre> <p> ParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location. </p> <div id=\"example_ParseInLocation\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">loc, _ := time.LoadLocation(\"Europe/Berlin\")\n\n    const longForm = \"Jan 2, 2006 at 3:04pm (MST)\"\n    t, _ := time.ParseInLocation(longForm, \"Jul 9, 2012 at 5:02am (CEST)\", loc)\n    fmt.Println(t)\n\n    // Note: without explicit zone, returns time in given location.\n    const shortForm = \"2006-Jan-02\"\n    t, _ = time.ParseInLocation(shortForm, \"2012-Jul-09\", loc)\n    fmt.Println(t)\n\n    </pre> <p>Output:</p> <pre class=\"output\" data-language=\"go\">2012-07-09 05:02:00 +0200 CEST\n2012-07-09 00:00:00 +0200 CEST\n</pre> </div> </div> <h3 id=\"Unix\">func <a href=\"https://golang.org/src/time/time.go?s=28624:28661#L966\">Unix</a>  </h3> <pre data-language=\"go\">func Unix(sec int64, nsec int64) Time</pre> <p> Unix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1&lt;&lt;63-1 (the largest int64 value). </p> <h3 id=\"Time.Add\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=18290:18324#L596\">Add</a>  </h3> <pre data-language=\"go\">func (t Time) Add(d Duration) Time</pre> <p> Add returns the time t+d. </p> <h3 id=\"Time.AddDate\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=19582:19641#L641\">AddDate</a>  </h3> <pre data-language=\"go\">func (t Time) AddDate(years int, months int, days int) Time</pre> <p> AddDate returns the time corresponding to adding the given number of years, months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010. </p> <p> AddDate normalizes its result in the same way that Date does, so, for example, adding one month to October 31 yields December 1, the normalized form for November 31. </p> <h3 id=\"Time.After\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=2425:2457#L48\">After</a>  </h3> <pre data-language=\"go\">func (t Time) After(u Time) bool</pre> <p> After reports whether the time instant t is after u. </p> <h3 id=\"Time.AppendFormat\">func (Time) <a href=\"https://golang.org/src/time/format.go?s=14349:14407#L446\">AppendFormat</a>  </h3> <pre data-language=\"go\">func (t Time) AppendFormat(b []byte, layout string) []byte</pre> <p> AppendFormat is like Format but appends the textual representation to b and returns the extended buffer. </p> <h3 id=\"Time.Before\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=2580:2613#L53\">Before</a>  </h3> <pre data-language=\"go\">func (t Time) Before(u Time) bool</pre> <p> Before reports whether the time instant t is before u. </p> <h3 id=\"Time.Clock\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=12505:12547#L372\">Clock</a>  </h3> <pre data-language=\"go\">func (t Time) Clock() (hour, min, sec int)</pre> <p> Clock returns the hour, minute, and second within the day specified by t. </p> <h3 id=\"Time.Date\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=9797:9850#L277\">Date</a>  </h3> <pre data-language=\"go\">func (t Time) Date() (year int, month Month, day int)</pre> <p> Date returns the year, month, and day in which t occurs. </p> <h3 id=\"Time.Day\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=10205:10228#L295\">Day</a>  </h3> <pre data-language=\"go\">func (t Time) Day() int</pre> <p> Day returns the day of the month specified by t. </p> <h3 id=\"Time.Equal\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=2956:2988#L62\">Equal</a>  </h3> <pre data-language=\"go\">func (t Time) Equal(u Time) bool</pre> <p> Equal reports whether t and u represent the same time instant. Two times can be equal even if they are in different locations. For example, 6:00 +0200 CEST and 4:00 UTC are Equal. This comparison is different from using t == u, which also compares the locations. </p> <h3 id=\"Time.Format\">func (Time) <a href=\"https://golang.org/src/time/format.go?s=13984:14026#L430\">Format</a>  </h3> <pre data-language=\"go\">func (t Time) Format(layout string) string</pre> <p> Format returns a textual representation of the time value formatted according to layout, which defines the format by showing how the reference time, defined to be </p> <pre data-language=\"go\">Mon Jan 2 15:04:05 -0700 MST 2006\n</pre> <p> would be displayed if it were the value; it serves as an example of the desired output. The same display rules will then be applied to the time value. </p> <p> A fractional second is represented by adding a period and zeros to the end of the seconds section of layout string, as in \"15:04:05.000\" to format a time stamp with millisecond precision. </p> <p> Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package. </p> <div id=\"example_Time_Format\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Parse a time value from a string in the standard Unix format.\n\tt, err := time.Parse(time.UnixDate, \"Sat Mar  7 11:06:39 PST 2015\")\n\tif err != nil { // Always check errors even if they should not happen.\n\t\tpanic(err)\n\t}\n\n\t// time.Time's Stringer method is useful without any format.\n\tfmt.Println(\"default format:\", t)\n\n\t// Predefined constants in the package implement common layouts.\n\tfmt.Println(\"Unix format:\", t.Format(time.UnixDate))\n\n\t// The time zone attached to the time value affects its output.\n\tfmt.Println(\"Same, in UTC:\", t.UTC().Format(time.UnixDate))\n\n\t// The rest of this function demonstrates the properties of the\n\t// layout string used in the format.\n\n\t// The layout string used by the Parse function and Format method\n\t// shows by example how the reference time should be represented.\n\t// We stress that one must show how the reference time is formatted,\n\t// not a time of the user's choosing. Thus each layout string is a\n\t// representation of the time stamp,\n\t//\tJan 2 15:04:05 2006 MST\n\t// An easy way to remember this value is that it holds, when presented\n\t// in this order, the values (lined up with the elements above):\n\t//\t  1 2  3  4  5    6  -7\n\t// There are some wrinkles illustrated below.\n\n\t// Most uses of Format and Parse use constant layout strings such as\n\t// the ones defined in this package, but the interface is flexible,\n\t// as these examples show.\n\n\t// Define a helper function to make the examples' output look nice.\n\tdo := func(name, layout, want string) {\n\t\tgot := t.Format(layout)\n\t\tif want != got {\n\t\t\tfmt.Printf(\"error: for %q got %q; expected %q\\n\", layout, got, want)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"%-15s %q gives %q\\n\", name, layout, got)\n\t}\n\n\t// Print a header in our output.\n\tfmt.Printf(\"\\nFormats:\\n\\n\")\n\n\t// A simple starter example.\n\tdo(\"Basic\", \"Mon Jan 2 15:04:05 MST 2006\", \"Sat Mar 7 11:06:39 PST 2015\")\n\n\t// For fixed-width printing of values, such as the date, that may be one or\n\t// two characters (7 vs. 07), use an _ instead of a space in the layout string.\n\t// Here we print just the day, which is 2 in our layout string and 7 in our\n\t// value.\n\tdo(\"No pad\", \"&lt;2&gt;\", \"&lt;7&gt;\")\n\n\t// An underscore represents a zero pad, if required.\n\tdo(\"Spaces\", \"&lt;_2&gt;\", \"&lt; 7&gt;\")\n\n\t// Similarly, a 0 indicates zero padding.\n\tdo(\"Zeros\", \"&lt;02&gt;\", \"&lt;07&gt;\")\n\n\t// If the value is already the right width, padding is not used.\n\t// For instance, the second (05 in the reference time) in our value is 39,\n\t// so it doesn't need padding, but the minutes (04, 06) does.\n\tdo(\"Suppressed pad\", \"04:05\", \"06:39\")\n\n\t// The predefined constant Unix uses an underscore to pad the day.\n\t// Compare with our simple starter example.\n\tdo(\"Unix\", time.UnixDate, \"Sat Mar  7 11:06:39 PST 2015\")\n\n\t// The hour of the reference time is 15, or 3PM. The layout can express\n\t// it either way, and since our value is the morning we should see it as\n\t// an AM time. We show both in one format string. Lower case too.\n\tdo(\"AM/PM\", \"3PM==3pm==15h\", \"11AM==11am==11h\")\n\n\t// When parsing, if the seconds value is followed by a decimal point\n\t// and some digits, that is taken as a fraction of a second even if\n\t// the layout string does not represent the fractional second.\n\t// Here we add a fractional second to our time value used above.\n\tt, err = time.Parse(time.UnixDate, \"Sat Mar  7 11:06:39.1234 PST 2015\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// It does not appear in the output if the layout string does not contain\n\t// a representation of the fractional second.\n\tdo(\"No fraction\", time.UnixDate, \"Sat Mar  7 11:06:39 PST 2015\")\n\n\t// Fractional seconds can be printed by adding a run of 0s or 9s after\n\t// a decimal point in the seconds value in the layout string.\n\t// If the layout digits are 0s, the fractional second is of the specified\n\t// width. Note that the output has a trailing zero.\n\tdo(\"0s for fraction\", \"15:04:05.00000\", \"11:06:39.12340\")\n\n\t// If the fraction in the layout is 9s, trailing zeros are dropped.\n\tdo(\"9s for fraction\", \"15:04:05.99999999\", \"11:06:39.1234\")\n\n}\n</pre> </div> </div> <h3 id=\"Time.GobDecode\">func (*Time) <a href=\"https://golang.org/src/time/time.go?s=26659:26702#L912\">GobDecode</a>  </h3> <pre data-language=\"go\">func (t *Time) GobDecode(data []byte) error</pre> <p> GobDecode implements the gob.GobDecoder interface. </p> <h3 id=\"Time.GobEncode\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=26532:26573#L907\">GobEncode</a>  </h3> <pre data-language=\"go\">func (t Time) GobEncode() ([]byte, error)</pre> <p> GobEncode implements the gob.GobEncoder interface. </p> <h3 id=\"Time.Hour\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=12929:12953#L387\">Hour</a>  </h3> <pre data-language=\"go\">func (t Time) Hour() int</pre> <p> Hour returns the hour within the day specified by t, in the range [0, 23]. </p> <h3 id=\"Time.ISOWeek\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=10913:10953#L316\">ISOWeek</a>  </h3> <pre data-language=\"go\">func (t Time) ISOWeek() (year, week int)</pre> <p> ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1. </p> <h3 id=\"Time.In\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=23141:23177#L787\">In</a>  </h3> <pre data-language=\"go\">func (t Time) In(loc *Location) Time</pre> <p> In returns t with the location information set to loc. </p> <p> In panics if loc is nil. </p> <h3 id=\"Time.IsZero\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=8438:8465#L228\">IsZero</a>  </h3> <pre data-language=\"go\">func (t Time) IsZero() bool</pre> <p> IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC. </p> <h3 id=\"Time.Local\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=22995:23021#L779\">Local</a>  </h3> <pre data-language=\"go\">func (t Time) Local() Time</pre> <p> Local returns t with the location set to local time. </p> <h3 id=\"Time.Location\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=23344:23378#L796\">Location</a>  </h3> <pre data-language=\"go\">func (t Time) Location() *Location</pre> <p> Location returns the time zone information associated with t. </p> <h3 id=\"Time.MarshalBinary\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=24337:24382#L828\">MarshalBinary</a>  </h3> <pre data-language=\"go\">func (t Time) MarshalBinary() ([]byte, error)</pre> <p> MarshalBinary implements the encoding.BinaryMarshaler interface. </p> <h3 id=\"Time.MarshalJSON\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=26891:26934#L918\">MarshalJSON</a>  </h3> <pre data-language=\"go\">func (t Time) MarshalJSON() ([]byte, error)</pre> <p> MarshalJSON implements the json.Marshaler interface. The time is a quoted string in RFC 3339 format, with sub-second precision added if present. </p> <h3 id=\"Time.MarshalText\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=27770:27813#L943\">MarshalText</a>  </h3> <pre data-language=\"go\">func (t Time) MarshalText() ([]byte, error)</pre> <p> MarshalText implements the encoding.TextMarshaler interface. The time is formatted in RFC 3339 format, with sub-second precision added if present. </p> <h3 id=\"Time.Minute\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=13101:13127#L392\">Minute</a>  </h3> <pre data-language=\"go\">func (t Time) Minute() int</pre> <p> Minute returns the minute offset within the hour specified by t, in the range [0, 59]. </p> <h3 id=\"Time.Month\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=10074:10101#L289\">Month</a>  </h3> <pre data-language=\"go\">func (t Time) Month() Month</pre> <p> Month returns the month of the year specified by t. </p> <h3 id=\"Time.Nanosecond\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=13462:13492#L403\">Nanosecond</a>  </h3> <pre data-language=\"go\">func (t Time) Nanosecond() int</pre> <p> Nanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999]. </p> <h3 id=\"Time.Round\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=32177:32213#L1101\">Round</a>  </h3> <pre data-language=\"go\">func (t Time) Round(d Duration) Time</pre> <p> Round returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d &lt;= 0, Round returns t unchanged. </p> <div id=\"example_Time_Round\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tt := time.Date(0, 0, 0, 12, 15, 30, 918273645, time.UTC)\n\tround := []time.Duration{\n\t\ttime.Nanosecond,\n\t\ttime.Microsecond,\n\t\ttime.Millisecond,\n\t\ttime.Second,\n\t\t2 * time.Second,\n\t\ttime.Minute,\n\t\t10 * time.Minute,\n\t\ttime.Hour,\n\t}\n\n\tfor _, d := range round {\n\t\tfmt.Printf(\"t.Round(%6s) = %s\\n\", d, t.Round(d).Format(\"15:04:05.999999999\"))\n\t}\n}\n</pre> </div> </div> <h3 id=\"Time.Second\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=13280:13306#L397\">Second</a>  </h3> <pre data-language=\"go\">func (t Time) Second() int</pre> <p> Second returns the second offset within the minute specified by t, in the range [0, 59]. </p> <h3 id=\"Time.String\">func (Time) <a href=\"https://golang.org/src/time/format.go?s=13016:13045#L410\">String</a>  </h3> <pre data-language=\"go\">func (t Time) String() string</pre> <p> String returns the time formatted using the format string </p> <pre data-language=\"go\">\"2006-01-02 15:04:05.999999999 -0700 MST\"\n</pre> <h3 id=\"Time.Sub\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=18731:18765#L614\">Sub</a>  </h3> <pre data-language=\"go\">func (t Time) Sub(u Time) Duration</pre> <p> Sub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d). </p> <h3 id=\"Time.Truncate\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=31873:31912#L1090\">Truncate</a>  </h3> <pre data-language=\"go\">func (t Time) Truncate(d Duration) Time</pre> <p> Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d &lt;= 0, Truncate returns t unchanged. </p> <div id=\"example_Time_Truncate\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tt, _ := time.Parse(\"2006 Jan 02 15:04:05\", \"2012 Dec 07 12:15:30.918273645\")\n\ttrunc := []time.Duration{\n\t\ttime.Nanosecond,\n\t\ttime.Microsecond,\n\t\ttime.Millisecond,\n\t\ttime.Second,\n\t\t2 * time.Second,\n\t\ttime.Minute,\n\t\t10 * time.Minute,\n\t\ttime.Hour,\n\t}\n\n\tfor _, d := range trunc {\n\t\tfmt.Printf(\"t.Truncate(%6s) = %s\\n\", d, t.Truncate(d).Format(\"15:04:05.999999999\"))\n\t}\n\n}\n</pre> </div> </div> <h3 id=\"Time.UTC\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=22886:22910#L773\">UTC</a>  </h3> <pre data-language=\"go\">func (t Time) UTC() Time</pre> <p> UTC returns t with the location set to UTC. </p> <h3 id=\"Time.Unix\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=23803:23829#L813\">Unix</a>  </h3> <pre data-language=\"go\">func (t Time) Unix() int64</pre> <p> Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. </p> <h3 id=\"Time.UnixNano\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=24148:24178#L821\">UnixNano</a>  </h3> <pre data-language=\"go\">func (t Time) UnixNano() int64</pre> <p> UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64. Note that this means the result of calling UnixNano on the zero Time is undefined. </p> <h3 id=\"Time.UnmarshalBinary\">func (*Time) <a href=\"https://golang.org/src/time/time.go?s=25338:25387#L867\">UnmarshalBinary</a>  </h3> <pre data-language=\"go\">func (t *Time) UnmarshalBinary(data []byte) error</pre> <p> UnmarshalBinary implements the encoding.BinaryUnmarshaler interface. </p> <h3 id=\"Time.UnmarshalJSON\">func (*Time) <a href=\"https://golang.org/src/time/time.go?s=27433:27480#L934\">UnmarshalJSON</a>  </h3> <pre data-language=\"go\">func (t *Time) UnmarshalJSON(data []byte) error</pre> <p> UnmarshalJSON implements the json.Unmarshaler interface. The time is expected to be a quoted string in RFC 3339 format. </p> <h3 id=\"Time.UnmarshalText\">func (*Time) <a href=\"https://golang.org/src/time/time.go?s=28143:28190#L954\">UnmarshalText</a>  </h3> <pre data-language=\"go\">func (t *Time) UnmarshalText(data []byte) error</pre> <p> UnmarshalText implements the encoding.TextUnmarshaler interface. The time is expected to be in RFC 3339 format. </p> <h3 id=\"Time.Weekday\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=10331:10362#L301\">Weekday</a>  </h3> <pre data-language=\"go\">func (t Time) Weekday() Weekday</pre> <p> Weekday returns the day of the week specified by t. </p> <h3 id=\"Time.Year\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=9944:9968#L283\">Year</a>  </h3> <pre data-language=\"go\">func (t Time) Year() int</pre> <p> Year returns the year in which t occurs. </p> <h3 id=\"Time.YearDay\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=13644:13671#L409\">YearDay</a>  </h3> <pre data-language=\"go\">func (t Time) YearDay() int</pre> <p> YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years, and [1,366] in leap years. </p> <h3 id=\"Time.Zone\">func (Time) <a href=\"https://golang.org/src/time/time.go?s=23587:23633#L806\">Zone</a>  </h3> <pre data-language=\"go\">func (t Time) Zone() (name string, offset int)</pre> <p> Zone computes the time zone in effect at time t, returning the abbreviated name of the zone (such as \"CET\") and its offset in seconds east of UTC. </p> <h2 id=\"Timer\">type Timer  </h2> <pre data-language=\"go\">type Timer struct {\n        C &lt;-chan Time\n        // contains filtered or unexported fields\n}</pre> <p> The Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by AfterFunc. A Timer must be created with NewTimer or AfterFunc. </p> <h3 id=\"AfterFunc\">func <a href=\"https://golang.org/src/time/sleep.go?s=4266:4309#L131\">AfterFunc</a>  </h3> <pre data-language=\"go\">func AfterFunc(d Duration, f func()) *Timer</pre> <p> AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that can be used to cancel the call using its Stop method. </p> <h3 id=\"NewTimer\">func <a href=\"https://golang.org/src/time/sleep.go?s=2220:2252#L64\">NewTimer</a>  </h3> <pre data-language=\"go\">func NewTimer(d Duration) *Timer</pre> <p> NewTimer creates a new Timer that will send the current time on its channel after at least duration d. </p> <h3 id=\"Timer.Reset\">func (*Timer) <a href=\"https://golang.org/src/time/sleep.go?s=3155:3193#L95\">Reset</a>  </h3> <pre data-language=\"go\">func (t *Timer) Reset(d Duration) bool</pre> <p> Reset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped. </p> <p> To reuse an active timer, always call its Stop method first and—if it had expired—drain the value from its channel. For example: </p> <pre data-language=\"go\">if !t.Stop() {\n\t&lt;-t.C\n}\nt.Reset(d)\n</pre> <p> This should not be done concurrent to other receives from the Timer's channel. </p> <p> Note that it is not possible to use Reset's return value correctly, as there is a race condition between draining the channel and the new timer expiring. Reset should always be used in concert with Stop, as described above. The return value exists to preserve compatibility with existing programs. </p> <h3 id=\"Timer.Stop\">func (*Timer) <a href=\"https://golang.org/src/time/sleep.go?s=1980:2007#L55\">Stop</a>  </h3> <pre data-language=\"go\">func (t *Timer) Stop() bool</pre> <p> Stop prevents the Timer from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped. Stop does not close the channel, to prevent a read from the channel succeeding incorrectly. </p> <p> To prevent the timer firing after a call to Stop, check the return value and drain the channel. For example: </p> <pre data-language=\"go\">if !t.Stop() {\n\t&lt;-t.C\n}\n</pre> <p> This cannot be done concurrent to other receives from the Timer's channel. </p> <h2 id=\"Weekday\">type Weekday  </h2> <pre data-language=\"go\">type Weekday int</pre> <p> A Weekday specifies a day of the week (Sunday = 0, ...). </p> <pre data-language=\"go\">const (\n        Sunday Weekday = iota\n        Monday\n        Tuesday\n        Wednesday\n        Thursday\n        Friday\n        Saturday\n)</pre> <h3 id=\"Weekday.String\">func (Weekday) <a href=\"https://golang.org/src/time/time.go?s=3889:3921#L126\">String</a>  </h3> <pre data-language=\"go\">func (d Weekday) String() string</pre> <p> String returns the English name of the day (\"Sunday\", \"Monday\", ...). </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/time/\" class=\"_attribution-link\">https://golang.org/pkg/time/</a>\n  </p>\n</div>\n","net/http/index":"<h1>Package http</h1>     <ul id=\"short-nav\">\n<li><code>import \"net/http\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package http provides HTTP client and server implementations. </p> <p> Get, Head, Post, and PostForm make HTTP (or HTTPS) requests: </p> <pre data-language=\"go\">resp, err := http.Get(\"http://example.com/\")\n...\nresp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", &amp;buf)\n...\nresp, err := http.PostForm(\"http://example.com/form\",\n\turl.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}})\n</pre> <p> The client must close the response body when finished with it: </p> <pre data-language=\"go\">resp, err := http.Get(\"http://example.com/\")\nif err != nil {\n\t// handle error\n}\ndefer resp.Body.Close()\nbody, err := ioutil.ReadAll(resp.Body)\n// ...\n</pre> <p> For control over HTTP client headers, redirect policy, and other settings, create a Client: </p> <pre data-language=\"go\">client := &amp;http.Client{\n\tCheckRedirect: redirectPolicyFunc,\n}\n\nresp, err := client.Get(\"http://example.com\")\n// ...\n\nreq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n// ...\nreq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\nresp, err := client.Do(req)\n// ...\n</pre> <p> For control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport: </p> <pre data-language=\"go\">tr := &amp;http.Transport{\n\tTLSClientConfig:    &amp;tls.Config{RootCAs: pool},\n\tDisableCompression: true,\n}\nclient := &amp;http.Client{Transport: tr}\nresp, err := client.Get(\"https://example.com\")\n</pre> <p> Clients and Transports are safe for concurrent use by multiple goroutines and for efficiency should only be created once and re-used. </p> <p> ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux: </p> <pre data-language=\"go\">http.Handle(\"/foo\", fooHandler)\n\nhttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n})\n\nlog.Fatal(http.ListenAndServe(\":8080\", nil))\n</pre> <p> More control over the server's behavior is available by creating a custom Server: </p> <pre data-language=\"go\">s := &amp;http.Server{\n\tAddr:           \":8080\",\n\tHandler:        myHandler,\n\tReadTimeout:    10 * time.Second,\n\tWriteTimeout:   10 * time.Second,\n\tMaxHeaderBytes: 1 &lt;&lt; 20,\n}\nlog.Fatal(s.ListenAndServe())\n</pre> <p> The http package has transparent support for the HTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2 can do so by setting Transport.TLSNextProto (for clients) or Server.TLSNextProto (for servers) to a non-nil, empty map. Alternatively, the following GODEBUG environment variables are currently supported: </p> <pre data-language=\"go\">GODEBUG=http2client=0  # disable HTTP/2 client support\nGODEBUG=http2server=0  # disable HTTP/2 server support\nGODEBUG=http2debug=1   # enable verbose HTTP/2 debug logs\nGODEBUG=http2debug=2   # ... even more verbose, with frame dumps\n</pre> <p> The GODEBUG variables are not covered by Go's API compatibility promise. HTTP/2 support was added in Go 1.6. Please report any issues instead of disabling HTTP/2 support: <a href=\"https://golang.org/s/http2bug\">https://golang.org/s/http2bug</a> </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#CanonicalHeaderKey\">func CanonicalHeaderKey(s string) string</a></li>\n<li><a href=\"#DetectContentType\">func DetectContentType(data []byte) string</a></li>\n<li><a href=\"#Error\">func Error(w ResponseWriter, error string, code int)</a></li>\n<li><a href=\"#Handle\">func Handle(pattern string, handler Handler)</a></li>\n<li><a href=\"#HandleFunc\">func HandleFunc(pattern string, handler func(ResponseWriter, *Request))</a></li>\n<li><a href=\"#ListenAndServe\">func ListenAndServe(addr string, handler Handler) error</a></li>\n<li><a href=\"#ListenAndServeTLS\">func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error</a></li>\n<li><a href=\"#MaxBytesReader\">func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser</a></li>\n<li><a href=\"#NotFound\">func NotFound(w ResponseWriter, r *Request)</a></li>\n<li><a href=\"#ParseHTTPVersion\">func ParseHTTPVersion(vers string) (major, minor int, ok bool)</a></li>\n<li><a href=\"#ParseTime\">func ParseTime(text string) (t time.Time, err error)</a></li>\n<li><a href=\"#ProxyFromEnvironment\">func ProxyFromEnvironment(req *Request) (*url.URL, error)</a></li>\n<li><a href=\"#ProxyURL\">func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)</a></li>\n<li><a href=\"#Redirect\">func Redirect(w ResponseWriter, r *Request, urlStr string, code int)</a></li>\n<li><a href=\"#Serve\">func Serve(l net.Listener, handler Handler) error</a></li>\n<li><a href=\"#ServeContent\">func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)</a></li>\n<li><a href=\"#ServeFile\">func ServeFile(w ResponseWriter, r *Request, name string)</a></li>\n<li><a href=\"#SetCookie\">func SetCookie(w ResponseWriter, cookie *Cookie)</a></li>\n<li><a href=\"#StatusText\">func StatusText(code int) string</a></li>\n<li><a href=\"#Client\">type Client</a></li>\n<li> <a href=\"#Client.Do\">func (c *Client) Do(req *Request) (*Response, error)</a>\n</li>\n<li> <a href=\"#Client.Get\">func (c *Client) Get(url string) (resp *Response, err error)</a>\n</li>\n<li> <a href=\"#Client.Head\">func (c *Client) Head(url string) (resp *Response, err error)</a>\n</li>\n<li> <a href=\"#Client.Post\">func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error)</a>\n</li>\n<li> <a href=\"#Client.PostForm\">func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)</a>\n</li>\n<li><a href=\"#CloseNotifier\">type CloseNotifier</a></li>\n<li><a href=\"#ConnState\">type ConnState</a></li>\n<li> <a href=\"#ConnState.String\">func (c ConnState) String() string</a>\n</li>\n<li><a href=\"#Cookie\">type Cookie</a></li>\n<li> <a href=\"#Cookie.String\">func (c *Cookie) String() string</a>\n</li>\n<li><a href=\"#CookieJar\">type CookieJar</a></li>\n<li><a href=\"#Dir\">type Dir</a></li>\n<li> <a href=\"#Dir.Open\">func (d Dir) Open(name string) (File, error)</a>\n</li>\n<li><a href=\"#File\">type File</a></li>\n<li><a href=\"#FileSystem\">type FileSystem</a></li>\n<li><a href=\"#Flusher\">type Flusher</a></li>\n<li><a href=\"#Handler\">type Handler</a></li>\n<li> <a href=\"#FileServer\">func FileServer(root FileSystem) Handler</a>\n</li>\n<li> <a href=\"#NotFoundHandler\">func NotFoundHandler() Handler</a>\n</li>\n<li> <a href=\"#RedirectHandler\">func RedirectHandler(url string, code int) Handler</a>\n</li>\n<li> <a href=\"#StripPrefix\">func StripPrefix(prefix string, h Handler) Handler</a>\n</li>\n<li> <a href=\"#TimeoutHandler\">func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler</a>\n</li>\n<li><a href=\"#HandlerFunc\">type HandlerFunc</a></li>\n<li> <a href=\"#HandlerFunc.ServeHTTP\">func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)</a>\n</li>\n<li><a href=\"#Header\">type Header</a></li>\n<li> <a href=\"#Header.Add\">func (h Header) Add(key, value string)</a>\n</li>\n<li> <a href=\"#Header.Del\">func (h Header) Del(key string)</a>\n</li>\n<li> <a href=\"#Header.Get\">func (h Header) Get(key string) string</a>\n</li>\n<li> <a href=\"#Header.Set\">func (h Header) Set(key, value string)</a>\n</li>\n<li> <a href=\"#Header.Write\">func (h Header) Write(w io.Writer) error</a>\n</li>\n<li> <a href=\"#Header.WriteSubset\">func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error</a>\n</li>\n<li><a href=\"#Hijacker\">type Hijacker</a></li>\n<li><a href=\"#ProtocolError\">type ProtocolError</a></li>\n<li> <a href=\"#ProtocolError.Error\">func (err *ProtocolError) Error() string</a>\n</li>\n<li><a href=\"#Request\">type Request</a></li>\n<li> <a href=\"#NewRequest\">func NewRequest(method, urlStr string, body io.Reader) (*Request, error)</a>\n</li>\n<li> <a href=\"#ReadRequest\">func ReadRequest(b *bufio.Reader) (*Request, error)</a>\n</li>\n<li> <a href=\"#Request.AddCookie\">func (r *Request) AddCookie(c *Cookie)</a>\n</li>\n<li> <a href=\"#Request.BasicAuth\">func (r *Request) BasicAuth() (username, password string, ok bool)</a>\n</li>\n<li> <a href=\"#Request.Context\">func (r *Request) Context() context.Context</a>\n</li>\n<li> <a href=\"#Request.Cookie\">func (r *Request) Cookie(name string) (*Cookie, error)</a>\n</li>\n<li> <a href=\"#Request.Cookies\">func (r *Request) Cookies() []*Cookie</a>\n</li>\n<li> <a href=\"#Request.FormFile\">func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)</a>\n</li>\n<li> <a href=\"#Request.FormValue\">func (r *Request) FormValue(key string) string</a>\n</li>\n<li> <a href=\"#Request.MultipartReader\">func (r *Request) MultipartReader() (*multipart.Reader, error)</a>\n</li>\n<li> <a href=\"#Request.ParseForm\">func (r *Request) ParseForm() error</a>\n</li>\n<li> <a href=\"#Request.ParseMultipartForm\">func (r *Request) ParseMultipartForm(maxMemory int64) error</a>\n</li>\n<li> <a href=\"#Request.PostFormValue\">func (r *Request) PostFormValue(key string) string</a>\n</li>\n<li> <a href=\"#Request.ProtoAtLeast\">func (r *Request) ProtoAtLeast(major, minor int) bool</a>\n</li>\n<li> <a href=\"#Request.Referer\">func (r *Request) Referer() string</a>\n</li>\n<li> <a href=\"#Request.SetBasicAuth\">func (r *Request) SetBasicAuth(username, password string)</a>\n</li>\n<li> <a href=\"#Request.UserAgent\">func (r *Request) UserAgent() string</a>\n</li>\n<li> <a href=\"#Request.WithContext\">func (r *Request) WithContext(ctx context.Context) *Request</a>\n</li>\n<li> <a href=\"#Request.Write\">func (r *Request) Write(w io.Writer) error</a>\n</li>\n<li> <a href=\"#Request.WriteProxy\">func (r *Request) WriteProxy(w io.Writer) error</a>\n</li>\n<li><a href=\"#Response\">type Response</a></li>\n<li> <a href=\"#Get\">func Get(url string) (resp *Response, err error)</a>\n</li>\n<li> <a href=\"#Head\">func Head(url string) (resp *Response, err error)</a>\n</li>\n<li> <a href=\"#Post\">func Post(url string, bodyType string, body io.Reader) (resp *Response, err error)</a>\n</li>\n<li> <a href=\"#PostForm\">func PostForm(url string, data url.Values) (resp *Response, err error)</a>\n</li>\n<li> <a href=\"#ReadResponse\">func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)</a>\n</li>\n<li> <a href=\"#Response.Cookies\">func (r *Response) Cookies() []*Cookie</a>\n</li>\n<li> <a href=\"#Response.Location\">func (r *Response) Location() (*url.URL, error)</a>\n</li>\n<li> <a href=\"#Response.ProtoAtLeast\">func (r *Response) ProtoAtLeast(major, minor int) bool</a>\n</li>\n<li> <a href=\"#Response.Write\">func (r *Response) Write(w io.Writer) error</a>\n</li>\n<li><a href=\"#ResponseWriter\">type ResponseWriter</a></li>\n<li><a href=\"#RoundTripper\">type RoundTripper</a></li>\n<li> <a href=\"#NewFileTransport\">func NewFileTransport(fs FileSystem) RoundTripper</a>\n</li>\n<li><a href=\"#ServeMux\">type ServeMux</a></li>\n<li> <a href=\"#NewServeMux\">func NewServeMux() *ServeMux</a>\n</li>\n<li> <a href=\"#ServeMux.Handle\">func (mux *ServeMux) Handle(pattern string, handler Handler)</a>\n</li>\n<li> <a href=\"#ServeMux.HandleFunc\">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</a>\n</li>\n<li> <a href=\"#ServeMux.Handler\">func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)</a>\n</li>\n<li> <a href=\"#ServeMux.ServeHTTP\">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</a>\n</li>\n<li><a href=\"#Server\">type Server</a></li>\n<li> <a href=\"#Server.ListenAndServe\">func (srv *Server) ListenAndServe() error</a>\n</li>\n<li> <a href=\"#Server.ListenAndServeTLS\">func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error</a>\n</li>\n<li> <a href=\"#Server.Serve\">func (srv *Server) Serve(l net.Listener) error</a>\n</li>\n<li> <a href=\"#Server.SetKeepAlivesEnabled\">func (srv *Server) SetKeepAlivesEnabled(v bool)</a>\n</li>\n<li><a href=\"#Transport\">type Transport</a></li>\n<li> <a href=\"#Transport.CancelRequest\">func (t *Transport) CancelRequest(req *Request)</a>\n</li>\n<li> <a href=\"#Transport.CloseIdleConnections\">func (t *Transport) CloseIdleConnections()</a>\n</li>\n<li> <a href=\"#Transport.RegisterProtocol\">func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)</a>\n</li>\n<li> <a href=\"#Transport.RoundTrip\">func (t *Transport) RoundTrip(req *Request) (*Response, error)</a>\n</li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_FileServer\">FileServer</a></dd> <dd><a class=\"exampleLink\" href=\"#example_FileServer_stripPrefix\">FileServer (StripPrefix)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Get\">Get</a></dd> <dd><a class=\"exampleLink\" href=\"#example_Hijacker\">Hijacker</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ResponseWriter_trailers\">ResponseWriter (Trailers)</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ServeMux_Handle\">ServeMux.Handle</a></dd> <dd><a class=\"exampleLink\" href=\"#example_StripPrefix\">StripPrefix</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/net/http/client.go\">client.go</a> <a href=\"https://golang.org/src/net/http/cookie.go\">cookie.go</a> <a href=\"https://golang.org/src/net/http/doc.go\">doc.go</a> <a href=\"https://golang.org/src/net/http/filetransport.go\">filetransport.go</a> <a href=\"https://golang.org/src/net/http/fs.go\">fs.go</a> <a href=\"https://golang.org/src/net/http/h2_bundle.go\">h2_bundle.go</a> <a href=\"https://golang.org/src/net/http/header.go\">header.go</a> <a href=\"https://golang.org/src/net/http/http.go\">http.go</a> <a href=\"https://golang.org/src/net/http/jar.go\">jar.go</a> <a href=\"https://golang.org/src/net/http/method.go\">method.go</a> <a href=\"https://golang.org/src/net/http/request.go\">request.go</a> <a href=\"https://golang.org/src/net/http/response.go\">response.go</a> <a href=\"https://golang.org/src/net/http/server.go\">server.go</a> <a href=\"https://golang.org/src/net/http/sniff.go\">sniff.go</a> <a href=\"https://golang.org/src/net/http/status.go\">status.go</a> <a href=\"https://golang.org/src/net/http/transfer.go\">transfer.go</a> <a href=\"https://golang.org/src/net/http/transport.go\">transport.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        MethodGet     = \"GET\"\n        MethodHead    = \"HEAD\"\n        MethodPost    = \"POST\"\n        MethodPut     = \"PUT\"\n        MethodPatch   = \"PATCH\" // RFC 5789\n        MethodDelete  = \"DELETE\"\n        MethodConnect = \"CONNECT\"\n        MethodOptions = \"OPTIONS\"\n        MethodTrace   = \"TRACE\"\n)</pre> <p> Common HTTP methods. </p> <p> Unless otherwise noted, these are defined in RFC 7231 section 4.3. </p> <pre data-language=\"go\">const (\n        StatusContinue           = 100 // RFC 7231, 6.2.1\n        StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2\n        StatusProcessing         = 102 // RFC 2518, 10.1\n\n        StatusOK                   = 200 // RFC 7231, 6.3.1\n        StatusCreated              = 201 // RFC 7231, 6.3.2\n        StatusAccepted             = 202 // RFC 7231, 6.3.3\n        StatusNonAuthoritativeInfo = 203 // RFC 7231, 6.3.4\n        StatusNoContent            = 204 // RFC 7231, 6.3.5\n        StatusResetContent         = 205 // RFC 7231, 6.3.6\n        StatusPartialContent       = 206 // RFC 7233, 4.1\n        StatusMultiStatus          = 207 // RFC 4918, 11.1\n        StatusAlreadyReported      = 208 // RFC 5842, 7.1\n        StatusIMUsed               = 226 // RFC 3229, 10.4.1\n\n        StatusMultipleChoices  = 300 // RFC 7231, 6.4.1\n        StatusMovedPermanently = 301 // RFC 7231, 6.4.2\n        StatusFound            = 302 // RFC 7231, 6.4.3\n        StatusSeeOther         = 303 // RFC 7231, 6.4.4\n        StatusNotModified      = 304 // RFC 7232, 4.1\n        StatusUseProxy         = 305 // RFC 7231, 6.4.5\n\n        StatusTemporaryRedirect = 307 // RFC 7231, 6.4.7\n        StatusPermanentRedirect = 308 // RFC 7538, 3\n\n        StatusBadRequest                   = 400 // RFC 7231, 6.5.1\n        StatusUnauthorized                 = 401 // RFC 7235, 3.1\n        StatusPaymentRequired              = 402 // RFC 7231, 6.5.2\n        StatusForbidden                    = 403 // RFC 7231, 6.5.3\n        StatusNotFound                     = 404 // RFC 7231, 6.5.4\n        StatusMethodNotAllowed             = 405 // RFC 7231, 6.5.5\n        StatusNotAcceptable                = 406 // RFC 7231, 6.5.6\n        StatusProxyAuthRequired            = 407 // RFC 7235, 3.2\n        StatusRequestTimeout               = 408 // RFC 7231, 6.5.7\n        StatusConflict                     = 409 // RFC 7231, 6.5.8\n        StatusGone                         = 410 // RFC 7231, 6.5.9\n        StatusLengthRequired               = 411 // RFC 7231, 6.5.10\n        StatusPreconditionFailed           = 412 // RFC 7232, 4.2\n        StatusRequestEntityTooLarge        = 413 // RFC 7231, 6.5.11\n        StatusRequestURITooLong            = 414 // RFC 7231, 6.5.12\n        StatusUnsupportedMediaType         = 415 // RFC 7231, 6.5.13\n        StatusRequestedRangeNotSatisfiable = 416 // RFC 7233, 4.4\n        StatusExpectationFailed            = 417 // RFC 7231, 6.5.14\n        StatusTeapot                       = 418 // RFC 7168, 2.3.3\n        StatusUnprocessableEntity          = 422 // RFC 4918, 11.2\n        StatusLocked                       = 423 // RFC 4918, 11.3\n        StatusFailedDependency             = 424 // RFC 4918, 11.4\n        StatusUpgradeRequired              = 426 // RFC 7231, 6.5.15\n        StatusPreconditionRequired         = 428 // RFC 6585, 3\n        StatusTooManyRequests              = 429 // RFC 6585, 4\n        StatusRequestHeaderFieldsTooLarge  = 431 // RFC 6585, 5\n        StatusUnavailableForLegalReasons   = 451 // RFC 7725, 3\n\n        StatusInternalServerError           = 500 // RFC 7231, 6.6.1\n        StatusNotImplemented                = 501 // RFC 7231, 6.6.2\n        StatusBadGateway                    = 502 // RFC 7231, 6.6.3\n        StatusServiceUnavailable            = 503 // RFC 7231, 6.6.4\n        StatusGatewayTimeout                = 504 // RFC 7231, 6.6.5\n        StatusHTTPVersionNotSupported       = 505 // RFC 7231, 6.6.6\n        StatusVariantAlsoNegotiates         = 506 // RFC 2295, 8.1\n        StatusInsufficientStorage           = 507 // RFC 4918, 11.5\n        StatusLoopDetected                  = 508 // RFC 5842, 7.2\n        StatusNotExtended                   = 510 // RFC 2774, 7\n        StatusNetworkAuthenticationRequired = 511 // RFC 6585, 6\n)</pre> <p> HTTP status codes as registered with IANA. See: <a href=\"http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\">http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</a> </p> <pre data-language=\"go\">const DefaultMaxHeaderBytes = 1 &lt;&lt; 20 // 1 MB\n</pre> <p> DefaultMaxHeaderBytes is the maximum permitted size of the headers in an HTTP request. This can be overridden by setting Server.MaxHeaderBytes. </p> <pre data-language=\"go\">const DefaultMaxIdleConnsPerHost = 2</pre> <p> DefaultMaxIdleConnsPerHost is the default value of Transport's MaxIdleConnsPerHost. </p> <pre data-language=\"go\">const TimeFormat = \"Mon, 02 Jan 2006 15:04:05 GMT\"</pre> <p> TimeFormat is the time format to use when generating times in HTTP headers. It is like time.RFC1123 but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format. </p> <p> For parsing this time format, see ParseTime. </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        ErrHeaderTooLong        = &amp;ProtocolError{\"header too long\"}\n        ErrShortBody            = &amp;ProtocolError{\"entity body too short\"}\n        ErrNotSupported         = &amp;ProtocolError{\"feature not supported\"}\n        ErrUnexpectedTrailer    = &amp;ProtocolError{\"trailer header without chunked transfer encoding\"}\n        ErrMissingContentLength = &amp;ProtocolError{\"missing ContentLength in HEAD response\"}\n        ErrNotMultipart         = &amp;ProtocolError{\"request Content-Type isn't multipart/form-data\"}\n        ErrMissingBoundary      = &amp;ProtocolError{\"no multipart boundary param in Content-Type\"}\n)</pre> <pre data-language=\"go\">var (\n        // ErrBodyNotAllowed is returned by ResponseWriter.Write calls\n        // when the HTTP method or response code does not permit a\n        // body.\n        ErrBodyNotAllowed = errors.New(\"http: request method or response status code does not allow body\")\n\n        // ErrHijacked is returned by ResponseWriter.Write calls when\n        // the underlying connection has been hijacked using the\n        // Hijacker interfaced.\n        ErrHijacked = errors.New(\"http: connection has been hijacked\")\n\n        // ErrContentLength is returned by ResponseWriter.Write calls\n        // when a Handler set a Content-Length response header with a\n        // declared size and then attempted to write more bytes than\n        // declared.\n        ErrContentLength = errors.New(\"http: wrote more than the declared Content-Length\")\n\n        // Deprecated: ErrWriteAfterFlush is no longer used.\n        ErrWriteAfterFlush = errors.New(\"unused\")\n)</pre> <p> Errors used by the HTTP server. </p> <pre data-language=\"go\">var (\n        // ServerContextKey is a context key. It can be used in HTTP\n        // handlers with context.WithValue to access the server that\n        // started the handler. The associated value will be of\n        // type *Server.\n        ServerContextKey = &amp;contextKey{\"http-server\"}\n\n        // LocalAddrContextKey is a context key. It can be used in\n        // HTTP handlers with context.WithValue to access the address\n        // the local address the connection arrived on.\n        // The associated value will be of type net.Addr.\n        LocalAddrContextKey = &amp;contextKey{\"local-addr\"}\n)</pre> <pre data-language=\"go\">var DefaultClient = &amp;Client{}</pre> <p> DefaultClient is the default Client and is used by Get, Head, and Post. </p> <pre data-language=\"go\">var DefaultServeMux = &amp;defaultServeMux</pre> <p> DefaultServeMux is the default ServeMux used by Serve. </p> <pre data-language=\"go\">var ErrBodyReadAfterClose = errors.New(\"http: invalid Read on closed Body\")</pre> <p> ErrBodyReadAfterClose is returned when reading a Request or Response Body after the body has been closed. This typically happens when the body is read after an HTTP Handler calls WriteHeader or Write on its ResponseWriter. </p> <pre data-language=\"go\">var ErrHandlerTimeout = errors.New(\"http: Handler timeout\")</pre> <p> ErrHandlerTimeout is returned on ResponseWriter Write calls in handlers which have timed out. </p> <pre data-language=\"go\">var ErrLineTooLong = internal.ErrLineTooLong</pre> <p> ErrLineTooLong is returned when reading request or response bodies with malformed chunked encoding. </p> <pre data-language=\"go\">var ErrMissingFile = errors.New(\"http: no such file\")</pre> <p> ErrMissingFile is returned by FormFile when the provided file field name is either not present in the request or not a file field. </p> <pre data-language=\"go\">var ErrNoCookie = errors.New(\"http: named cookie not present\")</pre> <p> ErrNoCookie is returned by Request's Cookie method when a cookie is not found. </p> <pre data-language=\"go\">var ErrNoLocation = errors.New(\"http: no Location header in response\")</pre> <p> ErrNoLocation is returned by Response's Location method when no Location header is present. </p> <pre data-language=\"go\">var ErrSkipAltProtocol = errors.New(\"net/http: skip alternate protocol\")</pre> <p> ErrSkipAltProtocol is a sentinel error value defined by Transport.RegisterProtocol. </p> <pre data-language=\"go\">var ErrUseLastResponse = errors.New(\"net/http: use last response\")</pre> <p> ErrUseLastResponse can be returned by Client.CheckRedirect hooks to control how redirects are processed. If returned, the next request is not sent and the most recent response is returned with its body unclosed. </p> <h2 id=\"CanonicalHeaderKey\">func CanonicalHeaderKey  </h2> <pre data-language=\"go\">func CanonicalHeaderKey(s string) string</pre> <p> CanonicalHeaderKey returns the canonical format of the header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". If s contains a space or invalid header field bytes, it is returned without modifications. </p> <h2 id=\"DetectContentType\">func DetectContentType  </h2> <pre data-language=\"go\">func DetectContentType(data []byte) string</pre> <p> DetectContentType implements the algorithm described at <a href=\"http://mimesniff.spec.whatwg.org/\">http://mimesniff.spec.whatwg.org/</a> to determine the Content-Type of the given data. It considers at most the first 512 bytes of data. DetectContentType always returns a valid MIME type: if it cannot determine a more specific one, it returns \"application/octet-stream\". </p> <h2 id=\"Error\">func Error  </h2> <pre data-language=\"go\">func Error(w ResponseWriter, error string, code int)</pre> <p> Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text. </p> <h2 id=\"Handle\">func Handle  </h2> <pre data-language=\"go\">func Handle(pattern string, handler Handler)</pre> <p> Handle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched. </p> <h2 id=\"HandleFunc\">func HandleFunc  </h2> <pre data-language=\"go\">func HandleFunc(pattern string, handler func(ResponseWriter, *Request))</pre> <p> HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched. </p> <h2 id=\"ListenAndServe\">func ListenAndServe  </h2> <pre data-language=\"go\">func ListenAndServe(addr string, handler Handler) error</pre> <p> ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives. Handler is typically nil, in which case the DefaultServeMux is used. </p> <p> A trivial example server is: </p> <pre data-language=\"go\">package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"log\"\n)\n\n// hello world, the web server\nfunc HelloServer(w http.ResponseWriter, req *http.Request) {\n\tio.WriteString(w, \"hello, world!\\n\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/hello\", HelloServer)\n\tlog.Fatal(http.ListenAndServe(\":12345\", nil))\n}\n</pre> <p> ListenAndServe always returns a non-nil error. </p> <h2 id=\"ListenAndServeTLS\">func ListenAndServeTLS  </h2> <pre data-language=\"go\">func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error</pre> <p> ListenAndServeTLS acts identically to ListenAndServe, except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. </p> <p> A trivial example server is: </p> <pre data-language=\"go\">import (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\tw.Write([]byte(\"This is an example server.\\n\"))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\tlog.Printf(\"About to listen on 10443. Go to https://127.0.0.1:10443/\")\n\terr := http.ListenAndServeTLS(\":10443\", \"cert.pem\", \"key.pem\", nil)\n\tlog.Fatal(err)\n}\n</pre> <p> One can use generate_cert.go in crypto/tls to generate cert.pem and key.pem. </p> <p> ListenAndServeTLS always returns a non-nil error. </p> <h2 id=\"MaxBytesReader\">func MaxBytesReader  </h2> <pre data-language=\"go\">func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser</pre> <p> MaxBytesReader is similar to io.LimitReader but is intended for limiting the size of incoming request bodies. In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non-EOF error for a Read beyond the limit, and closes the underlying reader when its Close method is called. </p> <p> MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources. </p> <h2 id=\"NotFound\">func NotFound  </h2> <pre data-language=\"go\">func NotFound(w ResponseWriter, r *Request)</pre> <p> NotFound replies to the request with an HTTP 404 not found error. </p> <h2 id=\"ParseHTTPVersion\">func ParseHTTPVersion  </h2> <pre data-language=\"go\">func ParseHTTPVersion(vers string) (major, minor int, ok bool)</pre> <p> ParseHTTPVersion parses a HTTP version string. \"HTTP/1.0\" returns (1, 0, true). </p> <h2 id=\"ParseTime\">func ParseTime  </h2> <pre data-language=\"go\">func ParseTime(text string) (t time.Time, err error)</pre> <p> ParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: TimeFormat, time.RFC850, and time.ANSIC. </p> <h2 id=\"ProxyFromEnvironment\">func ProxyFromEnvironment  </h2> <pre data-language=\"go\">func ProxyFromEnvironment(req *Request) (*url.URL, error)</pre> <p> ProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https requests. </p> <p> The environment values may be either a complete URL or a \"host[:port]\", in which case the \"http\" scheme is assumed. An error is returned if the value is a different form. </p> <p> A nil URL and nil error are returned if no proxy is defined in the environment, or a proxy should not be used for the given request, as defined by NO_PROXY. </p> <p> As a special case, if req.URL.Host is \"localhost\" (with or without a port number), then a nil URL and nil error will be returned. </p> <h2 id=\"ProxyURL\">func ProxyURL  </h2> <pre data-language=\"go\">func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)</pre> <p> ProxyURL returns a proxy function (for use in a Transport) that always returns the same URL. </p> <h2 id=\"Redirect\">func Redirect  </h2> <pre data-language=\"go\">func Redirect(w ResponseWriter, r *Request, urlStr string, code int)</pre> <p> Redirect replies to the request with a redirect to url, which may be a path relative to the request path. </p> <p> The provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther. </p> <h2 id=\"Serve\">func Serve  </h2> <pre data-language=\"go\">func Serve(l net.Listener, handler Handler) error</pre> <p> Serve accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them. Handler is typically nil, in which case the DefaultServeMux is used. </p> <h2 id=\"ServeContent\">func ServeContent  </h2> <pre data-language=\"go\">func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)</pre> <p> ServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over io.Copy is that it handles Range requests properly, sets the MIME type, and handles If-Modified-Since requests. </p> <p> If the response's Content-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to DetectContentType. The name is otherwise unused; in particular it can be empty and is never sent in the response. </p> <p> If modtime is not the zero time or Unix epoch, ServeContent includes it in a Last-Modified header in the response. If the request includes an If-Modified-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all. </p> <p> The content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size. </p> <p> If the caller has set w's ETag header, ServeContent uses it to handle requests using If-Range and If-None-Match. </p> <p> Note that *os.File implements the io.ReadSeeker interface. </p> <h2 id=\"ServeFile\">func ServeFile  </h2> <pre data-language=\"go\">func ServeFile(w ResponseWriter, r *Request, name string)</pre> <p> ServeFile replies to the request with the contents of the named file or directory. </p> <p> If the provided file or directory name is a relative path, it is interpreted relative to the current directory and may ascend to parent directories. If the provided name is constructed from user input, it should be sanitized before calling ServeFile. As a precaution, ServeFile will reject requests where r.URL.Path contains a \"..\" path element. </p> <p> As a special case, ServeFile redirects any request where r.URL.Path ends in \"/index.html\" to the same path, without the final \"index.html\". To avoid such redirects either modify the path or use ServeContent. </p> <h2 id=\"SetCookie\">func SetCookie  </h2> <pre data-language=\"go\">func SetCookie(w ResponseWriter, cookie *Cookie)</pre> <p> SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped. </p> <h2 id=\"StatusText\">func StatusText  </h2> <pre data-language=\"go\">func StatusText(code int) string</pre> <p> StatusText returns a text for the HTTP status code. It returns the empty string if the code is unknown. </p> <h2 id=\"Client\">type Client  </h2> <pre data-language=\"go\">type Client struct {\n        // Transport specifies the mechanism by which individual\n        // HTTP requests are made.\n        // If nil, DefaultTransport is used.\n        Transport RoundTripper\n\n        // CheckRedirect specifies the policy for handling redirects.\n        // If CheckRedirect is not nil, the client calls it before\n        // following an HTTP redirect. The arguments req and via are\n        // the upcoming request and the requests made already, oldest\n        // first. If CheckRedirect returns an error, the Client's Get\n        // method returns both the previous Response (with its Body\n        // closed) and CheckRedirect's error (wrapped in a url.Error)\n        // instead of issuing the Request req.\n        // As a special case, if CheckRedirect returns ErrUseLastResponse,\n        // then the most recent response is returned with its body\n        // unclosed, along with a nil error.\n        //\n        // If CheckRedirect is nil, the Client uses its default policy,\n        // which is to stop after 10 consecutive requests.\n        CheckRedirect func(req *Request, via []*Request) error\n\n        // Jar specifies the cookie jar.\n        // If Jar is nil, cookies are not sent in requests and ignored\n        // in responses.\n        Jar CookieJar\n\n        // Timeout specifies a time limit for requests made by this\n        // Client. The timeout includes connection time, any\n        // redirects, and reading the response body. The timer remains\n        // running after Get, Head, Post, or Do return and will\n        // interrupt reading of the Response.Body.\n        //\n        // A Timeout of zero means no timeout.\n        //\n        // The Client cancels requests to the underlying Transport\n        // using the Request.Cancel mechanism. Requests passed\n        // to Client.Do may still set Request.Cancel; both will\n        // cancel the request.\n        //\n        // For compatibility, the Client will also use the deprecated\n        // CancelRequest method on Transport if found. New\n        // RoundTripper implementations should use Request.Cancel\n        // instead of implementing CancelRequest.\n        Timeout time.Duration\n}</pre> <p> A Client is an HTTP client. Its zero value (DefaultClient) is a usable client that uses DefaultTransport. </p> <p> The Client's Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines. </p> <p> A Client is higher-level than a RoundTripper (such as Transport) and additionally handles HTTP details such as cookies and redirects. </p> <h3 id=\"Client.Do\">func (*Client) <a href=\"https://golang.org/src/net/http/client.go?s=6486:6538#L171\">Do</a>  </h3> <pre data-language=\"go\">func (c *Client) Do(req *Request) (*Response, error)</pre> <p> Do sends an HTTP request and returns an HTTP response, following policy (such as redirects, cookies, auth) as configured on the client. </p> <p> An error is returned if caused by client policy (such as CheckRedirect), or failure to speak HTTP (such as a network connectivity problem). A non-2xx status code doesn't cause an error. </p> <p> If the returned error is nil, the Response will contain a non-nil Body which the user is expected to close. If the Body is not closed, the Client's underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent \"keep-alive\" request. </p> <p> The request Body, if non-nil, will be closed by the underlying Transport, even on errors. </p> <p> On error, any Response can be ignored. A non-nil Response with a non-nil error only occurs when CheckRedirect fails, and even then the returned Response.Body is already closed. </p> <p> Generally Get, Post, or PostForm will be used instead of Do. </p> <h3 id=\"Client.Get\">func (*Client) <a href=\"https://golang.org/src/net/http/client.go?s=12903:12963#L403\">Get</a>  </h3> <pre data-language=\"go\">func (c *Client) Get(url string) (resp *Response, err error)</pre> <p> Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect after calling the Client's CheckRedirect function: </p> <pre data-language=\"go\">301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n</pre> <p> An error is returned if the Client's CheckRedirect function fails or if there was an HTTP protocol error. A non-2xx response doesn't cause an error. </p> <p> When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. </p> <p> To make a request with custom headers, use NewRequest and Client.Do. </p> <h3 id=\"Client.Head\">func (*Client) <a href=\"https://golang.org/src/net/http/client.go?s=19493:19554#L620\">Head</a>  </h3> <pre data-language=\"go\">func (c *Client) Head(url string) (resp *Response, err error)</pre> <p> Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect after calling the Client's CheckRedirect function: </p> <pre data-language=\"go\">301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n</pre> <h3 id=\"Client.Post\">func (*Client) <a href=\"https://golang.org/src/net/http/client.go?s=17414:17508#L563\">Post</a>  </h3> <pre data-language=\"go\">func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error)</pre> <p> Post issues a POST to the specified URL. </p> <p> Caller should close resp.Body when done reading from it. </p> <p> If the provided body is an io.Closer, it is closed after the request. </p> <p> To set custom headers, use NewRequest and Client.Do. </p> <h3 id=\"Client.PostForm\">func (*Client) <a href=\"https://golang.org/src/net/http/client.go?s=18618:18700#L594\">PostForm</a>  </h3> <pre data-language=\"go\">func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)</pre> <p> PostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body. </p> <p> The Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and DefaultClient.Do. </p> <p> When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. </p> <h2 id=\"CloseNotifier\">type CloseNotifier  </h2> <pre data-language=\"go\">type CloseNotifier interface {\n        // CloseNotify returns a channel that receives at most a\n        // single value (true) when the client connection has gone\n        // away.\n        //\n        // CloseNotify may wait to notify until Request.Body has been\n        // fully read.\n        //\n        // After the Handler has returned, there is no guarantee\n        // that the channel receives a value.\n        //\n        // If the protocol is HTTP/1.1 and CloseNotify is called while\n        // processing an idempotent request (such a GET) while\n        // HTTP/1.1 pipelining is in use, the arrival of a subsequent\n        // pipelined request may cause a value to be sent on the\n        // returned channel. In practice HTTP/1.1 pipelining is not\n        // enabled in browsers and not seen often in the wild. If this\n        // is a problem, use HTTP/2 or only use CloseNotify on methods\n        // such as POST.\n        CloseNotify() &lt;-chan bool\n}</pre> <p> The CloseNotifier interface is implemented by ResponseWriters which allow detecting when the underlying connection has gone away. </p> <p> This mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready. </p> <h2 id=\"ConnState\">type ConnState  </h2> <pre data-language=\"go\">type ConnState int</pre> <p> A ConnState represents the state of a client connection to a server. It's used by the optional Server.ConnState hook. </p> <pre data-language=\"go\">const (\n        // StateNew represents a new connection that is expected to\n        // send a request immediately. Connections begin at this\n        // state and then transition to either StateActive or\n        // StateClosed.\n        StateNew ConnState = iota\n\n        // StateActive represents a connection that has read 1 or more\n        // bytes of a request. The Server.ConnState hook for\n        // StateActive fires before the request has entered a handler\n        // and doesn't fire again until the request has been\n        // handled. After the request is handled, the state\n        // transitions to StateClosed, StateHijacked, or StateIdle.\n        // For HTTP/2, StateActive fires on the transition from zero\n        // to one active request, and only transitions away once all\n        // active requests are complete. That means that ConnState\n        // cannot be used to do per-request work; ConnState only notes\n        // the overall state of the connection.\n        StateActive\n\n        // StateIdle represents a connection that has finished\n        // handling a request and is in the keep-alive state, waiting\n        // for a new request. Connections transition from StateIdle\n        // to either StateActive or StateClosed.\n        StateIdle\n\n        // StateHijacked represents a hijacked connection.\n        // This is a terminal state. It does not transition to StateClosed.\n        StateHijacked\n\n        // StateClosed represents a closed connection.\n        // This is a terminal state. Hijacked connections do not\n        // transition to StateClosed.\n        StateClosed\n)</pre> <h3 id=\"ConnState.String\">func (ConnState) <a href=\"https://golang.org/src/net/http/server.go?s=66572:66606#L2174\">String</a>  </h3> <pre data-language=\"go\">func (c ConnState) String() string</pre> <h2 id=\"Cookie\">type Cookie  </h2> <pre data-language=\"go\">type Cookie struct {\n        Name  string\n        Value string\n\n        Path       string    // optional\n        Domain     string    // optional\n        Expires    time.Time // optional\n        RawExpires string    // for reading cookies only\n\n        // MaxAge=0 means no 'Max-Age' attribute specified.\n        // MaxAge&lt;0 means delete cookie now, equivalently 'Max-Age: 0'\n        // MaxAge&gt;0 means Max-Age attribute present and given in seconds\n        MaxAge   int\n        Secure   bool\n        HttpOnly bool\n        Raw      string\n        Unparsed []string // Raw text of unparsed attribute-value pairs\n}</pre> <p> A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request. </p> <p> See <a href=\"http://tools.ietf.org/html/rfc6265\">http://tools.ietf.org/html/rfc6265</a> for details. </p> <h3 id=\"Cookie.String\">func (*Cookie) <a href=\"https://golang.org/src/net/http/cookie.go?s=3428:3460#L130\">String</a>  </h3> <pre data-language=\"go\">func (c *Cookie) String() string</pre> <p> String returns the serialization of the cookie for use in a Cookie header (if only Name and Value are set) or a Set-Cookie response header (if other fields are set). If c is nil or c.Name is invalid, the empty string is returned. </p> <h2 id=\"CookieJar\">type CookieJar  </h2> <pre data-language=\"go\">type CookieJar interface {\n        // SetCookies handles the receipt of the cookies in a reply for the\n        // given URL.  It may or may not choose to save the cookies, depending\n        // on the jar's policy and implementation.\n        SetCookies(u *url.URL, cookies []*Cookie)\n\n        // Cookies returns the cookies to send in a request for the given URL.\n        // It is up to the implementation to honor the standard cookie use\n        // restrictions such as in RFC 6265.\n        Cookies(u *url.URL) []*Cookie\n}</pre> <p> A CookieJar manages storage and use of cookies in HTTP requests. </p> <p> Implementations of CookieJar must be safe for concurrent use by multiple goroutines. </p> <p> The net/http/cookiejar package provides a CookieJar implementation. </p> <h2 id=\"Dir\">type Dir  </h2> <pre data-language=\"go\">type Dir string</pre> <p> A Dir implements FileSystem using the native file system restricted to a specific directory tree. </p> <p> While the FileSystem.Open method takes '/'-separated paths, a Dir's string value is a filename on the native file system, not a URL, so it is separated by filepath.Separator, which isn't necessarily '/'. </p> <p> An empty Dir is treated as \".\". </p> <h3 id=\"Dir.Open\">func (Dir) <a href=\"https://golang.org/src/net/http/fs.go?s=744:788#L26\">Open</a>  </h3> <pre data-language=\"go\">func (d Dir) Open(name string) (File, error)</pre> <h2 id=\"File\">type File  </h2> <pre data-language=\"go\">type File interface {\n        io.Closer\n        io.Reader\n        io.Seeker\n        Readdir(count int) ([]os.FileInfo, error)\n        Stat() (os.FileInfo, error)\n}</pre> <p> A File is returned by a FileSystem's Open method and can be served by the FileServer implementation. </p> <p> The methods should behave the same as those on an *os.File. </p> <h2 id=\"FileSystem\">type FileSystem  </h2> <pre data-language=\"go\">type FileSystem interface {\n        Open(name string) (File, error)\n}</pre> <p> A FileSystem implements access to a collection of named files. The elements in a file path are separated by slash ('/', U+002F) characters, regardless of host operating system convention. </p> <h2 id=\"Flusher\">type Flusher  </h2> <pre data-language=\"go\">type Flusher interface {\n        // Flush sends any buffered data to the client.\n        Flush()\n}</pre> <p> The Flusher interface is implemented by ResponseWriters that allow an HTTP handler to flush buffered data to the client. </p> <p> The default HTTP/1.x and HTTP/2 ResponseWriter implementations support Flusher, but ResponseWriter wrappers may not. Handlers should always test for this ability at runtime. </p> <p> Note that even for ResponseWriters that support Flush, if the client is connected through an HTTP proxy, the buffered data may not reach the client until the response completes. </p> <h2 id=\"Handler\">type Handler  </h2> <pre data-language=\"go\">type Handler interface {\n        ServeHTTP(ResponseWriter, *Request)\n}</pre> <p> A Handler responds to an HTTP request. </p> <p> ServeHTTP should write reply headers and data to the ResponseWriter and then return. Returning signals that the request is finished; it is not valid to use the ResponseWriter or read from the Request.Body after or concurrently with the completion of the ServeHTTP call. </p> <p> Depending on the HTTP client software, HTTP protocol version, and any intermediaries between the client and the Go server, it may not be possible to read from the Request.Body after writing to the ResponseWriter. Cautious handlers should read the Request.Body first, and then reply. </p> <p> Except for reading the body, handlers should not modify the provided Request. </p> <p> If ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the effect of the panic was isolated to the active request. It recovers the panic, logs a stack trace to the server error log, and hangs up the connection. </p> <h3 id=\"FileServer\">func <a href=\"https://golang.org/src/net/http/fs.go?s=15918:15958#L506\">FileServer</a>  </h3> <pre data-language=\"go\">func FileServer(root FileSystem) Handler</pre> <p> FileServer returns a handler that serves HTTP requests with the contents of the file system rooted at root. </p> <p> To use the operating system's file system implementation, use http.Dir: </p> <pre data-language=\"go\">http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n</pre> <p> As a special case, the returned file server redirects any request ending in \"/index.html\" to the same path, without the final \"index.html\". </p> <div id=\"example_FileServer\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\t// Simple static webserver:\n\tlog.Fatal(http.ListenAndServe(\":8080\", http.FileServer(http.Dir(\"/usr/share/doc\"))))\n}\n</pre> </div> </div> <div id=\"example_FileServer_stripPrefix\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (StripPrefix)</h2> <pre class=\"play\">package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc main() {\n\t// To serve a directory on disk (/tmp) under an alternate URL\n\t// path (/tmpfiles/), use StripPrefix to modify the request\n\t// URL's path before the FileServer sees it:\n\thttp.Handle(\"/tmpfiles/\", http.StripPrefix(\"/tmpfiles/\", http.FileServer(http.Dir(\"/tmp\"))))\n}\n</pre> </div> </div> <h3 id=\"NotFoundHandler\">func <a href=\"https://golang.org/src/net/http/server.go?s=51936:51966#L1737\">NotFoundHandler</a>  </h3> <pre data-language=\"go\">func NotFoundHandler() Handler</pre> <p> NotFoundHandler returns a simple request handler that replies to each request with a “404 page not found” reply. </p> <h3 id=\"RedirectHandler\">func <a href=\"https://golang.org/src/net/http/server.go?s=55390:55440#L1851\">RedirectHandler</a>  </h3> <pre data-language=\"go\">func RedirectHandler(url string, code int) Handler</pre> <p> RedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code. </p> <p> The provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther. </p> <h3 id=\"StripPrefix\">func <a href=\"https://golang.org/src/net/http/server.go?s=52275:52325#L1744\">StripPrefix</a>  </h3> <pre data-language=\"go\">func StripPrefix(prefix string, h Handler) Handler</pre> <p> StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path and invoking the handler h. StripPrefix handles a request for a path that doesn't begin with prefix by replying with an HTTP 404 not found error. </p> <div id=\"example_StripPrefix\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc main() {\n\t// To serve a directory on disk (/tmp) under an alternate URL\n\t// path (/tmpfiles/), use StripPrefix to modify the request\n\t// URL's path before the FileServer sees it:\n\thttp.Handle(\"/tmpfiles/\", http.StripPrefix(\"/tmpfiles/\", http.FileServer(http.Dir(\"/tmp\"))))\n}\n</pre> </div> </div> <h3 id=\"TimeoutHandler\">func <a href=\"https://golang.org/src/net/http/server.go?s=76596:76664#L2479\">TimeoutHandler</a>  </h3> <pre data-language=\"go\">func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler</pre> <p> TimeoutHandler returns a Handler that runs h with the given time limit. </p> <p> The new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. (If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its ResponseWriter will return ErrHandlerTimeout. </p> <p> TimeoutHandler buffers all Handler writes to memory and does not support the Hijacker or Flusher interfaces. </p> <h2 id=\"HandlerFunc\">type HandlerFunc  </h2> <pre data-language=\"go\">type HandlerFunc func(ResponseWriter, *Request)</pre> <p> The HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers. If f is a function with the appropriate signature, HandlerFunc(f) is a Handler that calls f. </p> <h3 id=\"HandlerFunc.ServeHTTP\">func (HandlerFunc) <a href=\"https://golang.org/src/net/http/server.go?s=51112:51172#L1715\">ServeHTTP</a>  </h3> <pre data-language=\"go\">func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)</pre> <p> ServeHTTP calls f(w, r). </p> <h2 id=\"Header\">type Header  </h2> <pre data-language=\"go\">type Header map[string][]string</pre> <p> A Header represents the key-value pairs in an HTTP header. </p> <h3 id=\"Header.Add\">func (Header) <a href=\"https://golang.org/src/net/http/header.go?s=487:525#L13\">Add</a>  </h3> <pre data-language=\"go\">func (h Header) Add(key, value string)</pre> <p> Add adds the key, value pair to the header. It appends to any existing values associated with key. </p> <h3 id=\"Header.Del\">func (Header) <a href=\"https://golang.org/src/net/http/header.go?s=1319:1350#L41\">Del</a>  </h3> <pre data-language=\"go\">func (h Header) Del(key string)</pre> <p> Del deletes the values associated with key. </p> <h3 id=\"Header.Get\">func (Header) <a href=\"https://golang.org/src/net/http/header.go?s=1013:1051#L28\">Get</a>  </h3> <pre data-language=\"go\">func (h Header) Get(key string) string</pre> <p> Get gets the first value associated with the given key. If there are no values associated with the key, Get returns \"\". To access multiple values of a key, access the map directly with CanonicalHeaderKey. </p> <h3 id=\"Header.Set\">func (Header) <a href=\"https://golang.org/src/net/http/header.go?s=711:749#L20\">Set</a>  </h3> <pre data-language=\"go\">func (h Header) Set(key, value string)</pre> <p> Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key. </p> <h3 id=\"Header.Write\">func (Header) <a href=\"https://golang.org/src/net/http/header.go?s=1431:1471#L46\">Write</a>  </h3> <pre data-language=\"go\">func (h Header) Write(w io.Writer) error</pre> <p> Write writes a header in wire format. </p> <h3 id=\"Header.WriteSubset\">func (Header) <a href=\"https://golang.org/src/net/http/header.go?s=3674:3745#L135\">WriteSubset</a>  </h3> <pre data-language=\"go\">func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error</pre> <p> WriteSubset writes a header in wire format. If exclude is not nil, keys where exclude[key] == true are not written. </p> <h2 id=\"Hijacker\">type Hijacker  </h2> <pre data-language=\"go\">type Hijacker interface {\n        // Hijack lets the caller take over the connection.\n        // After a call to Hijack(), the HTTP server library\n        // will not do anything else with the connection.\n        //\n        // It becomes the caller's responsibility to manage\n        // and close the connection.\n        //\n        // The returned net.Conn may have read or write deadlines\n        // already set, depending on the configuration of the\n        // Server. It is the caller's responsibility to set\n        // or clear those deadlines as needed.\n        Hijack() (net.Conn, *bufio.ReadWriter, error)\n}</pre> <p> The Hijacker interface is implemented by ResponseWriters that allow an HTTP handler to take over the connection. </p> <p> The default ResponseWriter for HTTP/1.x connections supports Hijacker, but HTTP/2 connections intentionally do not. ResponseWriter wrappers may also not support Hijacker. Handlers should always test for this ability at runtime. </p> <div id=\"example_Hijacker\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/hijack\", func(w http.ResponseWriter, r *http.Request) {\n\t\thj, ok := w.(http.Hijacker)\n\t\tif !ok {\n\t\t\thttp.Error(w, \"webserver doesn't support hijacking\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tconn, bufrw, err := hj.Hijack()\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\t// Don't forget to close the connection:\n\t\tdefer conn.Close()\n\t\tbufrw.WriteString(\"Now we're speaking raw TCP. Say hi: \")\n\t\tbufrw.Flush()\n\t\ts, err := bufrw.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error reading string: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Fprintf(bufrw, \"You said: %q\\nBye.\\n\", s)\n\t\tbufrw.Flush()\n\t})\n}\n</pre> </div> </div> <h2 id=\"ProtocolError\">type ProtocolError  </h2> <pre data-language=\"go\">type ProtocolError struct {\n        ErrorString string\n}</pre> <p> HTTP request parsing errors. </p> <h3 id=\"ProtocolError.Error\">func (*ProtocolError) <a href=\"https://golang.org/src/net/http/request.go?s=752:792#L32\">Error</a>  </h3> <pre data-language=\"go\">func (err *ProtocolError) Error() string</pre> <h2 id=\"Request\">type Request  </h2> <pre data-language=\"go\">type Request struct {\n        // Method specifies the HTTP method (GET, POST, PUT, etc.).\n        // For client requests an empty string means GET.\n        Method string\n\n        // URL specifies either the URI being requested (for server\n        // requests) or the URL to access (for client requests).\n        //\n        // For server requests the URL is parsed from the URI\n        // supplied on the Request-Line as stored in RequestURI.  For\n        // most requests, fields other than Path and RawQuery will be\n        // empty. (See RFC 2616, Section 5.1.2)\n        //\n        // For client requests, the URL's Host specifies the server to\n        // connect to, while the Request's Host field optionally\n        // specifies the Host header value to send in the HTTP\n        // request.\n        URL *url.URL\n\n        // The protocol version for incoming server requests.\n        //\n        // For client requests these fields are ignored. The HTTP\n        // client code always uses either HTTP/1.1 or HTTP/2.\n        // See the docs on Transport for details.\n        Proto      string // \"HTTP/1.0\"\n        ProtoMajor int    // 1\n        ProtoMinor int    // 0\n\n        // Header contains the request header fields either received\n        // by the server or to be sent by the client.\n        //\n        // If a server received a request with header lines,\n        //\n        //\tHost: example.com\n        //\taccept-encoding: gzip, deflate\n        //\tAccept-Language: en-us\n        //\tfOO: Bar\n        //\tfoo: two\n        //\n        // then\n        //\n        //\tHeader = map[string][]string{\n        //\t\t\"Accept-Encoding\": {\"gzip, deflate\"},\n        //\t\t\"Accept-Language\": {\"en-us\"},\n        //\t\t\"Foo\": {\"Bar\", \"two\"},\n        //\t}\n        //\n        // For incoming requests, the Host header is promoted to the\n        // Request.Host field and removed from the Header map.\n        //\n        // HTTP defines that header names are case-insensitive. The\n        // request parser implements this by using CanonicalHeaderKey,\n        // making the first character and any characters following a\n        // hyphen uppercase and the rest lowercase.\n        //\n        // For client requests, certain headers such as Content-Length\n        // and Connection are automatically written when needed and\n        // values in Header may be ignored. See the documentation\n        // for the Request.Write method.\n        Header Header\n\n        // Body is the request's body.\n        //\n        // For client requests a nil body means the request has no\n        // body, such as a GET request. The HTTP Client's Transport\n        // is responsible for calling the Close method.\n        //\n        // For server requests the Request Body is always non-nil\n        // but will return EOF immediately when no body is present.\n        // The Server will close the request body. The ServeHTTP\n        // Handler does not need to.\n        Body io.ReadCloser\n\n        // ContentLength records the length of the associated content.\n        // The value -1 indicates that the length is unknown.\n        // Values &gt;= 0 indicate that the given number of bytes may\n        // be read from Body.\n        // For client requests, a value of 0 means unknown if Body is not nil.\n        ContentLength int64\n\n        // TransferEncoding lists the transfer encodings from outermost to\n        // innermost. An empty list denotes the \"identity\" encoding.\n        // TransferEncoding can usually be ignored; chunked encoding is\n        // automatically added and removed as necessary when sending and\n        // receiving requests.\n        TransferEncoding []string\n\n        // Close indicates whether to close the connection after\n        // replying to this request (for servers) or after sending this\n        // request and reading its response (for clients).\n        //\n        // For server requests, the HTTP server handles this automatically\n        // and this field is not needed by Handlers.\n        //\n        // For client requests, setting this field prevents re-use of\n        // TCP connections between requests to the same hosts, as if\n        // Transport.DisableKeepAlives were set.\n        Close bool\n\n        // For server requests Host specifies the host on which the\n        // URL is sought. Per RFC 2616, this is either the value of\n        // the \"Host\" header or the host name given in the URL itself.\n        // It may be of the form \"host:port\".\n        //\n        // For client requests Host optionally overrides the Host\n        // header to send. If empty, the Request.Write method uses\n        // the value of URL.Host.\n        Host string\n\n        // Form contains the parsed form data, including both the URL\n        // field's query parameters and the POST or PUT form data.\n        // This field is only available after ParseForm is called.\n        // The HTTP client ignores Form and uses Body instead.\n        Form url.Values\n\n        // PostForm contains the parsed form data from POST, PATCH,\n        // or PUT body parameters.\n        //\n        // This field is only available after ParseForm is called.\n        // The HTTP client ignores PostForm and uses Body instead.\n        PostForm url.Values\n\n        // MultipartForm is the parsed multipart form, including file uploads.\n        // This field is only available after ParseMultipartForm is called.\n        // The HTTP client ignores MultipartForm and uses Body instead.\n        MultipartForm *multipart.Form\n\n        // Trailer specifies additional headers that are sent after the request\n        // body.\n        //\n        // For server requests the Trailer map initially contains only the\n        // trailer keys, with nil values. (The client declares which trailers it\n        // will later send.)  While the handler is reading from Body, it must\n        // not reference Trailer. After reading from Body returns EOF, Trailer\n        // can be read again and will contain non-nil values, if they were sent\n        // by the client.\n        //\n        // For client requests Trailer must be initialized to a map containing\n        // the trailer keys to later send. The values may be nil or their final\n        // values. The ContentLength must be 0 or -1, to send a chunked request.\n        // After the HTTP request is sent the map values can be updated while\n        // the request body is read. Once the body returns EOF, the caller must\n        // not mutate Trailer.\n        //\n        // Few HTTP clients, servers, or proxies support HTTP trailers.\n        Trailer Header\n\n        // RemoteAddr allows HTTP servers and other software to record\n        // the network address that sent the request, usually for\n        // logging. This field is not filled in by ReadRequest and\n        // has no defined format. The HTTP server in this package\n        // sets RemoteAddr to an \"IP:port\" address before invoking a\n        // handler.\n        // This field is ignored by the HTTP client.\n        RemoteAddr string\n\n        // RequestURI is the unmodified Request-URI of the\n        // Request-Line (RFC 2616, Section 5.1) as sent by the client\n        // to a server. Usually the URL field should be used instead.\n        // It is an error to set this field in an HTTP client request.\n        RequestURI string\n\n        // TLS allows HTTP servers and other software to record\n        // information about the TLS connection on which the request\n        // was received. This field is not filled in by ReadRequest.\n        // The HTTP server in this package sets the field for\n        // TLS-enabled connections before invoking a handler;\n        // otherwise it leaves the field nil.\n        // This field is ignored by the HTTP client.\n        TLS *tls.ConnectionState\n\n        // Cancel is an optional channel whose closure indicates that the client\n        // request should be regarded as canceled. Not all implementations of\n        // RoundTripper may support Cancel.\n        //\n        // For server requests, this field is not applicable.\n        //\n        // Deprecated: Use the Context and WithContext methods\n        // instead. If a Request's Cancel field and context are both\n        // set, it is undefined whether Cancel is respected.\n        Cancel &lt;-chan struct{}\n\n        // Response is the redirect response which caused this request\n        // to be created. This field is only populated during client\n        // redirects.\n        Response *Response\n        // contains filtered or unexported fields\n}</pre> <p> A Request represents an HTTP request received by a server or to be sent by a client. </p> <p> The field semantics differ slightly between client and server usage. In addition to the notes on the fields below, see the documentation for Request.Write and RoundTripper. </p> <h3 id=\"NewRequest\">func <a href=\"https://golang.org/src/net/http/request.go?s=21674:21746#L656\">NewRequest</a>  </h3> <pre data-language=\"go\">func NewRequest(method, urlStr string, body io.Reader) (*Request, error)</pre> <p> NewRequest returns a new Request given a method, URL, and optional body. </p> <p> If the provided body is also an io.Closer, the returned Request.Body is set to body and will be closed by the Client methods Do, Post, and PostForm, and Transport.RoundTrip. </p> <p> NewRequest returns a Request suitable for use with Client.Do or Transport.RoundTrip. To create a request for use with testing a Server Handler use either ReadRequest or manually update the Request fields. See the Request type's documentation for the difference between inbound and outbound request fields. </p> <h3 id=\"ReadRequest\">func <a href=\"https://golang.org/src/net/http/request.go?s=24678:24729#L767\">ReadRequest</a>  </h3> <pre data-language=\"go\">func ReadRequest(b *bufio.Reader) (*Request, error)</pre> <p> ReadRequest reads and parses an incoming request from b. </p> <h3 id=\"Request.AddCookie\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=11610:11648#L323\">AddCookie</a>  </h3> <pre data-language=\"go\">func (r *Request) AddCookie(c *Cookie)</pre> <p> AddCookie adds a cookie to the request. Per RFC 6265 section 5.4, AddCookie does not attach more than one Cookie header field. That means all cookies, if any, are written into the same line, separated by semicolon. </p> <h3 id=\"Request.BasicAuth\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=22944:23010#L703\">BasicAuth</a>  </h3> <pre data-language=\"go\">func (r *Request) BasicAuth() (username, password string, ok bool)</pre> <p> BasicAuth returns the username and password provided in the request's Authorization header, if the request uses HTTP Basic Authentication. See RFC 2617, Section 2. </p> <h3 id=\"Request.Context\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=10070:10113#L271\">Context</a>  </h3> <pre data-language=\"go\">func (r *Request) Context() context.Context</pre> <p> Context returns the request's context. To change the context, use WithContext. </p> <p> The returned context is always non-nil; it defaults to the background context. </p> <p> For outgoing client requests, the context controls cancelation. </p> <p> For incoming server requests, the context is canceled when the ServeHTTP method returns. For its associated values, see ServerContextKey and LocalAddrContextKey. </p> <h3 id=\"Request.Cookie\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=11230:11284#L312\">Cookie</a>  </h3> <pre data-language=\"go\">func (r *Request) Cookie(name string) (*Cookie, error)</pre> <p> Cookie returns the named cookie provided in the request or ErrNoCookie if not found. </p> <h3 id=\"Request.Cookies\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=10916:10953#L303\">Cookies</a>  </h3> <pre data-language=\"go\">func (r *Request) Cookies() []*Cookie</pre> <p> Cookies parses and returns the HTTP cookies sent with the request. </p> <h3 id=\"Request.FormFile\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=34318:34403#L1118\">FormFile</a>  </h3> <pre data-language=\"go\">func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)</pre> <p> FormFile returns the first file for the provided form key. FormFile calls ParseMultipartForm and ParseForm if necessary. </p> <h3 id=\"Request.FormValue\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=33490:33536#L1091\">FormValue</a>  </h3> <pre data-language=\"go\">func (r *Request) FormValue(key string) string</pre> <p> FormValue returns the first value for the named component of the query. POST and PUT body parameters take precedence over URL query string values. FormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, FormValue returns the empty string. To access multiple values of the same key, call ParseForm and then inspect Request.Form directly. </p> <h3 id=\"Request.MultipartReader\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=12947:13009#L356\">MultipartReader</a>  </h3> <pre data-language=\"go\">func (r *Request) MultipartReader() (*multipart.Reader, error)</pre> <p> MultipartReader returns a MIME multipart reader if this is a multipart/form-data POST request, else returns nil and an error. Use this function instead of ParseMultipartForm to process the request body as a stream. </p> <h3 id=\"Request.ParseForm\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=31289:31324#L1005\">ParseForm</a>  </h3> <pre data-language=\"go\">func (r *Request) ParseForm() error</pre> <p> ParseForm parses the raw query from the URL and updates r.Form. </p> <p> For POST or PUT requests, it also parses the request body as a form and put the results into both r.PostForm and r.Form. POST and PUT body parameters take precedence over URL query string values in r.Form. </p> <p> If the request Body's size has not already been limited by MaxBytesReader, the size is capped at 10MB. </p> <p> ParseMultipartForm calls ParseForm automatically. It is idempotent. </p> <h3 id=\"Request.ParseMultipartForm\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=32344:32403#L1046\">ParseMultipartForm</a>  </h3> <pre data-language=\"go\">func (r *Request) ParseMultipartForm(maxMemory int64) error</pre> <p> ParseMultipartForm parses a request body as multipart/form-data. The whole request body is parsed and up to a total of maxMemory bytes of its file parts are stored in memory, with the remainder stored on disk in temporary files. ParseMultipartForm calls ParseForm if necessary. After one call to ParseMultipartForm, subsequent calls have no effect. </p> <h3 id=\"Request.PostFormValue\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=33997:34047#L1106\">PostFormValue</a>  </h3> <pre data-language=\"go\">func (r *Request) PostFormValue(key string) string</pre> <p> PostFormValue returns the first value for the named component of the POST or PUT request body. URL query parameters are ignored. PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, PostFormValue returns the empty string. </p> <h3 id=\"Request.ProtoAtLeast\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=10559:10612#L292\">ProtoAtLeast</a>  </h3> <pre data-language=\"go\">func (r *Request) ProtoAtLeast(major, minor int) bool</pre> <p> ProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor. </p> <h3 id=\"Request.Referer\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=12318:12352#L340\">Referer</a>  </h3> <pre data-language=\"go\">func (r *Request) Referer() string</pre> <p> Referer returns the referring URL, if sent in the request. </p> <p> Referer is misspelled as in the request itself, a mistake from the earliest days of HTTP. This value can also be fetched from the Header map as Header[\"Referer\"]; the benefit of making it available as a method is that the compiler can diagnose programs that use the alternate (correct English) spelling req.Referrer() but cannot diagnose programs that use Header[\"Referrer\"]. </p> <h3 id=\"Request.SetBasicAuth\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=23832:23889#L735\">SetBasicAuth</a>  </h3> <pre data-language=\"go\">func (r *Request) SetBasicAuth(username, password string)</pre> <p> SetBasicAuth sets the request's Authorization header to use HTTP Basic Authentication with the provided username and password. </p> <p> With HTTP Basic Authentication the provided username and password are not encrypted. </p> <h3 id=\"Request.UserAgent\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=10769:10805#L298\">UserAgent</a>  </h3> <pre data-language=\"go\">func (r *Request) UserAgent() string</pre> <p> UserAgent returns the client's User-Agent, if sent in the request. </p> <h3 id=\"Request.WithContext\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=10298:10357#L280\">WithContext</a>  </h3> <pre data-language=\"go\">func (r *Request) WithContext(ctx context.Context) *Request</pre> <p> WithContext returns a shallow copy of r with its context changed to ctx. The provided ctx must be non-nil. </p> <h3 id=\"Request.Write\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=14822:14864#L416\">Write</a>  </h3> <pre data-language=\"go\">func (r *Request) Write(w io.Writer) error</pre> <p> Write writes an HTTP/1.1 request, which is the header and body, in wire format. This method consults the following fields of the request: </p> <pre data-language=\"go\">Host\nURL\nMethod (defaults to \"GET\")\nHeader\nContentLength\nTransferEncoding\nBody\n</pre> <p> If Body is present, Content-Length is &lt;= 0 and TransferEncoding hasn't been set to \"identity\", Write adds \"Transfer-Encoding: chunked\" to the header. Body is closed after it is sent. </p> <h3 id=\"Request.WriteProxy\">func (*Request) <a href=\"https://golang.org/src/net/http/request.go?s=15261:15308#L426\">WriteProxy</a>  </h3> <pre data-language=\"go\">func (r *Request) WriteProxy(w io.Writer) error</pre> <p> WriteProxy is like Write but writes the request in the form expected by an HTTP proxy. In particular, WriteProxy writes the initial Request-URI line of the request with an absolute URI, per section 5.1.2 of RFC 2616, including the scheme and host. In either case, WriteProxy also writes a Host header, using either r.Host or r.URL.Host. </p> <h2 id=\"Response\">type Response  </h2> <pre data-language=\"go\">type Response struct {\n        Status     string // e.g. \"200 OK\"\n        StatusCode int    // e.g. 200\n        Proto      string // e.g. \"HTTP/1.0\"\n        ProtoMajor int    // e.g. 1\n        ProtoMinor int    // e.g. 0\n\n        // Header maps header keys to values. If the response had multiple\n        // headers with the same key, they may be concatenated, with comma\n        // delimiters.  (Section 4.2 of RFC 2616 requires that multiple headers\n        // be semantically equivalent to a comma-delimited sequence.) Values\n        // duplicated by other fields in this struct (e.g., ContentLength) are\n        // omitted from Header.\n        //\n        // Keys in the map are canonicalized (see CanonicalHeaderKey).\n        Header Header\n\n        // Body represents the response body.\n        //\n        // The http Client and Transport guarantee that Body is always\n        // non-nil, even on responses without a body or responses with\n        // a zero-length body. It is the caller's responsibility to\n        // close Body. The default HTTP client's Transport does not\n        // attempt to reuse HTTP/1.0 or HTTP/1.1 TCP connections\n        // (\"keep-alive\") unless the Body is read to completion and is\n        // closed.\n        //\n        // The Body is automatically dechunked if the server replied\n        // with a \"chunked\" Transfer-Encoding.\n        Body io.ReadCloser\n\n        // ContentLength records the length of the associated content. The\n        // value -1 indicates that the length is unknown. Unless Request.Method\n        // is \"HEAD\", values &gt;= 0 indicate that the given number of bytes may\n        // be read from Body.\n        ContentLength int64\n\n        // Contains transfer encodings from outer-most to inner-most. Value is\n        // nil, means that \"identity\" encoding is used.\n        TransferEncoding []string\n\n        // Close records whether the header directed that the connection be\n        // closed after reading Body. The value is advice for clients: neither\n        // ReadResponse nor Response.Write ever closes a connection.\n        Close bool\n\n        // Uncompressed reports whether the response was sent compressed but\n        // was decompressed by the http package. When true, reading from\n        // Body yields the uncompressed content instead of the compressed\n        // content actually set from the server, ContentLength is set to -1,\n        // and the \"Content-Length\" and \"Content-Encoding\" fields are deleted\n        // from the responseHeader. To get the original response from\n        // the server, set Transport.DisableCompression to true.\n        Uncompressed bool\n\n        // Trailer maps trailer keys to values in the same\n        // format as Header.\n        //\n        // The Trailer initially contains only nil values, one for\n        // each key specified in the server's \"Trailer\" header\n        // value. Those values are not added to Header.\n        //\n        // Trailer must not be accessed concurrently with Read calls\n        // on the Body.\n        //\n        // After Body.Read has returned io.EOF, Trailer will contain\n        // any trailer values sent by the server.\n        Trailer Header\n\n        // Request is the request that was sent to obtain this Response.\n        // Request's Body is nil (having already been consumed).\n        // This is only populated for Client requests.\n        Request *Request\n\n        // TLS contains information about the TLS connection on which the\n        // response was received. It is nil for unencrypted responses.\n        // The pointer is shared between responses and should not be\n        // modified.\n        TLS *tls.ConnectionState\n}</pre> <p> Response represents the response from an HTTP request. </p> <h3 id=\"Get\">func <a href=\"https://golang.org/src/net/http/client.go?s=12173:12221#L382\">Get</a>  </h3> <pre data-language=\"go\">func Get(url string) (resp *Response, err error)</pre> <p> Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects: </p> <pre data-language=\"go\">301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n</pre> <p> An error is returned if there were too many redirects or if there was an HTTP protocol error. A non-2xx response doesn't cause an error. </p> <p> When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. </p> <p> Get is a wrapper around DefaultClient.Get. </p> <p> To make a request with custom headers, use NewRequest and DefaultClient.Do. </p> <div id=\"example_Get\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tres, err := http.Get(\"http://www.google.com/robots.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\trobots, err := ioutil.ReadAll(res.Body)\n\tres.Body.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"%s\", robots)\n}\n</pre> </div> </div> <h3 id=\"Head\">func <a href=\"https://golang.org/src/net/http/client.go?s=19118:19167#L608\">Head</a>  </h3> <pre data-language=\"go\">func Head(url string) (resp *Response, err error)</pre> <p> Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect, up to a maximum of 10 redirects: </p> <pre data-language=\"go\">301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n</pre> <p> Head is a wrapper around DefaultClient.Head </p> <h3 id=\"Post\">func <a href=\"https://golang.org/src/net/http/client.go?s=17033:17115#L551\">Post</a>  </h3> <pre data-language=\"go\">func Post(url string, bodyType string, body io.Reader) (resp *Response, err error)</pre> <p> Post issues a POST to the specified URL. </p> <p> Caller should close resp.Body when done reading from it. </p> <p> If the provided body is an io.Closer, it is closed after the request. </p> <p> Post is a wrapper around DefaultClient.Post. </p> <p> To set custom headers, use NewRequest and DefaultClient.Do. </p> <h3 id=\"PostForm\">func <a href=\"https://golang.org/src/net/http/client.go?s=18126:18196#L582\">PostForm</a>  </h3> <pre data-language=\"go\">func PostForm(url string, data url.Values) (resp *Response, err error)</pre> <p> PostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body. </p> <p> The Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and DefaultClient.Do. </p> <p> When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. </p> <p> PostForm is a wrapper around DefaultClient.PostForm. </p> <h3 id=\"ReadResponse\">func <a href=\"https://golang.org/src/net/http/response.go?s=4845:4912#L131\">ReadResponse</a>  </h3> <pre data-language=\"go\">func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)</pre> <p> ReadResponse reads and returns an HTTP response from r. The req parameter optionally specifies the Request that corresponds to this Response. If nil, a GET request is assumed. Clients must call resp.Body.Close when finished reading resp.Body. After that call, clients can inspect resp.Trailer to find key/value pairs included in the response trailer. </p> <h3 id=\"Response.Cookies\">func (*Response) <a href=\"https://golang.org/src/net/http/response.go?s=3779:3817#L102\">Cookies</a>  </h3> <pre data-language=\"go\">func (r *Response) Cookies() []*Cookie</pre> <p> Cookies parses and returns the cookies set in the Set-Cookie headers. </p> <h3 id=\"Response.Location\">func (*Response) <a href=\"https://golang.org/src/net/http/response.go?s=4240:4287#L114\">Location</a>  </h3> <pre data-language=\"go\">func (r *Response) Location() (*url.URL, error)</pre> <p> Location returns the URL of the response's \"Location\" header, if present. Relative redirects are resolved relative to the Response's Request. ErrNoLocation is returned if no Location header is present. </p> <h3 id=\"Response.ProtoAtLeast\">func (*Response) <a href=\"https://golang.org/src/net/http/response.go?s=6536:6590#L201\">ProtoAtLeast</a>  </h3> <pre data-language=\"go\">func (r *Response) ProtoAtLeast(major, minor int) bool</pre> <p> ProtoAtLeast reports whether the HTTP protocol used in the response is at least major.minor. </p> <h3 id=\"Response.Write\">func (*Response) <a href=\"https://golang.org/src/net/http/response.go?s=7128:7171#L222\">Write</a>  </h3> <pre data-language=\"go\">func (r *Response) Write(w io.Writer) error</pre> <p> Write writes r to w in the HTTP/1.x server response format, including the status line, headers, body, and optional trailer. </p> <p> This method consults the following fields of the response r: </p> <pre data-language=\"go\">StatusCode\nProtoMajor\nProtoMinor\nRequest.Method\nTransferEncoding\nTrailer\nBody\nContentLength\nHeader, values for non-canonical keys will have unpredictable behavior\n</pre> <p> The Response Body is closed after it is sent. </p> <h2 id=\"ResponseWriter\">type ResponseWriter  </h2> <pre data-language=\"go\">type ResponseWriter interface {\n        // Header returns the header map that will be sent by\n        // WriteHeader. Changing the header after a call to\n        // WriteHeader (or Write) has no effect unless the modified\n        // headers were declared as trailers by setting the\n        // \"Trailer\" header before the call to WriteHeader (see example).\n        // To suppress implicit response headers, set their value to nil.\n        Header() Header\n\n        // Write writes the data to the connection as part of an HTTP reply.\n        //\n        // If WriteHeader has not yet been called, Write calls\n        // WriteHeader(http.StatusOK) before writing the data. If the Header\n        // does not contain a Content-Type line, Write adds a Content-Type set\n        // to the result of passing the initial 512 bytes of written data to\n        // DetectContentType.\n        //\n        // Depending on the HTTP protocol version and the client, calling\n        // Write or WriteHeader may prevent future reads on the\n        // Request.Body. For HTTP/1.x requests, handlers should read any\n        // needed request body data before writing the response. Once the\n        // headers have been flushed (due to either an explicit Flusher.Flush\n        // call or writing enough data to trigger a flush), the request body\n        // may be unavailable. For HTTP/2 requests, the Go HTTP server permits\n        // handlers to continue to read the request body while concurrently\n        // writing the response. However, such behavior may not be supported\n        // by all HTTP/2 clients. Handlers should read before writing if\n        // possible to maximize compatibility.\n        Write([]byte) (int, error)\n\n        // WriteHeader sends an HTTP response header with status code.\n        // If WriteHeader is not called explicitly, the first call to Write\n        // will trigger an implicit WriteHeader(http.StatusOK).\n        // Thus explicit calls to WriteHeader are mainly used to\n        // send error codes.\n        WriteHeader(int)\n}</pre> <p> A ResponseWriter interface is used by an HTTP handler to construct an HTTP response. </p> <p> A ResponseWriter may not be used after the Handler.ServeHTTP method has returned. </p> <div id=\"example_ResponseWriter_trailers\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Trailers)</h2> <p>HTTP Trailers are a set of key/value pairs like headers that come after the HTTP response, instead of before. </p> <pre class=\"play\">package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/sendstrailers\", func(w http.ResponseWriter, req *http.Request) {\n\t\t// Before any call to WriteHeader or Write, declare\n\t\t// the trailers you will set during the HTTP\n\t\t// response. These three headers are actually sent in\n\t\t// the trailer.\n\t\tw.Header().Set(\"Trailer\", \"AtEnd1, AtEnd2\")\n\t\tw.Header().Add(\"Trailer\", \"AtEnd3\")\n\n\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\") // normal header\n\t\tw.WriteHeader(http.StatusOK)\n\n\t\tw.Header().Set(\"AtEnd1\", \"value 1\")\n\t\tio.WriteString(w, \"This HTTP response has both headers before this text and trailers at the end.\\n\")\n\t\tw.Header().Set(\"AtEnd2\", \"value 2\")\n\t\tw.Header().Set(\"AtEnd3\", \"value 3\") // These will appear as trailers.\n\t})\n}\n</pre> </div> </div> <h2 id=\"RoundTripper\">type RoundTripper  </h2> <pre data-language=\"go\">type RoundTripper interface {\n        // RoundTrip executes a single HTTP transaction, returning\n        // a Response for the provided Request.\n        //\n        // RoundTrip should not attempt to interpret the response. In\n        // particular, RoundTrip must return err == nil if it obtained\n        // a response, regardless of the response's HTTP status code.\n        // A non-nil err should be reserved for failure to obtain a\n        // response. Similarly, RoundTrip should not attempt to\n        // handle higher-level protocol details such as redirects,\n        // authentication, or cookies.\n        //\n        // RoundTrip should not modify the request, except for\n        // consuming and closing the Request's Body.\n        //\n        // RoundTrip must always close the body, including on errors,\n        // but depending on the implementation may do so in a separate\n        // goroutine even after RoundTrip returns. This means that\n        // callers wanting to reuse the body for subsequent requests\n        // must arrange to wait for the Close call before doing so.\n        //\n        // The Request's URL and Header fields must be initialized.\n        RoundTrip(*Request) (*Response, error)\n}</pre> <p> RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request. </p> <p> A RoundTripper must be safe for concurrent use by multiple goroutines. </p> <pre data-language=\"go\">var DefaultTransport RoundTripper = &amp;Transport{\n        Proxy: ProxyFromEnvironment,\n        DialContext: (&amp;net.Dialer{\n                Timeout:   30 * time.Second,\n                KeepAlive: 30 * time.Second,\n        }).DialContext,\n        MaxIdleConns:          100,\n        IdleConnTimeout:       90 * time.Second,\n        TLSHandshakeTimeout:   10 * time.Second,\n        ExpectContinueTimeout: 1 * time.Second,\n}</pre> <p> DefaultTransport is the default implementation of Transport and is used by DefaultClient. It establishes network connections as needed and caches them for reuse by subsequent calls. It uses HTTP proxies as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy) environment variables. </p> <h3 id=\"NewFileTransport\">func <a href=\"https://golang.org/src/net/http/filetransport.go?s=827:876#L20\">NewFileTransport</a>  </h3> <pre data-language=\"go\">func NewFileTransport(fs FileSystem) RoundTripper</pre> <p> NewFileTransport returns a new RoundTripper, serving the provided FileSystem. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request. </p> <p> The typical use case for NewFileTransport is to register the \"file\" protocol with a Transport, as in: </p> <pre data-language=\"go\">t := &amp;http.Transport{}\nt.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\nc := &amp;http.Client{Transport: t}\nres, err := c.Get(\"file:///etc/passwd\")\n...\n</pre> <h2 id=\"ServeMux\">type ServeMux  </h2> <pre data-language=\"go\">type ServeMux struct {\n        // contains filtered or unexported fields\n}</pre> <p> ServeMux is an HTTP request multiplexer. It matches the URL of each incoming request against a list of registered patterns and calls the handler for the pattern that most closely matches the URL. </p> <p> Patterns name fixed, rooted paths, like \"/favicon.ico\", or rooted subtrees, like \"/images/\" (note the trailing slash). Longer patterns take precedence over shorter ones, so that if there are handlers registered for both \"/images/\" and \"/images/thumbnails/\", the latter handler will be called for paths beginning \"/images/thumbnails/\" and the former will receive requests for any other paths in the \"/images/\" subtree. </p> <p> Note that since a pattern ending in a slash names a rooted subtree, the pattern \"/\" matches all paths not matched by other registered patterns, not just the URL with Path == \"/\". </p> <p> If a subtree has been registered and a request is received naming the subtree root without its trailing slash, ServeMux redirects that request to the subtree root (adding the trailing slash). This behavior can be overridden with a separate registration for the path without the trailing slash. For example, registering \"/images/\" causes ServeMux to redirect a request for \"/images\" to \"/images/\", unless \"/images\" has been registered separately. </p> <p> Patterns may optionally begin with a host name, restricting matches to URLs on that host only. Host-specific patterns take precedence over general patterns, so that a handler might register for the two patterns \"/codesearch\" and \"codesearch.google.com/\" without also taking over requests for \"<a href=\"http://www.google.com/\">http://www.google.com/</a>\". </p> <p> ServeMux also takes care of sanitizing the URL request path, redirecting any request containing . or .. elements or repeated slashes to an equivalent, cleaner URL. </p> <h3 id=\"NewServeMux\">func <a href=\"https://golang.org/src/net/http/server.go?s=57564:57592#L1903\">NewServeMux</a>  </h3> <pre data-language=\"go\">func NewServeMux() *ServeMux</pre> <p> NewServeMux allocates and returns a new ServeMux. </p> <h3 id=\"ServeMux.Handle\">func (*ServeMux) <a href=\"https://golang.org/src/net/http/server.go?s=60616:60676#L2017\">Handle</a>  </h3> <pre data-language=\"go\">func (mux *ServeMux) Handle(pattern string, handler Handler)</pre> <p> Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics. </p> <div id=\"example_ServeMux_Handle\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <p>Code:</p> <pre class=\"code\" data-language=\"go\">\n    mux := http.NewServeMux()\n    mux.Handle(\"/api/\", apiHandler{})\n    mux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n            // The \"/\" pattern matches everything, so we need to check\n            // that we're at the root here.\n            if req.URL.Path != \"/\" {\n                    http.NotFound(w, req)\n                    return\n            }\n            fmt.Fprintf(w, \"Welcome to the home page!\")\n    })\n</pre> </div> </div> <h3 id=\"ServeMux.HandleFunc\">func (*ServeMux) <a href=\"https://golang.org/src/net/http/server.go?s=61837:61924#L2059\">HandleFunc</a>  </h3> <pre data-language=\"go\">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</pre> <p> HandleFunc registers the handler function for the given pattern. </p> <h3 id=\"ServeMux.Handler\">func (*ServeMux) <a href=\"https://golang.org/src/net/http/server.go?s=59320:59388#L1969\">Handler</a>  </h3> <pre data-language=\"go\">func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)</pre> <p> Handler returns the handler to use for the given request, consulting r.Method, r.Host, and r.URL.Path. It always returns a non-nil handler. If the path is not in its canonical form, the handler will be an internally-generated handler that redirects to the canonical path. </p> <p> Handler also returns the registered pattern that matches the request or, in the case of internally-generated redirects, the pattern that will match after following the redirect. </p> <p> If there is no registered handler that applies to the request, Handler returns a “page not found” handler and an empty pattern. </p> <h3 id=\"ServeMux.ServeHTTP\">func (*ServeMux) <a href=\"https://golang.org/src/net/http/server.go?s=60248:60308#L2003\">ServeHTTP</a>  </h3> <pre data-language=\"go\">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</pre> <p> ServeHTTP dispatches the request to the handler whose pattern most closely matches the request URL. </p> <h2 id=\"Server\">type Server  </h2> <pre data-language=\"go\">type Server struct {\n        Addr         string        // TCP address to listen on, \":http\" if empty\n        Handler      Handler       // handler to invoke, http.DefaultServeMux if nil\n        ReadTimeout  time.Duration // maximum duration before timing out read of the request\n        WriteTimeout time.Duration // maximum duration before timing out write of the response\n        TLSConfig    *tls.Config   // optional TLS config, used by ListenAndServeTLS\n\n        // MaxHeaderBytes controls the maximum number of bytes the\n        // server will read parsing the request header's keys and\n        // values, including the request line. It does not limit the\n        // size of the request body.\n        // If zero, DefaultMaxHeaderBytes is used.\n        MaxHeaderBytes int\n\n        // TLSNextProto optionally specifies a function to take over\n        // ownership of the provided TLS connection when an NPN/ALPN\n        // protocol upgrade has occurred. The map key is the protocol\n        // name negotiated. The Handler argument should be used to\n        // handle HTTP requests and will initialize the Request's TLS\n        // and RemoteAddr if not already set. The connection is\n        // automatically closed when the function returns.\n        // If TLSNextProto is nil, HTTP/2 support is enabled automatically.\n        TLSNextProto map[string]func(*Server, *tls.Conn, Handler)\n\n        // ConnState specifies an optional callback function that is\n        // called when a client connection changes state. See the\n        // ConnState type and associated constants for details.\n        ConnState func(net.Conn, ConnState)\n\n        // ErrorLog specifies an optional logger for errors accepting\n        // connections and unexpected behavior from handlers.\n        // If nil, logging goes to os.Stderr via the log package's\n        // standard logger.\n        ErrorLog *log.Logger\n        // contains filtered or unexported fields\n}</pre> <p> A Server defines parameters for running an HTTP server. The zero value for Server is a valid configuration. </p> <h3 id=\"Server.ListenAndServe\">func (*Server) <a href=\"https://golang.org/src/net/http/server.go?s=67356:67397#L2200\">ListenAndServe</a>  </h3> <pre data-language=\"go\">func (srv *Server) ListenAndServe() error</pre> <p> ListenAndServe listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives. If srv.Addr is blank, \":http\" is used. ListenAndServe always returns a non-nil error. </p> <h3 id=\"Server.ListenAndServeTLS\">func (*Server) <a href=\"https://golang.org/src/net/http/server.go?s=73569:73637#L2391\">ListenAndServeTLS</a>  </h3> <pre data-language=\"go\">func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error</pre> <p> ListenAndServeTLS listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming TLS connections. Accepted connections are configured to enable TCP keep-alives. </p> <p> Filenames containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates nor TLSConfig.GetCertificate are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. </p> <p> If srv.Addr is blank, \":https\" is used. </p> <p> ListenAndServeTLS always returns a non-nil error. </p> <h3 id=\"Server.Serve\">func (*Server) <a href=\"https://golang.org/src/net/http/server.go?s=69176:69222#L2246\">Serve</a>  </h3> <pre data-language=\"go\">func (srv *Server) Serve(l net.Listener) error</pre> <p> Serve accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines read requests and then call srv.Handler to reply to them. </p> <p> For HTTP/2 support, srv.TLSConfig should be initialized to the provided listener's TLS Config before calling Serve. If srv.TLSConfig is non-nil and doesn't include the string \"h2\" in Config.NextProtos, HTTP/2 support is not enabled. </p> <p> Serve always returns a non-nil error. </p> <h3 id=\"Server.SetKeepAlivesEnabled\">func (*Server) <a href=\"https://golang.org/src/net/http/server.go?s=70519:70566#L2295\">SetKeepAlivesEnabled</a>  </h3> <pre data-language=\"go\">func (srv *Server) SetKeepAlivesEnabled(v bool)</pre> <p> SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled. By default, keep-alives are always enabled. Only very resource-constrained environments or servers in the process of shutting down should disable them. </p> <h2 id=\"Transport\">type Transport  </h2> <pre data-language=\"go\">type Transport struct {\n\n        // Proxy specifies a function to return a proxy for a given\n        // Request. If the function returns a non-nil error, the\n        // request is aborted with the provided error.\n        // If Proxy is nil or returns a nil *URL, no proxy is used.\n        Proxy func(*Request) (*url.URL, error)\n\n        // DialContext specifies the dial function for creating unencrypted TCP connections.\n        // If DialContext is nil (and the deprecated Dial below is also nil),\n        // then the transport dials using package net.\n        DialContext func(ctx context.Context, network, addr string) (net.Conn, error)\n\n        // Dial specifies the dial function for creating unencrypted TCP connections.\n        //\n        // Deprecated: Use DialContext instead, which allows the transport\n        // to cancel dials as soon as they are no longer needed.\n        // If both are set, DialContext takes priority.\n        Dial func(network, addr string) (net.Conn, error)\n\n        // DialTLS specifies an optional dial function for creating\n        // TLS connections for non-proxied HTTPS requests.\n        //\n        // If DialTLS is nil, Dial and TLSClientConfig are used.\n        //\n        // If DialTLS is set, the Dial hook is not used for HTTPS\n        // requests and the TLSClientConfig and TLSHandshakeTimeout\n        // are ignored. The returned net.Conn is assumed to already be\n        // past the TLS handshake.\n        DialTLS func(network, addr string) (net.Conn, error)\n\n        // TLSClientConfig specifies the TLS configuration to use with\n        // tls.Client. If nil, the default configuration is used.\n        TLSClientConfig *tls.Config\n\n        // TLSHandshakeTimeout specifies the maximum amount of time waiting to\n        // wait for a TLS handshake. Zero means no timeout.\n        TLSHandshakeTimeout time.Duration\n\n        // DisableKeepAlives, if true, prevents re-use of TCP connections\n        // between different HTTP requests.\n        DisableKeepAlives bool\n\n        // DisableCompression, if true, prevents the Transport from\n        // requesting compression with an \"Accept-Encoding: gzip\"\n        // request header when the Request contains no existing\n        // Accept-Encoding value. If the Transport requests gzip on\n        // its own and gets a gzipped response, it's transparently\n        // decoded in the Response.Body. However, if the user\n        // explicitly requested gzip it is not automatically\n        // uncompressed.\n        DisableCompression bool\n\n        // MaxIdleConns controls the maximum number of idle (keep-alive)\n        // connections across all hosts. Zero means no limit.\n        MaxIdleConns int\n\n        // MaxIdleConnsPerHost, if non-zero, controls the maximum idle\n        // (keep-alive) connections to keep per-host. If zero,\n        // DefaultMaxIdleConnsPerHost is used.\n        MaxIdleConnsPerHost int\n\n        // IdleConnTimeout is the maximum amount of time an idle\n        // (keep-alive) connection will remain idle before closing\n        // itself.\n        // Zero means no limit.\n        IdleConnTimeout time.Duration\n\n        // ResponseHeaderTimeout, if non-zero, specifies the amount of\n        // time to wait for a server's response headers after fully\n        // writing the request (including its body, if any). This\n        // time does not include the time to read the response body.\n        ResponseHeaderTimeout time.Duration\n\n        // ExpectContinueTimeout, if non-zero, specifies the amount of\n        // time to wait for a server's first response headers after fully\n        // writing the request headers if the request has an\n        // \"Expect: 100-continue\" header. Zero means no timeout.\n        // This time does not include the time to send the request header.\n        ExpectContinueTimeout time.Duration\n\n        // TLSNextProto specifies how the Transport switches to an\n        // alternate protocol (such as HTTP/2) after a TLS NPN/ALPN\n        // protocol negotiation. If Transport dials an TLS connection\n        // with a non-empty protocol name and TLSNextProto contains a\n        // map entry for that key (such as \"h2\"), then the func is\n        // called with the request's authority (such as \"example.com\"\n        // or \"example.com:1234\") and the TLS connection. The function\n        // must return a RoundTripper that then handles the request.\n        // If TLSNextProto is nil, HTTP/2 support is enabled automatically.\n        TLSNextProto map[string]func(authority string, c *tls.Conn) RoundTripper\n\n        // MaxResponseHeaderBytes specifies a limit on how many\n        // response bytes are allowed in the server's response\n        // header.\n        //\n        // Zero means to use a default limit.\n        MaxResponseHeaderBytes int64\n        // contains filtered or unexported fields\n}</pre> <p> Transport is an implementation of RoundTripper that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT). </p> <p> By default, Transport caches connections for future re-use. This may leave many open connections when accessing many hosts. This behavior can be managed using Transport's CloseIdleConnections method and the MaxIdleConnsPerHost and DisableKeepAlives fields. </p> <p> Transports should be reused instead of created as needed. Transports are safe for concurrent use by multiple goroutines. </p> <p> A Transport is a low-level primitive for making HTTP and HTTPS requests. For high-level functionality, such as cookies and redirects, see Client. </p> <p> Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for HTTPS URLs, depending on whether the server supports HTTP/2. See the package docs for more about HTTP/2. </p> <h3 id=\"Transport.CancelRequest\">func (*Transport) <a href=\"https://golang.org/src/net/http/transport.go?s=17109:17156#L493\">CancelRequest</a>  </h3> <pre data-language=\"go\">func (t *Transport) CancelRequest(req *Request)</pre> <p> CancelRequest cancels an in-flight request by closing its connection. CancelRequest should only be called after RoundTrip has returned. </p> <p> Deprecated: Use Request.Cancel instead. CancelRequest cannot cancel HTTP/2 requests. </p> <h3 id=\"Transport.CloseIdleConnections\">func (*Transport) <a href=\"https://golang.org/src/net/http/transport.go?s=16476:16518#L469\">CloseIdleConnections</a>  </h3> <pre data-language=\"go\">func (t *Transport) CloseIdleConnections()</pre> <p> CloseIdleConnections closes any connections which were previously connected from previous requests but are now sitting idle in a \"keep-alive\" state. It does not interrupt any connections currently in use. </p> <h3 id=\"Transport.RegisterProtocol\">func (*Transport) <a href=\"https://golang.org/src/net/http/transport.go?s=15945:16013#L453\">RegisterProtocol</a>  </h3> <pre data-language=\"go\">func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)</pre> <p> RegisterProtocol registers a new protocol with scheme. The Transport will pass requests using the given scheme to rt. It is rt's responsibility to simulate HTTP request semantics. </p> <p> RegisterProtocol can be used by other packages to provide implementations of protocol schemes like \"ftp\" or \"file\". </p> <p> If rt.RoundTrip returns ErrSkipAltProtocol, the Transport will handle the RoundTrip itself for that one request, as if the protocol were not registered. </p> <h3 id=\"Transport.RoundTrip\">func (*Transport) <a href=\"https://golang.org/src/net/http/transport.go?s=11022:11084#L296\">RoundTrip</a>  </h3> <pre data-language=\"go\">func (t *Transport) RoundTrip(req *Request) (*Response, error)</pre> <p> RoundTrip implements the RoundTripper interface. </p> <p> For higher-level HTTP client support (such as handling of cookies and redirects), see Get, Post, and the Client type. </p> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"cgi/index\">cgi</a> </td> <td class=\"pkg-synopsis\"> Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"cookiejar/index\">cookiejar</a> </td> <td class=\"pkg-synopsis\"> Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"fcgi/index\">fcgi</a> </td> <td class=\"pkg-synopsis\"> Package fcgi implements the FastCGI protocol. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"httptest/index\">httptest</a> </td> <td class=\"pkg-synopsis\"> Package httptest provides utilities for HTTP testing. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"httptrace/index\">httptrace</a> </td> <td class=\"pkg-synopsis\"> Package httptrace provides mechanisms to trace the events within HTTP client requests. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"httputil/index\">httputil</a> </td> <td class=\"pkg-synopsis\"> Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"pprof/index\">pprof</a> </td> <td class=\"pkg-synopsis\"> Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/net/http/\" class=\"_attribution-link\">https://golang.org/pkg/net/http/</a>\n  </p>\n</div>\n","unicode/index":"<h1>Package unicode</h1>     <ul id=\"short-nav\">\n<li><code>import \"unicode\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n<li><a href=\"#pkg-examples\" class=\"examplesLink\">Examples</a></li>\n<li><a href=\"#pkg-subdirectories\">Subdirectories</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package unicode provides data and functions to test some properties of Unicode code points. </p> </div> </div> <div id=\"example__is\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example (Is)</h2> <p>Functions starting with \"Is\" can be used to inspect which table of range a rune belongs to. Note that runes may fit into more than one range. </p> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode\"\n)\n\nfunc main() {\n\n\t// constant with mixed type runes\n\tconst mixed = \"\\b5Ὂg̀9! ℃ᾭG\"\n\tfor _, c := range mixed {\n\t\tfmt.Printf(\"For %q:\\n\", c)\n\t\tif unicode.IsControl(c) {\n\t\t\tfmt.Println(\"\\tis control rune\")\n\t\t}\n\t\tif unicode.IsDigit(c) {\n\t\t\tfmt.Println(\"\\tis digit rune\")\n\t\t}\n\t\tif unicode.IsGraphic(c) {\n\t\t\tfmt.Println(\"\\tis graphic rune\")\n\t\t}\n\t\tif unicode.IsLetter(c) {\n\t\t\tfmt.Println(\"\\tis letter rune\")\n\t\t}\n\t\tif unicode.IsLower(c) {\n\t\t\tfmt.Println(\"\\tis lower case rune\")\n\t\t}\n\t\tif unicode.IsMark(c) {\n\t\t\tfmt.Println(\"\\tis mark rune\")\n\t\t}\n\t\tif unicode.IsNumber(c) {\n\t\t\tfmt.Println(\"\\tis number rune\")\n\t\t}\n\t\tif unicode.IsPrint(c) {\n\t\t\tfmt.Println(\"\\tis printable rune\")\n\t\t}\n\t\tif !unicode.IsPrint(c) {\n\t\t\tfmt.Println(\"\\tis not printable rune\")\n\t\t}\n\t\tif unicode.IsPunct(c) {\n\t\t\tfmt.Println(\"\\tis punct rune\")\n\t\t}\n\t\tif unicode.IsSpace(c) {\n\t\t\tfmt.Println(\"\\tis space rune\")\n\t\t}\n\t\tif unicode.IsSymbol(c) {\n\t\t\tfmt.Println(\"\\tis symbol rune\")\n\t\t}\n\t\tif unicode.IsTitle(c) {\n\t\t\tfmt.Println(\"\\tis title case rune\")\n\t\t}\n\t\tif unicode.IsUpper(c) {\n\t\t\tfmt.Println(\"\\tis upper case rune\")\n\t\t}\n\t}\n\n}\n</pre> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#In\">func In(r rune, ranges ...*RangeTable) bool</a></li>\n<li><a href=\"#Is\">func Is(rangeTab *RangeTable, r rune) bool</a></li>\n<li><a href=\"#IsControl\">func IsControl(r rune) bool</a></li>\n<li><a href=\"#IsDigit\">func IsDigit(r rune) bool</a></li>\n<li><a href=\"#IsGraphic\">func IsGraphic(r rune) bool</a></li>\n<li><a href=\"#IsLetter\">func IsLetter(r rune) bool</a></li>\n<li><a href=\"#IsLower\">func IsLower(r rune) bool</a></li>\n<li><a href=\"#IsMark\">func IsMark(r rune) bool</a></li>\n<li><a href=\"#IsNumber\">func IsNumber(r rune) bool</a></li>\n<li><a href=\"#IsOneOf\">func IsOneOf(ranges []*RangeTable, r rune) bool</a></li>\n<li><a href=\"#IsPrint\">func IsPrint(r rune) bool</a></li>\n<li><a href=\"#IsPunct\">func IsPunct(r rune) bool</a></li>\n<li><a href=\"#IsSpace\">func IsSpace(r rune) bool</a></li>\n<li><a href=\"#IsSymbol\">func IsSymbol(r rune) bool</a></li>\n<li><a href=\"#IsTitle\">func IsTitle(r rune) bool</a></li>\n<li><a href=\"#IsUpper\">func IsUpper(r rune) bool</a></li>\n<li><a href=\"#SimpleFold\">func SimpleFold(r rune) rune</a></li>\n<li><a href=\"#To\">func To(_case int, r rune) rune</a></li>\n<li><a href=\"#ToLower\">func ToLower(r rune) rune</a></li>\n<li><a href=\"#ToTitle\">func ToTitle(r rune) rune</a></li>\n<li><a href=\"#ToUpper\">func ToUpper(r rune) rune</a></li>\n<li><a href=\"#CaseRange\">type CaseRange</a></li>\n<li><a href=\"#Range16\">type Range16</a></li>\n<li><a href=\"#Range32\">type Range32</a></li>\n<li><a href=\"#RangeTable\">type RangeTable</a></li>\n<li><a href=\"#SpecialCase\">type SpecialCase</a></li>\n<li> <a href=\"#SpecialCase.ToLower\">func (special SpecialCase) ToLower(r rune) rune</a>\n</li>\n<li> <a href=\"#SpecialCase.ToTitle\">func (special SpecialCase) ToTitle(r rune) rune</a>\n</li>\n<li> <a href=\"#SpecialCase.ToUpper\">func (special SpecialCase) ToUpper(r rune) rune</a>\n</li>\n<li><a href=\"#pkg-note-BUG\">Bugs</a></li>\n</ul> <div id=\"pkg-examples\"> <h4>Examples</h4> <dl> <dd><a class=\"exampleLink\" href=\"#example_SimpleFold\">SimpleFold</a></dd> <dd><a class=\"exampleLink\" href=\"#example_SpecialCase\">SpecialCase</a></dd> <dd><a class=\"exampleLink\" href=\"#example_To\">To</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ToLower\">ToLower</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ToTitle\">ToTitle</a></dd> <dd><a class=\"exampleLink\" href=\"#example_ToUpper\">ToUpper</a></dd> <dd><a class=\"exampleLink\" href=\"#example__is\">Package (Is)</a></dd> </dl> </div> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/unicode/casetables.go\">casetables.go</a> <a href=\"https://golang.org/src/unicode/digit.go\">digit.go</a> <a href=\"https://golang.org/src/unicode/graphic.go\">graphic.go</a> <a href=\"https://golang.org/src/unicode/letter.go\">letter.go</a> <a href=\"https://golang.org/src/unicode/tables.go\">tables.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        MaxRune         = '\\U0010FFFF' // Maximum valid Unicode code point.\n        ReplacementChar = '\\uFFFD'     // Represents invalid code points.\n        MaxASCII        = '\\u007F'     // maximum ASCII value.\n        MaxLatin1       = '\\u00FF'     // maximum Latin-1 value.\n)</pre> <pre data-language=\"go\">const (\n        UpperCase = iota\n        LowerCase\n        TitleCase\n        MaxCase\n)</pre> <p> Indices into the Delta arrays inside CaseRanges for case mapping. </p> <pre data-language=\"go\">const (\n        UpperLower = MaxRune + 1 // (Cannot be a valid delta.)\n)</pre> <p> If the Delta field of a CaseRange is UpperLower, it means this CaseRange represents a sequence of the form (say) Upper Lower Upper Lower. </p> <pre data-language=\"go\">const Version = \"9.0.0\"</pre> <p> Version is the Unicode edition from which the tables are derived. </p> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        Cc     = _Cc // Cc is the set of Unicode characters in category Cc.\n        Cf     = _Cf // Cf is the set of Unicode characters in category Cf.\n        Co     = _Co // Co is the set of Unicode characters in category Co.\n        Cs     = _Cs // Cs is the set of Unicode characters in category Cs.\n        Digit  = _Nd // Digit is the set of Unicode characters with the \"decimal digit\" property.\n        Nd     = _Nd // Nd is the set of Unicode characters in category Nd.\n        Letter = _L  // Letter/L is the set of Unicode letters, category L.\n        L      = _L\n        Lm     = _Lm // Lm is the set of Unicode characters in category Lm.\n        Lo     = _Lo // Lo is the set of Unicode characters in category Lo.\n        Lower  = _Ll // Lower is the set of Unicode lower case letters.\n        Ll     = _Ll // Ll is the set of Unicode characters in category Ll.\n        Mark   = _M  // Mark/M is the set of Unicode mark characters, category M.\n        M      = _M\n        Mc     = _Mc // Mc is the set of Unicode characters in category Mc.\n        Me     = _Me // Me is the set of Unicode characters in category Me.\n        Mn     = _Mn // Mn is the set of Unicode characters in category Mn.\n        Nl     = _Nl // Nl is the set of Unicode characters in category Nl.\n        No     = _No // No is the set of Unicode characters in category No.\n        Number = _N  // Number/N is the set of Unicode number characters, category N.\n        N      = _N\n        Other  = _C // Other/C is the set of Unicode control and special characters, category C.\n        C      = _C\n        Pc     = _Pc // Pc is the set of Unicode characters in category Pc.\n        Pd     = _Pd // Pd is the set of Unicode characters in category Pd.\n        Pe     = _Pe // Pe is the set of Unicode characters in category Pe.\n        Pf     = _Pf // Pf is the set of Unicode characters in category Pf.\n        Pi     = _Pi // Pi is the set of Unicode characters in category Pi.\n        Po     = _Po // Po is the set of Unicode characters in category Po.\n        Ps     = _Ps // Ps is the set of Unicode characters in category Ps.\n        Punct  = _P  // Punct/P is the set of Unicode punctuation characters, category P.\n        P      = _P\n        Sc     = _Sc // Sc is the set of Unicode characters in category Sc.\n        Sk     = _Sk // Sk is the set of Unicode characters in category Sk.\n        Sm     = _Sm // Sm is the set of Unicode characters in category Sm.\n        So     = _So // So is the set of Unicode characters in category So.\n        Space  = _Z  // Space/Z is the set of Unicode space characters, category Z.\n        Z      = _Z\n        Symbol = _S // Symbol/S is the set of Unicode symbol characters, category S.\n        S      = _S\n        Title  = _Lt // Title is the set of Unicode title case letters.\n        Lt     = _Lt // Lt is the set of Unicode characters in category Lt.\n        Upper  = _Lu // Upper is the set of Unicode upper case letters.\n        Lu     = _Lu // Lu is the set of Unicode characters in category Lu.\n        Zl     = _Zl // Zl is the set of Unicode characters in category Zl.\n        Zp     = _Zp // Zp is the set of Unicode characters in category Zp.\n        Zs     = _Zs // Zs is the set of Unicode characters in category Zs.\n)</pre> <p> These variables have type *RangeTable. </p> <pre data-language=\"go\">var (\n        Adlam                  = _Adlam                  // Adlam is the set of Unicode characters in script Adlam.\n        Ahom                   = _Ahom                   // Ahom is the set of Unicode characters in script Ahom.\n        Anatolian_Hieroglyphs  = _Anatolian_Hieroglyphs  // Anatolian_Hieroglyphs is the set of Unicode characters in script Anatolian_Hieroglyphs.\n        Arabic                 = _Arabic                 // Arabic is the set of Unicode characters in script Arabic.\n        Armenian               = _Armenian               // Armenian is the set of Unicode characters in script Armenian.\n        Avestan                = _Avestan                // Avestan is the set of Unicode characters in script Avestan.\n        Balinese               = _Balinese               // Balinese is the set of Unicode characters in script Balinese.\n        Bamum                  = _Bamum                  // Bamum is the set of Unicode characters in script Bamum.\n        Bassa_Vah              = _Bassa_Vah              // Bassa_Vah is the set of Unicode characters in script Bassa_Vah.\n        Batak                  = _Batak                  // Batak is the set of Unicode characters in script Batak.\n        Bengali                = _Bengali                // Bengali is the set of Unicode characters in script Bengali.\n        Bhaiksuki              = _Bhaiksuki              // Bhaiksuki is the set of Unicode characters in script Bhaiksuki.\n        Bopomofo               = _Bopomofo               // Bopomofo is the set of Unicode characters in script Bopomofo.\n        Brahmi                 = _Brahmi                 // Brahmi is the set of Unicode characters in script Brahmi.\n        Braille                = _Braille                // Braille is the set of Unicode characters in script Braille.\n        Buginese               = _Buginese               // Buginese is the set of Unicode characters in script Buginese.\n        Buhid                  = _Buhid                  // Buhid is the set of Unicode characters in script Buhid.\n        Canadian_Aboriginal    = _Canadian_Aboriginal    // Canadian_Aboriginal is the set of Unicode characters in script Canadian_Aboriginal.\n        Carian                 = _Carian                 // Carian is the set of Unicode characters in script Carian.\n        Caucasian_Albanian     = _Caucasian_Albanian     // Caucasian_Albanian is the set of Unicode characters in script Caucasian_Albanian.\n        Chakma                 = _Chakma                 // Chakma is the set of Unicode characters in script Chakma.\n        Cham                   = _Cham                   // Cham is the set of Unicode characters in script Cham.\n        Cherokee               = _Cherokee               // Cherokee is the set of Unicode characters in script Cherokee.\n        Common                 = _Common                 // Common is the set of Unicode characters in script Common.\n        Coptic                 = _Coptic                 // Coptic is the set of Unicode characters in script Coptic.\n        Cuneiform              = _Cuneiform              // Cuneiform is the set of Unicode characters in script Cuneiform.\n        Cypriot                = _Cypriot                // Cypriot is the set of Unicode characters in script Cypriot.\n        Cyrillic               = _Cyrillic               // Cyrillic is the set of Unicode characters in script Cyrillic.\n        Deseret                = _Deseret                // Deseret is the set of Unicode characters in script Deseret.\n        Devanagari             = _Devanagari             // Devanagari is the set of Unicode characters in script Devanagari.\n        Duployan               = _Duployan               // Duployan is the set of Unicode characters in script Duployan.\n        Egyptian_Hieroglyphs   = _Egyptian_Hieroglyphs   // Egyptian_Hieroglyphs is the set of Unicode characters in script Egyptian_Hieroglyphs.\n        Elbasan                = _Elbasan                // Elbasan is the set of Unicode characters in script Elbasan.\n        Ethiopic               = _Ethiopic               // Ethiopic is the set of Unicode characters in script Ethiopic.\n        Georgian               = _Georgian               // Georgian is the set of Unicode characters in script Georgian.\n        Glagolitic             = _Glagolitic             // Glagolitic is the set of Unicode characters in script Glagolitic.\n        Gothic                 = _Gothic                 // Gothic is the set of Unicode characters in script Gothic.\n        Grantha                = _Grantha                // Grantha is the set of Unicode characters in script Grantha.\n        Greek                  = _Greek                  // Greek is the set of Unicode characters in script Greek.\n        Gujarati               = _Gujarati               // Gujarati is the set of Unicode characters in script Gujarati.\n        Gurmukhi               = _Gurmukhi               // Gurmukhi is the set of Unicode characters in script Gurmukhi.\n        Han                    = _Han                    // Han is the set of Unicode characters in script Han.\n        Hangul                 = _Hangul                 // Hangul is the set of Unicode characters in script Hangul.\n        Hanunoo                = _Hanunoo                // Hanunoo is the set of Unicode characters in script Hanunoo.\n        Hatran                 = _Hatran                 // Hatran is the set of Unicode characters in script Hatran.\n        Hebrew                 = _Hebrew                 // Hebrew is the set of Unicode characters in script Hebrew.\n        Hiragana               = _Hiragana               // Hiragana is the set of Unicode characters in script Hiragana.\n        Imperial_Aramaic       = _Imperial_Aramaic       // Imperial_Aramaic is the set of Unicode characters in script Imperial_Aramaic.\n        Inherited              = _Inherited              // Inherited is the set of Unicode characters in script Inherited.\n        Inscriptional_Pahlavi  = _Inscriptional_Pahlavi  // Inscriptional_Pahlavi is the set of Unicode characters in script Inscriptional_Pahlavi.\n        Inscriptional_Parthian = _Inscriptional_Parthian // Inscriptional_Parthian is the set of Unicode characters in script Inscriptional_Parthian.\n        Javanese               = _Javanese               // Javanese is the set of Unicode characters in script Javanese.\n        Kaithi                 = _Kaithi                 // Kaithi is the set of Unicode characters in script Kaithi.\n        Kannada                = _Kannada                // Kannada is the set of Unicode characters in script Kannada.\n        Katakana               = _Katakana               // Katakana is the set of Unicode characters in script Katakana.\n        Kayah_Li               = _Kayah_Li               // Kayah_Li is the set of Unicode characters in script Kayah_Li.\n        Kharoshthi             = _Kharoshthi             // Kharoshthi is the set of Unicode characters in script Kharoshthi.\n        Khmer                  = _Khmer                  // Khmer is the set of Unicode characters in script Khmer.\n        Khojki                 = _Khojki                 // Khojki is the set of Unicode characters in script Khojki.\n        Khudawadi              = _Khudawadi              // Khudawadi is the set of Unicode characters in script Khudawadi.\n        Lao                    = _Lao                    // Lao is the set of Unicode characters in script Lao.\n        Latin                  = _Latin                  // Latin is the set of Unicode characters in script Latin.\n        Lepcha                 = _Lepcha                 // Lepcha is the set of Unicode characters in script Lepcha.\n        Limbu                  = _Limbu                  // Limbu is the set of Unicode characters in script Limbu.\n        Linear_A               = _Linear_A               // Linear_A is the set of Unicode characters in script Linear_A.\n        Linear_B               = _Linear_B               // Linear_B is the set of Unicode characters in script Linear_B.\n        Lisu                   = _Lisu                   // Lisu is the set of Unicode characters in script Lisu.\n        Lycian                 = _Lycian                 // Lycian is the set of Unicode characters in script Lycian.\n        Lydian                 = _Lydian                 // Lydian is the set of Unicode characters in script Lydian.\n        Mahajani               = _Mahajani               // Mahajani is the set of Unicode characters in script Mahajani.\n        Malayalam              = _Malayalam              // Malayalam is the set of Unicode characters in script Malayalam.\n        Mandaic                = _Mandaic                // Mandaic is the set of Unicode characters in script Mandaic.\n        Manichaean             = _Manichaean             // Manichaean is the set of Unicode characters in script Manichaean.\n        Marchen                = _Marchen                // Marchen is the set of Unicode characters in script Marchen.\n        Meetei_Mayek           = _Meetei_Mayek           // Meetei_Mayek is the set of Unicode characters in script Meetei_Mayek.\n        Mende_Kikakui          = _Mende_Kikakui          // Mende_Kikakui is the set of Unicode characters in script Mende_Kikakui.\n        Meroitic_Cursive       = _Meroitic_Cursive       // Meroitic_Cursive is the set of Unicode characters in script Meroitic_Cursive.\n        Meroitic_Hieroglyphs   = _Meroitic_Hieroglyphs   // Meroitic_Hieroglyphs is the set of Unicode characters in script Meroitic_Hieroglyphs.\n        Miao                   = _Miao                   // Miao is the set of Unicode characters in script Miao.\n        Modi                   = _Modi                   // Modi is the set of Unicode characters in script Modi.\n        Mongolian              = _Mongolian              // Mongolian is the set of Unicode characters in script Mongolian.\n        Mro                    = _Mro                    // Mro is the set of Unicode characters in script Mro.\n        Multani                = _Multani                // Multani is the set of Unicode characters in script Multani.\n        Myanmar                = _Myanmar                // Myanmar is the set of Unicode characters in script Myanmar.\n        Nabataean              = _Nabataean              // Nabataean is the set of Unicode characters in script Nabataean.\n        New_Tai_Lue            = _New_Tai_Lue            // New_Tai_Lue is the set of Unicode characters in script New_Tai_Lue.\n        Newa                   = _Newa                   // Newa is the set of Unicode characters in script Newa.\n        Nko                    = _Nko                    // Nko is the set of Unicode characters in script Nko.\n        Ogham                  = _Ogham                  // Ogham is the set of Unicode characters in script Ogham.\n        Ol_Chiki               = _Ol_Chiki               // Ol_Chiki is the set of Unicode characters in script Ol_Chiki.\n        Old_Hungarian          = _Old_Hungarian          // Old_Hungarian is the set of Unicode characters in script Old_Hungarian.\n        Old_Italic             = _Old_Italic             // Old_Italic is the set of Unicode characters in script Old_Italic.\n        Old_North_Arabian      = _Old_North_Arabian      // Old_North_Arabian is the set of Unicode characters in script Old_North_Arabian.\n        Old_Permic             = _Old_Permic             // Old_Permic is the set of Unicode characters in script Old_Permic.\n        Old_Persian            = _Old_Persian            // Old_Persian is the set of Unicode characters in script Old_Persian.\n        Old_South_Arabian      = _Old_South_Arabian      // Old_South_Arabian is the set of Unicode characters in script Old_South_Arabian.\n        Old_Turkic             = _Old_Turkic             // Old_Turkic is the set of Unicode characters in script Old_Turkic.\n        Oriya                  = _Oriya                  // Oriya is the set of Unicode characters in script Oriya.\n        Osage                  = _Osage                  // Osage is the set of Unicode characters in script Osage.\n        Osmanya                = _Osmanya                // Osmanya is the set of Unicode characters in script Osmanya.\n        Pahawh_Hmong           = _Pahawh_Hmong           // Pahawh_Hmong is the set of Unicode characters in script Pahawh_Hmong.\n        Palmyrene              = _Palmyrene              // Palmyrene is the set of Unicode characters in script Palmyrene.\n        Pau_Cin_Hau            = _Pau_Cin_Hau            // Pau_Cin_Hau is the set of Unicode characters in script Pau_Cin_Hau.\n        Phags_Pa               = _Phags_Pa               // Phags_Pa is the set of Unicode characters in script Phags_Pa.\n        Phoenician             = _Phoenician             // Phoenician is the set of Unicode characters in script Phoenician.\n        Psalter_Pahlavi        = _Psalter_Pahlavi        // Psalter_Pahlavi is the set of Unicode characters in script Psalter_Pahlavi.\n        Rejang                 = _Rejang                 // Rejang is the set of Unicode characters in script Rejang.\n        Runic                  = _Runic                  // Runic is the set of Unicode characters in script Runic.\n        Samaritan              = _Samaritan              // Samaritan is the set of Unicode characters in script Samaritan.\n        Saurashtra             = _Saurashtra             // Saurashtra is the set of Unicode characters in script Saurashtra.\n        Sharada                = _Sharada                // Sharada is the set of Unicode characters in script Sharada.\n        Shavian                = _Shavian                // Shavian is the set of Unicode characters in script Shavian.\n        Siddham                = _Siddham                // Siddham is the set of Unicode characters in script Siddham.\n        SignWriting            = _SignWriting            // SignWriting is the set of Unicode characters in script SignWriting.\n        Sinhala                = _Sinhala                // Sinhala is the set of Unicode characters in script Sinhala.\n        Sora_Sompeng           = _Sora_Sompeng           // Sora_Sompeng is the set of Unicode characters in script Sora_Sompeng.\n        Sundanese              = _Sundanese              // Sundanese is the set of Unicode characters in script Sundanese.\n        Syloti_Nagri           = _Syloti_Nagri           // Syloti_Nagri is the set of Unicode characters in script Syloti_Nagri.\n        Syriac                 = _Syriac                 // Syriac is the set of Unicode characters in script Syriac.\n        Tagalog                = _Tagalog                // Tagalog is the set of Unicode characters in script Tagalog.\n        Tagbanwa               = _Tagbanwa               // Tagbanwa is the set of Unicode characters in script Tagbanwa.\n        Tai_Le                 = _Tai_Le                 // Tai_Le is the set of Unicode characters in script Tai_Le.\n        Tai_Tham               = _Tai_Tham               // Tai_Tham is the set of Unicode characters in script Tai_Tham.\n        Tai_Viet               = _Tai_Viet               // Tai_Viet is the set of Unicode characters in script Tai_Viet.\n        Takri                  = _Takri                  // Takri is the set of Unicode characters in script Takri.\n        Tamil                  = _Tamil                  // Tamil is the set of Unicode characters in script Tamil.\n        Tangut                 = _Tangut                 // Tangut is the set of Unicode characters in script Tangut.\n        Telugu                 = _Telugu                 // Telugu is the set of Unicode characters in script Telugu.\n        Thaana                 = _Thaana                 // Thaana is the set of Unicode characters in script Thaana.\n        Thai                   = _Thai                   // Thai is the set of Unicode characters in script Thai.\n        Tibetan                = _Tibetan                // Tibetan is the set of Unicode characters in script Tibetan.\n        Tifinagh               = _Tifinagh               // Tifinagh is the set of Unicode characters in script Tifinagh.\n        Tirhuta                = _Tirhuta                // Tirhuta is the set of Unicode characters in script Tirhuta.\n        Ugaritic               = _Ugaritic               // Ugaritic is the set of Unicode characters in script Ugaritic.\n        Vai                    = _Vai                    // Vai is the set of Unicode characters in script Vai.\n        Warang_Citi            = _Warang_Citi            // Warang_Citi is the set of Unicode characters in script Warang_Citi.\n        Yi                     = _Yi                     // Yi is the set of Unicode characters in script Yi.\n)</pre> <p> These variables have type *RangeTable. </p> <pre data-language=\"go\">var (\n        ASCII_Hex_Digit                    = _ASCII_Hex_Digit                    // ASCII_Hex_Digit is the set of Unicode characters with property ASCII_Hex_Digit.\n        Bidi_Control                       = _Bidi_Control                       // Bidi_Control is the set of Unicode characters with property Bidi_Control.\n        Dash                               = _Dash                               // Dash is the set of Unicode characters with property Dash.\n        Deprecated                         = _Deprecated                         // Deprecated is the set of Unicode characters with property Deprecated.\n        Diacritic                          = _Diacritic                          // Diacritic is the set of Unicode characters with property Diacritic.\n        Extender                           = _Extender                           // Extender is the set of Unicode characters with property Extender.\n        Hex_Digit                          = _Hex_Digit                          // Hex_Digit is the set of Unicode characters with property Hex_Digit.\n        Hyphen                             = _Hyphen                             // Hyphen is the set of Unicode characters with property Hyphen.\n        IDS_Binary_Operator                = _IDS_Binary_Operator                // IDS_Binary_Operator is the set of Unicode characters with property IDS_Binary_Operator.\n        IDS_Trinary_Operator               = _IDS_Trinary_Operator               // IDS_Trinary_Operator is the set of Unicode characters with property IDS_Trinary_Operator.\n        Ideographic                        = _Ideographic                        // Ideographic is the set of Unicode characters with property Ideographic.\n        Join_Control                       = _Join_Control                       // Join_Control is the set of Unicode characters with property Join_Control.\n        Logical_Order_Exception            = _Logical_Order_Exception            // Logical_Order_Exception is the set of Unicode characters with property Logical_Order_Exception.\n        Noncharacter_Code_Point            = _Noncharacter_Code_Point            // Noncharacter_Code_Point is the set of Unicode characters with property Noncharacter_Code_Point.\n        Other_Alphabetic                   = _Other_Alphabetic                   // Other_Alphabetic is the set of Unicode characters with property Other_Alphabetic.\n        Other_Default_Ignorable_Code_Point = _Other_Default_Ignorable_Code_Point // Other_Default_Ignorable_Code_Point is the set of Unicode characters with property Other_Default_Ignorable_Code_Point.\n        Other_Grapheme_Extend              = _Other_Grapheme_Extend              // Other_Grapheme_Extend is the set of Unicode characters with property Other_Grapheme_Extend.\n        Other_ID_Continue                  = _Other_ID_Continue                  // Other_ID_Continue is the set of Unicode characters with property Other_ID_Continue.\n        Other_ID_Start                     = _Other_ID_Start                     // Other_ID_Start is the set of Unicode characters with property Other_ID_Start.\n        Other_Lowercase                    = _Other_Lowercase                    // Other_Lowercase is the set of Unicode characters with property Other_Lowercase.\n        Other_Math                         = _Other_Math                         // Other_Math is the set of Unicode characters with property Other_Math.\n        Other_Uppercase                    = _Other_Uppercase                    // Other_Uppercase is the set of Unicode characters with property Other_Uppercase.\n        Pattern_Syntax                     = _Pattern_Syntax                     // Pattern_Syntax is the set of Unicode characters with property Pattern_Syntax.\n        Pattern_White_Space                = _Pattern_White_Space                // Pattern_White_Space is the set of Unicode characters with property Pattern_White_Space.\n        Prepended_Concatenation_Mark       = _Prepended_Concatenation_Mark       // Prepended_Concatenation_Mark is the set of Unicode characters with property Prepended_Concatenation_Mark.\n        Quotation_Mark                     = _Quotation_Mark                     // Quotation_Mark is the set of Unicode characters with property Quotation_Mark.\n        Radical                            = _Radical                            // Radical is the set of Unicode characters with property Radical.\n        STerm                              = _Sentence_Terminal                  // STerm is an alias for Sentence_Terminal.\n        Sentence_Terminal                  = _Sentence_Terminal                  // Sentence_Terminal is the set of Unicode characters with property Sentence_Terminal.\n        Soft_Dotted                        = _Soft_Dotted                        // Soft_Dotted is the set of Unicode characters with property Soft_Dotted.\n        Terminal_Punctuation               = _Terminal_Punctuation               // Terminal_Punctuation is the set of Unicode characters with property Terminal_Punctuation.\n        Unified_Ideograph                  = _Unified_Ideograph                  // Unified_Ideograph is the set of Unicode characters with property Unified_Ideograph.\n        Variation_Selector                 = _Variation_Selector                 // Variation_Selector is the set of Unicode characters with property Variation_Selector.\n        White_Space                        = _White_Space                        // White_Space is the set of Unicode characters with property White_Space.\n)</pre> <p> These variables have type *RangeTable. </p> <pre data-language=\"go\">var CaseRanges = _CaseRanges</pre> <p> CaseRanges is the table describing case mappings for all letters with non-self mappings. </p> <pre data-language=\"go\">var Categories = map[string]*RangeTable{\n        \"C\":  C,\n        \"Cc\": Cc,\n        \"Cf\": Cf,\n        \"Co\": Co,\n        \"Cs\": Cs,\n        \"L\":  L,\n        \"Ll\": Ll,\n        \"Lm\": Lm,\n        \"Lo\": Lo,\n        \"Lt\": Lt,\n        \"Lu\": Lu,\n        \"M\":  M,\n        \"Mc\": Mc,\n        \"Me\": Me,\n        \"Mn\": Mn,\n        \"N\":  N,\n        \"Nd\": Nd,\n        \"Nl\": Nl,\n        \"No\": No,\n        \"P\":  P,\n        \"Pc\": Pc,\n        \"Pd\": Pd,\n        \"Pe\": Pe,\n        \"Pf\": Pf,\n        \"Pi\": Pi,\n        \"Po\": Po,\n        \"Ps\": Ps,\n        \"S\":  S,\n        \"Sc\": Sc,\n        \"Sk\": Sk,\n        \"Sm\": Sm,\n        \"So\": So,\n        \"Z\":  Z,\n        \"Zl\": Zl,\n        \"Zp\": Zp,\n        \"Zs\": Zs,\n}</pre> <p> Categories is the set of Unicode category tables. </p> <pre data-language=\"go\">var FoldCategory = map[string]*RangeTable{\n        \"Common\":    foldCommon,\n        \"Greek\":     foldGreek,\n        \"Inherited\": foldInherited,\n        \"L\":         foldL,\n        \"Ll\":        foldLl,\n        \"Lt\":        foldLt,\n        \"Lu\":        foldLu,\n        \"M\":         foldM,\n        \"Mn\":        foldMn,\n}</pre> <p> FoldCategory maps a category name to a table of code points outside the category that are equivalent under simple case folding to code points inside the category. If there is no entry for a category name, there are no such points. </p> <pre data-language=\"go\">var FoldScript = map[string]*RangeTable{}</pre> <p> FoldScript maps a script name to a table of code points outside the script that are equivalent under simple case folding to code points inside the script. If there is no entry for a script name, there are no such points. </p> <pre data-language=\"go\">var GraphicRanges = []*RangeTable{\n        L, M, N, P, S, Zs,\n}</pre> <p> GraphicRanges defines the set of graphic characters according to Unicode. </p> <pre data-language=\"go\">var PrintRanges = []*RangeTable{\n        L, M, N, P, S,\n}</pre> <p> PrintRanges defines the set of printable characters according to Go. ASCII space, U+0020, is handled separately. </p> <pre data-language=\"go\">var Properties = map[string]*RangeTable{\n        \"ASCII_Hex_Digit\":                    ASCII_Hex_Digit,\n        \"Bidi_Control\":                       Bidi_Control,\n        \"Dash\":                               Dash,\n        \"Deprecated\":                         Deprecated,\n        \"Diacritic\":                          Diacritic,\n        \"Extender\":                           Extender,\n        \"Hex_Digit\":                          Hex_Digit,\n        \"Hyphen\":                             Hyphen,\n        \"IDS_Binary_Operator\":                IDS_Binary_Operator,\n        \"IDS_Trinary_Operator\":               IDS_Trinary_Operator,\n        \"Ideographic\":                        Ideographic,\n        \"Join_Control\":                       Join_Control,\n        \"Logical_Order_Exception\":            Logical_Order_Exception,\n        \"Noncharacter_Code_Point\":            Noncharacter_Code_Point,\n        \"Other_Alphabetic\":                   Other_Alphabetic,\n        \"Other_Default_Ignorable_Code_Point\": Other_Default_Ignorable_Code_Point,\n        \"Other_Grapheme_Extend\":              Other_Grapheme_Extend,\n        \"Other_ID_Continue\":                  Other_ID_Continue,\n        \"Other_ID_Start\":                     Other_ID_Start,\n        \"Other_Lowercase\":                    Other_Lowercase,\n        \"Other_Math\":                         Other_Math,\n        \"Other_Uppercase\":                    Other_Uppercase,\n        \"Pattern_Syntax\":                     Pattern_Syntax,\n        \"Pattern_White_Space\":                Pattern_White_Space,\n        \"Prepended_Concatenation_Mark\":       Prepended_Concatenation_Mark,\n        \"Quotation_Mark\":                     Quotation_Mark,\n        \"Radical\":                            Radical,\n        \"Sentence_Terminal\":                  Sentence_Terminal,\n        \"STerm\":                              Sentence_Terminal,\n        \"Soft_Dotted\":                        Soft_Dotted,\n        \"Terminal_Punctuation\":               Terminal_Punctuation,\n        \"Unified_Ideograph\":                  Unified_Ideograph,\n        \"Variation_Selector\":                 Variation_Selector,\n        \"White_Space\":                        White_Space,\n}</pre> <p> Properties is the set of Unicode property tables. </p> <pre data-language=\"go\">var Scripts = map[string]*RangeTable{\n        \"Adlam\":                  Adlam,\n        \"Ahom\":                   Ahom,\n        \"Anatolian_Hieroglyphs\":  Anatolian_Hieroglyphs,\n        \"Arabic\":                 Arabic,\n        \"Armenian\":               Armenian,\n        \"Avestan\":                Avestan,\n        \"Balinese\":               Balinese,\n        \"Bamum\":                  Bamum,\n        \"Bassa_Vah\":              Bassa_Vah,\n        \"Batak\":                  Batak,\n        \"Bengali\":                Bengali,\n        \"Bhaiksuki\":              Bhaiksuki,\n        \"Bopomofo\":               Bopomofo,\n        \"Brahmi\":                 Brahmi,\n        \"Braille\":                Braille,\n        \"Buginese\":               Buginese,\n        \"Buhid\":                  Buhid,\n        \"Canadian_Aboriginal\":    Canadian_Aboriginal,\n        \"Carian\":                 Carian,\n        \"Caucasian_Albanian\":     Caucasian_Albanian,\n        \"Chakma\":                 Chakma,\n        \"Cham\":                   Cham,\n        \"Cherokee\":               Cherokee,\n        \"Common\":                 Common,\n        \"Coptic\":                 Coptic,\n        \"Cuneiform\":              Cuneiform,\n        \"Cypriot\":                Cypriot,\n        \"Cyrillic\":               Cyrillic,\n        \"Deseret\":                Deseret,\n        \"Devanagari\":             Devanagari,\n        \"Duployan\":               Duployan,\n        \"Egyptian_Hieroglyphs\":   Egyptian_Hieroglyphs,\n        \"Elbasan\":                Elbasan,\n        \"Ethiopic\":               Ethiopic,\n        \"Georgian\":               Georgian,\n        \"Glagolitic\":             Glagolitic,\n        \"Gothic\":                 Gothic,\n        \"Grantha\":                Grantha,\n        \"Greek\":                  Greek,\n        \"Gujarati\":               Gujarati,\n        \"Gurmukhi\":               Gurmukhi,\n        \"Han\":                    Han,\n        \"Hangul\":                 Hangul,\n        \"Hanunoo\":                Hanunoo,\n        \"Hatran\":                 Hatran,\n        \"Hebrew\":                 Hebrew,\n        \"Hiragana\":               Hiragana,\n        \"Imperial_Aramaic\":       Imperial_Aramaic,\n        \"Inherited\":              Inherited,\n        \"Inscriptional_Pahlavi\":  Inscriptional_Pahlavi,\n        \"Inscriptional_Parthian\": Inscriptional_Parthian,\n        \"Javanese\":               Javanese,\n        \"Kaithi\":                 Kaithi,\n        \"Kannada\":                Kannada,\n        \"Katakana\":               Katakana,\n        \"Kayah_Li\":               Kayah_Li,\n        \"Kharoshthi\":             Kharoshthi,\n        \"Khmer\":                  Khmer,\n        \"Khojki\":                 Khojki,\n        \"Khudawadi\":              Khudawadi,\n        \"Lao\":                    Lao,\n        \"Latin\":                  Latin,\n        \"Lepcha\":                 Lepcha,\n        \"Limbu\":                  Limbu,\n        \"Linear_A\":               Linear_A,\n        \"Linear_B\":               Linear_B,\n        \"Lisu\":                   Lisu,\n        \"Lycian\":                 Lycian,\n        \"Lydian\":                 Lydian,\n        \"Mahajani\":               Mahajani,\n        \"Malayalam\":              Malayalam,\n        \"Mandaic\":                Mandaic,\n        \"Manichaean\":             Manichaean,\n        \"Marchen\":                Marchen,\n        \"Meetei_Mayek\":           Meetei_Mayek,\n        \"Mende_Kikakui\":          Mende_Kikakui,\n        \"Meroitic_Cursive\":       Meroitic_Cursive,\n        \"Meroitic_Hieroglyphs\":   Meroitic_Hieroglyphs,\n        \"Miao\":                   Miao,\n        \"Modi\":                   Modi,\n        \"Mongolian\":              Mongolian,\n        \"Mro\":                    Mro,\n        \"Multani\":                Multani,\n        \"Myanmar\":                Myanmar,\n        \"Nabataean\":              Nabataean,\n        \"New_Tai_Lue\":            New_Tai_Lue,\n        \"Newa\":                   Newa,\n        \"Nko\":                    Nko,\n        \"Ogham\":                  Ogham,\n        \"Ol_Chiki\":               Ol_Chiki,\n        \"Old_Hungarian\":          Old_Hungarian,\n        \"Old_Italic\":             Old_Italic,\n        \"Old_North_Arabian\":      Old_North_Arabian,\n        \"Old_Permic\":             Old_Permic,\n        \"Old_Persian\":            Old_Persian,\n        \"Old_South_Arabian\":      Old_South_Arabian,\n        \"Old_Turkic\":             Old_Turkic,\n        \"Oriya\":                  Oriya,\n        \"Osage\":                  Osage,\n        \"Osmanya\":                Osmanya,\n        \"Pahawh_Hmong\":           Pahawh_Hmong,\n        \"Palmyrene\":              Palmyrene,\n        \"Pau_Cin_Hau\":            Pau_Cin_Hau,\n        \"Phags_Pa\":               Phags_Pa,\n        \"Phoenician\":             Phoenician,\n        \"Psalter_Pahlavi\":        Psalter_Pahlavi,\n        \"Rejang\":                 Rejang,\n        \"Runic\":                  Runic,\n        \"Samaritan\":              Samaritan,\n        \"Saurashtra\":             Saurashtra,\n        \"Sharada\":                Sharada,\n        \"Shavian\":                Shavian,\n        \"Siddham\":                Siddham,\n        \"SignWriting\":            SignWriting,\n        \"Sinhala\":                Sinhala,\n        \"Sora_Sompeng\":           Sora_Sompeng,\n        \"Sundanese\":              Sundanese,\n        \"Syloti_Nagri\":           Syloti_Nagri,\n        \"Syriac\":                 Syriac,\n        \"Tagalog\":                Tagalog,\n        \"Tagbanwa\":               Tagbanwa,\n        \"Tai_Le\":                 Tai_Le,\n        \"Tai_Tham\":               Tai_Tham,\n        \"Tai_Viet\":               Tai_Viet,\n        \"Takri\":                  Takri,\n        \"Tamil\":                  Tamil,\n        \"Tangut\":                 Tangut,\n        \"Telugu\":                 Telugu,\n        \"Thaana\":                 Thaana,\n        \"Thai\":                   Thai,\n        \"Tibetan\":                Tibetan,\n        \"Tifinagh\":               Tifinagh,\n        \"Tirhuta\":                Tirhuta,\n        \"Ugaritic\":               Ugaritic,\n        \"Vai\":                    Vai,\n        \"Warang_Citi\":            Warang_Citi,\n        \"Yi\":                     Yi,\n}</pre> <p> Scripts is the set of Unicode script tables. </p> <h2 id=\"In\">func In  </h2> <pre data-language=\"go\">func In(r rune, ranges ...*RangeTable) bool</pre> <p> In reports whether the rune is a member of one of the ranges. </p> <h2 id=\"Is\">func Is  </h2> <pre data-language=\"go\">func Is(rangeTab *RangeTable, r rune) bool</pre> <p> Is reports whether the rune is in the specified table of ranges. </p> <h2 id=\"IsControl\">func IsControl  </h2> <pre data-language=\"go\">func IsControl(r rune) bool</pre> <p> IsControl reports whether the rune is a control character. The C (Other) Unicode category includes more code points such as surrogates; use Is(C, r) to test for them. </p> <h2 id=\"IsDigit\">func IsDigit  </h2> <pre data-language=\"go\">func IsDigit(r rune) bool</pre> <p> IsDigit reports whether the rune is a decimal digit. </p> <h2 id=\"IsGraphic\">func IsGraphic  </h2> <pre data-language=\"go\">func IsGraphic(r rune) bool</pre> <p> IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, Zs. </p> <h2 id=\"IsLetter\">func IsLetter  </h2> <pre data-language=\"go\">func IsLetter(r rune) bool</pre> <p> IsLetter reports whether the rune is a letter (category L). </p> <h2 id=\"IsLower\">func IsLower  </h2> <pre data-language=\"go\">func IsLower(r rune) bool</pre> <p> IsLower reports whether the rune is a lower case letter. </p> <h2 id=\"IsMark\">func IsMark  </h2> <pre data-language=\"go\">func IsMark(r rune) bool</pre> <p> IsMark reports whether the rune is a mark character (category M). </p> <h2 id=\"IsNumber\">func IsNumber  </h2> <pre data-language=\"go\">func IsNumber(r rune) bool</pre> <p> IsNumber reports whether the rune is a number (category N). </p> <h2 id=\"IsOneOf\">func IsOneOf  </h2> <pre data-language=\"go\">func IsOneOf(ranges []*RangeTable, r rune) bool</pre> <p> IsOneOf reports whether the rune is a member of one of the ranges. The function \"In\" provides a nicer signature and should be used in preference to IsOneOf. </p> <h2 id=\"IsPrint\">func IsPrint  </h2> <pre data-language=\"go\">func IsPrint(r rune) bool</pre> <p> IsPrint reports whether the rune is defined as printable by Go. Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories L, M, N, P, S and the ASCII space character. This categorization is the same as IsGraphic except that the only spacing character is ASCII space, U+0020. </p> <h2 id=\"IsPunct\">func IsPunct  </h2> <pre data-language=\"go\">func IsPunct(r rune) bool</pre> <p> IsPunct reports whether the rune is a Unicode punctuation character (category P). </p> <h2 id=\"IsSpace\">func IsSpace  </h2> <pre data-language=\"go\">func IsSpace(r rune) bool</pre> <p> IsSpace reports whether the rune is a space character as defined by Unicode's White Space property; in the Latin-1 space this is </p> <pre data-language=\"go\">'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\n</pre> <p> Other definitions of spacing characters are set by category Z and property Pattern_White_Space. </p> <h2 id=\"IsSymbol\">func IsSymbol  </h2> <pre data-language=\"go\">func IsSymbol(r rune) bool</pre> <p> IsSymbol reports whether the rune is a symbolic character. </p> <h2 id=\"IsTitle\">func IsTitle  </h2> <pre data-language=\"go\">func IsTitle(r rune) bool</pre> <p> IsTitle reports whether the rune is a title case letter. </p> <h2 id=\"IsUpper\">func IsUpper  </h2> <pre data-language=\"go\">func IsUpper(r rune) bool</pre> <p> IsUpper reports whether the rune is an upper case letter. </p> <h2 id=\"SimpleFold\">func SimpleFold  </h2> <pre data-language=\"go\">func SimpleFold(r rune) rune</pre> <p> SimpleFold iterates over Unicode code points equivalent under the Unicode-defined simple case folding. Among the code points equivalent to rune (including rune itself), SimpleFold returns the smallest rune &gt; r if one exists, or else the smallest rune &gt;= 0. </p> <p> For example: </p> <pre data-language=\"go\">SimpleFold('A') = 'a'\nSimpleFold('a') = 'A'\n\nSimpleFold('K') = 'k'\nSimpleFold('k') = '\\u212A' (Kelvin symbol, K)\nSimpleFold('\\u212A') = 'K'\n\nSimpleFold('1') = '1'\n</pre> <div id=\"example_SimpleFold\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode\"\n)\n\nfunc main() {\n\tfmt.Printf(\"%#U\\n\", unicode.SimpleFold('A'))      // 'a'\n\tfmt.Printf(\"%#U\\n\", unicode.SimpleFold('a'))      // 'A'\n\tfmt.Printf(\"%#U\\n\", unicode.SimpleFold('K'))      // 'k'\n\tfmt.Printf(\"%#U\\n\", unicode.SimpleFold('k'))      // '\\u212A' (Kelvin symbol, K)\n\tfmt.Printf(\"%#U\\n\", unicode.SimpleFold('\\u212A')) // 'K'\n\tfmt.Printf(\"%#U\\n\", unicode.SimpleFold('1'))      // '1'\n\n}\n</pre> </div> </div> <h2 id=\"To\">func To  </h2> <pre data-language=\"go\">func To(_case int, r rune) rune</pre> <p> To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase. </p> <div id=\"example_To\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode\"\n)\n\nfunc main() {\n\tconst lcG = 'g'\n\tfmt.Printf(\"%#U\\n\", unicode.To(unicode.UpperCase, lcG))\n\tfmt.Printf(\"%#U\\n\", unicode.To(unicode.LowerCase, lcG))\n\tfmt.Printf(\"%#U\\n\", unicode.To(unicode.TitleCase, lcG))\n\n\tconst ucG = 'G'\n\tfmt.Printf(\"%#U\\n\", unicode.To(unicode.UpperCase, ucG))\n\tfmt.Printf(\"%#U\\n\", unicode.To(unicode.LowerCase, ucG))\n\tfmt.Printf(\"%#U\\n\", unicode.To(unicode.TitleCase, ucG))\n\n}\n</pre> </div> </div> <h2 id=\"ToLower\">func ToLower  </h2> <pre data-language=\"go\">func ToLower(r rune) rune</pre> <p> ToLower maps the rune to lower case. </p> <div id=\"example_ToLower\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode\"\n)\n\nfunc main() {\n\tconst ucG = 'G'\n\tfmt.Printf(\"%#U\\n\", unicode.ToLower(ucG))\n\n}\n</pre> </div> </div> <h2 id=\"ToTitle\">func ToTitle  </h2> <pre data-language=\"go\">func ToTitle(r rune) rune</pre> <p> ToTitle maps the rune to title case. </p> <div id=\"example_ToTitle\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode\"\n)\n\nfunc main() {\n\tconst ucG = 'g'\n\tfmt.Printf(\"%#U\\n\", unicode.ToTitle(ucG))\n\n}\n</pre> </div> </div> <h2 id=\"ToUpper\">func ToUpper  </h2> <pre data-language=\"go\">func ToUpper(r rune) rune</pre> <p> ToUpper maps the rune to upper case. </p> <div id=\"example_ToUpper\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode\"\n)\n\nfunc main() {\n\tconst ucG = 'g'\n\tfmt.Printf(\"%#U\\n\", unicode.ToUpper(ucG))\n\n}\n</pre> </div> </div> <h2 id=\"CaseRange\">type CaseRange  </h2> <pre data-language=\"go\">type CaseRange struct {\n        Lo    uint32\n        Hi    uint32\n        Delta d\n}</pre> <p> CaseRange represents a range of Unicode code points for simple (one code point to one code point) case conversion. The range runs from Lo to Hi inclusive, with a fixed stride of 1. Deltas are the number to add to the code point to reach the code point for a different case for that character. They may be negative. If zero, it means the character is in the corresponding case. There is a special case representing sequences of alternating corresponding Upper and Lower pairs. It appears with a fixed Delta of </p> <pre data-language=\"go\">{UpperLower, UpperLower, UpperLower}\n</pre> <p> The constant UpperLower has an otherwise impossible delta value. </p> <h2 id=\"Range16\">type Range16  </h2> <pre data-language=\"go\">type Range16 struct {\n        Lo     uint16\n        Hi     uint16\n        Stride uint16\n}</pre> <p> Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi inclusive and has the specified stride. </p> <h2 id=\"Range32\">type Range32  </h2> <pre data-language=\"go\">type Range32 struct {\n        Lo     uint32\n        Hi     uint32\n        Stride uint32\n}</pre> <p> Range32 represents of a range of Unicode code points and is used when one or more of the values will not fit in 16 bits. The range runs from Lo to Hi inclusive and has the specified stride. Lo and Hi must always be &gt;= 1&lt;&lt;16. </p> <h2 id=\"RangeTable\">type RangeTable  </h2> <pre data-language=\"go\">type RangeTable struct {\n        R16         []Range16\n        R32         []Range32\n        LatinOffset int // number of entries in R16 with Hi &lt;= MaxLatin1\n}</pre> <p> RangeTable defines a set of Unicode code points by listing the ranges of code points within the set. The ranges are listed in two slices to save space: a slice of 16-bit ranges and a slice of 32-bit ranges. The two slices must be in sorted order and non-overlapping. Also, R32 should contain only values &gt;= 0x10000 (1&lt;&lt;16). </p> <h2 id=\"SpecialCase\">type SpecialCase  </h2> <pre data-language=\"go\">type SpecialCase []CaseRange</pre> <p> SpecialCase represents language-specific case mappings such as Turkish. Methods of SpecialCase customize (by overriding) the standard mappings. </p> <pre data-language=\"go\">var AzeriCase SpecialCase = _TurkishCase</pre> <pre data-language=\"go\">var TurkishCase SpecialCase = _TurkishCase</pre> <div id=\"example_SpecialCase\" class=\"toggle\">  <div class=\"expanded\"> <h2 class=\"exampleHeading toggleButton\"> Example</h2> <pre class=\"play\">package main\n\nimport (\n\t\"fmt\"\n\t\"unicode\"\n)\n\nfunc main() {\n\tt := unicode.TurkishCase\n\n\tconst lci = 'i'\n\tfmt.Printf(\"%#U\\n\", t.ToLower(lci))\n\tfmt.Printf(\"%#U\\n\", t.ToTitle(lci))\n\tfmt.Printf(\"%#U\\n\", t.ToUpper(lci))\n\n\tconst uci = 'İ'\n\tfmt.Printf(\"%#U\\n\", t.ToLower(uci))\n\tfmt.Printf(\"%#U\\n\", t.ToTitle(uci))\n\tfmt.Printf(\"%#U\\n\", t.ToUpper(uci))\n\n}\n</pre> </div> </div> <h3 id=\"SpecialCase.ToLower\">func (SpecialCase) <a href=\"https://golang.org/src/unicode/letter.go?s=8185:8232#L292\">ToLower</a>  </h3> <pre data-language=\"go\">func (special SpecialCase) ToLower(r rune) rune</pre> <p> ToLower maps the rune to lower case giving priority to the special mapping. </p> <h3 id=\"SpecialCase.ToTitle\">func (SpecialCase) <a href=\"https://golang.org/src/unicode/letter.go?s=7961:8008#L283\">ToTitle</a>  </h3> <pre data-language=\"go\">func (special SpecialCase) ToTitle(r rune) rune</pre> <p> ToTitle maps the rune to title case giving priority to the special mapping. </p> <h3 id=\"SpecialCase.ToUpper\">func (SpecialCase) <a href=\"https://golang.org/src/unicode/letter.go?s=7737:7784#L274\">ToUpper</a>  </h3> <pre data-language=\"go\">func (special SpecialCase) ToUpper(r rune) rune</pre> <p> ToUpper maps the rune to upper case giving priority to the special mapping. </p> <h2 id=\"pkg-note-BUG\">Bugs</h2> <ul style=\"list-style: none; padding: 0;\"> <li>\n<a href=\"https://golang.org/src/unicode/letter.go?s=2544:2678#L57\" style=\"float: left;\">☞</a> <p> There is no mechanism for full case folding, that is, for characters that involve multiple runes in the input or output. </p> </li> </ul> <h2 id=\"pkg-subdirectories\">Subdirectories</h2> <div class=\"pkg-dir\"> <table> <tr> <th class=\"pkg-name\">Name</th> <th class=\"pkg-synopsis\">Synopsis</th> </tr> <tr> <td colspan=\"2\"><a href=\"../index\">..</a></td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"utf16/index\">utf16</a> </td> <td class=\"pkg-synopsis\"> Package utf16 implements encoding and decoding of UTF-16 sequences. </td> </tr> <tr> <td class=\"pkg-name\"> <a href=\"utf8/index\">utf8</a> </td> <td class=\"pkg-synopsis\"> Package utf8 implements functions and constants to support text encoded in UTF-8. </td> </tr> </table> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/unicode/\" class=\"_attribution-link\">https://golang.org/pkg/unicode/</a>\n  </p>\n</div>\n","syscall/index":"<h1>Package syscall</h1>     <ul id=\"short-nav\">\n<li><code>import \"syscall\"</code></li>\n<li><a href=\"#pkg-overview\" class=\"overviewLink\">Overview</a></li>\n<li><a href=\"#pkg-index\" class=\"indexLink\">Index</a></li>\n</ul>  <div id=\"pkg-overview\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Overview section\">Overview </h2> <p> Package syscall contains an interface to the low-level operating system primitives. The details vary depending on the underlying system, and by default, godoc will display the syscall documentation for the current system. If you want godoc to display syscall documentation for another system, set $GOOS and $GOARCH to the desired system. For example, if you want to view documentation for freebsd/arm on linux/amd64, set $GOOS to freebsd and $GOARCH to arm. The primary use of syscall is inside other packages that provide a more portable interface to the system, such as \"os\", \"time\" and \"net\". Use those packages rather than this one if you can. For details of the functions and data types in this package consult the manuals for the appropriate operating system. These calls return err == nil to indicate success; otherwise err is an operating system error describing the failure. On most systems, that error has type syscall.Errno. </p> <p> NOTE: This package is locked down. Code outside the standard Go repository should be migrated to use the corresponding package in the golang.org/x/sys repository. That is also where updates required by new systems or versions should be applied. See <a href=\"https://golang.org/s/go1.4-syscall\">https://golang.org/s/go1.4-syscall</a> for more information. </p> </div> </div> <div id=\"pkg-index\" class=\"toggleVisible\">  <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Index section\">Index </h2>  <ul id=\"manual-nav\">\n<li><a href=\"#pkg-constants\">Constants</a></li>\n<li><a href=\"#pkg-variables\">Variables</a></li>\n<li><a href=\"#Accept\">func Accept(fd int) (nfd int, sa Sockaddr, err error)</a></li>\n<li><a href=\"#Accept4\">func Accept4(fd int, flags int) (nfd int, sa Sockaddr, err error)</a></li>\n<li><a href=\"#Access\">func Access(path string, mode uint32) (err error)</a></li>\n<li><a href=\"#Acct\">func Acct(path string) (err error)</a></li>\n<li><a href=\"#Adjtimex\">func Adjtimex(buf *Timex) (state int, err error)</a></li>\n<li><a href=\"#AttachLsf\">func AttachLsf(fd int, i []SockFilter) error</a></li>\n<li><a href=\"#Bind\">func Bind(fd int, sa Sockaddr) (err error)</a></li>\n<li><a href=\"#BindToDevice\">func BindToDevice(fd int, device string) (err error)</a></li>\n<li><a href=\"#BytePtrFromString\">func BytePtrFromString(s string) (*byte, error)</a></li>\n<li><a href=\"#ByteSliceFromString\">func ByteSliceFromString(s string) ([]byte, error)</a></li>\n<li><a href=\"#Chdir\">func Chdir(path string) (err error)</a></li>\n<li><a href=\"#Chmod\">func Chmod(path string, mode uint32) (err error)</a></li>\n<li><a href=\"#Chown\">func Chown(path string, uid int, gid int) (err error)</a></li>\n<li><a href=\"#Chroot\">func Chroot(path string) (err error)</a></li>\n<li><a href=\"#Clearenv\">func Clearenv()</a></li>\n<li><a href=\"#Close\">func Close(fd int) (err error)</a></li>\n<li><a href=\"#CloseOnExec\">func CloseOnExec(fd int)</a></li>\n<li><a href=\"#CmsgLen\">func CmsgLen(datalen int) int</a></li>\n<li><a href=\"#CmsgSpace\">func CmsgSpace(datalen int) int</a></li>\n<li><a href=\"#Connect\">func Connect(fd int, sa Sockaddr) (err error)</a></li>\n<li><a href=\"#Creat\">func Creat(path string, mode uint32) (fd int, err error)</a></li>\n<li><a href=\"#DetachLsf\">func DetachLsf(fd int) error</a></li>\n<li><a href=\"#Dup\">func Dup(oldfd int) (fd int, err error)</a></li>\n<li><a href=\"#Dup2\">func Dup2(oldfd int, newfd int) (err error)</a></li>\n<li><a href=\"#Dup3\">func Dup3(oldfd int, newfd int, flags int) (err error)</a></li>\n<li><a href=\"#Environ\">func Environ() []string</a></li>\n<li><a href=\"#EpollCreate\">func EpollCreate(size int) (fd int, err error)</a></li>\n<li><a href=\"#EpollCreate1\">func EpollCreate1(flag int) (fd int, err error)</a></li>\n<li><a href=\"#EpollCtl\">func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error)</a></li>\n<li><a href=\"#EpollWait\">func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error)</a></li>\n<li><a href=\"#Exec\">func Exec(argv0 string, argv []string, envv []string) (err error)</a></li>\n<li><a href=\"#Exit\">func Exit(code int)</a></li>\n<li><a href=\"#Faccessat\">func Faccessat(dirfd int, path string, mode uint32, flags int) (err error)</a></li>\n<li><a href=\"#Fallocate\">func Fallocate(fd int, mode uint32, off int64, len int64) (err error)</a></li>\n<li><a href=\"#Fchdir\">func Fchdir(fd int) (err error)</a></li>\n<li><a href=\"#Fchmod\">func Fchmod(fd int, mode uint32) (err error)</a></li>\n<li><a href=\"#Fchmodat\">func Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)</a></li>\n<li><a href=\"#Fchown\">func Fchown(fd int, uid int, gid int) (err error)</a></li>\n<li><a href=\"#Fchownat\">func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)</a></li>\n<li><a href=\"#FcntlFlock\">func FcntlFlock(fd uintptr, cmd int, lk *Flock_t) error</a></li>\n<li><a href=\"#Fdatasync\">func Fdatasync(fd int) (err error)</a></li>\n<li><a href=\"#Flock\">func Flock(fd int, how int) (err error)</a></li>\n<li><a href=\"#ForkExec\">func ForkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)</a></li>\n<li><a href=\"#Fstat\">func Fstat(fd int, stat *Stat_t) (err error)</a></li>\n<li><a href=\"#Fstatfs\">func Fstatfs(fd int, buf *Statfs_t) (err error)</a></li>\n<li><a href=\"#Fsync\">func Fsync(fd int) (err error)</a></li>\n<li><a href=\"#Ftruncate\">func Ftruncate(fd int, length int64) (err error)</a></li>\n<li><a href=\"#Futimes\">func Futimes(fd int, tv []Timeval) (err error)</a></li>\n<li><a href=\"#Futimesat\">func Futimesat(dirfd int, path string, tv []Timeval) (err error)</a></li>\n<li><a href=\"#Getcwd\">func Getcwd(buf []byte) (n int, err error)</a></li>\n<li><a href=\"#Getdents\">func Getdents(fd int, buf []byte) (n int, err error)</a></li>\n<li><a href=\"#Getegid\">func Getegid() (egid int)</a></li>\n<li><a href=\"#Getenv\">func Getenv(key string) (value string, found bool)</a></li>\n<li><a href=\"#Geteuid\">func Geteuid() (euid int)</a></li>\n<li><a href=\"#Getgid\">func Getgid() (gid int)</a></li>\n<li><a href=\"#Getgroups\">func Getgroups() (gids []int, err error)</a></li>\n<li><a href=\"#Getpagesize\">func Getpagesize() int</a></li>\n<li><a href=\"#Getpgid\">func Getpgid(pid int) (pgid int, err error)</a></li>\n<li><a href=\"#Getpgrp\">func Getpgrp() (pid int)</a></li>\n<li><a href=\"#Getpid\">func Getpid() (pid int)</a></li>\n<li><a href=\"#Getppid\">func Getppid() (ppid int)</a></li>\n<li><a href=\"#Getpriority\">func Getpriority(which int, who int) (prio int, err error)</a></li>\n<li><a href=\"#Getrlimit\">func Getrlimit(resource int, rlim *Rlimit) (err error)</a></li>\n<li><a href=\"#Getrusage\">func Getrusage(who int, rusage *Rusage) (err error)</a></li>\n<li><a href=\"#GetsockoptInet4Addr\">func GetsockoptInet4Addr(fd, level, opt int) (value [4]byte, err error)</a></li>\n<li><a href=\"#GetsockoptInt\">func GetsockoptInt(fd, level, opt int) (value int, err error)</a></li>\n<li><a href=\"#Gettid\">func Gettid() (tid int)</a></li>\n<li><a href=\"#Gettimeofday\">func Gettimeofday(tv *Timeval) (err error)</a></li>\n<li><a href=\"#Getuid\">func Getuid() (uid int)</a></li>\n<li><a href=\"#Getwd\">func Getwd() (wd string, err error)</a></li>\n<li><a href=\"#Getxattr\">func Getxattr(path string, attr string, dest []byte) (sz int, err error)</a></li>\n<li><a href=\"#InotifyAddWatch\">func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error)</a></li>\n<li><a href=\"#InotifyInit\">func InotifyInit() (fd int, err error)</a></li>\n<li><a href=\"#InotifyInit1\">func InotifyInit1(flags int) (fd int, err error)</a></li>\n<li><a href=\"#InotifyRmWatch\">func InotifyRmWatch(fd int, watchdesc uint32) (success int, err error)</a></li>\n<li><a href=\"#Ioperm\">func Ioperm(from int, num int, on int) (err error)</a></li>\n<li><a href=\"#Iopl\">func Iopl(level int) (err error)</a></li>\n<li><a href=\"#Kill\">func Kill(pid int, sig Signal) (err error)</a></li>\n<li><a href=\"#Klogctl\">func Klogctl(typ int, buf []byte) (n int, err error)</a></li>\n<li><a href=\"#Lchown\">func Lchown(path string, uid int, gid int) (err error)</a></li>\n<li><a href=\"#Link\">func Link(oldpath string, newpath string) (err error)</a></li>\n<li><a href=\"#Listen\">func Listen(s int, n int) (err error)</a></li>\n<li><a href=\"#Listxattr\">func Listxattr(path string, dest []byte) (sz int, err error)</a></li>\n<li><a href=\"#LsfSocket\">func LsfSocket(ifindex, proto int) (int, error)</a></li>\n<li><a href=\"#Lstat\">func Lstat(path string, stat *Stat_t) (err error)</a></li>\n<li><a href=\"#Madvise\">func Madvise(b []byte, advice int) (err error)</a></li>\n<li><a href=\"#Mkdir\">func Mkdir(path string, mode uint32) (err error)</a></li>\n<li><a href=\"#Mkdirat\">func Mkdirat(dirfd int, path string, mode uint32) (err error)</a></li>\n<li><a href=\"#Mkfifo\">func Mkfifo(path string, mode uint32) (err error)</a></li>\n<li><a href=\"#Mknod\">func Mknod(path string, mode uint32, dev int) (err error)</a></li>\n<li><a href=\"#Mknodat\">func Mknodat(dirfd int, path string, mode uint32, dev int) (err error)</a></li>\n<li><a href=\"#Mlock\">func Mlock(b []byte) (err error)</a></li>\n<li><a href=\"#Mlockall\">func Mlockall(flags int) (err error)</a></li>\n<li><a href=\"#Mmap\">func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error)</a></li>\n<li><a href=\"#Mount\">func Mount(source string, target string, fstype string, flags uintptr, data string) (err error)</a></li>\n<li><a href=\"#Mprotect\">func Mprotect(b []byte, prot int) (err error)</a></li>\n<li><a href=\"#Munlock\">func Munlock(b []byte) (err error)</a></li>\n<li><a href=\"#Munlockall\">func Munlockall() (err error)</a></li>\n<li><a href=\"#Munmap\">func Munmap(b []byte) (err error)</a></li>\n<li><a href=\"#Nanosleep\">func Nanosleep(time *Timespec, leftover *Timespec) (err error)</a></li>\n<li><a href=\"#NetlinkRIB\">func NetlinkRIB(proto, family int) ([]byte, error)</a></li>\n<li><a href=\"#Open\">func Open(path string, mode int, perm uint32) (fd int, err error)</a></li>\n<li><a href=\"#Openat\">func Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)</a></li>\n<li><a href=\"#ParseDirent\">func ParseDirent(buf []byte, max int, names []string) (consumed int, count int, newnames []string)</a></li>\n<li><a href=\"#ParseNetlinkMessage\">func ParseNetlinkMessage(b []byte) ([]NetlinkMessage, error)</a></li>\n<li><a href=\"#ParseNetlinkRouteAttr\">func ParseNetlinkRouteAttr(m *NetlinkMessage) ([]NetlinkRouteAttr, error)</a></li>\n<li><a href=\"#ParseSocketControlMessage\">func ParseSocketControlMessage(b []byte) ([]SocketControlMessage, error)</a></li>\n<li><a href=\"#ParseUnixRights\">func ParseUnixRights(m *SocketControlMessage) ([]int, error)</a></li>\n<li><a href=\"#Pause\">func Pause() (err error)</a></li>\n<li><a href=\"#Pipe\">func Pipe(p []int) (err error)</a></li>\n<li><a href=\"#Pipe2\">func Pipe2(p []int, flags int) (err error)</a></li>\n<li><a href=\"#PivotRoot\">func PivotRoot(newroot string, putold string) (err error)</a></li>\n<li><a href=\"#Pread\">func Pread(fd int, p []byte, offset int64) (n int, err error)</a></li>\n<li><a href=\"#PtraceAttach\">func PtraceAttach(pid int) (err error)</a></li>\n<li><a href=\"#PtraceCont\">func PtraceCont(pid int, signal int) (err error)</a></li>\n<li><a href=\"#PtraceDetach\">func PtraceDetach(pid int) (err error)</a></li>\n<li><a href=\"#PtraceGetEventMsg\">func PtraceGetEventMsg(pid int) (msg uint, err error)</a></li>\n<li><a href=\"#PtraceGetRegs\">func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error)</a></li>\n<li><a href=\"#PtracePeekData\">func PtracePeekData(pid int, addr uintptr, out []byte) (count int, err error)</a></li>\n<li><a href=\"#PtracePeekText\">func PtracePeekText(pid int, addr uintptr, out []byte) (count int, err error)</a></li>\n<li><a href=\"#PtracePokeData\">func PtracePokeData(pid int, addr uintptr, data []byte) (count int, err error)</a></li>\n<li><a href=\"#PtracePokeText\">func PtracePokeText(pid int, addr uintptr, data []byte) (count int, err error)</a></li>\n<li><a href=\"#PtraceSetOptions\">func PtraceSetOptions(pid int, options int) (err error)</a></li>\n<li><a href=\"#PtraceSetRegs\">func PtraceSetRegs(pid int, regs *PtraceRegs) (err error)</a></li>\n<li><a href=\"#PtraceSingleStep\">func PtraceSingleStep(pid int) (err error)</a></li>\n<li><a href=\"#PtraceSyscall\">func PtraceSyscall(pid int, signal int) (err error)</a></li>\n<li><a href=\"#Pwrite\">func Pwrite(fd int, p []byte, offset int64) (n int, err error)</a></li>\n<li><a href=\"#RawSyscall\">func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)</a></li>\n<li><a href=\"#RawSyscall6\">func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)</a></li>\n<li><a href=\"#Read\">func Read(fd int, p []byte) (n int, err error)</a></li>\n<li><a href=\"#ReadDirent\">func ReadDirent(fd int, buf []byte) (n int, err error)</a></li>\n<li><a href=\"#Readlink\">func Readlink(path string, buf []byte) (n int, err error)</a></li>\n<li><a href=\"#Reboot\">func Reboot(cmd int) (err error)</a></li>\n<li><a href=\"#Recvfrom\">func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, err error)</a></li>\n<li><a href=\"#Recvmsg\">func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error)</a></li>\n<li><a href=\"#Removexattr\">func Removexattr(path string, attr string) (err error)</a></li>\n<li><a href=\"#Rename\">func Rename(oldpath string, newpath string) (err error)</a></li>\n<li><a href=\"#Renameat\">func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)</a></li>\n<li><a href=\"#Rmdir\">func Rmdir(path string) error</a></li>\n<li><a href=\"#Seek\">func Seek(fd int, offset int64, whence int) (off int64, err error)</a></li>\n<li><a href=\"#Select\">func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)</a></li>\n<li><a href=\"#Sendfile\">func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)</a></li>\n<li><a href=\"#Sendmsg\">func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (err error)</a></li>\n<li><a href=\"#SendmsgN\">func SendmsgN(fd int, p, oob []byte, to Sockaddr, flags int) (n int, err error)</a></li>\n<li><a href=\"#Sendto\">func Sendto(fd int, p []byte, flags int, to Sockaddr) (err error)</a></li>\n<li><a href=\"#SetLsfPromisc\">func SetLsfPromisc(name string, m bool) error</a></li>\n<li><a href=\"#SetNonblock\">func SetNonblock(fd int, nonblocking bool) (err error)</a></li>\n<li><a href=\"#Setdomainname\">func Setdomainname(p []byte) (err error)</a></li>\n<li><a href=\"#Setenv\">func Setenv(key, value string) error</a></li>\n<li><a href=\"#Setfsgid\">func Setfsgid(gid int) (err error)</a></li>\n<li><a href=\"#Setfsuid\">func Setfsuid(uid int) (err error)</a></li>\n<li><a href=\"#Setgid\">func Setgid(gid int) (err error)</a></li>\n<li><a href=\"#Setgroups\">func Setgroups(gids []int) (err error)</a></li>\n<li><a href=\"#Sethostname\">func Sethostname(p []byte) (err error)</a></li>\n<li><a href=\"#Setpgid\">func Setpgid(pid int, pgid int) (err error)</a></li>\n<li><a href=\"#Setpriority\">func Setpriority(which int, who int, prio int) (err error)</a></li>\n<li><a href=\"#Setregid\">func Setregid(rgid int, egid int) (err error)</a></li>\n<li><a href=\"#Setresgid\">func Setresgid(rgid int, egid int, sgid int) (err error)</a></li>\n<li><a href=\"#Setresuid\">func Setresuid(ruid int, euid int, suid int) (err error)</a></li>\n<li><a href=\"#Setreuid\">func Setreuid(ruid int, euid int) (err error)</a></li>\n<li><a href=\"#Setrlimit\">func Setrlimit(resource int, rlim *Rlimit) (err error)</a></li>\n<li><a href=\"#Setsid\">func Setsid() (pid int, err error)</a></li>\n<li><a href=\"#SetsockoptByte\">func SetsockoptByte(fd, level, opt int, value byte) (err error)</a></li>\n<li><a href=\"#SetsockoptICMPv6Filter\">func SetsockoptICMPv6Filter(fd, level, opt int, filter *ICMPv6Filter) error</a></li>\n<li><a href=\"#SetsockoptIPMreq\">func SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (err error)</a></li>\n<li><a href=\"#SetsockoptIPMreqn\">func SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error)</a></li>\n<li><a href=\"#SetsockoptIPv6Mreq\">func SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (err error)</a></li>\n<li><a href=\"#SetsockoptInet4Addr\">func SetsockoptInet4Addr(fd, level, opt int, value [4]byte) (err error)</a></li>\n<li><a href=\"#SetsockoptInt\">func SetsockoptInt(fd, level, opt int, value int) (err error)</a></li>\n<li><a href=\"#SetsockoptLinger\">func SetsockoptLinger(fd, level, opt int, l *Linger) (err error)</a></li>\n<li><a href=\"#SetsockoptString\">func SetsockoptString(fd, level, opt int, s string) (err error)</a></li>\n<li><a href=\"#SetsockoptTimeval\">func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (err error)</a></li>\n<li><a href=\"#Settimeofday\">func Settimeofday(tv *Timeval) (err error)</a></li>\n<li><a href=\"#Setuid\">func Setuid(uid int) (err error)</a></li>\n<li><a href=\"#Setxattr\">func Setxattr(path string, attr string, data []byte, flags int) (err error)</a></li>\n<li><a href=\"#Shutdown\">func Shutdown(fd int, how int) (err error)</a></li>\n<li><a href=\"#SlicePtrFromStrings\">func SlicePtrFromStrings(ss []string) ([]*byte, error)</a></li>\n<li><a href=\"#Socket\">func Socket(domain, typ, proto int) (fd int, err error)</a></li>\n<li><a href=\"#Socketpair\">func Socketpair(domain, typ, proto int) (fd [2]int, err error)</a></li>\n<li><a href=\"#Splice\">func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)</a></li>\n<li><a href=\"#StartProcess\">func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error)</a></li>\n<li><a href=\"#Stat\">func Stat(path string, stat *Stat_t) (err error)</a></li>\n<li><a href=\"#Statfs\">func Statfs(path string, buf *Statfs_t) (err error)</a></li>\n<li><a href=\"#StringBytePtr\">func StringBytePtr(s string) *byte</a></li>\n<li><a href=\"#StringByteSlice\">func StringByteSlice(s string) []byte</a></li>\n<li><a href=\"#StringSlicePtr\">func StringSlicePtr(ss []string) []*byte</a></li>\n<li><a href=\"#Symlink\">func Symlink(oldpath string, newpath string) (err error)</a></li>\n<li><a href=\"#Sync\">func Sync()</a></li>\n<li><a href=\"#SyncFileRange\">func SyncFileRange(fd int, off int64, n int64, flags int) (err error)</a></li>\n<li><a href=\"#Syscall\">func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)</a></li>\n<li><a href=\"#Syscall6\">func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)</a></li>\n<li><a href=\"#Sysinfo\">func Sysinfo(info *Sysinfo_t) (err error)</a></li>\n<li><a href=\"#Tee\">func Tee(rfd int, wfd int, len int, flags int) (n int64, err error)</a></li>\n<li><a href=\"#Tgkill\">func Tgkill(tgid int, tid int, sig Signal) (err error)</a></li>\n<li><a href=\"#Times\">func Times(tms *Tms) (ticks uintptr, err error)</a></li>\n<li><a href=\"#TimespecToNsec\">func TimespecToNsec(ts Timespec) int64</a></li>\n<li><a href=\"#TimevalToNsec\">func TimevalToNsec(tv Timeval) int64</a></li>\n<li><a href=\"#Truncate\">func Truncate(path string, length int64) (err error)</a></li>\n<li><a href=\"#Umask\">func Umask(mask int) (oldmask int)</a></li>\n<li><a href=\"#Uname\">func Uname(buf *Utsname) (err error)</a></li>\n<li><a href=\"#UnixCredentials\">func UnixCredentials(ucred *Ucred) []byte</a></li>\n<li><a href=\"#UnixRights\">func UnixRights(fds ...int) []byte</a></li>\n<li><a href=\"#Unlink\">func Unlink(path string) error</a></li>\n<li><a href=\"#Unlinkat\">func Unlinkat(dirfd int, path string) error</a></li>\n<li><a href=\"#Unmount\">func Unmount(target string, flags int) (err error)</a></li>\n<li><a href=\"#Unsetenv\">func Unsetenv(key string) error</a></li>\n<li><a href=\"#Unshare\">func Unshare(flags int) (err error)</a></li>\n<li><a href=\"#Ustat\">func Ustat(dev int, ubuf *Ustat_t) (err error)</a></li>\n<li><a href=\"#Utime\">func Utime(path string, buf *Utimbuf) (err error)</a></li>\n<li><a href=\"#Utimes\">func Utimes(path string, tv []Timeval) (err error)</a></li>\n<li><a href=\"#UtimesNano\">func UtimesNano(path string, ts []Timespec) (err error)</a></li>\n<li><a href=\"#Wait4\">func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error)</a></li>\n<li><a href=\"#Write\">func Write(fd int, p []byte) (n int, err error)</a></li>\n<li><a href=\"#Cmsghdr\">type Cmsghdr</a></li>\n<li> <a href=\"#Cmsghdr.SetLen\">func (cmsg *Cmsghdr) SetLen(length int)</a>\n</li>\n<li><a href=\"#Credential\">type Credential</a></li>\n<li><a href=\"#Dirent\">type Dirent</a></li>\n<li><a href=\"#EpollEvent\">type EpollEvent</a></li>\n<li><a href=\"#Errno\">type Errno</a></li>\n<li> <a href=\"#Errno.Error\">func (e Errno) Error() string</a>\n</li>\n<li> <a href=\"#Errno.Temporary\">func (e Errno) Temporary() bool</a>\n</li>\n<li> <a href=\"#Errno.Timeout\">func (e Errno) Timeout() bool</a>\n</li>\n<li><a href=\"#FdSet\">type FdSet</a></li>\n<li><a href=\"#Flock_t\">type Flock_t</a></li>\n<li><a href=\"#Fsid\">type Fsid</a></li>\n<li><a href=\"#ICMPv6Filter\">type ICMPv6Filter</a></li>\n<li> <a href=\"#GetsockoptICMPv6Filter\">func GetsockoptICMPv6Filter(fd, level, opt int) (*ICMPv6Filter, error)</a>\n</li>\n<li><a href=\"#IPMreq\">type IPMreq</a></li>\n<li> <a href=\"#GetsockoptIPMreq\">func GetsockoptIPMreq(fd, level, opt int) (*IPMreq, error)</a>\n</li>\n<li><a href=\"#IPMreqn\">type IPMreqn</a></li>\n<li> <a href=\"#GetsockoptIPMreqn\">func GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error)</a>\n</li>\n<li><a href=\"#IPv6MTUInfo\">type IPv6MTUInfo</a></li>\n<li> <a href=\"#GetsockoptIPv6MTUInfo\">func GetsockoptIPv6MTUInfo(fd, level, opt int) (*IPv6MTUInfo, error)</a>\n</li>\n<li><a href=\"#IPv6Mreq\">type IPv6Mreq</a></li>\n<li> <a href=\"#GetsockoptIPv6Mreq\">func GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error)</a>\n</li>\n<li><a href=\"#IfAddrmsg\">type IfAddrmsg</a></li>\n<li><a href=\"#IfInfomsg\">type IfInfomsg</a></li>\n<li><a href=\"#Inet4Pktinfo\">type Inet4Pktinfo</a></li>\n<li><a href=\"#Inet6Pktinfo\">type Inet6Pktinfo</a></li>\n<li><a href=\"#InotifyEvent\">type InotifyEvent</a></li>\n<li><a href=\"#Iovec\">type Iovec</a></li>\n<li> <a href=\"#Iovec.SetLen\">func (iov *Iovec) SetLen(length int)</a>\n</li>\n<li><a href=\"#Linger\">type Linger</a></li>\n<li><a href=\"#Msghdr\">type Msghdr</a></li>\n<li> <a href=\"#Msghdr.SetControllen\">func (msghdr *Msghdr) SetControllen(length int)</a>\n</li>\n<li><a href=\"#NetlinkMessage\">type NetlinkMessage</a></li>\n<li><a href=\"#NetlinkRouteAttr\">type NetlinkRouteAttr</a></li>\n<li><a href=\"#NetlinkRouteRequest\">type NetlinkRouteRequest</a></li>\n<li><a href=\"#NlAttr\">type NlAttr</a></li>\n<li><a href=\"#NlMsgerr\">type NlMsgerr</a></li>\n<li><a href=\"#NlMsghdr\">type NlMsghdr</a></li>\n<li><a href=\"#ProcAttr\">type ProcAttr</a></li>\n<li><a href=\"#PtraceRegs\">type PtraceRegs</a></li>\n<li> <a href=\"#PtraceRegs.PC\">func (r *PtraceRegs) PC() uint64</a>\n</li>\n<li> <a href=\"#PtraceRegs.SetPC\">func (r *PtraceRegs) SetPC(pc uint64)</a>\n</li>\n<li><a href=\"#RawSockaddr\">type RawSockaddr</a></li>\n<li><a href=\"#RawSockaddrAny\">type RawSockaddrAny</a></li>\n<li><a href=\"#RawSockaddrInet4\">type RawSockaddrInet4</a></li>\n<li><a href=\"#RawSockaddrInet6\">type RawSockaddrInet6</a></li>\n<li><a href=\"#RawSockaddrLinklayer\">type RawSockaddrLinklayer</a></li>\n<li><a href=\"#RawSockaddrNetlink\">type RawSockaddrNetlink</a></li>\n<li><a href=\"#RawSockaddrUnix\">type RawSockaddrUnix</a></li>\n<li><a href=\"#Rlimit\">type Rlimit</a></li>\n<li><a href=\"#RtAttr\">type RtAttr</a></li>\n<li><a href=\"#RtGenmsg\">type RtGenmsg</a></li>\n<li><a href=\"#RtMsg\">type RtMsg</a></li>\n<li><a href=\"#RtNexthop\">type RtNexthop</a></li>\n<li><a href=\"#Rusage\">type Rusage</a></li>\n<li><a href=\"#Signal\">type Signal</a></li>\n<li> <a href=\"#Signal.Signal\">func (s Signal) Signal()</a>\n</li>\n<li> <a href=\"#Signal.String\">func (s Signal) String() string</a>\n</li>\n<li><a href=\"#SockFilter\">type SockFilter</a></li>\n<li> <a href=\"#LsfJump\">func LsfJump(code, k, jt, jf int) *SockFilter</a>\n</li>\n<li> <a href=\"#LsfStmt\">func LsfStmt(code, k int) *SockFilter</a>\n</li>\n<li><a href=\"#SockFprog\">type SockFprog</a></li>\n<li><a href=\"#Sockaddr\">type Sockaddr</a></li>\n<li> <a href=\"#Getpeername\">func Getpeername(fd int) (sa Sockaddr, err error)</a>\n</li>\n<li> <a href=\"#Getsockname\">func Getsockname(fd int) (sa Sockaddr, err error)</a>\n</li>\n<li><a href=\"#SockaddrInet4\">type SockaddrInet4</a></li>\n<li><a href=\"#SockaddrInet6\">type SockaddrInet6</a></li>\n<li><a href=\"#SockaddrLinklayer\">type SockaddrLinklayer</a></li>\n<li><a href=\"#SockaddrNetlink\">type SockaddrNetlink</a></li>\n<li><a href=\"#SockaddrUnix\">type SockaddrUnix</a></li>\n<li><a href=\"#SocketControlMessage\">type SocketControlMessage</a></li>\n<li><a href=\"#Stat_t\">type Stat_t</a></li>\n<li><a href=\"#Statfs_t\">type Statfs_t</a></li>\n<li><a href=\"#SysProcAttr\">type SysProcAttr</a></li>\n<li><a href=\"#SysProcIDMap\">type SysProcIDMap</a></li>\n<li><a href=\"#Sysinfo_t\">type Sysinfo_t</a></li>\n<li><a href=\"#TCPInfo\">type TCPInfo</a></li>\n<li><a href=\"#Termios\">type Termios</a></li>\n<li><a href=\"#Time_t\">type Time_t</a></li>\n<li> <a href=\"#Time\">func Time(t *Time_t) (tt Time_t, err error)</a>\n</li>\n<li><a href=\"#Timespec\">type Timespec</a></li>\n<li> <a href=\"#NsecToTimespec\">func NsecToTimespec(nsec int64) (ts Timespec)</a>\n</li>\n<li> <a href=\"#Timespec.Nano\">func (ts *Timespec) Nano() int64</a>\n</li>\n<li> <a href=\"#Timespec.Unix\">func (ts *Timespec) Unix() (sec int64, nsec int64)</a>\n</li>\n<li><a href=\"#Timeval\">type Timeval</a></li>\n<li> <a href=\"#NsecToTimeval\">func NsecToTimeval(nsec int64) (tv Timeval)</a>\n</li>\n<li> <a href=\"#Timeval.Nano\">func (tv *Timeval) Nano() int64</a>\n</li>\n<li> <a href=\"#Timeval.Unix\">func (tv *Timeval) Unix() (sec int64, nsec int64)</a>\n</li>\n<li><a href=\"#Timex\">type Timex</a></li>\n<li><a href=\"#Tms\">type Tms</a></li>\n<li><a href=\"#Ucred\">type Ucred</a></li>\n<li> <a href=\"#GetsockoptUcred\">func GetsockoptUcred(fd, level, opt int) (*Ucred, error)</a>\n</li>\n<li> <a href=\"#ParseUnixCredentials\">func ParseUnixCredentials(m *SocketControlMessage) (*Ucred, error)</a>\n</li>\n<li><a href=\"#Ustat_t\">type Ustat_t</a></li>\n<li><a href=\"#Utimbuf\">type Utimbuf</a></li>\n<li><a href=\"#Utsname\">type Utsname</a></li>\n<li><a href=\"#WaitStatus\">type WaitStatus</a></li>\n<li> <a href=\"#WaitStatus.Continued\">func (w WaitStatus) Continued() bool</a>\n</li>\n<li> <a href=\"#WaitStatus.CoreDump\">func (w WaitStatus) CoreDump() bool</a>\n</li>\n<li> <a href=\"#WaitStatus.ExitStatus\">func (w WaitStatus) ExitStatus() int</a>\n</li>\n<li> <a href=\"#WaitStatus.Exited\">func (w WaitStatus) Exited() bool</a>\n</li>\n<li> <a href=\"#WaitStatus.Signal\">func (w WaitStatus) Signal() Signal</a>\n</li>\n<li> <a href=\"#WaitStatus.Signaled\">func (w WaitStatus) Signaled() bool</a>\n</li>\n<li> <a href=\"#WaitStatus.StopSignal\">func (w WaitStatus) StopSignal() Signal</a>\n</li>\n<li> <a href=\"#WaitStatus.Stopped\">func (w WaitStatus) Stopped() bool</a>\n</li>\n<li> <a href=\"#WaitStatus.TrapCause\">func (w WaitStatus) TrapCause() int</a>\n</li>\n</ul> <h4>Package files</h4> <p> <span style=\"font-size:90%\"> <a href=\"https://golang.org/src/syscall/env_unix.go\">env_unix.go</a> <a href=\"https://golang.org/src/syscall/exec_linux.go\">exec_linux.go</a> <a href=\"https://golang.org/src/syscall/exec_unix.go\">exec_unix.go</a> <a href=\"https://golang.org/src/syscall/flock.go\">flock.go</a> <a href=\"https://golang.org/src/syscall/lsf_linux.go\">lsf_linux.go</a> <a href=\"https://golang.org/src/syscall/msan0.go\">msan0.go</a> <a href=\"https://golang.org/src/syscall/netlink_linux.go\">netlink_linux.go</a> <a href=\"https://golang.org/src/syscall/sockcmsg_linux.go\">sockcmsg_linux.go</a> <a href=\"https://golang.org/src/syscall/sockcmsg_unix.go\">sockcmsg_unix.go</a> <a href=\"https://golang.org/src/syscall/str.go\">str.go</a> <a href=\"https://golang.org/src/syscall/syscall.go\">syscall.go</a> <a href=\"https://golang.org/src/syscall/syscall_linux.go\">syscall_linux.go</a> <a href=\"https://golang.org/src/syscall/syscall_linux_amd64.go\">syscall_linux_amd64.go</a> <a href=\"https://golang.org/src/syscall/syscall_unix.go\">syscall_unix.go</a> <a href=\"https://golang.org/src/syscall/zerrors_linux_amd64.go\">zerrors_linux_amd64.go</a> <a href=\"https://golang.org/src/syscall/zsyscall_linux_amd64.go\">zsyscall_linux_amd64.go</a> <a href=\"https://golang.org/src/syscall/zsysnum_linux_amd64.go\">zsysnum_linux_amd64.go</a> <a href=\"https://golang.org/src/syscall/ztypes_linux_amd64.go\">ztypes_linux_amd64.go</a> </span> </p> </div> </div> <div id=\"pkg-callgraph\" class=\"toggle\" style=\"display: none\">   <div class=\"expanded\"> <h2 class=\"toggleButton\" title=\"Click to hide Internal Call Graph section\">Internal call graph </h2> <p> In the call graph viewer below, each node is a function belonging to this package and its children are the functions it calls—perhaps dynamically. </p> <p> The root nodes are the entry points of the package: functions that may be called from outside the package. There may be non-exported or anonymous functions among them if they are called dynamically from another package. </p> <p> Click a node to visit that function's source code. From there you can visit its callers by clicking its declaring <code>func</code> token. </p> <p> Functions may be omitted if they were determined to be unreachable in the particular programs or tests that were analyzed. </p>   </div> </div>  <h2 id=\"pkg-constants\">Constants</h2> <pre data-language=\"go\">const (\n        AF_ALG                           = 0x26\n        AF_APPLETALK                     = 0x5\n        AF_ASH                           = 0x12\n        AF_ATMPVC                        = 0x8\n        AF_ATMSVC                        = 0x14\n        AF_AX25                          = 0x3\n        AF_BLUETOOTH                     = 0x1f\n        AF_BRIDGE                        = 0x7\n        AF_CAIF                          = 0x25\n        AF_CAN                           = 0x1d\n        AF_DECnet                        = 0xc\n        AF_ECONET                        = 0x13\n        AF_FILE                          = 0x1\n        AF_IEEE802154                    = 0x24\n        AF_INET                          = 0x2\n        AF_INET6                         = 0xa\n        AF_IPX                           = 0x4\n        AF_IRDA                          = 0x17\n        AF_ISDN                          = 0x22\n        AF_IUCV                          = 0x20\n        AF_KEY                           = 0xf\n        AF_LLC                           = 0x1a\n        AF_LOCAL                         = 0x1\n        AF_MAX                           = 0x27\n        AF_NETBEUI                       = 0xd\n        AF_NETLINK                       = 0x10\n        AF_NETROM                        = 0x6\n        AF_PACKET                        = 0x11\n        AF_PHONET                        = 0x23\n        AF_PPPOX                         = 0x18\n        AF_RDS                           = 0x15\n        AF_ROSE                          = 0xb\n        AF_ROUTE                         = 0x10\n        AF_RXRPC                         = 0x21\n        AF_SECURITY                      = 0xe\n        AF_SNA                           = 0x16\n        AF_TIPC                          = 0x1e\n        AF_UNIX                          = 0x1\n        AF_UNSPEC                        = 0x0\n        AF_WANPIPE                       = 0x19\n        AF_X25                           = 0x9\n        ARPHRD_ADAPT                     = 0x108\n        ARPHRD_APPLETLK                  = 0x8\n        ARPHRD_ARCNET                    = 0x7\n        ARPHRD_ASH                       = 0x30d\n        ARPHRD_ATM                       = 0x13\n        ARPHRD_AX25                      = 0x3\n        ARPHRD_BIF                       = 0x307\n        ARPHRD_CHAOS                     = 0x5\n        ARPHRD_CISCO                     = 0x201\n        ARPHRD_CSLIP                     = 0x101\n        ARPHRD_CSLIP6                    = 0x103\n        ARPHRD_DDCMP                     = 0x205\n        ARPHRD_DLCI                      = 0xf\n        ARPHRD_ECONET                    = 0x30e\n        ARPHRD_EETHER                    = 0x2\n        ARPHRD_ETHER                     = 0x1\n        ARPHRD_EUI64                     = 0x1b\n        ARPHRD_FCAL                      = 0x311\n        ARPHRD_FCFABRIC                  = 0x313\n        ARPHRD_FCPL                      = 0x312\n        ARPHRD_FCPP                      = 0x310\n        ARPHRD_FDDI                      = 0x306\n        ARPHRD_FRAD                      = 0x302\n        ARPHRD_HDLC                      = 0x201\n        ARPHRD_HIPPI                     = 0x30c\n        ARPHRD_HWX25                     = 0x110\n        ARPHRD_IEEE1394                  = 0x18\n        ARPHRD_IEEE802                   = 0x6\n        ARPHRD_IEEE80211                 = 0x321\n        ARPHRD_IEEE80211_PRISM           = 0x322\n        ARPHRD_IEEE80211_RADIOTAP        = 0x323\n        ARPHRD_IEEE802154                = 0x324\n        ARPHRD_IEEE802154_PHY            = 0x325\n        ARPHRD_IEEE802_TR                = 0x320\n        ARPHRD_INFINIBAND                = 0x20\n        ARPHRD_IPDDP                     = 0x309\n        ARPHRD_IPGRE                     = 0x30a\n        ARPHRD_IRDA                      = 0x30f\n        ARPHRD_LAPB                      = 0x204\n        ARPHRD_LOCALTLK                  = 0x305\n        ARPHRD_LOOPBACK                  = 0x304\n        ARPHRD_METRICOM                  = 0x17\n        ARPHRD_NETROM                    = 0x0\n        ARPHRD_NONE                      = 0xfffe\n        ARPHRD_PIMREG                    = 0x30b\n        ARPHRD_PPP                       = 0x200\n        ARPHRD_PRONET                    = 0x4\n        ARPHRD_RAWHDLC                   = 0x206\n        ARPHRD_ROSE                      = 0x10e\n        ARPHRD_RSRVD                     = 0x104\n        ARPHRD_SIT                       = 0x308\n        ARPHRD_SKIP                      = 0x303\n        ARPHRD_SLIP                      = 0x100\n        ARPHRD_SLIP6                     = 0x102\n        ARPHRD_TUNNEL                    = 0x300\n        ARPHRD_TUNNEL6                   = 0x301\n        ARPHRD_VOID                      = 0xffff\n        ARPHRD_X25                       = 0x10f\n        BPF_A                            = 0x10\n        BPF_ABS                          = 0x20\n        BPF_ADD                          = 0x0\n        BPF_ALU                          = 0x4\n        BPF_AND                          = 0x50\n        BPF_B                            = 0x10\n        BPF_DIV                          = 0x30\n        BPF_H                            = 0x8\n        BPF_IMM                          = 0x0\n        BPF_IND                          = 0x40\n        BPF_JA                           = 0x0\n        BPF_JEQ                          = 0x10\n        BPF_JGE                          = 0x30\n        BPF_JGT                          = 0x20\n        BPF_JMP                          = 0x5\n        BPF_JSET                         = 0x40\n        BPF_K                            = 0x0\n        BPF_LD                           = 0x0\n        BPF_LDX                          = 0x1\n        BPF_LEN                          = 0x80\n        BPF_LSH                          = 0x60\n        BPF_MAJOR_VERSION                = 0x1\n        BPF_MAXINSNS                     = 0x1000\n        BPF_MEM                          = 0x60\n        BPF_MEMWORDS                     = 0x10\n        BPF_MINOR_VERSION                = 0x1\n        BPF_MISC                         = 0x7\n        BPF_MSH                          = 0xa0\n        BPF_MUL                          = 0x20\n        BPF_NEG                          = 0x80\n        BPF_OR                           = 0x40\n        BPF_RET                          = 0x6\n        BPF_RSH                          = 0x70\n        BPF_ST                           = 0x2\n        BPF_STX                          = 0x3\n        BPF_SUB                          = 0x10\n        BPF_TAX                          = 0x0\n        BPF_TXA                          = 0x80\n        BPF_W                            = 0x0\n        BPF_X                            = 0x8\n        CLONE_CHILD_CLEARTID             = 0x200000\n        CLONE_CHILD_SETTID               = 0x1000000\n        CLONE_DETACHED                   = 0x400000\n        CLONE_FILES                      = 0x400\n        CLONE_FS                         = 0x200\n        CLONE_IO                         = 0x80000000\n        CLONE_NEWIPC                     = 0x8000000\n        CLONE_NEWNET                     = 0x40000000\n        CLONE_NEWNS                      = 0x20000\n        CLONE_NEWPID                     = 0x20000000\n        CLONE_NEWUSER                    = 0x10000000\n        CLONE_NEWUTS                     = 0x4000000\n        CLONE_PARENT                     = 0x8000\n        CLONE_PARENT_SETTID              = 0x100000\n        CLONE_PTRACE                     = 0x2000\n        CLONE_SETTLS                     = 0x80000\n        CLONE_SIGHAND                    = 0x800\n        CLONE_SYSVSEM                    = 0x40000\n        CLONE_THREAD                     = 0x10000\n        CLONE_UNTRACED                   = 0x800000\n        CLONE_VFORK                      = 0x4000\n        CLONE_VM                         = 0x100\n        DT_BLK                           = 0x6\n        DT_CHR                           = 0x2\n        DT_DIR                           = 0x4\n        DT_FIFO                          = 0x1\n        DT_LNK                           = 0xa\n        DT_REG                           = 0x8\n        DT_SOCK                          = 0xc\n        DT_UNKNOWN                       = 0x0\n        DT_WHT                           = 0xe\n        EPOLLERR                         = 0x8\n        EPOLLET                          = -0x80000000\n        EPOLLHUP                         = 0x10\n        EPOLLIN                          = 0x1\n        EPOLLMSG                         = 0x400\n        EPOLLONESHOT                     = 0x40000000\n        EPOLLOUT                         = 0x4\n        EPOLLPRI                         = 0x2\n        EPOLLRDBAND                      = 0x80\n        EPOLLRDHUP                       = 0x2000\n        EPOLLRDNORM                      = 0x40\n        EPOLLWRBAND                      = 0x200\n        EPOLLWRNORM                      = 0x100\n        EPOLL_CLOEXEC                    = 0x80000\n        EPOLL_CTL_ADD                    = 0x1\n        EPOLL_CTL_DEL                    = 0x2\n        EPOLL_CTL_MOD                    = 0x3\n        EPOLL_NONBLOCK                   = 0x800\n        ETH_P_1588                       = 0x88f7\n        ETH_P_8021Q                      = 0x8100\n        ETH_P_802_2                      = 0x4\n        ETH_P_802_3                      = 0x1\n        ETH_P_AARP                       = 0x80f3\n        ETH_P_ALL                        = 0x3\n        ETH_P_AOE                        = 0x88a2\n        ETH_P_ARCNET                     = 0x1a\n        ETH_P_ARP                        = 0x806\n        ETH_P_ATALK                      = 0x809b\n        ETH_P_ATMFATE                    = 0x8884\n        ETH_P_ATMMPOA                    = 0x884c\n        ETH_P_AX25                       = 0x2\n        ETH_P_BPQ                        = 0x8ff\n        ETH_P_CAIF                       = 0xf7\n        ETH_P_CAN                        = 0xc\n        ETH_P_CONTROL                    = 0x16\n        ETH_P_CUST                       = 0x6006\n        ETH_P_DDCMP                      = 0x6\n        ETH_P_DEC                        = 0x6000\n        ETH_P_DIAG                       = 0x6005\n        ETH_P_DNA_DL                     = 0x6001\n        ETH_P_DNA_RC                     = 0x6002\n        ETH_P_DNA_RT                     = 0x6003\n        ETH_P_DSA                        = 0x1b\n        ETH_P_ECONET                     = 0x18\n        ETH_P_EDSA                       = 0xdada\n        ETH_P_FCOE                       = 0x8906\n        ETH_P_FIP                        = 0x8914\n        ETH_P_HDLC                       = 0x19\n        ETH_P_IEEE802154                 = 0xf6\n        ETH_P_IEEEPUP                    = 0xa00\n        ETH_P_IEEEPUPAT                  = 0xa01\n        ETH_P_IP                         = 0x800\n        ETH_P_IPV6                       = 0x86dd\n        ETH_P_IPX                        = 0x8137\n        ETH_P_IRDA                       = 0x17\n        ETH_P_LAT                        = 0x6004\n        ETH_P_LINK_CTL                   = 0x886c\n        ETH_P_LOCALTALK                  = 0x9\n        ETH_P_LOOP                       = 0x60\n        ETH_P_MOBITEX                    = 0x15\n        ETH_P_MPLS_MC                    = 0x8848\n        ETH_P_MPLS_UC                    = 0x8847\n        ETH_P_PAE                        = 0x888e\n        ETH_P_PAUSE                      = 0x8808\n        ETH_P_PHONET                     = 0xf5\n        ETH_P_PPPTALK                    = 0x10\n        ETH_P_PPP_DISC                   = 0x8863\n        ETH_P_PPP_MP                     = 0x8\n        ETH_P_PPP_SES                    = 0x8864\n        ETH_P_PUP                        = 0x200\n        ETH_P_PUPAT                      = 0x201\n        ETH_P_RARP                       = 0x8035\n        ETH_P_SCA                        = 0x6007\n        ETH_P_SLOW                       = 0x8809\n        ETH_P_SNAP                       = 0x5\n        ETH_P_TEB                        = 0x6558\n        ETH_P_TIPC                       = 0x88ca\n        ETH_P_TRAILER                    = 0x1c\n        ETH_P_TR_802_2                   = 0x11\n        ETH_P_WAN_PPP                    = 0x7\n        ETH_P_WCCP                       = 0x883e\n        ETH_P_X25                        = 0x805\n        FD_CLOEXEC                       = 0x1\n        FD_SETSIZE                       = 0x400\n        F_DUPFD                          = 0x0\n        F_DUPFD_CLOEXEC                  = 0x406\n        F_EXLCK                          = 0x4\n        F_GETFD                          = 0x1\n        F_GETFL                          = 0x3\n        F_GETLEASE                       = 0x401\n        F_GETLK                          = 0x5\n        F_GETLK64                        = 0x5\n        F_GETOWN                         = 0x9\n        F_GETOWN_EX                      = 0x10\n        F_GETPIPE_SZ                     = 0x408\n        F_GETSIG                         = 0xb\n        F_LOCK                           = 0x1\n        F_NOTIFY                         = 0x402\n        F_OK                             = 0x0\n        F_RDLCK                          = 0x0\n        F_SETFD                          = 0x2\n        F_SETFL                          = 0x4\n        F_SETLEASE                       = 0x400\n        F_SETLK                          = 0x6\n        F_SETLK64                        = 0x6\n        F_SETLKW                         = 0x7\n        F_SETLKW64                       = 0x7\n        F_SETOWN                         = 0x8\n        F_SETOWN_EX                      = 0xf\n        F_SETPIPE_SZ                     = 0x407\n        F_SETSIG                         = 0xa\n        F_SHLCK                          = 0x8\n        F_TEST                           = 0x3\n        F_TLOCK                          = 0x2\n        F_ULOCK                          = 0x0\n        F_UNLCK                          = 0x2\n        F_WRLCK                          = 0x1\n        ICMPV6_FILTER                    = 0x1\n        IFA_F_DADFAILED                  = 0x8\n        IFA_F_DEPRECATED                 = 0x20\n        IFA_F_HOMEADDRESS                = 0x10\n        IFA_F_NODAD                      = 0x2\n        IFA_F_OPTIMISTIC                 = 0x4\n        IFA_F_PERMANENT                  = 0x80\n        IFA_F_SECONDARY                  = 0x1\n        IFA_F_TEMPORARY                  = 0x1\n        IFA_F_TENTATIVE                  = 0x40\n        IFA_MAX                          = 0x7\n        IFF_ALLMULTI                     = 0x200\n        IFF_AUTOMEDIA                    = 0x4000\n        IFF_BROADCAST                    = 0x2\n        IFF_DEBUG                        = 0x4\n        IFF_DYNAMIC                      = 0x8000\n        IFF_LOOPBACK                     = 0x8\n        IFF_MASTER                       = 0x400\n        IFF_MULTICAST                    = 0x1000\n        IFF_NOARP                        = 0x80\n        IFF_NOTRAILERS                   = 0x20\n        IFF_NO_PI                        = 0x1000\n        IFF_ONE_QUEUE                    = 0x2000\n        IFF_POINTOPOINT                  = 0x10\n        IFF_PORTSEL                      = 0x2000\n        IFF_PROMISC                      = 0x100\n        IFF_RUNNING                      = 0x40\n        IFF_SLAVE                        = 0x800\n        IFF_TAP                          = 0x2\n        IFF_TUN                          = 0x1\n        IFF_TUN_EXCL                     = 0x8000\n        IFF_UP                           = 0x1\n        IFF_VNET_HDR                     = 0x4000\n        IFNAMSIZ                         = 0x10\n        IN_ACCESS                        = 0x1\n        IN_ALL_EVENTS                    = 0xfff\n        IN_ATTRIB                        = 0x4\n        IN_CLASSA_HOST                   = 0xffffff\n        IN_CLASSA_MAX                    = 0x80\n        IN_CLASSA_NET                    = 0xff000000\n        IN_CLASSA_NSHIFT                 = 0x18\n        IN_CLASSB_HOST                   = 0xffff\n        IN_CLASSB_MAX                    = 0x10000\n        IN_CLASSB_NET                    = 0xffff0000\n        IN_CLASSB_NSHIFT                 = 0x10\n        IN_CLASSC_HOST                   = 0xff\n        IN_CLASSC_NET                    = 0xffffff00\n        IN_CLASSC_NSHIFT                 = 0x8\n        IN_CLOEXEC                       = 0x80000\n        IN_CLOSE                         = 0x18\n        IN_CLOSE_NOWRITE                 = 0x10\n        IN_CLOSE_WRITE                   = 0x8\n        IN_CREATE                        = 0x100\n        IN_DELETE                        = 0x200\n        IN_DELETE_SELF                   = 0x400\n        IN_DONT_FOLLOW                   = 0x2000000\n        IN_EXCL_UNLINK                   = 0x4000000\n        IN_IGNORED                       = 0x8000\n        IN_ISDIR                         = 0x40000000\n        IN_LOOPBACKNET                   = 0x7f\n        IN_MASK_ADD                      = 0x20000000\n        IN_MODIFY                        = 0x2\n        IN_MOVE                          = 0xc0\n        IN_MOVED_FROM                    = 0x40\n        IN_MOVED_TO                      = 0x80\n        IN_MOVE_SELF                     = 0x800\n        IN_NONBLOCK                      = 0x800\n        IN_ONESHOT                       = 0x80000000\n        IN_ONLYDIR                       = 0x1000000\n        IN_OPEN                          = 0x20\n        IN_Q_OVERFLOW                    = 0x4000\n        IN_UNMOUNT                       = 0x2000\n        IPPROTO_AH                       = 0x33\n        IPPROTO_COMP                     = 0x6c\n        IPPROTO_DCCP                     = 0x21\n        IPPROTO_DSTOPTS                  = 0x3c\n        IPPROTO_EGP                      = 0x8\n        IPPROTO_ENCAP                    = 0x62\n        IPPROTO_ESP                      = 0x32\n        IPPROTO_FRAGMENT                 = 0x2c\n        IPPROTO_GRE                      = 0x2f\n        IPPROTO_HOPOPTS                  = 0x0\n        IPPROTO_ICMP                     = 0x1\n        IPPROTO_ICMPV6                   = 0x3a\n        IPPROTO_IDP                      = 0x16\n        IPPROTO_IGMP                     = 0x2\n        IPPROTO_IP                       = 0x0\n        IPPROTO_IPIP                     = 0x4\n        IPPROTO_IPV6                     = 0x29\n        IPPROTO_MTP                      = 0x5c\n        IPPROTO_NONE                     = 0x3b\n        IPPROTO_PIM                      = 0x67\n        IPPROTO_PUP                      = 0xc\n        IPPROTO_RAW                      = 0xff\n        IPPROTO_ROUTING                  = 0x2b\n        IPPROTO_RSVP                     = 0x2e\n        IPPROTO_SCTP                     = 0x84\n        IPPROTO_TCP                      = 0x6\n        IPPROTO_TP                       = 0x1d\n        IPPROTO_UDP                      = 0x11\n        IPPROTO_UDPLITE                  = 0x88\n        IPV6_2292DSTOPTS                 = 0x4\n        IPV6_2292HOPLIMIT                = 0x8\n        IPV6_2292HOPOPTS                 = 0x3\n        IPV6_2292PKTINFO                 = 0x2\n        IPV6_2292PKTOPTIONS              = 0x6\n        IPV6_2292RTHDR                   = 0x5\n        IPV6_ADDRFORM                    = 0x1\n        IPV6_ADD_MEMBERSHIP              = 0x14\n        IPV6_AUTHHDR                     = 0xa\n        IPV6_CHECKSUM                    = 0x7\n        IPV6_DROP_MEMBERSHIP             = 0x15\n        IPV6_DSTOPTS                     = 0x3b\n        IPV6_HOPLIMIT                    = 0x34\n        IPV6_HOPOPTS                     = 0x36\n        IPV6_IPSEC_POLICY                = 0x22\n        IPV6_JOIN_ANYCAST                = 0x1b\n        IPV6_JOIN_GROUP                  = 0x14\n        IPV6_LEAVE_ANYCAST               = 0x1c\n        IPV6_LEAVE_GROUP                 = 0x15\n        IPV6_MTU                         = 0x18\n        IPV6_MTU_DISCOVER                = 0x17\n        IPV6_MULTICAST_HOPS              = 0x12\n        IPV6_MULTICAST_IF                = 0x11\n        IPV6_MULTICAST_LOOP              = 0x13\n        IPV6_NEXTHOP                     = 0x9\n        IPV6_PKTINFO                     = 0x32\n        IPV6_PMTUDISC_DO                 = 0x2\n        IPV6_PMTUDISC_DONT               = 0x0\n        IPV6_PMTUDISC_PROBE              = 0x3\n        IPV6_PMTUDISC_WANT               = 0x1\n        IPV6_RECVDSTOPTS                 = 0x3a\n        IPV6_RECVERR                     = 0x19\n        IPV6_RECVHOPLIMIT                = 0x33\n        IPV6_RECVHOPOPTS                 = 0x35\n        IPV6_RECVPKTINFO                 = 0x31\n        IPV6_RECVRTHDR                   = 0x38\n        IPV6_RECVTCLASS                  = 0x42\n        IPV6_ROUTER_ALERT                = 0x16\n        IPV6_RTHDR                       = 0x39\n        IPV6_RTHDRDSTOPTS                = 0x37\n        IPV6_RTHDR_LOOSE                 = 0x0\n        IPV6_RTHDR_STRICT                = 0x1\n        IPV6_RTHDR_TYPE_0                = 0x0\n        IPV6_RXDSTOPTS                   = 0x3b\n        IPV6_RXHOPOPTS                   = 0x36\n        IPV6_TCLASS                      = 0x43\n        IPV6_UNICAST_HOPS                = 0x10\n        IPV6_V6ONLY                      = 0x1a\n        IPV6_XFRM_POLICY                 = 0x23\n        IP_ADD_MEMBERSHIP                = 0x23\n        IP_ADD_SOURCE_MEMBERSHIP         = 0x27\n        IP_BLOCK_SOURCE                  = 0x26\n        IP_DEFAULT_MULTICAST_LOOP        = 0x1\n        IP_DEFAULT_MULTICAST_TTL         = 0x1\n        IP_DF                            = 0x4000\n        IP_DROP_MEMBERSHIP               = 0x24\n        IP_DROP_SOURCE_MEMBERSHIP        = 0x28\n        IP_FREEBIND                      = 0xf\n        IP_HDRINCL                       = 0x3\n        IP_IPSEC_POLICY                  = 0x10\n        IP_MAXPACKET                     = 0xffff\n        IP_MAX_MEMBERSHIPS               = 0x14\n        IP_MF                            = 0x2000\n        IP_MINTTL                        = 0x15\n        IP_MSFILTER                      = 0x29\n        IP_MSS                           = 0x240\n        IP_MTU                           = 0xe\n        IP_MTU_DISCOVER                  = 0xa\n        IP_MULTICAST_IF                  = 0x20\n        IP_MULTICAST_LOOP                = 0x22\n        IP_MULTICAST_TTL                 = 0x21\n        IP_OFFMASK                       = 0x1fff\n        IP_OPTIONS                       = 0x4\n        IP_ORIGDSTADDR                   = 0x14\n        IP_PASSSEC                       = 0x12\n        IP_PKTINFO                       = 0x8\n        IP_PKTOPTIONS                    = 0x9\n        IP_PMTUDISC                      = 0xa\n        IP_PMTUDISC_DO                   = 0x2\n        IP_PMTUDISC_DONT                 = 0x0\n        IP_PMTUDISC_PROBE                = 0x3\n        IP_PMTUDISC_WANT                 = 0x1\n        IP_RECVERR                       = 0xb\n        IP_RECVOPTS                      = 0x6\n        IP_RECVORIGDSTADDR               = 0x14\n        IP_RECVRETOPTS                   = 0x7\n        IP_RECVTOS                       = 0xd\n        IP_RECVTTL                       = 0xc\n        IP_RETOPTS                       = 0x7\n        IP_RF                            = 0x8000\n        IP_ROUTER_ALERT                  = 0x5\n        IP_TOS                           = 0x1\n        IP_TRANSPARENT                   = 0x13\n        IP_TTL                           = 0x2\n        IP_UNBLOCK_SOURCE                = 0x25\n        IP_XFRM_POLICY                   = 0x11\n        LINUX_REBOOT_CMD_CAD_OFF         = 0x0\n        LINUX_REBOOT_CMD_CAD_ON          = 0x89abcdef\n        LINUX_REBOOT_CMD_HALT            = 0xcdef0123\n        LINUX_REBOOT_CMD_KEXEC           = 0x45584543\n        LINUX_REBOOT_CMD_POWER_OFF       = 0x4321fedc\n        LINUX_REBOOT_CMD_RESTART         = 0x1234567\n        LINUX_REBOOT_CMD_RESTART2        = 0xa1b2c3d4\n        LINUX_REBOOT_CMD_SW_SUSPEND      = 0xd000fce2\n        LINUX_REBOOT_MAGIC1              = 0xfee1dead\n        LINUX_REBOOT_MAGIC2              = 0x28121969\n        LOCK_EX                          = 0x2\n        LOCK_NB                          = 0x4\n        LOCK_SH                          = 0x1\n        LOCK_UN                          = 0x8\n        MADV_DOFORK                      = 0xb\n        MADV_DONTFORK                    = 0xa\n        MADV_DONTNEED                    = 0x4\n        MADV_HUGEPAGE                    = 0xe\n        MADV_HWPOISON                    = 0x64\n        MADV_MERGEABLE                   = 0xc\n        MADV_NOHUGEPAGE                  = 0xf\n        MADV_NORMAL                      = 0x0\n        MADV_RANDOM                      = 0x1\n        MADV_REMOVE                      = 0x9\n        MADV_SEQUENTIAL                  = 0x2\n        MADV_UNMERGEABLE                 = 0xd\n        MADV_WILLNEED                    = 0x3\n        MAP_32BIT                        = 0x40\n        MAP_ANON                         = 0x20\n        MAP_ANONYMOUS                    = 0x20\n        MAP_DENYWRITE                    = 0x800\n        MAP_EXECUTABLE                   = 0x1000\n        MAP_FILE                         = 0x0\n        MAP_FIXED                        = 0x10\n        MAP_GROWSDOWN                    = 0x100\n        MAP_HUGETLB                      = 0x40000\n        MAP_LOCKED                       = 0x2000\n        MAP_NONBLOCK                     = 0x10000\n        MAP_NORESERVE                    = 0x4000\n        MAP_POPULATE                     = 0x8000\n        MAP_PRIVATE                      = 0x2\n        MAP_SHARED                       = 0x1\n        MAP_STACK                        = 0x20000\n        MAP_TYPE                         = 0xf\n        MCL_CURRENT                      = 0x1\n        MCL_FUTURE                       = 0x2\n        MNT_DETACH                       = 0x2\n        MNT_EXPIRE                       = 0x4\n        MNT_FORCE                        = 0x1\n        MSG_CMSG_CLOEXEC                 = 0x40000000\n        MSG_CONFIRM                      = 0x800\n        MSG_CTRUNC                       = 0x8\n        MSG_DONTROUTE                    = 0x4\n        MSG_DONTWAIT                     = 0x40\n        MSG_EOR                          = 0x80\n        MSG_ERRQUEUE                     = 0x2000\n        MSG_FASTOPEN                     = 0x20000000\n        MSG_FIN                          = 0x200\n        MSG_MORE                         = 0x8000\n        MSG_NOSIGNAL                     = 0x4000\n        MSG_OOB                          = 0x1\n        MSG_PEEK                         = 0x2\n        MSG_PROXY                        = 0x10\n        MSG_RST                          = 0x1000\n        MSG_SYN                          = 0x400\n        MSG_TRUNC                        = 0x20\n        MSG_TRYHARD                      = 0x4\n        MSG_WAITALL                      = 0x100\n        MSG_WAITFORONE                   = 0x10000\n        MS_ACTIVE                        = 0x40000000\n        MS_ASYNC                         = 0x1\n        MS_BIND                          = 0x1000\n        MS_DIRSYNC                       = 0x80\n        MS_INVALIDATE                    = 0x2\n        MS_I_VERSION                     = 0x800000\n        MS_KERNMOUNT                     = 0x400000\n        MS_MANDLOCK                      = 0x40\n        MS_MGC_MSK                       = 0xffff0000\n        MS_MGC_VAL                       = 0xc0ed0000\n        MS_MOVE                          = 0x2000\n        MS_NOATIME                       = 0x400\n        MS_NODEV                         = 0x4\n        MS_NODIRATIME                    = 0x800\n        MS_NOEXEC                        = 0x8\n        MS_NOSUID                        = 0x2\n        MS_NOUSER                        = -0x80000000\n        MS_POSIXACL                      = 0x10000\n        MS_PRIVATE                       = 0x40000\n        MS_RDONLY                        = 0x1\n        MS_REC                           = 0x4000\n        MS_RELATIME                      = 0x200000\n        MS_REMOUNT                       = 0x20\n        MS_RMT_MASK                      = 0x800051\n        MS_SHARED                        = 0x100000\n        MS_SILENT                        = 0x8000\n        MS_SLAVE                         = 0x80000\n        MS_STRICTATIME                   = 0x1000000\n        MS_SYNC                          = 0x4\n        MS_SYNCHRONOUS                   = 0x10\n        MS_UNBINDABLE                    = 0x20000\n        NAME_MAX                         = 0xff\n        NETLINK_ADD_MEMBERSHIP           = 0x1\n        NETLINK_AUDIT                    = 0x9\n        NETLINK_BROADCAST_ERROR          = 0x4\n        NETLINK_CONNECTOR                = 0xb\n        NETLINK_DNRTMSG                  = 0xe\n        NETLINK_DROP_MEMBERSHIP          = 0x2\n        NETLINK_ECRYPTFS                 = 0x13\n        NETLINK_FIB_LOOKUP               = 0xa\n        NETLINK_FIREWALL                 = 0x3\n        NETLINK_GENERIC                  = 0x10\n        NETLINK_INET_DIAG                = 0x4\n        NETLINK_IP6_FW                   = 0xd\n        NETLINK_ISCSI                    = 0x8\n        NETLINK_KOBJECT_UEVENT           = 0xf\n        NETLINK_NETFILTER                = 0xc\n        NETLINK_NFLOG                    = 0x5\n        NETLINK_NO_ENOBUFS               = 0x5\n        NETLINK_PKTINFO                  = 0x3\n        NETLINK_ROUTE                    = 0x0\n        NETLINK_SCSITRANSPORT            = 0x12\n        NETLINK_SELINUX                  = 0x7\n        NETLINK_UNUSED                   = 0x1\n        NETLINK_USERSOCK                 = 0x2\n        NETLINK_XFRM                     = 0x6\n        NLA_ALIGNTO                      = 0x4\n        NLA_F_NESTED                     = 0x8000\n        NLA_F_NET_BYTEORDER              = 0x4000\n        NLA_HDRLEN                       = 0x4\n        NLMSG_ALIGNTO                    = 0x4\n        NLMSG_DONE                       = 0x3\n        NLMSG_ERROR                      = 0x2\n        NLMSG_HDRLEN                     = 0x10\n        NLMSG_MIN_TYPE                   = 0x10\n        NLMSG_NOOP                       = 0x1\n        NLMSG_OVERRUN                    = 0x4\n        NLM_F_ACK                        = 0x4\n        NLM_F_APPEND                     = 0x800\n        NLM_F_ATOMIC                     = 0x400\n        NLM_F_CREATE                     = 0x400\n        NLM_F_DUMP                       = 0x300\n        NLM_F_ECHO                       = 0x8\n        NLM_F_EXCL                       = 0x200\n        NLM_F_MATCH                      = 0x200\n        NLM_F_MULTI                      = 0x2\n        NLM_F_REPLACE                    = 0x100\n        NLM_F_REQUEST                    = 0x1\n        NLM_F_ROOT                       = 0x100\n        O_ACCMODE                        = 0x3\n        O_APPEND                         = 0x400\n        O_ASYNC                          = 0x2000\n        O_CLOEXEC                        = 0x80000\n        O_CREAT                          = 0x40\n        O_DIRECT                         = 0x4000\n        O_DIRECTORY                      = 0x10000\n        O_DSYNC                          = 0x1000\n        O_EXCL                           = 0x80\n        O_FSYNC                          = 0x101000\n        O_LARGEFILE                      = 0x0\n        O_NDELAY                         = 0x800\n        O_NOATIME                        = 0x40000\n        O_NOCTTY                         = 0x100\n        O_NOFOLLOW                       = 0x20000\n        O_NONBLOCK                       = 0x800\n        O_RDONLY                         = 0x0\n        O_RDWR                           = 0x2\n        O_RSYNC                          = 0x101000\n        O_SYNC                           = 0x101000\n        O_TRUNC                          = 0x200\n        O_WRONLY                         = 0x1\n        PACKET_ADD_MEMBERSHIP            = 0x1\n        PACKET_BROADCAST                 = 0x1\n        PACKET_DROP_MEMBERSHIP           = 0x2\n        PACKET_FASTROUTE                 = 0x6\n        PACKET_HOST                      = 0x0\n        PACKET_LOOPBACK                  = 0x5\n        PACKET_MR_ALLMULTI               = 0x2\n        PACKET_MR_MULTICAST              = 0x0\n        PACKET_MR_PROMISC                = 0x1\n        PACKET_MULTICAST                 = 0x2\n        PACKET_OTHERHOST                 = 0x3\n        PACKET_OUTGOING                  = 0x4\n        PACKET_RECV_OUTPUT               = 0x3\n        PACKET_RX_RING                   = 0x5\n        PACKET_STATISTICS                = 0x6\n        PRIO_PGRP                        = 0x1\n        PRIO_PROCESS                     = 0x0\n        PRIO_USER                        = 0x2\n        PROT_EXEC                        = 0x4\n        PROT_GROWSDOWN                   = 0x1000000\n        PROT_GROWSUP                     = 0x2000000\n        PROT_NONE                        = 0x0\n        PROT_READ                        = 0x1\n        PROT_WRITE                       = 0x2\n        PR_CAPBSET_DROP                  = 0x18\n        PR_CAPBSET_READ                  = 0x17\n        PR_ENDIAN_BIG                    = 0x0\n        PR_ENDIAN_LITTLE                 = 0x1\n        PR_ENDIAN_PPC_LITTLE             = 0x2\n        PR_FPEMU_NOPRINT                 = 0x1\n        PR_FPEMU_SIGFPE                  = 0x2\n        PR_FP_EXC_ASYNC                  = 0x2\n        PR_FP_EXC_DISABLED               = 0x0\n        PR_FP_EXC_DIV                    = 0x10000\n        PR_FP_EXC_INV                    = 0x100000\n        PR_FP_EXC_NONRECOV               = 0x1\n        PR_FP_EXC_OVF                    = 0x20000\n        PR_FP_EXC_PRECISE                = 0x3\n        PR_FP_EXC_RES                    = 0x80000\n        PR_FP_EXC_SW_ENABLE              = 0x80\n        PR_FP_EXC_UND                    = 0x40000\n        PR_GET_DUMPABLE                  = 0x3\n        PR_GET_ENDIAN                    = 0x13\n        PR_GET_FPEMU                     = 0x9\n        PR_GET_FPEXC                     = 0xb\n        PR_GET_KEEPCAPS                  = 0x7\n        PR_GET_NAME                      = 0x10\n        PR_GET_PDEATHSIG                 = 0x2\n        PR_GET_SECCOMP                   = 0x15\n        PR_GET_SECUREBITS                = 0x1b\n        PR_GET_TIMERSLACK                = 0x1e\n        PR_GET_TIMING                    = 0xd\n        PR_GET_TSC                       = 0x19\n        PR_GET_UNALIGN                   = 0x5\n        PR_MCE_KILL                      = 0x21\n        PR_MCE_KILL_CLEAR                = 0x0\n        PR_MCE_KILL_DEFAULT              = 0x2\n        PR_MCE_KILL_EARLY                = 0x1\n        PR_MCE_KILL_GET                  = 0x22\n        PR_MCE_KILL_LATE                 = 0x0\n        PR_MCE_KILL_SET                  = 0x1\n        PR_SET_DUMPABLE                  = 0x4\n        PR_SET_ENDIAN                    = 0x14\n        PR_SET_FPEMU                     = 0xa\n        PR_SET_FPEXC                     = 0xc\n        PR_SET_KEEPCAPS                  = 0x8\n        PR_SET_NAME                      = 0xf\n        PR_SET_PDEATHSIG                 = 0x1\n        PR_SET_PTRACER                   = 0x59616d61\n        PR_SET_SECCOMP                   = 0x16\n        PR_SET_SECUREBITS                = 0x1c\n        PR_SET_TIMERSLACK                = 0x1d\n        PR_SET_TIMING                    = 0xe\n        PR_SET_TSC                       = 0x1a\n        PR_SET_UNALIGN                   = 0x6\n        PR_TASK_PERF_EVENTS_DISABLE      = 0x1f\n        PR_TASK_PERF_EVENTS_ENABLE       = 0x20\n        PR_TIMING_STATISTICAL            = 0x0\n        PR_TIMING_TIMESTAMP              = 0x1\n        PR_TSC_ENABLE                    = 0x1\n        PR_TSC_SIGSEGV                   = 0x2\n        PR_UNALIGN_NOPRINT               = 0x1\n        PR_UNALIGN_SIGBUS                = 0x2\n        PTRACE_ARCH_PRCTL                = 0x1e\n        PTRACE_ATTACH                    = 0x10\n        PTRACE_CONT                      = 0x7\n        PTRACE_DETACH                    = 0x11\n        PTRACE_EVENT_CLONE               = 0x3\n        PTRACE_EVENT_EXEC                = 0x4\n        PTRACE_EVENT_EXIT                = 0x6\n        PTRACE_EVENT_FORK                = 0x1\n        PTRACE_EVENT_VFORK               = 0x2\n        PTRACE_EVENT_VFORK_DONE          = 0x5\n        PTRACE_GETEVENTMSG               = 0x4201\n        PTRACE_GETFPREGS                 = 0xe\n        PTRACE_GETFPXREGS                = 0x12\n        PTRACE_GETREGS                   = 0xc\n        PTRACE_GETREGSET                 = 0x4204\n        PTRACE_GETSIGINFO                = 0x4202\n        PTRACE_GET_THREAD_AREA           = 0x19\n        PTRACE_KILL                      = 0x8\n        PTRACE_OLDSETOPTIONS             = 0x15\n        PTRACE_O_MASK                    = 0x7f\n        PTRACE_O_TRACECLONE              = 0x8\n        PTRACE_O_TRACEEXEC               = 0x10\n        PTRACE_O_TRACEEXIT               = 0x40\n        PTRACE_O_TRACEFORK               = 0x2\n        PTRACE_O_TRACESYSGOOD            = 0x1\n        PTRACE_O_TRACEVFORK              = 0x4\n        PTRACE_O_TRACEVFORKDONE          = 0x20\n        PTRACE_PEEKDATA                  = 0x2\n        PTRACE_PEEKTEXT                  = 0x1\n        PTRACE_PEEKUSR                   = 0x3\n        PTRACE_POKEDATA                  = 0x5\n        PTRACE_POKETEXT                  = 0x4\n        PTRACE_POKEUSR                   = 0x6\n        PTRACE_SETFPREGS                 = 0xf\n        PTRACE_SETFPXREGS                = 0x13\n        PTRACE_SETOPTIONS                = 0x4200\n        PTRACE_SETREGS                   = 0xd\n        PTRACE_SETREGSET                 = 0x4205\n        PTRACE_SETSIGINFO                = 0x4203\n        PTRACE_SET_THREAD_AREA           = 0x1a\n        PTRACE_SINGLEBLOCK               = 0x21\n        PTRACE_SINGLESTEP                = 0x9\n        PTRACE_SYSCALL                   = 0x18\n        PTRACE_SYSEMU                    = 0x1f\n        PTRACE_SYSEMU_SINGLESTEP         = 0x20\n        PTRACE_TRACEME                   = 0x0\n        RLIMIT_AS                        = 0x9\n        RLIMIT_CORE                      = 0x4\n        RLIMIT_CPU                       = 0x0\n        RLIMIT_DATA                      = 0x2\n        RLIMIT_FSIZE                     = 0x1\n        RLIMIT_NOFILE                    = 0x7\n        RLIMIT_STACK                     = 0x3\n        RLIM_INFINITY                    = -0x1\n        RTAX_ADVMSS                      = 0x8\n        RTAX_CWND                        = 0x7\n        RTAX_FEATURES                    = 0xc\n        RTAX_FEATURE_ALLFRAG             = 0x8\n        RTAX_FEATURE_ECN                 = 0x1\n        RTAX_FEATURE_SACK                = 0x2\n        RTAX_FEATURE_TIMESTAMP           = 0x4\n        RTAX_HOPLIMIT                    = 0xa\n        RTAX_INITCWND                    = 0xb\n        RTAX_INITRWND                    = 0xe\n        RTAX_LOCK                        = 0x1\n        RTAX_MAX                         = 0xe\n        RTAX_MTU                         = 0x2\n        RTAX_REORDERING                  = 0x9\n        RTAX_RTO_MIN                     = 0xd\n        RTAX_RTT                         = 0x4\n        RTAX_RTTVAR                      = 0x5\n        RTAX_SSTHRESH                    = 0x6\n        RTAX_UNSPEC                      = 0x0\n        RTAX_WINDOW                      = 0x3\n        RTA_ALIGNTO                      = 0x4\n        RTA_MAX                          = 0x10\n        RTCF_DIRECTSRC                   = 0x4000000\n        RTCF_DOREDIRECT                  = 0x1000000\n        RTCF_LOG                         = 0x2000000\n        RTCF_MASQ                        = 0x400000\n        RTCF_NAT                         = 0x800000\n        RTCF_VALVE                       = 0x200000\n        RTF_ADDRCLASSMASK                = 0xf8000000\n        RTF_ADDRCONF                     = 0x40000\n        RTF_ALLONLINK                    = 0x20000\n        RTF_BROADCAST                    = 0x10000000\n        RTF_CACHE                        = 0x1000000\n        RTF_DEFAULT                      = 0x10000\n        RTF_DYNAMIC                      = 0x10\n        RTF_FLOW                         = 0x2000000\n        RTF_GATEWAY                      = 0x2\n        RTF_HOST                         = 0x4\n        RTF_INTERFACE                    = 0x40000000\n        RTF_IRTT                         = 0x100\n        RTF_LINKRT                       = 0x100000\n        RTF_LOCAL                        = 0x80000000\n        RTF_MODIFIED                     = 0x20\n        RTF_MSS                          = 0x40\n        RTF_MTU                          = 0x40\n        RTF_MULTICAST                    = 0x20000000\n        RTF_NAT                          = 0x8000000\n        RTF_NOFORWARD                    = 0x1000\n        RTF_NONEXTHOP                    = 0x200000\n        RTF_NOPMTUDISC                   = 0x4000\n        RTF_POLICY                       = 0x4000000\n        RTF_REINSTATE                    = 0x8\n        RTF_REJECT                       = 0x200\n        RTF_STATIC                       = 0x400\n        RTF_THROW                        = 0x2000\n        RTF_UP                           = 0x1\n        RTF_WINDOW                       = 0x80\n        RTF_XRESOLVE                     = 0x800\n        RTM_BASE                         = 0x10\n        RTM_DELACTION                    = 0x31\n        RTM_DELADDR                      = 0x15\n        RTM_DELADDRLABEL                 = 0x49\n        RTM_DELLINK                      = 0x11\n        RTM_DELNEIGH                     = 0x1d\n        RTM_DELQDISC                     = 0x25\n        RTM_DELROUTE                     = 0x19\n        RTM_DELRULE                      = 0x21\n        RTM_DELTCLASS                    = 0x29\n        RTM_DELTFILTER                   = 0x2d\n        RTM_F_CLONED                     = 0x200\n        RTM_F_EQUALIZE                   = 0x400\n        RTM_F_NOTIFY                     = 0x100\n        RTM_F_PREFIX                     = 0x800\n        RTM_GETACTION                    = 0x32\n        RTM_GETADDR                      = 0x16\n        RTM_GETADDRLABEL                 = 0x4a\n        RTM_GETANYCAST                   = 0x3e\n        RTM_GETDCB                       = 0x4e\n        RTM_GETLINK                      = 0x12\n        RTM_GETMULTICAST                 = 0x3a\n        RTM_GETNEIGH                     = 0x1e\n        RTM_GETNEIGHTBL                  = 0x42\n        RTM_GETQDISC                     = 0x26\n        RTM_GETROUTE                     = 0x1a\n        RTM_GETRULE                      = 0x22\n        RTM_GETTCLASS                    = 0x2a\n        RTM_GETTFILTER                   = 0x2e\n        RTM_MAX                          = 0x4f\n        RTM_NEWACTION                    = 0x30\n        RTM_NEWADDR                      = 0x14\n        RTM_NEWADDRLABEL                 = 0x48\n        RTM_NEWLINK                      = 0x10\n        RTM_NEWNDUSEROPT                 = 0x44\n        RTM_NEWNEIGH                     = 0x1c\n        RTM_NEWNEIGHTBL                  = 0x40\n        RTM_NEWPREFIX                    = 0x34\n        RTM_NEWQDISC                     = 0x24\n        RTM_NEWROUTE                     = 0x18\n        RTM_NEWRULE                      = 0x20\n        RTM_NEWTCLASS                    = 0x28\n        RTM_NEWTFILTER                   = 0x2c\n        RTM_NR_FAMILIES                  = 0x10\n        RTM_NR_MSGTYPES                  = 0x40\n        RTM_SETDCB                       = 0x4f\n        RTM_SETLINK                      = 0x13\n        RTM_SETNEIGHTBL                  = 0x43\n        RTNH_ALIGNTO                     = 0x4\n        RTNH_F_DEAD                      = 0x1\n        RTNH_F_ONLINK                    = 0x4\n        RTNH_F_PERVASIVE                 = 0x2\n        RTN_MAX                          = 0xb\n        RTPROT_BIRD                      = 0xc\n        RTPROT_BOOT                      = 0x3\n        RTPROT_DHCP                      = 0x10\n        RTPROT_DNROUTED                  = 0xd\n        RTPROT_GATED                     = 0x8\n        RTPROT_KERNEL                    = 0x2\n        RTPROT_MRT                       = 0xa\n        RTPROT_NTK                       = 0xf\n        RTPROT_RA                        = 0x9\n        RTPROT_REDIRECT                  = 0x1\n        RTPROT_STATIC                    = 0x4\n        RTPROT_UNSPEC                    = 0x0\n        RTPROT_XORP                      = 0xe\n        RTPROT_ZEBRA                     = 0xb\n        RT_CLASS_DEFAULT                 = 0xfd\n        RT_CLASS_LOCAL                   = 0xff\n        RT_CLASS_MAIN                    = 0xfe\n        RT_CLASS_MAX                     = 0xff\n        RT_CLASS_UNSPEC                  = 0x0\n        RUSAGE_CHILDREN                  = -0x1\n        RUSAGE_SELF                      = 0x0\n        RUSAGE_THREAD                    = 0x1\n        SCM_CREDENTIALS                  = 0x2\n        SCM_RIGHTS                       = 0x1\n        SCM_TIMESTAMP                    = 0x1d\n        SCM_TIMESTAMPING                 = 0x25\n        SCM_TIMESTAMPNS                  = 0x23\n        SHUT_RD                          = 0x0\n        SHUT_RDWR                        = 0x2\n        SHUT_WR                          = 0x1\n        SIOCADDDLCI                      = 0x8980\n        SIOCADDMULTI                     = 0x8931\n        SIOCADDRT                        = 0x890b\n        SIOCATMARK                       = 0x8905\n        SIOCDARP                         = 0x8953\n        SIOCDELDLCI                      = 0x8981\n        SIOCDELMULTI                     = 0x8932\n        SIOCDELRT                        = 0x890c\n        SIOCDEVPRIVATE                   = 0x89f0\n        SIOCDIFADDR                      = 0x8936\n        SIOCDRARP                        = 0x8960\n        SIOCGARP                         = 0x8954\n        SIOCGIFADDR                      = 0x8915\n        SIOCGIFBR                        = 0x8940\n        SIOCGIFBRDADDR                   = 0x8919\n        SIOCGIFCONF                      = 0x8912\n        SIOCGIFCOUNT                     = 0x8938\n        SIOCGIFDSTADDR                   = 0x8917\n        SIOCGIFENCAP                     = 0x8925\n        SIOCGIFFLAGS                     = 0x8913\n        SIOCGIFHWADDR                    = 0x8927\n        SIOCGIFINDEX                     = 0x8933\n        SIOCGIFMAP                       = 0x8970\n        SIOCGIFMEM                       = 0x891f\n        SIOCGIFMETRIC                    = 0x891d\n        SIOCGIFMTU                       = 0x8921\n        SIOCGIFNAME                      = 0x8910\n        SIOCGIFNETMASK                   = 0x891b\n        SIOCGIFPFLAGS                    = 0x8935\n        SIOCGIFSLAVE                     = 0x8929\n        SIOCGIFTXQLEN                    = 0x8942\n        SIOCGPGRP                        = 0x8904\n        SIOCGRARP                        = 0x8961\n        SIOCGSTAMP                       = 0x8906\n        SIOCGSTAMPNS                     = 0x8907\n        SIOCPROTOPRIVATE                 = 0x89e0\n        SIOCRTMSG                        = 0x890d\n        SIOCSARP                         = 0x8955\n        SIOCSIFADDR                      = 0x8916\n        SIOCSIFBR                        = 0x8941\n        SIOCSIFBRDADDR                   = 0x891a\n        SIOCSIFDSTADDR                   = 0x8918\n        SIOCSIFENCAP                     = 0x8926\n        SIOCSIFFLAGS                     = 0x8914\n        SIOCSIFHWADDR                    = 0x8924\n        SIOCSIFHWBROADCAST               = 0x8937\n        SIOCSIFLINK                      = 0x8911\n        SIOCSIFMAP                       = 0x8971\n        SIOCSIFMEM                       = 0x8920\n        SIOCSIFMETRIC                    = 0x891e\n        SIOCSIFMTU                       = 0x8922\n        SIOCSIFNAME                      = 0x8923\n        SIOCSIFNETMASK                   = 0x891c\n        SIOCSIFPFLAGS                    = 0x8934\n        SIOCSIFSLAVE                     = 0x8930\n        SIOCSIFTXQLEN                    = 0x8943\n        SIOCSPGRP                        = 0x8902\n        SIOCSRARP                        = 0x8962\n        SOCK_CLOEXEC                     = 0x80000\n        SOCK_DCCP                        = 0x6\n        SOCK_DGRAM                       = 0x2\n        SOCK_NONBLOCK                    = 0x800\n        SOCK_PACKET                      = 0xa\n        SOCK_RAW                         = 0x3\n        SOCK_RDM                         = 0x4\n        SOCK_SEQPACKET                   = 0x5\n        SOCK_STREAM                      = 0x1\n        SOL_AAL                          = 0x109\n        SOL_ATM                          = 0x108\n        SOL_DECNET                       = 0x105\n        SOL_ICMPV6                       = 0x3a\n        SOL_IP                           = 0x0\n        SOL_IPV6                         = 0x29\n        SOL_IRDA                         = 0x10a\n        SOL_PACKET                       = 0x107\n        SOL_RAW                          = 0xff\n        SOL_SOCKET                       = 0x1\n        SOL_TCP                          = 0x6\n        SOL_X25                          = 0x106\n        SOMAXCONN                        = 0x80\n        SO_ACCEPTCONN                    = 0x1e\n        SO_ATTACH_FILTER                 = 0x1a\n        SO_BINDTODEVICE                  = 0x19\n        SO_BROADCAST                     = 0x6\n        SO_BSDCOMPAT                     = 0xe\n        SO_DEBUG                         = 0x1\n        SO_DETACH_FILTER                 = 0x1b\n        SO_DOMAIN                        = 0x27\n        SO_DONTROUTE                     = 0x5\n        SO_ERROR                         = 0x4\n        SO_KEEPALIVE                     = 0x9\n        SO_LINGER                        = 0xd\n        SO_MARK                          = 0x24\n        SO_NO_CHECK                      = 0xb\n        SO_OOBINLINE                     = 0xa\n        SO_PASSCRED                      = 0x10\n        SO_PASSSEC                       = 0x22\n        SO_PEERCRED                      = 0x11\n        SO_PEERNAME                      = 0x1c\n        SO_PEERSEC                       = 0x1f\n        SO_PRIORITY                      = 0xc\n        SO_PROTOCOL                      = 0x26\n        SO_RCVBUF                        = 0x8\n        SO_RCVBUFFORCE                   = 0x21\n        SO_RCVLOWAT                      = 0x12\n        SO_RCVTIMEO                      = 0x14\n        SO_REUSEADDR                     = 0x2\n        SO_RXQ_OVFL                      = 0x28\n        SO_SECURITY_AUTHENTICATION       = 0x16\n        SO_SECURITY_ENCRYPTION_NETWORK   = 0x18\n        SO_SECURITY_ENCRYPTION_TRANSPORT = 0x17\n        SO_SNDBUF                        = 0x7\n        SO_SNDBUFFORCE                   = 0x20\n        SO_SNDLOWAT                      = 0x13\n        SO_SNDTIMEO                      = 0x15\n        SO_TIMESTAMP                     = 0x1d\n        SO_TIMESTAMPING                  = 0x25\n        SO_TIMESTAMPNS                   = 0x23\n        SO_TYPE                          = 0x3\n        S_BLKSIZE                        = 0x200\n        S_IEXEC                          = 0x40\n        S_IFBLK                          = 0x6000\n        S_IFCHR                          = 0x2000\n        S_IFDIR                          = 0x4000\n        S_IFIFO                          = 0x1000\n        S_IFLNK                          = 0xa000\n        S_IFMT                           = 0xf000\n        S_IFREG                          = 0x8000\n        S_IFSOCK                         = 0xc000\n        S_IREAD                          = 0x100\n        S_IRGRP                          = 0x20\n        S_IROTH                          = 0x4\n        S_IRUSR                          = 0x100\n        S_IRWXG                          = 0x38\n        S_IRWXO                          = 0x7\n        S_IRWXU                          = 0x1c0\n        S_ISGID                          = 0x400\n        S_ISUID                          = 0x800\n        S_ISVTX                          = 0x200\n        S_IWGRP                          = 0x10\n        S_IWOTH                          = 0x2\n        S_IWRITE                         = 0x80\n        S_IWUSR                          = 0x80\n        S_IXGRP                          = 0x8\n        S_IXOTH                          = 0x1\n        S_IXUSR                          = 0x40\n        TCIFLUSH                         = 0x0\n        TCIOFLUSH                        = 0x2\n        TCOFLUSH                         = 0x1\n        TCP_CONGESTION                   = 0xd\n        TCP_CORK                         = 0x3\n        TCP_DEFER_ACCEPT                 = 0x9\n        TCP_INFO                         = 0xb\n        TCP_KEEPCNT                      = 0x6\n        TCP_KEEPIDLE                     = 0x4\n        TCP_KEEPINTVL                    = 0x5\n        TCP_LINGER2                      = 0x8\n        TCP_MAXSEG                       = 0x2\n        TCP_MAXWIN                       = 0xffff\n        TCP_MAX_WINSHIFT                 = 0xe\n        TCP_MD5SIG                       = 0xe\n        TCP_MD5SIG_MAXKEYLEN             = 0x50\n        TCP_MSS                          = 0x200\n        TCP_NODELAY                      = 0x1\n        TCP_QUICKACK                     = 0xc\n        TCP_SYNCNT                       = 0x7\n        TCP_WINDOW_CLAMP                 = 0xa\n        TIOCCBRK                         = 0x5428\n        TIOCCONS                         = 0x541d\n        TIOCEXCL                         = 0x540c\n        TIOCGDEV                         = 0x80045432\n        TIOCGETD                         = 0x5424\n        TIOCGICOUNT                      = 0x545d\n        TIOCGLCKTRMIOS                   = 0x5456\n        TIOCGPGRP                        = 0x540f\n        TIOCGPTN                         = 0x80045430\n        TIOCGRS485                       = 0x542e\n        TIOCGSERIAL                      = 0x541e\n        TIOCGSID                         = 0x5429\n        TIOCGSOFTCAR                     = 0x5419\n        TIOCGWINSZ                       = 0x5413\n        TIOCINQ                          = 0x541b\n        TIOCLINUX                        = 0x541c\n        TIOCMBIC                         = 0x5417\n        TIOCMBIS                         = 0x5416\n        TIOCMGET                         = 0x5415\n        TIOCMIWAIT                       = 0x545c\n        TIOCMSET                         = 0x5418\n        TIOCM_CAR                        = 0x40\n        TIOCM_CD                         = 0x40\n        TIOCM_CTS                        = 0x20\n        TIOCM_DSR                        = 0x100\n        TIOCM_DTR                        = 0x2\n        TIOCM_LE                         = 0x1\n        TIOCM_RI                         = 0x80\n        TIOCM_RNG                        = 0x80\n        TIOCM_RTS                        = 0x4\n        TIOCM_SR                         = 0x10\n        TIOCM_ST                         = 0x8\n        TIOCNOTTY                        = 0x5422\n        TIOCNXCL                         = 0x540d\n        TIOCOUTQ                         = 0x5411\n        TIOCPKT                          = 0x5420\n        TIOCPKT_DATA                     = 0x0\n        TIOCPKT_DOSTOP                   = 0x20\n        TIOCPKT_FLUSHREAD                = 0x1\n        TIOCPKT_FLUSHWRITE               = 0x2\n        TIOCPKT_IOCTL                    = 0x40\n        TIOCPKT_NOSTOP                   = 0x10\n        TIOCPKT_START                    = 0x8\n        TIOCPKT_STOP                     = 0x4\n        TIOCSBRK                         = 0x5427\n        TIOCSCTTY                        = 0x540e\n        TIOCSERCONFIG                    = 0x5453\n        TIOCSERGETLSR                    = 0x5459\n        TIOCSERGETMULTI                  = 0x545a\n        TIOCSERGSTRUCT                   = 0x5458\n        TIOCSERGWILD                     = 0x5454\n        TIOCSERSETMULTI                  = 0x545b\n        TIOCSERSWILD                     = 0x5455\n        TIOCSER_TEMT                     = 0x1\n        TIOCSETD                         = 0x5423\n        TIOCSIG                          = 0x40045436\n        TIOCSLCKTRMIOS                   = 0x5457\n        TIOCSPGRP                        = 0x5410\n        TIOCSPTLCK                       = 0x40045431\n        TIOCSRS485                       = 0x542f\n        TIOCSSERIAL                      = 0x541f\n        TIOCSSOFTCAR                     = 0x541a\n        TIOCSTI                          = 0x5412\n        TIOCSWINSZ                       = 0x5414\n        TUNATTACHFILTER                  = 0x401054d5\n        TUNDETACHFILTER                  = 0x401054d6\n        TUNGETFEATURES                   = 0x800454cf\n        TUNGETIFF                        = 0x800454d2\n        TUNGETSNDBUF                     = 0x800454d3\n        TUNGETVNETHDRSZ                  = 0x800454d7\n        TUNSETDEBUG                      = 0x400454c9\n        TUNSETGROUP                      = 0x400454ce\n        TUNSETIFF                        = 0x400454ca\n        TUNSETLINK                       = 0x400454cd\n        TUNSETNOCSUM                     = 0x400454c8\n        TUNSETOFFLOAD                    = 0x400454d0\n        TUNSETOWNER                      = 0x400454cc\n        TUNSETPERSIST                    = 0x400454cb\n        TUNSETSNDBUF                     = 0x400454d4\n        TUNSETTXFILTER                   = 0x400454d1\n        TUNSETVNETHDRSZ                  = 0x400454d8\n        WALL                             = 0x40000000\n        WCLONE                           = 0x80000000\n        WCONTINUED                       = 0x8\n        WEXITED                          = 0x4\n        WNOHANG                          = 0x1\n        WNOTHREAD                        = 0x20000000\n        WNOWAIT                          = 0x1000000\n        WORDSIZE                         = 0x40\n        WSTOPPED                         = 0x2\n        WUNTRACED                        = 0x2\n)</pre> <pre data-language=\"go\">const (\n        E2BIG           = Errno(0x7)\n        EACCES          = Errno(0xd)\n        EADDRINUSE      = Errno(0x62)\n        EADDRNOTAVAIL   = Errno(0x63)\n        EADV            = Errno(0x44)\n        EAFNOSUPPORT    = Errno(0x61)\n        EAGAIN          = Errno(0xb)\n        EALREADY        = Errno(0x72)\n        EBADE           = Errno(0x34)\n        EBADF           = Errno(0x9)\n        EBADFD          = Errno(0x4d)\n        EBADMSG         = Errno(0x4a)\n        EBADR           = Errno(0x35)\n        EBADRQC         = Errno(0x38)\n        EBADSLT         = Errno(0x39)\n        EBFONT          = Errno(0x3b)\n        EBUSY           = Errno(0x10)\n        ECANCELED       = Errno(0x7d)\n        ECHILD          = Errno(0xa)\n        ECHRNG          = Errno(0x2c)\n        ECOMM           = Errno(0x46)\n        ECONNABORTED    = Errno(0x67)\n        ECONNREFUSED    = Errno(0x6f)\n        ECONNRESET      = Errno(0x68)\n        EDEADLK         = Errno(0x23)\n        EDEADLOCK       = Errno(0x23)\n        EDESTADDRREQ    = Errno(0x59)\n        EDOM            = Errno(0x21)\n        EDOTDOT         = Errno(0x49)\n        EDQUOT          = Errno(0x7a)\n        EEXIST          = Errno(0x11)\n        EFAULT          = Errno(0xe)\n        EFBIG           = Errno(0x1b)\n        EHOSTDOWN       = Errno(0x70)\n        EHOSTUNREACH    = Errno(0x71)\n        EIDRM           = Errno(0x2b)\n        EILSEQ          = Errno(0x54)\n        EINPROGRESS     = Errno(0x73)\n        EINTR           = Errno(0x4)\n        EINVAL          = Errno(0x16)\n        EIO             = Errno(0x5)\n        EISCONN         = Errno(0x6a)\n        EISDIR          = Errno(0x15)\n        EISNAM          = Errno(0x78)\n        EKEYEXPIRED     = Errno(0x7f)\n        EKEYREJECTED    = Errno(0x81)\n        EKEYREVOKED     = Errno(0x80)\n        EL2HLT          = Errno(0x33)\n        EL2NSYNC        = Errno(0x2d)\n        EL3HLT          = Errno(0x2e)\n        EL3RST          = Errno(0x2f)\n        ELIBACC         = Errno(0x4f)\n        ELIBBAD         = Errno(0x50)\n        ELIBEXEC        = Errno(0x53)\n        ELIBMAX         = Errno(0x52)\n        ELIBSCN         = Errno(0x51)\n        ELNRNG          = Errno(0x30)\n        ELOOP           = Errno(0x28)\n        EMEDIUMTYPE     = Errno(0x7c)\n        EMFILE          = Errno(0x18)\n        EMLINK          = Errno(0x1f)\n        EMSGSIZE        = Errno(0x5a)\n        EMULTIHOP       = Errno(0x48)\n        ENAMETOOLONG    = Errno(0x24)\n        ENAVAIL         = Errno(0x77)\n        ENETDOWN        = Errno(0x64)\n        ENETRESET       = Errno(0x66)\n        ENETUNREACH     = Errno(0x65)\n        ENFILE          = Errno(0x17)\n        ENOANO          = Errno(0x37)\n        ENOBUFS         = Errno(0x69)\n        ENOCSI          = Errno(0x32)\n        ENODATA         = Errno(0x3d)\n        ENODEV          = Errno(0x13)\n        ENOENT          = Errno(0x2)\n        ENOEXEC         = Errno(0x8)\n        ENOKEY          = Errno(0x7e)\n        ENOLCK          = Errno(0x25)\n        ENOLINK         = Errno(0x43)\n        ENOMEDIUM       = Errno(0x7b)\n        ENOMEM          = Errno(0xc)\n        ENOMSG          = Errno(0x2a)\n        ENONET          = Errno(0x40)\n        ENOPKG          = Errno(0x41)\n        ENOPROTOOPT     = Errno(0x5c)\n        ENOSPC          = Errno(0x1c)\n        ENOSR           = Errno(0x3f)\n        ENOSTR          = Errno(0x3c)\n        ENOSYS          = Errno(0x26)\n        ENOTBLK         = Errno(0xf)\n        ENOTCONN        = Errno(0x6b)\n        ENOTDIR         = Errno(0x14)\n        ENOTEMPTY       = Errno(0x27)\n        ENOTNAM         = Errno(0x76)\n        ENOTRECOVERABLE = Errno(0x83)\n        ENOTSOCK        = Errno(0x58)\n        ENOTSUP         = Errno(0x5f)\n        ENOTTY          = Errno(0x19)\n        ENOTUNIQ        = Errno(0x4c)\n        ENXIO           = Errno(0x6)\n        EOPNOTSUPP      = Errno(0x5f)\n        EOVERFLOW       = Errno(0x4b)\n        EOWNERDEAD      = Errno(0x82)\n        EPERM           = Errno(0x1)\n        EPFNOSUPPORT    = Errno(0x60)\n        EPIPE           = Errno(0x20)\n        EPROTO          = Errno(0x47)\n        EPROTONOSUPPORT = Errno(0x5d)\n        EPROTOTYPE      = Errno(0x5b)\n        ERANGE          = Errno(0x22)\n        EREMCHG         = Errno(0x4e)\n        EREMOTE         = Errno(0x42)\n        EREMOTEIO       = Errno(0x79)\n        ERESTART        = Errno(0x55)\n        ERFKILL         = Errno(0x84)\n        EROFS           = Errno(0x1e)\n        ESHUTDOWN       = Errno(0x6c)\n        ESOCKTNOSUPPORT = Errno(0x5e)\n        ESPIPE          = Errno(0x1d)\n        ESRCH           = Errno(0x3)\n        ESRMNT          = Errno(0x45)\n        ESTALE          = Errno(0x74)\n        ESTRPIPE        = Errno(0x56)\n        ETIME           = Errno(0x3e)\n        ETIMEDOUT       = Errno(0x6e)\n        ETOOMANYREFS    = Errno(0x6d)\n        ETXTBSY         = Errno(0x1a)\n        EUCLEAN         = Errno(0x75)\n        EUNATCH         = Errno(0x31)\n        EUSERS          = Errno(0x57)\n        EWOULDBLOCK     = Errno(0xb)\n        EXDEV           = Errno(0x12)\n        EXFULL          = Errno(0x36)\n)</pre> <p> Errors </p> <pre data-language=\"go\">const (\n        SIGABRT   = Signal(0x6)\n        SIGALRM   = Signal(0xe)\n        SIGBUS    = Signal(0x7)\n        SIGCHLD   = Signal(0x11)\n        SIGCLD    = Signal(0x11)\n        SIGCONT   = Signal(0x12)\n        SIGFPE    = Signal(0x8)\n        SIGHUP    = Signal(0x1)\n        SIGILL    = Signal(0x4)\n        SIGINT    = Signal(0x2)\n        SIGIO     = Signal(0x1d)\n        SIGIOT    = Signal(0x6)\n        SIGKILL   = Signal(0x9)\n        SIGPIPE   = Signal(0xd)\n        SIGPOLL   = Signal(0x1d)\n        SIGPROF   = Signal(0x1b)\n        SIGPWR    = Signal(0x1e)\n        SIGQUIT   = Signal(0x3)\n        SIGSEGV   = Signal(0xb)\n        SIGSTKFLT = Signal(0x10)\n        SIGSTOP   = Signal(0x13)\n        SIGSYS    = Signal(0x1f)\n        SIGTERM   = Signal(0xf)\n        SIGTRAP   = Signal(0x5)\n        SIGTSTP   = Signal(0x14)\n        SIGTTIN   = Signal(0x15)\n        SIGTTOU   = Signal(0x16)\n        SIGUNUSED = Signal(0x1f)\n        SIGURG    = Signal(0x17)\n        SIGUSR1   = Signal(0xa)\n        SIGUSR2   = Signal(0xc)\n        SIGVTALRM = Signal(0x1a)\n        SIGWINCH  = Signal(0x1c)\n        SIGXCPU   = Signal(0x18)\n        SIGXFSZ   = Signal(0x19)\n)</pre> <p> Signals </p> <pre data-language=\"go\">const (\n        SYS_READ                   = 0\n        SYS_WRITE                  = 1\n        SYS_OPEN                   = 2\n        SYS_CLOSE                  = 3\n        SYS_STAT                   = 4\n        SYS_FSTAT                  = 5\n        SYS_LSTAT                  = 6\n        SYS_POLL                   = 7\n        SYS_LSEEK                  = 8\n        SYS_MMAP                   = 9\n        SYS_MPROTECT               = 10\n        SYS_MUNMAP                 = 11\n        SYS_BRK                    = 12\n        SYS_RT_SIGACTION           = 13\n        SYS_RT_SIGPROCMASK         = 14\n        SYS_RT_SIGRETURN           = 15\n        SYS_IOCTL                  = 16\n        SYS_PREAD64                = 17\n        SYS_PWRITE64               = 18\n        SYS_READV                  = 19\n        SYS_WRITEV                 = 20\n        SYS_ACCESS                 = 21\n        SYS_PIPE                   = 22\n        SYS_SELECT                 = 23\n        SYS_SCHED_YIELD            = 24\n        SYS_MREMAP                 = 25\n        SYS_MSYNC                  = 26\n        SYS_MINCORE                = 27\n        SYS_MADVISE                = 28\n        SYS_SHMGET                 = 29\n        SYS_SHMAT                  = 30\n        SYS_SHMCTL                 = 31\n        SYS_DUP                    = 32\n        SYS_DUP2                   = 33\n        SYS_PAUSE                  = 34\n        SYS_NANOSLEEP              = 35\n        SYS_GETITIMER              = 36\n        SYS_ALARM                  = 37\n        SYS_SETITIMER              = 38\n        SYS_GETPID                 = 39\n        SYS_SENDFILE               = 40\n        SYS_SOCKET                 = 41\n        SYS_CONNECT                = 42\n        SYS_ACCEPT                 = 43\n        SYS_SENDTO                 = 44\n        SYS_RECVFROM               = 45\n        SYS_SENDMSG                = 46\n        SYS_RECVMSG                = 47\n        SYS_SHUTDOWN               = 48\n        SYS_BIND                   = 49\n        SYS_LISTEN                 = 50\n        SYS_GETSOCKNAME            = 51\n        SYS_GETPEERNAME            = 52\n        SYS_SOCKETPAIR             = 53\n        SYS_SETSOCKOPT             = 54\n        SYS_GETSOCKOPT             = 55\n        SYS_CLONE                  = 56\n        SYS_FORK                   = 57\n        SYS_VFORK                  = 58\n        SYS_EXECVE                 = 59\n        SYS_EXIT                   = 60\n        SYS_WAIT4                  = 61\n        SYS_KILL                   = 62\n        SYS_UNAME                  = 63\n        SYS_SEMGET                 = 64\n        SYS_SEMOP                  = 65\n        SYS_SEMCTL                 = 66\n        SYS_SHMDT                  = 67\n        SYS_MSGGET                 = 68\n        SYS_MSGSND                 = 69\n        SYS_MSGRCV                 = 70\n        SYS_MSGCTL                 = 71\n        SYS_FCNTL                  = 72\n        SYS_FLOCK                  = 73\n        SYS_FSYNC                  = 74\n        SYS_FDATASYNC              = 75\n        SYS_TRUNCATE               = 76\n        SYS_FTRUNCATE              = 77\n        SYS_GETDENTS               = 78\n        SYS_GETCWD                 = 79\n        SYS_CHDIR                  = 80\n        SYS_FCHDIR                 = 81\n        SYS_RENAME                 = 82\n        SYS_MKDIR                  = 83\n        SYS_RMDIR                  = 84\n        SYS_CREAT                  = 85\n        SYS_LINK                   = 86\n        SYS_UNLINK                 = 87\n        SYS_SYMLINK                = 88\n        SYS_READLINK               = 89\n        SYS_CHMOD                  = 90\n        SYS_FCHMOD                 = 91\n        SYS_CHOWN                  = 92\n        SYS_FCHOWN                 = 93\n        SYS_LCHOWN                 = 94\n        SYS_UMASK                  = 95\n        SYS_GETTIMEOFDAY           = 96\n        SYS_GETRLIMIT              = 97\n        SYS_GETRUSAGE              = 98\n        SYS_SYSINFO                = 99\n        SYS_TIMES                  = 100\n        SYS_PTRACE                 = 101\n        SYS_GETUID                 = 102\n        SYS_SYSLOG                 = 103\n        SYS_GETGID                 = 104\n        SYS_SETUID                 = 105\n        SYS_SETGID                 = 106\n        SYS_GETEUID                = 107\n        SYS_GETEGID                = 108\n        SYS_SETPGID                = 109\n        SYS_GETPPID                = 110\n        SYS_GETPGRP                = 111\n        SYS_SETSID                 = 112\n        SYS_SETREUID               = 113\n        SYS_SETREGID               = 114\n        SYS_GETGROUPS              = 115\n        SYS_SETGROUPS              = 116\n        SYS_SETRESUID              = 117\n        SYS_GETRESUID              = 118\n        SYS_SETRESGID              = 119\n        SYS_GETRESGID              = 120\n        SYS_GETPGID                = 121\n        SYS_SETFSUID               = 122\n        SYS_SETFSGID               = 123\n        SYS_GETSID                 = 124\n        SYS_CAPGET                 = 125\n        SYS_CAPSET                 = 126\n        SYS_RT_SIGPENDING          = 127\n        SYS_RT_SIGTIMEDWAIT        = 128\n        SYS_RT_SIGQUEUEINFO        = 129\n        SYS_RT_SIGSUSPEND          = 130\n        SYS_SIGALTSTACK            = 131\n        SYS_UTIME                  = 132\n        SYS_MKNOD                  = 133\n        SYS_USELIB                 = 134\n        SYS_PERSONALITY            = 135\n        SYS_USTAT                  = 136\n        SYS_STATFS                 = 137\n        SYS_FSTATFS                = 138\n        SYS_SYSFS                  = 139\n        SYS_GETPRIORITY            = 140\n        SYS_SETPRIORITY            = 141\n        SYS_SCHED_SETPARAM         = 142\n        SYS_SCHED_GETPARAM         = 143\n        SYS_SCHED_SETSCHEDULER     = 144\n        SYS_SCHED_GETSCHEDULER     = 145\n        SYS_SCHED_GET_PRIORITY_MAX = 146\n        SYS_SCHED_GET_PRIORITY_MIN = 147\n        SYS_SCHED_RR_GET_INTERVAL  = 148\n        SYS_MLOCK                  = 149\n        SYS_MUNLOCK                = 150\n        SYS_MLOCKALL               = 151\n        SYS_MUNLOCKALL             = 152\n        SYS_VHANGUP                = 153\n        SYS_MODIFY_LDT             = 154\n        SYS_PIVOT_ROOT             = 155\n        SYS__SYSCTL                = 156\n        SYS_PRCTL                  = 157\n        SYS_ARCH_PRCTL             = 158\n        SYS_ADJTIMEX               = 159\n        SYS_SETRLIMIT              = 160\n        SYS_CHROOT                 = 161\n        SYS_SYNC                   = 162\n        SYS_ACCT                   = 163\n        SYS_SETTIMEOFDAY           = 164\n        SYS_MOUNT                  = 165\n        SYS_UMOUNT2                = 166\n        SYS_SWAPON                 = 167\n        SYS_SWAPOFF                = 168\n        SYS_REBOOT                 = 169\n        SYS_SETHOSTNAME            = 170\n        SYS_SETDOMAINNAME          = 171\n        SYS_IOPL                   = 172\n        SYS_IOPERM                 = 173\n        SYS_CREATE_MODULE          = 174\n        SYS_INIT_MODULE            = 175\n        SYS_DELETE_MODULE          = 176\n        SYS_GET_KERNEL_SYMS        = 177\n        SYS_QUERY_MODULE           = 178\n        SYS_QUOTACTL               = 179\n        SYS_NFSSERVCTL             = 180\n        SYS_GETPMSG                = 181\n        SYS_PUTPMSG                = 182\n        SYS_AFS_SYSCALL            = 183\n        SYS_TUXCALL                = 184\n        SYS_SECURITY               = 185\n        SYS_GETTID                 = 186\n        SYS_READAHEAD              = 187\n        SYS_SETXATTR               = 188\n        SYS_LSETXATTR              = 189\n        SYS_FSETXATTR              = 190\n        SYS_GETXATTR               = 191\n        SYS_LGETXATTR              = 192\n        SYS_FGETXATTR              = 193\n        SYS_LISTXATTR              = 194\n        SYS_LLISTXATTR             = 195\n        SYS_FLISTXATTR             = 196\n        SYS_REMOVEXATTR            = 197\n        SYS_LREMOVEXATTR           = 198\n        SYS_FREMOVEXATTR           = 199\n        SYS_TKILL                  = 200\n        SYS_TIME                   = 201\n        SYS_FUTEX                  = 202\n        SYS_SCHED_SETAFFINITY      = 203\n        SYS_SCHED_GETAFFINITY      = 204\n        SYS_SET_THREAD_AREA        = 205\n        SYS_IO_SETUP               = 206\n        SYS_IO_DESTROY             = 207\n        SYS_IO_GETEVENTS           = 208\n        SYS_IO_SUBMIT              = 209\n        SYS_IO_CANCEL              = 210\n        SYS_GET_THREAD_AREA        = 211\n        SYS_LOOKUP_DCOOKIE         = 212\n        SYS_EPOLL_CREATE           = 213\n        SYS_EPOLL_CTL_OLD          = 214\n        SYS_EPOLL_WAIT_OLD         = 215\n        SYS_REMAP_FILE_PAGES       = 216\n        SYS_GETDENTS64             = 217\n        SYS_SET_TID_ADDRESS        = 218\n        SYS_RESTART_SYSCALL        = 219\n        SYS_SEMTIMEDOP             = 220\n        SYS_FADVISE64              = 221\n        SYS_TIMER_CREATE           = 222\n        SYS_TIMER_SETTIME          = 223\n        SYS_TIMER_GETTIME          = 224\n        SYS_TIMER_GETOVERRUN       = 225\n        SYS_TIMER_DELETE           = 226\n        SYS_CLOCK_SETTIME          = 227\n        SYS_CLOCK_GETTIME          = 228\n        SYS_CLOCK_GETRES           = 229\n        SYS_CLOCK_NANOSLEEP        = 230\n        SYS_EXIT_GROUP             = 231\n        SYS_EPOLL_WAIT             = 232\n        SYS_EPOLL_CTL              = 233\n        SYS_TGKILL                 = 234\n        SYS_UTIMES                 = 235\n        SYS_VSERVER                = 236\n        SYS_MBIND                  = 237\n        SYS_SET_MEMPOLICY          = 238\n        SYS_GET_MEMPOLICY          = 239\n        SYS_MQ_OPEN                = 240\n        SYS_MQ_UNLINK              = 241\n        SYS_MQ_TIMEDSEND           = 242\n        SYS_MQ_TIMEDRECEIVE        = 243\n        SYS_MQ_NOTIFY              = 244\n        SYS_MQ_GETSETATTR          = 245\n        SYS_KEXEC_LOAD             = 246\n        SYS_WAITID                 = 247\n        SYS_ADD_KEY                = 248\n        SYS_REQUEST_KEY            = 249\n        SYS_KEYCTL                 = 250\n        SYS_IOPRIO_SET             = 251\n        SYS_IOPRIO_GET             = 252\n        SYS_INOTIFY_INIT           = 253\n        SYS_INOTIFY_ADD_WATCH      = 254\n        SYS_INOTIFY_RM_WATCH       = 255\n        SYS_MIGRATE_PAGES          = 256\n        SYS_OPENAT                 = 257\n        SYS_MKDIRAT                = 258\n        SYS_MKNODAT                = 259\n        SYS_FCHOWNAT               = 260\n        SYS_FUTIMESAT              = 261\n        SYS_NEWFSTATAT             = 262\n        SYS_UNLINKAT               = 263\n        SYS_RENAMEAT               = 264\n        SYS_LINKAT                 = 265\n        SYS_SYMLINKAT              = 266\n        SYS_READLINKAT             = 267\n        SYS_FCHMODAT               = 268\n        SYS_FACCESSAT              = 269\n        SYS_PSELECT6               = 270\n        SYS_PPOLL                  = 271\n        SYS_UNSHARE                = 272\n        SYS_SET_ROBUST_LIST        = 273\n        SYS_GET_ROBUST_LIST        = 274\n        SYS_SPLICE                 = 275\n        SYS_TEE                    = 276\n        SYS_SYNC_FILE_RANGE        = 277\n        SYS_VMSPLICE               = 278\n        SYS_MOVE_PAGES             = 279\n        SYS_UTIMENSAT              = 280\n        SYS_EPOLL_PWAIT            = 281\n        SYS_SIGNALFD               = 282\n        SYS_TIMERFD_CREATE         = 283\n        SYS_EVENTFD                = 284\n        SYS_FALLOCATE              = 285\n        SYS_TIMERFD_SETTIME        = 286\n        SYS_TIMERFD_GETTIME        = 287\n        SYS_ACCEPT4                = 288\n        SYS_SIGNALFD4              = 289\n        SYS_EVENTFD2               = 290\n        SYS_EPOLL_CREATE1          = 291\n        SYS_DUP3                   = 292\n        SYS_PIPE2                  = 293\n        SYS_INOTIFY_INIT1          = 294\n        SYS_PREADV                 = 295\n        SYS_PWRITEV                = 296\n        SYS_RT_TGSIGQUEUEINFO      = 297\n        SYS_PERF_EVENT_OPEN        = 298\n        SYS_RECVMMSG               = 299\n        SYS_FANOTIFY_INIT          = 300\n        SYS_FANOTIFY_MARK          = 301\n        SYS_PRLIMIT64              = 302\n)</pre> <pre data-language=\"go\">const (\n        SizeofSockaddrInet4     = 0x10\n        SizeofSockaddrInet6     = 0x1c\n        SizeofSockaddrAny       = 0x70\n        SizeofSockaddrUnix      = 0x6e\n        SizeofSockaddrLinklayer = 0x14\n        SizeofSockaddrNetlink   = 0xc\n        SizeofLinger            = 0x8\n        SizeofIPMreq            = 0x8\n        SizeofIPMreqn           = 0xc\n        SizeofIPv6Mreq          = 0x14\n        SizeofMsghdr            = 0x38\n        SizeofCmsghdr           = 0x10\n        SizeofInet4Pktinfo      = 0xc\n        SizeofInet6Pktinfo      = 0x14\n        SizeofIPv6MTUInfo       = 0x20\n        SizeofICMPv6Filter      = 0x20\n        SizeofUcred             = 0xc\n        SizeofTCPInfo           = 0x68\n)</pre> <pre data-language=\"go\">const (\n        IFA_UNSPEC          = 0x0\n        IFA_ADDRESS         = 0x1\n        IFA_LOCAL           = 0x2\n        IFA_LABEL           = 0x3\n        IFA_BROADCAST       = 0x4\n        IFA_ANYCAST         = 0x5\n        IFA_CACHEINFO       = 0x6\n        IFA_MULTICAST       = 0x7\n        IFLA_UNSPEC         = 0x0\n        IFLA_ADDRESS        = 0x1\n        IFLA_BROADCAST      = 0x2\n        IFLA_IFNAME         = 0x3\n        IFLA_MTU            = 0x4\n        IFLA_LINK           = 0x5\n        IFLA_QDISC          = 0x6\n        IFLA_STATS          = 0x7\n        IFLA_COST           = 0x8\n        IFLA_PRIORITY       = 0x9\n        IFLA_MASTER         = 0xa\n        IFLA_WIRELESS       = 0xb\n        IFLA_PROTINFO       = 0xc\n        IFLA_TXQLEN         = 0xd\n        IFLA_MAP            = 0xe\n        IFLA_WEIGHT         = 0xf\n        IFLA_OPERSTATE      = 0x10\n        IFLA_LINKMODE       = 0x11\n        IFLA_LINKINFO       = 0x12\n        IFLA_NET_NS_PID     = 0x13\n        IFLA_IFALIAS        = 0x14\n        IFLA_MAX            = 0x1d\n        RT_SCOPE_UNIVERSE   = 0x0\n        RT_SCOPE_SITE       = 0xc8\n        RT_SCOPE_LINK       = 0xfd\n        RT_SCOPE_HOST       = 0xfe\n        RT_SCOPE_NOWHERE    = 0xff\n        RT_TABLE_UNSPEC     = 0x0\n        RT_TABLE_COMPAT     = 0xfc\n        RT_TABLE_DEFAULT    = 0xfd\n        RT_TABLE_MAIN       = 0xfe\n        RT_TABLE_LOCAL      = 0xff\n        RT_TABLE_MAX        = 0xffffffff\n        RTA_UNSPEC          = 0x0\n        RTA_DST             = 0x1\n        RTA_SRC             = 0x2\n        RTA_IIF             = 0x3\n        RTA_OIF             = 0x4\n        RTA_GATEWAY         = 0x5\n        RTA_PRIORITY        = 0x6\n        RTA_PREFSRC         = 0x7\n        RTA_METRICS         = 0x8\n        RTA_MULTIPATH       = 0x9\n        RTA_FLOW            = 0xb\n        RTA_CACHEINFO       = 0xc\n        RTA_TABLE           = 0xf\n        RTN_UNSPEC          = 0x0\n        RTN_UNICAST         = 0x1\n        RTN_LOCAL           = 0x2\n        RTN_BROADCAST       = 0x3\n        RTN_ANYCAST         = 0x4\n        RTN_MULTICAST       = 0x5\n        RTN_BLACKHOLE       = 0x6\n        RTN_UNREACHABLE     = 0x7\n        RTN_PROHIBIT        = 0x8\n        RTN_THROW           = 0x9\n        RTN_NAT             = 0xa\n        RTN_XRESOLVE        = 0xb\n        RTNLGRP_NONE        = 0x0\n        RTNLGRP_LINK        = 0x1\n        RTNLGRP_NOTIFY      = 0x2\n        RTNLGRP_NEIGH       = 0x3\n        RTNLGRP_TC          = 0x4\n        RTNLGRP_IPV4_IFADDR = 0x5\n        RTNLGRP_IPV4_MROUTE = 0x6\n        RTNLGRP_IPV4_ROUTE  = 0x7\n        RTNLGRP_IPV4_RULE   = 0x8\n        RTNLGRP_IPV6_IFADDR = 0x9\n        RTNLGRP_IPV6_MROUTE = 0xa\n        RTNLGRP_IPV6_ROUTE  = 0xb\n        RTNLGRP_IPV6_IFINFO = 0xc\n        RTNLGRP_IPV6_PREFIX = 0x12\n        RTNLGRP_IPV6_RULE   = 0x13\n        RTNLGRP_ND_USEROPT  = 0x14\n        SizeofNlMsghdr      = 0x10\n        SizeofNlMsgerr      = 0x14\n        SizeofRtGenmsg      = 0x1\n        SizeofNlAttr        = 0x4\n        SizeofRtAttr        = 0x4\n        SizeofIfInfomsg     = 0x10\n        SizeofIfAddrmsg     = 0x8\n        SizeofRtMsg         = 0xc\n        SizeofRtNexthop     = 0x8\n)</pre> <pre data-language=\"go\">const (\n        SizeofSockFilter = 0x8\n        SizeofSockFprog  = 0x10\n)</pre> <pre data-language=\"go\">const (\n        VINTR    = 0x0\n        VQUIT    = 0x1\n        VERASE   = 0x2\n        VKILL    = 0x3\n        VEOF     = 0x4\n        VTIME    = 0x5\n        VMIN     = 0x6\n        VSWTC    = 0x7\n        VSTART   = 0x8\n        VSTOP    = 0x9\n        VSUSP    = 0xa\n        VEOL     = 0xb\n        VREPRINT = 0xc\n        VDISCARD = 0xd\n        VWERASE  = 0xe\n        VLNEXT   = 0xf\n        VEOL2    = 0x10\n        IGNBRK   = 0x1\n        BRKINT   = 0x2\n        IGNPAR   = 0x4\n        PARMRK   = 0x8\n        INPCK    = 0x10\n        ISTRIP   = 0x20\n        INLCR    = 0x40\n        IGNCR    = 0x80\n        ICRNL    = 0x100\n        IUCLC    = 0x200\n        IXON     = 0x400\n        IXANY    = 0x800\n        IXOFF    = 0x1000\n        IMAXBEL  = 0x2000\n        IUTF8    = 0x4000\n        OPOST    = 0x1\n        OLCUC    = 0x2\n        ONLCR    = 0x4\n        OCRNL    = 0x8\n        ONOCR    = 0x10\n        ONLRET   = 0x20\n        OFILL    = 0x40\n        OFDEL    = 0x80\n        B0       = 0x0\n        B50      = 0x1\n        B75      = 0x2\n        B110     = 0x3\n        B134     = 0x4\n        B150     = 0x5\n        B200     = 0x6\n        B300     = 0x7\n        B600     = 0x8\n        B1200    = 0x9\n        B1800    = 0xa\n        B2400    = 0xb\n        B4800    = 0xc\n        B9600    = 0xd\n        B19200   = 0xe\n        B38400   = 0xf\n        CSIZE    = 0x30\n        CS5      = 0x0\n        CS6      = 0x10\n        CS7      = 0x20\n        CS8      = 0x30\n        CSTOPB   = 0x40\n        CREAD    = 0x80\n        PARENB   = 0x100\n        PARODD   = 0x200\n        HUPCL    = 0x400\n        CLOCAL   = 0x800\n        B57600   = 0x1001\n        B115200  = 0x1002\n        B230400  = 0x1003\n        B460800  = 0x1004\n        B500000  = 0x1005\n        B576000  = 0x1006\n        B921600  = 0x1007\n        B1000000 = 0x1008\n        B1152000 = 0x1009\n        B1500000 = 0x100a\n        B2000000 = 0x100b\n        B2500000 = 0x100c\n        B3000000 = 0x100d\n        B3500000 = 0x100e\n        B4000000 = 0x100f\n        ISIG     = 0x1\n        ICANON   = 0x2\n        XCASE    = 0x4\n        ECHO     = 0x8\n        ECHOE    = 0x10\n        ECHOK    = 0x20\n        ECHONL   = 0x40\n        NOFLSH   = 0x80\n        TOSTOP   = 0x100\n        ECHOCTL  = 0x200\n        ECHOPRT  = 0x400\n        ECHOKE   = 0x800\n        FLUSHO   = 0x1000\n        PENDIN   = 0x4000\n        IEXTEN   = 0x8000\n        TCGETS   = 0x5401\n        TCSETS   = 0x5402\n)</pre> <pre data-language=\"go\">const ImplementsGetwd = true</pre> <pre data-language=\"go\">const (\n        PathMax = 0x1000\n)</pre> <pre data-language=\"go\">const SizeofInotifyEvent = 0x10</pre> <h2 id=\"pkg-variables\">Variables</h2> <pre data-language=\"go\">var (\n        Stdin  = 0\n        Stdout = 1\n        Stderr = 2\n)</pre> <pre data-language=\"go\">var ForkLock sync.RWMutex</pre> <pre data-language=\"go\">var SocketDisableIPv6 bool</pre> <p> For testing: clients can set this flag to force creation of IPv6 sockets to return EAFNOSUPPORT. </p> <h2 id=\"Accept\">func Accept  </h2> <pre data-language=\"go\">func Accept(fd int) (nfd int, sa Sockaddr, err error)</pre> <h2 id=\"Accept4\">func Accept4  </h2> <pre data-language=\"go\">func Accept4(fd int, flags int) (nfd int, sa Sockaddr, err error)</pre> <h2 id=\"Access\">func Access  </h2> <pre data-language=\"go\">func Access(path string, mode uint32) (err error)</pre> <h2 id=\"Acct\">func Acct  </h2> <pre data-language=\"go\">func Acct(path string) (err error)</pre> <h2 id=\"Adjtimex\">func Adjtimex  </h2> <pre data-language=\"go\">func Adjtimex(buf *Timex) (state int, err error)</pre> <h2 id=\"AttachLsf\">func AttachLsf  </h2> <pre data-language=\"go\">func AttachLsf(fd int, i []SockFilter) error</pre> <p> Deprecated: Use golang.org/x/net/bpf instead. </p> <h2 id=\"Bind\">func Bind  </h2> <pre data-language=\"go\">func Bind(fd int, sa Sockaddr) (err error)</pre> <h2 id=\"BindToDevice\">func BindToDevice  </h2> <pre data-language=\"go\">func BindToDevice(fd int, device string) (err error)</pre> <p> BindToDevice binds the socket associated with fd to device. </p> <h2 id=\"BytePtrFromString\">func BytePtrFromString  </h2> <pre data-language=\"go\">func BytePtrFromString(s string) (*byte, error)</pre> <p> BytePtrFromString returns a pointer to a NUL-terminated array of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, EINVAL). </p> <h2 id=\"ByteSliceFromString\">func ByteSliceFromString  </h2> <pre data-language=\"go\">func ByteSliceFromString(s string) ([]byte, error)</pre> <p> ByteSliceFromString returns a NUL-terminated slice of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, EINVAL). </p> <h2 id=\"Chdir\">func Chdir  </h2> <pre data-language=\"go\">func Chdir(path string) (err error)</pre> <h2 id=\"Chmod\">func Chmod  </h2> <pre data-language=\"go\">func Chmod(path string, mode uint32) (err error)</pre> <h2 id=\"Chown\">func Chown  </h2> <pre data-language=\"go\">func Chown(path string, uid int, gid int) (err error)</pre> <h2 id=\"Chroot\">func Chroot  </h2> <pre data-language=\"go\">func Chroot(path string) (err error)</pre> <h2 id=\"Clearenv\">func Clearenv  </h2> <pre data-language=\"go\">func Clearenv()</pre> <h2 id=\"Close\">func Close  </h2> <pre data-language=\"go\">func Close(fd int) (err error)</pre> <h2 id=\"CloseOnExec\">func CloseOnExec  </h2> <pre data-language=\"go\">func CloseOnExec(fd int)</pre> <h2 id=\"CmsgLen\">func CmsgLen  </h2> <pre data-language=\"go\">func CmsgLen(datalen int) int</pre> <p> CmsgLen returns the value to store in the Len field of the Cmsghdr structure, taking into account any necessary alignment. </p> <h2 id=\"CmsgSpace\">func CmsgSpace  </h2> <pre data-language=\"go\">func CmsgSpace(datalen int) int</pre> <p> CmsgSpace returns the number of bytes an ancillary element with payload of the passed data length occupies. </p> <h2 id=\"Connect\">func Connect  </h2> <pre data-language=\"go\">func Connect(fd int, sa Sockaddr) (err error)</pre> <h2 id=\"Creat\">func Creat  </h2> <pre data-language=\"go\">func Creat(path string, mode uint32) (fd int, err error)</pre> <h2 id=\"DetachLsf\">func DetachLsf  </h2> <pre data-language=\"go\">func DetachLsf(fd int) error</pre> <p> Deprecated: Use golang.org/x/net/bpf instead. </p> <h2 id=\"Dup\">func Dup  </h2> <pre data-language=\"go\">func Dup(oldfd int) (fd int, err error)</pre> <h2 id=\"Dup2\">func Dup2  </h2> <pre data-language=\"go\">func Dup2(oldfd int, newfd int) (err error)</pre> <h2 id=\"Dup3\">func Dup3  </h2> <pre data-language=\"go\">func Dup3(oldfd int, newfd int, flags int) (err error)</pre> <h2 id=\"Environ\">func Environ  </h2> <pre data-language=\"go\">func Environ() []string</pre> <h2 id=\"EpollCreate\">func EpollCreate  </h2> <pre data-language=\"go\">func EpollCreate(size int) (fd int, err error)</pre> <h2 id=\"EpollCreate1\">func EpollCreate1  </h2> <pre data-language=\"go\">func EpollCreate1(flag int) (fd int, err error)</pre> <h2 id=\"EpollCtl\">func EpollCtl  </h2> <pre data-language=\"go\">func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error)</pre> <h2 id=\"EpollWait\">func EpollWait  </h2> <pre data-language=\"go\">func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error)</pre> <h2 id=\"Exec\">func Exec  </h2> <pre data-language=\"go\">func Exec(argv0 string, argv []string, envv []string) (err error)</pre> <p> Ordinary exec. </p> <h2 id=\"Exit\">func Exit  </h2> <pre data-language=\"go\">func Exit(code int)</pre> <h2 id=\"Faccessat\">func Faccessat  </h2> <pre data-language=\"go\">func Faccessat(dirfd int, path string, mode uint32, flags int) (err error)</pre> <h2 id=\"Fallocate\">func Fallocate  </h2> <pre data-language=\"go\">func Fallocate(fd int, mode uint32, off int64, len int64) (err error)</pre> <h2 id=\"Fchdir\">func Fchdir  </h2> <pre data-language=\"go\">func Fchdir(fd int) (err error)</pre> <h2 id=\"Fchmod\">func Fchmod  </h2> <pre data-language=\"go\">func Fchmod(fd int, mode uint32) (err error)</pre> <h2 id=\"Fchmodat\">func Fchmodat  </h2> <pre data-language=\"go\">func Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)</pre> <h2 id=\"Fchown\">func Fchown  </h2> <pre data-language=\"go\">func Fchown(fd int, uid int, gid int) (err error)</pre> <h2 id=\"Fchownat\">func Fchownat  </h2> <pre data-language=\"go\">func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)</pre> <h2 id=\"FcntlFlock\">func FcntlFlock  </h2> <pre data-language=\"go\">func FcntlFlock(fd uintptr, cmd int, lk *Flock_t) error</pre> <p> FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command. </p> <h2 id=\"Fdatasync\">func Fdatasync  </h2> <pre data-language=\"go\">func Fdatasync(fd int) (err error)</pre> <h2 id=\"Flock\">func Flock  </h2> <pre data-language=\"go\">func Flock(fd int, how int) (err error)</pre> <h2 id=\"ForkExec\">func ForkExec  </h2> <pre data-language=\"go\">func ForkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)</pre> <p> Combination of fork and exec, careful to be thread safe. </p> <h2 id=\"Fstat\">func Fstat  </h2> <pre data-language=\"go\">func Fstat(fd int, stat *Stat_t) (err error)</pre> <h2 id=\"Fstatfs\">func Fstatfs  </h2> <pre data-language=\"go\">func Fstatfs(fd int, buf *Statfs_t) (err error)</pre> <h2 id=\"Fsync\">func Fsync  </h2> <pre data-language=\"go\">func Fsync(fd int) (err error)</pre> <h2 id=\"Ftruncate\">func Ftruncate  </h2> <pre data-language=\"go\">func Ftruncate(fd int, length int64) (err error)</pre> <h2 id=\"Futimes\">func Futimes  </h2> <pre data-language=\"go\">func Futimes(fd int, tv []Timeval) (err error)</pre> <h2 id=\"Futimesat\">func Futimesat  </h2> <pre data-language=\"go\">func Futimesat(dirfd int, path string, tv []Timeval) (err error)</pre> <h2 id=\"Getcwd\">func Getcwd  </h2> <pre data-language=\"go\">func Getcwd(buf []byte) (n int, err error)</pre> <h2 id=\"Getdents\">func Getdents  </h2> <pre data-language=\"go\">func Getdents(fd int, buf []byte) (n int, err error)</pre> <h2 id=\"Getegid\">func Getegid  </h2> <pre data-language=\"go\">func Getegid() (egid int)</pre> <h2 id=\"Getenv\">func Getenv  </h2> <pre data-language=\"go\">func Getenv(key string) (value string, found bool)</pre> <h2 id=\"Geteuid\">func Geteuid  </h2> <pre data-language=\"go\">func Geteuid() (euid int)</pre> <h2 id=\"Getgid\">func Getgid  </h2> <pre data-language=\"go\">func Getgid() (gid int)</pre> <h2 id=\"Getgroups\">func Getgroups  </h2> <pre data-language=\"go\">func Getgroups() (gids []int, err error)</pre> <h2 id=\"Getpagesize\">func Getpagesize  </h2> <pre data-language=\"go\">func Getpagesize() int</pre> <h2 id=\"Getpgid\">func Getpgid  </h2> <pre data-language=\"go\">func Getpgid(pid int) (pgid int, err error)</pre> <h2 id=\"Getpgrp\">func Getpgrp  </h2> <pre data-language=\"go\">func Getpgrp() (pid int)</pre> <h2 id=\"Getpid\">func Getpid  </h2> <pre data-language=\"go\">func Getpid() (pid int)</pre> <h2 id=\"Getppid\">func Getppid  </h2> <pre data-language=\"go\">func Getppid() (ppid int)</pre> <h2 id=\"Getpriority\">func Getpriority  </h2> <pre data-language=\"go\">func Getpriority(which int, who int) (prio int, err error)</pre> <h2 id=\"Getrlimit\">func Getrlimit  </h2> <pre data-language=\"go\">func Getrlimit(resource int, rlim *Rlimit) (err error)</pre> <h2 id=\"Getrusage\">func Getrusage  </h2> <pre data-language=\"go\">func Getrusage(who int, rusage *Rusage) (err error)</pre> <h2 id=\"GetsockoptInet4Addr\">func GetsockoptInet4Addr  </h2> <pre data-language=\"go\">func GetsockoptInet4Addr(fd, level, opt int) (value [4]byte, err error)</pre> <h2 id=\"GetsockoptInt\">func GetsockoptInt  </h2> <pre data-language=\"go\">func GetsockoptInt(fd, level, opt int) (value int, err error)</pre> <h2 id=\"Gettid\">func Gettid  </h2> <pre data-language=\"go\">func Gettid() (tid int)</pre> <h2 id=\"Gettimeofday\">func Gettimeofday  </h2> <pre data-language=\"go\">func Gettimeofday(tv *Timeval) (err error)</pre> <h2 id=\"Getuid\">func Getuid  </h2> <pre data-language=\"go\">func Getuid() (uid int)</pre> <h2 id=\"Getwd\">func Getwd  </h2> <pre data-language=\"go\">func Getwd() (wd string, err error)</pre> <h2 id=\"Getxattr\">func Getxattr  </h2> <pre data-language=\"go\">func Getxattr(path string, attr string, dest []byte) (sz int, err error)</pre> <h2 id=\"InotifyAddWatch\">func InotifyAddWatch  </h2> <pre data-language=\"go\">func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error)</pre> <h2 id=\"InotifyInit\">func InotifyInit  </h2> <pre data-language=\"go\">func InotifyInit() (fd int, err error)</pre> <h2 id=\"InotifyInit1\">func InotifyInit1  </h2> <pre data-language=\"go\">func InotifyInit1(flags int) (fd int, err error)</pre> <h2 id=\"InotifyRmWatch\">func InotifyRmWatch  </h2> <pre data-language=\"go\">func InotifyRmWatch(fd int, watchdesc uint32) (success int, err error)</pre> <h2 id=\"Ioperm\">func Ioperm  </h2> <pre data-language=\"go\">func Ioperm(from int, num int, on int) (err error)</pre> <h2 id=\"Iopl\">func Iopl  </h2> <pre data-language=\"go\">func Iopl(level int) (err error)</pre> <h2 id=\"Kill\">func Kill  </h2> <pre data-language=\"go\">func Kill(pid int, sig Signal) (err error)</pre> <h2 id=\"Klogctl\">func Klogctl  </h2> <pre data-language=\"go\">func Klogctl(typ int, buf []byte) (n int, err error)</pre> <h2 id=\"Lchown\">func Lchown  </h2> <pre data-language=\"go\">func Lchown(path string, uid int, gid int) (err error)</pre> <h2 id=\"Link\">func Link  </h2> <pre data-language=\"go\">func Link(oldpath string, newpath string) (err error)</pre> <h2 id=\"Listen\">func Listen  </h2> <pre data-language=\"go\">func Listen(s int, n int) (err error)</pre> <h2 id=\"Listxattr\">func Listxattr  </h2> <pre data-language=\"go\">func Listxattr(path string, dest []byte) (sz int, err error)</pre> <h2 id=\"LsfSocket\">func LsfSocket  </h2> <pre data-language=\"go\">func LsfSocket(ifindex, proto int) (int, error)</pre> <p> Deprecated: Use golang.org/x/net/bpf instead. </p> <h2 id=\"Lstat\">func Lstat  </h2> <pre data-language=\"go\">func Lstat(path string, stat *Stat_t) (err error)</pre> <h2 id=\"Madvise\">func Madvise  </h2> <pre data-language=\"go\">func Madvise(b []byte, advice int) (err error)</pre> <h2 id=\"Mkdir\">func Mkdir  </h2> <pre data-language=\"go\">func Mkdir(path string, mode uint32) (err error)</pre> <h2 id=\"Mkdirat\">func Mkdirat  </h2> <pre data-language=\"go\">func Mkdirat(dirfd int, path string, mode uint32) (err error)</pre> <h2 id=\"Mkfifo\">func Mkfifo  </h2> <pre data-language=\"go\">func Mkfifo(path string, mode uint32) (err error)</pre> <h2 id=\"Mknod\">func Mknod  </h2> <pre data-language=\"go\">func Mknod(path string, mode uint32, dev int) (err error)</pre> <h2 id=\"Mknodat\">func Mknodat  </h2> <pre data-language=\"go\">func Mknodat(dirfd int, path string, mode uint32, dev int) (err error)</pre> <h2 id=\"Mlock\">func Mlock  </h2> <pre data-language=\"go\">func Mlock(b []byte) (err error)</pre> <h2 id=\"Mlockall\">func Mlockall  </h2> <pre data-language=\"go\">func Mlockall(flags int) (err error)</pre> <h2 id=\"Mmap\">func Mmap  </h2> <pre data-language=\"go\">func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error)</pre> <h2 id=\"Mount\">func Mount  </h2> <pre data-language=\"go\">func Mount(source string, target string, fstype string, flags uintptr, data string) (err error)</pre> <h2 id=\"Mprotect\">func Mprotect  </h2> <pre data-language=\"go\">func Mprotect(b []byte, prot int) (err error)</pre> <h2 id=\"Munlock\">func Munlock  </h2> <pre data-language=\"go\">func Munlock(b []byte) (err error)</pre> <h2 id=\"Munlockall\">func Munlockall  </h2> <pre data-language=\"go\">func Munlockall() (err error)</pre> <h2 id=\"Munmap\">func Munmap  </h2> <pre data-language=\"go\">func Munmap(b []byte) (err error)</pre> <h2 id=\"Nanosleep\">func Nanosleep  </h2> <pre data-language=\"go\">func Nanosleep(time *Timespec, leftover *Timespec) (err error)</pre> <h2 id=\"NetlinkRIB\">func NetlinkRIB  </h2> <pre data-language=\"go\">func NetlinkRIB(proto, family int) ([]byte, error)</pre> <p> NetlinkRIB returns routing information base, as known as RIB, which consists of network facility information, states and parameters. </p> <h2 id=\"Open\">func Open  </h2> <pre data-language=\"go\">func Open(path string, mode int, perm uint32) (fd int, err error)</pre> <h2 id=\"Openat\">func Openat  </h2> <pre data-language=\"go\">func Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)</pre> <h2 id=\"ParseDirent\">func ParseDirent  </h2> <pre data-language=\"go\">func ParseDirent(buf []byte, max int, names []string) (consumed int, count int, newnames []string)</pre> <h2 id=\"ParseNetlinkMessage\">func ParseNetlinkMessage  </h2> <pre data-language=\"go\">func ParseNetlinkMessage(b []byte) ([]NetlinkMessage, error)</pre> <p> ParseNetlinkMessage parses b as an array of netlink messages and returns the slice containing the NetlinkMessage structures. </p> <h2 id=\"ParseNetlinkRouteAttr\">func ParseNetlinkRouteAttr  </h2> <pre data-language=\"go\">func ParseNetlinkRouteAttr(m *NetlinkMessage) ([]NetlinkRouteAttr, error)</pre> <p> ParseNetlinkRouteAttr parses m's payload as an array of netlink route attributes and returns the slice containing the NetlinkRouteAttr structures. </p> <h2 id=\"ParseSocketControlMessage\">func ParseSocketControlMessage  </h2> <pre data-language=\"go\">func ParseSocketControlMessage(b []byte) ([]SocketControlMessage, error)</pre> <p> ParseSocketControlMessage parses b as an array of socket control messages. </p> <h2 id=\"ParseUnixRights\">func ParseUnixRights  </h2> <pre data-language=\"go\">func ParseUnixRights(m *SocketControlMessage) ([]int, error)</pre> <p> ParseUnixRights decodes a socket control message that contains an integer array of open file descriptors from another process. </p> <h2 id=\"Pause\">func Pause  </h2> <pre data-language=\"go\">func Pause() (err error)</pre> <h2 id=\"Pipe\">func Pipe  </h2> <pre data-language=\"go\">func Pipe(p []int) (err error)</pre> <h2 id=\"Pipe2\">func Pipe2  </h2> <pre data-language=\"go\">func Pipe2(p []int, flags int) (err error)</pre> <h2 id=\"PivotRoot\">func PivotRoot  </h2> <pre data-language=\"go\">func PivotRoot(newroot string, putold string) (err error)</pre> <h2 id=\"Pread\">func Pread  </h2> <pre data-language=\"go\">func Pread(fd int, p []byte, offset int64) (n int, err error)</pre> <h2 id=\"PtraceAttach\">func PtraceAttach  </h2> <pre data-language=\"go\">func PtraceAttach(pid int) (err error)</pre> <h2 id=\"PtraceCont\">func PtraceCont  </h2> <pre data-language=\"go\">func PtraceCont(pid int, signal int) (err error)</pre> <h2 id=\"PtraceDetach\">func PtraceDetach  </h2> <pre data-language=\"go\">func PtraceDetach(pid int) (err error)</pre> <h2 id=\"PtraceGetEventMsg\">func PtraceGetEventMsg  </h2> <pre data-language=\"go\">func PtraceGetEventMsg(pid int) (msg uint, err error)</pre> <h2 id=\"PtraceGetRegs\">func PtraceGetRegs  </h2> <pre data-language=\"go\">func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error)</pre> <h2 id=\"PtracePeekData\">func PtracePeekData  </h2> <pre data-language=\"go\">func PtracePeekData(pid int, addr uintptr, out []byte) (count int, err error)</pre> <h2 id=\"PtracePeekText\">func PtracePeekText  </h2> <pre data-language=\"go\">func PtracePeekText(pid int, addr uintptr, out []byte) (count int, err error)</pre> <h2 id=\"PtracePokeData\">func PtracePokeData  </h2> <pre data-language=\"go\">func PtracePokeData(pid int, addr uintptr, data []byte) (count int, err error)</pre> <h2 id=\"PtracePokeText\">func PtracePokeText  </h2> <pre data-language=\"go\">func PtracePokeText(pid int, addr uintptr, data []byte) (count int, err error)</pre> <h2 id=\"PtraceSetOptions\">func PtraceSetOptions  </h2> <pre data-language=\"go\">func PtraceSetOptions(pid int, options int) (err error)</pre> <h2 id=\"PtraceSetRegs\">func PtraceSetRegs  </h2> <pre data-language=\"go\">func PtraceSetRegs(pid int, regs *PtraceRegs) (err error)</pre> <h2 id=\"PtraceSingleStep\">func PtraceSingleStep  </h2> <pre data-language=\"go\">func PtraceSingleStep(pid int) (err error)</pre> <h2 id=\"PtraceSyscall\">func PtraceSyscall  </h2> <pre data-language=\"go\">func PtraceSyscall(pid int, signal int) (err error)</pre> <h2 id=\"Pwrite\">func Pwrite  </h2> <pre data-language=\"go\">func Pwrite(fd int, p []byte, offset int64) (n int, err error)</pre> <h2 id=\"RawSyscall\">func RawSyscall  </h2> <pre data-language=\"go\">func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)</pre> <h2 id=\"RawSyscall6\">func RawSyscall6  </h2> <pre data-language=\"go\">func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)</pre> <h2 id=\"Read\">func Read  </h2> <pre data-language=\"go\">func Read(fd int, p []byte) (n int, err error)</pre> <h2 id=\"ReadDirent\">func ReadDirent  </h2> <pre data-language=\"go\">func ReadDirent(fd int, buf []byte) (n int, err error)</pre> <h2 id=\"Readlink\">func Readlink  </h2> <pre data-language=\"go\">func Readlink(path string, buf []byte) (n int, err error)</pre> <h2 id=\"Reboot\">func Reboot  </h2> <pre data-language=\"go\">func Reboot(cmd int) (err error)</pre> <h2 id=\"Recvfrom\">func Recvfrom  </h2> <pre data-language=\"go\">func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, err error)</pre> <h2 id=\"Recvmsg\">func Recvmsg  </h2> <pre data-language=\"go\">func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error)</pre> <h2 id=\"Removexattr\">func Removexattr  </h2> <pre data-language=\"go\">func Removexattr(path string, attr string) (err error)</pre> <h2 id=\"Rename\">func Rename  </h2> <pre data-language=\"go\">func Rename(oldpath string, newpath string) (err error)</pre> <h2 id=\"Renameat\">func Renameat  </h2> <pre data-language=\"go\">func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)</pre> <h2 id=\"Rmdir\">func Rmdir  </h2> <pre data-language=\"go\">func Rmdir(path string) error</pre> <h2 id=\"Seek\">func Seek  </h2> <pre data-language=\"go\">func Seek(fd int, offset int64, whence int) (off int64, err error)</pre> <h2 id=\"Select\">func Select  </h2> <pre data-language=\"go\">func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)</pre> <h2 id=\"Sendfile\">func Sendfile  </h2> <pre data-language=\"go\">func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)</pre> <h2 id=\"Sendmsg\">func Sendmsg  </h2> <pre data-language=\"go\">func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (err error)</pre> <h2 id=\"SendmsgN\">func SendmsgN  </h2> <pre data-language=\"go\">func SendmsgN(fd int, p, oob []byte, to Sockaddr, flags int) (n int, err error)</pre> <h2 id=\"Sendto\">func Sendto  </h2> <pre data-language=\"go\">func Sendto(fd int, p []byte, flags int, to Sockaddr) (err error)</pre> <h2 id=\"SetLsfPromisc\">func SetLsfPromisc  </h2> <pre data-language=\"go\">func SetLsfPromisc(name string, m bool) error</pre> <p> Deprecated: Use golang.org/x/net/bpf instead. </p> <h2 id=\"SetNonblock\">func SetNonblock  </h2> <pre data-language=\"go\">func SetNonblock(fd int, nonblocking bool) (err error)</pre> <h2 id=\"Setdomainname\">func Setdomainname  </h2> <pre data-language=\"go\">func Setdomainname(p []byte) (err error)</pre> <h2 id=\"Setenv\">func Setenv  </h2> <pre data-language=\"go\">func Setenv(key, value string) error</pre> <h2 id=\"Setfsgid\">func Setfsgid  </h2> <pre data-language=\"go\">func Setfsgid(gid int) (err error)</pre> <h2 id=\"Setfsuid\">func Setfsuid  </h2> <pre data-language=\"go\">func Setfsuid(uid int) (err error)</pre> <h2 id=\"Setgid\">func Setgid  </h2> <pre data-language=\"go\">func Setgid(gid int) (err error)</pre> <h2 id=\"Setgroups\">func Setgroups  </h2> <pre data-language=\"go\">func Setgroups(gids []int) (err error)</pre> <h2 id=\"Sethostname\">func Sethostname  </h2> <pre data-language=\"go\">func Sethostname(p []byte) (err error)</pre> <h2 id=\"Setpgid\">func Setpgid  </h2> <pre data-language=\"go\">func Setpgid(pid int, pgid int) (err error)</pre> <h2 id=\"Setpriority\">func Setpriority  </h2> <pre data-language=\"go\">func Setpriority(which int, who int, prio int) (err error)</pre> <h2 id=\"Setregid\">func Setregid  </h2> <pre data-language=\"go\">func Setregid(rgid int, egid int) (err error)</pre> <h2 id=\"Setresgid\">func Setresgid  </h2> <pre data-language=\"go\">func Setresgid(rgid int, egid int, sgid int) (err error)</pre> <h2 id=\"Setresuid\">func Setresuid  </h2> <pre data-language=\"go\">func Setresuid(ruid int, euid int, suid int) (err error)</pre> <h2 id=\"Setreuid\">func Setreuid  </h2> <pre data-language=\"go\">func Setreuid(ruid int, euid int) (err error)</pre> <h2 id=\"Setrlimit\">func Setrlimit  </h2> <pre data-language=\"go\">func Setrlimit(resource int, rlim *Rlimit) (err error)</pre> <h2 id=\"Setsid\">func Setsid  </h2> <pre data-language=\"go\">func Setsid() (pid int, err error)</pre> <h2 id=\"SetsockoptByte\">func SetsockoptByte  </h2> <pre data-language=\"go\">func SetsockoptByte(fd, level, opt int, value byte) (err error)</pre> <h2 id=\"SetsockoptICMPv6Filter\">func SetsockoptICMPv6Filter  </h2> <pre data-language=\"go\">func SetsockoptICMPv6Filter(fd, level, opt int, filter *ICMPv6Filter) error</pre> <h2 id=\"SetsockoptIPMreq\">func SetsockoptIPMreq  </h2> <pre data-language=\"go\">func SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (err error)</pre> <h2 id=\"SetsockoptIPMreqn\">func SetsockoptIPMreqn  </h2> <pre data-language=\"go\">func SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error)</pre> <h2 id=\"SetsockoptIPv6Mreq\">func SetsockoptIPv6Mreq  </h2> <pre data-language=\"go\">func SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (err error)</pre> <h2 id=\"SetsockoptInet4Addr\">func SetsockoptInet4Addr  </h2> <pre data-language=\"go\">func SetsockoptInet4Addr(fd, level, opt int, value [4]byte) (err error)</pre> <h2 id=\"SetsockoptInt\">func SetsockoptInt  </h2> <pre data-language=\"go\">func SetsockoptInt(fd, level, opt int, value int) (err error)</pre> <h2 id=\"SetsockoptLinger\">func SetsockoptLinger  </h2> <pre data-language=\"go\">func SetsockoptLinger(fd, level, opt int, l *Linger) (err error)</pre> <h2 id=\"SetsockoptString\">func SetsockoptString  </h2> <pre data-language=\"go\">func SetsockoptString(fd, level, opt int, s string) (err error)</pre> <h2 id=\"SetsockoptTimeval\">func SetsockoptTimeval  </h2> <pre data-language=\"go\">func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (err error)</pre> <h2 id=\"Settimeofday\">func Settimeofday  </h2> <pre data-language=\"go\">func Settimeofday(tv *Timeval) (err error)</pre> <h2 id=\"Setuid\">func Setuid  </h2> <pre data-language=\"go\">func Setuid(uid int) (err error)</pre> <h2 id=\"Setxattr\">func Setxattr  </h2> <pre data-language=\"go\">func Setxattr(path string, attr string, data []byte, flags int) (err error)</pre> <h2 id=\"Shutdown\">func Shutdown  </h2> <pre data-language=\"go\">func Shutdown(fd int, how int) (err error)</pre> <h2 id=\"SlicePtrFromStrings\">func SlicePtrFromStrings  </h2> <pre data-language=\"go\">func SlicePtrFromStrings(ss []string) ([]*byte, error)</pre> <p> SlicePtrFromStrings converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte, it returns (nil, EINVAL). </p> <h2 id=\"Socket\">func Socket  </h2> <pre data-language=\"go\">func Socket(domain, typ, proto int) (fd int, err error)</pre> <h2 id=\"Socketpair\">func Socketpair  </h2> <pre data-language=\"go\">func Socketpair(domain, typ, proto int) (fd [2]int, err error)</pre> <h2 id=\"Splice\">func Splice  </h2> <pre data-language=\"go\">func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)</pre> <h2 id=\"StartProcess\">func StartProcess  </h2> <pre data-language=\"go\">func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error)</pre> <p> StartProcess wraps ForkExec for package os. </p> <h2 id=\"Stat\">func Stat  </h2> <pre data-language=\"go\">func Stat(path string, stat *Stat_t) (err error)</pre> <h2 id=\"Statfs\">func Statfs  </h2> <pre data-language=\"go\">func Statfs(path string, buf *Statfs_t) (err error)</pre> <h2 id=\"StringBytePtr\">func StringBytePtr  </h2> <pre data-language=\"go\">func StringBytePtr(s string) *byte</pre> <p> StringBytePtr returns a pointer to a NUL-terminated array of bytes. If s contains a NUL byte this function panics instead of returning an error. </p> <p> Deprecated: Use BytePtrFromString instead. </p> <h2 id=\"StringByteSlice\">func StringByteSlice  </h2> <pre data-language=\"go\">func StringByteSlice(s string) []byte</pre> <p> StringByteSlice converts a string to a NUL-terminated []byte, If s contains a NUL byte this function panics instead of returning an error. </p> <p> Deprecated: Use ByteSliceFromString instead. </p> <h2 id=\"StringSlicePtr\">func StringSlicePtr  </h2> <pre data-language=\"go\">func StringSlicePtr(ss []string) []*byte</pre> <p> StringSlicePtr converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte this function panics instead of returning an error. </p> <p> Deprecated: Use SlicePtrFromStrings instead. </p> <h2 id=\"Symlink\">func Symlink  </h2> <pre data-language=\"go\">func Symlink(oldpath string, newpath string) (err error)</pre> <h2 id=\"Sync\">func Sync  </h2> <pre data-language=\"go\">func Sync()</pre> <h2 id=\"SyncFileRange\">func SyncFileRange  </h2> <pre data-language=\"go\">func SyncFileRange(fd int, off int64, n int64, flags int) (err error)</pre> <h2 id=\"Syscall\">func Syscall  </h2> <pre data-language=\"go\">func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)</pre> <h2 id=\"Syscall6\">func Syscall6  </h2> <pre data-language=\"go\">func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)</pre> <h2 id=\"Sysinfo\">func Sysinfo  </h2> <pre data-language=\"go\">func Sysinfo(info *Sysinfo_t) (err error)</pre> <h2 id=\"Tee\">func Tee  </h2> <pre data-language=\"go\">func Tee(rfd int, wfd int, len int, flags int) (n int64, err error)</pre> <h2 id=\"Tgkill\">func Tgkill  </h2> <pre data-language=\"go\">func Tgkill(tgid int, tid int, sig Signal) (err error)</pre> <h2 id=\"Times\">func Times  </h2> <pre data-language=\"go\">func Times(tms *Tms) (ticks uintptr, err error)</pre> <h2 id=\"TimespecToNsec\">func TimespecToNsec  </h2> <pre data-language=\"go\">func TimespecToNsec(ts Timespec) int64</pre> <h2 id=\"TimevalToNsec\">func TimevalToNsec  </h2> <pre data-language=\"go\">func TimevalToNsec(tv Timeval) int64</pre> <h2 id=\"Truncate\">func Truncate  </h2> <pre data-language=\"go\">func Truncate(path string, length int64) (err error)</pre> <h2 id=\"Umask\">func Umask  </h2> <pre data-language=\"go\">func Umask(mask int) (oldmask int)</pre> <h2 id=\"Uname\">func Uname  </h2> <pre data-language=\"go\">func Uname(buf *Utsname) (err error)</pre> <h2 id=\"UnixCredentials\">func UnixCredentials  </h2> <pre data-language=\"go\">func UnixCredentials(ucred *Ucred) []byte</pre> <p> UnixCredentials encodes credentials into a socket control message for sending to another process. This can be used for authentication. </p> <h2 id=\"UnixRights\">func UnixRights  </h2> <pre data-language=\"go\">func UnixRights(fds ...int) []byte</pre> <p> UnixRights encodes a set of open file descriptors into a socket control message for sending to another process. </p> <h2 id=\"Unlink\">func Unlink  </h2> <pre data-language=\"go\">func Unlink(path string) error</pre> <h2 id=\"Unlinkat\">func Unlinkat  </h2> <pre data-language=\"go\">func Unlinkat(dirfd int, path string) error</pre> <h2 id=\"Unmount\">func Unmount  </h2> <pre data-language=\"go\">func Unmount(target string, flags int) (err error)</pre> <h2 id=\"Unsetenv\">func Unsetenv  </h2> <pre data-language=\"go\">func Unsetenv(key string) error</pre> <h2 id=\"Unshare\">func Unshare  </h2> <pre data-language=\"go\">func Unshare(flags int) (err error)</pre> <h2 id=\"Ustat\">func Ustat  </h2> <pre data-language=\"go\">func Ustat(dev int, ubuf *Ustat_t) (err error)</pre> <h2 id=\"Utime\">func Utime  </h2> <pre data-language=\"go\">func Utime(path string, buf *Utimbuf) (err error)</pre> <h2 id=\"Utimes\">func Utimes  </h2> <pre data-language=\"go\">func Utimes(path string, tv []Timeval) (err error)</pre> <h2 id=\"UtimesNano\">func UtimesNano  </h2> <pre data-language=\"go\">func UtimesNano(path string, ts []Timespec) (err error)</pre> <h2 id=\"Wait4\">func Wait4  </h2> <pre data-language=\"go\">func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error)</pre> <h2 id=\"Write\">func Write  </h2> <pre data-language=\"go\">func Write(fd int, p []byte) (n int, err error)</pre> <h2 id=\"Cmsghdr\">type Cmsghdr  </h2> <pre data-language=\"go\">type Cmsghdr struct {\n        Len          uint64\n        Level        int32\n        Type         int32\n        X__cmsg_data [0]uint8\n}</pre> <h3 id=\"Cmsghdr.SetLen\">func (*Cmsghdr) <a href=\"https://golang.org/src/syscall/syscall_linux_amd64.go?s=4935:4974#L134\">SetLen</a>  </h3> <pre data-language=\"go\">func (cmsg *Cmsghdr) SetLen(length int)</pre> <h2 id=\"Credential\">type Credential  </h2> <pre data-language=\"go\">type Credential struct {\n        Uid    uint32   // User ID.\n        Gid    uint32   // Group ID.\n        Groups []uint32 // Supplementary group IDs.\n}</pre> <p> Credential holds user and group identities to be assumed by a child process started by StartProcess. </p> <h2 id=\"Dirent\">type Dirent  </h2> <pre data-language=\"go\">type Dirent struct {\n        Ino       uint64\n        Off       int64\n        Reclen    uint16\n        Type      uint8\n        Name      [256]int8\n        Pad_cgo_0 [5]byte\n}</pre> <h2 id=\"EpollEvent\">type EpollEvent  </h2> <pre data-language=\"go\">type EpollEvent struct {\n        Events uint32\n        Fd     int32\n        Pad    int32\n}</pre> <h2 id=\"Errno\">type Errno  </h2> <pre data-language=\"go\">type Errno uintptr</pre> <p> An Errno is an unsigned number describing an error condition. It implements the error interface. The zero Errno is by convention a non-error, so code to convert from Errno to error should use: </p> <pre data-language=\"go\">err = nil\nif errno != 0 {\n\terr = errno\n}\n</pre> <h3 id=\"Errno.Error\">func (Errno) <a href=\"https://golang.org/src/syscall/syscall_unix.go?s=2490:2519#L92\">Error</a>  </h3> <pre data-language=\"go\">func (e Errno) Error() string</pre> <h3 id=\"Errno.Temporary\">func (Errno) <a href=\"https://golang.org/src/syscall/syscall_unix.go?s=2650:2681#L102\">Temporary</a>  </h3> <pre data-language=\"go\">func (e Errno) Temporary() bool</pre> <h3 id=\"Errno.Timeout\">func (Errno) <a href=\"https://golang.org/src/syscall/syscall_unix.go?s=2776:2805#L106\">Timeout</a>  </h3> <pre data-language=\"go\">func (e Errno) Timeout() bool</pre> <h2 id=\"FdSet\">type FdSet  </h2> <pre data-language=\"go\">type FdSet struct {\n        Bits [16]int64\n}</pre> <h2 id=\"Flock_t\">type Flock_t  </h2> <pre data-language=\"go\">type Flock_t struct {\n        Type      int16\n        Whence    int16\n        Pad_cgo_0 [4]byte\n        Start     int64\n        Len       int64\n        Pid       int32\n        Pad_cgo_1 [4]byte\n}</pre> <h2 id=\"Fsid\">type Fsid  </h2> <pre data-language=\"go\">type Fsid struct {\n        X__val [2]int32\n}</pre> <h2 id=\"ICMPv6Filter\">type ICMPv6Filter  </h2> <pre data-language=\"go\">type ICMPv6Filter struct {\n        Data [8]uint32\n}</pre> <h3 id=\"GetsockoptICMPv6Filter\">func <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=12606:12676#L501\">GetsockoptICMPv6Filter</a>  </h3> <pre data-language=\"go\">func GetsockoptICMPv6Filter(fd, level, opt int) (*ICMPv6Filter, error)</pre> <h2 id=\"IPMreq\">type IPMreq  </h2> <pre data-language=\"go\">type IPMreq struct {\n        Multiaddr [4]byte /* in_addr */\n        Interface [4]byte /* in_addr */\n}</pre> <h3 id=\"GetsockoptIPMreq\">func <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=11758:11816#L473\">GetsockoptIPMreq</a>  </h3> <pre data-language=\"go\">func GetsockoptIPMreq(fd, level, opt int) (*IPMreq, error)</pre> <h2 id=\"IPMreqn\">type IPMreqn  </h2> <pre data-language=\"go\">type IPMreqn struct {\n        Multiaddr [4]byte /* in_addr */\n        Address   [4]byte /* in_addr */\n        Ifindex   int32\n}</pre> <h3 id=\"GetsockoptIPMreqn\">func <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=11962:12022#L480\">GetsockoptIPMreqn</a>  </h3> <pre data-language=\"go\">func GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error)</pre> <h2 id=\"IPv6MTUInfo\">type IPv6MTUInfo  </h2> <pre data-language=\"go\">type IPv6MTUInfo struct {\n        Addr RawSockaddrInet6\n        Mtu  uint32\n}</pre> <h3 id=\"GetsockoptIPv6MTUInfo\">func <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=12382:12450#L494\">GetsockoptIPv6MTUInfo</a>  </h3> <pre data-language=\"go\">func GetsockoptIPv6MTUInfo(fd, level, opt int) (*IPv6MTUInfo, error)</pre> <h2 id=\"IPv6Mreq\">type IPv6Mreq  </h2> <pre data-language=\"go\">type IPv6Mreq struct {\n        Multiaddr [16]byte /* in6_addr */\n        Interface uint32\n}</pre> <h3 id=\"GetsockoptIPv6Mreq\">func <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=12170:12232#L487\">GetsockoptIPv6Mreq</a>  </h3> <pre data-language=\"go\">func GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error)</pre> <h2 id=\"IfAddrmsg\">type IfAddrmsg  </h2> <pre data-language=\"go\">type IfAddrmsg struct {\n        Family    uint8\n        Prefixlen uint8\n        Flags     uint8\n        Scope     uint8\n        Index     uint32\n}</pre> <h2 id=\"IfInfomsg\">type IfInfomsg  </h2> <pre data-language=\"go\">type IfInfomsg struct {\n        Family     uint8\n        X__ifi_pad uint8\n        Type       uint16\n        Index      int32\n        Flags      uint32\n        Change     uint32\n}</pre> <h2 id=\"Inet4Pktinfo\">type Inet4Pktinfo  </h2> <pre data-language=\"go\">type Inet4Pktinfo struct {\n        Ifindex  int32\n        Spec_dst [4]byte /* in_addr */\n        Addr     [4]byte /* in_addr */\n}</pre> <h2 id=\"Inet6Pktinfo\">type Inet6Pktinfo  </h2> <pre data-language=\"go\">type Inet6Pktinfo struct {\n        Addr    [16]byte /* in6_addr */\n        Ifindex uint32\n}</pre> <h2 id=\"InotifyEvent\">type InotifyEvent  </h2> <pre data-language=\"go\">type InotifyEvent struct {\n        Wd     int32\n        Mask   uint32\n        Cookie uint32\n        Len    uint32\n        Name   [0]uint8\n}</pre> <h2 id=\"Iovec\">type Iovec  </h2> <pre data-language=\"go\">type Iovec struct {\n        Base *byte\n        Len  uint64\n}</pre> <h3 id=\"Iovec.SetLen\">func (*Iovec) <a href=\"https://golang.org/src/syscall/syscall_linux_amd64.go?s=4778:4814#L126\">SetLen</a>  </h3> <pre data-language=\"go\">func (iov *Iovec) SetLen(length int)</pre> <h2 id=\"Linger\">type Linger  </h2> <pre data-language=\"go\">type Linger struct {\n        Onoff  int32\n        Linger int32\n}</pre> <h2 id=\"Msghdr\">type Msghdr  </h2> <pre data-language=\"go\">type Msghdr struct {\n        Name       *byte\n        Namelen    uint32\n        Pad_cgo_0  [4]byte\n        Iov        *Iovec\n        Iovlen     uint64\n        Control    *byte\n        Controllen uint64\n        Flags      int32\n        Pad_cgo_1  [4]byte\n}</pre> <h3 id=\"Msghdr.SetControllen\">func (*Msghdr) <a href=\"https://golang.org/src/syscall/syscall_linux_amd64.go?s=4846:4893#L130\">SetControllen</a>  </h3> <pre data-language=\"go\">func (msghdr *Msghdr) SetControllen(length int)</pre> <h2 id=\"NetlinkMessage\">type NetlinkMessage  </h2> <pre data-language=\"go\">type NetlinkMessage struct {\n        Header NlMsghdr\n        Data   []byte\n}</pre> <p> NetlinkMessage represents a netlink message. </p> <h2 id=\"NetlinkRouteAttr\">type NetlinkRouteAttr  </h2> <pre data-language=\"go\">type NetlinkRouteAttr struct {\n        Attr  RtAttr\n        Value []byte\n}</pre> <p> NetlinkRouteAttr represents a netlink route attribute. </p> <h2 id=\"NetlinkRouteRequest\">type NetlinkRouteRequest  </h2> <pre data-language=\"go\">type NetlinkRouteRequest struct {\n        Header NlMsghdr\n        Data   RtGenmsg\n}</pre> <p> NetlinkRouteRequest represents a request message to receive routing and link states from the kernel. </p> <h2 id=\"NlAttr\">type NlAttr  </h2> <pre data-language=\"go\">type NlAttr struct {\n        Len  uint16\n        Type uint16\n}</pre> <h2 id=\"NlMsgerr\">type NlMsgerr  </h2> <pre data-language=\"go\">type NlMsgerr struct {\n        Error int32\n        Msg   NlMsghdr\n}</pre> <h2 id=\"NlMsghdr\">type NlMsghdr  </h2> <pre data-language=\"go\">type NlMsghdr struct {\n        Len   uint32\n        Type  uint16\n        Flags uint16\n        Seq   uint32\n        Pid   uint32\n}</pre> <h2 id=\"ProcAttr\">type ProcAttr  </h2> <pre data-language=\"go\">type ProcAttr struct {\n        Dir   string    // Current working directory.\n        Env   []string  // Environment.\n        Files []uintptr // File descriptors.\n        Sys   *SysProcAttr\n}</pre> <p> ProcAttr holds attributes that will be applied to a new process started by StartProcess. </p> <h2 id=\"PtraceRegs\">type PtraceRegs  </h2> <pre data-language=\"go\">type PtraceRegs struct {\n        R15      uint64\n        R14      uint64\n        R13      uint64\n        R12      uint64\n        Rbp      uint64\n        Rbx      uint64\n        R11      uint64\n        R10      uint64\n        R9       uint64\n        R8       uint64\n        Rax      uint64\n        Rcx      uint64\n        Rdx      uint64\n        Rsi      uint64\n        Rdi      uint64\n        Orig_rax uint64\n        Rip      uint64\n        Cs       uint64\n        Eflags   uint64\n        Rsp      uint64\n        Ss       uint64\n        Fs_base  uint64\n        Gs_base  uint64\n        Ds       uint64\n        Es       uint64\n        Fs       uint64\n        Gs       uint64\n}</pre> <h3 id=\"PtraceRegs.PC\">func (*PtraceRegs) <a href=\"https://golang.org/src/syscall/syscall_linux_amd64.go?s=4673:4705#L122\">PC</a>  </h3> <pre data-language=\"go\">func (r *PtraceRegs) PC() uint64</pre> <h3 id=\"PtraceRegs.SetPC\">func (*PtraceRegs) <a href=\"https://golang.org/src/syscall/syscall_linux_amd64.go?s=4724:4761#L124\">SetPC</a>  </h3> <pre data-language=\"go\">func (r *PtraceRegs) SetPC(pc uint64)</pre> <h2 id=\"RawSockaddr\">type RawSockaddr  </h2> <pre data-language=\"go\">type RawSockaddr struct {\n        Family uint16\n        Data   [14]int8\n}</pre> <h2 id=\"RawSockaddrAny\">type RawSockaddrAny  </h2> <pre data-language=\"go\">type RawSockaddrAny struct {\n        Addr RawSockaddr\n        Pad  [96]int8\n}</pre> <h2 id=\"RawSockaddrInet4\">type RawSockaddrInet4  </h2> <pre data-language=\"go\">type RawSockaddrInet4 struct {\n        Family uint16\n        Port   uint16\n        Addr   [4]byte /* in_addr */\n        Zero   [8]uint8\n}</pre> <h2 id=\"RawSockaddrInet6\">type RawSockaddrInet6  </h2> <pre data-language=\"go\">type RawSockaddrInet6 struct {\n        Family   uint16\n        Port     uint16\n        Flowinfo uint32\n        Addr     [16]byte /* in6_addr */\n        Scope_id uint32\n}</pre> <h2 id=\"RawSockaddrLinklayer\">type RawSockaddrLinklayer  </h2> <pre data-language=\"go\">type RawSockaddrLinklayer struct {\n        Family   uint16\n        Protocol uint16\n        Ifindex  int32\n        Hatype   uint16\n        Pkttype  uint8\n        Halen    uint8\n        Addr     [8]uint8\n}</pre> <h2 id=\"RawSockaddrNetlink\">type RawSockaddrNetlink  </h2> <pre data-language=\"go\">type RawSockaddrNetlink struct {\n        Family uint16\n        Pad    uint16\n        Pid    uint32\n        Groups uint32\n}</pre> <h2 id=\"RawSockaddrUnix\">type RawSockaddrUnix  </h2> <pre data-language=\"go\">type RawSockaddrUnix struct {\n        Family uint16\n        Path   [108]int8\n}</pre> <h2 id=\"Rlimit\">type Rlimit  </h2> <pre data-language=\"go\">type Rlimit struct {\n        Cur uint64\n        Max uint64\n}</pre> <h2 id=\"RtAttr\">type RtAttr  </h2> <pre data-language=\"go\">type RtAttr struct {\n        Len  uint16\n        Type uint16\n}</pre> <h2 id=\"RtGenmsg\">type RtGenmsg  </h2> <pre data-language=\"go\">type RtGenmsg struct {\n        Family uint8\n}</pre> <h2 id=\"RtMsg\">type RtMsg  </h2> <pre data-language=\"go\">type RtMsg struct {\n        Family   uint8\n        Dst_len  uint8\n        Src_len  uint8\n        Tos      uint8\n        Table    uint8\n        Protocol uint8\n        Scope    uint8\n        Type     uint8\n        Flags    uint32\n}</pre> <h2 id=\"RtNexthop\">type RtNexthop  </h2> <pre data-language=\"go\">type RtNexthop struct {\n        Len     uint16\n        Flags   uint8\n        Hops    uint8\n        Ifindex int32\n}</pre> <h2 id=\"Rusage\">type Rusage  </h2> <pre data-language=\"go\">type Rusage struct {\n        Utime    Timeval\n        Stime    Timeval\n        Maxrss   int64\n        Ixrss    int64\n        Idrss    int64\n        Isrss    int64\n        Minflt   int64\n        Majflt   int64\n        Nswap    int64\n        Inblock  int64\n        Oublock  int64\n        Msgsnd   int64\n        Msgrcv   int64\n        Nsignals int64\n        Nvcsw    int64\n        Nivcsw   int64\n}</pre> <h2 id=\"Signal\">type Signal  </h2> <pre data-language=\"go\">type Signal int</pre> <p> A Signal is a number describing a process signal. It implements the os.Signal interface. </p> <h3 id=\"Signal.Signal\">func (Signal) <a href=\"https://golang.org/src/syscall/syscall_unix.go?s=3403:3427#L138\">Signal</a>  </h3> <pre data-language=\"go\">func (s Signal) Signal()</pre> <h3 id=\"Signal.String\">func (Signal) <a href=\"https://golang.org/src/syscall/syscall_unix.go?s=3432:3463#L140\">String</a>  </h3> <pre data-language=\"go\">func (s Signal) String() string</pre> <h2 id=\"SockFilter\">type SockFilter  </h2> <pre data-language=\"go\">type SockFilter struct {\n        Code uint16\n        Jt   uint8\n        Jf   uint8\n        K    uint32\n}</pre> <h3 id=\"LsfJump\">func <a href=\"https://golang.org/src/syscall/lsf_linux.go?s=418:463#L9\">LsfJump</a>  </h3> <pre data-language=\"go\">func LsfJump(code, k, jt, jf int) *SockFilter</pre> <p> Deprecated: Use golang.org/x/net/bpf instead. </p> <h3 id=\"LsfStmt\">func <a href=\"https://golang.org/src/syscall/lsf_linux.go?s=272:309#L4\">LsfStmt</a>  </h3> <pre data-language=\"go\">func LsfStmt(code, k int) *SockFilter</pre> <p> Deprecated: Use golang.org/x/net/bpf instead. </p> <h2 id=\"SockFprog\">type SockFprog  </h2> <pre data-language=\"go\">type SockFprog struct {\n        Len       uint16\n        Pad_cgo_0 [6]byte\n        Filter    *SockFilter\n}</pre> <h2 id=\"Sockaddr\">type Sockaddr  </h2> <pre data-language=\"go\">type Sockaddr interface {\n        // contains filtered or unexported methods\n}</pre> <h3 id=\"Getpeername\">func <a href=\"https://golang.org/src/syscall/syscall_unix.go?s=4969:5018#L222\">Getpeername</a>  </h3> <pre data-language=\"go\">func Getpeername(fd int) (sa Sockaddr, err error)</pre> <h3 id=\"Getsockname\">func <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=11360:11409#L458\">Getsockname</a>  </h3> <pre data-language=\"go\">func Getsockname(fd int) (sa Sockaddr, err error)</pre> <h2 id=\"SockaddrInet4\">type SockaddrInet4  </h2> <pre data-language=\"go\">type SockaddrInet4 struct {\n        Port int\n        Addr [4]byte\n        // contains filtered or unexported fields\n}</pre> <h2 id=\"SockaddrInet6\">type SockaddrInet6  </h2> <pre data-language=\"go\">type SockaddrInet6 struct {\n        Port   int\n        ZoneId uint32\n        Addr   [16]byte\n        // contains filtered or unexported fields\n}</pre> <h2 id=\"SockaddrLinklayer\">type SockaddrLinklayer  </h2> <pre data-language=\"go\">type SockaddrLinklayer struct {\n        Protocol uint16\n        Ifindex  int\n        Hatype   uint16\n        Pkttype  uint8\n        Halen    uint8\n        Addr     [8]byte\n        // contains filtered or unexported fields\n}</pre> <h2 id=\"SockaddrNetlink\">type SockaddrNetlink  </h2> <pre data-language=\"go\">type SockaddrNetlink struct {\n        Family uint16\n        Pad    uint16\n        Pid    uint32\n        Groups uint32\n        // contains filtered or unexported fields\n}</pre> <h2 id=\"SockaddrUnix\">type SockaddrUnix  </h2> <pre data-language=\"go\">type SockaddrUnix struct {\n        Name string\n        // contains filtered or unexported fields\n}</pre> <h2 id=\"SocketControlMessage\">type SocketControlMessage  </h2> <pre data-language=\"go\">type SocketControlMessage struct {\n        Header Cmsghdr\n        Data   []byte\n}</pre> <p> SocketControlMessage represents a socket control message. </p> <h2 id=\"Stat_t\">type Stat_t  </h2> <pre data-language=\"go\">type Stat_t struct {\n        Dev       uint64\n        Ino       uint64\n        Nlink     uint64\n        Mode      uint32\n        Uid       uint32\n        Gid       uint32\n        X__pad0   int32\n        Rdev      uint64\n        Size      int64\n        Blksize   int64\n        Blocks    int64\n        Atim      Timespec\n        Mtim      Timespec\n        Ctim      Timespec\n        X__unused [3]int64\n}</pre> <h2 id=\"Statfs_t\">type Statfs_t  </h2> <pre data-language=\"go\">type Statfs_t struct {\n        Type    int64\n        Bsize   int64\n        Blocks  uint64\n        Bfree   uint64\n        Bavail  uint64\n        Files   uint64\n        Ffree   uint64\n        Fsid    Fsid\n        Namelen int64\n        Frsize  int64\n        Flags   int64\n        Spare   [4]int64\n}</pre> <h2 id=\"SysProcAttr\">type SysProcAttr  </h2> <pre data-language=\"go\">type SysProcAttr struct {\n        Chroot       string         // Chroot.\n        Credential   *Credential    // Credential.\n        Ptrace       bool           // Enable tracing.\n        Setsid       bool           // Create session.\n        Setpgid      bool           // Set process group ID to Pgid, or, if Pgid == 0, to new pid.\n        Setctty      bool           // Set controlling terminal to fd Ctty (only meaningful if Setsid is set)\n        Noctty       bool           // Detach fd 0 from controlling terminal\n        Ctty         int            // Controlling TTY fd\n        Foreground   bool           // Place child's process group in foreground. (Implies Setpgid. Uses Ctty as fd of controlling TTY)\n        Pgid         int            // Child's process group ID if Setpgid.\n        Pdeathsig    Signal         // Signal that the process will get when its parent dies (Linux only)\n        Cloneflags   uintptr        // Flags for clone calls (Linux only)\n        Unshareflags uintptr        // Flags for unshare calls (Linux only)\n        UidMappings  []SysProcIDMap // User ID mappings for user namespaces.\n        GidMappings  []SysProcIDMap // Group ID mappings for user namespaces.\n        // GidMappingsEnableSetgroups enabling setgroups syscall.\n        // If false, then setgroups syscall will be disabled for the child process.\n        // This parameter is no-op if GidMappings == nil. Otherwise for unprivileged\n        // users this should be set to false for mappings work.\n        GidMappingsEnableSetgroups bool\n}</pre> <h2 id=\"SysProcIDMap\">type SysProcIDMap  </h2> <pre data-language=\"go\">type SysProcIDMap struct {\n        ContainerID int // Container ID.\n        HostID      int // Host ID.\n        Size        int // Size.\n}</pre> <p> SysProcIDMap holds Container ID to Host ID mappings used for User Namespaces in Linux. See user_namespaces(7). </p> <h2 id=\"Sysinfo_t\">type Sysinfo_t  </h2> <pre data-language=\"go\">type Sysinfo_t struct {\n        Uptime    int64\n        Loads     [3]uint64\n        Totalram  uint64\n        Freeram   uint64\n        Sharedram uint64\n        Bufferram uint64\n        Totalswap uint64\n        Freeswap  uint64\n        Procs     uint16\n        Pad       uint16\n        Pad_cgo_0 [4]byte\n        Totalhigh uint64\n        Freehigh  uint64\n        Unit      uint32\n        X_f       [0]byte\n        Pad_cgo_1 [4]byte\n}</pre> <h2 id=\"TCPInfo\">type TCPInfo  </h2> <pre data-language=\"go\">type TCPInfo struct {\n        State          uint8\n        Ca_state       uint8\n        Retransmits    uint8\n        Probes         uint8\n        Backoff        uint8\n        Options        uint8\n        Pad_cgo_0      [2]byte\n        Rto            uint32\n        Ato            uint32\n        Snd_mss        uint32\n        Rcv_mss        uint32\n        Unacked        uint32\n        Sacked         uint32\n        Lost           uint32\n        Retrans        uint32\n        Fackets        uint32\n        Last_data_sent uint32\n        Last_ack_sent  uint32\n        Last_data_recv uint32\n        Last_ack_recv  uint32\n        Pmtu           uint32\n        Rcv_ssthresh   uint32\n        Rtt            uint32\n        Rttvar         uint32\n        Snd_ssthresh   uint32\n        Snd_cwnd       uint32\n        Advmss         uint32\n        Reordering     uint32\n        Rcv_rtt        uint32\n        Rcv_space      uint32\n        Total_retrans  uint32\n}</pre> <h2 id=\"Termios\">type Termios  </h2> <pre data-language=\"go\">type Termios struct {\n        Iflag     uint32\n        Oflag     uint32\n        Cflag     uint32\n        Lflag     uint32\n        Line      uint8\n        Cc        [32]uint8\n        Pad_cgo_0 [3]byte\n        Ispeed    uint32\n        Ospeed    uint32\n}</pre> <h2 id=\"Time_t\">type Time_t  </h2> <pre data-language=\"go\">type Time_t int64</pre> <h3 id=\"Time\">func <a href=\"https://golang.org/src/syscall/syscall_linux_amd64.go?s=3632:3675#L67\">Time</a>  </h3> <pre data-language=\"go\">func Time(t *Time_t) (tt Time_t, err error)</pre> <h2 id=\"Timespec\">type Timespec  </h2> <pre data-language=\"go\">type Timespec struct {\n        Sec  int64\n        Nsec int64\n}</pre> <h3 id=\"NsecToTimespec\">func <a href=\"https://golang.org/src/syscall/syscall_linux_amd64.go?s=3917:3962#L81\">NsecToTimespec</a>  </h3> <pre data-language=\"go\">func NsecToTimespec(nsec int64) (ts Timespec)</pre> <h3 id=\"Timespec.Nano\">func (*Timespec) <a href=\"https://golang.org/src/syscall/syscall.go?s=3117:3149#L78\">Nano</a>  </h3> <pre data-language=\"go\">func (ts *Timespec) Nano() int64</pre> <h3 id=\"Timespec.Unix\">func (*Timespec) <a href=\"https://golang.org/src/syscall/syscall.go?s=2923:2973#L70\">Unix</a>  </h3> <pre data-language=\"go\">func (ts *Timespec) Unix() (sec int64, nsec int64)</pre> <h2 id=\"Timeval\">type Timeval  </h2> <pre data-language=\"go\">type Timeval struct {\n        Sec  int64\n        Usec int64\n}</pre> <h3 id=\"NsecToTimeval\">func <a href=\"https://golang.org/src/syscall/syscall_linux_amd64.go?s=4107:4150#L89\">NsecToTimeval</a>  </h3> <pre data-language=\"go\">func NsecToTimeval(nsec int64) (tv Timeval)</pre> <h3 id=\"Timeval.Nano\">func (*Timeval) <a href=\"https://golang.org/src/syscall/syscall.go?s=3198:3229#L82\">Nano</a>  </h3> <pre data-language=\"go\">func (tv *Timeval) Nano() int64</pre> <h3 id=\"Timeval.Unix\">func (*Timeval) <a href=\"https://golang.org/src/syscall/syscall.go?s=3017:3066#L74\">Unix</a>  </h3> <pre data-language=\"go\">func (tv *Timeval) Unix() (sec int64, nsec int64)</pre> <h2 id=\"Timex\">type Timex  </h2> <pre data-language=\"go\">type Timex struct {\n        Modes     uint32\n        Pad_cgo_0 [4]byte\n        Offset    int64\n        Freq      int64\n        Maxerror  int64\n        Esterror  int64\n        Status    int32\n        Pad_cgo_1 [4]byte\n        Constant  int64\n        Precision int64\n        Tolerance int64\n        Time      Timeval\n        Tick      int64\n        Ppsfreq   int64\n        Jitter    int64\n        Shift     int32\n        Pad_cgo_2 [4]byte\n        Stabil    int64\n        Jitcnt    int64\n        Calcnt    int64\n        Errcnt    int64\n        Stbcnt    int64\n        Tai       int32\n        Pad_cgo_3 [44]byte\n}</pre> <h2 id=\"Tms\">type Tms  </h2> <pre data-language=\"go\">type Tms struct {\n        Utime  int64\n        Stime  int64\n        Cutime int64\n        Cstime int64\n}</pre> <h2 id=\"Ucred\">type Ucred  </h2> <pre data-language=\"go\">type Ucred struct {\n        Pid int32\n        Uid uint32\n        Gid uint32\n}</pre> <h3 id=\"GetsockoptUcred\">func <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=12834:12890#L508\">GetsockoptUcred</a>  </h3> <pre data-language=\"go\">func GetsockoptUcred(fd, level, opt int) (*Ucred, error)</pre> <h3 id=\"ParseUnixCredentials\">func <a href=\"https://golang.org/src/syscall/sockcmsg_linux.go?s=813:879#L17\">ParseUnixCredentials</a>  </h3> <pre data-language=\"go\">func ParseUnixCredentials(m *SocketControlMessage) (*Ucred, error)</pre> <p> ParseUnixCredentials decodes a socket control message that contains credentials in a Ucred structure. To receive such a message, the SO_PASSCRED option must be enabled on the socket. </p> <h2 id=\"Ustat_t\">type Ustat_t  </h2> <pre data-language=\"go\">type Ustat_t struct {\n        Tfree     int32\n        Pad_cgo_0 [4]byte\n        Tinode    uint64\n        Fname     [6]int8\n        Fpack     [6]int8\n        Pad_cgo_1 [4]byte\n}</pre> <h2 id=\"Utimbuf\">type Utimbuf  </h2> <pre data-language=\"go\">type Utimbuf struct {\n        Actime  int64\n        Modtime int64\n}</pre> <h2 id=\"Utsname\">type Utsname  </h2> <pre data-language=\"go\">type Utsname struct {\n        Sysname    [65]int8\n        Nodename   [65]int8\n        Release    [65]int8\n        Version    [65]int8\n        Machine    [65]int8\n        Domainname [65]int8\n}</pre> <h2 id=\"WaitStatus\">type WaitStatus  </h2> <pre data-language=\"go\">type WaitStatus uint32</pre> <h3 id=\"WaitStatus.Continued\">func (WaitStatus) <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=5544:5580#L210\">Continued</a>  </h3> <pre data-language=\"go\">func (w WaitStatus) Continued() bool</pre> <h3 id=\"WaitStatus.CoreDump\">func (WaitStatus) <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=5605:5640#L212\">CoreDump</a>  </h3> <pre data-language=\"go\">func (w WaitStatus) CoreDump() bool</pre> <h3 id=\"WaitStatus.ExitStatus\">func (WaitStatus) <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=5681:5717#L214\">ExitStatus</a>  </h3> <pre data-language=\"go\">func (w WaitStatus) ExitStatus() int</pre> <h3 id=\"WaitStatus.Exited\">func (WaitStatus) <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=5330:5363#L204\">Exited</a>  </h3> <pre data-language=\"go\">func (w WaitStatus) Exited() bool</pre> <h3 id=\"WaitStatus.Signal\">func (WaitStatus) <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=5785:5820#L221\">Signal</a>  </h3> <pre data-language=\"go\">func (w WaitStatus) Signal() Signal</pre> <h3 id=\"WaitStatus.Signaled\">func (WaitStatus) <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=5393:5428#L206\">Signaled</a>  </h3> <pre data-language=\"go\">func (w WaitStatus) Signaled() bool</pre> <h3 id=\"WaitStatus.StopSignal\">func (WaitStatus) <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=5886:5925#L228\">StopSignal</a>  </h3> <pre data-language=\"go\">func (w WaitStatus) StopSignal() Signal</pre> <h3 id=\"WaitStatus.Stopped\">func (WaitStatus) <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=5479:5513#L208\">Stopped</a>  </h3> <pre data-language=\"go\">func (w WaitStatus) Stopped() bool</pre> <h3 id=\"WaitStatus.TrapCause\">func (WaitStatus) <a href=\"https://golang.org/src/syscall/syscall_linux.go?s=5997:6032#L235\">TrapCause</a>  </h3> <pre data-language=\"go\">func (w WaitStatus) TrapCause() int</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>\n    <a href=\"https://golang.org/pkg/syscall/\" class=\"_attribution-link\">https://golang.org/pkg/syscall/</a>\n  </p>\n</div>\n"}