{"index":"<h1>Sinon.JS</h1>\n<h2 id=\"spies\">Test spies </h2>\n<h3>What is a test spy?</h3>\n<p>A test spy is a function that records arguments, return value, the value of <code>this</code> and exception thrown (if any) for all its calls. A test spy can be an anonymous function or it can wrap an existing function.</p>\n<h3>When to use spies?</h3>\n<p>Test spies are useful to test both callbacks and how certain functions/methods are used throughout the system under test. The following simplified example shows how to use spies to test how a function handles a callback:</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should call subscribers on publish\": function () {\n    var callback = sinon.spy();\n    PubSub.subscribe(\"message\", callback);\n\n    PubSub.publishSync(\"message\");\n\n    assertTrue(callback.called);\n}\n</pre>\n<h3>Spying on existing methods</h3>\n<p><code>sinon.spy</code> can also spy on existing functions. When doing so, the original function will behave just as normal (including when used as a constructor) but you will have access to data about all calls. The following is a slightly contrived example:</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">{\n    setUp: function () {\n        sinon.spy(jQuery, \"ajax\");\n    },\n\n    tearDown: function () {\n        jQuery.ajax.restore(); // Unwraps the spy\n    },\n\n    \"test should inspect jQuery.getJSON's usage of jQuery.ajax\": function () {\n        jQuery.getJSON(\"/some/resource\");\n\n        assert(jQuery.ajax.calledOnce);\n        assertEquals(\"/some/resource\", jQuery.ajax.getCall(0).args[0].url);\n        assertEquals(\"json\", jQuery.ajax.getCall(0).args[0].dataType);\n    }\n}\n</pre>\n<h3>Creating spies: sinon.spy()</h3>\n <dl> <dt id=\"sinon-spy\"><code>var spy = sinon.spy();</code></dt> <dd> Creates an anonymous function that records arguments, <code>this</code> value, exceptions and return values for all calls. </dd> <dt><code>var spy = sinon.spy(myFunc);</code></dt> <dd>Spies on the provided function</dd> <dt><code>var spy = sinon.spy(object, \"method\");</code></dt> <dd> Creates a <a href=\"#spyprops\">spy</a> for <code>object.method</code> and replaces the original method with the spy. The spy acts exactly like the original method in all cases. The original method can be restored by calling <code>object.method.restore()</code>. The returned spy is the function object which replaced the original method. <code>spy === object.method</code>. </dd> </dl>\n<h3>Spy API</h3>\n\n<p>Spies provide a rich interface to inspect their usage. The above examples showed the <code>calledOnce</code> boolean property as well as the <code>getCall</code> method and the returned object’s <code>args</code> property. There are three ways of inspecting call data.</p>\n<p>The preferred approach is to use the spy’s <code>calledWith</code> method (and friends) because it keeps your test from being too specific about which call did what and so on. It will return <code>true</code> if the spy was ever called with the provided arguments.</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should call subscribers with message as first argument\" : function () {\n    var message = 'an example message';\n    var spy = sinon.spy();\n\n    PubSub.subscribe(message, spy);\n    PubSub.publishSync(message, \"some payload\");\n\n    assert(spy.calledWith(message));\n}\n</pre>\n<p>If you want to be specific, you can directly check the first argument of the first call. There are two ways of achieving this:</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should call subscribers with message as first argument\" : function () {\n    var message = 'an example message';\n    var spy = sinon.spy();\n\n    PubSub.subscribe(message, spy);\n    PubSub.publishSync(message, \"some payload\");\n\n    assertEquals(message, spy.args[0][0]);\n}\n</pre> <pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should call subscribers with message as first argument\" : function () {\n    var message = 'an example message';\n    var spy = sinon.spy();\n\n    PubSub.subscribe(message, spy);\n    PubSub.publishSync(message, \"some payload\");\n\n    assertEquals(message, spy.getCall(0).args[0]);\n}\n</pre>\n<p>The first example uses the two-dimensional <code>args</code> array directly on the spy, while the second example fetches the first call object and then accesses it’s <code>args</code> array. Which one to use is a matter of preference, but the recommended approach is going with <code>spy.calledWith(arg1, arg2, ...)</code> unless there’s a need to make the tests highly specific.</p>\n<h3>Spy API</h3>\n<p>Spy objects are objects returned from `sinon.spy()`. When spying on existing methods with `sinon.spy(object, method)`, the following properties and methods are also available on `object.method`.</p>\n<dl class=\"dafuq\">\n<dt id=\"spy-withargs\"><code>spy.withArgs(arg1[, arg2, ...]);</code></dt>\n<dd>\n<p>Creates a spy that only records calls when the received arguments match those passed to <code>withArgs</code>. This is useful to be more expressive in your assertions, where you can access the spy with the same call.</p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">\"should call method once with each argument\": function () {\n    var object = { method: function () {} };\n    var spy = sinon.spy(object, \"method\");\n    spy.withArgs(42);\n    spy.withArgs(1);\n\n    object.method(42);\n    object.method(1);\n\n    assert(spy.withArgs(42).calledOnce);\n    assert(spy.withArgs(1).calledOnce);\n}\n</pre>\n</dd>\n<dt id=\"spy-callcount\"><code>spy.callCount</code></dt>\n<dd><p>The number of recorded calls.</p></dd>\n<dt id=\"spy-called\"><code>spy.called</code></dt>\n<dd><p><code>true</code> if the spy was called at least once</p></dd>\n<dt id=\"spy-calledonce\"><code>spy.calledOnce</code></dt>\n<dd><p><code>true</code> if spy was called exactly once</p></dd>\n<dt id=\"spy-calledtwice\"><code>spy.calledTwice</code></dt>\n<dd><p><code>true</code> if the spy was called exactly twice</p></dd>\n<dt id=\"spy-calledthrice\"><code>spy.calledThrice</code></dt>\n<dd><p><code>true</code> if the spy was called exactly thrice</p></dd>\n<dt id=\"spy-firstcall\"><code>spy.firstCall</code></dt>\n<dd><p>The first call</p></dd>\n<dt id=\"spy-secondcall\"><code>spy.secondCall</code></dt>\n<dd><p>The second call</p></dd>\n<dt id=\"spy-thirdcall\"><code>spy.thirdCall</code></dt>\n<dd><p>The third call</p></dd>\n<dt id=\"spy-lastcall\"><code>spy.lastCall</code></dt>\n<dd><p>The last call</p></dd>\n<dt id=\"spy-calledbefore\"><code>spy.calledBefore(anotherSpy);</code></dt>\n<dd><p>Returns <code>true</code> if the spy was called before <code>anotherSpy</code></p></dd>\n<dt id=\"spy-calledafter\"><code>spy.calledAfter(anotherSpy);</code></dt>\n<dd><p>Returns <code>true</code> if the spy was called after <code>anotherSpy</code></p></dd>\n<dt id=\"spy-calledon\"><code>spy.calledOn(obj);</code></dt>\n<dd><p>Returns <code>true</code> if the spy was called at least once with <code>obj</code> as <code>this</code>.</p></dd>\n<dt id=\"spy-alwayscalledon\"><code>spy.alwaysCalledOn(obj);</code></dt>\n<dd><p>Returns <code>true</code> if the spy was always called with <code>obj</code> as <code>this</code>.</p></dd>\n<dt id=\"spy-calledwith\"><code>spy.calledWith(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if spy was called at least once with the provided arguments. Can be used for partial matching, Sinon only checks the provided arguments against actual arguments, so a call that received the provided arguments (in the same spots) and possibly others as well will return <code>true</code>.</p></dd>\n<dt id=\"spy-alwayscalledwith\"><code>spy.alwaysCalledWith(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if spy was always called with the provided arguments (and possibly others).</p></dd>\n<dt id=\"spy-calledwithexactly\"><code>spy.calledWithExactly(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if spy was called at least once with the provided arguments and no others.</p></dd>\n<dt id=\"spy-alwayscalledwithexactly\"><code>spy.alwaysCalledWithExactly(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if spy was always called with the exact provided arguments.</p></dd>\n<dt id=\"spy-calledwithmatch\"><code>spy.calledWithMatch(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if spy was called with matching arguments (and possibly others). This behaves the same as <code>spy.calledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd>\n<dt id=\"spy-alwayscalledwithmatch\"><code>spy.alwaysCalledWithMatch(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if spy was always called with matching arguments (and possibly others). This behaves the same as <code>spy.alwaysCalledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd>\n<dt id=\"spy-calledwithnew\"><code>spy.calledWithNew();</code></dt>\n<dd><p>Returns <code>true</code> if spy/stub was called the <code>new</code> operator. Beware that this is inferred based on the value of the <code>this</code> object and the spy function’s <code>prototype</code>, so it may give false positives if you actively return the right kind of object.</p></dd>\n<dt id=\"spy-nevercalledwith\"><code>spy.neverCalledWith(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if the spy/stub was never called with the provided arguments.</p></dd>\n<dt id=\"spy-nevercalledwithmatch\"><code>spy.neverCalledWithMatch(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if the spy/stub was never called with matching arguments. This behaves the same as <code>spy.neverCalledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd>\n<dt id=\"spy-threw\"><code>spy.threw();</code></dt>\n<dd><p>Returns <code>true</code> if spy threw an exception at least once.</p></dd>\n<dt><code>spy.threw(\"TypeError\");</code></dt>\n<dd><p>Returns <code>true</code> if spy threw an exception of the provided type at least once.</p></dd>\n<dt><code>spy.threw(obj);</code></dt>\n<dd><p>Returns <code>true</code> if spy threw the provided exception object at least once.</p></dd>\n<dt id=\"spy-alwaysthrew\"><code>spy.alwaysThrew();</code></dt>\n<dd><p>Returns <code>true</code> if spy always threw an exception.</p></dd>\n<dt><code>spy.alwaysThrew(\"TypeError\");</code></dt>\n<dd><p>Returns <code>true</code> if spy always threw an exception of the provided type.</p></dd>\n<dt><code>spy.alwaysThrew(obj);</code></dt>\n<dd><p>Returns <code>true</code> if spy always threw the provided exception object.</p></dd>\n<dt id=\"spy-returned\"><code>spy.returned(obj);</code></dt>\n<dd><p>Returns <code>true</code> if spy returned the provided value at least once. Uses deep comparison for objects and arrays. Use <code>spy.returned(sinon.match.same(obj))</code> for strict comparison (see <a href=\"#matchers\">matchers</a>).</p></dd>\n<dt id=\"spy-alwaysreturned\"><code>spy.alwaysReturned(obj);</code></dt>\n<dd><p>Returns <code>true</code> if spy always returned the provided value.</p></dd>\n<dt id=\"spy-getcall\"><code>var spyCall = spy.getCall(n);</code></dt>\n<dd>\n<p> Returns the <em>nth</em> [call](#spycall). Accessing individual calls helps with more detailed behavior verification when the spy is called more than once. Example: </p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">sinon.spy(jQuery, \"ajax\");\njQuery.ajax(\"/stuffs\");\nvar spyCall = jQuery.ajax.getCall(0);\n\nassertEquals(\"/stuffs\", spyCall.args[0]);\n</pre>\n</dd>\n<dt id=\"spy-thisvalues\"><code>spy.thisValues</code></dt>\n<dd><p>Array of <code>this</code> objects, <code>spy.thisValues[0]</code> is the <code>this</code> object for the first call.</p></dd>\n<dt id=\"spy-args\"><code>spy.args</code></dt>\n<dd><p>Array of arguments received, <code>spy.args[0]</code> is an array of arguments received in the first call.</p></dd>\n<dt id=\"spy-exceptions\"><code>spy.exceptions</code></dt>\n<dd><p>Array of exception objects thrown, <code>spy.exceptions[0]</code> is the exception thrown by the first call. If the call did not throw an error, the value at the call’s location in <code>.exceptions</code> will be ‘undefined’.</p></dd>\n<dt id=\"spy-returnvalues\"><code>spy.returnValues</code></dt>\n<dd><p>Array of return values, <code>spy.returnValues[0]</code> is the return value of the first call. If the call did not explicitly return a value, the value at the call’s location in <code>.returnValues</code> will be ‘undefined’.</p></dd>\n<dt id=\"spy-reset\"><code>spy.reset()</code></dt>\n<dd><p>Resets the state of a spy.</p></dd>\n<dt id=\"spy-printf\"><code>spy.printf(format string\", [arg1, arg2, ...])`</code></dt>\n<dd>\n<p>Returns the passed format string with the following replacements performed: </p>\n<ul> <li>\n<code>%n</code>: the name of the spy (“spy” by default)</li> <li>\n<code>%c</code>: the number of times the spy was called, in words (“once”, “twice”, etc.)</li> <li>\n<code>%C</code>: a list of string representations of the calls to the spy, with each call prefixed by a newline and four spaces</li> <li>\n<code>%t</code>: a comma-delimited list of <code>this</code> values the spy was called on</li> <li>\n<code>%&lt;var&gt;n&lt;/var&gt;</code>: the formatted value of the <var>n</var>th argument passed to <code>printf</code>\n</li> <li>\n<code>%*</code>: a comma-delimited list of the (non-format string) arguments passed to <code>printf</code>\n</li> </ul>\n</dd>\n</dl>\n<h3>Individual spy calls</h3>\n\n<dl class=\"dafuq\">\n<dt><code>var spyCall = spy.getCall(n)</code></dt>\n<dd>\n<p> Returns the <em>nth</em> [call](#spycall). Accessing individual calls helps with more detailed behavior verification when the spy is called more than once. Example: </p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">sinon.spy(jQuery, \"ajax\");\njQuery.ajax(\"/stuffs\");\nvar spyCall = jQuery.ajax.getCall(0);\n\nassertEquals(\"/stuffs\", spyCall.args[0]);\n</pre>\n</dd>\n<dt id=\"spycall-calledon\"><code>spyCall.calledOn(obj);</code></dt>\n<dd><p>Returns <code>true</code> if <code>obj</code> was <code>this</code> for this call.</p></dd>\n<dt id=\"spycall-calledwith\"><code>spyCall.calledWith(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if call received provided arguments (and possibly others).</p></dd>\n<dt id=\"spycall-calledwithexactly\"><code>spyCall.calledWithExactly(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if call received provided arguments and no others.</p></dd>\n<dt id=\"spycall-calledwithmatch\"><code>spyCall.calledWithMatch(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if call received matching arguments (and possibly others). This behaves the same as <code>spyCall.calledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd>\n<dt id=\"spycall-notcalledwith\"><code>spyCall.notCalledWith(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if call did not receive provided arguments.</p></dd>\n<dt id=\"spycall-notcalledwithmatch\"><code>spyCall.notCalledWithMatch(arg1, arg2, ...);</code></dt>\n<dd><p>Returns <code>true</code> if call did not receive matching arguments. This behaves the same as <code>spyCall.notCalledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd>\n<dt id=\"spycall-threw\"><code>spyCall.threw();</code></dt>\n<dd><p>Returns <code>true</code> if call threw an exception.</p></dd>\n<dt><code>spyCall.threw(TypeError\");`</code></dt>\n<dd><p>Returns <code>true</code> if call threw exception of provided type.</p></dd>\n<dt><code>spyCall.threw(obj);</code></dt>\n<dd><p>Returns <code>true</code> if call threw provided exception object.</p></dd>\n<dt id=\"spycall-thisvalue\"><code>spyCall.thisValue</code></dt>\n<dd><p>The call’s <code>this</code> value.</p></dd>\n<dt id=\"spycall-args\"><code>spyCall.args</code></dt>\n<dd><p>Array of received arguments.</p></dd>\n<dt id=\"spycall-exception\"><code>spyCall.exception</code></dt>\n<dd><p>Exception thrown, if any.</p></dd>\n<dt id=\"spycall-returnvalue\"><code>spyCall.returnValue</code></dt>\n<dd><p>Return value.</p></dd>\n</dl>\n<h2 id=\"stubs\">Test stubs </h2>\n<h3>What are stubs?</h3>\n<p>Test stubs are functions (spies) with pre-programmed behavior. They support the full <a href=\"#spies\">test spy API</a> in addition to methods which can be used to alter the stub’s behavior.</p>\n<p>As spies, stubs can be either anonymous, or wrap existing functions. When wrapping an existing function with a stub, the original function is not called.</p>\n<h3>When to use stubs?</h3>\n<p>Use a stub when you want to:</p> <ol> <li><p>Control a method’s behavior from a test to force the code down a specific path. Examples include forcing a method to throw an error in order to test error handling.</p></li> <li><p>When you want to prevent a specific method from being called directly (possibly because it triggers undesired behavior, such as a XMLHttpRequest or similar).</p></li> </ol>\n<p>The following example is yet another test from Morgan Roderick’s PubSubJS which shows how to create an anonymous stub that throws an exception when called.</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should call all subscribers, even if there are exceptions\" : function(){\n    var message = 'an example message';\n    var error = 'an example error message';\n    var stub = sinon.stub().throws();\n    var spy1 = sinon.spy();\n    var spy2 = sinon.spy();\n\n    PubSub.subscribe(message, stub);\n    PubSub.subscribe(message, spy1);\n    PubSub.subscribe(message, spy2);\n\n    PubSub.publishSync(message, undefined);\n\n    assert(spy1.called);\n    assert(spy2.called);\n    assert(stub.calledBefore(spy1));\n}\n</pre>\n<p>Note how the stub also implements the spy interface. The test verifies that all callbacks were called, and also that the exception throwing stub was called before one of the other callbacks.</p>\n<h3>Defining stub behavior on consecutive calls</h3>\n<p>Calling behavior defining methods like <code>returns</code> or <code>throws</code> multiple times overrides the behavior of the stub. As of Sinon version 1.8, you can use the <a href=\"http://sinonjs.org/docs/\" stub-oncall=\"stub-oncall\"><code>onCall</code></a> method to make a stub respond differently on consecutive calls.</p>\n<p>Note that in Sinon version 1.5 to version 1.7, multiple calls to the <code>yields*</code> and <code>callsArg*</code> family of methods define a sequence of behaviors for consecutive calls. As of 1.8, this functionality has been removed in favor of the <a href=\"#stub-onCall\"><code>onCall</code></a> API.</p>\n<h3>Stub API</h3>\n\n<dl class=\"dafuq\">\n<dt id=\"sinon-stub\"><code>var stub = sinon.stub();</code></dt>\n<dd><p>Creates an anonymous stub function.</p></dd>\n<dt><code>var stub = sinon.stub(object, \"method\");</code></dt>\n<dd><p>Replaces <code>object.method</code> with a stub function. The original function can be restored by calling <code>object.method.restore();</code> (or <code>stub.restore();</code>). An exception is thrown if the property is not already a function, to help avoid typos when stubbing methods.</p></dd>\n<dt><code>var stub = sinon.stub(object, \"method\", func);</code></dt>\n<dd><p>Replaces <code>object.method</code> with a <code>func</code>, wrapped in a <code>spy</code>. As usual, <code>object.method.restore();</code> can be used to restore the original method.</p></dd>\n<dt><code>var stub = sinon.stub(obj);</code></dt>\n<dd>\n<p>Stubs all the object’s methods. Note that it’s usually better practice to stub individual methods, particularly on objects that you don’t understand or control all the methods for (e.g. library dependencies). Stubbing individual methods tests intent more precisely and is less susceptible to unexpected behavior as the object’s code evolves.<br> If you want to create a stub object of <code>MyConstructor</code>, but don’t want the constructor to be invoked, use this utility function.</p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">var stub = sinon.createStubInstance(MyConstructor)\n</pre>\n</dd>\n<dt id=\"stub-withargs\"><code>stub.withArgs(arg1[, arg2, ...]);</code></dt>\n<dd>\n<p>Stubs the method only for the provided arguments. This is useful to be more expressive in your assertions, where you can access the spy with the same call. It is also useful to create a stub that can act differently in response to different arguments.</p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should stub method differently based on arguments\": function () {\n    var callback = sinon.stub();\n    callback.withArgs(42).returns(1);\n    callback.withArgs(1).throws(\"TypeError\");\n\n    callback(); // No return value, no exception\n    callback(42); // Returns 1\n    callback(1); // Throws TypeError\n}\n</pre>\n</dd>\n<dt id=\"stub-oncall\"><code>stub.onCall(n);</code></dt>\n<dd>\n<p><em>Added in Sinon.JS 1.8</em></p>\n<p>Defines the behavior of the stub on the <em>nth</em> call. Useful for testing sequential interactions.</p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should stub method differently on consecutive calls\": function () {\n    var callback = sinon.stub();\n    callback.onCall(0).returns(1);\n    callback.onCall(1).returns(2);\n    callback.returns(3);\n\n    callback(); // Returns 1\n    callback(); // Returns 2\n    callback(); // All following calls return 3\n}\n</pre>\n<p>There are methods <code>onFirstCall</code>, <code>onSecondCall</code>,<code>onThirdCall</code> to make stub definitions read more naturally.</p> <pre data-language=\"javascript\">                      `onCall` can be combined with all of the behavior defining methods in this section.  In particular, it can be used together with `withArgs`.\n</pre>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should stub method differently on consecutive calls with certain argument\": function () {\n    var callback = sinon.stub();\n    callback.withArgs(42)\n        .onFirstCall().returns(1)\n        .onSecondCall().returns(2);\n    callback.returns(0);\n\n    callback(1); // Returns 0\n    callback(42); // Returns 1\n    callback(1); // Returns 0\n    callback(42); // Returns 2\n    callback(1); // Returns 0\n    callback(42); // Returns 0\n}\n</pre>\n<p>Note how the behavior of the stub for argument <code>42</code> falls back to the default behavior once no more calls have been defined.</p>\n</dd>\n<dt id=\"stub-onfirstcall\"><code>stub.onFirstCall();</code></dt>\n<dd><p>Alias for <code>stub.onCall(0);</code></p></dd>\n<dt id=\"stub-onsecondcall\"><code>stub.onSecondCall();</code></dt>\n<dd><p>Alias for <code>stub.onCall(1);</code></p></dd>\n<dt id=\"stub-onthirdcall\"><code>stub.onThirdCall();</code></dt>\n<dd><p>Alias for <code>stub.onCall(2);</code></p></dd>\n<dt id=\"stub-returns\"><code>stub.returns(obj);</code></dt>\n<dd><p>Makes the stub return the provided value.</p></dd>\n<dt id=\"stub-returnsarg\"><code>stub.returnsArg(index);</code></dt>\n<dd><p>Causes the stub to return the argument at the provided index. <code>stub.returnsArg(0);</code> causes the stub to return the first argument.</p></dd>\n<dt id=\"stub-returnsthis\"><code>stub.returnsThis();</code></dt>\n<dd><p>Causes the stub to return its <code>this</code> value. Useful for stubbing jQuery-style fluent APIs.</p></dd>\n<dt id=\"stub-throws\"><code>stub.throws();</code></dt>\n<dd><p>Causes the stub to throw an exception (<code>Error</code>).</p></dd>\n<dt><code>stub.throws(\"TypeError\");</code></dt>\n<dd><p>Causes the stub to throw an exception of the provided type.</p></dd>\n<dt><code>stub.throws(obj);</code></dt>\n<dd><p>Causes the stub to throw the provided exception object.</p></dd>\n<dt id=\"stub-callsarg\"><code>stub.callsArg(index);</code></dt>\n<dd><p>Causes the stub to call the argument at the provided index as a callback function. <code>stub.callsArg(0);</code> causes the stub to call the first argument as a callback.</p></dd>\n<dt id=\"stub-callsargon\"><code>stub.callsArgOn(index, context);</code></dt>\n<dd><p>Like above but with an additional parameter to pass the <code>this</code> context.</p></dd>\n<dt id=\"stub-callsargwith\"><code>stub.callsArgWith(index, arg1, arg2, ...);</code></dt>\n<dd><p>Like <code>callsArg</code>, but with arguments to pass to the callback.</p></dd>\n<dt id=\"stub-callsargonwith\"><code>stub.callsArgOnWith(index, context, arg1, arg2, ...);</code></dt>\n<dd><p>Like above but with an additional parameter to pass the <code>this</code> context.</p></dd>\n<dt id=\"stub-yields\"><code>stub.yields([arg1, arg2, ...])</code></dt>\n<dd><p>Almost like <code>callsArg</code>. Causes the stub to call the first callback it receives with the provided arguments (if any). If a method accepts more than one callback, you need to use <code>callsArg</code> to have the stub invoke other callbacks than the first one.</p></dd>\n<dt id=\"stub-yieldson\"><code>stub.yieldsOn(context, [arg1, arg2, ...])</code></dt>\n<dd><p>Like above but with an additional parameter to pass the <code>this</code> context.</p></dd>\n<dt id=\"stub-yieldsto\"><code>stub.yieldsTo(property, [arg1, arg2, ...])</code></dt>\n<dd><p>Causes the spy to invoke a callback passed as a property of an object to the spy. Like <code>yields</code>, <code>yieldsTo</code> grabs the first matching argument, finds the callback and calls it with the (optional) arguments.</p></dd>\n<dt id=\"stub-yieldstoon\"><code>stub.yieldsToOn(property, context, [arg1, arg2, ...])</code></dt>\n<dd>\n<p>Like above but with an additional parameter to pass the <code>this</code> context.</p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should fake successful ajax request\": function () {\n    sinon.stub(jQuery, \"ajax\").yieldsTo(\"success\", [1, 2, 3]);\n\n    jQuery.ajax({\n        success: function (data) {\n            assertEquals([1, 2, 3], data);\n        }\n    });\n}\n</pre>\n</dd>\n<dt id=\"stub-yield\"><code>stub.yield([arg1, arg2, ...])</code></dt>\n<dd><p>Invoke callbacks passed to the <code>stub</code> with the given arguments. If the stub was never called with a function argument, <code>yield</code> throws an error. Also aliased as <code>invokeCallback</code>.</p></dd>\n<dt id=\"stub-yieldto\"><code>stub.yieldTo(callback, [arg1, arg2, ...])</code></dt>\n<dd>\n<p>Invokes callbacks passed as a property of an object to the spy. Like <code>yield</code>, <code>yieldTo</code> grabs the first matching argument, finds the callback and calls it with the (optional) arguments.</p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">\"calling callbacks\": function () {\n    var callback = sinon.stub();\n    callback({\n        \"success\": function () {\n            console.log(\"Success!\");\n        },\n        \"failure\": function () {\n            console.log(\"Oh noes!\");\n        }\n    });\n\n    callback.yieldTo(\"failure\"); // Logs \"Oh noes!\"\n}\n</pre>\n</dd>\n<dt id=\"stub-callarg\"><code>stub.callArg(argNum)</code></dt>\n<dd>\n<p>Like <code>yield</code>, but with an explicit argument number specifying which callback to call. Useful if a function is called with more than one callback, and simply calling the first callback is not desired.</p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">\"calling the last callback\": function () {\n    var callback = sinon.stub();\n    callback(function () {\n        console.log(\"Success!\");\n    }, function () {\n        console.log(\"Oh noes!\");\n    });\n\n    callback.callArg(1); // Logs \"Oh noes!\"\n}\n</pre>\n</dd>\n<dt id=\"stub-callargwith\"><code>stub.callArgWith(argNum, [arg1, arg2, ...])</code></dt>\n<dd><pre data-language=\"javascript\">    Like `callArg`, but with arguments.\n</pre></dd>\n<dt id=\"stub-callsargasync\"><code>stub.callsArgAsync(index);</code></dt>\n<dd><p>Same as their corresponding non-Async counterparts, but with callback being deferred (executed not immediately but after short timeout and in another “thread”)</p></dd>\n<dt><code>stub.callsArgAsync(index);</code></dt>\n\n<dt id=\"stub-callsargonasync\"><code>stub.callsArgOnAsync(index, context);</code></dt>\n\n<dt id=\"stub-callsargwithasync\"><code>stub.callsArgWithAsync(index, arg1, arg2, ...);</code></dt>\n\n<dt id=\"stub-callsargonwithasync\"><code>stub.callsArgOnWithAsync(index, context, arg1, arg2, ...);</code></dt>\n\n<dt id=\"stub-yieldsasync\"><code>stub.yieldsAsync([arg1, arg2, ...])</code></dt>\n\n<dt id=\"stub-yieldsonasync\"><code>stub.yieldsOnAsync(context, [arg1, arg2, ...])</code></dt>\n\n<dt id=\"stub-yieldstoasync\"><code>stub.yieldsToAsync(property, [arg1, arg2, ...])</code></dt>\n\n<dt id=\"stub-yieldstoonasync\"><code>stub.yieldsToOnAsync(property, context, [arg1, arg2, ...])</code></dt>\n<dd><p>Same as their corresponding non-Async counterparts, but with callback being deferred (executed not immediately but after short timeout and in another “thread”)</p></dd>\n</dl>\n<h2 id=\"mocks\">Mocks </h2>\n<h3>What are mocks?</h3>\n<p>Mocks (and mock expectations) are fake methods (like spies) with pre-programmed behavior (like stubs) as well as <em>pre-programmed expectations</em>. A mock will fail your test if it is not used as expected.</p>\n<h3>When to use mocks?</h3>\n<p>Mocks should only be used for the <em>method under test</em>. In every unit test, there should be one unit under test. If you want to control how your unit is being used and like stating expectations upfront (as opposed to asserting after the fact), use a mock.</p>\n<h3>When to <strong>not</strong> use mocks?</h3>\n<p>Mocks come with built-in expectations that may fail your test. Thus, they enforce implementation details. The rule of thumb is: if you wouldn’t add an assertion for some specific call, don’t mock it. Use a stub instead. In general you should never have more than <strong>one</strong> mock (possibly with several expectations) in a single test.</p>\n<p><a href=\"#expectations\">Expectations</a> implement both the <a href=\"#spies\">spies</a> and <a href=\"#stubs\">stubs</a> APIs.</p>\n<p>To see how mocks look like in Sinon.JS, here’s one of the PubSubJS tests again, this time using a method as callback and using mocks to verify its behavior:</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should call all subscribers when exceptions\": function () {\n    var myAPI = { method: function () {} };\n\n    var spy = sinon.spy();\n    var mock = sinon.mock(myAPI);\n    mock.expects(\"method\").once().throws();\n\n    PubSub.subscribe(\"message\", myAPI.method);\n    PubSub.subscribe(\"message\", spy);\n    PubSub.publishSync(\"message\", undefined);\n\n    mock.verify();\n    assert(spy.calledOnce);\n}\n</pre>\n<h3>Mocks API</h3>\n\n<dl class=\"dafuq\">\n<dt id=\"sinon-mock\"><code>var mock = sinon.mock(obj);</code></dt>\n<dd><p>Creates a mock for the provided object. Does not change the object, but returns a mock object to set expectations on the object’s methods.</p></dd>\n<dt id=\"mock-expects\"><code>var expectation = mock.expects(\"method\");</code></dt>\n<dd><p>Overrides <code>obj.method</code> with a mock function and returns it. See <a href=\"#expectations-api\">expectations</a> below.</p></dd>\n<dt id=\"mock-restore\"><code>mock.restore();</code></dt>\n<dd><p>Restores all mocked methods.</p></dd>\n<dt id=\"mock-verify\"><code>mock.verify();</code></dt>\n<dd><p>Verifies all expectations on the mock. If any expectation is not satisfied, an exception is thrown. Also restores the mocked methods.</p></dd>\n</dl>\n<h3>Expectations</h3>\n<p>All the expectation methods return the expectation, meaning you can chain them. Typical usage: </p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">sinon.mock(jQuery).expects(\"ajax\").atLeast(2).atMost(5);\njQuery.ajax.verify();\n</pre>\n<dl class=\"dafuq\">\n<dt id=\"sinon-expectation-create\"><code>var expectation = sinon.expectation.create([methodName]);</code></dt>\n<dd><p>Creates an expectation without a mock object, basically an anonymous mock function. Method name is optional and is used in exception messages to make them more readable.</p></dd>\n<dt><code>var expectation = sinon.mock();</code></dt>\n<dd><p>The same as the above.</p></dd>\n<dt id=\"expectation-atleast\"><code>expectation.atLeast(number);</code></dt>\n<dd><p>Specify the minimum amount of calls expected.</p></dd>\n<dt id=\"expectation-atmost\"><code>expectation.atMost(number);</code></dt>\n<dd><p>Specify the maximum amount of calls expected.</p></dd>\n<dt id=\"expectation-never\"><code>expectation.never();</code></dt>\n<dd><p>Expect the method to never be called.</p></dd>\n<dt id=\"expectation-once\"><code>expectation.once();</code></dt>\n<dd><p>Expect the method to be called exactly once.</p></dd>\n<dt id=\"expectation-twice\"><code>expectation.twice();</code></dt>\n<dd><p>Expect the method to be called exactly twice.</p></dd>\n<dt id=\"expectation-thrice\"><code>expectation.thrice();</code></dt>\n<dd><p>Expect the method to be called exactly thrice.</p></dd>\n<dt id=\"expectation-exactly\"><code>expectation.exactly(number);</code></dt>\n<dd><p>Expect the method to be called exactly <code>number</code> times.</p></dd>\n<dt id=\"expectation-withargs\"><code>expectation.withArgs(arg1, arg2, ...);</code></dt>\n<dd><p>Expect the method to be called with the provided arguments and possibly others.</p></dd>\n<dt id=\"expectation-withexactargs\"><code>expectation.withExactArgs(arg1, arg2, ...);</code></dt>\n<dd><p>Expect the method to be called with the provided arguments and no others.</p></dd>\n<dt id=\"expectation-on\"><code>expectation.on(obj);</code></dt>\n<dd><p>Expect the method to be called with <code>obj</code> as <code>this</code>.</p></dd>\n<dt id=\"expectation-verify\"><code>expectation.verify();</code></dt>\n<dd><p>Verifies the expectation and throws an exception if it’s not met.</p></dd>\n</dl>\n<h2 id=\"fake-timers\">Fake timers </h2>\n<p>Fake timers is a synchronous implementation of <code>setTimeout</code> and friends that Sinon.JS can overwrite the global functions with to allow you to more easily test code using them. Fake timers provide a <code>clock</code> object to pass time, which can also be used to control <code>Date</code> objects created through either <code>new Date();</code> or <code>Date.now();</code> (if supported by the browser).</p>\n<p>When faking timers with IE you also need <a href=\"http://sinonjs.org/releases/sinon-ie-1.17.5.js\">sinon-ie-1.17.5</a>, which should be loaded after sinon-1.17.5.js.</p>\n<p>For standalone usage of fake timers it is recommended to use <a href=\"https://github.com/sinonjs/lolex\">lolex</a> package instead. It provides the same set features and was previously extracted from Sinon.JS.</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">{\n    setUp: function () {\n        this.clock = sinon.useFakeTimers();\n    },\n\n    tearDown: function () {\n        this.clock.restore();\n    },\n\n    \"test should animate element over 500ms\" : function(){\n        var el = jQuery(\"&lt;div&gt;&lt;/div&gt;\");\n        el.appendTo(document.body);\n\n        el.animate({ height: \"200px\", width: \"200px\" });\n        this.clock.tick(510);\n\n        assertEquals(\"200px\", el.css(\"height\"));\n        assertEquals(\"200px\", el.css(\"width\"));\n    }\n}\n</pre>\n<h3>Fake timers API</h3>\n\n<dl class=\"dafuq\">\n<dt id=\"sinon-usefaketimers\"><code>var clock = sinon.useFakeTimers();</code></dt>\n<dd><p>Causes Sinon to replace the global <code>setTimeout</code>, <code>clearTimeout</code>, <code>setInterval</code>, <code>clearInterval</code> and <code>Date</code> with a custom implementation which is bound to the returned <code>clock</code> object. Starts the clock at the UNIX epoch (timestamp of 0)</p></dd>\n<dt><code>var clock = sinon.useFakeTimers(now);</code></dt>\n<dd><p>As above, but rather than starting the clock with a timestamp of 0, start at the provided timestamp.</p></dd>\n<dt><code>var clock = sinon.useFakeTimers([now, ]prop1, prop2, ...);</code></dt>\n<dd><p>Sets the clock start timestamp and names functions to fake. Possible functions are setTimeout, clearTimeout, setInterval, clearInterval, and Date. Can also be called without the timestamp.</p></dd>\n<dt id=\"clock-tick\"><code>clock.tick(ms);</code></dt>\n<dd><p>Tick the clock ahead <code>ms</code> milliseconds. Causes all timers scheduled within the affected time range to be called.</p></dd>\n<dt id=\"clock-restore\"><code>clock.restore();</code></dt>\n<dd><p>Restore the faked methods. Call in e.g. <code>tearDown</code>.</p></dd>\n</dl>\n<h2 id=\"fake-xmlhttprequest\">Fake XMLHttpRequest </h2>\n<p>Provides a fake implementation of <code>XMLHttpRequest</code> and provides several interfaces for manipulating objects created by it. Also fakes the native <code>XMLHttpRequest</code> and <code>ActiveXObject</code> (if available, and only for <code>XMLHTTP</code> progids). Helps with testing requests made with XHR.</p>\n<p>When faking XHR with IE you also need <a href=\"http://sinonjs.org/releases/sinon-ie-1.17.5.js\">sinon-ie-1.17.5</a>, which should be loaded after sinon-1.17.5.js.</p>\n<p>The fake server and XHR can be used completely stand-alone by downloading <a href=\"http://sinonjs.org/releases/sinon-server-1.17.5.js\">sinon-server-1.17.5</a>. When using the fake server in IE you also need <a href=\"http://sinonjs.org/releases/sinon-ie-1.17.5.js\">sinon-ie-1.17.5</a>. Load it after the first file.</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">{\n    setUp: function () {\n        this.xhr = sinon.useFakeXMLHttpRequest();\n        var requests = this.requests = [];\n\n        this.xhr.onCreate = function (xhr) {\n            requests.push(xhr);\n        };\n    },\n\n    tearDown: function () {\n        this.xhr.restore();\n    },\n\n    \"test should fetch comments from server\" : function () {\n        var callback = sinon.spy();\n        myLib.getCommentsFor(\"/some/article\", callback);\n        assertEquals(1, this.requests.length);\n\n        this.requests[0].respond(200, { \"Content-Type\": \"application/json\" },\n                                 '[{ \"id\": 12, \"comment\": \"Hey there\" }]');\n        assert(callback.calledWith([{ id: 12, comment: \"Hey there\" }]));\n    }\n}\n</pre>\n<h3>sinon.useFakeXMLHttpRequest</h3>\n\n<dl class=\"dafuq\">\n<dt id=\"sinon-usefakexmlhttprequest\"><code>var xhr = sinon.useFakeXMLHttpRequest();</code></dt>\n<dd><p>Causes Sinon to replace the native <code>XMLHttpRequest</code> object in browsers that support it with a custom implementation which does not send actual requests. In browsers that support <code>ActiveXObject</code>, this constructor is replaced, and fake objects are returned for <code>XMLHTTP</code> progIds. Other progIds, such as <code>XMLDOM</code> are left untouched.<br><br>The native <code>XMLHttpRequest</code> object will be available at <code>sinon.xhr.XMLHttpRequest</code></p></dd>\n<dt><code>xhr.onCreate = function (xhr) {};</code></dt>\n<dd><p>By assigning a function to the <code>onCreate</code> property of the returned object from <code>useFakeXMLHttpRequest()</code> you can subscribe to newly created <code>FakeXMLHttpRequest</code> objects. See below for the fake xhr object API. Using this observer means you can still reach objects created by e.g. <code>jQuery.ajax</code> (or other abstractions/frameworks).</p></dd>\n<dt id=\"xhr-restore\"><code>xhr.restore();</code></dt>\n<dd><p>Restore original function(s).</p></dd>\n</dl>\n<h3>FakeXMLHttpRequest</h3>\n\n<dl class=\"dafuq\">\n<dt id=\"request-url\"><code>String request.url</code></dt>\n<dd><p>The URL set on the request object.</p></dd>\n<dt id=\"request-method\"><code>String request.method</code></dt>\n<dd><p>The request method as a string.</p></dd>\n<dt id=\"request-requestheaders\"><code>Object request.requestHeaders</code></dt>\n<dd>\n<p> An object of all request headers, i.e.: </p> <pre data-language=\"javascript\">{\n    \"Accept\": \"text/html, */*\",\n    \"Connection\": \"keep-alive\"\n}\n</pre>\n</dd>\n<dt id=\"request-requestbody\"><code>String request.requestBody</code></dt>\n<dd><p>The request body</p></dd>\n<dt id=\"request-status\"><code>int request.status</code></dt>\n<dd><p>The request’s status code. Undefined if the request has not been handled (see <a href=\"#respond\"><code>respond</code></a> below).</p></dd>\n<dt id=\"request-statustext\"><code>String request.statusText</code></dt>\n<dd><p>Only populated if the <a href=\"#respond\"><code>respond</code></a> method is called (see below).</p></dd>\n<dt id=\"request-async\"><code>boolean request.async</code></dt>\n<dd><p>Whether or not the request is asynchronous.</p></dd>\n<dt id=\"request-username\"><code>String request.username</code></dt>\n<dd><p>Username, if any.</p></dd>\n<dt id=\"request-password\"><code>String request.password</code></dt>\n<dd><p>Password, if any.</p></dd>\n<dt id=\"request-responsexml\"><code>Document request.responseXML</code></dt>\n<dd><p>When using <a href=\"#respond\"><code>respond</code></a>, this property is populated with a parsed document if response headers indicate as much (see <a href=\"http://www.w3.org/TR/XMLHttpRequest/\">the spec</a>).</p></dd>\n<dt><code>String\n    request.getResponseHeader(header);</code></dt>\n<dd><p>The value of the given response header, if the request has been responded to (see <a href=\"#respond\"><code>respond</code></a>).</p></dd>\n<dt id=\"request-getallresponseheaders\"><code>Object request.getAllResponseHeaders();</code></dt>\n<dd><p>All response headers as an object.</p></dd>\n</dl>\n<h3>Filtered requests</h3>\n<p>When using Sinon.JS for mockups or partial integration/functional testing, you might want to fake some requests, while allowing others to go throught to the backend server. With filtered `FakeXMLHttpRequest`s (new in Sinon 1.3.0), you can.</p>\n<dl class=\"dafuq\">\n<dt id=\"fakexmlhttprequest-usefilters\"><code>FakeXMLHttpRequest.useFilters</code></dt>\n<dd><p>Default <code>false</code>. When set to <code>true</code>, Sinon will check added filters if certain requests should be “unfaked”.</p></dd>\n<dt id=\"fakexmlhttprequest-addfilter\"><code>FakeXMLHttpRequest.addFilter(fn)</code></dt>\n<dd><p>Add a filter that will decide whether or not to fake a request. The filter will be called when <code>xhr.open</code> is called, with the exact same arguments (<code>method</code>, <code>url</code>, <code>async</code>, <code>username</code>, <code>password</code>). If the filter returns true, the request will not be faked.</p></dd>\n</dl>\n<h3>Simulating server responses</h3>\n\n<dl class=\"dafuq\">\n<dt id=\"request-setresponseheaders\"><code>request.setResponseHeaders(object);</code></dt>\n<dd><pre data-language=\"javascript\">Sets response headers (e.g. `{ \"Content-Type\": \"text/html\", /* ... */ }`,\n  updates the `readyState` property and fires `onreadystatechange`.\n</pre></dd>\n<dt id=\"request-setresponsebody\"><code>request.setResponseBody(body);</code></dt>\n<dd><p>Sets the respond body, updates the <code>readyState</code> property and fires <code>onreadystatechange</code>. Additionally, populates <code>responseXML</code> with a parsed document if <a href=\"http://www.w3.org/TR/XMLHttpRequest/\">response headers indicate as much</a>.</p></dd>\n<dt id=\"request-respond\"><code>request.respond(status, headers, body);</code></dt>\n<dd><p>Calls the above two methods and sets the <code>status</code> and <code>statusText</code> properties. Status should be a number, the status text is looked up from <code>sinon.FakeXMLHttpRequest.statusCodes</code>.</p></dd>\n<dt id=\"request-autorespond\"><code>Boolean request.autoRespond</code></dt>\n<dd><p>When set to <code>true</code>, causes the server to automatically respond to incoming requests after a timeout. The default timeout is 10ms but you can control it through the <code>autoRespondAfter</code> property. Note that this feature is intended to help during mockup development, and is not suitable for use in tests.</p></dd>\n<dt id=\"request-autorespondafter\"><code>Number request.autoRespondAfter</code></dt>\n<dd><p>When <code>autoRespond</code> is <code>true</code>, respond to requests after this number of milliseconds. Default is 10.</p></dd>\n</dl>\n<h3>Fake server</h3>\n<p>High-level API to manipulate `FakeXMLHttpRequest` instances. <small>For help with handling JSON-P please refer to our [notes below](#json-p)</small> </p>\n<pre id=\"server_example\" class=\"sh_javascript timers\" data-language=\"javascript\">{\n    setUp: function () {\n        this.server = sinon.fakeServer.create();\n    },\n\n    tearDown: function () {\n        this.server.restore();\n    },\n\n    \"test should fetch comments from server\" : function () {\n        this.server.respondWith(\"GET\", \"/some/article/comments.json\",\n            [200, { \"Content-Type\": \"application/json\" },\n             '[{ \"id\": 12, \"comment\": \"Hey there\" }]']);\n\n        var callback = sinon.spy();\n        myLib.getCommentsFor(\"/some/article\", callback);\n        this.server.respond();\n\n        sinon.assert.calledWith(callback, [{ id: 12, comment: \"Hey there\" }]);\n    }\n}</pre>\n<dl class=\"dafuq\">\n<dt id=\"sinon-fakeserver-create\"><code>var server = sinon.fakeServer.create([config]);</code></dt>\n<dd><p>Creates a new server. This function also calls <code>sinon.useFakeXMLHttpRequest()</code>. <code>create</code> accepts optional properties to configure the fake server. See <a href=\"#options\">options</a> below for configuration parameters.</p></dd>\n<dt id=\"sinon-fakeserverwithclock-create\"><code>var server = sinon.fakeServerWithClock.create();</code></dt>\n<dd><p>Creates a server that also manages fake timers. This is useful when testing XHR objects created with e.g. jQuery 1.3.x, which uses a timer to poll the object for completion, rather than the usual <code>onreadystatechange</code>.</p></dd>\n<dt id=\"server-configure\"><code>server.configure(config)</code></dt>\n<dd><p>Configures the fake server. See <a href=\"#options\">options</a> below for configuration parameters.</p></dd>\n<dt id=\"server-respondwith\"><code>server.respondWith(response);</code></dt>\n<dd>\n<p><code>response</code> can be on of three things:</p> <ol> <li>A string representing the response body</li> <li>An array with status, headers and response body, e.g. <code>[200, { \"Content-Type\": \"text/html\", \"Content-Length\": 2 }, \"OK\"]</code>\n</li> <li>A function.</li> </ol>\n<p>Default status is 200 and default headers are none. Causes the server to respond to any request not matched by another response with the provided data. The default catch-all response is <code>[404, {}, \"\"]</code>.</p>\n<p>When the response is a function, it will be passed the request object. You must manually call <a href=\"#respond\">respond</a> on it to complete the request.</p>\n</dd>\n<dt><code>server.respondWith(url, response);</code></dt>\n<dd><p>Responds to all requests to given URL, e.g. <code>/posts/1</code>.</p></dd>\n<dt><code>server.respondWith(method, url, response);</code></dt>\n<dd><p>Responds to all <code>method</code> requests to the given URL with the given response. <code>method</code> is an HTTP verb.</p></dd>\n<dt><code>server.respondWith(urlRegExp, response);</code></dt>\n<dd>\n<p>URL may be a regular expression, e.g. <code>/\\/post\\//\\d+</code> If the response is a function, it will be passed any capture groups from the regular expression along with the XMLHttpRequest object: </p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">server.respondWith(/\\/todo-items\\/(\\d+)/, function (xhr, id) {  xhr.respond(200, { ?Content-Type?: ?application/json? }, ?[{ ?id?: ? + id + ? }]?); });\n</pre>\n</dd>\n<dt><code>server.respondWith(method, urlRegExp, response);</code></dt>\n<dd><p>Responds to all <code>method</code> requests to URLs matching the regular expression.</p></dd>\n<dt id=\"server-respond\"><code>server.respond();</code></dt>\n<dd><p>Causes all queued asynchronous requests to receive a response. If none of the responses added through <code>respondWith</code> match, the default response is <code>[404, {}, \"\"]</code>. Synchronous requests are responded to immediately, so make sure to call <code>respondWith</code> upfront. If called with arguments, <code>respondWith</code> will be called with those arguments before responding to requests.</p></dd>\n<dt id=\"server-autorespond\"><code>server.autoRespond = true;</code></dt>\n<dd><p>If set, will automatically respond to every request after a timeout. The default timeout is 10ms but you can control it through the <code>autoRespondAfter</code> property. Note that this feature is intended to help during mockup development, and is not suitable for use in tests. For synchronous immediate responses, use <code>respondImmediately</code> instead.</p></dd>\n<dt id=\"server-autorespondafter\"><code>server.autoRespondAfter = ms;</code></dt>\n<dd><p>Causes the server to automatically respond to incoming requests after a timeout.</p></dd>\n<dt id=\"server-respondimmediately\"><code>server.respondImmediately = true;</code></dt>\n<dd><p>If set, the server will respond to every request immediately and synchronously. This is ideal for faking the server from within a test without having to call <code>server.respond()</code> after each request made in that test. As this is synchronous and immediate, this is not suitable for simulating actual network latency in tests or mockups. To simulate network latency with automatic responses, see <code>server.autoRespond</code> and <code>server.autoRespondAfter</code>.</p></dd>\n<dt id=\"server-fakehttpmethods\"><code>Boolean `server.fakeHTTPMethods`</code></dt>\n<dd><p>If set to <code>true</code>, server will find <code>_method</code> parameter in POST body and recognize that as the actual method. Supports a pattern common to Ruby on Rails applications. For custom HTTP method faking, override <code>server.getHTTPMethod(request)</code>.</p></dd>\n<dt id=\"server-gethttpmethod\"><code>server.getHTTPMethod(request)</code></dt>\n<dd><p>Used internally to determine the HTTP method used with the provided request. By default this method simply returns <code>request.method</code>. When <code>server.fakeHTTPMethods</code> is true, the method will return the value of the <code>_method</code> parameter if the method is “POST”. This method can be overrided to provide custom behavior.</p></dd>\n<dt id=\"server-restore\"><code>server.restore();</code></dt>\n<dd><p>Restores the native XHR constructor.</p></dd>\n</dl>\n<h3>Fake server options</h3>\n<p>These options are properties on the server object and can be set directly: </p>\n<pre class=\"sh_javascript\" data-language=\"javascript\">server.autoRespond = true</pre> You can also pass options with an object literal to <code>fakeServer.create</code> and <code>.configure</code>.<dl class=\"dafuq\">\n<dt id=\"autorespond\"><code>boolean autoRespond</code></dt>\n<dd><p>If set, will automatically respond to every request after a timeout. The default timeout is 10ms but you can control it through the <code>autoRespondAfter</code> property. Note that this feature is intended to help during mockup development, and is not suitable for use in tests. For synchronous immediate responses, use <code>respondImmediately</code> instead.</p></dd>\n<dt><code>int autoRespondAfter (ms)</code></dt>\n<dd><p>Causes the server to automatically respond to incoming requests after a timeout.</p></dd>\n<dt id=\"respondimmediately\"><code>boolean respondImmediately</code></dt>\n<dd><p>If set, the server will respond to every request immediately and synchronously. This is ideal for faking the server from within a test without having to call <code>server.respond()</code> after each request made in that test. As this is synchronous and immediate, this is not suitable for simulating actual network latency in tests or mockups. To simulate network latency with automatic responses, see <code>server.autoRespond</code> and <code>server.autoRespondAfter</code>.</p></dd>\n<dt id=\"fakehttpmethods\"><code>boolean fakeHTTPMethods</code></dt>\n<dd><p>If set to <code>true</code>, server will find <code>_method</code> parameter in <code>POST</code> body and recognize that as the actual method. Supports a pattern common to Ruby on Rails applications. For custom HTTP method faking, override <code>server.getHTTPMethod(request)</code>.</p></dd>\n</dl>\n<h2 id=\"json-p\">JSON-P </h2>\n\n<p>JSON-P doesn’t use Ajax requests, which is what the fake server is concerned with. A JSON-P request actually creates a script element and inserts it into the document. There is no sensible/unobtrusive enough way to fake this automatically. Your best option is to simply stub jQuery in this case:</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">sinon.stub(jQuery, \"ajax\");\nsinon.assert.calledOnce(jQuery.ajax);\n</pre>\n<p>Potentially we could have had the fake server detect jQuery and fake any calls to jQuery.ajax when JSON-P is used, but that felt like a compromise in the focus of the Sinon project compared to simply documenting the above work-around.</p>\n<h2 id=\"assertions\">Assertions </h2>\n<p>Sinon.JS ships with a set of assertions that mirror most behavior verification methods and properties on spies and stubs. The advantage of using the assertions is that failed expectations on stubs and spies can be expressed directly as assertion failures with detailed and helpful error messages.</p>\n<p>To make sure assertions integrate nicely with your test framework, you should customize either <code>sinon.assert.fail</code> or <code>sinon.assert.failException</code> and look into <a href=\"#assert-expose\"><code>sinon.assert.expose</code></a> and <a href=\"#assert-pass\"><code>sinon.assert.pass</code></a>.</p>\n<p>The assertions can be used with either spies or stubs.</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should call subscribers with message as first argument\" : function () {\n    var message = \"an example message\";\n    var spy = sinon.spy();\n\n    PubSub.subscribe(message, spy);\n    PubSub.publishSync(message, \"some payload\");\n\n    sinon.assert.calledOnce(spy);\n    sinon.assert.calledWith(spy, message);\n}\n</pre>\n<h3>Assertions API</h3>\n\n<dl class=\"dafuq\">\n<dt id=\"sinon-assert-fail\"><code>sinon.assert.fail(message)</code></dt>\n<dd><p>Every assertion fails by calling this method. By default it throws an error of type <code>sinon.assert.failException</code>. If your testing framework looks for assertion errors by checking for a specific exception, you can simply override the kind of exception thrown. If that does not fit with your testing framework of choice, override the <code>fail</code> method to do the right thing.</p></dd>\n<dt id=\"sinon-assert-failexception\"><code>sinon.assert.failException</code></dt>\n<dd><p>Defaults to <code>\"AssertError\"</code>.</p></dd>\n<dt id=\"sinon-assert-pass\"><code>sinon.assert.pass(assertion)</code></dt>\n<dd><p>Called every time an assertion passes. Default implementation does nothing.</p></dd>\n<dt id=\"sinon-assert-notcalled\"><code>sinon.assert.notCalled(spy)</code></dt>\n<dd><p>Passes if spy was never called.</p></dd>\n<dt id=\"sinon-assert-called\"><code>sinon.assert.called(spy)</code></dt>\n<dd><p>Passes if spy was called at least once.</p></dd>\n<dt id=\"sinon-assert-calledonce\"><code>sinon.assert.calledOnce(spy)</code></dt>\n<dd><p>Passes if spy was called once and only once.</p></dd>\n<dt id=\"sinon-assert-calledtwice\"><code>sinon.assert.calledTwice()</code></dt>\n<dd><p>Passes if spy was called exactly twice.</p></dd>\n<dt id=\"sinon-assert-calledthrice\"><code>sinon.assert.calledThrice()</code></dt>\n<dd><p>Passes if spy was called exactly three times.</p></dd>\n<dt id=\"sinon-assert-callcount\"><code>sinon.assert.callCount(spy, num)</code></dt>\n<dd><p>Passes if the spy was called exactly <code>num</code> times.</p></dd>\n<dt id=\"sinon-assert-callorder\"><code>sinon.assert.callOrder(spy1, spy2, ...)</code></dt>\n<dd><p>Passes if the provided spies where called in the specified order.</p></dd>\n<dt id=\"sinon-assert-calledon\"><code>sinon.assert.calledOn(spy, obj)</code></dt>\n<dd><p>Passes if the spy was ever called with <code>obj</code> as its <code>this</code> value.</p></dd>\n<dt id=\"sinon-assert-alwayscalledon\"><code>sinon.assert.alwaysCalledOn(spy, obj)</code></dt>\n<dd><p>Passes if the spy was always called with <code>obj</code> as its <code>this</code> value.</p></dd>\n<dt id=\"sinon-assert-calledwith\"><code>sinon.assert.calledWith(spy, arg1, arg2, ...)</code></dt>\n<dd><p>Passes if the spy was called with the provided arguments.</p></dd>\n<dt id=\"sinon-assert-alwayscalledwith\"><code>sinon.assert.alwaysCalledWith(spy, arg1, arg2, ...)</code></dt>\n<dd><p>Passes if the spy was always called with the provided arguments.</p></dd>\n<dt id=\"sinon-assert-nevercalledwith\"><code>sinon.assert.neverCalledWith(spy, arg1, arg2, ...)</code></dt>\n<dd><p>Passes if the spy was never called with the provided arguments.</p></dd>\n<dt id=\"sinon-assert-calledwithexactly\"><code>sinon.assert.calledWithExactly(spy, arg1, arg2, ...)</code></dt>\n<dd><p>Passes if the spy was called with the provided arguments and no others.</p></dd>\n<dt id=\"sinon-assert-alwayscalledwithexactly\"><code>sinon.assert.alwaysCalledWithExactly(spy, arg1, arg2, ...)</code></dt>\n<dd><p>Passes if the spy was always called with the provided arguments and no others.</p></dd>\n<dt id=\"sinon-assert-calledwithmatch\"><code>sinon.assert.calledWithMatch(spy, arg1, arg2, ...)</code></dt>\n<dd><p>Passes if the spy was called with matching arguments. This behaves the same as <code>sinon.assert.calledWith(spy, sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd>\n<dt id=\"sinon-assert-alwayscalledwithmatch\"><code>sinon.assert.alwaysCalledWithMatch(spy, arg1, arg2, ...)</code></dt>\n<dd><p>Passes if the spy was always called with matching arguments. This behaves the same as <code>sinon.assert.alwaysCalledWith(spy, sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd>\n<dt id=\"sinon-assert-nevercalledwithmatch\"><code>sinon.assert.neverCalledWithMatch(spy, arg1, arg2, ...)</code></dt>\n<dd><p>Passes if the spy was never called with matching arguments. This behaves the same as <code>sinon.assert.neverCalledWith(spy, sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd>\n<dt id=\"sinon-assert-threw\"><code>sinon.assert.threw(spy, exception)</code></dt>\n<dd><p>Passes if the spy threw the given exception. The exception can be a string denoting its type, or an actual object. If only one argument is provided, the assertion passes if the spy ever threw any exception.</p></dd>\n<dt id=\"sinon-assert-alwaysthrew\"><code>sinon.assert.alwaysThrew(spy, exception)</code></dt>\n<dd><p>Like above, only required for all calls to the spy.</p></dd>\n<dt id=\"sinon-assert-expose\"><code>sinon.assert.expose(object, options)</code></dt>\n<dd>\n<p>Exposes assertions into another object, to better integrate with the test framework. For instance, JsTestDriver uses global assertions, and to make Sinon.JS assertions appear alongside them, you can do.</p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">sinon.assert.expose(this);\n</pre>\n<p>This will give you <code>assertCalled(spy)</code>,<code>assertCallOrder(spy1, spy2, ...)</code> and so on.</p>\n<p>The method accepts an optional options object with two options. <strong>prefix</strong> is a prefix to give assertions. By default it is “assert”, so <code>sinon.assert.called</code> becomes <code>target.assertCalled</code>. By passing a blank string, the exposed method will be <code>target.called</code>. The second option, <strong>includeFail</strong> is true by default, and copies over the <code>fail</code> and <code>failException</code> properties.</p>\n</dd>\n</dl>\n<h2 id=\"matchers\">Matchers </h2>\n<p>Matchers can be passed as arguments to <code>spy.calledWith</code>, <code>spy.returned</code> and the corresponding <code>sinon.assert</code> functions as well as <code>spy.withArgs</code>. Matchers allow to be either more fuzzy or more specific about the expected value.</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should assert fuzzy\": function () {\n    var book = {\n        pages: 42,\n        author: \"cjno\"\n    };\n    var spy = sinon.spy();\n\n    spy(book);\n\n    sinon.assert.calledWith(spy, sinon.match({ author: \"cjno\" }));\n    sinon.assert.calledWith(spy, sinon.match.has(\"pages\", 42));\n}\n</pre> <pre class=\"codehilite javascript\" data-language=\"javascript\">\"test should stub method differently based on argument types\": function () {\n    var callback = sinon.stub();\n    callback.withArgs(sinon.match.string).returns(true);\n    callback.withArgs(sinon.match.number).throws(\"TypeError\");\n\n    callback(\"abc\"); // Returns true\n    callback(123); // Throws TypeError\n}\n</pre>\n<h3>Matchers API</h3>\n\n<dl class=\"dafuq\">\n<dt id=\"sinon-match\"><code>sinon.match(number)</code></dt>\n<dd><p>Requires the value to be == to the given number.</p></dd>\n<dt><code>sinon.match(string)</code></dt>\n<dd><p>Requires the value to be a string and have the expectation as a substring.</p></dd>\n<dt><code>sinon.match(regexp)</code></dt>\n<dd><p>Requires the value to be a string and match the given regular expression.</p></dd>\n<dt><code>sinon.match(object)</code></dt>\n<dd><p>Requires the value to be not null or undefined and have at least the same properties as <code>expectation</code>. This supports nested matchers.</p></dd>\n<dt><code>sinon.match(function)</code></dt>\n<dd><p>See <a href=\"#sinon-match-custom\">custom matchers</a>.</p></dd>\n<dt id=\"sinon-match-any\"><code>sinon.match.any</code></dt>\n<dd><p>Matches anything.</p></dd>\n<dt id=\"sinon-match-defined\"><code>sinon.match.defined</code></dt>\n<dd><p>Requires the value to be defined.</p></dd>\n<dt id=\"sinon-match-truthy\"><code>sinon.match.truthy</code></dt>\n<dd><p>Requires the value to be truthy.</p></dd>\n<dt id=\"sinon-match-falsy\"><code>sinon.match.falsy</code></dt>\n<dd><p>Requires the value to be falsy.</p></dd>\n<dt id=\"sinon-match-bool\"><code>sinon.match.bool</code></dt>\n<dd><p>Requires the value to be a boolean.</p></dd>\n<dt id=\"sinon-match-number\"><code>sinon.match.number</code></dt>\n<dd><p>Requires the value to be a number.</p></dd>\n<dt id=\"sinon-match-string\"><code>sinon.match.string</code></dt>\n<dd><p>Requires the value to be a string.</p></dd>\n<dt id=\"sinon-match-object\"><code>sinon.match.object</code></dt>\n<dd><p>Requires the value to be an object.</p></dd>\n<dt id=\"sinon-match-func\"><code>sinon.match.func</code></dt>\n<dd><p>Requires the value to be a function.</p></dd>\n<dt id=\"sinon-match-array\"><code>sinon.match.array</code></dt>\n<dd><p>Requires the value to be an array.</p></dd>\n<dt id=\"sinon-match-regexp\"><code>sinon.match.regexp</code></dt>\n<dd><p>Requires the value to be a regular expression.</p></dd>\n<dt id=\"sinon-match-date\"><code>sinon.match.date</code></dt>\n<dd><p>Requires the value to be a date object.</p></dd>\n<dt id=\"sinon-match-same\"><code>sinon.match.same(ref)</code></dt>\n<dd><p>Requires the value to strictly equal <code>ref</code>.</p></dd>\n<dt id=\"sinon-match-typeof\"><code>sinon.match.typeOf(type)</code></dt>\n<dd><p>Requires the value to be of the given type, where <code>type</code> can be one of <code>\"undefined\"</code>, <code>\"null\"</code>, <code>\"boolean\"</code>, <code>\"number\"</code>, <code>\"string\"</code>, <code>\"object\"</code>, <code>\"function\"</code>, <code>\"array\"</code>, <code>\"regexp\"</code> or <code>\"date\"</code>.</p></dd>\n<dt id=\"sinon-match-instanceof\"><code>sinon.match.instanceOf(type)</code></dt>\n<dd><p>Requires the value to be an instance of the given type.</p></dd>\n<dt id=\"sinon-match-has\"><code>sinon.match.has(property[, expectation])</code></dt>\n<dd><p>Requires the value to define the given property. The property might be inherited via the prototype chain. If the optional expectation is given, the value of the property is deeply compared with the expectation. The expectation can be another matcher.</p></dd>\n<dt id=\"sinon-match-hasown\"><code>sinon.match.hasOwn(property[, expectation])</code></dt>\n<dd><p>Same as <code>sinon.match.has</code> but the property must be defined by the value itself. Inherited properties are ignored.</p></dd>\n</dl>\n<h3>Combining matchers</h3>\n<p>All matchers implement `and` and `or`. This allows to logically combine mutliple matchers. The result is a new matchers that requires both (and) or one of the matchers (or) to return true. </p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">var stringOrNumber = sinon.match.string.or(sinon.match.number);\n\nvar bookWithPages = sinon.match.instanceOf(Book).and(sinon.match.has(\"pages\"));\n</pre>\n\n<h3>Custom matchers</h3>\n<p>Custom matchers are created with the `sinon.match` factory which takes a test function and an optional message. The test function takes a value as the only argument, returns `true` if the value matches the expectation and `false` otherwise. The message string is used to generate the error message in case the value does not match the expectation. </p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">var trueIsh = sinon.match(function (value) {\n    return !!value;\n}, \"trueIsh\");\n</pre>\n\n<h2 id=\"sandboxes\">Sandboxes </h2>\n<p>Sandboxes simplify working with fakes that need to be restored and/or verified. If you’re using fake timers, fake XHR, or you are stubbing/spying on globally accessible properties you should use a sandbox to ease cleanup. By default the spy, stub and mock properties of the sandbox is bound to whatever object the function is run on, so if you don’t want to manually <code>restore()</code>, you have to use <code>this.spy()</code> instead of <code>sinon.spy()</code> (and stub, mock).</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">\"test using sinon.test sandbox\": sinon.test(function () {\n    var myAPI = { method: function () {} };\n    this.mock(myAPI).expects(\"method\").once();\n\n    PubSub.subscribe(\"message\", myAPI.method);\n    PubSub.publishSync(\"message\", undefined);\n})\n</pre>\n<h3>Sandbox API</h3>\n\n<dl class=\"dafuq\">\n<dt id=\"sinon-sandbox-create\"><code>var sandbox = sinon.sandbox.create();</code></dt>\n<dd><p>Creates a sandbox object</p></dd>\n<dt><code>var sandbox = sinon.sandbox.create(config);</code></dt>\n<dd>\n<p> The `sinon.sandbox.create(config)` method is mostly an integration feature, and as an end-user of Sinon.JS you will probably not need it. </p> <p> Creates a pre-configured sandbox object. The configuration can instruct the sandbox to include fake timers, fake server, and how to interact with these. The default configuration looks like: </p> <pre class=\"codehilite javascript\" data-language=\"javascript\">sinon.defaultConfig = {\n    // ...\n    injectInto: null,\n    properties: [\"spy\", \"stub\", \"mock\", \"clock\", \"server\", \"requests\"],\n    useFakeTimers: true,\n    useFakeServer: true\n}\n</pre> <dl> <dt>injectInto</dt> <dd> The sandbox's methods can be injected into another object for convenience. The `injectInto` configuration option can name an object to add properties to. Usually, this is set by `sinon.test` such that it is the `this` value in a given test function. </dd> <dt>properties</dt> <dd> What properties to inject. Note that simply naming \"server\" here is not sufficient to have a `server` property show up in the target object, you also have to set `useFakeServer` to true. </dd> <dt>useFakeTimers</dt> <dd> If `true`, the sandbox will have a `clock` property. Can also be an array of timer properties to fake. </dd> <dt>useFakeServer</dt> <dd> <p> If `true`, `server` and `requests` properties are added to the sandbox. Can also be an object to use for fake server. The default one is `sinon.fakeServer`, but if you're using jQuery 1.3.x or some other library that does not set the XHR's `onreadystatechange` handler, you might want to do: </p> <pre class=\"codehilite javascript\" data-language=\"javascript\">sinon.config = {\n    useFakeServer: sinon.fakeServerWithClock\n};\n</pre> </dd> </dl>\n</dd>\n<dt id=\"sandbox-spy\"><code>sandbox.spy();</code></dt>\n<dd><p>Works exactly like <code>sinon.spy</code>, only also adds the returned spy to the internal collection of fakes for easy restoring through <code>sandbox.restore()</code>.</p></dd>\n<dt id=\"sandbox-stub\"><code>sandbox.stub();</code></dt>\n<dd><p>Works almost exactly like <code>sinon.stub</code>, only also adds the returned stub to the internal collection of fakes for easy restoring through <code>sandbox.restore()</code>. The sandbox <code>stub</code> method can also be used to stub any kind of property. This is useful if you need to override an object’s property for the duration of a test, and have it restored when the test completes.</p></dd>\n<dt id=\"sandbox-mock\"><code>sandbox.mock();</code></dt>\n<dd><p>Works exactly like <code>sinon.mock</code>, only also adds the returned mock to the internal collection of fakes for easy restoring through <code>sandbox.restore()</code>.</p></dd>\n<dt id=\"sandbox-usefaketimers\"><code>sandbox.useFakeTimers();</code></dt>\n<dd><p>Fakes timers and binds the <code>clock</code> object to the sandbox such that it too is restored when calling <code>sandbox.restore()</code>. Access through <code>sandbox.clock</code>.</p></dd>\n<dt id=\"sandbox-usefakexmlhttprequest\"><code>sandbox.useFakeXMLHttpRequest();</code></dt>\n<dd><p>Fakes XHR and binds the resulting object to the sandbox such that it too is restored when calling <code>sandbox.restore()</code>. Access requests through <code>sandbox.requests</code>.</p></dd>\n<dt id=\"sandbox-usefakeserver\"><code>sandbox.useFakeServer();</code></dt>\n<dd><p>Fakes XHR and binds a server object to the sandbox such that it too is restored when calling <code>sandbox.restore()</code>. Access requests through <code>sandbox.requests</code> and server through <code>sandbox.server</code>.</p></dd>\n<dt id=\"sandbox-restore\"><code>sandbox.restore();</code></dt>\n<dd><p>Restores all fakes created through sandbox.</p></dd>\n</dl>\n<h3>Test methods</h3>\n<p>Wrapping test methods in `sinon.test` allows Sinon.JS to automatically create and manage sandboxes for you. The function's behavior can be configured through `sinon.config`.</p>\n<dl class=\"dafuq\">\n<dt id=\"sinon-test\"><code>var wrappedFn = sinon.test(fn);</code></dt>\n<dd>\n<p>The <code>wrappedFn</code> function works exactly like the original one in all respect - in addition a sandbox object is created and automatically restored when the function finishes a call. By default the spy, stub and mock properties of the sandbox is bound to whatever object the function is run on, so you can do <code>this.spy()</code> (and stub, mock) and it works exactly like <code>sandbox.spy()</code> (and stub, mock), except you don’t need to manually <code>restore()</code>.</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">{\n    injectIntoThis: true,\n    injectInto: null,\n    properties: [\"spy\", \"stub\", \"mock\", \"clock\", \"server\", \"requests\"],\n    useFakeTimers: true,\n    useFakeServer: true\n}\n</pre>\n<p>Simply set <code>sinon.config</code> to override any or all of these, e.g.:</p> <pre class=\"codehilite javascript\" data-language=\"javascript\">sinon.config = {\n    useFakeTimers: false,\n    useFakeServer: false\n}\n</pre>\n<p>In this case, defaults are used for the non-existent properties. Additionally, sandboxes and tests will not have automatic access to the fake timers and fake server when using this configuration.</p>\n</dd>\n</dl>\n<h3>sinon.config</h3>\n<p>The configuration controls how Sinon binds properties when using `sinon.test`. The default configuration looks like:</p>\n<dl class=\"dafuq\">\n<dt id=\"sinon-config-injectintothis\"><code>Boolean injectIntoThis</code></dt>\n<dd><p>Causes properties to be injected into the <code>this</code> object of the test function. Default <code>true</code>.</p></dd>\n<dt id=\"sinon-config-injectinto\"><code>Object injectInto</code></dt>\n<dd><p>Object to bind properties to. If this is <code>null</code> (default) and <code>injectIntoThis</code> is <code>false</code> (not default), the properties are passed as arguments to the test function instead.</p></dd>\n<dt id=\"sinon-config-properties\"><code>Array properties</code></dt>\n<dd><p>Properties to expose. Default is all: <code>[\"spy\", \"stub\", \"mock\", \"clock\", \"server\", \"requests\"]</code>. However, the last three properties are only bound if the following two configuration options are <code>true</code> (which is the default).</p></dd>\n<dt id=\"sinon-config-usefaketimers\"><code>Boolean useFakeTimers</code></dt>\n<dd><p>Causes timers to be faked and allows <code>clock</code> property to be exposed. Default is <code>true</code>.</p></dd>\n<dt id=\"sinon-config-usefakeserver\"><code>Boolean useFakeServer</code></dt>\n<dd><p>Causes fake XHR and server to be created and allows <code>server</code> and <code>requests</code> properties to be exposed. Default is <code>true</code>.</p></dd>\n</dl>\n<h3>Test cases</h3>\n<p>If you need the behavior of `sinon.test` for more than one test method in a test case, you can use `sinon.testCase`, which behaves exactly like wrapping each test in `sinon.test` with one exception: `setUp` and `tearDown` can share fakes.</p>\n<dl class=\"dafuq\">\n<dt id=\"sinon-config-sinon-testcase\"><code>var obj = sinon.testCase({});</code></dt>\n\n</dl>\n<h2 id=\"utilities\">Sinon.JS utilities </h2>\n<p>Sinon.JS has a few utilities used internally in lib/sinon.js. Unless the method in question is documented here, it should not be considered part of the public API, and thus is subject to change.</p>\n<h3>Utils API</h3>\n\n<dl class=\"dafuq\">\n<dt id=\"sinon-createstubinstance\"><code>sinon.createStubInstance(constructor)</code></dt>\n<dd><p>Creates a new object with the given function as the protoype and stubs all implemented functions. The given constructor function is not invoked. See also the <a href=\"#stubs\">stub API</a>.</p></dd>\n<dt id=\"sinon-format\"><code>sinon.format(object)</code></dt>\n<dd><p>Formats an object for pretty printing in error messages. Sinon &lt; 1.3.0 defaulted to coercing objects to strings. As of 1.3.0, Sinon uses <a href=\"https://busterjs.org/docs/buster-format/\">buster-format</a> by default, or Node’s <a href=\"http://nodejs.org/docs/v0.6.6/api/util.html\">util</a> module. Feel free to override this method with your own implementation if you prefer different visualization of e.g. objects. The method should return a string.</p></dd>\n<dt id=\"sinon-log\"><code>sinon.log(string)</code></dt>\n<dd>\n<p>Logs internal errors, helpful for debugging. By default this property is a noop function, set it to something that prints warnings in your environment for more help, e.g. (if you are using JsTestDriver): </p>\n<pre class=\"codehilite javascript\" data-language=\"javascript\">sinon.log = function (message) {  jstestdriver.console.log(message); };\n</pre>\n</dd>\n</dl>\n<div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2010&ndash;2016 Christian Johansen<br>Licensed under the BSD License.<br>\n    <a href=\"http://sinonjs.org/docs/\" class=\"_attribution-link\">http://sinonjs.org/docs/</a>\n  </p>\n</div>\n"}