{"index":"<h1>Knockout.js</h1> <p>Knockout is a JavaScript library that helps you to create rich, responsive display and editor user interfaces with a clean underlying data model. Any time you have sections of UI that update dynamically (e.g., changing depending on the user’s actions or when an external data source changes), KO can help you implement it more simply and maintainably.</p> <p>Headline features:</p> <ul> <li>\n<strong>Elegant dependency tracking</strong> - automatically updates the right parts of your UI whenever your data model changes.</li> <li>\n<strong>Declarative bindings</strong> - a simple and obvious way to connect parts of your UI to your data model. You can construct a complex dynamic UIs easily using arbitrarily nested binding contexts.</li> <li>\n<strong>Trivially extensible</strong> - implement custom behaviors as new declarative bindings for easy reuse in just a few lines of code.</li> </ul> <p>Additional benefits:</p> <ul> <li>\n<strong>Pure JavaScript library</strong> - works with any server or client-side technology</li> <li>\n<strong>Can be added on top of your existing web application</strong> without requiring major architectural changes</li> <li>\n<strong>Compact</strong> - around 13kb after gzipping</li> <li>\n<strong>Works on any mainstream browser</strong> (IE 6+, Firefox 2+, Chrome, Safari, Edge, others)</li> <li>\n<strong>Comprehensive suite of specifications</strong> (developed BDD-style) means its correct functioning can easily be verified on new browsers and platforms</li> </ul> <p>Developers familiar with Ruby on Rails, ASP.NET MVC, or other MV* technologies may see MVVM as a real-time form of MVC with declarative syntax. In another sense, you can think of KO as a general way to make UIs for editing JSON data… whatever works for you :)</p> <h2 id=\"ok-how-do-you-use-it\">OK, how do you use it?</h2> <p>The quickest and most fun way to get started is by working through the <a href=\"http://learn.knockoutjs.com\">interactive tutorials</a>. Once you’ve got to grips with the basics, explore the <a href=\"http://knockoutjs.com/examples/index.html\">live examples</a> and then have a go with it in your own project.</p> <h2 id=\"is-ko-intended-to-compete-with-jquery-or-prototype-etc-or-work-with-it\">Is KO intended to compete with jQuery (or Prototype, etc.) or work with it?</h2> <p>Everyone loves jQuery! It’s an outstanding replacement for the clunky, inconsistent DOM API we had to put up with in the past. jQuery is an excellent low-level way to manipulate elements and event handlers in a web page. KO solves a different problem.</p> <p>As soon as your UI gets nontrivial and has a few overlapping behaviors, things can get tricky and expensive to maintain if you only use jQuery. Consider an example: you’re displaying a list of items, stating the number of items in that list, and want to enable an ‘Add’ button only when there are fewer than 5 items. jQuery doesn’t have a concept of an underlying data model, so to get the number of items you have to infer it from the number of TRs in a table or the number of DIVs with a certain CSS class. Maybe the number of items is displayed in some SPAN, and you have to remember to update that SPAN’s text when the user adds an item. You also must remember to disable the ‘Add’ button when the number of TRs is 5. Later, you’re asked also to implement a ‘Delete’ button and you have to figure out which DOM elements to change whenever it’s clicked.</p> <h3 id=\"how-is-knockout-different\">How is Knockout different?</h3> <p>It’s much easier with KO. It lets you scale up in complexity without fear of introducing inconsistencies. Just represent your items as a JavaScript array, and then use a <code>foreach</code> binding to transform this array into a TABLE or set of DIVs. Whenever the array changes, the UI changes to match (you don’t have to figure out how to inject new TRs or where to inject them). The rest of the UI stays in sync. For example, you can declaratively bind a SPAN to display the number of items as follows:</p> <pre>There are &lt;span data-bind=\"text: myItems().length\"&gt;&lt;/span&gt; items\n</pre> <p>That’s it! You don’t have to write code to update it; it updates on its own when the <code>myItems</code> array changes. Similarly, to make the ‘Add’ button enable or disable depending on the number of items, just write:</p> <pre>&lt;button data-bind=\"enable: myItems().length &lt; 5\"&gt;Add&lt;/button&gt;\n</pre> <p>Later, when you’re asked to implement the ‘Delete’ functionality, you don’t have to figure out what bits of the UI it has to interact with; you just make it alter the underlying data model.</p> <p>To summarise: KO doesn’t compete with jQuery or similar low-level DOM APIs. KO provides a complementary, high-level way to link a data model to a UI. KO itself doesn’t depend on jQuery, but you can certainly use jQuery at the same time, and indeed that’s often useful if you want things like animated transitions.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/introduction.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/introduction.html</a>\n  </p>\n</div>\n","observables":"<h1>Observables</h1> <p>Knockout is built around three core features:</p> <ol> <li>Observables and dependency tracking</li> <li>Declarative bindings</li> <li>Templating</li> </ol> <p>On this page, you’ll learn about the first of these three. But before that, let’s examine the MVVM pattern and the concept of a <em>view model</em>.</p> <h2 id=\"mvvm-and-view-models\">MVVM and View Models</h2> <p><em>Model-View-View Model (MVVM)</em> is a design pattern for building user interfaces. It describes how you can keep a potentially sophisticated UI simple by splitting it into three parts:</p> <ul> <li> <p>A <em>model</em>: your application’s stored data. This data represents objects and operations in your business domain (e.g., bank accounts that can perform money transfers) and is independent of any UI. When using KO, you will usually make Ajax calls to some server-side code to read and write this stored model data.</p> </li> <li> <p>A <em>view model</em>: a pure-code representation of the data and operations on a UI. For example, if you’re implementing a list editor, your view model would be an object holding a list of items, and exposing methods to add and remove items.</p> <p>Note that this is not the UI itself: it doesn’t have any concept of buttons or display styles. It’s not the persisted data model either - it holds the unsaved data the user is working with. When using KO, your view models are pure JavaScript objects that hold no knowledge of HTML. Keeping the view model abstract in this way lets it stay simple, so you can manage more sophisticated behaviors without getting lost.</p> </li> <li> <p>A <em>view</em>: a visible, interactive UI representing the state of the view model. It displays information from the view model, sends commands to the view model (e.g., when the user clicks buttons), and updates whenever the state of the view model changes.</p> <p>When using KO, your view is simply your HTML document with declarative bindings to link it to the view model. Alternatively, you can use templates that generate HTML using data from your view model.</p> </li> </ul> <p>To create a view model with KO, just declare any JavaScript object. For example,</p> <pre>var myViewModel = {\n    personName: 'Bob',\n    personAge: 123\n};\n</pre> <p>You can then create a very simple <em>view</em> of this view model using a declarative binding. For example, the following markup displays the <code>personName</code> value:</p> <pre>The name is &lt;span data-bind=\"text: personName\"&gt;&lt;/span&gt;\n</pre> <h2 id=\"activating-knockout\">Activating Knockout</h2> <p>The <code>data-bind</code> attribute isn’t native to HTML, though it is perfectly OK (it’s strictly compliant in HTML 5, and causes no problems with HTML 4 even though a validator will point out that it’s an unrecognized attribute). But since the browser doesn’t know what it means, you need to activate Knockout to make it take effect.</p> <p>To activate Knockout, add the following line to a <code>&lt;script&gt;</code> block:</p> <pre>ko.applyBindings(myViewModel);\n</pre> <p>You can either put the script block at the bottom of your HTML document, or you can put it at the top and wrap the contents in a DOM-ready handler such as <a href=\"http://api.jquery.com/jQuery/#jQuery3\">jQuery’s <code>$</code> function</a>.</p> <p>That does it! Now, your view will display as if you’d written the following HTML:</p> <pre>The name is &lt;span&gt;Bob&lt;/span&gt;\n</pre> <p>In case you’re wondering what the parameters to <code>ko.applyBindings</code> do,</p> <ul> <li> <p>The first parameter says what view model object you want to use with the declarative bindings it activates</p> </li> <li> <p>Optionally, you can pass a second parameter to define which part of the document you want to search for <code>data-bind</code> attributes. For example, <code>ko.applyBindings(myViewModel, document.getElementById('someElementId'))</code>. This restricts the activation to the element with ID <code>someElementId</code> and its descendants, which is useful if you want to have multiple view models and associate each with a different region of the page.</p> </li> </ul> <p>Pretty simple, really.</p> <h2 id=\"observables\">Observables</h2> <p>OK, you’ve seen how to create a basic view model and how to display one of its properties using a binding. But one of the key benefits of KO is that it updates your UI automatically when the view model changes. How can KO know when parts of your view model change? Answer: you need to declare your model properties as <em>observables</em>, because these are special JavaScript objects that can notify subscribers about changes, and can automatically detect dependencies.</p> <p>For example, rewrite the preceding view model object as follows:</p> <pre>var myViewModel = {\n    personName: ko.observable('Bob'),\n    personAge: ko.observable(123)\n};\n</pre> <p>You don’t have to change the view at all - the same <code>data-bind</code> syntax will keep working. The difference is that it’s now capable of detecting changes, and when it does, it will update the view automatically.</p> <h2 id=\"reading-and-writing-observables\">Reading and writing observables</h2> <p>Not all browsers support JavaScript getters and setters (* cough * IE * cough *), so for compatibility, <code>ko.observable</code> objects are actually <em>functions</em>.</p> <ul> <li> <p>To <strong>read</strong> the observable’s current value, just call the observable with no parameters. In this example, <code>myViewModel.personName()</code> will return <code>'Bob'</code>, and <code>myViewModel.personAge()</code> will return <code>123</code>.</p> </li> <li> <p>To <strong>write</strong> a new value to the observable, call the observable and pass the new value as a parameter. For example, calling <code>myViewModel.personName('Mary')</code> will change the name value to <code>'Mary'</code>.</p> </li> <li> <p>To write values to <strong>multiple observable properties</strong> on a model object, you can use <em>chaining syntax</em>. For example, <code>myViewModel.personName('Mary').personAge(50)</code> will change the name value to <code>'Mary'</code> <em>and</em> the age value to <code>50</code>.</p> </li> </ul> <p>The whole point of observables is that they can be observed, i.e., other code can say that it wants to be notified of changes. That’s what many of KO’s built-in bindings do internally. So, when you wrote <code>data-bind=\"text: personName\"</code>, the <code>text</code> binding registered itself to be notified when <code>personName</code> changes (assuming it’s an observable value, which it is now).</p> <p>When you change the name value to <code>'Mary'</code> by calling <code>myViewModel.personName('Mary')</code>, the <code>text</code> binding will automatically update the text contents of the associated DOM element. That’s how changes to the view model automatically propagate to the view.</p> <h2 id=\"explicitly-subscribing-to-observables\">Explicitly subscribing to observables</h2> <p><em>You won’t normally need to set up subscriptions manually, so beginners should skip this section.</em></p> <p>For advanced users, if you want to register your own subscriptions to be notified of changes to observables, you can call their <code>subscribe</code> function. For example:</p> <pre>myViewModel.personName.subscribe(function(newValue) {\n    alert(\"The person's new name is \" + newValue);\n});\n</pre> <p>The <code>subscribe</code> function is how many parts of KO work internally. Most of the time you don’t need to use this, because the built-in bindings and templating system take care of managing subscriptions.</p> <p>The <code>subscribe</code> function accepts three parameters: <code>callback</code> is the function that is called whenever the notification happens, <code>target</code> (optional) defines the value of <code>this</code> in the callback function, and <code>event</code> (optional; default is <code>\"change\"</code>) is the name of the event to receive notification for.</p> <p>You can also terminate a subscription if you wish: first capture the return value as a variable, then you can call its <code>dispose</code> function, e.g.:</p> <pre>var subscription = myViewModel.personName.subscribe(function(newValue) { /* do stuff */ });\n// ...then later...\nsubscription.dispose(); // I no longer want notifications\n</pre> <p>If you want to be notified of the value of an observable before it is about to be changed, you can subscribe to the <code>beforeChange</code> event. For example:</p> <pre>myViewModel.personName.subscribe(function(oldValue) {\n    alert(\"The person's previous name is \" + oldValue);\n}, null, \"beforeChange\");\n</pre> <p>Note: Knockout does not guarantee that the <code>beforeChange</code> and <code>change</code> events will occur in pairs, since other parts of your code might raise either event individually. If you need to track the previous value of an observable, it’s up to you to use a subscription to capture and track it.</p> <h2 id=\"forcing-observables-to-always-notify-subscribers\">Forcing observables to always notify subscribers</h2> <p>When writing to an observable that contains a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in <code>notify</code> <a href=\"extenders\">extender</a> to ensure that an observable’s subscribers are always notified on a write, even if the value is the same. You would apply the extender to an observable like this:</p> <pre>myViewModel.personName.extend({ notify: 'always' });\n</pre> <h2 id=\"delaying-andor-suppressing-change-notifications\">Delaying and/or suppressing change notifications</h2> <p>Normally, an observable notifies its subscribers immediately, as soon as it’s changed. But if an observable is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying the observable’s change notifications. This is accomplished using the <a href=\"ratelimit-observable\"><code>rateLimit</code> extender</a> like this:</p> <pre>// Ensure it notifies about changes no more than once per 50-millisecond period\nmyViewModel.personName.extend({ rateLimit: 50 });\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/observables.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/observables.html</a>\n  </p>\n</div>\n","ifnot-binding":"<h1>The \"ifnot\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>ifnot</code> binding is exactly the same as <a href=\"if-binding\">the <code>if</code> binding</a>, except that it inverts the result of whatever expression you pass to it. For more details, see documentation for <a href=\"if-binding\">the <code>if</code> binding</a>.</p> <h3 id=\"note-ifnot-is-the-same-as-a-negated-if\">Note: “ifnot” is the same as a negated “if”</h3> <p>The following markup:</p> <pre>&lt;div data-bind=\"ifnot: someProperty\"&gt;...&lt;/div&gt;\n</pre> <p>… is equivalent to the following:</p> <pre>&lt;div data-bind=\"if: !someProperty()\"&gt;...&lt;/div&gt;\n</pre> <p>… assuming that <code>someProperty</code> is <em>observable</em> and hence you need to invoke it as a function to obtain the current value.</p> <p>The only reason to use <code>ifnot</code> instead of a negated <code>if</code> is just as a matter of taste: many developers feel that it looks tidier.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/ifnot-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/ifnot-binding.html</a>\n  </p>\n</div>\n","visible-binding":"<h1>The \"visible\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>visible</code> binding causes the associated DOM element to become hidden or visible according to the value you pass to the binding.</p> <h3 id=\"example\">Example</h3> <pre>&lt;div data-bind=\"visible: shouldShowMessage\"&gt;\n    You will see this message only when \"shouldShowMessage\" holds a true value.\n&lt;/div&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n\t\tshouldShowMessage: ko.observable(true) // Message initially visible\n    };\n    viewModel.shouldShowMessage(false); // ... now it's hidden\n    viewModel.shouldShowMessage(true); // ... now it's visible again\n&lt;/script&gt;\n</pre> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <ul> <li> <p>When the parameter resolves to a <strong>false-like value</strong> (e.g., the boolean value <code>false</code>, or the numeric value <code>0</code>, or <code>null</code>, or <code>undefined</code>), the binding sets <code>yourElement.style.display</code> to <code>none</code>, causing it to be hidden. This takes priority over any display style you’ve defined using CSS.</p> </li> <li> <p>When the parameter resolves to a <strong>true-like value</strong> (e.g., the boolean value <code>true</code>, or a non-<code>null</code> object or array), the binding removes the <code>yourElement.style.display</code> value, causing it to become visible.</p> <p>Note that any display style you’ve configured using your CSS rules will then apply (so CSS rules like <code>x { display:table-row }</code> work fine in conjunction with this binding).</p> </li> </ul> <p>If this parameter is an observable value, the binding will update the element’s visibility whenever the value changes. If the parameter isn’t observable, it will only set the element’s visibility once and will not update it again later.</p> </li> <li> <p>Additional parameters</p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-using-functions-and-expressions-to-control-element-visibility\">Note: Using functions and expressions to control element visibility</h3> <p>You can also use a JavaScript function or arbitrary JavaScript expression as the parameter value. If you do, KO will run your function/evaluate your expression, and use the result to determine whether to hide the element.</p> <p>For example,</p> <pre>&lt;div data-bind=\"visible: myValues().length &gt; 0\"&gt;\n    You will see this message only when 'myValues' has at least one member.\n&lt;/div&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n\t\tmyValues: ko.observableArray([]) // Initially empty, so message hidden\n    };\n    viewModel.myValues.push(\"some value\"); // Now visible\n&lt;/script&gt;\n</pre> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/visible-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/visible-binding.html</a>\n  </p>\n</div>\n","with-binding":"<h1>The \"with\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>with</code> binding creates a new <a href=\"binding-context\">binding context</a>, so that descendant elements are bound in the context of a specified object.</p> <p>Of course, you can arbitrarily nest <code>with</code> bindings along with the other control-flow bindings such as <a href=\"if-binding\"><code>if</code></a> and <a href=\"foreach-binding\"><code>foreach</code></a>.</p> <h3 id=\"example-1\">Example 1</h3> <p>Here is a very basic example of switching the binding context to a child object. Notice that in the <code>data-bind</code> attributes, it is <em>not</em> necessary to prefix <code>latitude</code> or <code>longitude</code> with <code>coords.</code>, because the binding context is switched to <code>coords</code>.</p> <pre>&lt;h1 data-bind=\"text: city\"&gt; &lt;/h1&gt;\n&lt;p data-bind=\"with: coords\"&gt;\n    Latitude: &lt;span data-bind=\"text: latitude\"&gt; &lt;/span&gt;,\n    Longitude: &lt;span data-bind=\"text: longitude\"&gt; &lt;/span&gt;\n&lt;/p&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    ko.applyBindings({\n        city: \"London\",\n        coords: {\n            latitude:  51.5001524,\n            longitude: -0.1262362\n        }\n    });\n&lt;/script&gt;\n</pre> <h3 id=\"example-2\">Example 2</h3> <p>This interactive example demonstrates that:</p> <ul> <li>The <code>with</code> binding will dynamically add or remove descendant elements depending on whether the associated value is <code>null</code>/<code>undefined</code> or not</li> <li>If you want to access data/functions from parent binding contexts, you can use <a href=\"binding-context\">special context properties such as <code>$parent</code> and <code>$root</code></a>.</li> </ul> <p>Try it out:</p> <div class=\"liveExample\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n&lt;form data-bind=\"submit: getTweets\"&gt;\n    Twitter account:\n    &lt;input data-bind=\"value: twitterName\" /&gt;\n    &lt;button type=\"submit\"&gt;Get tweets&lt;/button&gt;\n&lt;/form&gt;\n\n&lt;div data-bind=\"with: resultData\"&gt;\n    &lt;h3&gt;Recent tweets fetched at &lt;span data-bind=\"text: retrievalDate\"&gt; &lt;/span&gt;&lt;/h3&gt;\n    &lt;ol data-bind=\"foreach: topTweets\"&gt;\n        &lt;li data-bind=\"text: text\"&gt;&lt;/li&gt;\n    &lt;/ol&gt;\n\n    &lt;button data-bind=\"click: $parent.clearResults\"&gt;Clear tweets&lt;/button&gt;\n&lt;/div&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\nfunction AppViewModel() {\n    var self = this;\n    self.twitterName = ko.observable('@example');\n    self.resultData = ko.observable(); // No initial value\n\n    self.getTweets = function() {\n        var name = self.twitterName(),\n            simulatedResults = [\n                { text: name + ' What a nice day.' },\n                { text: name + ' Building some cool apps.' },\n                { text: name + ' Just saw a famous celebrity eating lard. Yum.' }\n            ];\n\n        self.resultData({ retrievalDate: new Date(), topTweets: simulatedResults });\n    }\n\n    self.clearResults = function() {\n        self.resultData(undefined);\n    }\n}\n\nko.applyBindings(new AppViewModel());\n</pre> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>The object that you want to use as the context for binding descendant elements.</p> <p>If the expression you supply evaluates to <code>null</code> or <code>undefined</code>, descendant elements will <em>not</em> be bound at all, but will instead be removed from the document.</p> <p>If the expression you supply involves any observable values, the expression will be re-evaluated whenever any of those observables change. Then, descendant elements will be cleared out, and <strong>a new copy of the markup</strong> will be added to your document and bound in the context of the new evaluation result.</p> </li> <li> <p>Additional parameters</p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-1-using-with-without-a-container-element\">Note 1: Using “with” without a container element</h3> <p>Just like other control flow elements such as <a href=\"if-binding\"><code>if</code></a> and <a href=\"foreach-binding\"><code>foreach</code></a>, you can use <code>with</code> without any container element to host it. This is useful if you need to use <code>with</code> in a place where it would not be legal to introduce a new container element just to hold the <code>with</code> binding. See the documentation for <a href=\"if-binding\"><code>if</code></a> or <a href=\"foreach-binding\"><code>foreach</code></a> for more details.</p> <p>Example:</p> <pre>&lt;ul&gt;\n    &lt;li&gt;Header element&lt;/li&gt;\n    &lt;!-- ko with: outboundFlight --&gt;\n        ...\n    &lt;!-- /ko --&gt;\n    &lt;!-- ko with: inboundFlight --&gt;\n        ...\n    &lt;!-- /ko --&gt;\n&lt;/ul&gt;\n</pre> <p>The <code>&lt;!-- ko --&gt;</code> and <code>&lt;!-- /ko --&gt;</code> comments act as start/end markers, defining a “virtual element” that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.</p> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/with-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/with-binding.html</a>\n  </p>\n</div>\n","observablearrays":"<h1>Observable Arrays</h1> <p>If you want to detect and respond to changes on one object, you’d use <a href=\"observables\">observables</a>. If you want to detect and respond to changes of a <em>collection of things</em>, use an <code>observableArray</code>. This is useful in many scenarios where you’re displaying or editing multiple values and need repeated sections of UI to appear and disappear as items are added and removed.</p> <h3 id=\"example\">Example</h3> <pre>var myObservableArray = ko.observableArray();    // Initially an empty array\nmyObservableArray.push('Some value');            // Adds the value and notifies observers\n</pre> <p>To see how you can bind the <code>observableArray</code> to a UI and let the user modify it, see <a href=\"http://knockoutjs.com/examples/simpleList.html\">the simple list example</a>.</p> <h3 id=\"key-point-an-observablearray-tracks-which-objects-are-in-the-array-not-the-state-of-those-objects\">Key point: An observableArray tracks which objects are <em>in</em> the array, <em>not</em> the state of those objects</h3> <p>Simply putting an object into an <code>observableArray</code> doesn’t make all of that object’s properties themselves observable. Of course, you can make those properties observable if you wish, but that’s an independent choice. An <code>observableArray</code> just tracks which objects it holds, and notifies listeners when objects are added or removed.</p> <h2 id=\"prepopulating-an-observablearray\">Prepopulating an observableArray</h2> <p>If you want your observable array <strong>not</strong> to start empty, but to contain some initial items, pass those items as an array to the constructor. For example,</p> <pre>// This observable array initially contains three objects\nvar anotherObservableArray = ko.observableArray([\n    { name: \"Bungle\", type: \"Bear\" },\n    { name: \"George\", type: \"Hippo\" },\n    { name: \"Zippy\", type: \"Unknown\" }\n]);\n</pre> <h2 id=\"reading-information-from-an-observablearray\">Reading information from an observableArray</h2> <p>Behind the scenes, an <code>observableArray</code> is actually an <a href=\"observables\">observable</a> whose value is an array (plus, <code>observableArray</code> adds some additional features described below). So, you can get the underlying JavaScript array by invoking the <code>observableArray</code> as a function with no parameters, just like any other observable. Then you can read information from that underlying array. For example,</p> <pre>alert('The length of the array is ' + myObservableArray().length);\nalert('The first element is ' + myObservableArray()[0]);\n</pre> <p>Technically you can use any of the native JavaScript array functions to operate on that underlying array, but normally there’s a better alternative. KO’s <code>observableArray</code> has equivalent functions of its own, and they’re more useful because:</p> <ol> <li>They work on all targeted browsers. (For example, the native JavaScript <code>indexOf</code> function doesn’t work on IE 8 or earlier, but KO’s <code>indexOf</code> works everywhere.)</li> <li>For functions that modify the contents of the array, such as <code>push</code> and <code>splice</code>, KO’s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated.</li> <li>The syntax is more convenient. To call KO’s <code>push</code> method, just write <code>myObservableArray.push(...)</code>. This is slightly nicer than calling the underlying array’s <code>push</code> method by writing <code>myObservableArray().push(...)</code>.</li> </ol> <p>The rest of this page describes <code>observableArray</code>’s functions for reading and writing array information.</p> <h3 id=\"indexof\">indexOf</h3> <p>The <code>indexOf</code> function returns the index of the first array item that equals your parameter. For example, <code>myObservableArray.indexOf('Blah')</code> will return the zero-based index of the first array entry that equals <code>Blah</code>, or the value <code>-1</code> if no matching value was found.</p> <h3 id=\"slice\">slice</h3> <p>The <code>slice</code> function is the <code>observableArray</code> equivalent of the native JavaScript <code>slice</code> function (i.e., it returns the entries of your array from a given start index up to a given end index). Calling <code>myObservableArray.slice(...)</code> is equivalent to calling the same method on the underlying array (i.e., <code>myObservableArray().slice(...)</code>).</p> <h2 id=\"manipulating-an-observablearray\">Manipulating an observableArray</h2> <p><code>observableArray</code> exposes a familiar set of functions for modifying the contents of the array and notifying listeners.</p> <h3 id=\"pop-push-shift-unshift-reverse-sort-splice\">pop, push, shift, unshift, reverse, sort, splice</h3> <p>All of these functions are equivalent to running the native JavaScript array functions on the underlying array, and then notifying listeners about the change:</p> <ul> <li>\n<code>push( value )</code> — Adds a new item to the end of array.</li> <li>\n<code>pop()</code> — Removes the last value from the array and returns it.</li> <li>\n<code>unshift( value )</code> — Inserts a new item at the beginning of the array.</li> <li>\n<code>shift()</code> — Removes the first value from the array and returns it.</li> <li>\n<code>reverse()</code> — Reverses the order of the array and returns the <code>observableArray</code> (not the underlying array).</li> <li>\n<code>sort()</code> — Sorts the array contents and returns the <code>observableArray</code>. <ul> <li>The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. Your function should accept any two objects from the array and return a negative value if the first argument is smaller, a positive value is the second is smaller, or zero to treat them as equal. For example, to sort an array of ‘person’ objects by last name, you could write <code>myObservableArray.sort(function (left, right) { return left.lastName == right.lastName ? 0 : (left.lastName &lt; right.lastName ? -1 : 1) })</code>\n</li> </ul> </li> <li>\n<code>splice()</code> — Removes and returns a given number of elements starting from a given index. For example, <code>myObservableArray.splice(1, 3)</code> removes three elements starting from index position 1 (i.e., the 2nd, 3rd, and 4th elements) and returns them as an array.</li> </ul> <p>For more details about these <code>observableArray</code> functions, see the equivalent documentation of the <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2\">standard JavaScript array functions</a>.</p> <h3 id=\"remove-and-removeall\">remove and removeAll</h3> <p><code>observableArray</code> adds some more useful methods that aren’t found on JavaScript arrays by default:</p> <ul> <li>\n<code>remove( someItem )</code> — Removes all values that equal <code>someItem</code> and returns them as an array.</li> <li>\n<code>remove( function (item) { return item.age &lt; 18; } )</code> — Removes all values whose <code>age</code> property is less than 18, and returns them as an array.</li> <li>\n<code>removeAll( ['Chad', 132, undefined] )</code> — Removes all values that equal <code>'Chad'</code>, <code>123</code>, or <code>undefined</code> and returns them as an array.</li> <li>\n<code>removeAll()</code> — Removes all values and returns them as an array.</li> </ul> <h3 id=\"destroy-and-destroyall\">destroy and destroyAll (Note: Usually relevant to Ruby on Rails developers only)</h3> <p>The <code>destroy</code> and <code>destroyAll</code> functions are mainly intended as a convenience for developers using Ruby on Rails:</p> <ul> <li>\n<code>destroy( someItem )</code> — Finds any objects in the array that equal <code>someItem</code> and gives them a special property called <code>_destroy</code> with value <code>true</code>.</li> <li>\n<code>destroy( function (someItem) { return someItem.age &lt; 18; } )</code> — Finds any objects in the array whose <code>age</code> property is less than 18, and gives those objects a special property called <code>_destroy</code> with value <code>true</code>.</li> <li>\n<code>destroyAll( ['Chad', 132, undefined] )</code> — Finds any objects in the array that equal <code>'Chad'</code>, <code>123</code>, or <code>undefined</code> and gives them a special property called <code>_destroy</code> with value <code>true</code>.</li> <li>\n<code>destroyAll()</code> — Gives a special property called <code>_destroy</code> with value <code>true</code> to all objects in the array.</li> </ul> <p>So, what’s this <code>_destroy</code> thing all about? It’s only really interesting to Rails developers. The convention in Rails is that, when you pass into an action a JSON object graph, the framework can automatically convert it to an ActiveRecord object graph and then save it to your database. It knows which of the objects are already in your database, and issues the correct INSERT or UPDATE statements. To tell the framework to DELETE a record, you just mark it with <code>_destroy</code> set to <code>true</code>.</p> <p>Note that when KO renders a <code>foreach</code> binding, it automatically hides any objects marked with <code>_destroy</code> equal to <code>true</code>. So, you can have some kind of “delete” button that invokes the <code>destroy(someItem)</code> method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).</p> <h2 id=\"delaying-andor-suppressing-change-notifications\">Delaying and/or suppressing change notifications</h2> <p>Normally, an <code>observableArray</code> notifies its subscribers immediately, as soon as it’s changed. But if an <code>observableArray</code> is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying change notifications. This is accomplished using the <a href=\"ratelimit-observable\"><code>rateLimit</code> extender</a> like this:</p> <pre>// Ensure it notifies about changes no more than once per 50-millisecond period\nmyViewModel.myObservableArray.extend({ rateLimit: 50 });\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/observableArrays.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/observableArrays.html</a>\n  </p>\n</div>\n","computedobservables":"<h1>Computed Observables</h1> <p>What if you’ve got an <a href=\"observables\">observable</a> for <code>firstName</code>, and another for <code>lastName</code>, and you want to display the full name? That’s where <em>computed observables</em> come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change.</p> <p>For example, given the following view model class,</p> <pre>function AppViewModel() {\n    this.firstName = ko.observable('Bob');\n    this.lastName = ko.observable('Smith');\n}\n</pre> <p>… you could add a computed observable to return the full name:</p> <pre>function AppViewModel() {\n    // ... leave firstName and lastName unchanged ...\n\n    this.fullName = ko.computed(function() {\n        return this.firstName() + \" \" + this.lastName();\n    }, this);\n}\n</pre> <p>Now you could bind UI elements to it, e.g.:</p> <pre>The name is &lt;span data-bind=\"text: fullName\"&gt;&lt;/span&gt;\n</pre> <p>… and they will be updated whenever <code>firstName</code> or <code>lastName</code> changes (your evaluator function will be called once each time any of its dependencies change, and whatever value you return will be passed on to the observers such as UI elements or other computed observables).</p> <h3 id=\"dependency-chains-just-work\">Dependency chains just work</h3> <p>Of course, you can create whole chains of computed observables if you wish. For example, you might have:</p> <ul> <li>an <strong>observable</strong> called <code>items</code> representing a set of items</li> <li>another <strong>observable</strong> called <code>selectedIndexes</code> storing which item indexes have been ‘selected’ by the user</li> <li>a <strong>computed observable</strong> called <code>selectedItems</code> that returns an array of item objects corresponding to the selected indexes</li> <li>another <strong>computed observable</strong> that returns <code>true</code> or <code>false</code> depending on whether any of <code>selectedItems</code> has some property (like being new or being unsaved). Some UI element, like a button, might be enabled or disabled based on this value.</li> </ul> <p>Changes to <code>items</code> or <code>selectedIndexes</code> will ripple through the chain of computed observables, which in turn will update any UI elements bound to them.</p> <h3 id=\"managing-this\">Managing ‘this’</h3> <p>The second parameter to <code>ko.computed</code> (the bit where we passed <code>this</code> in the above example) defines the value of <code>this</code> when evaluating the computed observable. Without passing it in, it would not have been possible to refer to <code>this.firstName()</code> or <code>this.lastName()</code>. Experienced JavaScript coders will regard this as obvious, but if you’re still getting to know JavaScript it might seem strange. (Languages like C# and Java never expect the programmer to set a value for <code>this</code>, but JavaScript does, because its functions themselves aren’t part of any object by default.)</p> <h4 id=\"a-popular-convention-that-simplifies-things\">A popular convention that simplifies things</h4> <p>There’s a popular convention that avoids the need to track <code>this</code> altogether: if your viewmodel’s constructor copies a reference to <code>this</code> into a different variable (traditionally called <code>self</code>), you can then use <code>self</code> throughout your viewmodel and don’t have to worry about it being redefined to refer to something else. For example:</p> <pre>function AppViewModel() {\n    var self = this;\n\n    self.firstName = ko.observable('Bob');\n    self.lastName = ko.observable('Smith');\n    self.fullName = ko.computed(function() {\n        return self.firstName() + \" \" + self.lastName();\n    });\n}\n</pre> <p>Because <code>self</code> is captured in the function’s closure, it remains available and consistent in any nested functions, such as the computed observable’s evaluator. This convention is even more useful when it comes to event handlers, as you’ll see in many of the <a href=\"http://knockoutjs.com/examples/\">live examples</a>.</p> <h3 id=\"pure-computed-observables\">\n<em>Pure</em> computed observables</h3> <p>If your computed observable simply calculates and returns a value based on some observable dependencies, then it’s better to declare it as a <code>ko.pureComputed</code> instead of a <code>ko.computed</code>. For example:</p> <pre>this.fullName = ko.pureComputed(function() {\n    return this.firstName() + \" \" + this.lastName();\n}, this);\n</pre> <p>Since this computed is declared to be <em>pure</em> (i.e., its evaluator does not directly modify other objects or state), Knockout can more efficiently manage its re-evaluation and memory use. Knockout will automatically suspend or release it if no other code has an active dependency on it.</p> <p>Pure computeds were introduced in Knockout 3.2.0. See also: <a href=\"computed-pure\">more about pure computed observables</a>.</p> <h3 id=\"forcing-computed-observables-to-always-notify-subscribers\">Forcing computed observables to always notify subscribers</h3> <p>When a computed observable returns a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in <code>notify</code> <a href=\"extenders\">extender</a> to ensure that a computed observable’s subscribers are always notified on an update, even if the value is the same. You would apply the extender like this:</p> <pre>myViewModel.fullName = ko.pureComputed(function() {\n    return myViewModel.firstName() + \" \" + myViewModel.lastName();\n}).extend({ notify: 'always' });\n</pre> <h3 id=\"delaying-andor-suppressing-change-notifications\">Delaying and/or suppressing change notifications</h3> <p>Normally, a computed observable updates and notifies its subscribers immediately, as soon as its dependencies change. But if a computed observable has many dependencies or involves expensive updates, you may get better performance by limiting or delaying the computed observable’s updates and notifications. This is accomplished using the <a href=\"ratelimit-observable\"><code>rateLimit</code> extender</a> like this:</p> <pre>// Ensure updates no more than once per 50-millisecond period\nmyViewModel.fullName.extend({ rateLimit: 50 });\n</pre> <h3 id=\"determining-if-a-property-is-a-computed-observable\">Determining if a property is a computed observable</h3> <p>In some scenarios, it is useful to programmatically determine if you are dealing with a computed observable. Knockout provides a utility function, <code>ko.isComputed</code> to help with this situation. For example, you might want to exclude computed observables from data that you are sending back to the server.</p> <pre>for (var prop in myObject) {\n    if (myObject.hasOwnProperty(prop) &amp;&amp; !ko.isComputed(myObject[prop])) {\n        result[prop] = myObject[prop];\n    }\n}\n</pre> <p>Additionally, Knockout provides similar functions that can operate on observables and computed observables:</p> <ul> <li>\n<code>ko.isObservable</code> - returns true for observables, observable arrays, and all computed observables.</li> <li>\n<code>ko.isWritableObservable</code> - returns true for observables, observable arrays, and writable computed observables (also aliased as <code>ko.isWriteableObservable</code>).</li> </ul> <h3 id=\"when-the-computed-observable-is-only-used-in-your-ui\">When the computed observable is only used in your UI</h3> <p>If you only need to use the compound full name in the UI you could declare it as:</p> <pre>function AppViewModel() {\n    // ... leave firstName and lastName unchanged ...\n\n    this.fullName = function() {\n        return this.firstName() + \" \" + this.lastName();\n    };\n}\n</pre> <p>Now your binding in UI elements becomes a method call, e.g.:</p> <pre>The name is &lt;span data-bind=\"text: fullName()\"&gt;&lt;/span&gt;\n</pre> <p>Knockout will create a computed observable internally in order to detect what observables the expression depends on, and will automatically dispose it when the associated element is later removed.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/computedObservables.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/computedObservables.html</a>\n  </p>\n</div>\n","computed-pure":"<h1>Pure computed observables</h1> <p><em>Pure</em> computed observables, introduced in Knockout 3.2.0, provide performance and memory benefits over regular computed observables for most applications. This is because a <em>pure</em> computed observable doesn’t maintain subscriptions to its dependencies when it has no subscribers itself. This feature:</p> <ul> <li>\n<strong>Prevents memory leaks</strong> from computed observables that are no longer referenced in an application but whose dependencies still exist.</li> <li>\n<strong>Reduces computation overhead</strong> by not re-calculating computed observables whose value isn’t being observed.</li> </ul> <p>A <em>pure</em> computed observable automatically switches between two states based on whether it has <code>change</code> subscribers.</p> <ol> <li> <p>Whenever it has <em>no</em> <code>change</code> subscribers, it is <strong><em>sleeping</em></strong>. When entering the <em>sleeping</em> state, it disposes all subscriptions to its dependencies. During this state, it will not subscribe to any observables accessed in the evaluator function (although it does keep track of them). If the computed observable’s value is read while it is <em>sleeping</em>, it is automatically re-evaluated if any of its dependencies have changed.</p> </li> <li> <p>Whenever it has <em>any</em> <code>change</code> subscribers, it is awake and <strong><em>listening</em></strong>. When entering the <em>listening</em> state, it immediately subscribes to any dependencies. In this state, it operates just like a regular computed observable, as described in <a href=\"computed-dependency-tracking\">how dependency tracking works</a>.</p> </li> </ol> <h4 id=\"pure-computed-function-defined\">Why “pure”?</h4> <p>We’ve borrowed the term from <a href=\"http://en.wikipedia.org/wiki/Pure_function\">pure functions</a> because this feature is generally only applicable for computed observables whose evaluator is a <em>pure function</em> as follows:</p> <ol> <li>Evaluating the computed observable should not cause any side effects.</li> <li>The value of the computed observable shouldn’t vary based on the number of evaluations or other “hidden” information. Its value should be based solely on the values of other observables in the application, which for the pure function definition, are considered its parameters.</li> </ol> <h4 id=\"syntax\">Syntax</h4> <p>The standard method of defining a <em>pure</em> computed observable is to use <code>ko.pureComputed</code>:</p> <pre>this.fullName = ko.pureComputed(function() {\n    return this.firstName() + \" \" + this.lastName();\n}, this);\n</pre> <p>Alternatively, you can use the <code>pure</code> option with <code>ko.computed</code>:</p> <pre>this.fullName = ko.computed(function() {\n    return this.firstName() + \" \" + this.lastName();\n}, this, { pure: true });\n</pre> <p>For complete syntax, see the <a href=\"computed-reference\">computed observable reference</a>.</p> <h3 id=\"when-to-use-a-pure-computed-observable\">When to use a <em>pure</em> computed observable</h3> <p>You can use the <em>pure</em> feature for any computed observable that follows the <a href=\"#pure-computed-function-defined\"><em>pure function</em> guidelines</a>. You’ll see the most benefit, though, when it is applied to application designs that involve persistent view models that are used and shared by temporary views and view models. Using <em>pure</em> computed observables in a persistent view model provides computation performance benefits. Using them in temporary view models provides memory management benefits.</p> <p>In the following example of a simple wizard interface, the <code>fullName</code> <em>pure</em> computed is only bound to the view during the final step and so is only updated when that step is active.</p>  <div class=\"liveExample\" id=\"wizard-example\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n&lt;div class=\"log\" data-bind=\"text: computedLog\"&gt;&lt;/div&gt;\n&lt;!--ko if: step() == 0--&gt;\n    &lt;p&gt;First name: &lt;input data-bind=\"textInput: firstName\" /&gt;&lt;/p&gt;\n&lt;!--/ko--&gt;\n&lt;!--ko if: step() == 1--&gt;\n    &lt;p&gt;Last name: &lt;input data-bind=\"textInput: lastName\" /&gt;&lt;/p&gt;\n&lt;!--/ko--&gt;\n&lt;!--ko if: step() == 2--&gt;\n    &lt;div&gt;Prefix: &lt;select data-bind=\"value: prefix, options: ['Mr.', 'Ms.','Mrs.','Dr.']\"&gt;&lt;/select&gt;&lt;/div&gt;\n    &lt;h2&gt;Hello, &lt;span data-bind=\"text: fullName\"&gt; &lt;/span&gt;!&lt;/h2&gt;\n&lt;!--/ko--&gt;\n&lt;p&gt;&lt;button type=\"button\" data-bind=\"click: next\"&gt;Next&lt;/button&gt;&lt;/p&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\nfunction AppData() {\n    this.firstName = ko.observable('John');\n    this.lastName = ko.observable('Burns');\n    this.prefix = ko.observable('Dr.');\n    this.computedLog = ko.observable('Log: ');\n    this.fullName = ko.pureComputed(function () {\n        var value = this.prefix() + \" \" + this.firstName() + \" \" + this.lastName();\n        // Normally, you should avoid writing to observables within a pure computed \n        // observable (avoiding side effects). But this example is meant to demonstrate \n        // its internal workings, and writing a log is a good way to do so.\n        this.computedLog(this.computedLog.peek() + value + '; ');\n        return value;\n    }, this);\n\n    this.step = ko.observable(0);\n    this.next = function () {\n        this.step(this.step() === 2 ? 0 : this.step()+1);\n    };\n};\nko.applyBindings(new AppData());\n</pre> <h3 id=\"when-not-to-use-a-pure-computed-observable\">When <em>not</em> to use a <em>pure</em> computed observable</h3> <h4 id=\"side-effects\">Side effects</h4> <p>You should not use the <em>pure</em> feature for a computed observable that is meant to perform an action when its dependencies change. Examples include:</p> <ul> <li> <p>Using a computed observable to run a callback based on multiple observables.</p> <pre>  ko.computed(function () {\n      var cleanData = ko.toJS(this);\n      myDataClient.update(cleanData);\n  }, this);\n</pre> </li> <li> <p>In a binding’s <code>init</code> function, using a computed observable to update the bound element.</p> <pre>  ko.computed({\n      read: function () {\n          element.title = ko.unwrap(valueAccessor());\n      },\n      disposeWhenNodeIsRemoved: element\n  });\n</pre> </li> </ul> <p>The reason you shouldn’t use a <em>pure</em> computed if the evaluator has important side effects is simply that the evaluator will not run whenever the computed has no active subscribers (and so is sleeping). If it’s important for the evaluator to always run when dependencies change, use a <a href=\"computedobservables\">regular computed</a> instead.</p> <h3 id=\"determining-if-a-property-is-a-pure-computed-observable\">Determining if a property is a pure computed observable</h3> <p>In some scenarios, it is useful to programmatically determine if you are dealing with a pure computed observable. Knockout provides a utility function, <code>ko.isPureComputed</code> to help with this situation. For example, you might want to exclude non-pure computed observables from data that you are sending back to the server.</p> <pre>var result = {};\nko.utils.objectForEach(myObject, function (name, value) {\n    if (!ko.isComputed(value) || ko.isPureComputed(value)) {\n        result[name] = value;\n    }\n});\n</pre> <h3 id=\"state-change-notifications\">State-change notifications</h3> <p>A pure computed observable notifies an <code>awake</code> event (using its current value) whenever it enters the <em>listening</em> state and notifies an <code>asleep</code> event (using an <code>undefined</code> value) whevener it enter the <em>sleeping</em> state. You won’t normally need to know about the internal state of your computed observables. But since the internal state can correspond to whether the computed observable is bound to the view or not, you might use that information to do some view-model initialization or cleanup.</p> <pre>this.someComputedThatWillBeBound = ko.pureComputed(function () {\n    ...\n}, this);\n\nthis.someComputedThatWillBeBound.subscribe(function () {\n    // do something when this is bound\n}, this, \"awake\");\n\nthis.someComputedThatWillBeBound.subscribe(function () {\n    // do something when this is un-bound\n}, this, \"asleep\");\n</pre> <p>(The <code>awake</code> event also applies to normal computed observables created with the <code>deferEvaluation</code> option.)</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/computed-pure.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/computed-pure.html</a>\n  </p>\n</div>\n","computed-reference":"<h1>Computed Observable Reference</h1> <p>The following documentation describes how to construct and work with computed observables.</p> <h2 id=\"constructing-a-computed-observable\">Constructing a computed observable</h2> <p>A computed observable can be constructed using one of the following forms:</p> <ol> <li>\n<code>ko.computed( evaluator [, targetObject, options] )</code> — This form supports the most common case of creating a computed observable. <ul> <li>\n<code>evaluator</code> — A function that is used to evaluate the computed observable’s current value.</li> <li>\n<code>targetObject</code> — If given, defines the value of <code>this</code> whenever KO invokes your callback functions. See the section on <a href=\"computedobservables#managing-this\">managing <code>this</code></a> for more information.</li> <li>\n<code>options</code> — An object with further properties for the computed observable. See the full list below.</li> </ul> </li> <li>\n<code>ko.computed( options )</code> — This single parameter form for creating a computed observable accepts a JavaScript object with any of the following properties. <ul> <li>\n<code>read</code> — Required. A function that is used to evaluate the computed observable’s current value.</li> <li>\n<code>write</code> — Optional. If given, makes the computed observable <em>writable</em>. This is a function that receives values that other code is trying to write to your computed observable. It’s up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</li> <li>\n<code>owner</code> — Optional. If given, defines the value of <code>this</code> whenever KO invokes your <code>read</code> or <code>write</code> callbacks.</li> <li>\n<code>pure</code> — Optional. If this option is <code>true</code>, the computed observable will be set up as a <a href=\"computed-pure\"><em>pure</em> computed observable</a>. This option is an alternative to the <code>ko.pureComputed</code> constructor.</li> <li>\n<code>deferEvaluation</code> — Optional. If this option is <code>true</code>, then the value of the computed observable will not be evaluated until something actually attempts to access its value or manually subscribes to it. By default, a computed observable has its value determined immediately during creation.</li> <li>\n<code>disposeWhen</code> — Optional. If given, this function is executed before each re-evaluation to determine if the computed observable should be disposed. A <code>true</code>-ish result will trigger disposal of the computed observable.</li> <li>\n<code>disposeWhenNodeIsRemoved</code> — Optional. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by KO. This feature is used to dispose computed observables used in bindings when nodes are removed by the <code>template</code> and control-flow bindings.</li> </ul> </li> <li> <p><code>ko.pureComputed( evaluator [, targetObject] )</code> — Constructs a <a href=\"computed-pure\"><em>pure</em> computed observable</a> using the given evaluator function and optional object to use for <code>this</code>. Unlike <code>ko.computed</code>, this method doesn’t accept an <code>options</code> parameter.</p> </li> <li>\n<code>ko.pureComputed( options )</code> — Constructs a <em>pure</em> computed observable using an <code>options</code> object. This accepts the <code>read</code>, <code>write</code>, and <code>owner</code> options described above.</li> </ol> <h2 id=\"using-a-computed-observable\">Using a computed observable</h2> <p>A computed observable provides the following functions:</p> <ul> <li>\n<code>dispose()</code> — Manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won’t be cleaned.</li> <li>\n<code>extend(extenders)</code> — Applies the given <a href=\"extenders\">extenders</a> to the computed observable.</li> <li>\n<code>getDependenciesCount()</code> — Returns the current number of dependencies of the computed observable.</li> <li>\n<code>getSubscriptionsCount( [event] )</code> — Returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable. Optionally, pass an event name (like <code>\"change\"</code>) to return just the count of subscriptions for that event.</li> <li>\n<code>isActive()</code> — Returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.</li> <li>\n<code>peek()</code> — Returns the current value of the computed observable without creating a dependency (see the section on <a href=\"computed-dependency-tracking#controlling-dependencies-using-peek\"><code>peek</code></a>).</li> <li>\n<code>subscribe( callback [,callbackTarget, event] )</code> — Registers a <a href=\"observables#explicitly-subscribing-to-observables\">manual subscription</a> to be notified of changes to the computed observable.</li> </ul> <h2 id=\"determining-the-observable-type\">Determining the observable type</h2> <p>To check if a property is observable, computed, etc., use the following set of functions:</p> <ul> <li>\n<code>ko.isObservable</code> — returns <code>true</code> for observables, observable arrays, and all computed observables.</li> <li>\n<code>ko.isWritableObservable</code> — returns <code>true</code> for observables, observable arrays, and <em>writable</em> computed observables (also aliased as <code>ko.isWriteableObservable</code>).</li> <li>\n<code>ko.isComputed</code> — returns <code>true</code> for all computed observables.</li> <li>\n<code>ko.isPureComputed</code> — returns <code>true</code> for <em>pure</em> computed observables.</li> </ul> <h2 id=\"using-the-computed-context\">Using the computed context</h2> <p>During the execution of a computed observable’s evaluator function, you can access <code>ko.computedContext</code> to get information about the current computed property. It provides the following functions:</p> <ul> <li> <p><code>isInitial()</code> — A function that returns <code>true</code> if called during the first ever evaluation of the current computed observable, or <code>false</code> otherwise. For <em>pure</em> computed observables, <code>isInitial()</code> is always <code>undefined</code>.</p> </li> <li> <p><code>getDependenciesCount()</code> — Returns the number of dependencies of the computed observable detected so far during the current evaluation.</p> <ul> <li>Note: <code>ko.computedContext.getDependenciesCount()</code> is equivalent to calling <code>getDependenciesCount()</code> on the computed observable itself. The reason that it also exists on <code>ko.computedContext</code> is to provide a way of counting the dependencies during the first ever evaluation, before the computed observable has even finished being constructed.</li> </ul> </li> </ul> <p>Example:</p> <pre>var myComputed = ko.computed(function() {\n    // ... Omitted: read some data that might be observable ...\n\n    // Now let's inspect ko.computedContext\n    var isFirstEvaluation = ko.computedContext.isInitial(),\n        dependencyCount = ko.computedContext.getDependenciesCount(),\n    console.log(\"Evaluating \" + (isFirstEvaluation ? \"for the first time\" : \"again\"));\n    console.log(\"By now, this computed has \" + dependencyCount + \" dependencies\");\n\n    // ... Omitted: return the result ...\n});\n</pre> <p>These facilities are typically useful only in advanced scenarios, for example when your computed observable’s primary purpose is to trigger some side-effect during its evaluator, and you want to perform some setup logic only during the first run, or only if it has at least one dependency (and hence might re-evaluate in the future). Most computed properties do not need to care whether they have been evaluated before, or how many dependencies they have.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/computed-reference.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/computed-reference.html</a>\n  </p>\n</div>\n","html-binding":"<h1>The \"html\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>html</code> binding causes the associated DOM element to display the HTML specified by your parameter.</p> <p>Typically this is useful when values in your view model are actually strings of HTML markup that you want to render.</p> <h3 id=\"example\">Example</h3> <pre>&lt;div data-bind=\"html: details\"&gt;&lt;/div&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n\t\tdetails: ko.observable() // Initially blank\n    };\n    viewModel.details(\"&lt;em&gt;For further details, view the report &lt;a href='report.html'&gt;here&lt;/a&gt;.&lt;/em&gt;\"); // HTML content appears\n&lt;/script&gt;\n</pre> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>KO clears the previous content and then sets the element’s content to your parameter value using jQuery’s <code>html</code> function or by parsing the string into HTML nodes and appending each node as a child of the element, if jQuery is not available.</p> <p>If this parameter is an observable value, the binding will update the element’s content whenever the value changes. If the parameter isn’t observable, it will only set the element’s content once and will not update it again later.</p> <p>If you supply something other than a number or a string (e.g., you pass an object or an array), the <code>innerHTML</code> will be equivalent to <code>yourParameter.toString()</code></p> </li> <li> <p>Additional parameters</p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-about-html-encoding\">Note: About HTML encoding</h3> <p>Since this binding sets your element’s content using <code>innerHTML</code>, you should be careful not to use it with untrusted model values, because that might open the possibility of a script injection attack. If you cannot guarantee that the content is safe to display (for example, if it is based on a different user’s input that was stored in your database), then you can use <a href=\"text-binding\">the text binding</a>, which will set the element’s text value using <code>innerText</code> or <code>textContent</code> instead.</p> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/html-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/html-binding.html</a>\n  </p>\n</div>\n","css-binding":"<h1>The \"css\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>css</code> binding adds or removes one or more named CSS classes to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative.</p> <p>(Note: If you don’t want to apply a CSS class but instead want to assign a <code>style</code> attribute value directly, see <a href=\"style-binding\">the style binding</a>.)</p> <h3 id=\"example-with-static-classes\">Example with static classes</h3> <pre>&lt;div data-bind=\"css: { profitWarning: currentProfit() &lt; 0 }\"&gt;\n   Profit Information\n&lt;/div&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        currentProfit: ko.observable(150000) // Positive value, so initially we don't apply the \"profitWarning\" class\n    };\n    viewModel.currentProfit(-50); // Causes the \"profitWarning\" class to be applied\n&lt;/script&gt;\n</pre> <p>This will apply the CSS class <code>profitWarning</code> whenever the <code>currentProfit</code> value dips below zero, and remove that class whenever it goes above zero.</p> <h3 id=\"example-with-dynamic-classes\">Example with dynamic classes</h3> <pre>&lt;div data-bind=\"css: profitStatus\"&gt;\n   Profit Information\n&lt;/div&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        currentProfit: ko.observable(150000)\n    };\n\n    // Evalutes to a positive value, so initially we apply the \"profitPositive\" class\n    viewModel.profitStatus = ko.pureComputed(function() {\n        return this.currentProfit() &lt; 0 ? \"profitWarning\" : \"profitPositive\";\n    }, viewModel);\n\n    // Causes the \"profitPositive\" class to be removed and \"profitWarning\" class to be added\n    viewModel.currentProfit(-50);\n&lt;/script&gt;\n</pre> <p>This will apply the CSS class <code>profitPositive</code> when the <code>currentProfit</code> value is positive, otherwise it will apply the <code>profitWarning</code> CSS class.</p> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>If you are using static CSS class names, then you can pass a JavaScript object in which the property names are your CSS classes, and their values evaluate to <code>true</code> or <code>false</code> according to whether the class should currently be applied.</p> <p>You can set multiple CSS classes at once. For example, if your view model has a property called <code>isSevere</code>,</p> <pre>&lt;div data-bind=\"css: { profitWarning: currentProfit() &lt; 0, majorHighlight: isSevere }\"&gt;\n</pre> <p>You can even set multiple CSS classes based on the same condition by wrapping the names in quotes like:</p> <pre>&lt;div data-bind=\"css: { profitWarning: currentProfit() &lt; 0, 'major highlight': isSevere }\"&gt;\n</pre> <p>Non-boolean values are interpreted loosely as boolean. For example, <code>0</code> and <code>null</code> are treated as <code>false</code>, whereas <code>21</code> and non-<code>null</code> objects are treated as <code>true</code>.</p> <p>If your parameter references an observable value, the binding will add or remove the CSS class whenever the observable value changes. If the parameter doesn’t reference an observable value, it will only add or remove the class once and will not do so again later.</p> <p>If you want to use dynamic CSS class names, then you can pass a string that corresponds to the CSS class or classes that you want to add to the element. If the parameter references an observable value, then the binding will remove any previously added classes and add the class or classes corresponding to the observable’s new value.</p> <p>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. KO will evaluate them and use the resulting values to determine the appropriate CSS classes to add or remove.</p> </li> <li> <p>Additional parameters </p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-applying-css-classes-whose-names-arent-legal-javascript-variable-names\">Note: Applying CSS classes whose names aren’t legal JavaScript variable names</h3> <p>If you want to apply the CSS class <code>my-class</code>, you <em>can’t</em> write this:</p> <pre>&lt;div data-bind=\"css: { my-class: someValue }\"&gt;...&lt;/div&gt;\n</pre> <p>… because <code>my-class</code> isn’t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</p> <pre>&lt;div data-bind=\"css: { 'my-class': someValue }\"&gt;...&lt;/div&gt;\n</pre> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/css-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/css-binding.html</a>\n  </p>\n</div>\n","style-binding":"<h1>The \"style\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>style</code> binding adds or removes one or more style values to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative, or to set the width of a bar to match a numerical value that changes.</p> <p>(Note: If you don’t want to apply an explicit style value but instead want to assign a CSS class, see <a href=\"css-binding\">the css binding</a>.)</p> <h3 id=\"example\">Example</h3> <pre>&lt;div data-bind=\"style: { color: currentProfit() &lt; 0 ? 'red' : 'black' }\"&gt;\n   Profit Information\n&lt;/div&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        currentProfit: ko.observable(150000) // Positive value, so initially black\n    };\n    viewModel.currentProfit(-50); // Causes the DIV's contents to go red\n&lt;/script&gt;\n</pre> <p>This will set the element’s <code>style.color</code> property to <code>red</code> whenever the <code>currentProfit</code> value dips below zero, and to <code>black</code> whenever it goes above zero.</p> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>You should pass a JavaScript object in which the property names correspond to style names, and the values correspond to the style values you wish to apply.</p> <p>You can set multiple style values at once. For example, if your view model has a property called <code>isSevere</code>,</p> <p><code>&lt;div data-bind=\"style: { color: currentProfit() &lt; 0 ? 'red' : 'black', fontWeight: isSevere() ? 'bold' : '' }\"&gt;...&lt;/div&gt;</code></p> <p>If your parameter references an observable value, the binding will update the styles whenever the observable value changes. If the parameter doesn’t reference an observable value, it will only set the styles once and will not update them later.</p> <p>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. KO will evaluate them and use the resulting values to detemine the style values to apply.</p> </li> <li> <p>Additional parameters </p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-applying-styles-whose-names-arent-legal-javascript-variable-names\">Note: Applying styles whose names aren’t legal JavaScript variable names</h3> <p>If you want to apply a <code>font-weight</code> or <code>text-decoration</code> style, or any other style whose name isn’t a legal JavaScript identifier (e.g., because it contains a hyphen), you must use the <em>JavaScript name</em> for that style. For example,</p> <ul> <li>Don’t write <code>{ font-weight: someValue }</code>; do write <code>{ fontWeight: someValue }</code>\n</li> <li>Don’t write <code>{ text-decoration: someValue }</code>; do write <code>{ textDecoration: someValue }</code>\n</li> </ul> <p>See also: <a href=\"http://www.comptechdoc.org/independent/web/cgi/javamanual/javastyle.html\">a longer list of style names and their JavaScript equivalents</a></p> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/style-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/style-binding.html</a>\n  </p>\n</div>\n","attr-binding":"<h1>The \"attr\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>attr</code> binding provides a generic way to set the value of any attribute for the associated DOM element. This is useful, for example, when you need to set the <code>title</code> attribute of an element, the <code>src</code> of an <code>img</code> tag, or the <code>href</code> of a link based on values in your view model, with the attribute value being updated automatically whenever the corresponding model property changes.</p> <h3 id=\"example\">Example</h3> <pre>&lt;a data-bind=\"attr: { href: url, title: details }\"&gt;\n    Report\n&lt;/a&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        url: ko.observable(\"year-end.html\"),\n        details: ko.observable(\"Report including final year-end statistics\")\n    };\n&lt;/script&gt;\n</pre> <p>This will set the element’s <code>href</code> attribute to <code>year-end.html</code> and the element’s <code>title</code> attribute to <code>Report including final year-end statistics</code>.</p> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>You should pass a JavaScript object in which the property names correspond to attribute names, and the values correspond to the attribute values you wish to apply.</p> <p>If your parameter references an observable value, the binding will update the attribute whenever the observable value changes. If the parameter doesn’t reference an observable value, it will only set the attribute once and will not update it later.</p> </li> <li> <p>Additional parameters </p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-applying-attributes-whose-names-arent-legal-javascript-variable-names\">Note: Applying attributes whose names aren’t legal JavaScript variable names</h3> <p>If you want to apply the attribute <code>data-something</code>, you <em>can’t</em> write this:</p> <pre>&lt;div data-bind=\"attr: { data-something: someValue }\"&gt;...&lt;/div&gt;\n</pre> <p>… because <code>data-something</code> isn’t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</p> <pre>&lt;div data-bind=\"attr: { 'data-something': someValue }\"&gt;...&lt;/div&gt;\n</pre> <h3 id=\"note-using-reserved-words-as-attribute-names-in-older-browsers\">Note: Using reserved words as attribute names in older browsers</h3> <p>In older browsers (ie8 and below) using reserved javascript words as attribute names causes an error. You can get around this by quoting them like this:</p> <pre>&lt;input data-bind=\"attr: { 'for': someValue }\" /&gt;\n</pre> <p>You can find a good list of reserved words on <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords\">Mozilla’s MDN page here</a>.</p> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/attr-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/attr-binding.html</a>\n  </p>\n</div>\n","if-binding":"<h1>The \"if\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>if</code> binding causes a section of markup to appear in your document (and to have its <code>data-bind</code> attributes applied), only if a specified expression evaluates to <code>true</code> (or a <code>true</code>-ish value such as a non-<code>null</code> object or nonempty string). </p> <p><code>if</code> plays a similar role to <a href=\"visible-binding\">the <code>visible</code> binding</a>. The difference is that, with <code>visible</code>, the contained markup always remains in the DOM and always has its <code>data-bind</code> attributes applied - the <code>visible</code> binding just uses CSS to toggle the container element’s visiblity. The <code>if</code> binding, however, physically adds or removes the contained markup in your DOM, and only applies bindings to descendants if the expression is <code>true</code>.</p> <h3 id=\"example-1\">Example 1</h3> <p>This example shows that the <code>if</code> binding can dynamically add and remove sections of markup as observable values change.</p> <div class=\"liveExample\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n&lt;label&gt;&lt;input type=\"checkbox\" data-bind=\"checked: displayMessage\" /&gt; Display message&lt;/label&gt;\n\n&lt;div data-bind=\"if: displayMessage\"&gt;Here is a message. Astonishing.&lt;/div&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\nko.applyBindings({\n    displayMessage: ko.observable(false)\n});\n</pre> <h3 id=\"example-2\">Example 2</h3> <p>In the following example, the <code>&lt;div&gt;</code> element will be empty for “Mercury”, but populated for “Earth”. That’s because Earth has a non-null <code>capital</code> property, whereas “Mercury” has <code>null</code> for that property.</p> <pre>&lt;ul data-bind=\"foreach: planets\"&gt;\n    &lt;li&gt;\n        Planet: &lt;b data-bind=\"text: name\"&gt; &lt;/b&gt;\n        &lt;div data-bind=\"if: capital\"&gt;\n            Capital: &lt;b data-bind=\"text: capital.cityName\"&gt; &lt;/b&gt;\n        &lt;/div&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n\n\n&lt;script&gt;\n    ko.applyBindings({\n        planets: [\n            { name: 'Mercury', capital: null }, \n            { name: 'Earth', capital: { cityName: 'Barnsley' } }        \n        ]\n    });\n&lt;/script&gt;\n</pre> <p>It’s important to understand that the <code>if</code> binding really is vital to make this code work properly. Without it, there would be an error when trying to evaluate <code>capital.cityName</code> in the context of “Mercury” where <code>capital</code> is <code>null</code>. In JavaScript, you’re not allowed to evaluate subproperties of <code>null</code> or <code>undefined</code> values.</p> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>The expression you wish to evaluate. If it evaluates to <code>true</code> (or a true-ish value), the contained markup will be present in the document, and any <code>data-bind</code> attributes on it will be applied. If your expression evaluates to <code>false</code>, the contained markup will be removed from your document without first applying any bindings to it.</p> <p>If your expression involves any observable values, the expression will be re-evaluated whenever any of them change. Correspondingly, the markup within your <code>if</code> block can be added or removed dynamically as the result of the expression changes. <code>data-bind</code> attributes will be applied to <strong>a new copy of the contained markup</strong> whenever it is re-added.</p> </li> <li> <p>Additional parameters </p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-using-if-without-a-container-element\">Note: Using “if” without a container element</h3> <p>Sometimes you may want to control the presence/absence of a section of markup <em>without</em> having any container element that can hold an <code>if</code> binding. For example, you might want to control whether a certain <code>&lt;li&gt;</code> element appears alongside siblings that always appear:</p> <pre>&lt;ul&gt;\n    &lt;li&gt;This item always appears&lt;/li&gt;\n    &lt;li&gt;I want to make this item present/absent dynamically&lt;/li&gt;\n&lt;/ul&gt;\n</pre> <p>In this case, you can’t put <code>if</code> on the <code>&lt;ul&gt;</code> (because then it would affect the first <code>&lt;li&gt;</code> too), and you can’t put any other container around the second <code>&lt;li&gt;</code> (because HTML doesn’t allow extra containers within <code>&lt;ul&gt;</code>s).</p> <p>To handle this, you can use the <em>containerless control flow syntax</em>, which is based on comment tags. For example,</p> <pre>&lt;ul&gt;\n    &lt;li&gt;This item always appears&lt;/li&gt;\n    &lt;!-- ko if: someExpressionGoesHere --&gt;\n        &lt;li&gt;I want to make this item present/absent dynamically&lt;/li&gt;\n    &lt;!-- /ko --&gt;\n&lt;/ul&gt;\n</pre> <p>The <code>&lt;!-- ko --&gt;</code> and <code>&lt;!-- /ko --&gt;</code> comments act as start/end markers, defining a “virtual element” that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.</p> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/if-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/if-binding.html</a>\n  </p>\n</div>\n","computed-writable":"<h1>Writable computed observables</h1> <p><em>Beginners may wish to skip this section - writable computed observables are fairly advanced and are not necessary in most situations</em></p> <p>Normally, computed observables have a value that is computed from other observables and are therefore <em>read-only</em>. What may seem surprising, then, is that it is possible to make computed observables <em>writable</em>. You just need to supply your own callback function that does something sensible with written values.</p> <p>You can use a writable computed observable exactly like a regular observable, with your own custom logic intercepting all reads and writes. Just like observables, you can write values to multiple observable or computed observable properties on a model object using <em>chaining syntax</em>. For example, <code>myViewModel.fullName('Joe Smith').age(50)</code>.</p> <p>Writable computed observables are a powerful feature with a wide range of possible uses.</p> <h3 id=\"example-1-decomposing-user-input\">Example 1: Decomposing user input</h3> <p>Going back to the classic “first name + last name = full name” example, you can turn things back-to-front: make the <code>fullName</code> computed observable writable, so that the user can directly edit the full name, and their supplied value will be parsed and mapped back to the underlying <code>firstName</code> and <code>lastName</code> observables. In this example, the <code>write</code> callback handles incoming values by splitting the incoming text into “firstName” and “lastName” components, and writing those values back to the underlying observables.</p> <div class=\"liveExample\" id=\"decompose-input\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n    &lt;div&gt;First name: &lt;span data-bind=\"text: firstName\"&gt;&lt;/span&gt;&lt;/div&gt;\n    &lt;div&gt;Last name: &lt;span data-bind=\"text: lastName\"&gt;&lt;/span&gt;&lt;/div&gt;\n    &lt;div class=\"heading\"&gt;Hello, &lt;input data-bind=\"textInput: fullName\"/&gt;&lt;/div&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\n    function MyViewModel() {\n        this.firstName = ko.observable('Planet');\n        this.lastName = ko.observable('Earth');\n\n        this.fullName = ko.pureComputed({\n            read: function () {\n                return this.firstName() + \" \" + this.lastName();\n            },\n            write: function (value) {\n                var lastSpacePos = value.lastIndexOf(\" \");\n                if (lastSpacePos &gt; 0) { // Ignore values with no space character\n                    this.firstName(value.substring(0, lastSpacePos)); // Update \"firstName\"\n                    this.lastName(value.substring(lastSpacePos + 1)); // Update \"lastName\"\n                }\n            },\n            owner: this\n        });\n    }\n\n    ko.applyBindings(new MyViewModel());\n</pre> <p>This is the exact opposite of the <a href=\"http://knockoutjs.com/examples/helloWorld.html\">Hello World</a> example, in that here the first and last names are not editable, but the combined full name is editable.</p> <p>The preceding view model code demonstrates the <em>single parameter syntax</em> for initializing computed observables. See the <a href=\"computed-reference\">computed observable reference</a> for the full list of available options.</p> <h3 id=\"example-2-selectingdeselecting-all-items\">Example 2: Selecting/deselecting all items</h3> <p>When presenting the user with a list of selectable items, it is often useful to include a method to select or deselect all of the items. This can be represented quite intuitively with a boolean value that represents whether all items are selected. When set to <code>true</code> it will select all items, and when set to <code>false</code> it will deselect them.</p>  <div class=\"liveExample\" id=\"select-all-items\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n    &lt;div class=\"heading\"&gt;\n        &lt;input type=\"checkbox\" data-bind=\"checked: selectedAllProduce\" title=\"Select all/none\"/&gt; Produce\n    &lt;/div&gt;\n    &lt;div data-bind=\"foreach: produce\"&gt;\n        &lt;label&gt;\n            &lt;input type=\"checkbox\" data-bind=\"checkedValue: $data, checked: $parent.selectedProduce\"/&gt;\n            &lt;span data-bind=\"text: $data\"&gt;&lt;/span&gt;\n        &lt;/label&gt;\n    &lt;/div&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\n    function MyViewModel() {\n        this.produce = [ 'Apple', 'Banana', 'Celery', 'Corn', 'Orange', 'Spinach' ];\n        this.selectedProduce = ko.observableArray([ 'Corn', 'Orange' ]);\n        this.selectedAllProduce = ko.pureComputed({\n            read: function () {\n                // Comparing length is quick and is accurate if only items from the\n                // main array are added to the selected array.\n                return this.selectedProduce().length === this.produce.length;\n            },\n            write: function (value) {\n                this.selectedProduce(value ? this.produce.slice(0) : []);\n            },\n            owner: this\n        });\n    }\n    ko.applyBindings(new MyViewModel());\n</pre> <h3 id=\"example-3-a-value-converter\">Example 3: A value converter</h3> <p>Sometimes you might want to represent a data point on the screen in a different format than its underlying storage. For example, you might want to store a price as a raw float value, but let the user edit it with a currency symbol and fixed number of decimal places. You can use a writable computed observable to represent the formatted price, mapping incoming values back to the underlying float value:</p> <div class=\"liveExample\" id=\"value-converter\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n    &lt;div&gt;Enter bid price: &lt;input data-bind=\"textInput: formattedPrice\"/&gt;&lt;/div&gt;\n    &lt;div&gt;(Raw value: &lt;span data-bind=\"text: price\"&gt;&lt;/span&gt;)&lt;/div&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\n    function MyViewModel() {\n        this.price = ko.observable(25.99);\n\n        this.formattedPrice = ko.pureComputed({\n            read: function () {\n                return '$' + this.price().toFixed(2);\n            },\n            write: function (value) {\n                // Strip out unwanted characters, parse as float, then write the \n                // raw data back to the underlying \"price\" observable\n                value = parseFloat(value.replace(/[^\\.\\d]/g, \"\"));\n                this.price(isNaN(value) ? 0 : value); // Write to underlying storage\n            },\n            owner: this\n        });\n    }\n\n    ko.applyBindings(new MyViewModel());\n</pre> <p>Now, whenever the user enters a new price, the text box immediately updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can’t enter more than two decimal places, because if they try to, the additional decimal places are immediately removed. Similarly, they can’t enter negative values, because the <code>write</code> callback strips off any minus sign.</p> <h3 id=\"example-4-filtering-and-validating-user-input\">Example 4: Filtering and validating user input</h3> <p>Example 1 showed how a writable computed observable can effectively <em>filter</em> its incoming data by choosing not to write certain values back to the underlying observables if they don’t meet some criteria. It ignored full name values that didn’t include a space.</p> <p>Taking this a step further, you could also toggle an <code>isValid</code> flag depending on whether the latest input was satisfactory, and display a message in the UI accordingly. There’s an easier way of doing validation (explained below), but first consider the following example, which demonstrates the mechanism:</p>  <div class=\"liveExample\" id=\"validate-input\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n    &lt;div&gt;Enter a numeric value: &lt;input data-bind=\"textInput: attemptedValue\"/&gt;&lt;/div&gt;\n    &lt;div class=\"error\" data-bind=\"visible: !lastInputWasValid()\"&gt;That's not a number!&lt;/div&gt;\n    &lt;div&gt;(Accepted value: &lt;span data-bind=\"text: acceptedNumericValue\"&gt;&lt;/span&gt;)&lt;/div&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\n    function MyViewModel() {\n        this.acceptedNumericValue = ko.observable(123);\n        this.lastInputWasValid = ko.observable(true);\n\n        this.attemptedValue = ko.pureComputed({\n            read: this.acceptedNumericValue,\n            write: function (value) {\n                if (isNaN(value))\n                    this.lastInputWasValid(false);\n                else {\n                    this.lastInputWasValid(true);\n                    this.acceptedNumericValue(value); // Write to underlying storage\n                }\n            },\n            owner: this\n        });\n    }\n\n    ko.applyBindings(new MyViewModel());\n</pre> <p>Now, <code>acceptedNumericValue</code> will only ever contain numeric values, and any other values entered will trigger the appearance of a validation message instead of updating <code>acceptedNumericValue</code>.</p> <p><strong>Note:</strong> For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its <code>number</code> class on the <code>&lt;input&gt;</code> element. Knockout and jQuery Validation work together nicely, as demonstrated on the <a href=\"http://knockoutjs.com/examples/gridEditor.html\">grid editor</a> example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/computed-writable.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/computed-writable.html</a>\n  </p>\n</div>\n","computed-dependency-tracking":"<h1>How dependency tracking works</h1> <p><em>Beginners don’t need to know about this, but more advanced developers will want to know why we keep making all these claims about KO automatically tracking dependencies and updating the right parts of the UI…</em></p> <p>It’s actually very simple and rather lovely. The tracking algorithm goes like this:</p> <ol> <li>Whenever you declare a computed observable, KO immediately invokes its evaluator function to get its initial value.</li> <li>While the evaluator function is running, KO sets up a subscription to any observables (including other computed observables) that the evaluator reads. The subscription callback is set to cause the evaluator to run again, looping the whole process back to step 1 (disposing of any old subscriptions that no longer apply).</li> <li>KO notifies any subscribers about the new value of your computed observable.</li> </ol> <p>So, Knockout doesn’t just detect dependencies the first time the evaluator runs - it redetects them every time. This means, for example, that the dependencies can vary dynamically: dependency A could determine whether the computed observable also depend on B or C. Then, it will only be re-evaluated when either A or your current choice of B or C changes. You don’t have to declare dependencies: they’re determined at runtime from the code’s execution.</p> <p>The other neat trick is that declarative bindings are simply implemented as computed observables. So, if a binding reads the value of an observable, that binding becomes dependent on that observable, which causes that binding to be re-evaluated if the observable changes.</p> <p><em>Pure</em> computed observables work slightly differently. For more details, see the documentation for <a href=\"computed-pure\"><em>pure</em> computed observables</a>.</p> <h2 id=\"controlling-dependencies-using-peek\">Controlling dependencies using peek</h2> <p>Knockout’s automatic dependency tracking normally does exactly what you want. But you might sometimes need to control which observables will update your computed observable, especially if the computed observable performs some sort of action, such as making an Ajax request. The <code>peek</code> function lets you access an observable or computed observable without creating a dependency.</p> <p>In the example below, a computed observable is used to reload an observable named <code>currentPageData</code> using Ajax with data from two other observable properties. The computed observable will update whenever <code>pageIndex</code> changes, but it ignores changes to <code>selectedItem</code> because it is accessed using <code>peek</code>. In this case, the user might want to use the current value of <code>selectedItem</code> only for tracking purposes when a new set of data is loaded.</p> <pre>ko.computed(function() {\n    var params = {\n        page: this.pageIndex(),\n        selected: this.selectedItem.peek()\n    };\n    $.getJSON('/Some/Json/Service', params, this.currentPageData);\n}, this);\n</pre> <p>Note: If you just want to prevent a computed observable from updating too often, see the <a href=\"ratelimit-observable\"><code>rateLimit</code> extender</a>.</p> <h2 id=\"ignoring-dependencies-within-a-computed\">Ignoring dependencies within a computed</h2> <p>The <code>ko.ignoreDependencies</code> function is available for scenarios where you want to execute code within a computed that should not contribute to that computed’s dependencies. This is often useful in a custom binding when you want to call code that may access observables, but you do not want to re-trigger the binding based on changes to those observables.</p> <pre>ko.ignoreDependencies( callback, callbackTarget, callbackArgs );\n</pre> <p>Example:</p> <pre>ko.bindingHandlers.myBinding = {\n    update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var options = ko.unwrap(valueAccessor());\n        var value = ko.unwrap(options.value);\n        var afterUpdateHandler = options.afterUpdate;\n\n        // the developer supplied a function to call when this binding updates, but\n        // we don't really want to track any dependencies that would re-trigger this binding\n        if (typeof afterUpdateHandler === \"function\") {\n            ko.ignoreDependencies(afterUpdateHandler, viewModel, [value, color]);\n        }\n\n        $(element).somePlugin(\"value\", value);\n    }\n}\n</pre> <h2 id=\"note-why-circular-dependencies-arent-meaningful\">Note: Why circular dependencies aren’t meaningful</h2> <p>Computed observables are supposed to map a set of observable inputs into a single observable output. As such, it doesn’t make sense to include cycles in your dependency chains. Cycles would <em>not</em> be analogous to recursion; they would be analogous to having two spreadsheet cells that are computed as functions of each other. It would lead to an infinite evaluation loop.</p> <p>So what does Knockout do if you have a cycle in your dependency graph? It avoids infinite loops by enforcing the following rule: <strong>Knockout will not restart evaluation of a computed while it is already evaluating</strong>. This is very unlikely to affect your code. It’s relevant in two situations: when two computed observables are dependent on each other (possible only if one or both use the <code>deferEvaluation</code> option), or when a computed observable writes to another observable on which it has a dependency (either directly or via a dependency chain). If you need to use one of these patterns and want to entirely avoid the circular dependency, you can use the <code>peek</code> function described above.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/computed-dependency-tracking.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/computed-dependency-tracking.html</a>\n  </p>\n</div>\n","text-binding":"<h1>The \"text\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>text</code> binding causes the associated DOM element to display the text value of your parameter.</p> <p>Typically this is useful with elements like <code>&lt;span&gt;</code> or <code>&lt;em&gt;</code> that traditionally display text, but technically you can use it with any element.</p> <h3 id=\"example\">Example</h3> <pre>Today's message is: &lt;span data-bind=\"text: myMessage\"&gt;&lt;/span&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        myMessage: ko.observable() // Initially blank\n    };\n    viewModel.myMessage(\"Hello, world!\"); // Text appears\n&lt;/script&gt;\n</pre> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>Knockout sets the element’s content to a text node with your parameter value. Any previous content will be overwritten.</p> <p>If this parameter is an observable value, the binding will update the element’s text whenever the value changes. If the parameter isn’t observable, it will only set the element’s text once and will not update it again later.</p> <p>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to <code>yourParameter.toString()</code></p> </li> <li> <p>Additional parameters</p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-1-using-functions-and-expressions-to-detemine-text-values\">Note 1: Using functions and expressions to detemine text values</h3> <p>If you want to detemine text programmatically, one option is to create a <a href=\"computedobservables\">computed observable</a>, and use its evaluator function as a place for your code that works out what text to display.</p> <p>For example,</p> <pre>The item is &lt;span data-bind=\"text: priceRating\"&gt;&lt;/span&gt; today.\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        price: ko.observable(24.95)\n    };\n    viewModel.priceRating = ko.pureComputed(function() {\n        return this.price() &gt; 50 ? \"expensive\" : \"affordable\";\n    }, viewModel);\n&lt;/script&gt;\n</pre> <p>Now, the text will switch between “expensive” and “affordable” as needed whenever <code>price</code> changes.</p> <p>Alternatively, you don’t need to create a computed observable if you’re doing something simple like this. You can pass an arbitrary JavaScript expression to the <code>text</code> binding. For example,</p> <pre>The item is &lt;span data-bind=\"text: price() &gt; 50 ? 'expensive' : 'affordable'\"&gt;&lt;/span&gt; today.\n</pre> <p>This has exactly the same result, without requiring the <code>priceRating</code> computed observable.</p> <h3 id=\"note-2-about-html-encoding\">Note 2: About HTML encoding</h3> <p>Since this binding sets your text value using a text node, it’s safe to set any string value without risking HTML or script injection. For example, if you wrote:</p> <pre>viewModel.myMessage(\"&lt;i&gt;Hello, world!&lt;/i&gt;\");\n</pre> <p>… this would <em>not</em> render as italic text, but would render as literal text with visible angle brackets.</p> <p>If you need to set HTML content in this manner, see <a href=\"html-binding\">the html binding</a>.</p> <h3 id=\"note-3-using-text-without-a-container-element\">Note 3: Using “text” without a container element</h3> <p>Sometimes you may want to set text using Knockout without including an extra element for the <code>text</code> binding. For example, you’re not allowed to include other elements within an <code>option</code> element, so the following will not work.</p> <pre>&lt;select data-bind=\"foreach: items\"&gt;\n    &lt;option&gt;Item &lt;span data-bind=\"text: name\"&gt;&lt;/span&gt;&lt;/option&gt;\n&lt;/select&gt;\n</pre> <p>To handle this, you can use the <em>containerless syntax</em>, which is based on comment tags.</p> <pre>&lt;select data-bind=\"foreach: items\"&gt;\n    &lt;option&gt;Item &lt;!--ko text: name--&gt;&lt;!--/ko--&gt;&lt;/option&gt;\n&lt;/select&gt;\n</pre> <p>The <code>&lt;!--ko--&gt;</code> and <code>&lt;!--/ko--&gt;</code> comments act as start/end markers, defining a “virtual element” that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.</p> <h3 id=\"note-4-about-an-ie-6-whitespace-quirk\">Note 4: About an IE 6 whitespace quirk</h3> <p>IE 6 has a strange quirk whereby it sometimes ignores whitespace that immediately follows an empty span. This has nothing directly to do with Knockout, but in case you do want to write:</p> <pre>Welcome, &lt;span data-bind=\"text: userName\"&gt;&lt;/span&gt; to our web site.\n</pre> <p>… and IE 6 renders no whitespace before the words <code>to our web site</code>, you can avoid the problem by putting any text into the <code>&lt;span&gt;</code>, e.g.:</p> <pre>Welcome, &lt;span data-bind=\"text: userName\"&gt;&amp;nbsp;&lt;/span&gt; to our web site.\n</pre> <p>Other browsers, and newer versions of IE, don’t have this quirk.</p> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/text-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/text-binding.html</a>\n  </p>\n</div>\n","component-binding":"<h1>The \"component\" binding</h1> <p>The <code>component</code> binding injects a specified <a href=\"component-overview\">component</a> into an element, and optionally passes parameters to it.</p> <ul id=\"markdown-toc\"> <li><a href=\"#live-example\">Live example</a></li> <li><a href=\"#api\">API</a></li> <li><a href=\"#component-lifecycle\">Component lifecycle</a></li> <li><a href=\"#note-template-only-components\">Note: Template-only components</a></li> <li><a href=\"#note-using-component-without-a-container-element\">Note: Using <code>component</code> without a container element</a></li> <li><a href=\"#note-passing-markup-to-components\">Note: Passing markup to components</a></li> <li><a href=\"#disposal-and-memory-management\">Disposal and memory management</a></li> </ul> <h3 id=\"live-example\">Live example</h3>  <div class=\"liveExample\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n    &lt;h4&gt;First instance, without parameters&lt;/h4&gt;\n    &lt;div data-bind='component: \"message-editor\"'&gt;&lt;/div&gt;\n\n    &lt;h4&gt;Second instance, passing parameters&lt;/h4&gt;\n    &lt;div data-bind='component: {\n        name: \"message-editor\",\n        params: { initialText: \"Hello, world!\" }\n    }'&gt;&lt;/div&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\n    ko.components.register('message-editor', {\n        viewModel: function(params) {\n            this.text = ko.observable(params &amp;&amp; params.initialText || '');\n        },\n        template: 'Message: &lt;input data-bind=\"value: text\" /&gt; '\n                + '(length: &lt;span data-bind=\"text: text().length\"&gt;&lt;/span&gt;)'\n    });\n\n    ko.applyBindings();\n</pre> <p>Note: In more realistic cases, you would typically load component viewmodels and templates from external files, instead of hardcoding them into the registration. See <a href=\"component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand\">an example</a> and <a href=\"component-registration\">registration documentation</a>.</p> <h3 id=\"api\">API</h3> <p>There are two ways to use the <code>component</code> binding:</p> <ul> <li> <p><strong>Shorthand syntax</strong></p> <p>If you pass just a string, it is interpreted as a component name. The named component is then injected without supplying any parameters to it. Example:</p> <pre>&lt;div data-bind='component: \"my-component\"'&gt;&lt;/div&gt;\n</pre> <p>The shorthand value can also be observable. In this case, if it changes, the <code>component</code> binding will <a href=\"#disposal-and-memory-management\">dispose</a> the old component instance, and inject the newly-referenced component. Example:</p> <pre>&lt;div data-bind='component: observableWhoseValueIsAComponentName'&gt;&lt;/div&gt;\n</pre> </li> <li> <p><strong>Full syntax</strong></p> <p>To supply parameters to the component, pass an object with the following properties:</p> <ul> <li>\n<code>name</code> — the name of the component to inject. Again, this can be observable.</li> <li>\n<code>params</code> — an object that will be passed on to the component. Typically this is a key-value object containing multiple parameters, and is typically received by the component’s viewmodel constructor.</li> </ul> <p>Example:</p> <pre>&lt;div data-bind='component: {\n    name: \"shopping-cart\",\n    params: { mode: \"detailed-list\", items: productsList }\n}'&gt;&lt;/div&gt;\n</pre> </li> </ul> <p>Note that whenever a component is removed (either because the <code>name</code> observable changed, or because an enclosing control-flow binding removed the entire element), the removed component is <a href=\"#disposal-and-memory-management\">disposed</a></p> <h3 id=\"component-lifecycle\">Component lifecycle</h3> <p>When a <code>component</code> binding injects a component,</p> <ol> <li> <p><strong>Your component loaders are asked to supply the viewmodel factory and template</strong></p> <ul> <li>Multiple component loaders may be consulted, until the first one recognises the component name and supplies a viewmodel/template. This process only takes place <strong>once per component type</strong>, since Knockout caches the resulting definitions in memory.</li> <li>The default component loader supplies viewmodels/templates based on <a href=\"component-registration\">what you have registered</a>. If applicable, this is the phase where it requests any specified AMD modules from your AMD loader.</li> </ul> <p>Normally, this is an <em>asynchronous</em> process. It may involve requests to the server. For API consistency, Knockout by default ensures that the loading process completes as an asynchronous callback even if the component is already loaded and cached in memory. For more about this, and how to allow synchronous loading, see <a href=\"component-registration#controlling-synchronousasynchronous-loading\">Controlling synchronous/asynchronous loading</a>.</p> </li> <li> <p><strong>The component template is cloned and injected into the container element</strong></p> <p>Any existing content is removed and discarded.</p> </li> <li> <p><strong>If the component has a viewmodel, it is instantiated</strong></p> <p>If the viewmodel is given as a constructor function, this means Knockout calls <code>new YourViewModel(params)</code>.</p> <p>If the viewmodel is given as a <code>createViewModel</code> factory function, Knockout calls <code>createViewModel(params, componentInfo)</code>, where <code>componentInfo.element</code> is the element into which the not-yet-bound template has already been injected.</p> <p>This phase always completes synchronously (constructors and factory functions are not allowed to be asynchronous), since it occurs <em>every time a component is instantiated</em> and performance would be unacceptable if it involved waiting for network requests.</p> </li> <li> <p><strong>The viewmodel is bound to the view</strong></p> <p>Or, if the component has no viewmodel, then the view is bound to any <code>params</code> you’ve supplied to the <code>component</code> binding.</p> </li> <li> <p><strong>The component is active</strong></p> <p>Now the component is operating, and can remain on-screen for as long as needed.</p> <p>If any of the parameters passed to the component is observable, then the component can of course observe any changes, or even write back modified values. This is how it can communicate cleanly with its parent, without tightly coupling the component code to any parent that uses it.</p> </li> <li> <p><strong>The component is torn down, and the viewmodel is disposed</strong></p> <p>If the <code>component</code> binding’s <code>name</code> value changes observably, or if an enclosing control-flow binding causes the container element to be removed, then any <code>dispose</code> function on the viewmodel is called just before the container element is removed from the DOM. See also: <a href=\"#disposal-and-memory-management\">disposal and memory management</a>.</p> <p>Note: If the user navigates to an entirely different web page, browsers do this without asking any code running in the page to clean up. So in this case no <code>dispose</code> functions will be invoked. This is OK because the browser will automatically release the memory used by all objects that were in use.</p> </li> </ol> <h3 id=\"note-template-only-components\">Note: Template-only components</h3> <p>Components usually have viewmodels, but they don’t necessarily have to. A component can specify just a template.</p> <p>In this case, the object to which the component’s view is bound is the <code>params</code> object that you passed to the <code>component</code> binding. Example:</p> <pre>ko.components.register('special-offer', {\n    template: '&lt;div class=\"offer-box\" data-bind=\"text: productName\"&gt;&lt;/div&gt;'\n});\n</pre> <p>… can be injected with:</p> <pre>&lt;div data-bind='component: {\n     name: \"special-offer-callout\",\n     params: { productName: someProduct.name }\n}'&gt;&lt;/div&gt;\n</pre> <p>… or, more conveniently, as a <a href=\"component-custom-elements\">custom element</a>:</p> <pre>&lt;special-offer params='productName: someProduct.name'&gt;&lt;/special-offer&gt;\n</pre> <h3 id=\"note-using-component-without-a-container-element\">Note: Using <code>component</code> without a container element</h3> <p>Sometimes you may want to inject a component into a view without using an extra container element. You can do this using <em>containerless control flow syntax</em>, which is based on comment tags. For example,</p> <pre>&lt;!-- ko component: \"message-editor\" --&gt;\n&lt;!-- /ko --&gt;\n</pre> <p>… or passing parameters:</p> <pre>&lt;!-- ko component: {\n    name: \"message-editor\",\n    params: { initialText: \"Hello, world!\", otherParam: 123 }\n} --&gt;\n&lt;!-- /ko --&gt;\n</pre> <p>The <code>&lt;!-- ko --&gt;</code> and <code>&lt;!-- /ko --&gt;</code> comments act as start/end markers, defining a “virtual element” that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.</p> <h3 id=\"note-passing-markup-to-components\">Note: Passing markup to components</h3> <p>The element you attach a <code>component</code> binding to may contain further markup. For example,</p> <pre>&lt;div data-bind=\"component: { name: 'my-special-list', params: { items: someArrayOfPeople } }\"&gt;\n    &lt;!-- Look, here's some arbitrary markup. By default it gets stripped out\n         and is replaced by the component output. --&gt;\n    The person &lt;em data-bind=\"text: name\"&gt;&lt;/em&gt;\n    is &lt;em data-bind=\"text: age\"&gt;&lt;/em&gt; years old.\n&lt;/div&gt;\n</pre> <p>Although the DOM nodes in this element will be stripped out and not bound by default, they are not lost. Instead, they are supplied to the component (in this case, <code>my-special-list</code>), which can include them in its output however it wishes.</p> <p>This is useful if you want to build components that represent “container” UI elements, such as grids, lists, dialogs, or tab sets, which need to inject and bind arbitrary markup into a common structure. See <a href=\"component-custom-elements#passing-markup-into-components\">a complete example for custom elements</a>, which also works without custom elements using the syntax shown above.</p> <h3 id=\"disposal-and-memory-management\">Disposal and memory management</h3> <p>Optionally, your viewmodel class may have a <code>dispose</code> function. If implemented, Knockout will call this whenever the component is being torn down and removed from the DOM (e.g., because the corresponding item was removed from a <code>foreach</code>, or an <code>if</code> binding has become <code>false</code>).</p> <p>You must use <code>dispose</code> to release any resources that aren’t inherently garbage-collectable. For example:</p> <ul> <li>\n<code>setInterval</code> callbacks will continue to fire until explicitly cleared. <ul> <li>Use <code>clearInterval(handle)</code> to stop them, otherwise your viewmodel might be held in memory.</li> </ul> </li> <li>\n<code>ko.computed</code> properties continue to receive notifications from their dependencies until explicitly disposed. <ul> <li>If a dependency is on an external object, then be sure to use <code>.dispose()</code> on the computed property, otherwise it (and possibly also your viewmodel) will be held in memory. Alternatively, consider using a <a href=\"computed-pure\"><em>pure</em> computed</a> to avoid the need for manual disposal.</li> </ul> </li> <li>\n<strong>Subscriptions</strong> to observables continue to fire until explicitly disposed. <ul> <li>If you have subscribed to an external observable, be sure to use <code>.dispose()</code> on the subscription, otherwise the callback (and possibly also your viewmodel) will be held in memory.</li> </ul> </li> <li>Manually-created <strong>event handlers</strong> on external DOM elements, if created inside a <code>createViewModel</code> function (or even inside a regular component viewmodel, although to fit the MVVM pattern you shouldn’t) must be removed. <ul> <li>Of course, you don’t have to worry about releasing any event handlers created by standard Knockout bindings in your view, as KO automatically unregisters them when the elements are removed.</li> </ul> </li> </ul> <p>For example:</p> <pre>var someExternalObservable = ko.observable(123);\n\nfunction SomeComponentViewModel() {\n    this.myComputed = ko.computed(function() {\n        return someExternalObservable() + 1;\n    }, this);\n\n    this.myPureComputed = ko.pureComputed(function() {\n        return someExternalObservable() + 2;\n    }, this);\n\n    this.mySubscription = someExternalObservable.subscribe(function(val) {\n        console.log('The external observable changed to ' + val);\n    }, this);\n\n    this.myIntervalHandle = window.setInterval(function() {\n        console.log('Another second passed, and the component is still alive.');\n    }, 1000);\n}\n\nSomeComponentViewModel.prototype.dispose = function() {\n    this.myComputed.dispose();\n    this.mySubscription.dispose();\n    window.clearInterval(this.myIntervalHandle);\n    // this.myPureComputed doesn't need to be manually disposed.\n}\n\nko.components.register('your-component-name', {\n    viewModel: SomeComponentViewModel,\n    template: 'some template'\n});\n</pre> <p>It isn’t strictly necessary to dispose computeds and subscriptions that only depend on properties of the same viewmodel object, since this creates only a circular reference which JavaScript garbage collectors know how to release. However, to avoid having to remember which things need disposal, you may prefer to use <code>pureComputed</code> wherever possible, and explicitly dispose all other computeds/subscriptions whether technically necessary or not.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/component-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/component-binding.html</a>\n  </p>\n</div>\n","click-binding":"<h1>The \"click\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>click</code> binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is clicked. This is most commonly used with elements like <code>button</code>, <code>input</code>, and <code>a</code>, but actually works with any visible DOM element.</p> <h3 id=\"example\">Example</h3> <pre>&lt;div&gt;\n    You've clicked &lt;span data-bind=\"text: numberOfClicks\"&gt;&lt;/span&gt; times\n    &lt;button data-bind=\"click: incrementClickCounter\"&gt;Click me&lt;/button&gt;\n&lt;/div&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        numberOfClicks : ko.observable(0),\n        incrementClickCounter : function() {\n            var previousCount = this.numberOfClicks();\n            this.numberOfClicks(previousCount + 1);\n        }\n    };\n&lt;/script&gt;\n</pre> <p>Each time you click the button, this will invoke <code>incrementClickCounter()</code> on the view model, which in turn changes the view model state, which causes the UI to update.</p> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>The function you want to bind to the element’s <code>click</code> event.</p> <p>You can reference any JavaScript function - it doesn’t have to be a function on your view model. You can reference a function on any object by writing <code>click: someObject.someFunction</code>.</p> </li> <li> <p>Additional parameters</p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-1-passing-a-current-item-as-a-parameter-to-your-handler-function\">Note 1: Passing a “current item” as a parameter to your handler function</h3> <p>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you’re rendering some UI for each item in a collection, and you need to know which item’s UI was clicked. For example,</p> <pre>&lt;ul data-bind=\"foreach: places\"&gt;\n    &lt;li&gt;\n        &lt;span data-bind=\"text: $data\"&gt;&lt;/span&gt;\n        &lt;button data-bind=\"click: $parent.removePlace\"&gt;Remove&lt;/button&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n\n &lt;script type=\"text/javascript\"&gt;\n     function MyViewModel() {\n         var self = this;\n         self.places = ko.observableArray(['London', 'Paris', 'Tokyo']);\n\n         // The current item will be passed as the first parameter, so we know which place to remove\n         self.removePlace = function(place) {\n             self.places.remove(place)\n         }\n     }\n     ko.applyBindings(new MyViewModel());\n&lt;/script&gt;\n</pre> <p>Two points to note about this example:</p> <ul> <li>If you’re inside a nested <a href=\"binding-context\">binding context</a>, for example if you’re inside a <code>foreach</code> or a <code>with</code> block, but your handler function is on the root viewmodel or some other parent context, you’ll need to use a prefix such as <code>$parent</code> or <code>$root</code> to locate the handler function.</li> <li>In your viewmodel, it’s often useful to declare <code>self</code> (or some other variable) as an alias for <code>this</code>. Doing so avoids any problems with <code>this</code> being redefined to mean something else in event handlers or Ajax request callbacks.</li> </ul> <h3 id=\"note-2-accessing-the-event-object-or-passing-more-parameters\">Note 2: Accessing the event object, or passing more parameters</h3> <p>In some scenarios, you may need to access the DOM event object associated with your click event. Knockout will pass the event as the second parameter to your function, as in this example:</p> <pre>&lt;button data-bind=\"click: myFunction\"&gt;\n    Click me\n&lt;/button&gt;\n\n &lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        myFunction: function(data, event) {\n            if (event.shiftKey) {\n                //do something different when user has shift key down\n            } else {\n                //do normal action\n            }\n        }\n    };\n    ko.applyBindings(viewModel);\n&lt;/script&gt;\n</pre> <p>If you need to pass more parameters, one way to do it is by wrapping your handler in a function literal that takes in a parameter, as in this example:</p> <pre>&lt;button data-bind=\"click: function(data, event) { myFunction('param1', 'param2', data, event) }\"&gt;\n    Click me\n&lt;/button&gt;\n</pre> <p>Now, KO will pass the data and event objects to your function literal, which are then available to be passed to your handler.</p> <p>Alternatively, if you prefer to avoid the function literal in your view, you can use the <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\">bind</a> function, which attaches specific parameter values to a function reference:</p> <pre>&lt;button data-bind=\"click: myFunction.bind($data, 'param1', 'param2')\"&gt;\n    Click me\n&lt;/button&gt;\n</pre> <h3 id=\"note-3-allowing-the-default-click-action\">Note 3: Allowing the default click action</h3> <p>By default, Knockout will prevent the click event from taking any default action. This means that if you use the <code>click</code> binding on an <code>a</code> tag (a link), for example, the browser will only call your handler function and will <em>not</em> navigate to the link’s <code>href</code>. This is a useful default because when you use the <code>click</code> binding, it’s normally because you’re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.</p> <p>However, if you <em>do</em> want to let the default click action proceed, just return <code>true</code> from your <code>click</code> handler function.</p> <h3 id=\"note-4-preventing-the-event-from-bubbling\">Note 4: Preventing the event from bubbling</h3> <p>By default, Knockout will allow the click event to continue to bubble up to any higher level event handlers. For example, if your element and a parent of that element are both handling the <code>click</code> event, then the click handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named <code>clickBubble</code> and passing false to it, as in this example:</p> <pre>    &lt;div data-bind=\"click: myDivHandler\"&gt;\n        &lt;button data-bind=\"click: myButtonHandler, clickBubble: false\"&gt;\n            Click me\n        &lt;/button&gt;\n    &lt;/div&gt;\n</pre> <p>Normally, in this case <code>myButtonHandler</code> would be called first, then the click event would bubble up to <code>myDivHandler</code>. However, the <code>clickBubble</code> binding that we added with a value of <code>false</code> prevents the event from making it past <code>myButtonHandler</code>.</p> <h3 id=\"note-5-interaction-with-jquery\">Note 5: Interaction with jQuery</h3> <p>Knockout will use jQuery, if it is present, for handling UI events such as <code>click</code>. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling <code>ko.applyBindings</code>:</p> <pre>ko.options.useOnlyNativeEvents = true;\n</pre> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/click-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/click-binding.html</a>\n  </p>\n</div>\n","event-binding":"<h1>The \"event\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>event</code> binding allows you to add an event handler for a specified event so that your chosen JavaScript function will be invoked when that event is triggered for the associated DOM element. This can be used to bind to any event, such as <code>keypress</code>, <code>mouseover</code> or <code>mouseout</code>.</p> <h3 id=\"example\">Example</h3> <pre>&lt;div&gt;\n    &lt;div data-bind=\"event: { mouseover: enableDetails, mouseout: disableDetails }\"&gt;\n        Mouse over me\n    &lt;/div&gt;\n    &lt;div data-bind=\"visible: detailsEnabled\"&gt;\n        Details\n    &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        detailsEnabled: ko.observable(false),\n        enableDetails: function() {\n            this.detailsEnabled(true);\n        },\n        disableDetails: function() {\n            this.detailsEnabled(false);\n        }\n    };\n    ko.applyBindings(viewModel);\n&lt;/script&gt;\n</pre> <p>Now, moving your mouse pointer on or off of the first element will invoke methods on the view model to toggle the <code>detailsEnabled</code> observable. The second element reacts to changes to the value of <code>detailsEnabled</code> by either showing or hiding itself.</p> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>You should pass a JavaScript object in which the property names correspond to event names, and the values correspond to the function that you want to bind to the event.</p> <p>You can reference any JavaScript function - it doesn’t have to be a function on your view model. You can reference a function on any object by writing <code>event { mouseover: someObject.someFunction }</code>.</p> </li> <li> <p>Additional parameters</p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-1-passing-a-current-item-as-a-parameter-to-your-handler-function\">Note 1: Passing a “current item” as a parameter to your handler function</h3> <p>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you’re rendering some UI for each item in a collection, and you need to know which item the event refers to. For example,</p> <pre>&lt;ul data-bind=\"foreach: places\"&gt;\n    &lt;li data-bind=\"text: $data, event: { mouseover: $parent.logMouseOver }\"&gt; &lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;You seem to be interested in: &lt;span data-bind=\"text: lastInterest\"&gt; &lt;/span&gt;&lt;/p&gt;\n\n &lt;script type=\"text/javascript\"&gt;\n     function MyViewModel() {\n         var self = this;\n         self.lastInterest = ko.observable();\n         self.places = ko.observableArray(['London', 'Paris', 'Tokyo']);\n\n         // The current item will be passed as the first parameter, so we know which place was hovered over\n         self.logMouseOver = function(place) {\n             self.lastInterest(place);\n         }\n     }\n     ko.applyBindings(new MyViewModel());\n&lt;/script&gt;\n</pre> <p>Two points to note about this example:</p> <ul> <li>If you’re inside a nested <a href=\"binding-context\">binding context</a>, for example if you’re inside a <code>foreach</code> or a <code>with</code> block, but your handler function is on the root viewmodel or some other parent context, you’ll need to use a prefix such as <code>$parent</code> or <code>$root</code> to locate the handler function.</li> <li>In your viewmodel, it’s often useful to declare <code>self</code> (or some other variable) as an alias for <code>this</code>. Doing so avoids any problems with <code>this</code> being redefined to mean something else in event handlers or Ajax request callbacks.</li> </ul> <h3 id=\"note-2-accessing-the-event-object-or-passing-more-parameters\">Note 2: Accessing the event object, or passing more parameters</h3> <p>In some scenarios, you may need to access the DOM event object associated with your event. Knockout will pass the event as the second parameter to your function, as in this example:</p> <pre>&lt;div data-bind=\"event: { mouseover: myFunction }\"&gt;\n    Mouse over me\n&lt;/div&gt;\n\n &lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        myFunction: function(data, event) {\n            if (event.shiftKey) {\n                //do something different when user has shift key down\n            } else {\n                //do normal action\n            }\n        }\n    };\n    ko.applyBindings(viewModel);\n&lt;/script&gt;\n</pre> <p>If you need to pass more parameters, one way to do it is by wrapping your handler in a function literal that takes in a parameter, as in this example:</p> <pre>&lt;div data-bind=\"event: { mouseover: function(data, event) { myFunction('param1', 'param2', data, event) } }\"&gt;\n    Mouse over me\n&lt;/div&gt;\n</pre> <p>Now, KO will pass the event to your function literal, which is then available to be passed to your handler.</p> <p>Alternatively, if you prefer to avoid the function literal in your view, you can use the <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\">bind</a> function, which attaches specific parameter values to a function reference:</p> <pre>&lt;button data-bind=\"event: { mouseover: myFunction.bind($data, 'param1', 'param2') }\"&gt;\n    Click me\n&lt;/button&gt;\n</pre> <h3 id=\"note-3-allowing-the-default-action\">Note 3: Allowing the default action</h3> <p>By default, Knockout will prevent the event from taking any default action. For example if you use the <code>event</code> binding to capture the <code>keypress</code> event of an <code>input</code> tag, the browser will only call your handler function and will <em>not</em> add the value of the key to the <code>input</code> element’s value. A more common example is using <a href=\"click-binding\">the click binding</a>, which internally uses this binding, where your handler function will be called, but the browser will <em>not</em> navigate to the link’s <code>href</code>. This is a useful default because when you use the <code>click</code> binding, it’s normally because you’re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.</p> <p>However, if you <em>do</em> want to let the default action proceed, just return <code>true</code> from your <code>event</code> handler function.</p> <h3 id=\"note-4-preventing-the-event-from-bubbling\">Note 4: Preventing the event from bubbling</h3> <p>By default, Knockout will allow the event to continue to bubble up to any higher level event handlers. For example, if your element is handling a <code>mouseover</code> event and a parent of the element also handles that same event, then the event handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named <code>youreventBubble</code> and passing false to it, as in this example:</p> <pre>    &lt;div data-bind=\"event: { mouseover: myDivHandler }\"&gt;\n        &lt;button data-bind=\"event: { mouseover: myButtonHandler }, mouseoverBubble: false\"&gt;\n            Click me\n        &lt;/button&gt;\n    &lt;/div&gt;\n</pre> <p>Normally, in this case <code>myButtonHandler</code> would be called first, then the event would bubble up to <code>myDivHandler</code>. However, the <code>mouseoverBubble</code> binding that we added with a value of <code>false</code> prevents the event from making it past <code>myButtonHandler</code>.</p> <h3 id=\"note-5-interaction-with-jquery\">Note 5: Interaction with jQuery</h3> <p>Knockout will use jQuery, if it is present, for handling UI events. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling <code>ko.applyBindings</code>:</p> <pre>ko.options.useOnlyNativeEvents = true;\n</pre> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/event-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/event-binding.html</a>\n  </p>\n</div>\n","enable-binding":"<h1>The \"enable\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>enable</code> binding causes the associated DOM element to be enabled only when the parameter value is <code>true</code>. This is useful with form elements like <code>input</code>, <code>select</code>, and <code>textarea</code>.</p> <h3 id=\"example\">Example</h3> <pre>&lt;p&gt;\n    &lt;input type='checkbox' data-bind=\"checked: hasCellphone\" /&gt;\n    I have a cellphone\n&lt;/p&gt;\n&lt;p&gt;\n    Your cellphone number:\n    &lt;input type='text' data-bind=\"value: cellphoneNumber, enable: hasCellphone\" /&gt;\n&lt;/p&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        hasCellphone : ko.observable(false),\n        cellphoneNumber: \"\"\n    };\n&lt;/script&gt;\n</pre> <p>In this example, the “Your cellphone number” text box will initially be disabled. It will be enabled only when the user checks the box labelled “I have a cellphone”.</p> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>A value that controls whether or not the associated DOM element should be enabled.</p> <p>Non-boolean values are interpreted loosely as boolean. For example, <code>0</code> and <code>null</code> are treated as <code>false</code>, whereas <code>21</code> and non-<code>null</code> objects are treated as <code>true</code>.</p> <p>If your parameter references an observable value, the binding will update the enabled/disabled state whenever the observable value changes. If the parameter doesn’t reference an observable value, it will only set the state once and will not do so again later. </p> </li> <li> <p>Additional parameters </p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-using-arbitrary-javascript-expressions\">Note: Using arbitrary JavaScript expressions</h3> <p>You’re not limited to referencing variables - you can reference arbitrary expressions to control an element’s enabledness. For example,</p> <pre>&lt;button data-bind=\"enable: parseAreaCode(viewModel.cellphoneNumber()) != '555'\"&gt;\n    Do something\n&lt;/button&gt;\n</pre> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/enable-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/enable-binding.html</a>\n  </p>\n</div>\n","disable-binding":"<h1>The \"disable\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>disable</code> binding causes the associated DOM element to be disabled only when the parameter value is <code>true</code>. This is useful with form elements like <code>input</code>, <code>select</code>, and <code>textarea</code>.</p> <p>This is the mirror image of the <code>enable</code> binding. For more information, see <a href=\"enable-binding\">documentation for the <code>enable</code> binding</a>, because <code>disable</code> works in exactly the same way except that it negates whatever parameter you pass to it.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/disable-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/disable-binding.html</a>\n  </p>\n</div>\n","foreach-binding":"<h1>The \"foreach\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>foreach</code> binding duplicates a section of markup for each entry in an array, and binds each copy of that markup to the corresponding array item. This is especially useful for rendering lists or tables.</p> <p>Assuming your array is an <a href=\"observablearrays\">observable array</a>, whenever you later add, remove, or re-order array entries, the binding will efficiently update the UI to match - inserting or removing more copies of the markup, or re-ordering existing DOM elements, without affecting any other DOM elements. This is far faster than regenerating the entire <code>foreach</code> output after each array change.</p> <p>Of course, you can arbitrarily nest any number of <code>foreach</code> bindings along with other control-flow bindings such as <code>if</code> and <code>with</code>.</p> <h3 id=\"example-1-iterating-over-an-array\">Example 1: Iterating over an array</h3> <p>This example uses <code>foreach</code> to produce a read-only table with a row for each array entry.</p> <pre>&lt;table&gt;\n    &lt;thead&gt;\n        &lt;tr&gt;&lt;th&gt;First name&lt;/th&gt;&lt;th&gt;Last name&lt;/th&gt;&lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody data-bind=\"foreach: people\"&gt;\n        &lt;tr&gt;\n            &lt;td data-bind=\"text: firstName\"&gt;&lt;/td&gt;\n            &lt;td data-bind=\"text: lastName\"&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    ko.applyBindings({\n        people: [\n            { firstName: 'Bert', lastName: 'Bertington' },\n            { firstName: 'Charles', lastName: 'Charlesforth' },\n            { firstName: 'Denise', lastName: 'Dentiste' }\n        ]\n    });\n&lt;/script&gt;\n</pre> <h3 id=\"example-2-live-example-with-addremove\">Example 2: Live example with add/remove</h3> <p>The following example shows that, if your array is observable, then the UI will be kept in sync with changes to that array.</p> <div class=\"liveExample\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n&lt;h4&gt;People&lt;/h4&gt;\n&lt;ul data-bind=\"foreach: people\"&gt;\n    &lt;li&gt;\n        Name at position &lt;span data-bind=\"text: $index\"&gt; &lt;/span&gt;:\n        &lt;span data-bind=\"text: name\"&gt; &lt;/span&gt;\n        &lt;a href=\"#\" data-bind=\"click: $parent.removePerson\"&gt;Remove&lt;/a&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n&lt;button data-bind=\"click: addPerson\"&gt;Add&lt;/button&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\nfunction AppViewModel() {\n    var self = this;\n\n    self.people = ko.observableArray([\n        { name: 'Bert' },\n        { name: 'Charles' },\n        { name: 'Denise' }\n    ]);\n\n    self.addPerson = function() {\n        self.people.push({ name: \"New at \" + new Date() });\n    };\n\n    self.removePerson = function() {\n        self.people.remove(this);\n    }\n}\n\nko.applyBindings(new AppViewModel());\n</pre> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>Pass the array that you wish to iterate over. The binding will output a section of markup for each entry.</p> <p>Alternatively, pass a JavaScript object literal with a property called <code>data</code> which is the array you wish to iterate over. The object literal may also have other properties, such as <code>afterAdd</code> or <code>includeDestroyed</code> — see below for details of these extra options and examples of their use.</p> <p>If the array you supply is observable, the <code>foreach</code> binding will respond to any future changes in the array’s contents by adding or removing corresponding sections of markup in the DOM.</p> </li> <li> <p>Additional parameters</p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-1-referring-to-each-array-entry-using-data\">Note 1: Referring to each array entry using $data</h3> <p>As shown in the above examples, bindings within the <code>foreach</code> block can refer to properties on the array entries. For example, <a href=\"#example-1-iterating-over-an-array\">Example 1</a> referenced the <code>firstName</code> and <code>lastName</code> properties on each array entry.</p> <p>But what if you want to refer to the array entry itself (not just one of its properties)? In that case, you can use the <a href=\"binding-context\">special context property</a> <code>$data</code>. Within a <code>foreach</code> block, it means “the current item”. For example,</p> <pre>&lt;ul data-bind=\"foreach: months\"&gt;\n    &lt;li&gt;\n        The current item is: &lt;b data-bind=\"text: $data\"&gt;&lt;/b&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    ko.applyBindings({\n        months: [ 'Jan', 'Feb', 'Mar', 'etc' ]\n    });\n&lt;/script&gt;\n</pre> <p>If you wanted, you could use <code>$data</code> as a prefix when referencing properties on each entry. For example, you could rewrite part of <a href=\"#example-1-iterating-over-an-array\">Example 1</a> as follows:</p> <pre>&lt;td data-bind=\"text: $data.firstName\"&gt;&lt;/td&gt;\n</pre> <p>… but you don’t have to, because <code>firstName</code> will be evaluated within the context of <code>$data</code> by default anyway.</p> <h3 id=\"note-2-using-index-parent-and-other-context-properties\">Note 2: Using $index, $parent, and other context properties</h3> <p>As you can see from Example 2 above, it’s possible to use <code>$index</code> to refer to the zero-based index of the current array item. <code>$index</code> is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</p> <p>Similarly, you can use <code>$parent</code> to refer to data from outside the <code>foreach</code>, e.g.:</p> <pre>&lt;h1 data-bind=\"text: blogPostTitle\"&gt;&lt;/h1&gt;\n&lt;ul data-bind=\"foreach: likes\"&gt;\n    &lt;li&gt;\n        &lt;b data-bind=\"text: name\"&gt;&lt;/b&gt; likes the blog post &lt;b data-bind=\"text: $parent.blogPostTitle\"&gt;&lt;/b&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n</pre> <p>For more information about <code>$index</code> and other context properties such as <code>$parent</code>, see documentation for <a href=\"binding-context\">binding context properties</a>.</p> <h3 id=\"note-3-using-as-to-give-an-alias-to-foreach-items\">Note 3: Using “as” to give an alias to “foreach” items</h3> <p>As described in Note 1, you can refer to each array entry using the <code>$data</code> <a href=\"binding-context\">context variable</a>. In some cases though, it may be useful to give the current item a more descriptive name using the <code>as</code> option like:</p> <pre>&lt;ul data-bind=\"foreach: { data: people, as: 'person' }\"&gt;&lt;/ul&gt;\n</pre> <p>Now anywhere inside this <code>foreach</code> loop, bindings will be able to refer to <code>person</code> to access the current array item, from the <code>people</code> array, that is being rendered. This can be especially useful in scenarios where you have nested <code>foreach</code> blocks and you need to refer to an item declared at a higher level in the hierarchy. For example:</p> <pre>&lt;ul data-bind=\"foreach: { data: categories, as: 'category' }\"&gt;\n    &lt;li&gt;\n        &lt;ul data-bind=\"foreach: { data: items, as: 'item' }\"&gt;\n            &lt;li&gt;\n                &lt;span data-bind=\"text: category.name\"&gt;&lt;/span&gt;:\n                &lt;span data-bind=\"text: item\"&gt;&lt;/span&gt;\n            &lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;script&gt;\n    var viewModel = {\n        categories: ko.observableArray([\n            { name: 'Fruit', items: [ 'Apple', 'Orange', 'Banana' ] },\n            { name: 'Vegetables', items: [ 'Celery', 'Corn', 'Spinach' ] }\n        ])\n    };\n    ko.applyBindings(viewModel);\n&lt;/script&gt;\n</pre> <p>Tip: Remember to pass a <em>string literal value</em> to <code>as</code> (e.g., <code>as: 'category'</code>, <em>not</em> <code>as: category</code>), because you are giving a name for a new variable, not reading the value of a variable that already exists.</p> <h3 id=\"note-4-using-foreach-without-a-container-element\">Note 4: Using foreach without a container element</h3> <p>In some cases, you might want to duplicate a section of markup, but you don’t have any container element on which to put a <code>foreach</code> binding. For example, you might want to generate the following:</p> <pre>&lt;ul&gt;\n    &lt;li class=\"header\"&gt;Header item&lt;/li&gt;\n    &lt;!-- The following are generated dynamically from an array --&gt;\n    &lt;li&gt;Item A&lt;/li&gt;\n    &lt;li&gt;Item B&lt;/li&gt;\n    &lt;li&gt;Item C&lt;/li&gt;\n&lt;/ul&gt;\n</pre> <p>In this example, there isn’t anywhere to put a normal <code>foreach</code> binding. You can’t put it on the <code>&lt;ul&gt;</code> (because then you’d be duplicating the header item), nor can you put a further container inside the <code>&lt;ul&gt;</code> (because only <code>&lt;li&gt;</code> elements are allowed inside <code>&lt;ul&gt;</code>s).</p> <p>To handle this, you can use the <em>containerless control flow syntax</em>, which is based on comment tags. For example,</p> <pre>&lt;ul&gt;\n    &lt;li class=\"header\"&gt;Header item&lt;/li&gt;\n    &lt;!-- ko foreach: myItems --&gt;\n        &lt;li&gt;Item &lt;span data-bind=\"text: $data\"&gt;&lt;/span&gt;&lt;/li&gt;\n    &lt;!-- /ko --&gt;\n&lt;/ul&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    ko.applyBindings({\n        myItems: [ 'A', 'B', 'C' ]\n    });\n&lt;/script&gt;\n</pre> <p>The <code>&lt;!-- ko --&gt;</code> and <code>&lt;!-- /ko --&gt;</code> comments act as start/end markers, defining a “virtual element” that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.</p> <h3 id=\"note-5-how-array-changes-are-detected-and-handled\">Note 5: How array changes are detected and handled</h3> <p>When you modify the contents of your model array (by adding, moving, or deleting its entries), the <code>foreach</code> binding uses an efficient differencing algorithm to figure out what has changed, so it can then update the DOM to match. This means it can handle arbitrary combinations of simulaneous changes.</p> <ul> <li>When you <strong>add</strong> array entries, <code>foreach</code> will render new copies of your template and insert them into the existing DOM</li> <li>When you <strong>delete</strong> array entries, <code>foreach</code> will simply remove the corresponding DOM elements</li> <li>When you <strong>reorder</strong> array entries (retaining the same object instances), <code>foreach</code> will typically just move the corresponding DOM elements into their new position</li> </ul> <p>Note that reordering detection is not guaranteed: to ensure the algorithm completes quickly, it is optimized to detect “simple” movements of small numbers of array entries. If the algorithm detects too many simultaneous reorderings combined with unrelated insertions and deletions, then for speed it can choose to regard a reordering as an “delete” plus an “add” instead of a single “move”, and in that case the corresponding DOM elements will be torn down and recreated. Most developers won’t encounter this edge case, and even if you do, the end-user experience will usually be identical.</p> <h3 id=\"note-6-destroyed-entries-are-hidden-by-default\">Note 6: Destroyed entries are hidden by default</h3> <p>Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a <em>non-destructive delete</em>. For details of how to do this, see <a href=\"observablearrays#destroy-and-destroyall\">the destroy function on <code>observableArray</code></a>.</p> <p>By default, the <code>foreach</code> binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, use the <code>includeDestroyed</code> option. For example,</p> <pre>&lt;div data-bind='foreach: { data: myArray, includeDestroyed: true }'&gt;\n    ...\n&lt;/div&gt;\n</pre> <h3 id=\"note-7-post-processing-or-animating-the-generated-dom-elements\">Note 7: Post-processing or animating the generated DOM elements</h3> <p>If you need to run some further custom logic on the generated DOM elements, you can use any of the <code>afterRender</code>/<code>afterAdd</code>/<code>beforeRemove</code>/<code>beforeMove</code>/<code>afterMove</code> callbacks described below.</p> <blockquote> <p><strong>Note:</strong> These callbacks are <em>only</em> intended for triggering animations related to changes in a list. If your goal is actually to attach other behaviors to new DOM elements when they have been added (e.g., event handlers, or to activate third-party UI controls), then your work will be much easier if you implement that new behavior as a <a href=\"custom-bindings\">custom binding</a> instead, because then you can use that behavior anywhere, independently of the <code>foreach</code> binding.</p> </blockquote> <p>Here’s a trivial example that uses <code>afterAdd</code> to apply the classic “yellow fade” effect to newly-added items. It requires the <a href=\"https://github.com/jquery/jquery-color\">jQuery Color plugin</a> to enable animation of background colors.</p> <pre>&lt;ul data-bind=\"foreach: { data: myItems, afterAdd: yellowFadeIn }\"&gt;\n    &lt;li data-bind=\"text: $data\"&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;button data-bind=\"click: addItem\"&gt;Add&lt;/button&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    ko.applyBindings({\n        myItems: ko.observableArray([ 'A', 'B', 'C' ]),\n        yellowFadeIn: function(element, index, data) {\n            $(element).filter(\"li\")\n                      .animate({ backgroundColor: 'yellow' }, 200)\n                      .animate({ backgroundColor: 'white' }, 800);\n        },\n        addItem: function() { this.myItems.push('New item'); }\n    });\n&lt;/script&gt;\n</pre> <p>Full details:</p> <ul> <li> <p><code>afterRender</code> — is invoked each time the <code>foreach</code> block is duplicated and inserted into the document, both when <code>foreach</code> first initializes, and when new entries are added to the associated array later. Knockout will supply the following parameters to your callback:</p> <ol> <li>An array of the inserted DOM elements</li> <li>The data item against which they are being bound</li> </ol> </li> <li> <p><code>afterAdd</code> — is like <code>afterRender</code>, except it is invoked only when new entries are added to your array (and <em>not</em> when <code>foreach</code> first iterates over your array’s initial contents). A common use for <code>afterAdd</code> is to call a method such as jQuery’s <code>$(domNode).fadeIn()</code> so that you get animated transitions whenever items are added. Knockout will supply the following parameters to your callback:</p> <ol> <li>A DOM node being added to the document</li> <li>The index of the added array element</li> <li>The added array element</li> </ol> </li> <li> <p><code>beforeRemove</code> — is invoked when an array item has been removed, but before the corresponding DOM nodes have been removed. If you specify a <code>beforeRemove</code> callback, then <em>it becomes your responsibility to remove the DOM nodes</em>. The obvious use case here is calling something like jQuery’s <code>$(domNode).fadeOut()</code> to animate the removal of the corresponding DOM nodes — in this case, Knockout cannot know how soon it is allowed to physically remove the DOM nodes (who knows how long your animation will take?), so it is up to you to remove them. Knockout will supply the following parameters to your callback:</p> <ol> <li>A DOM node that you should remove</li> <li>The index of the removed array element</li> <li>The removed array element</li> </ol> </li> <li> <p><code>beforeMove</code> — is invoked when an array item has changed position in the array, but before the corresponding DOM nodes have been moved. Note that <code>beforeMove</code> applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. You could use <code>beforeMove</code> to store the original screen coordinates of the affected elements so that you can animate their movements in the <code>afterMove</code> callback. Knockout will supply the following parameters to your callback:</p> <ol> <li>A DOM node that may be about to move</li> <li>The index of the moved array element</li> <li>The moved array element</li> </ol> </li> <li> <p><code>afterMove</code> — is invoked after an array item has changed position in the array, and after <code>foreach</code> has updated the DOM to match. Note that <code>afterMove</code> applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. Knockout will supply the following parameters to your callback:</p> <ol> <li>A DOM node that may have moved</li> <li>The index of the moved array element</li> <li>The moved array element</li> </ol> </li> </ul> <p>For examples of <code>afterAdd</code> and <code>beforeRemove</code> see <a href=\"http://knockoutjs.com/examples/animatedTransitions.html\">animated transitions</a>.</p> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/foreach-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/foreach-binding.html</a>\n  </p>\n</div>\n","submit-binding":"<h1>The \"submit\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>submit</code> binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is submitted. Typically you will only want to use this on <code>form</code> elements.</p> <p>When you use the <code>submit</code> binding on a form, Knockout will prevent the browser’s default submit action for that form. In other words, the browser will call your handler function but will <em>not</em> submit the form to the server. This is a useful default because when you use the <code>submit</code> binding, it’s normally because you’re using the form as an interface to your view model, not as a regular HTML form. If you <em>do</em> want to let the form submit like a normal HTML form, just return <code>true</code> from your <code>submit</code> handler.</p> <h3 id=\"example\">Example</h3> <pre>&lt;form data-bind=\"submit: doSomething\"&gt;\n    ... form contents go here ...\n    &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        doSomething : function(formElement) {\n            // ... now do something\n        }\n    };\n&lt;/script&gt;\n</pre> <p>As illustrated in this example, KO passes the form element as a parameter to your submit handler function. You can ignore that parameter if you want, or there are various ways you might want to use it, for example:</p> <ul> <li> <p>Extracting additional data or state from the form elements</p> </li> <li> <p>Triggering UI-level validation using a library such as <a href=\"https://github.com/jzaefferer/jquery-validation\">jQuery Validation</a>, using code similar to the following snippet: <code>if ($(formElement).valid()) { /* do something */ }</code>.</p> </li> </ul> <h3 id=\"why-not-just-put-a-click-handler-on-the-submit-button\">Why not just put a <code>click</code> handler on the submit button?</h3> <p>Instead of using <code>submit</code> on the form, you <em>could</em> use <code>click</code> on the submit button. However, <code>submit</code> has the advantage that it also captures alternative ways to submit the form, such as pressing the <em>enter</em> key while typing into a text box.</p> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>The function you want to bind to the element’s <code>submit</code> event.</p> <p>You can reference any JavaScript function - it doesn’t have to be a function on your view model. You can reference a function on any object by writing <code>submit: someObject.someFunction</code>.</p> <p>Functions on your view model are slightly special because you can reference them by name, i.e., you can write <code>submit: doSomething</code> and <em>don’t</em> have to write <code>submit: viewModel.doSomething</code> (though technically that’s also valid).</p> </li> <li> <p>Additional parameters</p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"notes\">Notes</h3> <p>For information about how to pass additional parameters to your submit handler function, or how to control the <code>this</code> handle when invoking functions that aren’t on your view model, see the notes relating to the <a href=\"click-binding\">click binding</a>. All the notes on that page apply to <code>submit</code> handlers too.</p> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/submit-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/submit-binding.html</a>\n  </p>\n</div>\n","value-binding":"<h1>The \"value\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>value</code> binding links the associated DOM element’s value with a property on your view model. This is typically useful with form elements such as <code>&lt;input&gt;</code>, <code>&lt;select&gt;</code> and <code>&lt;textarea&gt;</code>.</p> <p>When the user edits the value in the associated form control, it updates the value on your view model. Likewise, when you update the value in your view model, this updates the value of the form control on screen.</p> <p>Note: If you’re working with checkboxes or radio buttons, use <a href=\"checked-binding\">the <code>checked</code> binding</a> to read and write your element’s checked state, not the <code>value</code> binding.</p> <h3 id=\"example\">Example</h3> <pre>&lt;p&gt;Login name: &lt;input data-bind=\"value: userName\" /&gt;&lt;/p&gt;\n&lt;p&gt;Password: &lt;input type=\"password\" data-bind=\"value: userPassword\" /&gt;&lt;/p&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        userName: ko.observable(\"\"),        // Initially blank\n        userPassword: ko.observable(\"abc\"), // Prepopulate\n    };\n&lt;/script&gt;\n</pre> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>KO sets the element’s <code>value</code> property to your parameter value. Any previous value will be overwritten.</p> <p>If this parameter is an observable value, the binding will update the element’s value whenever the value changes. If the parameter isn’t observable, it will only set the element’s value once and will not update it again later.</p> <p>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to <code>yourParameter.toString()</code> (that’s usually not very useful, so it’s best to supply string or numeric values).</p> <p>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified and a user transfers focus to another DOM node (i.e., on the <code>change</code> event), but you can also trigger updates based on other events by using the <code>valueUpdate</code> parameter described below.</p> </li> <li> <p>Additional parameters</p> <ul> <li> <p><code>valueUpdate</code></p> <p>If your binding also includes a parameter called <code>valueUpdate</code>, this defines additional browser events KO should use to detect changes besides the <code>change</code> event. The following string values are the most commonly useful choices:</p> <ul> <li>\n<code>\"input\"</code> - updates your view model when the value of an <code>&lt;input&gt;</code> or <code>&lt;textarea&gt;</code> element changes. Note that this event is only raised by reasonably modern browsers (e.g., IE 9+).</li> <li>\n<code>\"keyup\"</code> - updates your view model when the user releases a key</li> <li>\n<code>\"keypress\"</code> - updates your view model when the user has typed a key. Unlike <code>keyup</code>, this updates repeatedly while the user holds a key down</li> <li>\n<code>\"afterkeydown\"</code> - updates your view model as soon as the user begins typing a character. This works by catching the browser’s <code>keydown</code> event and handling the event asynchronously. This does not work in some mobile browsers.</li> </ul> </li> <li> <p><code>valueAllowUnset</code></p> <p>See <a href=\"#using-valueallowunset-with-select-elements\">Note 2</a> below. Note that <code>valueAllowUnset</code> is only applicable when using <code>value</code> to control selection on a <code>&lt;select&gt;</code> element. On other elements it has no effect.</p> </li> </ul> </li> </ul> <h3 id=\"note-1-getting-value-updates-instantly-from-inputs\">Note 1: Getting value updates instantly from inputs</h3> <p>If you are trying to bind an <code>&lt;input type=\"text\" /&gt;</code> or <code>&lt;textarea&gt;</code> to get instant updates to your viewmodel, use the <a href=\"textinput-binding\">the <code>textInput</code> binding</a>. It has better support for browser edge cases than any combination of <code>valueUpdate</code> options.</p> <h3 id=\"note-2-working-with-drop-down-lists-ie-select-elements\">Note 2: Working with drop-down lists (i.e., <code>&lt;select&gt;</code> elements)</h3> <p>Knockout has special support for drop-down lists (i.e., <code>&lt;select&gt;</code> elements). The <code>value</code> binding works in conjunction with the <code>options</code> binding to let you read and write values that are arbitrary JavaScript objects, not just string values. This is very useful if you want to let the user select from a set of model objects. For examples of this, see <a href=\"options-binding\">the <code>options</code> binding</a> or for handling multi-select lists, see the documentation for <a href=\"selectedoptions-binding\">the <code>selectedOptions</code> binding</a>.</p> <p>You can also use the <code>value</code> binding with a <code>&lt;select&gt;</code> element that does not use the <code>options</code> binding. In this case, you can choose to specify your <code>&lt;option&gt;</code> elements in markup or build them using the <code>foreach</code> or <code>template</code> bindings. You can even nest options within <code>&lt;optgroup&gt;</code> elements and Knockout will set the selected value appropriately.</p> <h4 id=\"using-valueallowunset-with-select-elements\">Using <code>valueAllowUnset</code> with <code>&lt;select&gt;</code> elements</h4> <p>Normally, when you use the <code>value</code> binding on a <code>&lt;select&gt;</code> element, it means that you want the associated model value to describe which item in the <code>&lt;select&gt;</code> is selected. But what happens if you set the model value to something that has no corresponding entry in the list? The default behavior is for Knockout to overwrite your model value to reset it to whatever is already selected in the dropdown, thereby preventing the model and UI from getting out of sync.</p> <p>However, sometimes you might not want that behavior. If instead you want Knockout to allow your model observable to take values that have no corresponding entry in the <code>&lt;select&gt;</code>, then specify <code>valueAllowUnset: true</code>. In this case, whenever your model value cannot be represented in the <code>&lt;select&gt;</code>, then the <code>&lt;select&gt;</code> simply has no selected value at that time, which is visually represented by it being blank. When the user later selects an entry from the dropdown, this will be written to your model as usual. For example:</p> <pre>&lt;p&gt;\n    Select a country:\n    &lt;select data-bind=\"options: countries,\n                       optionsCaption: 'Choose one...',\n                       value: selectedCountry,\n                       valueAllowUnset: true\"&gt;&lt;/select&gt;\n&lt;/p&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        countries: ['Japan', 'Bolivia', 'New Zealand'],\n        selectedCountry: ko.observable('Latvia')\n    };\n&lt;/script&gt;\n</pre> <p>In the above example, <code>selectedCountry</code> will retain the value <code>'Latvia'</code>, and the dropdown will be blank, because there is no corresponding option.</p> <p>If <code>valueAllowUnset</code> had not been enabled, then Knockout would have overwritten <code>selectedCountry</code> with <code>undefined</code>, so that it would match the value of the <code>'Choose one...'</code> caption entry.</p> <h3 id=\"note-3-updating-observable-and-non-observable-property-values\">Note 3: Updating observable and non-observable property values</h3> <p>If you use <code>value</code> to link a form element to an observable property, KO is able to set up a 2-way binding so that changes to either affect the other.</p> <p>However, if you use <code>value</code> to link a form element to a <em>non</em>-observable property (e.g., a plain old string, or an arbitrary JavaScript expression), KO will do the following:</p> <ul> <li> <p>If you reference a <em>simple property</em>, i.e., it is just a regular property on your view model, KO will set the form element’s initial state to the property value, and when the form element is edited, KO will write the changes back to your property. It cannot detect when the property changes (because it isn’t observable), so this is only a 1-way binding.</p> </li> <li> <p>If you reference something that is <em>not</em> a simple property, e.g., the result of a function call or comparison operation, KO will set the form element’s initial state to that value, but it will not be able to write any changes back when the user edits the form element. In this case it’s a one-time-only value setter, not an ongoing binding that reacts to changes.</p> </li> </ul> <p>Example:</p> <pre>&lt;!-- Two-way binding. Populates textbox; syncs both ways. --&gt;\n&lt;p&gt;First value: &lt;input data-bind=\"value: firstValue\" /&gt;&lt;/p&gt;\n\n&lt;!-- One-way binding. Populates textbox; syncs only from textbox to model. --&gt;\n&lt;p&gt;Second value: &lt;input data-bind=\"value: secondValue\" /&gt;&lt;/p&gt;\n\n&lt;!-- No binding. Populates textbox, but doesn't react to any changes. --&gt;\n&lt;p&gt;Third value: &lt;input data-bind=\"value: secondValue.length &gt; 8\" /&gt;&lt;/p&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        firstValue: ko.observable(\"hello\"), // Observable\n        secondValue: \"hello, again\"         // Not observable\n    };\n&lt;/script&gt;\n</pre> <h3 id=\"note-4-using-the-value-binding-with-the-checked-binding\">Note 4: Using the <code>value</code> binding with the <code>checked</code> binding</h3> <p>The <a href=\"checked-binding\"><code>checked</code></a> binding should be used to bind a view model property against the value of a checkbox (<code>&lt;input type='checkbox'&gt;</code>) or radio button (<code>&lt;input type='radio'&gt;</code>). If you do include the <code>value</code> binding with the <code>checked</code> binding on one of these elements, then the <code>value</code> binding will simply act like the <a href=\"checked-binding#checkedValue\"><code>checkedValue</code></a> option that can be used with the <code>checked</code> binding and will control the value that is used for updating your view model.</p> <h3 id=\"note-5-interaction-with-jquery\">Note 5: Interaction with jQuery</h3> <p>Knockout will use jQuery, if it is present, for handling UI events such as <code>change</code>. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling <code>ko.applyBindings</code>:</p> <pre>ko.options.useOnlyNativeEvents = true;\n</pre> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/value-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/value-binding.html</a>\n  </p>\n</div>\n","uniquename-binding":"<h1>The \"uniqueName\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>uniqueName</code> binding ensures that the associated DOM element has a nonempty <code>name</code> attribute. If the DOM element did not have a <code>name</code> attribute, this binding gives it one and sets it to some unique string value.</p> <p>You won’t need to use this often. It’s only useful in a few rare cases, e.g.:</p> <ul> <li> <p>Other technologies may depend on the assumption that certain elements have names, even though names might be irrelevant when you’re using KO. For example, <a href=\"http://jqueryvalidation.org/\">jQuery Validation</a> currently will only validate elements that have names. To use this with a Knockout UI, it’s sometimes necessary to apply the <code>uniqueName</code> binding to avoid confusing jQuery Validation. See <a href=\"http://knockoutjs.com/examples/gridEditor.html\">an example of using jQuery Validation with KO</a>.</p> </li> <li> <p>IE 6 does not allow radio buttons to be checked if they don’t have a <code>name</code> attribute. Most of the time this is irrelevant because your radio button elements <em>will</em> have name attributes to put them into mutually-exclusive groups. However, just in case you didn’t add a <code>name</code> attribute because it’s unnecessary in your case, KO will internally use <code>uniqueName</code> on those elements to ensure they can be checked.</p> </li> </ul> <h3 id=\"example\">Example</h3> <pre>&lt;input data-bind=\"value: someModelProperty, uniqueName: true\" /&gt;\n</pre> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>Pass <code>true</code> (or some value that evaluates as true) to enable the <code>uniqueName</code> binding, as in the preceding example.</p> </li> <li> <p>Additional parameters </p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/uniqueName-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/uniqueName-binding.html</a>\n  </p>\n</div>\n","textinput-binding":"<h1>The \"textInput\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>textInput</code> binding links a text box (<code>&lt;input&gt;</code>) or text area (<code>&lt;textarea&gt;</code>) with a viewmodel property, providing two-way updates between the viewmodel property and the element’s value. Unlike the <code>value</code> binding, <code>textInput</code> provides instant updates from the DOM for all types of user input, including autocomplete, drag-and-drop, and clipboard events.</p> <h3 id=\"example\">Example</h3> <pre>&lt;p&gt;Login name: &lt;input data-bind=\"textInput: userName\" /&gt;&lt;/p&gt;\n&lt;p&gt;Password: &lt;input type=\"password\" data-bind=\"textInput: userPassword\" /&gt;&lt;/p&gt;\n\nViewModel:\n&lt;pre data-bind=\"text: ko.toJSON($root, null, 2)\"&gt;&lt;/pre&gt;\n\n&lt;script&gt;\n    ko.applyBindings({\n        userName: ko.observable(\"\"),        // Initially blank\n        userPassword: ko.observable(\"abc\")  // Prepopulate\n    });\n&lt;/script&gt;\n</pre> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main Parameter</p> <p>KO sets the element’s text content to your parameter value. Any previous value will be overwritten.</p> <p>If this parameter is an observable value, the binding will update the element’s value whenever the observable value changes. If the parameter isn’t observable, it will only set the element’s value once and will not update it again later.</p> <p>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to <code>yourParameter.toString()</code> (that’s usually not very useful, so it’s best to supply string or numeric values).</p> <p>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified by the user or any DOM events.</p> </li> <li> <p>Additional parameters</p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-1-textinput-vs-value-binding\">Note 1: <code>textInput</code> vs <code>value</code> binding</h3> <p>Although the <a href=\"value-binding\"><code>value</code> binding</a> can also perform two-way binding between text boxes and viewmodel properties, you should prefer <code>textInput</code> whenever you want immediate live updates. The main differences are:</p> <ul> <li> <p><strong>Immediate updates</strong></p> <p><code>value</code>, by default, only updates your model when the user moves focus out of the text box. <code>textInput</code> updates your model immediately on each keystroke or other text entry mechanism (such as cutting or dragging text, which don’t necessarily raise any focus change events).</p> </li> <li> <p><strong>Browser event quirks handling</strong></p> <p>Browsers are highly inconsistent in the events that fire in response to unusual text entry mechanisms such as cutting, dragging, or accepting autocomplete suggestions. The <code>value</code> binding, even with extra options such as <code>valueUpdate: afterkeydown</code> to get updates on particular events, does not cover all text entry scenarios on all browsers.</p> <p>The <code>textInput</code> binding is specifically designed to handle a wide range of browser quirks, to provide consistent and immediate model updates even in response to unusual text entry methods.</p> </li> </ul> <p>Don’t try to use the <code>value</code> and <code>textInput</code> bindings together on the same element, as that won’t achieve anything useful.</p> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/textinput-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/textinput-binding.html</a>\n  </p>\n</div>\n","hasfocus-binding":"<h1>The \"hasFocus\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>hasFocus</code> binding links a DOM element’s focus state with a viewmodel property. It is a two-way binding, so:</p> <ul> <li>If you set the viewmodel property to <code>true</code> or <code>false</code>, the associated element will become focused or unfocused.</li> <li>If the user manually focuses or unfocuses the associated element, the viewmodel property will be set to <code>true</code> or <code>false</code> accordingly.</li> </ul> <p>This is useful if you’re building sophisticated forms in which editable elements appear dynamically, and you would like to control where the user should start typing, or respond to the location of the caret.</p> <h3 id=\"example-1-the-basics\">Example 1: The basics</h3> <p>This example simply displays a message if the textbox currently has focus, and uses a button to show that you can trigger focus programmatically.</p> <div class=\"liveExample\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n&lt;input data-bind=\"hasFocus: isSelected\" /&gt;\n&lt;button data-bind=\"click: setIsSelected\"&gt;Focus programmatically&lt;/button&gt;\n&lt;span data-bind=\"visible: isSelected\"&gt;The textbox has focus&lt;/span&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\nvar viewModel = {\n    isSelected: ko.observable(false),\n    setIsSelected: function() { this.isSelected(true) }\n};\nko.applyBindings(viewModel);\n</pre> <h3 id=\"example-2-click-to-edit\">Example 2: Click-to-edit</h3> <p>Because the <code>hasFocus</code> binding works in both directions (setting the associated value focuses or unfocuses the element; focusing or unfocusing the element sets the associated value), it’s a convenient way to toggle an “edit” mode. In this example, the UI displays either a <code>&lt;span&gt;</code> or an <code>&lt;input&gt;</code> element depending on the model’s <code>editing</code> property. Unfocusing the <code>&lt;input&gt;</code> element sets <code>editing</code> to <code>false</code>, so the UI switches out of “edit” mode.</p> <div class=\"liveExample\" id=\"click_to_edit\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n&lt;p&gt;\n\tName: \n\t&lt;b data-bind=\"visible: !editing(), text: name, click: edit\"&gt;&amp;nbsp;&lt;/b&gt;\n\t&lt;input data-bind=\"visible: editing, value: name, hasFocus: editing\" /&gt;\n&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;Click the name to edit it; click elsewhere to apply changes.&lt;/em&gt;&lt;/p&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\nfunction PersonViewModel(name) {\n    // Data\n    this.name = ko.observable(name);\n    this.editing = ko.observable(false);\n        \n    // Behaviors\n    this.edit = function() { this.editing(true) }\n}\n\nko.applyBindings(new PersonViewModel(\"Bert Bertington\"));\n</pre> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>Pass <code>true</code> (or some value that evaluates as true) to focus the associated element. Otherwise, the associated element will be unfocused.</p> <p>When the user manually focuses or unfocuses the element, your value will be set to <code>true</code> or <code>false</code> accordingly.</p> <p>If the value you supply is observable, the <code>hasFocus</code> binding will update the element’s focus state whenever that observable value changes.</p> </li> <li> <p>Additional parameters </p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/hasfocus-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/hasfocus-binding.html</a>\n  </p>\n</div>\n","checked-binding":"<h1>The \"checked\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>checked</code> binding links a checkable form control — i.e., a checkbox (<code>&lt;input type='checkbox'&gt;</code>) or a radio button (<code>&lt;input type='radio'&gt;</code>) — with a property on your view model.</p> <p>When the user checks the associated form control, this updates the value on your view model. Likewise, when you update the value in your view model, this checks or unchecks the form control on screen.</p> <p>Note: For text boxes, drop-down lists, and all non-checkable form controls, use <a href=\"value-binding\">the <code>value</code> binding</a> to read and write the element’s value, not the <code>checked</code> binding.</p> <h3 id=\"example-with-checkbox\">Example with checkbox</h3> <pre>&lt;p&gt;Send me spam: &lt;input type=\"checkbox\" data-bind=\"checked: wantsSpam\" /&gt;&lt;/p&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n\t\twantsSpam: ko.observable(true) // Initially checked\n    };\n\n    // ... then later ...\n    viewModel.wantsSpam(false); // The checkbox becomes unchecked\n&lt;/script&gt;\n</pre> <h3 id=\"example-adding-checkboxes-bound-to-an-array\">Example adding checkboxes bound to an array</h3> <pre>&lt;p&gt;Send me spam: &lt;input type=\"checkbox\" data-bind=\"checked: wantsSpam\" /&gt;&lt;/p&gt;\n&lt;div data-bind=\"visible: wantsSpam\"&gt;\n\tPreferred flavors of spam:\n\t&lt;div&gt;&lt;input type=\"checkbox\" value=\"cherry\" data-bind=\"checked: spamFlavors\" /&gt; Cherry&lt;/div&gt;\n\t&lt;div&gt;&lt;input type=\"checkbox\" value=\"almond\" data-bind=\"checked: spamFlavors\" /&gt; Almond&lt;/div&gt;\n\t&lt;div&gt;&lt;input type=\"checkbox\" value=\"msg\" data-bind=\"checked: spamFlavors\" /&gt; Monosodium Glutamate&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n\t\twantsSpam: ko.observable(true),\n\t\tspamFlavors: ko.observableArray([\"cherry\",\"almond\"]) // Initially checks the Cherry and Almond checkboxes\n    };\n\n    // ... then later ...\n    viewModel.spamFlavors.push(\"msg\"); // Now additionally checks the Monosodium Glutamate checkbox\n&lt;/script&gt;\n</pre> <h3 id=\"example-adding-radio-buttons\">Example adding radio buttons</h3> <pre>&lt;p&gt;Send me spam: &lt;input type=\"checkbox\" data-bind=\"checked: wantsSpam\" /&gt;&lt;/p&gt;\n&lt;div data-bind=\"visible: wantsSpam\"&gt;\n\tPreferred flavor of spam:\n\t&lt;div&gt;&lt;input type=\"radio\" name=\"flavorGroup\" value=\"cherry\" data-bind=\"checked: spamFlavor\" /&gt; Cherry&lt;/div&gt;\n\t&lt;div&gt;&lt;input type=\"radio\" name=\"flavorGroup\" value=\"almond\" data-bind=\"checked: spamFlavor\" /&gt; Almond&lt;/div&gt;\n\t&lt;div&gt;&lt;input type=\"radio\" name=\"flavorGroup\" value=\"msg\" data-bind=\"checked: spamFlavor\" /&gt; Monosodium Glutamate&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n\t\twantsSpam: ko.observable(true),\n\t\tspamFlavor: ko.observable(\"almond\") // Initially selects only the Almond radio button\n    };\n\n    // ... then later ...\n    viewModel.spamFlavor(\"msg\"); // Now only Monosodium Glutamate is checked\n&lt;/script&gt;\n</pre> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>KO sets the element’s checked state to match your parameter value. Any previous checked state will be overwritten. The way your parameter is interpreted depends on what type of element you’re binding to:</p> <ul> <li> <p>For <strong>checkboxes</strong>, KO will set the element to be <em>checked</em> when the parameter value is <code>true</code>, and <em>unchecked</em> when it is <code>false</code>. If you give a value that isn’t actually boolean, it will be interpreted loosely. This means that nonzero numbers and non-<code>null</code> objects and non-empty strings will all be interpreted as <code>true</code>, whereas zero, <code>null</code>, <code>undefined</code>, and empty strings will be interpreted as <code>false</code>.</p> <p>When the user checks or unchecks the checkbox, KO will set your model property to <code>true</code> or <code>false</code> accordingly.</p> <p>Special consideration is given if your parameter resolves to an <code>array</code>. In this case, KO will set the element to be <em>checked</em> if the value matches an item in the array, and <em>unchecked</em> if it is not contained in the array.</p> <p>When the user checks or unchecks the checkbox, KO will add or remove the value from the array accordingly.</p> </li> <li> <p>For <strong>radio buttons</strong>, KO will set the element to be <em>checked</em> if and only if the parameter value equals the radio button node’s <code>value</code> attribute or the value specified by the <code>checkedValue</code> parameter. In the previous example, the radio button with <code>value=\"almond\"</code> was checked only when the view model’s <code>spamFlavor</code> property was equal to <code>\"almond\"</code>.</p> <p>When the user changes which radio button is selected, KO will set your model property to equal the value of the selected radio button. In the preceding example, clicking on the radio button with <code>value=\"cherry\"</code> would set <code>viewModel.spamFlavor</code> to be <code>\"cherry\"</code>.</p> <p>Of course, this is most useful when you have multiple radio button elements bound to a single model property. To ensure that only <em>one</em> of those radio buttons can be checked at any one time, you should set all of their <code>name</code> attributes to an arbitrary common value (e.g., the value <code>flavorGroup</code> in the preceding example) - doing this puts them into a group where only one can be selected.</p> </li> </ul> <p>If your parameter is an observable value, the binding will update the element’s checked state whenever the value changes. If the parameter isn’t observable, it will only set the element’s checked state once and will not update it again later.</p> </li> <li> <p>Additional parameters</p> <ul> <li> <p><code id=\"checkedValue\">checkedValue</code></p> <p>If your binding also includes <code>checkedValue</code>, this defines the value used by the <code>checked</code> binding instead of the element’s <code>value</code> attribute. This is useful if you want the value to be something other than a string (such as an integer or object), or you want the value set dynamically.</p> <p>In the following example, the item objects themselves (not their <code>itemName</code> strings) will be included in the <code>chosenItems</code> array when their corresponding checkboxes are checked:</p> <pre>&lt;!-- ko foreach: items --&gt;\n    &lt;input type=\"checkbox\" data-bind=\"checkedValue: $data, checked: $root.chosenItems\" /&gt;\n    &lt;span data-bind=\"text: itemName\"&gt;&lt;/span&gt;\n&lt;!-- /ko --&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        items: ko.observableArray([\n            { itemName: 'Choice 1' },\n            { itemName: 'Choice 2' }\n        ]),\n        chosenItems: ko.observableArray()\n    };\n&lt;/script&gt;\n</pre> <p>If your <code>checkedValue</code> parameter is an observable value, whenever the value changes and the element is currently checked, the binding will update the <code>checked</code> model property. For checkboxes, it will remove the old value from the array and add the new value. For radio buttons, it will just update the model value.</p> </li> </ul> </li> </ul> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/checked-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/checked-binding.html</a>\n  </p>\n</div>\n","options-binding":"<h1>The \"options\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>options</code> binding controls what options should appear in a drop-down list (i.e., a <code>&lt;select&gt;</code> element) or multi-select list (e.g., <code>&lt;select size='6'&gt;</code>). This binding cannot be used with anything other than <code>&lt;select&gt;</code> elements.</p> <p>The value you assign should be an array (or observable array). The <code>&lt;select&gt;</code> element will then display one item for each item in your array.</p> <p>Note: For a multi-select list, to set which of the options are selected, or to read which of the options are selected, use <a href=\"selectedoptions-binding\">the <code>selectedOptions</code> binding</a>. For a single-select list, you can also read and write the selected option using <a href=\"value-binding\">the <code>value</code> binding</a>.</p> <h3 id=\"example-1-drop-down-list\">Example 1: Drop-down list</h3> <pre>&lt;p&gt;\n    Destination country:\n    &lt;select data-bind=\"options: availableCountries\"&gt;&lt;/select&gt;\n&lt;/p&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        // These are the initial options\n        availableCountries: ko.observableArray(['France', 'Germany', 'Spain'])\n    };\n\n    // ... then later ...\n    viewModel.availableCountries.push('China'); // Adds another option\n&lt;/script&gt;\n</pre> <h3 id=\"example-2-multi-select-list\">Example 2: Multi-select list</h3> <pre>&lt;p&gt;\n    Choose some countries you would like to visit:\n    &lt;select data-bind=\"options: availableCountries\" size=\"5\" multiple=\"true\"&gt;&lt;/select&gt;\n&lt;/p&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        availableCountries: ko.observableArray(['France', 'Germany', 'Spain'])\n    };\n&lt;/script&gt;\n</pre> <h3 id=\"example-3-drop-down-list-representing-arbitrary-javascript-objects-not-just-strings\">Example 3: Drop-down list representing arbitrary JavaScript objects, not just strings</h3> <pre>&lt;p&gt;\n    Your country:\n    &lt;select data-bind=\"options: availableCountries,\n                       optionsText: 'countryName',\n                       value: selectedCountry,\n                       optionsCaption: 'Choose...'\"&gt;&lt;/select&gt;\n&lt;/p&gt;\n\n&lt;div data-bind=\"visible: selectedCountry\"&gt; &lt;!-- Appears when you select something --&gt;\n    You have chosen a country with population\n    &lt;span data-bind=\"text: selectedCountry() ? selectedCountry().countryPopulation : 'unknown'\"&gt;&lt;/span&gt;.\n&lt;/div&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    // Constructor for an object with two properties\n    var Country = function(name, population) {\n        this.countryName = name;\n        this.countryPopulation = population;\n    };\n\n    var viewModel = {\n        availableCountries : ko.observableArray([\n            new Country(\"UK\", 65000000),\n            new Country(\"USA\", 320000000),\n            new Country(\"Sweden\", 29000000)\n        ]),\n        selectedCountry : ko.observable() // Nothing selected by default\n    };\n&lt;/script&gt;\n</pre> <h3 id=\"example-4-drop-down-list-representing-arbitrary-javascript-objects-with-displayed-text-computed-as-a-function-of-the-represented-item\">Example 4: Drop-down list representing arbitrary JavaScript objects, with displayed text computed as a function of the represented item</h3> <pre>&lt;!-- Same as example 3, except the &lt;select&gt; box expressed as follows: --&gt;\n&lt;select data-bind=\"options: availableCountries,\n                   optionsText: function(item) {\n                       return item.countryName + ' (pop: ' + item.countryPopulation + ')'\n                   },\n                   value: selectedCountry,\n                   optionsCaption: 'Choose...'\"&gt;&lt;/select&gt;\n</pre> <p>Note that the only difference between examples 3 and 4 is the <code>optionsText</code> value.</p> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>You should supply an array (or observable array). For each item, KO will add an <code>&lt;option&gt;</code> to the associated <code>&lt;select&gt;</code> node. Any previous options will be removed.</p> <p>If your parameter’s value is an array of strings, you don’t need to give any other parameters. The <code>&lt;select&gt;</code> element will display an option for each string value. However, if you want to let the user choose from an array of <em>arbitrary JavaScript objects</em> (not merely strings), then see the <code>optionsText</code> and <code>optionsValue</code> parameters below.</p> <p>If this parameter is an observable value, the binding will update the element’s available options whenever the value changes. If the parameter isn’t observable, it will only set the element’s available options once and will not update them again later.</p> </li> <li> <p>Additional parameters</p> <ul> <li> <p><code>optionsCaption</code></p> <p>Sometimes, you might not want to select any particular option by default. But a single-select drop-down list usually starts with some item selected, so how can you avoid preselecting something? The usual solution is to prefix the list of options with a special dummy option that just reads “Select an item” or “Please choose an option” or similar, and have that one selected by default.</p> <p>This easy to do: just add an additional parameter with name <code>optionsCaption</code>, with its value being a string to display. For example:</p> <p><code>&lt;select data-bind='options: myOptions, optionsCaption: \"Select an item...\", value: myChosenValue'&gt;&lt;/select&gt;</code></p> <p>KO will prefix the list of items with one that displays the text “Select an item…” and has the value <code>undefined</code>. So, if <code>myChosenValue</code> holds the value <code>undefined</code> (which observables do by default), then the dummy option will be selected. If the <code>optionsCaption</code> parameter is an observable, then the text of the initial item will update as the observable’s value changes.</p> </li> <li> <p><code>optionsText</code></p> <p>See Example 3 above to see how you can bind <code>options</code> to an array of arbitrary JavaScript object - not just strings. In this case, you need to choose which of the objects’ properties should be displayed as the text in the drop-down list or multi-select list. Example 3 shows how you can specify that property name by passing an additional parameter called <code>optionsText</code>.</p> <p>If you don’t want to display just a simple property value as the text for each item in the dropdown, you can pass a JavaScript function for the <code>optionsText</code> option and supply your own arbitrary logic for computing the displayed text in terms of the represented object. See Example 4 above, which shows how you could generate the displayed text by concatenating together multiple property values.</p> </li> <li> <p><code>optionsValue</code></p> <p>Similar to <code>optionsText</code>, you can also pass an additional parameter called <code>optionsValue</code> to specify which of the objects’ properties should be used to set the <code>value</code> attribute on the <code>&lt;option&gt;</code> elements that KO generates. You can also specify a JavaScript function to determine this value. This function will receive the selected item as its only argument and should return a string to use for the <code>&lt;option&gt;</code> element’s value attribute.</p> <p>Typically you’d only want to use <code>optionsValue</code> as a way of ensuring that KO can correctly retain selection when you update the set of available options. For example, if you’re repeatedly getting a list of “car” objects via Ajax calls and want to ensure that the selected car is preserved, you might need to set <code>optionsValue</code> to <code>\"carId\"</code> or whatever unique identifier each “car” object has, otherwise KO won’t necessarily know which of the previous “car” objects corresponds to which of the new ones.</p> </li> <li> <p><code>optionsIncludeDestroyed</code></p> <p>Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a non-destructive delete. For details of how to do this, see <a href=\"observablearrays#destroy-and-destroyall\">the destroy function on <code>observableArray</code></a>.</p> <p>By default, the options binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, then specify this additional parameter like:</p> <p><code>&lt;select data-bind='options: myOptions, optionsIncludeDestroyed: true'&gt;&lt;/select&gt;</code></p> </li> <li> <p><code>optionsAfterRender</code></p> <p>If you need to run some further custom logic on the generated <code>option</code> elements, you can use the <code>optionsAfterRender</code> callback. See Note 2 below.</p> </li> <li> <p><code>selectedOptions</code></p> <p>For a multi-select list, you can read and write the selection state using <code>selectedOptions</code>. Technically this is a separate binding, so it has <a href=\"selectedoptions-binding\">its own documentation</a>.</p> </li> <li> <p><code>valueAllowUnset</code></p> <p>If you want Knockout to allow your model property to take values that have no corresponding entry in your <code>&lt;select&gt;</code> element (and display this by making the <code>&lt;select&gt;</code> element blank), then see <a href=\"value-binding#using-valueallowunset-with-select-elements\">documentation for <code>valueAllowUnset</code></a>.</p> </li> </ul> </li> </ul> <h3 id=\"note-1-selection-is-preserved-when-settingchanging-options\">Note 1: Selection is preserved when setting/changing options</h3> <p>When the <code>options</code> binding changes the set of options in your <code>&lt;select&gt;</code> element, KO will leave the user’s selection unchanged where possible. So, for a single-select drop-down list, the previously selected option value will still be selected, and for a multi-select list, all the previously selected option values will still be selected (unless, of course, you’ve removed one or more of those options).</p> <p>That’s because the <code>options</code> binding tries to be independent of the <code>value</code> binding (which controls selection for a single-select list) and the <code>selectedOptions</code> binding (which controls selection for a multi-select list).</p> <h3 id=\"note-2-post-processing-the-generated-options\">Note 2: Post-processing the generated options</h3> <p>If you need to run some further custom logic on the generated <code>option</code> elements, you can use the <code>optionsAfterRender</code> callback. The callback function is invoked each time an <code>option</code> element is inserted into the list, with the following parameters:</p> <ol> <li>The inserted <code>option</code> element</li> <li>The data item against which it is bound, or <code>undefined</code> for the caption element</li> </ol> <p>Here’s an example that uses <code>optionsAfterRender</code> to add a <code>disable</code> binding to each option.</p> <pre>&lt;select size=3 data-bind=\"\n    options: myItems,\n    optionsText: 'name',\n    optionsValue: 'id',\n    optionsAfterRender: setOptionDisable\"&gt;\n&lt;/select&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var vm = {\n        myItems: [\n            { name: 'Item 1', id: 1, disable: ko.observable(false)},\n            { name: 'Item 3', id: 3, disable: ko.observable(true)},\n            { name: 'Item 4', id: 4, disable: ko.observable(false)}\n        ],\n        setOptionDisable: function(option, item) {\n            ko.applyBindingsToNode(option, {disable: item.disable}, item);\n        }\n    };\n    ko.applyBindings(vm);\n&lt;/script&gt;\n</pre> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/options-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/options-binding.html</a>\n  </p>\n</div>\n","selectedoptions-binding":"<h1>The \"selectedOptions\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>selectedOptions</code> binding controls which elements in a multi-select list are currently selected. This is intended to be used in conjunction with a <code>&lt;select&gt;</code> element and the <code>options</code> binding.</p> <p>When the user selects or de-selects an item in the multi-select list, this adds or removes the corresponding value to an array on your view model. Likewise, assuming it’s an <em>observable</em> array on your view model, then whenever you add or remove (e.g., via <code>push</code> or <code>splice</code>) items to this array, the corresponding items in the UI become selected or deselected. It’s a 2-way binding.</p> <p>Note: To control which element in a single-select drop-down list is selected, you can use <a href=\"value-binding\">the <code>value</code> binding</a> instead.</p> <h3 id=\"example\">Example</h3> <pre>&lt;p&gt;\n    Choose some countries you'd like to visit: \n    &lt;select data-bind=\"options: availableCountries, selectedOptions: chosenCountries\" size=\"5\" multiple=\"true\"&gt;&lt;/select&gt;\n&lt;/p&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        availableCountries : ko.observableArray(['France', 'Germany', 'Spain']),\n        chosenCountries : ko.observableArray(['Germany']) // Initially, only Germany is selected\n    };\n    \n    // ... then later ...\n    viewModel.chosenCountries.push('France'); // Now France is selected too\n&lt;/script&gt;\n</pre> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>This should be an array (or an observable array). KO sets the element’s selected options to match the contents of the array. Any previous selection state will be overwritten.</p> <p>If your parameter is an observable array, the binding will update the element’s selection whenever the array changes (e.g., via <code>push</code>, <code>pop</code> or <a href=\"observablearrays\">other observable array methods</a>). If the parameter isn’t observable, it will only set the element’s selection state once and will not update it again later.</p> <p>Whether or not the parameter is an observable array, KO will detect when the user selects or deselects an item in the multi-select list, and will update the array to match. This is how you can read which of the options is selected.</p> </li> <li> <p>Additional parameters </p> <ul> <li>None</li> </ul> </li> </ul> <h3 id=\"note-letting-the-user-select-from-arbitrary-javascript-objects\">Note: Letting the user select from arbitrary JavaScript objects</h3> <p>In the example code above, the user can choose from an array of string values. You’re <em>not</em> limited to providing strings - your <code>options</code> array can contain arbitrary JavaScript objects if you wish. See <a href=\"options-binding\">the <code>options</code> binding</a> for details on how to control how arbitrary objects should be displayed in the list.</p> <p>In this scenario, the values you can read and write using <code>selectedOptions</code> are those objects themselves, <em>not</em> their textual representations. This leads to much cleaner and more elegant code in most cases. Your view model can imagine that the user chooses from an array of arbitrary objects, without having to care how those objects are mapped to an on-screen representation.</p> <h3 id=\"dependencies\">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/selectedOptions-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/selectedOptions-binding.html</a>\n  </p>\n</div>\n","template-binding":"<h1>The \"template\" binding</h1> <h3 id=\"purpose\">Purpose</h3> <p>The <code>template</code> binding populates the associated DOM element with the results of rendering a template. Templates are a simple and convenient way to build sophisticated UI structures - possibly with repeating or nested blocks - as a function of your view model data.</p> <p>There are two main ways of using templates:</p> <ul> <li>\n<em>Native templating</em> is the mechanism that underpins <code>foreach</code>, <code>if</code>, <code>with</code>, and other control flow bindings. Internally, those control flow bindings capture the HTML markup contained in your element, and use it as a template to render against an arbitrary data item. This feature is built into Knockout and doesn’t require any external library.</li> <li>\n<em>String-based templating</em> is a way to connect Knockout to a third-party template engine. Knockout will pass your model values to the external template engine and inject the resulting markup string into your document. See below for examples that use the <em>jquery.tmpl</em> and <em>Underscore</em> template engines.</li> </ul> <h3 id=\"parameters\">Parameters</h3> <ul> <li> <p>Main parameter</p> <ul> <li> <p>Shorthand syntax: If you just supply a string value, KO will interpret this as the ID of a template to render. The data it supplies to the template will be your current model object.</p> </li> <li> <p>For more control, pass a JavaScript object with some combination of the following properties:</p> <ul> <li>\n<code>name</code> — the ID of an element that contains the template you wish to render - see <a href=\"#note-5-dynamically-choosing-which-template-is-used\">Note 5</a> for how to vary this programmatically.</li> <li>\n<code>nodes</code> — directly pass an array of DOM nodes to use as a template. This should be a non-observable array and note that the elements will be removed from their current parent if they have one. This option is ignored if you have also passed a nonempty value for <code>name</code>.</li> <li>\n<code>data</code> — an object to supply as the data for the template to render. If you omit this parameter, KO will look for a <code>foreach</code> parameter, or will fall back on using your current model object.</li> <li>\n<code>if</code> — if this parameter is provided, the template will only be rendered if the specified expression evaluates to <code>true</code> (or a <code>true</code>-ish value). This can be useful for preventing a null observable from being bound against a template before it is populated.</li> <li>\n<code>foreach</code> — instructs KO to render the template in “foreach” mode - see <a href=\"#note-2-using-the-foreach-option-with-a-named-template\">Note 2</a> for details.</li> <li>\n<code>as</code> — when used in conjunction with <code>foreach</code>, defines an alias for each item being rendered - see <a href=\"#note-3-using-as-to-give-an-alias-to-foreach-items\">Note 3</a> for details.</li> <li>\n<code>afterRender</code>, <code>afterAdd</code>, or <code>beforeRemove</code> — callback functions to be invoked against the rendered DOM elements - see <a href=\"#note-4-using-afterrender-afteradd-and-beforeremove\">Note 4</a>\n</li> </ul> </li> </ul> </li> </ul> <h3 id=\"note-1-rendering-a-named-template\">Note 1: Rendering a named template</h3> <p>Normally, when you’re using control flow bindings (<code>foreach</code>, <code>with</code>, <code>if</code>, etc.), there’s no need to give names to your templates: they are defined implicitly and anonymously by the markup inside your DOM element. But if you want to, you can factor out templates into a separate element and then reference them by name:</p> <pre>&lt;h2&gt;Participants&lt;/h2&gt;\nHere are the participants:\n&lt;div data-bind=\"template: { name: 'person-template', data: buyer }\"&gt;&lt;/div&gt;\n&lt;div data-bind=\"template: { name: 'person-template', data: seller }\"&gt;&lt;/div&gt;\n\n&lt;script type=\"text/html\" id=\"person-template\"&gt;\n    &lt;h3 data-bind=\"text: name\"&gt;&lt;/h3&gt;\n    &lt;p&gt;Credits: &lt;span data-bind=\"text: credits\"&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;/script&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n     function MyViewModel() {\n         this.buyer = { name: 'Franklin', credits: 250 };\n         this.seller = { name: 'Mario', credits: 5800 };\n     }\n     ko.applyBindings(new MyViewModel());\n&lt;/script&gt;\n</pre> <p>In this example, the <code>person-template</code> markup is used twice: once for <code>buyer</code>, and once for <code>seller</code>. Notice that the template markup is wrapped in a <code>&lt;script type=\"text/html\"&gt;</code> — the dummy <code>type</code> attribute is necessary to ensure that the markup is not executed as JavaScript, and Knockout does not attempt to apply bindings to that markup except when it is being used as a template.</p> <p>It’s not very often that you’ll need to use named templates, but on occasion it can help to minimise duplication of markup.</p> <h3 id=\"note-2-using-the-foreach-option-with-a-named-template\">Note 2: Using the “foreach” option with a named template</h3> <p>If you want the equivalent of a <code>foreach</code> binding, but using a named template, you can do so in the natural way:</p> <pre>&lt;h2&gt;Participants&lt;/h2&gt;\nHere are the participants:\n&lt;div data-bind=\"template: { name: 'person-template', foreach: people }\"&gt;&lt;/div&gt;\n\n&lt;script type=\"text/html\" id=\"person-template\"&gt;\n    &lt;h3 data-bind=\"text: name\"&gt;&lt;/h3&gt;\n    &lt;p&gt;Credits: &lt;span data-bind=\"text: credits\"&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;/script&gt;\n\n function MyViewModel() {\n     this.people = [\n         { name: 'Franklin', credits: 250 },\n         { name: 'Mario', credits: 5800 }\n     ]\n }\n ko.applyBindings(new MyViewModel());\n</pre> <p>This gives the same result as embedding an anonymous template directly inside the element to which you use <code>foreach</code>, i.e.:</p> <pre>&lt;div data-bind=\"foreach: people\"&gt;\n    &lt;h3 data-bind=\"text: name\"&gt;&lt;/h3&gt;\n    &lt;p&gt;Credits: &lt;span data-bind=\"text: credits\"&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n</pre> <h3 id=\"note-3-using-as-to-give-an-alias-to-foreach-items\">Note 3: Using “as” to give an alias to “foreach” items</h3> <p>When nesting <code>foreach</code> templates, it’s often useful to refer to items at higher levels in the hierarchy. One way to do this is to refer to <code>$parent</code> or other <a href=\"binding-context\">binding context</a> variables in your bindings.</p> <p>A simpler and more elegant option, however, is to use <code>as</code> to declare a name for your iteration variables. For example:</p> <pre>&lt;ul data-bind=\"template: { name: 'employeeTemplate',\n                                  foreach: employees,\n                                  as: 'employee' }\"&gt;&lt;/ul&gt;\n</pre> <p>Notice the string value <code>'employee'</code> associated with <code>as</code>. Now anywhere inside this <code>foreach</code> loop, bindings in your child templates will be able to refer to <code>employee</code> to access the employee object being rendered.</p> <p>This is mainly useful if you have multiple levels of nested <code>foreach</code> blocks, because it gives you an unambiguous way to refer to any named item declared at a higher level in the hierarchy. Here’s a complete example, showing how <code>season</code> can be referenced while rendering a <code>month</code>:</p> <pre>&lt;ul data-bind=\"template: { name: 'seasonTemplate', foreach: seasons, as: 'season' }\"&gt;&lt;/ul&gt;\n\n&lt;script type=\"text/html\" id=\"seasonTemplate\"&gt;\n    &lt;li&gt;\n        &lt;strong data-bind=\"text: name\"&gt;&lt;/strong&gt;\n        &lt;ul data-bind=\"template: { name: 'monthTemplate', foreach: months, as: 'month' }\"&gt;&lt;/ul&gt;\n    &lt;/li&gt;\n&lt;/script&gt;\n\n&lt;script type=\"text/html\" id=\"monthTemplate\"&gt;\n    &lt;li&gt;\n        &lt;span data-bind=\"text: month\"&gt;&lt;/span&gt;\n        is in\n        &lt;span data-bind=\"text: season.name\"&gt;&lt;/span&gt;\n    &lt;/li&gt;\n&lt;/script&gt;\n\n&lt;script&gt;\n    var viewModel = {\n        seasons: ko.observableArray([\n            { name: 'Spring', months: [ 'March', 'April', 'May' ] },\n            { name: 'Summer', months: [ 'June', 'July', 'August' ] },\n            { name: 'Autumn', months: [ 'September', 'October', 'November' ] },\n            { name: 'Winter', months: [ 'December', 'January', 'February' ] }\n        ])\n    };\n    ko.applyBindings(viewModel);\n&lt;/script&gt;\n</pre> <p>Tip: Remember to pass a <em>string literal value</em> to as (e.g., <code>as: 'season'</code>, <em>not</em> <code>as: season</code>), because you are giving a name for a new variable, not reading the value of a variable that already exists.</p> <h3 id=\"note-4-using-afterrender-afteradd-and-beforeremove\">Note 4: Using “afterRender”, “afterAdd”, and “beforeRemove”</h3> <p>Sometimes you might want to run custom post-processing logic on the DOM elements generated by your templates. For example, if you’re using a JavaScript widgets library such as jQuery UI, you might want to intercept your templates’ output so that you can run jQuery UI commands on it to transform some of the rendered elements into date pickers, sliders, or anything else.</p> <p>Generally, the best way to perform such post-processing on DOM elements is to write a <a href=\"custom-bindings\">custom binding</a>, but if you really just want to access the raw DOM elements emitted by a template, you can use <code>afterRender</code>.</p> <p>Pass a function reference (either a function literal, or give the name of a function on your view model), and Knockout will invoke it immediately after rendering or re-rendering your template. If you’re using <code>foreach</code>, Knockout will invoke your <code>afterRender</code> callback for each item added to your observable array. For example,</p> <pre>&lt;div data-bind='template: { name: \"personTemplate\",\n                            data: myData,\n                            afterRender: myPostProcessingLogic }'&gt; &lt;/div&gt;\n</pre> <p>… and define a corresponding function on your view model (i.e., the object that contains <code>myData</code>):</p> <pre>viewModel.myPostProcessingLogic = function(elements) {\n    // \"elements\" is an array of DOM nodes just rendered by the template\n    // You can add custom post-processing logic here\n}\n</pre> <p>If you are using <code>foreach</code> and only want to be notified about elements that are specifically being added or are being removed, you can use <code>afterAdd</code> and <code>beforeRemove</code> instead. For details, see documentation for the <a href=\"foreach-binding\"><code>foreach</code> binding</a>.</p> <h3 id=\"note-5-dynamically-choosing-which-template-is-used\">Note 5: Dynamically choosing which template is used</h3> <p>If you have multiple named templates, you can pass an observable for the <code>name</code> option. As the observable’s value is updated, the element’s contents will be re-rendered using the appropriate template. Alternatively, you can pass a callback function to determine which template to use. If you are using the <code>foreach</code> template mode, Knockout will evaluate the function for each item in your array, passing that item’s value as the only argument. Otherwise, the function will be given the <code>data</code> option’s value or fall back to providing your whole current model object.</p> <p>For example,</p> <pre>&lt;ul data-bind='template: { name: displayMode,\n                           foreach: employees }'&gt; &lt;/ul&gt;\n\n&lt;script&gt;\n    var viewModel = {\n        employees: ko.observableArray([\n            { name: \"Kari\", active: ko.observable(true) },\n            { name: \"Brynn\", active: ko.observable(false) },\n            { name: \"Nora\", active: ko.observable(false) }\n        ]),\n        displayMode: function(employee) {\n            // Initially \"Kari\" uses the \"active\" template, while the others use \"inactive\"\n            return employee.active() ? \"active\" : \"inactive\";\n        }\n    };\n\n    // ... then later ...\n    viewModel.employees()[1].active(true); // Now \"Brynn\" is also rendered using the \"active\" template.\n&lt;/script&gt;\n</pre> <p>If your function references observable values, then the binding will update whenever any of those values change. This will cause the data to be re-rendered using the appropriate template.</p> <p>If your function accepts a second parameter, then it will receive the entire <a href=\"binding-context\">binding context</a>. You can then access <code>$parent</code> or any other <a href=\"binding-context\">binding context</a> variable when dynamically choosing a template. For example, you could amend the preceding code snippet as follows:</p> <pre>displayMode: function(employee, bindingContext) {\n    // Now return a template name string based on properties of employee or bindingContext\n}\n</pre> <h3 id=\"note-6-using-jquerytmpl-an-external-string-based-template-engine\">Note 6: Using jQuery.tmpl, an external string-based template engine</h3> <p>In the vast majority of cases, Knockout’s native templating and the <code>foreach</code>, <code>if</code>, <code>with</code> and other control flow bindings will be all you need to construct an arbitrarily sophisticated UI. But in case you wish to integrate with an external templating library, such as the <a href=\"http://documentcloud.github.com/underscore/#template\">Underscore template engine</a> or <a href=\"http://api.jquery.com/jquery.tmpl/\">jquery.tmpl</a>, Knockout offers a way to do it.</p> <p>By default, Knockout comes with support for <a href=\"https://github.com/BorisMoore/jquery-tmpl\">jquery.tmpl</a>. To use it, you need to reference the following libraries, in this order:</p> <pre>&lt;!-- First jQuery --&gt;     &lt;script src=\"http://code.jquery.com/jquery-1.7.1.min.js\"&gt;&lt;/script&gt;\n&lt;!-- Then jQuery.tmpl --&gt; &lt;script src=\"jquery.tmpl.js\"&gt;&lt;/script&gt;\n&lt;!-- Then Knockout --&gt;    &lt;script src=\"knockout-x.y.z.js\"&gt;&lt;/script&gt;\n</pre> <p>Then, you can use jQuery.tmpl syntax in your templates. For example,</p> <pre>&lt;h1&gt;People&lt;/h1&gt;\n&lt;div data-bind=\"template: 'peopleList'\"&gt;&lt;/div&gt;\n\n&lt;script type=\"text/html\" id=\"peopleList\"&gt;\n    {{each people}}\n        &lt;p&gt;\n            &lt;b&gt;${name}&lt;/b&gt; is ${age} years old\n        &lt;/p&gt;\n    {{/each}}\n&lt;/script&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        people: ko.observableArray([\n            { name: 'Rod', age: 123 },\n            { name: 'Jane', age: 125 },\n        ])\n    }\n    ko.applyBindings(viewModel);\n&lt;/script&gt;\n</pre> <p>This works because <code>{{each ...}}</code> and <code>${ ... }</code> are jQuery.tmpl syntaxes. What’s more, it’s trivial to nest templates: because you can use data-bind attributes from inside a template, you can simply put a <code>data-bind=\"template: ...\"</code> inside a template to render a nested one.</p> <p>Please note that, as of December 2011, jQuery.tmpl is no longer under active development. We recommend the use of Knockout’s native DOM-based templating (i.e., the <code>foreach</code>, <code>if</code>, <code>with</code>, etc. bindings) instead of jQuery.tmpl or any other string-based template engine.</p> <h3 id=\"note-7-using-the-underscorejs-template-engine\">Note 7: Using the Underscore.js template engine</h3> <p>The <a href=\"http://documentcloud.github.com/underscore/#template\">Underscore.js template engine</a> by default uses ERB-style delimiters (<code>&lt;%= ... %&gt;</code>). Here’s how the preceding example’s template might look with Underscore:</p> <pre>&lt;script type=\"text/html\" id=\"peopleList\"&gt;\n    &lt;% _.each(people(), function(person) { %&gt;\n        &lt;li&gt;\n            &lt;b&gt;&lt;%= person.name %&gt;&lt;/b&gt; is &lt;%= person.age %&gt; years old\n        &lt;/li&gt;\n    &lt;% }) %&gt;\n&lt;/script&gt;\n</pre> <p>Here’s <a href=\"http://jsfiddle.net/rniemeyer/NW5Vn/\">a simple implementation of integrating Underscore templates with Knockout</a>. The integration code is just 16 lines long, but it’s enough to support Knockout <code>data-bind</code> attributes (and hence nested templates) and Knockout <a href=\"binding-context\">binding context</a> variables (<code>$parent</code>, <code>$root</code>, etc.).</p> <p>If you’re not a fan of the <code>&lt;%= ... %&gt;</code> delimiters, you can configure the Underscore template engine to use any other delimiter characters of your choice.</p> <h3 id=\"dependencies\">Dependencies</h3> <ul> <li>\n<strong>Native templating</strong> does not require any library other than Knockout itself</li> <li>\n<strong>String-based templating</strong> works only once you’ve referenced a suitable template engine, such as jQuery.tmpl or the Underscore template engine.</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/template-binding.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/template-binding.html</a>\n  </p>\n</div>\n","binding-syntax":"<h1>The data-bind syntax</h1> <p>Knockout’s declarative binding system provides a concise and powerful way to link data to the UI. It’s generally easy and obvious to bind to simple data properties or to use a single binding. For more complex bindings, it helps to better understand the behavior and syntax of Knockout’s binding system.</p> <h3 id=\"binding-syntax\">Binding syntax</h3> <p>A binding consists of two items, the binding <em>name</em> and <em>value</em>, separated by a colon. Here is an example of a single, simple binding:</p> <pre>Today's message is: &lt;span data-bind=\"text: myMessage\"&gt;&lt;/span&gt;\n</pre> <p>An element can include multiple bindings (related or unrelated), with each binding separated by a comma. Here are some examples:</p> <pre>&lt;!-- related bindings: valueUpdate is a parameter for value --&gt;\nYour value: &lt;input data-bind=\"value: someValue, valueUpdate: 'afterkeydown'\" /&gt;\n\n&lt;!-- unrelated bindings --&gt;\nCellphone: &lt;input data-bind=\"value: cellphoneNumber, enable: hasCellphone\" /&gt;\n</pre> <p>The binding <em>name</em> should generally match a registered binding handler (either built-in or <a href=\"custom-bindings\">custom</a>) or be a parameter for another binding. If the name matches neither of those, Knockout will ignore it (without any error or warning). So if a binding doesn’t appear to work, first check that the name is correct.</p> <h4 id=\"binding-values\">Binding values</h4> <p>The binding <em>value</em> can be a single <a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals\">value, variable, or literal</a> or almost any valid <a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Expressions_and_Operators\">JavaScript expression</a>. Here are examples of various binding values:</p> <pre>&lt;!-- variable (usually a property of the current view model --&gt;\n&lt;div data-bind=\"visible: shouldShowMessage\"&gt;...&lt;/div&gt;\n\n&lt;!-- comparison and conditional --&gt;\nThe item is &lt;span data-bind=\"text: price() &gt; 50 ? 'expensive' : 'cheap'\"&gt;&lt;/span&gt;.\n\n&lt;!-- function call and comparison --&gt;\n&lt;button data-bind=\"enable: parseAreaCode(cellphoneNumber()) != '555'\"&gt;...&lt;/button&gt;\n\n&lt;!-- function expression --&gt;\n&lt;div data-bind=\"click: function (data) { myFunction('param1', data) }\"&gt;...&lt;/div&gt;\n\n&lt;!-- object literal (with unquoted and quoted property names) --&gt;\n&lt;div data-bind=\"with: {emotion: 'happy', 'facial-expression': 'smile'}\"&gt;...&lt;/div&gt;\n</pre> <p>These examples show that the value can be just about any JavaScript expression. Even the comma is fine when it’s enclosed in braces, brackets, or parentheses. When the value is an object literal, the object’s property names must be valid JavaScript identifiers or be enclosed in quotes. If the binding value is an invalid expression or references an unknown variable, Knockout will output an error and stop processing bindings.</p> <h4 id=\"whitespace\">Whitespace</h4> <p>Bindings can include any amount of <em>whitespace</em> (spaces, tab, and newlines), so you’re free to use it to arrange your bindings as you like. The following examples are all equivalent:</p> <pre>&lt;!-- no spaces --&gt;\n&lt;select data-bind=\"options:availableCountries,optionsText:'countryName',value:selectedCountry,optionsCaption:'Choose...'\"&gt;&lt;/select&gt;\n\n&lt;!-- some spaces --&gt;\n&lt;select data-bind=\"options : availableCountries, optionsText : 'countryName', value : selectedCountry, optionsCaption : 'Choose...'\"&gt;&lt;/select&gt;\n\n&lt;!-- spaces and newlines --&gt;\n&lt;select data-bind=\"\n    options: availableCountries,\n    optionsText: 'countryName',\n    value: selectedCountry,\n    optionsCaption: 'Choose...'\"&gt;&lt;/select&gt;\n</pre> <h4 id=\"skipping-the-binding-value\">Skipping the binding value</h4> <p>Starting with Knockout 3.0, you can specify bindings without a value, which will give the binding an <code>undefined</code> value. For example:</p> <pre>&lt;span data-bind=\"text\"&gt;Text that will be cleared when bindings are applied.&lt;/span&gt;\n</pre> <p>This ability is especially useful when paired with <a href=\"binding-preprocessing\">binding preprocessing</a>, which can assign a default value for a binding.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/binding-syntax.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/binding-syntax.html</a>\n  </p>\n</div>\n","binding-context":"<h1>Binding context</h1> <p>A <em>binding context</em> is an object that holds data that you can reference from your bindings. While applying bindings, Knockout automatically creates and manages a hierarchy of binding contexts. The root level of the hierarchy refers to the <code>viewModel</code> parameter you supplied to <code>ko.applyBindings(viewModel)</code>. Then, each time you use a control flow binding such as <a href=\"with-binding\"><code>with</code></a> or <a href=\"foreach-binding\"><code>foreach</code></a>, that creates a child binding context that refers to the nested view model data.</p> <p>Bindings contexts offer the following special properties that you can reference in any binding:</p> <ul> <li> <p><code>$parent</code></p> <p>This is the view model object in the parent context, the one immeditely outside the current context. In the root context, this is undefined. Example:</p> <pre> &lt;h1 data-bind=\"text: name\"&gt;&lt;/h1&gt;\n\n &lt;div data-bind=\"with: manager\"&gt;\n     &lt;!-- Now we're inside a nested binding context --&gt;\n     &lt;span data-bind=\"text: name\"&gt;&lt;/span&gt; is the\n     manager of &lt;span data-bind=\"text: $parent.name\"&gt;&lt;/span&gt;\n &lt;/div&gt;\n</pre> </li> <li> <p><code>$parents</code></p> <p>This is an array representing all of the parent view models:</p> <p><code>$parents[0]</code> is the view model from the parent context (i.e., it’s the same as <code>$parent</code>)</p> <p><code>$parents[1]</code> is the view model from the grandparent context</p> <p><code>$parents[2]</code> is the view model from the great-grandparent context</p> <p>… and so on.</p> </li> <li> <p><code>$root</code></p> <p>This is the main view model object in the root context, i.e., the topmost parent context. It’s usually the object that was passed to <code>ko.applyBindings</code>. It is equivalent to <code>$parents[$parents.length - 1]</code>. </p> </li> <li> <p><code>$component</code></p> <p>If you’re within the context of a particular <a href=\"component-overview\">component</a> template, then <code>$component</code> refers to the viewmodel for that component. It’s the component-specific equivalent to <code>$root</code>. In the case of nested components, <code>$component</code> refers to the viewmodel for the closest component.</p> <p>This is useful, for example, if a component’s template includes one or more <code>foreach</code> blocks in which you wish to refer to some property or function on the component viewmodel rather than on the current data item.</p> </li> <li> <p><code>$data</code></p> <p>This is the view model object in the current context. In the root context, <code>$data</code> and <code>$root</code> are equivalent. Inside a nested binding context, this parameter will be set to the current data item (e.g., inside a <code>with: person</code> binding, <code>$data</code> will be set to <code>person</code>). <code>$data</code> is useful when you want to reference the viewmodel itself, rather than a property on the viewmodel. Example:</p> <pre> &lt;ul data-bind=\"foreach: ['cats', 'dogs', 'fish']\"&gt;\n     &lt;li&gt;The value is &lt;span data-bind=\"text: $data\"&gt;&lt;/span&gt;&lt;/li&gt;\n &lt;/ul&gt;\n</pre> </li> <li> <p><code>$index</code> (only available within <code>foreach</code> bindings)</p> <p>This is the zero-based index of the current array entry being rendered by a <code>foreach</code> binding. Unlike the other binding context properties, <code>$index</code> is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</p> </li> <li> <p><code>$parentContext</code></p> <p>This refers to the binding context object at the parent level. This is different from <code>$parent</code>, which refers to the <em>data</em> (not binding context) at the parent level. This is useful, for example, if you need to access the index value of an outer <code>foreach</code> item from an inner context (usage: <code>$parentContext.$index</code>). This is undefined in the root context.</p> </li> <li> <p><code>$rawData</code></p> <p>This is the raw view model value in the current context. Usually this will be the same as <code>$data</code>, but if the view model provided to Knockout is wrapped in an observable, <code>$data</code> will be the unwrapped view model, and <code>$rawData</code> will be the observable itself.</p> </li> <li> <p><code>$componentTemplateNodes</code></p> <p>If you’re within the context of a particular <a href=\"component-overview\">component</a> template, then <code>$componentTemplateNodes</code> is an array containing any DOM nodes that were passed to that component. This makes it easy to build components that receive templates, for example a grid component that accepts a template to define its output rows. For a complete example, see <a href=\"component-custom-elements#passing-markup-into-components\">passing markup into components</a>.</p> </li> </ul> <p>The following special variables are also available in bindings, but are not part of the binding context object:</p> <ul> <li> <p><code>$context</code></p> <p>This refers to the current binding context object. This may be useful if you want to access properties of the context when they might also exist in the view model, or if you want to pass the context object to a helper function in your view model.</p> </li> <li> <p><code>$element</code></p> <p>This is the element DOM object (for virtual elements, it will be the comment DOM object) of the current binding. This can be useful if a binding needs to access an attribute of the current element. Example:</p> <pre> &lt;div id=\"item1\" data-bind=\"text: $element.id\"&gt;&lt;/div&gt;\n</pre> </li> </ul> <h3 id=\"controlling-or-modifying-the-binding-context-in-custom-bindings\">Controlling or modifying the binding context in custom bindings</h3> <p>Just like the built-in bindings <a href=\"with-binding\"><code>with</code></a> and <a href=\"foreach-binding\"><code>foreach</code></a>, custom bindings can change the binding context for their descendant elements, or provide special properties by extending the binding context object. This is described in detail under <a href=\"custom-bindings-controlling-descendant-bindings\">creating custom bindings that control descendant bindings</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/binding-context.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/binding-context.html</a>\n  </p>\n</div>\n","custom-bindings-disposal":"<h1>Custom disposal logic</h1> <p>In a typical Knockout application, DOM elements are dynamically added and removed, for example using the <a href=\"template-binding\"><code>template</code></a> binding or via control-flow bindings (<a href=\"if-binding\"><code>if</code></a>, <a href=\"ifnot-binding\"><code>ifnot</code></a>, <a href=\"with-binding\"><code>with</code></a>, and <a href=\"foreach-binding\"><code>foreach</code></a>). When creating a custom binding, it is often desirable to add clean-up logic that runs when an element associated with your custom binding is removed by Knockout.</p> <h3 id=\"registering-a-callback-on-the-disposal-of-an-element\">Registering a callback on the disposal of an element</h3> <p>To register a function to run when a node is removed, you can call <code>ko.utils.domNodeDisposal.addDisposeCallback(node, callback)</code>. As an example, suppose you create a custom binding to instantiate a widget. When the element with the binding is removed, you may want to call the <code>destroy</code> method of the widget:</p> <pre>ko.bindingHandlers.myWidget = {\n    init: function(element, valueAccessor) {\n        var options = ko.unwrap(valueAccessor()),\n            $el = $(element);\n\n        $el.myWidget(options);\n\n        ko.utils.domNodeDisposal.addDisposeCallback(element, function() {\n            // This will be called when the element is removed by Knockout or\n            // if some other part of your code calls ko.removeNode(element)\n            $el.myWidget(\"destroy\");\n        });\n    }\n};\n</pre> <h3 id=\"overriding-the-clean-up-of-external-data\">Overriding the clean-up of external data</h3> <p>When removing an element, Knockout runs logic to clean up any data associated with the element. As part of this logic, Knockout calls jQuery’s <code>cleanData</code> method if jQuery is loaded in your page. In advanced scenarios, you may want to prevent or customize how this data is removed in your application. Knockout exposes a function, <code>ko.utils.domNodeDisposal.cleanExternalData(node)</code>, that can be overridden to support custom logic. For example, to prevent <code>cleanData</code> from being called, an empty function could be used to replace the standard <code>cleanExternalData</code> implementation:</p> <pre>ko.utils.domNodeDisposal.cleanExternalData = function () {\n    // Do nothing. Now any jQuery data associated with elements will\n    // not be cleaned up when the elements are removed from the DOM.\n};\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/custom-bindings-disposal.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/custom-bindings-disposal.html</a>\n  </p>\n</div>\n","custom-bindings":"<h1>Creating custom bindings</h1> <p>You’re not limited to using the built-in bindings like <code>click</code>, <code>value</code>, and so on — you can create your own ones. This is how to control how observables interact with DOM elements, and gives you a lot of flexibility to encapsulate sophisticated behaviors in an easy-to-reuse way.</p> <p>For example, you can create interactive components like grids, tabsets, and so on, in the form of custom bindings (see the <a href=\"http://knockoutjs.com/examples/grid.html\">grid example</a>).</p> <h3 id=\"registering-your-binding\">Registering your binding</h3> <p>To register a binding, add it as a subproperty of <code>ko.bindingHandlers</code>:</p> <pre>ko.bindingHandlers.yourBindingName = {\n    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        // This will be called when the binding is first applied to an element\n        // Set up any initial state, event handlers, etc. here\n    },\n    update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        // This will be called once when the binding is first applied to an element,\n        // and again whenever any observables/computeds that are accessed change\n        // Update the DOM element based on the supplied values here.\n    }\n};\n</pre> <p>… and then you can use it on any number of DOM elements:</p> <pre>&lt;div data-bind=\"yourBindingName: someValue\"&gt; &lt;/div&gt;\n</pre> <p>Note: you don’t actually have to provide both <code>init</code> <em>and</em> <code>update</code> callbacks — you can just provide one or the other if that’s all you need.</p> <h3 id=\"the-update-callback\">The “update” callback</h3> <p>Knockout will call the <code>update</code> callback initially when the binding is applied to an element and track any dependencies (observables/computeds) that you access. When any of these dependencies change, the <code>update</code> callback will be called once again. The following parameters are passed to it:</p> <ul> <li>\n<code>element</code> — The DOM element involved in this binding</li> <li>\n<code>valueAccessor</code> — A JavaScript function that you can call to get the current model property that is involved in this binding. Call this without passing any parameters (i.e., call <code>valueAccessor()</code>) to get the current model property value. To easily accept both observable and plain values, call <code>ko.unwrap</code> on the returned value.</li> <li>\n<code>allBindings</code> — A JavaScript object that you can use to access all the model values bound to this DOM element. Call <code>allBindings.get('name')</code> to retrieve the value of the <code>name</code> binding (returns <code>undefined</code> if the binding doesn’t exist); or <code>allBindings.has('name')</code> to determine if the <code>name</code> binding is present for the current element.</li> <li>\n<code>viewModel</code> — This parameter is deprecated in Knockout 3.x. Use <code>bindingContext.$data</code> or <code>bindingContext.$rawData</code> to access the view model instead.</li> <li>\n<code>bindingContext</code> — An object that holds the <a href=\"binding-context\">binding context</a> available to this element’s bindings. This object includes special properties including <code>$parent</code>, <code>$parents</code>, and <code>$root</code> that can be used to access data that is bound against ancestors of this context.</li> </ul> <p>For example, you might have been controlling an element’s visibility using the <code>visible</code> binding, but now you want to go a step further and animate the transition. You want elements to slide into and out of existence according to the value of an observable. You can do this by writing a custom binding that calls jQuery’s <code>slideUp</code>/<code>slideDown</code> functions:</p> <pre>ko.bindingHandlers.slideVisible = {\n    update: function(element, valueAccessor, allBindings) {\n        // First get the latest data that we're bound to\n        var value = valueAccessor();\n\n        // Next, whether or not the supplied model property is observable, get its current value\n        var valueUnwrapped = ko.unwrap(value);\n\n        // Grab some more data from another binding property\n        var duration = allBindings.get('slideDuration') || 400; // 400ms is default duration unless otherwise specified\n\n        // Now manipulate the DOM element\n        if (valueUnwrapped == true)\n            $(element).slideDown(duration); // Make the element visible\n        else\n            $(element).slideUp(duration);   // Make the element invisible\n    }\n};\n</pre> <p>Now you can use this binding as follows:</p> <pre>&lt;div data-bind=\"slideVisible: giftWrap, slideDuration:600\"&gt;You have selected the option&lt;/div&gt;\n&lt;label&gt;&lt;input type=\"checkbox\" data-bind=\"checked: giftWrap\" /&gt; Gift wrap&lt;/label&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        giftWrap: ko.observable(true)\n    };\n    ko.applyBindings(viewModel);\n&lt;/script&gt;\n</pre> <p>Of course, this is a lot of code at first glance, but once you’ve created your custom bindings they can very easily be reused in many places.</p> <h3 id=\"the-init-callback\">The “init” callback</h3> <p>Knockout will call your <code>init</code> function once for each DOM element that you use the binding on. There are two main uses for <code>init</code>:</p> <ul> <li>To set any initial state for the DOM element</li> <li>To register any event handlers so that, for example, when the user clicks on or modifies the DOM element, you can change the state of the associated observable</li> </ul> <p>KO will pass exactly the same set of parameters that it passes to <a href=\"#the-update-callback\">the <code>update</code> callback</a>.</p> <p>Continuing the previous example, you might want <code>slideVisible</code> to set the element to be instantly visible or invisible when the page first appears (without any animated slide), so that the animation only runs when the user changes the model state. You could do that as follows:</p> <pre>ko.bindingHandlers.slideVisible = {\n    init: function(element, valueAccessor) {\n        var value = ko.unwrap(valueAccessor()); // Get the current value of the current property we're bound to\n        $(element).toggle(value); // jQuery will hide/show the element depending on whether \"value\" or true or false\n    },\n    update: function(element, valueAccessor, allBindings) {\n        // Leave as before\n    }\n};\n</pre> <p>This means that if <code>giftWrap</code> was defined with the initial state <code>false</code> (i.e., <code>giftWrap: ko.observable(false)</code>) then the associated DIV would initially be hidden, and then would slide into view when the user later checks the box.</p> <h3 id=\"modifying-observables-after-dom-events\">Modifying observables after DOM events</h3> <p>You’ve already seen how to use <code>update</code> so that, when an observable changes, you can update an associated DOM element. But what about events in the other direction? When the user performs some action on a DOM element, you might want to updated an associated observable.</p> <p>You can use the <code>init</code> callback as a place to register an event handler that will cause changes to the associated observable. For example,</p> <pre>ko.bindingHandlers.hasFocus = {\n    init: function(element, valueAccessor) {\n        $(element).focus(function() {\n            var value = valueAccessor();\n            value(true);\n        });\n        $(element).blur(function() {\n            var value = valueAccessor();\n            value(false);\n        });\n    },\n    update: function(element, valueAccessor) {\n        var value = valueAccessor();\n        if (ko.unwrap(value))\n            element.focus();\n        else\n            element.blur();\n    }\n};\n</pre> <p>Now you can both read and write the “focusedness” of an element by binding it to an observable:</p> <pre>&lt;p&gt;Name: &lt;input data-bind=\"hasFocus: editingName\" /&gt;&lt;/p&gt;\n\n&lt;!-- Showing that we can both read and write the focus state --&gt;\n&lt;div data-bind=\"visible: editingName\"&gt;You're editing the name&lt;/div&gt;\n&lt;button data-bind=\"enable: !editingName(), click:function() { editingName(true) }\"&gt;Edit name&lt;/button&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n    var viewModel = {\n        editingName: ko.observable()\n    };\n    ko.applyBindings(viewModel);\n&lt;/script&gt;\n</pre> <h3 id=\"note-supporting-virtual-elements\">Note: Supporting virtual elements</h3> <p>If you want a custom binding to be usable with Knockout’s <em>virtual elements</em> syntax, e.g.:</p> <pre>&lt;!-- ko mybinding: somedata --&gt; ... &lt;!-- /ko --&gt;\n</pre> <p>… then see <a href=\"custom-bindings-for-virtual-elements\">the documentation for virtual elements</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/custom-bindings.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/custom-bindings.html</a>\n  </p>\n</div>\n","custom-bindings-controlling-descendant-bindings":"<h1>Creating custom bindings that control descendant bindings</h1> <p><em>Note: This is an advanced technique, typically used only when creating libraries of reusable bindings. It’s not something you’ll normally need to do when building applications with Knockout.</em></p> <p>By default, bindings only affect the element to which they are applied. But what if you want to affect all descendant elements too? This is possible. Your binding can tell Knockout <em>not</em> to bind descendants at all, and then your custom binding can do whatever it likes to bind them in a different way.</p> <p>To do this, simply return <code>{ controlsDescendantBindings: true }</code> from your binding’s <code>init</code> function.</p> <h3 id=\"example-controlling-whether-or-not-descendant-bindings-are-applied\">Example: Controlling whether or not descendant bindings are applied</h3> <p>For a very simple example, here’s a custom binding called <code>allowBindings</code> that allows descendant bindings to be applied only if its value is <code>true</code>. If the value is <code>false</code>, then <code>allowBindings</code> tells Knockout that it is responsible for descendant bindings so they won’t be bound as usual.</p> <pre>ko.bindingHandlers.allowBindings = {\n    init: function(elem, valueAccessor) {\n        // Let bindings proceed as normal *only if* my value is false\n        var shouldAllowBindings = ko.unwrap(valueAccessor());\n        return { controlsDescendantBindings: !shouldAllowBindings };\n    }\n};\n</pre> <p>To see this take effect, here’s a sample usage:</p> <pre>&lt;div data-bind=\"allowBindings: true\"&gt;\n    &lt;!-- This will display Replacement, because bindings are applied --&gt;\n    &lt;div data-bind=\"text: 'Replacement'\"&gt;Original&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;div data-bind=\"allowBindings: false\"&gt;\n    &lt;!-- This will display Original, because bindings are not applied --&gt;\n    &lt;div data-bind=\"text: 'Replacement'\"&gt;Original&lt;/div&gt;\n&lt;/div&gt;\n</pre> <h3 id=\"example-supplying-additional-values-to-descendant-bindings\">Example: Supplying additional values to descendant bindings</h3> <p>Normally, bindings that use <code>controlsDescendantBindings</code> will also call <code>ko.applyBindingsToDescendants(someBindingContext, element)</code> to apply the descendant bindings against some modified <a href=\"binding-context\">binding context</a>. For example, you could have a binding called <code>withProperties</code> that attaches some extra properties to the binding context that will then be available to all descendant bindings:</p> <pre>ko.bindingHandlers.withProperties = {\n    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        // Make a modified binding context, with a extra properties, and apply it to descendant elements\n        var innerBindingContext = bindingContext.extend(valueAccessor);\n        ko.applyBindingsToDescendants(innerBindingContext, element);\n\n        // Also tell KO *not* to bind the descendants itself, otherwise they will be bound twice\n        return { controlsDescendantBindings: true };\n    }\n};\n</pre> <p>As you can see, binding contexts have an <code>extend</code> function that produces a clone with extra properties. The <code>extend</code> function accepts either an object with the properties to copy or a function that returns such an object. The function syntax is preferred so that future changes in the binding value are always updated in the binding context. This process doesn’t affect the original binding context, so there is no danger of affecting sibling-level elements - it will only affect descendants.</p> <p>Here’s an example of using the above custom binding:</p> <pre>&lt;div data-bind=\"withProperties: { emotion: 'happy' }\"&gt;\n    Today I feel &lt;span data-bind=\"text: emotion\"&gt;&lt;/span&gt;. &lt;!-- Displays: happy --&gt;\n&lt;/div&gt;\n&lt;div data-bind=\"withProperties: { emotion: 'whimsical' }\"&gt;\n    Today I feel &lt;span data-bind=\"text: emotion\"&gt;&lt;/span&gt;. &lt;!-- Displays: whimsical --&gt;\n&lt;/div&gt;\n</pre> <h3 id=\"example-adding-extra-levels-in-the-binding-context-hierarchy\">Example: Adding extra levels in the binding context hierarchy</h3> <p>Bindings such as <a href=\"with-binding\"><code>with</code></a> and <a href=\"foreach-binding\"><code>foreach</code></a> create extra levels in the binding context hierarchy. This means that their descendants can access data at outer levels by using <code>$parent</code>, <code>$parents</code>, <code>$root</code>, or <code>$parentContext</code>.</p> <p>If you want to do this in custom bindings, then instead of using <code>bindingContext.extend()</code>, use <code>bindingContext.createChildContext(someData)</code>. This returns a new binding context whose viewmodel is <code>someData</code> and whose <code>$parentContext</code> is <code>bindingContext</code>. If you want, you can then extend the child context with extra properties using <code>ko.utils.extend</code>. For example,</p> <pre>ko.bindingHandlers.withProperties = {\n    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        // Make a modified binding context, with a extra properties, and apply it to descendant elements\n        var childBindingContext = bindingContext.createChildContext(\n            bindingContext.$rawData, \n            null, // Optionally, pass a string here as an alias for the data item in descendant contexts\n            function(context) {\n                ko.utils.extend(context, valueAccessor());\n            });\n        ko.applyBindingsToDescendants(childBindingContext, element);\n\n        // Also tell KO *not* to bind the descendants itself, otherwise they will be bound twice\n        return { controlsDescendantBindings: true };\n    }\n};\n</pre> <p>This updated <code>withProperties</code> binding could now be used in a nested way, with each level of nesting able to access the parent level via <code>$parentContext</code>:</p> <pre>&lt;div data-bind=\"withProperties: { displayMode: 'twoColumn' }\"&gt;\n    The outer display mode is &lt;span data-bind=\"text: displayMode\"&gt;&lt;/span&gt;.\n    &lt;div data-bind=\"withProperties: { displayMode: 'doubleWidth' }\"&gt;\n        The inner display mode is &lt;span data-bind=\"text: displayMode\"&gt;&lt;/span&gt;, but I haven't forgotten\n        that the outer display mode is &lt;span data-bind=\"text: $parentContext.displayMode\"&gt;&lt;/span&gt;.\n    &lt;/div&gt;\n&lt;/div&gt;\n</pre> <p>By modifying binding contexts and controlling descendant bindings, you have a powerful and advanced tool to create custom binding mechanisms of your own.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/custom-bindings-controlling-descendant-bindings.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/custom-bindings-controlling-descendant-bindings.html</a>\n  </p>\n</div>\n","custom-bindings-for-virtual-elements":"<h1>Creating custom bindings that support virtual elements</h1> <p><em>Note: This is an advanced technique, typically used only when creating libraries of reusable bindings. It’s not something you’ll normally need to do when building applications with Knockout.</em></p> <p>Knockout’s <em>control flow bindings</em> (e.g., <a href=\"if-binding\"><code>if</code></a> and <a href=\"foreach-binding\"><code>foreach</code></a>) can be applied not only to regular DOM elements, but also to “virtual” DOM elements defined by a special comment-based syntax. For example:</p> <pre>&lt;ul&gt;\n    &lt;li class=\"heading\"&gt;My heading&lt;/li&gt;\n    &lt;!-- ko foreach: items --&gt;\n        &lt;li data-bind=\"text: $data\"&gt;&lt;/li&gt;\n    &lt;!-- /ko --&gt;\n&lt;/ul&gt;\n</pre> <p>Custom bindings can work with virtual elements too, but to enable this, you must explicitly tell Knockout that your binding understands virtual elements, by using the <code>ko.virtualElements.allowedBindings</code> API.</p> <h3 id=\"example\">Example</h3> <p>To get started, here’s a custom binding that randomises the order of DOM nodes:</p> <pre>ko.bindingHandlers.randomOrder = {\n    init: function(elem, valueAccessor) {\n        // Pull out each of the child elements into an array\n        var childElems = [];\n        while(elem.firstChild)\n            childElems.push(elem.removeChild(elem.firstChild));\n\n        // Put them back in a random order\n        while(childElems.length) {\n            var randomIndex = Math.floor(Math.random() * childElems.length),\n                chosenChild = childElems.splice(randomIndex, 1);\n            elem.appendChild(chosenChild[0]);\n        }\n    }\n};\n</pre> <p>This works nicely with regular DOM elements. The following elements will be shuffled into a random order:</p> <pre>&lt;div data-bind=\"randomOrder: true\"&gt;\n    &lt;div&gt;First&lt;/div&gt;\n    &lt;div&gt;Second&lt;/div&gt;\n    &lt;div&gt;Third&lt;/div&gt;\n&lt;/div&gt;\n</pre> <p>However, it does <em>not</em> work with virtual elements. If you try the following:</p> <pre>&lt;!-- ko randomOrder: true --&gt;\n    &lt;div&gt;First&lt;/div&gt;\n    &lt;div&gt;Second&lt;/div&gt;\n    &lt;div&gt;Third&lt;/div&gt;\n&lt;!-- /ko --&gt;\n</pre> <p>… then you’ll get the error <code>The binding 'randomOrder' cannot be used with virtual elements</code>. Let’s fix this. To make <code>randomOrder</code> usable with virtual elements, start by telling Knockout to allow it. Add the following:</p> <pre>ko.virtualElements.allowedBindings.randomOrder = true;\n</pre> <p>Now there won’t be an error. However, it still won’t work properly, because our <code>randomOrder</code> binding is coded using normal DOM API calls (<code>firstChild</code>, <code>appendChild</code>, etc.) which don’t understand virtual elements. This is the reason why KO requires you to explicitly opt in to virtual element support: unless your custom binding is coded using virtual element APIs, it’s not going to work properly!</p> <p>Let’s update the code for <code>randomOrder</code>, this time using KO’s virtual element APIs:</p> <pre>ko.bindingHandlers.randomOrder = {\n    init: function(elem, valueAccessor) {\n        // Build an array of child elements\n        var child = ko.virtualElements.firstChild(elem),\n            childElems = [];\n        while (child) {\n            childElems.push(child);\n            child = ko.virtualElements.nextSibling(child);\n        }\n\n        // Remove them all, then put them back in a random order\n        ko.virtualElements.emptyNode(elem);\n        while(childElems.length) {\n            var randomIndex = Math.floor(Math.random() * childElems.length),\n                chosenChild = childElems.splice(randomIndex, 1);\n            ko.virtualElements.prepend(elem, chosenChild[0]);\n        }\n    }\n};\n</pre> <p>Notice how, instead of using APIs like <code>domElement.firstChild</code>, we’re now using <code>ko.virtualElements.firstChild(domOrVirtualElement)</code>. The <code>randomOrder</code> binding will now correctly work with virtual elements, e.g., <code>&lt;!-- ko randomOrder: true --&gt;...&lt;!-- /ko --&gt;</code>.</p> <p>Also, <code>randomOrder</code> will still work with regular DOM elements, because all of the <code>ko.virtualElements</code> APIs are backwardly compatible with regular DOM elements.</p> <h3 id=\"virtual-element-apis\">Virtual Element APIs</h3> <p>Knockout provides the following functions for working with virtual elements.</p> <ul> <li> <p><code>ko.virtualElements.allowedBindings</code></p> <p>An object whose keys determine which bindings are usable with virtual elements. Set <code>ko.virtualElements.allowedBindings.mySuperBinding = true</code> to allow <code>mySuperBinding</code> to be used with virtual elements.</p> </li> <li> <p><code>ko.virtualElements.emptyNode(containerElem)</code></p> <p>Removes all child nodes from the real or virtual element <code>containerElem</code> (cleaning away any data associated with them to avoid memory leaks).</p> </li> <li> <p><code>ko.virtualElements.firstChild(containerElem)</code></p> <p>Returns the first child of the real or virtual element <code>containerElem</code>, or <code>null</code> if there are no children.</p> </li> <li> <p><code>ko.virtualElements.insertAfter(containerElem, nodeToInsert, insertAfter)</code></p> <p>Inserts <code>nodeToInsert</code> as a child of the real or virtual element <code>containerElem</code>, positioned immediately after <code>insertAfter</code> (where <code>insertAfter</code> must be a child of <code>containerElem</code>).</p> </li> <li> <p><code>ko.virtualElements.nextSibling(node)</code></p> <p>Returns the sibling node that follows <code>node</code> in its real or virtual parent element, or <code>null</code> if there is no following sibling.</p> </li> <li> <p><code>ko.virtualElements.prepend(containerElem, nodeToPrepend)</code></p> <p>Inserts <code>nodeToPrepend</code> as the first child of the real or virtual element <code>containerElem</code>.</p> </li> <li> <p><code>ko.virtualElements.setDomNodeChildren(containerElem, arrayOfNodes)</code></p> <p>Removes all child nodes from the real or virtual element <code>containerElem</code> (in the process, cleaning away any data associated with them to avoid memory leaks), and then inserts all of the nodes from <code>arrayOfNodes</code> as its new children.</p> </li> </ul> <p>Notice that this is <em>not</em> intended to be a complete replacement to the full set of regular DOM APIs. Knockout provides only a minimal set of virtual element APIs to make it possible to perform the kinds of transformations needed when implementing control flow bindings.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/custom-bindings-for-virtual-elements.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/custom-bindings-for-virtual-elements.html</a>\n  </p>\n</div>\n","binding-preprocessing":"<h1>Extending Knockout's binding syntax using preprocessing</h1> <p><em>Note: This is an advanced technique, typically used only when creating libraries of reusable bindings or extended syntaxes. It’s not something you’ll normally need to do when building applications with Knockout.</em></p> <p>Starting with Knockout 3.0, developers can define custom syntaxes by providing callbacks that rewrite DOM nodes and binding strings during the binding process.</p> <h2 id=\"preprocessing-binding-strings\">Preprocessing binding strings</h2> <p>You can hook into Knockout’s logic for interpreting <code>data-bind</code> attributes by providing a <em>binding preprocessor</em> for a specific binding handler (such as <code>click</code>, <code>visible</code>, or any <a href=\"custom-bindings\">custom binding handler</a>).</p> <p>To do this, attach a <code>preprocess</code> function to the binding handler:</p> <pre>ko.bindingHandlers.yourBindingHandler.preprocess = function(stringFromMarkup) {\n    // Return stringFromMarkup if you don't want to change anything, or return\n    // some other string if you want Knockout to behave as if that was the\n    // syntax provided in the original HTML\n}\n</pre> <p>See later on this page for an API reference.</p> <h3 id=\"example-1-setting-a-default-value-for-a-binding\">Example 1: Setting a default value for a binding</h3> <p>If you leave off the value of a binding, it’s bound to <code>undefined</code> by default. If you want to have a different default value for a binding, you can do so with a preprocessor. For example, you can allow <code>uniqueName</code> to be bound without a value by making its default value <code>true</code>:</p> <pre>ko.bindingHandlers.uniqueName.preprocess = function(val) {\n    return val || 'true';\n}\n</pre> <p>Now you can bind it like this:</p> <pre>&lt;input data-bind=\"value: someModelProperty, uniqueName\" /&gt;\n</pre> <h3 id=\"example-2-binding-expressions-to-events\">Example 2: Binding expressions to events</h3> <p>If you’d like to be able to bind expressions to <code>click</code> events (rather than a function reference as Knockout expects), you can set up a preprocessor for the <code>click</code> handler to support this syntax:</p> <pre>ko.bindingHandlers.click.preprocess = function(val) {\n    return 'function($data,$event){ ' + val + ' }';\n}\n</pre> <p>Now you can bind <code>click</code> like this:</p> <pre>&lt;button type=\"button\" data-bind=\"click: myCount(myCount()+1)\"&gt;Increment&lt;/button&gt;\n</pre> <h3 id=\"binding-preprocessor-reference\">Binding preprocessor reference</h3> <ul> <li> <p><code>ko.bindingHandlers.&lt;name&gt;.preprocess(value, name, addBindingCallback)</code></p> <p>If defined, this function will be called for each <code>&lt;name&gt;</code> binding before the binding is evaluated.</p> <p><strong>Parameters:</strong></p> <ul> <li> <p><code>value</code>: the syntax associated with the binding value before Knockout attempts to parse it (e.g., for <code>yourBinding: 1 + 1</code>, the associated value is <code>\"1 + 1\"</code> as a string).</p> </li> <li> <p><code>name</code>: the name of the binding (e.g., for <code>yourBinding: 1 + 1</code>, the name is <code>\"yourBinding\"</code> as a string).</p> </li> <li> <p><code>addBinding</code>: a callback function you can optionally use to insert another binding on the current element. This requires two parameters, <code>name</code> and <code>value</code>. For example, inside your <code>preprocess</code> function, call <code>addBinding('visible', 'acceptsTerms()');</code> to make Knockout behave as if the element had a <code>visible: acceptsTerms()</code> binding on it.</p> </li> </ul> <p><strong>Return value</strong>:</p> <p>Your <code>preprocess</code> function must return the new string value to be parsed and passed to the binding, or return <code>undefined</code> to remove the binding.</p> <p>For example, if you return <code>'value + \".toUpperCase()\"'</code> as a string, then <code>yourBinding: \"Bert\"</code> would be interpreted as if the markup contained <code>yourBinding: \"Bert\".toUpperCase()</code>. Knockout will parse the returned value in the normal way, so it has to be a legal JavaScript expression.</p> <p>Don’t return non-string values. That wouldn’t make sense, because markup is always a string.</p> </li> </ul> <h2 id=\"preprocessing-dom-nodes\">Preprocessing DOM nodes</h2> <p>You can hook into Knockout’s logic for traversing the DOM by providing a <em>node preprocessor</em>. This is a function that Knockout will call once for each DOM node that it walks over, both when the UI is first bound, and later when any new DOM subtrees are injected (e.g., via a <a href=\"foreach-binding\"><code>foreach</code> binding</a>).</p> <p>To do this, define a <code>preprocessNode</code> function on your binding provider:</p> <pre>ko.bindingProvider.instance.preprocessNode = function(node) {\n    // Use DOM APIs such as setAttribute to modify 'node' if you wish.\n    // If you want to leave 'node' in the DOM, return null or have no 'return' statement.\n    // If you want to replace 'node' with some other set of nodes,\n    //    - Use DOM APIs such as insertChild to inject the new nodes\n    //      immediately before 'node'\n    //    - Use DOM APIs such as removeChild to remove 'node' if required\n    //    - Return an array of any new nodes that you've just inserted\n    //      so that Knockout can apply any bindings to them\n}\n</pre> <p>See later on this page for an API reference.</p> <h3 id=\"example-3-virtual-template-elements\">Example 3: Virtual template elements</h3> <p>If you commonly include template content using virtual elements, the normal syntax can feel a bit verbose. Using preprocessing, you can add a new template format that uses a single comment:</p> <pre>ko.bindingProvider.instance.preprocessNode = function(node) {\n    // Only react if this is a comment node of the form &lt;!-- template: ... --&gt;\n    if (node.nodeType == 8) {\n        var match = node.nodeValue.match(/^\\s*(template\\s*:[\\s\\S]+)/);\n        if (match) {\n            // Create a pair of comments to replace the single comment\n            var c1 = document.createComment(\"ko \" + match[1]),\n                c2 = document.createComment(\"/ko\");\n            node.parentNode.insertBefore(c1, node);\n            node.parentNode.replaceChild(c2, node);\n\n            // Tell Knockout about the new nodes so that it can apply bindings to them\n            return [c1, c2];\n        }\n    }\n}\n</pre> <p>Now you can include a template in your view like this:</p> <pre>&lt;!-- template: 'some-template' --&gt;\n</pre> <h3 id=\"preprocessing-reference\">Preprocessing Reference</h3> <ul> <li> <p><code>ko.bindingProvider.instance.preprocessNode(node)</code></p> <p>If defined, this function will be called for each DOM node before bindings are processed. The function can modify, remove, or replace <code>node</code>. Any new nodes must be inserted immediately before <code>node</code>, and if any nodes were added or <code>node</code> was removed, the function must return an array of the new nodes that are now in the document in place of <code>node</code>.</p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/binding-preprocessing.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/binding-preprocessing.html</a>\n  </p>\n</div>\n","component-overview":"<h1>Components and Custom Elements - Overview</h1> <p><strong>Components</strong> are a powerful, clean way of organizing your UI code into self-contained, reusable chunks. They:</p> <ul> <li>…can represent individual controls/widgets, or entire sections of your application</li> <li>…contain their own view, and usually (but optionally) their own viewmodel</li> <li>…can either be preloaded, or loaded asynchronously (on demand) via AMD or other module systems</li> <li>…can receive parameters, and optionally write back changes to them or invoke callbacks</li> <li>…can be composed together (nested) or inherited from other components</li> <li>…can easily be packaged for reuse across projects</li> <li>…let you define your own conventions/logic for configuration and loading</li> </ul> <p>This pattern is beneficial for large applications, because it <strong>simplifies development</strong> through clear organization and encapsulation, and helps to <strong>improve runtime performance</strong> by incrementally loading your application code and templates as needed.</p> <p><strong>Custom elements</strong> are an optional but convenient syntax for consuming components. Instead of needing placeholder <code>&lt;div&gt;</code>s into which components are injected with bindings, you can use more self-descriptive markup with custom element names (e.g., <code>&lt;voting-button&gt;</code> or <code>&lt;product-editor&gt;</code>). Knockout takes care to ensure compatibility even with old browsers such as IE 6.</p> <h3 id=\"example-a-likedislike-widget\">Example: A like/dislike widget</h3> <p>To get started, you can register a component using <code>ko.components.register</code> (technically, registration is optional, but it’s the easiest way to get started). A component definition specifies a <code>viewModel</code> and <code>template</code>. For example:</p> <pre>ko.components.register('like-widget', {\n    viewModel: function(params) {\n        // Data: value is either null, 'like', or 'dislike'\n        this.chosenValue = params.value;\n        \n        // Behaviors\n        this.like = function() { this.chosenValue('like'); }.bind(this);\n        this.dislike = function() { this.chosenValue('dislike'); }.bind(this);\n    },\n    template:\n        '&lt;div class=\"like-or-dislike\" data-bind=\"visible: !chosenValue()\"&gt;\\\n            &lt;button data-bind=\"click: like\"&gt;Like it&lt;/button&gt;\\\n            &lt;button data-bind=\"click: dislike\"&gt;Dislike it&lt;/button&gt;\\\n        &lt;/div&gt;\\\n        &lt;div class=\"result\" data-bind=\"visible: chosenValue\"&gt;\\\n            You &lt;strong data-bind=\"text: chosenValue\"&gt;&lt;/strong&gt; it\\\n        &lt;/div&gt;'\n});\n</pre> <p><strong>Normally, you’d load the view model and template from external files</strong> instead of declaring them inline like this. We’ll get to that later.</p> <p>Now, to use this component, you can reference it from any other view in your application, either using the <a href=\"component-binding\"><code>component</code> binding</a> or using a <a href=\"component-custom-elements\">custom element</a>. Here’s a live example that uses it as a custom element:</p>   <div class=\"liveExample\" id=\"component-inline\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n    &lt;ul data-bind=\"foreach: products\"&gt;\n        &lt;li class=\"product\"&gt;\n            &lt;strong data-bind=\"text: name\"&gt;&lt;/strong&gt;\n            &lt;like-widget params=\"value: userRating\"&gt;&lt;/like-widget&gt;\n        &lt;/li&gt;\n    &lt;/ul&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\n    function Product(name, rating) {\n        this.name = name;\n        this.userRating = ko.observable(rating || null);\n    }\n\n    function MyViewModel() {\n        this.products = [\n            new Product('Garlic bread'),\n            new Product('Pain au chocolat'),\n            new Product('Seagull spaghetti', 'like') // This one was already 'liked'\n        ];\n    }\n\n    ko.applyBindings(new MyViewModel());\n</pre> <p>In this example, the component both displays and edits an observable property called <code>userRating</code> on the <code>Product</code> view model class.</p> <h3 id=\"example-loading-the-likedislike-widget-from-external-files-on-demand\">Example: Loading the like/dislike widget from external files, on demand</h3> <p>In most applications, you’ll want to keep component view models and templates in external files. If you configure Knockout to fetch them via an AMD module loader such as <a href=\"http://requirejs.org/\">require.js</a>, then they can either be preloaded (possibly bundled/minified), or incrementally loaded as needed.</p> <p>Here’s an example configuration:</p> <pre>ko.components.register('like-or-dislike', {\n    viewModel: { require: 'files/component-like-widget' },\n    template: { require: 'text!files/component-like-widget.html' }\n});\n</pre> <p><strong>Requirements</strong></p> <p>For this to work, the files <a href=\"files/component-like-widget.js\"><code>files/component-like-widget.js</code></a> and <a href=\"files/component-like-widget\"><code>files/component-like-widget.html</code></a> need to exist. Check them out (and <em>view source</em> on the .html one) - as you’ll see, this is cleaner and more convenient that including the code inline in the definition.</p> <p>Also, you need to have referenced a suitable module loader library (such as <a href=\"http://requirejs.org/\">require.js</a>) or implemented a <a href=\"component-loaders\">custom component loader</a> that knows how to grab your files.</p> <p><strong>Using the component</strong></p> <p>Now <code>like-or-dislike</code> can be consumed in the same way as before, using either a <a href=\"component-binding\"><code>component</code> binding</a> or a <a href=\"component-custom-elements\">custom element</a>:</p>  <div class=\"liveExample\" id=\"component-amd\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n    &lt;ul data-bind=\"foreach: products\"&gt;\n        &lt;li class=\"product\"&gt;\n            &lt;strong data-bind=\"text: name\"&gt;&lt;/strong&gt;\n            &lt;like-or-dislike params=\"value: userRating\"&gt;&lt;/like-or-dislike&gt;\n        &lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;button data-bind=\"click: addProduct\"&gt;Add a product&lt;/button&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\n    function Product(name, rating) {\n        this.name = name;\n        this.userRating = ko.observable(rating || null);\n    }\n\n    function MyViewModel() {\n        this.products = ko.observableArray(); // Start empty\n    }\n\n    MyViewModel.prototype.addProduct = function() {\n        var name = 'Product ' + (this.products().length + 1);\n        this.products.push(new Product(name));\n    };\n\n    ko.applyBindings(new MyViewModel());\n</pre> <p>If you open your browser developer tools’ <strong>Network</strong> inspector before your first click on <em>Add product</em>, you’ll see that the component’s <code>.js</code>/<code>.html</code> files are fetched on demand when first required, and thereafter retained for reuse.</p> <h3 id=\"learn-more\">Learn more</h3> <p>More more detailed information, see:</p> <ul> <li><a href=\"component-registration\">Defining and registering components</a></li> <li><a href=\"component-binding\">Using the <code>component</code> binding</a></li> <li><a href=\"component-custom-elements\">Using custom elements</a></li> <li><a href=\"component-loaders\">Advanced: Custom component loaders</a></li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/component-overview.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/component-overview.html</a>\n  </p>\n</div>\n","component-registration":"<h1>Component registration</h1> <p>For Knockout to be able to load and instantiate your components, you must register them using <code>ko.components.register</code>, providing a configuration as described here.</p> <p><em>Note: As an alternative, it’s possible to implement a <a href=\"component-loaders\">custom component loader</a> that fetches components by your own conventions instead of explicit configuration.</em></p> <ul id=\"markdown-toc\"> <li>\n<a href=\"#registering-components-as-a-viewmodeltemplate-pair\">Registering components as a viewmodel/template pair</a> <ul> <li>\n<a href=\"#specifying-a-viewmodel\">Specifying a viewmodel</a> <ul> <li><a href=\"#a-constructor-function\">A constructor function</a></li> <li><a href=\"#a-shared-object-instance\">A shared object instance</a></li> <li><a href=\"#a-createviewmodel-factory-function\">A <code>createViewModel</code> factory function</a></li> <li><a href=\"#an-amd-module-whose-value-describes-a-viewmodel\">An AMD module whose value describes a viewmodel</a></li> </ul> </li> <li>\n<a href=\"#specifying-a-template\">Specifying a template</a> <ul> <li><a href=\"#an-existing-element-id\">An existing element ID</a></li> <li><a href=\"#an-existing-element-instance\">An existing element instance</a></li> <li><a href=\"#a-string-of-markup\">A string of markup</a></li> <li><a href=\"#an-array-of-dom-nodes\">An array of DOM nodes</a></li> <li><a href=\"#a-document-fragment\">A document fragment</a></li> <li><a href=\"#an-amd-module-whose-value-describes-a-template\">An AMD module whose value describes a template</a></li> </ul> </li> <li>\n<a href=\"#specifying-additional-component-options\">Specifying additional component options</a> <ul> <li><a href=\"#controlling-synchronousasynchronous-loading\">Controlling synchronous/asynchronous loading</a></li> </ul> </li> </ul> </li> <li>\n<a href=\"#how-knockout-loads-components-via-amd\">How Knockout loads components via AMD</a> <ul> <li><a href=\"#amd-modules-are-loaded-only-on-demand\">AMD modules are loaded only on demand</a></li> </ul> </li> <li>\n<a href=\"#registering-components-as-a-single-amd-module\">Registering components as a single AMD module</a> <ul> <li><a href=\"#a-recommended-amd-module-pattern\">A recommended AMD module pattern</a></li> </ul> </li> </ul> <h2 id=\"registering-components-as-a-viewmodeltemplate-pair\">Registering components as a viewmodel/template pair</h2> <p>You can register a component as follows:</p> <pre>ko.components.register('some-component-name', {\n    viewModel: &lt;see below&gt;,\n    template: &lt;see below&gt;\n});\n</pre> <ul> <li>The component <strong>name</strong> can be any nonempty string. It’s recommended, but not mandatory, to use lowercase dash-separated strings (such as <code>your-component-name</code>) so that the component name is valid to use as a <a href=\"component-custom-elements\">custom element</a> (such as <code>&lt;your-component-name&gt;</code>).</li> <li>\n<code>viewModel</code> is optional, and can take any of <a href=\"#specifying-a-viewmodel\">the <code>viewModel</code> formats described below</a>.</li> <li>\n<code>template</code> is required, and can take any of <a href=\"#specifying-a-template\">the <code>template</code> formats described below</a>.</li> </ul> <p>If no viewmodel is given, the component is treated as a simple block of HTML that will be bound to any parameters passed to the component.</p> <h3 id=\"specifying-a-viewmodel\">Specifying a viewmodel</h3> <p>Viewmodels can be specified in any of the following forms:</p> <h4 id=\"a-constructor-function\">A constructor function</h4> <pre>function SomeComponentViewModel(params) {\n    // 'params' is an object whose key/value pairs are the parameters\n    // passed from the component binding or custom element.\n    this.someProperty = params.something;\n}\n\nSomeComponentViewModel.prototype.doSomething = function() { ... };\n\nko.components.register('my-component', {\n    viewModel: SomeComponentViewModel,\n    template: ...\n});\n</pre> <p>Knockout will invoke your constructor once for each instance of the component, producing a separate viewmodel object for each. Properties on the resulting object or its prototype chain (e.g., <code>someProperty</code> and <code>doSomething</code> in the example above) are available for binding in the component’s view.</p> <h4 id=\"a-shared-object-instance\">A shared object instance</h4> <p>If you want all instances of your component to share the same viewmodel object instance (which is not usually desirable):</p> <pre>var sharedViewModelInstance = { ... };\n\nko.components.register('my-component', {\n    viewModel: { instance: sharedViewModelInstance },\n    template: ...\n});\n</pre> <p>Note that it’s necessary to specify <code>viewModel: { instance: object }</code>, and not just <code>viewModel: object</code>. This differentiates from the other cases below.</p> <h4 id=\"a-createviewmodel-factory-function\">A <code>createViewModel</code> factory function</h4> <p>If you want to run any setup logic on the associated element before it is bound to the viewmodel, or use arbitrary logic to decide which viewmodel class to instantiate:</p> <pre>ko.components.register('my-component', {\n    viewModel: {\n        createViewModel: function(params, componentInfo) {\n            // - 'params' is an object whose key/value pairs are the parameters\n            //   passed from the component binding or custom element\n            // - 'componentInfo.element' is the element the component is being\n            //   injected into. When createViewModel is called, the template has\n            //   already been injected into this element, but isn't yet bound.\n            // - 'componentInfo.templateNodes' is an array containing any DOM\n            //   nodes that have been supplied to the component. See below.\n\n            // Return the desired view model instance, e.g.:\n            return new MyViewModel(params);\n        }\n    },\n    template: ...\n});\n</pre> <p>Note that, typically, it’s best to perform direct DOM manipulation only through <a href=\"custom-bindings\">custom bindings</a> rather than acting on <code>componentInfo.element</code> from inside <code>createViewModel</code>. This leads to more modular, reusable code.</p> <p>The <code>componentInfo.templateNodes</code> array is useful if you want to build a component that accepts arbitrary markup to influence its output (for example, a grid, list, dialog, or tab set that injects supplied markup into itself). For a complete example, see <a href=\"component-custom-elements#passing-markup-into-components\">passing markup into components</a>.</p> <h4 id=\"an-amd-module-whose-value-describes-a-viewmodel\">An AMD module whose value describes a viewmodel</h4> <p>If you have an AMD loader (such as <a href=\"http://requirejs.org/\">require.js</a>) already in your page, then you can use it to fetch a viewmodel. For more details about how this works, see <a href=\"#how-knockout-loads-components-via-amd\">how Knockout loads components via AMD</a> below. Example:</p> <pre>ko.components.register('my-component', {\n    viewModel: { require: 'some/module/name' },\n    template: ...\n});\n</pre> <p>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a constructor function, e.g.:</p> <pre>// AMD module whose value is a component viewmodel constructor\ndefine(['knockout'], function(ko) {\n    function MyViewModel() {\n        // ...\n    }\n\n    return MyViewModel;\n});\n</pre> <p>… or a shared object instance, e.g.:</p> <pre>// AMD module whose value is a shared component viewmodel instance\ndefine(['knockout'], function(ko) {\n    function MyViewModel() {\n        // ...\n    }\n\n    return { instance: new MyViewModel() };\n});\n</pre> <p>… or a <code>createViewModel</code> function, e.g.:</p> <pre>// AMD module whose value is a 'createViewModel' function\ndefine(['knockout'], function(ko) {\n    function myViewModelFactory(params, componentInfo) {\n        // return something\n    }\n    \n    return { createViewModel: myViewModelFactory };\n});\n</pre> <p>… or even, though it’s unlikely you’d want to do this, a reference to a different AMD module, e.g.:</p> <pre>// AMD module whose value is a reference to a different AMD module,\n// which in turn can be in any of these formats\ndefine(['knockout'], function(ko) {\n    return { module: 'some/other/module' };\n});\n</pre> <h3 id=\"specifying-a-template\">Specifying a template</h3> <p>Templates can be specified in any of the following forms. The most commonly useful are <a href=\"#an-existing-element-id\">existing element IDs</a> and <a href=\"#an-amd-module-whose-value-describes-a-template\">AMD modules</a>.</p> <h4 id=\"an-existing-element-id\">An existing element ID</h4> <p>For example, the following element:</p> <pre>&lt;template id='my-component-template'&gt;\n    &lt;h1 data-bind='text: title'&gt;&lt;/h1&gt;\n    &lt;button data-bind='click: doSomething'&gt;Click me right now&lt;/button&gt;\n&lt;/template&gt;\n</pre> <p>… can be used as the template for a component by specifying its ID:</p> <pre>ko.components.register('my-component', {\n    template: { element: 'my-component-template' },\n    viewModel: ...\n});\n</pre> <p>Note that only the nodes <em>inside</em> the specified element will be cloned into each instance of the component. The container element (in this example, the <code>&lt;template&gt;</code> element), will <em>not</em> be treated as part of the component template.</p> <p>You’re not limited to using <code>&lt;template&gt;</code> elements, but these are convenient (on browsers that support them) since they don’t get rendered on their own. Any other element type works too.</p> <h4 id=\"an-existing-element-instance\">An existing element instance</h4> <p>If you have a reference to a DOM element in your code, you can use it as a container for template markup:</p> <pre>var elemInstance = document.getElementById('my-component-template');\n\nko.components.register('my-component', {\n    template: { element: elemInstance },\n    viewModel: ...\n});\n</pre> <p>Again, only the nodes <em>inside</em> the specified element will be cloned for use as the component’s template.</p> <h4 id=\"a-string-of-markup\">A string of markup</h4> <pre>ko.components.register('my-component', {\n    template: '&lt;h1 data-bind=\"text: title\"&gt;&lt;/h1&gt;\\\n               &lt;button data-bind=\"click: doSomething\"&gt;Clickety&lt;/button&gt;',\n    viewModel: ...\n});\n</pre> <p>This is mainly useful when you’re fetching the markup from somewhere programmatically (e.g., <a href=\"#a-recommended-amd-module-pattern\">AMD - see below</a>), or as a build system output that packages components for distribution, since it’s not very convenient to manually edit HTML as a JavaScript string literal.</p> <h4 id=\"an-array-of-dom-nodes\">An array of DOM nodes</h4> <p>If you’re building configurations programmatically and you have an array of DOM nodes, you can use them as a component template:</p> <pre>var myNodes = [\n    document.getElementById('first-node'),\n    document.getElementById('second-node'),\n    document.getElementById('third-node')\n];\n\nko.components.register('my-component', {\n    template: myNodes,\n    viewModel: ...\n});\n</pre> <p>In this case, all the specified nodes (and their descendants) will be cloned and concatenated into each copy of the component that gets instantiated.</p> <h4 id=\"a-document-fragment\">A document fragment</h4> <p>If you’re building configurations programmatically and you have a <code>DocumentFragment</code> object, you can use it as a component template:</p> <pre>ko.components.register('my-component', {\n    template: someDocumentFragmentInstance,\n    viewModel: ...\n});\n</pre> <p>Since document fragments can have multiple top-level nodes, the <em>entire</em> document fragment (not just descendants of top-level nodes) is treated as the component template.</p> <h4 id=\"an-amd-module-whose-value-describes-a-template\">An AMD module whose value describes a template</h4> <p>If you have an AMD loader (such as <a href=\"http://requirejs.org/\">require.js</a>) already in your page, then you can use it to fetch a template. For more details about how this works, see <a href=\"#how-knockout-loads-components-via-amd\">how Knockout loads components via AMD</a> below. Example:</p> <pre>ko.components.register('my-component', {\n    template: { require: 'some/template' },\n    viewModel: ...\n});\n</pre> <p>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a string of markup, e.g. fetched using <a href=\"http://requirejs.org/docs/api.html#text\">require.js’s text plugin</a>:</p> <pre>ko.components.register('my-component', {\n    template: { require: 'text!path/my-html-file.html' },\n    viewModel: ...\n});\n</pre> <p>… or any of the other forms described here, though it would be unusual for the others to be useful when fetching templates via AMD.</p> <h3 id=\"specifying-additional-component-options\">Specifying additional component options</h3> <p>As well as (or instead of) <code>template</code> and <code>viewModel</code>, your component configuration object can have arbitrary other properties. This configuration object is made available to any <a href=\"component-loaders\">custom component loader</a> you may be using.</p> <h4 id=\"controlling-synchronousasynchronous-loading\">Controlling synchronous/asynchronous loading</h4> <p>If your component configuration has a boolean <code>synchronous</code> property, Knockout uses this to determine whether the component is allowed to be loaded and injected synchronously. The default is <code>false</code> (i.e., forced to be asynchronous). For example,</p> <pre>ko.components.register('my-component', {\n    viewModel: { ... anything ... },\n    template: { ... anything ... },\n    synchronous: true // Injects synchronously if possible, otherwise still async\n});\n</pre> <p><strong>Why is component loading normally forced to be asynchronous?</strong></p> <p>Normally, Knockout ensures that component loading, and hence component injection, always completes asynchronously, because <em>sometimes it has no choice but to be asynchronous</em> (e.g., because it involves a request to the server). It does this even if a particular component instance could be injected synchronously (e.g., because the component definition was already loaded). This always-asynchronous policy is a matter of consistency, and is a well-established convention inherited from other modern asynchronous JavaScript technologies, such as AMD. The convention is a safe default — it mitigates potential bugs where a developer might not account for the possibility of a typically-asynchronous process sometimes completing synchronously or vice-versa.</p> <p><strong>Why would you ever enable synchronous loading?</strong></p> <p>If you want to change the policy for a particular component, you can specify <code>synchronous: true</code> on that component’s configuration. Then it might load asynchronously on first use, followed by synchronously on all subsequent uses. If you do this, then you need to account for this changeable behavior in any code that waits for components to load. However, if your component can always be loaded and initialized synchronously, then enabling this option will ensure consistently synchronous behavior. This might be important if you’re using a component within a <code>foreach</code> binding and want to use the <code>afterAdd</code> or <code>afterRender</code> options to do post-processing.</p> <p>Prior to Knockout 3.4.0, you might need to use synchronous loading to prevent multiple DOM reflows when including many components simultaneously (such as with the <code>foreach</code> binding). With Knockout 3.4.0, components use Knockout’s <a href=\"microtasks\">microtasks</a> to ensure asynchronicity, and so will generally perform as well as synchronous loading.</p> <h2 id=\"how-knockout-loads-components-via-amd\">How Knockout loads components via AMD</h2> <p>When you load a viewmodel or template via <code>require</code> declarations, e.g.,</p> <pre>ko.components.register('my-component', {\n    viewModel: { require: 'some/module/name' },\n    template: { require: 'text!some-template.html' }\n});\n</pre> <p>…all Knockout does is call <code>require(['some/module/name'], callback)</code> and <code>require(['text!some-template.html'], callback)</code>, and uses the asynchronously-returned objects as the viewmodel and template definitions. So,</p> <ul> <li>\n<strong>This does not take a strict dependency on <a href=\"http://requirejs.org/\">require.js</a></strong> or any other particular module loader. <em>Any</em> module loader that provides an AMD-style <code>require</code> API will do. If you want to integrate with a module loader whose API is different, you can implement a <a href=\"component-loaders\">custom component loader</a>.</li> <li>\n<strong>Knockout does not interpret the module name</strong> in any way - it merely passes it through to <code>require()</code>. So of course Knockout does not know or care about where your module files are loaded from. That’s up to your AMD loader and how you’ve configured it.</li> <li>\n<strong>Knockout doesn’t know or care whether your AMD modules are anonymous or not</strong>. Typically we find it’s most convenient for components to be defined as anonymous modules, but that concern is entirely separate from KO.</li> </ul> <h4 id=\"amd-modules-are-loaded-only-on-demand\">AMD modules are loaded only on demand</h4> <p>Knockout does not call <code>require([moduleName], ...)</code> until your component is being instantiated. This is how components get loaded on demand, not up front.</p> <p>For example, if your component is inside some other element with an <a href=\"if-binding\"><code>if</code> binding</a> (or another control flow binding), then it will not cause the AMD module to be loaded until the <code>if</code> condition is true. Of course, if the AMD module was already loaded (e.g., in a preloaded bundle) then the <code>require</code> call will not trigger any additional HTTP requests, so you can control what is preloaded and what is loaded on demand.</p> <h2 id=\"registering-components-as-a-single-amd-module\">Registering components as a single AMD module</h2> <p>For even better encapsulation, you can package a component into a single self-describing AMD module. Then you can reference a component as simply as:</p> <pre>ko.components.register('my-component', { require: 'some/module' });\n</pre> <p>Notice that no viewmodel/template pair is specified. The AMD module itself can provide a viewmodel/template pair, using any of the definition formats listed above. For example, the file <code>some/module.js</code> could be declared as:</p> <pre>// AMD module 'some/module.js' encapsulating the configuration for a component\ndefine(['knockout'], function(ko) {\n    function MyComponentViewModel(params) {\n        this.personName = ko.observable(params.name);\n    }\n\n    return {\n        viewModel: MyComponentViewModel,\n        template: 'The name is &lt;strong data-bind=\"text: personName\"&gt;&lt;/strong&gt;'\n    };\n});\n</pre> <h3 id=\"a-recommended-amd-module-pattern\">A recommended AMD module pattern</h3> <p>What tends to be most useful in practice is creating AMD modules that have inline viewmodel classes, and explicitly take AMD dependencies on external template files.</p> <p>For example, if the following is in a file at <code>path/my-component.js</code>,</p> <pre>// Recommended AMD module pattern for a Knockout component that:\n//  - Can be referenced with just a single 'require' declaration\n//  - Can be included in a bundle using the r.js optimizer\ndefine(['knockout', 'text!./my-component.html'], function(ko, htmlString) {\n    function MyComponentViewModel(params) {\n        // Set up properties, etc.\n    }\n\n    // Use prototype to declare any public methods\n    MyComponentViewModel.prototype.doSomething = function() { ... };\n\n    // Return component definition\n    return { viewModel: MyComponentViewModel, template: htmlString };\n});\n</pre> <p>… and the template markup is in the file <code>path/my-component.html</code>, then you have these benefits:</p> <ul> <li>Applications can reference this trivially, i.e., <code>ko.components.register('my-component', { require: 'path/my-component' });</code>\n</li> <li>You only need two files for the component - a viewmodel (<code>path/my-component.js</code>) and a template (<code>path/my-component.html</code>) - which is a very natural arrangement during development.</li> <li>Since the dependency on the template is explicitly stated in the <code>define</code> call, this automatically works with the <a href=\"http://requirejs.org/docs/optimization.html\"><code>r.js</code> optimizer</a> or similar bundling tools. The entire component - viewmodel plus template - can therefore trivially be included in a bundle file during a build step. <ul> <li>Note: Since the r.js optimizer is very flexible, it has a lot of options and can take some time to set up. You may want to start from a ready-made example of Knockout components being optimized through r.js, in which case see <a href=\"http://yeoman.io/\">Yeoman</a> and the <a href=\"https://www.npmjs.org/package/generator-ko\">generator-ko</a> generator. Blog post coming soon.</li> </ul> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/component-registration.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/component-registration.html</a>\n  </p>\n</div>\n","component-custom-elements":"<h1>Custom elements</h1> <p>Custom elements provide a convenient way of injecting <a href=\"component-overview\">components</a> into your views.</p> <ul id=\"markdown-toc\"> <li><a href=\"#introduction\">Introduction</a></li> <li><a href=\"#example\">Example</a></li> <li>\n<a href=\"#passing-parameters\">Passing parameters</a> <ul> <li><a href=\"#communication-between-parent-and-child-components\">Communication between parent and child components</a></li> <li><a href=\"#passing-observable-expressions\">Passing observable expressions</a></li> </ul> </li> <li><a href=\"#passing-markup-into-components\">Passing markup into components</a></li> <li><a href=\"#controlling-custom-element-tag-names\">Controlling custom element tag names</a></li> <li><a href=\"#registering-custom-elements\">Registering custom elements</a></li> <li><a href=\"#note-combining-custom-elements-with-regular-bindings\">Note: Combining custom elements with regular bindings</a></li> <li><a href=\"#note-custom-elements-cannot-be-self-closing\">Note: Custom elements cannot be self-closing</a></li> <li><a href=\"#note-custom-elements-and-internet-explorer-6-to-8\">Note: Custom elements and Internet Explorer 6 to 8</a></li> <li><a href=\"#advanced-accessing-raw-parameters\">Advanced: Accessing <code>$raw</code> parameters</a></li> </ul> <h3 id=\"introduction\">Introduction</h3> <p>Custom elements are a syntactical alternative to the <a href=\"component-binding\"><code>component</code> binding</a> (and in fact, custom elements make use of a component binding behind the scenes).</p> <p>For example, instead of writing this:</p> <pre>&lt;div data-bind='component: { name: \"flight-deals\", params: { from: \"lhr\", to: \"sfo\" } }'&gt;&lt;/div&gt;\n</pre> <p>… you can write:</p> <pre>&lt;flight-deals params='from: \"lhr\", to: \"sfo\"'&gt;&lt;/flight-deals&gt;\n</pre> <p>This allows for a very modern, <a href=\"http://www.w3.org/TR/components-intro/\">WebComponents</a>-like way to organize your code, while retaining support for even very old browsers (see <a href=\"#note-custom-elements-and-internet-explorer-6-to-8\">custom elements and IE 6 to 8</a>).</p> <h3 id=\"example\">Example</h3> <p>This example declares a component, and then injects two instances of it into a view. See the source code below.</p>  <div class=\"liveExample\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n    &lt;h4&gt;First instance, without parameters&lt;/h4&gt;\n    &lt;message-editor&gt;&lt;/message-editor&gt;\n\n    &lt;h4&gt;Second instance, passing parameters&lt;/h4&gt;\n    &lt;message-editor params='initialText: \"Hello, world!\"'&gt;&lt;/message-editor&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\n    ko.components.register('message-editor', {\n        viewModel: function(params) {\n            this.text = ko.observable(params.initialText || '');\n        },\n        template: 'Message: &lt;input data-bind=\"value: text\" /&gt; '\n                + '(length: &lt;span data-bind=\"text: text().length\"&gt;&lt;/span&gt;)'\n    });\n\n    ko.applyBindings();\n</pre> <p>Note: In more realistic cases, you would typically load component viewmodels and templates from external files, instead of hardcoding them into the registration. See <a href=\"component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand\">an example</a> and <a href=\"component-registration\">registration documentation</a>.</p> <h3 id=\"passing-parameters\">Passing parameters</h3> <p>As you have seen in the examples above, you can use a <code>params</code> attribute to supply parameters to the component viewmodel. The contents of the <code>params</code> attribute are interpreted like a JavaScript object literal (just like a <code>data-bind</code> attribute), so you can pass arbitrary values of any type. Example:</p> <pre>&lt;unrealistic-component\n    params='stringValue: \"hello\",\n            numericValue: 123,\n            boolValue: true,\n            objectValue: { a: 1, b: 2 },\n            dateValue: new Date(),\n            someModelProperty: myModelValue,\n            observableSubproperty: someObservable().subprop'&gt;\n&lt;/unrealistic-component&gt;\n</pre> <h4 id=\"communication-between-parent-and-child-components\">Communication between parent and child components</h4> <p>If you refer to model properties in a <code>params</code> attribute, then you are of course referring to the properties on the viewmodel outside the component (the ‘parent’ or ‘host’ viewmodel), since the component itself is not instantiated yet. In the above example, <code>myModelValue</code> would be a property on the parent viewmodel, and would be received by the child component viewmodel’s constructor as <code>params.someModelProperty</code>.</p> <p>This is how you can pass properties from a parent viewmodel to a child component. If the properties themselves are observable, then the parent viewmodel will be able to observe and react to any new values inserted into them by the child component.</p> <h4 id=\"passing-observable-expressions\">Passing observable expressions</h4> <p>In the following example,</p> <pre>&lt;some-component\n    params='simpleExpression: 1 + 1,\n            simpleObservable: myObservable,\n            observableExpression: myObservable() + 1'&gt;\n&lt;/some-component&gt;\n</pre> <p>… the component viewmodel’s <code>params</code> parameter will contain three values:</p> <ul> <li>\n<code>simpleExpression</code> <ul> <li> <p>This will be the numeric value <code>2</code>. It will not be an observable or computed value, since there are no observables involved.</p> <p>In general, if a parameter’s evaluation does not involve evaluating an observable (in this case, the value did not involve observables at all), then the value is passed literally. If the value was an object, then the child component could mutate it, but since it’s not observable the parent would not know the child had done so.</p> </li> </ul> </li> <li>\n<code>simpleObservable</code> <ul> <li> <p>This will be the <a href=\"observables\"><code>ko.observable</code></a> instance declared on the parent viewmodel as <code>myObservable</code>. It is not a wrapper — it’s the actual same instance as referenced by the parent. So if the child viewmodel writes to this observable, the parent viewmodel will receive that change.</p> <p>In general, if a parameter’s evaluation does not involve evaluating an observable (in this case, the observable was simply passed without evaluating it), then the value is passed literally.</p> </li> </ul> </li> <li>\n<code>observableExpression</code> <ul> <li> <p>This one is trickier. The expression itself, when evaluated, reads an observable. That observable’s value could change over time, so the expression result could change over time.</p> <p>To ensure that the child component can react to changes in the expression value, Knockout <strong>automatically upgrades this parameter to a computed property</strong>. So, the child component will be able to read <code>params.observableExpression()</code> to get the current value, or use <code>params.observableExpression.subscribe(...)</code>, etc.</p> <p>In general, with custom elements, if a parameter’s evaluation involves evaluating an observable, then Knockout automatically constructs a <code>ko.computed</code> value to give the expression’s result, and supplies that to the component.</p> </li> </ul> </li> </ul> <p>In summary, the general rule is:</p> <ol> <li>If a parameter’s evaluation <strong>does not</strong> involve evaluating an observable/computed, it is passed literally.</li> <li>If a parameter’s evaluation <strong>does</strong> involve evaluating one or more observables/computeds, it is passed as a computed property so that you can react to changes in the parameter value.</li> </ol> <h3 id=\"passing-markup-into-components\">Passing markup into components</h3> <p>Sometimes you may want to create a component that receives markup and uses it as part of its output. For example, you may want to build a “container” UI element such as a grid, list, dialog, or tab set that can receive and bind arbitrary markup inside itself.</p> <p>Consider a special list component that can be invoked as follows:</p> <pre>&lt;my-special-list params=\"items: someArrayOfPeople\"&gt;\n    &lt;!-- Look, I'm putting markup inside a custom element --&gt;\n    The person &lt;em data-bind=\"text: name\"&gt;&lt;/em&gt;\n    is &lt;em data-bind=\"text: age\"&gt;&lt;/em&gt; years old.\n&lt;/my-special-list&gt;\n</pre> <p>By default, the DOM nodes inside <code>&lt;my-special-list&gt;</code> will be stripped out (without being bound to any viewmodel) and replaced by the component’s output. However, those DOM nodes aren’t lost: they are remembered, and are supplied to the component in two ways:</p> <ul> <li>As an array, <code>$componentTemplateNodes</code>, available to any binding expression in the component’s template (i.e., as a <a href=\"binding-context\">binding context</a> property). Usually this is the most convenient way to use the supplied markup. See the example below.</li> <li>As an array, <code>componentInfo.templateNodes</code>, passed to its <a href=\"component-registration#a-createviewmodel-factory-function\"><code>createViewModel</code> function</a>\n</li> </ul> <p>The component can then choose to use the supplied DOM nodes as part of its output however it wishes, such as by using <code>template: { nodes: $componentTemplateNodes }</code> on any element in the component’s template.</p> <p>For example, the <code>my-special-list</code> component’s template can reference <code>$componentTemplateNodes</code> so that its output includes the supplied markup. Here’s the complete working example:</p> <div class=\"liveExample\" id=\"component-pass-markup\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n    &lt;!-- This could be in a separate file --&gt;\n    &lt;template id=\"my-special-list-template\"&gt;\n        &lt;h3&gt;Here is a special list&lt;/h3&gt;\n\n        &lt;ul data-bind=\"foreach: { data: myItems, as: 'myItem' }\"&gt;\n            &lt;li&gt;\n                &lt;h4&gt;Here is another one of my special items&lt;/h4&gt;\n                &lt;!-- ko template: { nodes: $componentTemplateNodes, data: myItem } --&gt;&lt;!-- /ko --&gt;\n            &lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/template&gt;\n\n    &lt;my-special-list params=\"items: someArrayOfPeople\"&gt;\n        &lt;!-- Look, I'm putting markup inside a custom element --&gt;\n        The person &lt;em data-bind=\"text: name\"&gt;&lt;/em&gt;\n        is &lt;em data-bind=\"text: age\"&gt;&lt;/em&gt; years old.\n    &lt;/my-special-list&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\n    ko.components.register('my-special-list', {\n        template: { element: 'my-special-list-template' },\n        viewModel: function(params) {\n            this.myItems = params.items;\n        }\n    });\n\n    ko.applyBindings({\n        someArrayOfPeople: ko.observableArray([\n            { name: 'Lewis', age: 56 },\n            { name: 'Hathaway', age: 34 }\n        ])\n    });\n</pre> <p>This “special list” example does nothing more than insert a heading above each list item. But the same technique can be used to create sophisticated grids, dialogs, tab sets, and so on, since all that is needed for such UI elements is common UI markup (e.g., to define the grid or dialog’s heading and borders) wrapped around arbitrary supplied markup.</p> <p>This technique is also possible when using components <em>without</em> custom elements, i.e., <a href=\"component-binding#note-passing-markup-to-components\">passing markup when using the <code>component</code> binding directly</a>.</p> <h3 id=\"controlling-custom-element-tag-names\">Controlling custom element tag names</h3> <p>By default, Knockout assumes that your custom element tag names correspond exactly to the names of components registered using <code>ko.components.register</code>. This convention-over-configuration strategy is ideal for most applications.</p> <p>If you want to have different custom element tag names, you can override <code>getComponentNameForNode</code> to control this. For example,</p> <pre>ko.components.getComponentNameForNode = function(node) {\n    var tagNameLower = node.tagName &amp;&amp; node.tagName.toLowerCase();\n\n    if (ko.components.isRegistered(tagNameLower)) {\n        // If the element's name exactly matches a preregistered\n        // component, use that component\n        return tagNameLower;\n    } else if (tagNameLower === \"special-element\") {\n        // For the element &lt;special-element&gt;, use the component\n        // \"MySpecialComponent\" (whether or not it was preregistered)\n        return \"MySpecialComponent\";\n    } else {\n        // Treat anything else as not representing a component\n        return null;\n    }\n}\n</pre> <p>You can use this technique if, for example, you want to control which subset of registered components may be used as custom elements.</p> <h3 id=\"registering-custom-elements\">Registering custom elements</h3> <p>If you are using the default component loader, and hence are registering your components using <code>ko.components.register</code>, then there is nothing extra you need to do. Components registered this way are immediately available for use as custom elements.</p> <p>If you have implemented a <a href=\"component-loaders\">custom component loader</a>, and are not using <code>ko.components.register</code>, then you need to tell Knockout about any element names you wish to use as custom elements. To do this, simply call <code>ko.components.register</code> - you don’t need to specify any configuration, since your custom component loader won’t be using the configuration anyway. For example,</p> <pre>ko.components.register('my-custom-element', { /* No config needed */ });\n</pre> <p>Alternatively, you can <a href=\"#controlling-custom-element-tag-names\">override <code>getComponentNameForNode</code></a> to control dynamically which elements map to which component names, independently of preregistration.</p> <h3 id=\"note-combining-custom-elements-with-regular-bindings\">Note: Combining custom elements with regular bindings</h3> <p>A custom element can have a regular <code>data-bind</code> attribute (in addition to any <code>params</code> attribute) if needed. For example,</p> <pre>&lt;products-list params='category: chosenCategory'\n               data-bind='visible: shouldShowProducts'&gt;\n&lt;/products-list&gt;\n</pre> <p>However, it does not make sense to use bindings that would modify the element’s contents, such as the <a href=\"text-binding\"><code>text</code></a> or <a href=\"template-binding\"><code>template</code></a> bindings, since they would overwrite the template injected by your component.</p> <p>Knockout will prevent the use of any bindings that use <a href=\"custom-bindings-controlling-descendant-bindings\"><code>controlsDescendantBindings</code></a>, because this also would clash with the component when trying to bind its viewmodel to the injected template. Therefore if you want to use a control flow binding such as <code>if</code> or <code>foreach</code>, then you must wrap it around your custom element rather than using it directly on the custom element, e.g.,:</p> <pre>&lt;!-- ko if: someCondition --&gt;\n    &lt;products-list&gt;&lt;/products-list&gt;\n&lt;!-- /ko --&gt;\n</pre> <p>or:</p> <pre>&lt;ul data-bind='foreach: allProducts'&gt;\n    &lt;product-details params='product: $data'&gt;&lt;/product-details&gt;\n&lt;/ul&gt;\n</pre> <h3 id=\"note-custom-elements-cannot-be-self-closing\">Note: Custom elements cannot be self-closing</h3> <p>You must write <code>&lt;my-custom-element&gt;&lt;/my-custom-element&gt;</code>, and <strong>not</strong> <code>&lt;my-custom-element /&gt;</code>. Otherwise, your custom element is not closed and subsequent elements will be parsed as child elements.</p> <p>This is a limitation of the HTML specification and is outside the scope of what Knockout can control. HTML parsers, following the HTML specification, <a href=\"http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag\">ignore any self-closing slashes</a> (except on a small number of special “foreign elements”, which are hardcoded into the parser). HTML is not the same as XML.</p> <h3 id=\"note-custom-elements-and-internet-explorer-6-to-8\">Note: Custom elements and Internet Explorer 6 to 8</h3> <p>Knockout tries hard to spare developers the pain of dealing with cross-browser compatiblity issues, especially those relating to older browsers! Even though custom elements provide a very modern style of web development, they still work on all commonly-encountered browsers:</p> <ul> <li>HTML5-era browsers, which includes <strong>Internet Explorer 9</strong> and later, automatically allow for custom elements with no difficulties.</li> <li>\n<strong>Internet Explorer 6 to 8</strong> also supports custom elements, <em>but only if they are registered before the HTML parser encounters any of those elements</em>.</li> </ul> <p>IE 6-8’s HTML parser will discard any unrecognized elements. To ensure it doesn’t throw out your custom elements, you must do one of the following:</p> <ul> <li>Ensure you call <code>ko.components.register('your-component')</code> <em>before</em> the HTML parser sees any <code>&lt;your-component&gt;</code> elements</li> <li>Or, at least call <code>document.createElement('your-component')</code> <em>before</em> the HTML parser sees any <code>&lt;your-component&gt;</code> elements. You can ignore the result of the <code>createElement</code> call — all that matters is that you have called it.</li> </ul> <p>For example, if you structure your page like this, then everything will be OK:</p> <pre>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;script src='some-script-that-registers-components.js'&gt;&lt;/script&gt;\n\n        &lt;my-custom-element&gt;&lt;/my-custom-element&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</pre> <p>If you’re working with AMD, then you might prefer a structure like this:</p> <pre>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;script&gt;\n            // Since the components aren't registered until the AMD module\n            // loads, which is asynchronous, the following prevents IE6-8's\n            // parser from discarding the custom element\n            document.createElement('my-custom-element');\n        &lt;/script&gt;\n\n        &lt;script src='require.js' data-main='app/startup'&gt;&lt;/script&gt;\n\n        &lt;my-custom-element&gt;&lt;/my-custom-element&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</pre> <p>Or if you really don’t like the hackiness of the <code>document.createElement</code> call, then you could use a <a href=\"component-binding\"><code>component</code> binding</a> for your top-level component instead of a custom element. As long as all other components are registered before your <code>ko.applyBindings</code> call, they can be used as custom elements on IE6-8 without futher trouble:</p> <pre>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;!-- The startup module registers all other KO components before calling\n             ko.applyBindings(), so they are OK as custom elements on IE6-8 --&gt;\n        &lt;script src='require.js' data-main='app/startup'&gt;&lt;/script&gt;\n\n        &lt;div data-bind='component: \"my-custom-element\"'&gt;&lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</pre> <h3 id=\"advanced-accessing-raw-parameters\">Advanced: Accessing <code>$raw</code> parameters</h3> <p>Consider the following unusual case, in which <code>useObservable1</code>, <code>observable1</code>, and <code>observable2</code> are all observables:</p> <pre>&lt;some-component\n    params='myExpr: useObservable1() ? observable1 : observable2'&gt;\n&lt;/some-component&gt;\n</pre> <p>Since evaluating <code>myExpr</code> involves reading an observable (<code>useObservable1</code>), KO will supply the parameter to the component as a computed property.</p> <p>However, the value of the computed property is itself an observable. This would seem to lead to an awkward scenario, where reading its current value would involve double-unwrapping (i.e., <code>params.myExpr()()</code>, where the first parentheses give the value of the expression, and the second give the value of the resulting observable instance).</p> <p>This double-unwrapping would be ugly, inconvenient, and unexpected, so Knockout automatically sets up the generated computed property (<code>params.myExpr</code>) to unwrap its value for you. That is, the component can read <code>params.myExpr()</code> to get the value of whichever observable has been selected (<code>observable1</code> or <code>observable2</code>), without the need for double-unwrapping.</p> <p>In the unlikely event that you <em>don’t</em> want the automatic unwrapping, because you want to access the <code>observable1</code>/<code>observable2</code> instances directly, you can read values from <code>params.$raw</code>. For example,</p> <pre>function MyComponentViewModel(params) {\n    var currentObservableInstance = params.$raw.myExpr();\n    \n    // Now currentObservableInstance is either observable1 or observable2\n    // and you would read its value with \"currentObservableInstance()\"\n}\n</pre> <p>This should be a very unusual scenario, so normally you will not need to work with <code>$raw</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/component-custom-elements.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/component-custom-elements.html</a>\n  </p>\n</div>\n","json-data":"<h1>Loading and Saving JSON data</h1> <p>Knockout allows you to implement sophisticated client-side interactivity, but almost all web applications also need to exchange data with the server, or at least to serialize the data for local storage. The most convenient way to exchange or store data is in <a href=\"http://json.org/\">JSON format</a> - the format that the majority of Ajax applications use today.</p> <h3 id=\"loading-or-saving-data\">Loading or Saving Data</h3> <p>Knockout doesn’t force you to use any one particular technique to load or save data. You can use whatever mechanism is a convenient fit for your chosen server-side technology. The most commonly-used mechanism is jQuery’s Ajax helper methods, such as <a href=\"http://api.jquery.com/jQuery.getJSON/\"><code>getJSON</code></a>, <a href=\"http://api.jquery.com/jQuery.post/\"><code>post</code></a>, and <a href=\"http://api.jquery.com/jQuery.ajax/\"><code>ajax</code></a>. You can fetch data from the server:</p> <pre>$.getJSON(\"/some/url\", function(data) { \n\t// Now use this data to update your view models, \n\t// and Knockout will update your UI automatically \n})\n</pre> <p>… or you can send data to the server:</p> <pre>var data = /* Your data in JSON format - see below */;\n$.post(\"/some/url\", data, function(returnedData) {\n\t// This callback is executed if the post was successful\t\t\n})\n</pre> <p>Or, if you don’t want to use jQuery, you can use any other mechanism for loading or saving JSON data. So, all Knockout needs to help you do is:</p> <ul> <li>For saving, get your view model data into a simple JSON format so you can send it using one of the above techniques</li> <li>For loading, update your view model using data that you’ve received using one of the above techniques</li> </ul> <h3 id=\"converting-view-model-data-to-plain-json\">Converting View Model Data to Plain JSON</h3> <p>Your view models <em>are</em> JavaScript objects, so in a sense, you could just serialize them as JSON using any standard JSON serializer, such as <a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify\">JSON.stringify</a> (a native function in modern browsers), or the <a href=\"https://github.com/douglascrockford/JSON-js/blob/master/json2.js\"><code>json2.js</code></a> library. However, your view models probably contain observables, computed observables, and observable arrays, which are implemented as JavaScript functions and therefore won’t always serialize cleanly without additional work on your behalf.</p> <p>To make it easy to serialize view model data, including observables and the like, Knockout includes two helper functions:</p> <ul> <li>\n<code>ko.toJS</code> — this clones your view model’s object graph, substituting for each observable the current value of that observable, so you get a plain copy that contains only your data and no Knockout-related artifacts</li> <li>\n<code>ko.toJSON</code> — this produces a JSON string representing your view model’s data. Internally, it simply calls <code>ko.toJS</code> on your view model, and then uses the browser’s native JSON serializer on the result. Note: for this to work on older browsers that have no native JSON serializer (e.g., IE 7 or earlier), you must also reference the <a href=\"https://github.com/douglascrockford/JSON-js/blob/master/json2.js\"><code>json2.js</code></a> library.</li> </ul> <p>For example, define a view model as follows:</p> <pre>var viewModel = {\n    firstName : ko.observable(\"Bert\"),\n    lastName : ko.observable(\"Smith\"),\n    pets : ko.observableArray([\"Cat\", \"Dog\", \"Fish\"]),\n    type : \"Customer\"\n};\nviewModel.hasALotOfPets = ko.computed(function() {\n    return this.pets().length &gt; 2\n}, viewModel)\n</pre> <p>This contains a mix of observables, computed observables, observable arrays, and plain values. You can convert it to a JSON string suitable for sending to the server using <code>ko.toJSON</code> as follows:</p> <pre>var jsonData = ko.toJSON(viewModel);\n\n// Result: jsonData is now a string equal to the following value\n// '{\"firstName\":\"Bert\",\"lastName\":\"Smith\",\"pets\":[\"Cat\",\"Dog\",\"Fish\"],\"type\":\"Customer\",\"hasALotOfPets\":true}'\n</pre> <p>Or, if you just want the plain JavaScript object graph <em>before</em> serialization, use <code>ko.toJS</code> as follows:</p> <pre>var plainJs = ko.toJS(viewModel);\n\n// Result: plainJS is now a plain JavaScript object in which nothing is observable. It's just data.\n// The object is equivalent to the following:\n//   {\n//      firstName: \"Bert\",\n//      lastName: \"Smith\",\n//      pets: [\"Cat\",\"Dog\",\"Fish\"],\n//      type: \"Customer\",\n//      hasALotOfPets: true\n//   }\n</pre> <p>Note that <code>ko.toJSON</code> accepts the same arguments as <a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify\">JSON.stringify</a>. For example, it can be useful to have a “live” representation of your view model data when debugging a Knockout application. To generate a nicely formatted display for this purpose, you can pass the <em>spaces</em> argument into <code>ko.toJSON</code> and bind against your view model like:</p> <pre>&lt;pre data-bind=\"text: ko.toJSON($root, null, 2)\"&gt;&lt;/pre&gt;\n</pre> <h3 id=\"updating-view-model-data-using-json\">Updating View Model Data using JSON</h3> <p>If you’ve loaded some data from the server and want to use it to update your view model, the most straightforward way is to do it yourself. For example,</p> <pre>// Load and parse the JSON\nvar someJSON = /* Omitted: fetch it from the server however you want */;\nvar parsed = JSON.parse(someJSON);\n\n// Update view model properties\nviewModel.firstName(parsed.firstName);\nviewModel.pets(parsed.pets);\n</pre> <p>In many scenarios, this direct approach is the simplest and most flexible solution. Of course, as you update the properties on your view model, Knockout will take care of updating the visible UI to match it.</p> <p>However, many developers prefer to use a more conventions-based approach to updating their view models using incoming data without manually writing a line of code for every property to be updated. This can be beneficial if your view models have many properties, or deeply nested data structures, because it can greatly reduce the amount of manual mapping code you need to write. For more details about this technique, see <a href=\"plugins-mapping\">the knockout.mapping plugin</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/json-data.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/json-data.html</a>\n  </p>\n</div>\n","extenders":"<h1>Using extenders to augment observables</h1> <p>Knockout observables provide the basic features necessary to support reading/writing values and notifying subscribers when that value changes. In some cases, though, you may wish to add additional functionality to an observable. This might include adding additional properties to the observable or intercepting writes by placing a writable computed observable in front of the observable. Knockout extenders provide an easy and flexible way to do this type of augmentation to an observable.</p> <h3 id=\"how-to-create-an-extender\">How to create an extender</h3> <p>Creating an extender involves adding a function to the <code>ko.extenders</code> object. The function takes in the observable itself as the first argument and any options in the second argument. It can then either return the observable or return something new like a computed observable that uses the original observable in some way.</p> <p>This simple <code>logChange</code> extender subscribes to the observable and uses the console to write any changes along with a configurable message.</p> <pre>ko.extenders.logChange = function(target, option) {\n    target.subscribe(function(newValue) {\n       console.log(option + \": \" + newValue);\n    });\n    return target;\n};\n</pre> <p>You would use this extender by calling the <code>extend</code> function of an observable and passing an object that contains a <code>logChange</code> property.</p> <pre>this.firstName = ko.observable(\"Bob\").extend({logChange: \"first name\"});\n</pre> <p>If the <code>firstName</code> observable’s value was changed to <code>Ted</code>, then the console would show <code>first name: Ted</code>.</p> <h3 id=\"live-example-1-forcing-input-to-be-numeric\">Live Example 1: Forcing input to be numeric</h3> <p>This example creates an extender that forces writes to an observable to be numeric rounded to a configurable level of precision. In this case, the extender will return a new writable computed observable that will sit in front of the real observable intercepting writes.</p>  <div class=\"liveExample\" id=\"numericFields\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n&lt;p&gt;&lt;input data-bind=\"value: myNumberOne\" /&gt; (round to whole number)&lt;/p&gt;\n&lt;p&gt;&lt;input data-bind=\"value: myNumberTwo\" /&gt; (round to two decimals)&lt;/p&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\nko.extenders.numeric = function(target, precision) {\n    //create a writable computed observable to intercept writes to our observable\n    var result = ko.pureComputed({\n        read: target,  //always return the original observables value\n        write: function(newValue) {\n            var current = target(),\n                roundingMultiplier = Math.pow(10, precision),\n                newValueAsNum = isNaN(newValue) ? 0 : parseFloat(+newValue),\n                valueToWrite = Math.round(newValueAsNum * roundingMultiplier) / roundingMultiplier;\n\n            //only write if it changed\n            if (valueToWrite !== current) {\n                target(valueToWrite);\n            } else {\n                //if the rounded value is the same, but a different value was written, force a notification for the current field\n                if (newValue !== current) {\n                    target.notifySubscribers(valueToWrite);\n                }\n            }\n        }\n    }).extend({ notify: 'always' });\n\n    //initialize with current value to make sure it is rounded appropriately\n    result(target());\n\n    //return the new computed observable\n    return result;\n};\n\nfunction AppViewModel(one, two) {\n    this.myNumberOne = ko.observable(one).extend({ numeric: 0 });\n    this.myNumberTwo = ko.observable(two).extend({ numeric: 2 });\n}\n\nko.applyBindings(new AppViewModel(221.2234, 123.4525));\n</pre> <p>Note that for this to automatically erase rejected values from the UI, it’s necessary to use <code>.extend({ notify: 'always' })</code> on the computed observable. Without this, it’s possible for the user to enter an invalid <code>newValue</code> that when rounded gives an unchanged <code>valueToWrite</code>. Then, since the model value would not be changing, there would be no notification to update the textbox in the UI. Using <code>{ notify: 'always' }</code> causes the textbox to refresh (erasing rejected values) even if the computed property has not changed value.</p> <h3 id=\"live-example-2-adding-validation-to-an-observable\">Live Example 2: Adding validation to an observable</h3> <p>This example creates an extender that allows an observable to be marked as required. Instead of returning a new object, this extender simply adds additional sub-observables to the existing observable. Since observables are functions, they can actually have their own properties. However, when the view model is converted to JSON, the sub-observables will be dropped and we will simply be left with the value of our actual observable. This is a nice way to add additional functionality that is only relevant for the UI and does not need to be sent back to the server.</p> <div class=\"liveExample\" id=\"requiredFields\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n&lt;p data-bind=\"css: { error: firstName.hasError }\"&gt;\n    &lt;input data-bind='value: firstName, valueUpdate: \"afterkeydown\"' /&gt;\n    &lt;span data-bind='visible: firstName.hasError, text: firstName.validationMessage'&gt; &lt;/span&gt;\n&lt;/p&gt;\n&lt;p data-bind=\"css: { error: lastName.hasError }\"&gt;\n    &lt;input data-bind='value: lastName, valueUpdate: \"afterkeydown\"' /&gt;\n    &lt;span data-bind='visible: lastName.hasError, text: lastName.validationMessage'&gt; &lt;/span&gt;\n&lt;/p&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\nko.extenders.required = function(target, overrideMessage) {\n    //add some sub-observables to our observable\n    target.hasError = ko.observable();\n    target.validationMessage = ko.observable();\n\n    //define a function to do validation\n    function validate(newValue) {\n       target.hasError(newValue ? false : true);\n       target.validationMessage(newValue ? \"\" : overrideMessage || \"This field is required\");\n    }\n\n    //initial validation\n    validate(target());\n\n    //validate whenever the value changes\n    target.subscribe(validate);\n\n    //return the original observable\n    return target;\n};\n\nfunction AppViewModel(first, last) {\n    this.firstName = ko.observable(first).extend({ required: \"Please enter a first name\" });\n    this.lastName = ko.observable(last).extend({ required: \"\" });\n}\n\nko.applyBindings(new AppViewModel(\"Bob\",\"Smith\"));\n</pre> <h3 id=\"applying-multiple-extenders\">Applying multiple extenders</h3> <p>More than one extender can be applied in a single call to the <code>.extend</code> method of an observable.</p> <pre>this.firstName = ko.observable(first).extend({ required: \"Please enter a first name\", logChange: \"first name\" });\n</pre> <p>In this case, both the <code>required</code> and <code>logChange</code> extenders would be executed against our observable.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/extenders.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/extenders.html</a>\n  </p>\n</div>\n","deferred-updates":"<h1>Deferred updates</h1> <p><em>Note: This documentation applies to Knockout 3.4.0 and later. For previous versions, the <a href=\"https://github.com/mbest/knockout-deferred-updates\">Deferred Updates</a> plugin provides similar support.</em></p> <p>In complex applications, with multiple, intertwined dependencies, updating a single <a href=\"observables\">observable</a> might trigger a cascade of <a href=\"computedobservables\">computed observables</a>, manual subscriptions, and UI binding updates. These updates can be expensive and inefficient if unnecessary intermediate values are pushed to the view or result in extra computed observable evaluations. Even in a simple application, updating related observables or a single observable multiple times (such as filling an <a href=\"observablearrays\">observable array</a>) can have a similar effect.</p> <p>Using deferred updates ensures that computed observables and bindings are updated only after their dependencies are stable. Even if an observable might go through multiple intermediate values, only the latest value is used to update its dependencies. To facilitate this, all notifications become asynchronous, scheduled using the <a href=\"microtasks\">Knockout microtask queue</a>. This may sound very similar to <a href=\"ratelimit-observable\">rate-limiting</a>, which also helps prevent extra notifications, but deferred updates can provide these benefits across an entire application without adding delays. Here’s how notification scheduling differs between the standard, deferred, and rate-limited modes:</p> <ul> <li>\n<em>Standard</em> – Notifications happen immediately and synchronously. Dependencies are often notified of intermediate values.</li> <li>\n<em>Deferred</em> – Notifications happen asynchronously, immediately after the current task and generally before any UI redraws.</li> <li>\n<em>Rate-limited</em> – Notifications happen after the specified period of time (a minimum of 2-10 ms depending on the browser).</li> </ul> <h2 id=\"enabling-deferred-updates\">Enabling deferred updates</h2> <p>Deferred updates are turned off by default to provide compatibility with existing applications. To use deferred updates for your application, you must enable it before initializing your viewmodels by setting the following option:</p> <pre>ko.options.deferUpdates = true;\n</pre> <p>When the <code>deferUpdates</code> option is on, all observables, computed observables, and bindings will be set to use deferred updates and notifications. Enabling this feature at the start of creating a Knockout-based application means you do not need to worry about working around the intermediate-value problem, and so can facilitate a cleaner, purely reactive design. But you should take care when enabling deferred updates for an existing application because it will break code that depends on synchronous updates or on notification of intermediate values (although you may be able to <a href=\"#forcing-deferred-notifications-to-happen-early\">work around these issues</a>).</p> <h3 id=\"example-avoiding-multiple-ui-updates\">Example: Avoiding multiple UI updates</h3> <p>The following is a contrived example to demonstrate the ability of deferred updates to eliminate UI updates of intermediate values and how this can improve performance.</p>  <div class=\"liveExample\" id=\"deferred-example1\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n&lt;!--ko foreach: $root--&gt;\n&lt;div class=\"example\"&gt;\n    &lt;table&gt;\n        &lt;tbody data-bind='foreach: data'&gt;\n            &lt;tr&gt;\n                &lt;td data-bind=\"text: name\"&gt;&lt;/td&gt;\n                &lt;td data-bind=\"text: position\"&gt;&lt;/td&gt;\n                &lt;td data-bind=\"text: location\"&gt;&lt;/td&gt;\n            &lt;/tr&gt;\n        &lt;/tbody&gt;\n    &lt;/table&gt;\n    &lt;button data-bind=\"click: flipData, text: 'Flip ' + type\"&gt;&lt;/button&gt;\n    &lt;div class=\"time\" data-bind=\"text: (data(), timing() + ' ms')\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;!--/ko--&gt;\n\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\nfunction AppViewModel(type) {\n    this.type = type;\n    this.data = ko.observableArray([\n        { name: 'Alfred', position: 'Butler', location: 'London' },\n        { name: 'Bruce', position: 'Chairman', location: 'New York' }\n    ]);\n    this.flipData = function () {\n        this.starttime = new Date().getTime();\n        var data = this.data();\n        for (var i = 0; i &lt; 999; i++) {\n            this.data([]);\n            this.data(data.reverse());\n        }\n    }\n    this.timing = function () {\n        return this.starttime ? new Date().getTime() - this.starttime : 0;\n    };\n}\n\nko.options.deferUpdates = true;\nvar vmDeferred = new AppViewModel('deferred');\n\nko.options.deferUpdates = false;\nvar vmStandard = new AppViewModel('standard');\n\nko.applyBindings([vmStandard, vmDeferred]);\n</pre> <h2 id=\"using-deferred-updates-for-specific-observables\">Using deferred updates for specific observables</h2> <p>Even if you don’t enable deferred updates for your whole application, you can still benefit from this feature by specifically making certain observables deferred. This is done using the <code>deferred</code> extender:</p> <pre>this.data = ko.observableArray().extend({ deferred: true });\n</pre> <p>Now we can <code>push</code> a bunch of items into the <code>data</code> array without worrying about causing excessive UI or computed updates. The <code>deferred</code> extender can be applied to any type of observable, including observable arrays and computed observables.</p> <h3 id=\"example-avoiding-multiple-ajax-requests\">Example: Avoiding multiple Ajax requests</h3> <p>The following model represents data that you could render as a paged grid:</p> <pre>function GridViewModel() {\n    this.pageSize = ko.observable(20);\n    this.pageIndex = ko.observable(1);\n    this.currentPageData = ko.observableArray();\n\n    // Query /Some/Json/Service whenever pageIndex or pageSize changes,\n    // and use the results to update currentPageData\n    ko.computed(function() {\n        var params = { page: this.pageIndex(), size: this.pageSize() };\n        $.getJSON('/Some/Json/Service', params, this.currentPageData);\n    }, this);\n}\n</pre> <p>Because the computed observable evaluates both <code>pageIndex</code> and <code>pageSize</code>, it becomes dependent on both of them. So, this code will use jQuery’s <a href=\"http://api.jquery.com/jQuery.getJSON/\"><code>$.getJSON</code> function</a> to reload <code>currentPageData</code> when a <code>GridViewModel</code> is first instantiated <em>and</em> whenever the <code>pageIndex</code> or <code>pageSize</code> properties are later changed.</p> <p>This is very simple and elegant (and it’s trivial to add yet more observable query parameters that also trigger a refresh automatically whenever they change), but there is a potential efficiency problem. Suppose you add the following function to <code>GridViewModel</code> that changes both <code>pageIndex</code> and <code>pageSize</code>:</p> <pre>this.setPageSize = function(newPageSize) {\n    // Whenever you change the page size, we always reset the page index to 1\n    this.pageSize(newPageSize);\n    this.pageIndex(1);\n}\n</pre> <p>The problem is that this will cause <em>two</em> Ajax requests: the first one will start when you update <code>pageSize</code>, and the second one will start immediately afterwards when you update <code>pageIndex</code>. This is a waste of bandwidth and server resources, and a source of unpredictable race conditions.</p> <p>When applied to a computed observable, the <code>deferred</code> extender will also avoid excess evaluation of the computed function. Using deferred updates ensures that any sequence of changes to dependencies in the current task will trigger just <em>one</em> re-evaluation of the computed observable. For example:</p> <pre>ko.computed(function() {\n    // This evaluation logic is exactly the same as before\n    var params = { page: this.pageIndex(), size: this.pageSize() };\n    $.getJSON('/Some/Json/Service', params, this.currentPageData);\n}, this).extend({ deferred: true });\n</pre> <p>Now you can change <code>pageIndex</code> and <code>pageSize</code> as many times as you like, and the Ajax call will only happen once after you release your thread back to the JavaScript runtime.</p> <h2 id=\"forcing-deferred-notifications-to-happen-early\">Forcing deferred notifications to happen early</h2> <p>Although deferred, asynchronous notifications are generally better because of fewer UI updates, it can be a problem if you need to update the UI immediately. Sometimes, for proper functionality, you need an intermediate value pushed to the UI. You can accomplish this using the <a href=\"microtasks#advanced-queue-control\"><code>ko.tasks.runEarly</code> method</a>. For example:</p> <pre>// remove an item from an array\nvar items = myArray.splice(sourceIndex, 1);\n\n// force updates so the UI will see a delete/add rather than a move\nko.tasks.runEarly();\n\n// add the item in a new location\nmyArray.splice(targetIndex, 0, items[0]);\n</pre> <h2 id=\"forcing-deferred-observables-to-always-notify-subscribers\">Forcing deferred observables to always notify subscribers</h2> <p>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued deferred observables notify only when their value is actually different at the end of the current task. In other words, if a primitive-valued deferred observable is changed to a new value and then changed back to the original value, no notification will happen.</p> <p>To ensure that the subscribers are always notified of an update, even if the value is the same, you would use the <code>notify</code> extender:</p> <pre>ko.options.deferUpdates = true;\n\nmyViewModel.fullName = ko.pureComputed(function() {\n    return myViewModel.firstName() + \" \" + myViewModel.lastName();\n}).extend({ notify: 'always' });\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/deferred-updates.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/deferred-updates.html</a>\n  </p>\n</div>\n","asynchronous-error-handling":"<h1>Asynchronous error handling</h1> <p><em>Note: This documentation applies to Knockout 3.4.0 and later.</em></p> <h2 id=\"koonerror\">ko.onError</h2> <p>Knockout wraps internal asynchronous calls and looks for an optional <code>ko.onError</code> callback to execute, if an exception is encountered, before throwing the original error. This gives you the opportunity to run custom logic, such as passing the error to a logging module. Additionally, since the original call is wrapped in a try/catch, the error passed to <code>ko.onError</code> contains a <code>stack</code> property, which is not true in many browsers when handling errors using <code>window.onerror</code>.</p> <p>This functionality applies to errors in the following contexts:</p> <ul> <li>asynchronous updates made as part of the <code>textInput</code> and <code>value</code> binding</li> <li>component loading of a cached component when not configured for <a href=\"component-registration#controlling-synchronousasynchronous-loading\">synchronous loading</a>\n</li> <li>\n<a href=\"ratelimit-observable\">rate-limited</a> and <a href=\"http://knockoutjs.com/documentation/throttle-extender.html\">throttled</a> computeds</li> <li>event handlers added by <code>ko.utils.registerEventHandler</code> including those bound by the <code>event</code> and <code>click</code> bindings</li> </ul> <h2 id=\"example\">Example</h2> <pre>ko.onError = function(error) {\n    myLogger(\"knockout error\", error);\n};\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/asynchronous-error-handling.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/asynchronous-error-handling.html</a>\n  </p>\n</div>\n","component-loaders":"<h1>Component loaders</h1> <p>Whenever you inject a <a href=\"component-overview\">component</a> using the <a href=\"component-binding\"><code>component</code> binding</a> or a <a href=\"component-custom-elements\">custom element</a>, Knockout fetches that component’s template and viewmodel using one or more <em>component loaders</em>. The job of a component loader is to asynchronously supply a template/viewmodel pair for any given component name.</p> <ul id=\"markdown-toc\"> <li><a href=\"#default-component-loader\">The default component loader</a></li> <li><a href=\"#component-loader-utility-functions\">Component loader utility functions</a></li> <li>\n<a href=\"#custom-component-loader\">Implementing a custom component loader</a> <ul> <li>\n<a href=\"#functions-you-can-implement\">Functions you can implement</a> <ul> <li><a href=\"#getconfigname-callback\"><code>getConfig(name, callback)</code></a></li> <li><a href=\"#loadcomponentname-componentconfig-callback\"><code>loadComponent(name, componentConfig, callback)</code></a></li> <li><a href=\"#loadtemplatename-templateconfig-callback\"><code>loadTemplate(name, templateConfig, callback)</code></a></li> <li><a href=\"#loadviewmodelname-templateconfig-callback\"><code>loadViewModel(name, templateConfig, callback)</code></a></li> </ul> </li> <li><a href=\"#registering-custom-component-loaders\">Registering custom component loaders</a></li> <li><a href=\"#controlling-precedence\">Controlling precedence</a></li> <li><a href=\"#sequence-of-calls\">Sequence of calls</a></li> </ul> </li> <li><a href=\"#example-1-a-component-loader-that-sets-up-naming-conventions\">Example 1: A component loader that sets up naming conventions</a></li> <li><a href=\"#example-2-a-component-loader-that-loads-external-files-using-custom-code\">Example 2: A component loader that loads external files using custom code</a></li> <li><a href=\"#note-custom-component-loaders-and-custom-elements\">Note: Custom component loaders and custom elements</a></li> <li><a href=\"#note-integrating-with-browserify\">Note: Integrating with browserify</a></li> </ul> <h2 id=\"default-component-loader\">The default component loader</h2> <p>The built-in default component loader, <code>ko.components.defaultLoader</code>, is based around a central “registry” of component definitions. It relies on you explicitly registering a configuration for each component before you can use that component.</p> <p><a href=\"component-registration\">Learn more about configuring and registering components with the default loader</a></p> <h2 id=\"component-loader-utility-functions\">Component loader utility functions</h2> <p>The following functions read and write the default component loader’s registry:</p> <ul> <li>\n<code>ko.components.register(name, configuration)</code> <ul> <li>Registers a component. See: <a href=\"component-registration\">full documentation</a>.</li> </ul> </li> <li>\n<code>ko.components.isRegistered(name)</code> <ul> <li>Returns <code>true</code> if a component with the specified name is already registered; <code>false</code> otherwise.</li> </ul> </li> <li>\n<code>ko.components.unregister(name)</code> <ul> <li>Removes the named component from the registry. Or if no such component was registered, does nothing.</li> </ul> </li> </ul> <p>The following functions work across the complete list of registered component loaders (not only the default loader):</p> <ul> <li>\n<code>ko.components.get(name, callback)</code> <ul> <li>Consults each registered loader in turn (by default, that’s just the default loader), to find the first one that supplies a viewmodel/template definition for the named component, then invokes <code>callback</code> to return than viewmodel/template declaration. Invokes <code>callback(null)</code> if none of the registered loaders know about this component.</li> </ul> </li> <li>\n<code>ko.components.clearCachedDefinition(name)</code> <ul> <li>Normally, Knockout consults the loaders <em>once per component name</em>, then caches the resulting definition. This ensures that large numbers of components may be instantiated very quickly. If you want to clear the cache entry for a given component, call this, and then the loaders will be consulted again the next time that component is needed.</li> </ul> </li> </ul> <p>Also, since <code>ko.components.defaultLoader</code> is a component loader, it implements the following standard component loader functions. You can invoke these directly, e.g., as part of your implementation of a custom loader:</p> <ul> <li><code>ko.components.defaultLoader.getConfig(name, callback)</code></li> <li><code>ko.components.defaultLoader.loadComponent(name, componentConfig, callback)</code></li> <li><code>ko.components.defaultLoader.loadTemplate(name, templateConfig, callback)</code></li> <li><code>ko.components.defaultLoader.loadViewModel(name, viewModelConfig, callback)</code></li> </ul> <p>For documentation on these standard component loader functions, see <a href=\"#custom-component-loader\">implementing a custom component loader</a>.</p> <h2 id=\"custom-component-loader\">Implementing a custom component loader</h2> <p>You might want to implement a custom component loader if you want to use naming conventions, rather than explicit registration, to load components. Or, if you want to use a third-party “loader” library to fetch component viewmodels or templates from external locations.</p> <h2 id=\"functions-you-can-implement\">Functions you can implement</h2> <p>A custom component loader is simply an object whose properties are <strong>any combination</strong> of the following functions:</p> <h3 id=\"getconfigname-callback\"><code>getConfig(name, callback)</code></h3> <p><em><strong>Define this if:</strong> you want to supply configurations programmatically based on names, e.g., to implement a naming convention.</em></p> <p>If declared, Knockout will call this function to obtain a configuration object for each component being instantiated.</p> <ul> <li>To supply a configuration, call <code>callback(componentConfig)</code>, where <code>componentConfig</code> is any object that can be understood by the <code>loadComponent</code> function on your loader or any other loader. The default loader simply supplies whatever object was registered using <code>ko.components.register</code>.</li> <li>For example, a <code>componentConfig</code> like <code>{ template: 'someElementId', viewModel: { require: 'myModule' } }</code> can be understood and instantiated by the default loader.</li> <li>You are not limited to supplying configuration objects in any standard format. You can supply arbitrary objects as long as your <code>loadComponent</code> function understands them.</li> <li>If you do not want your loader to supply a configuration for the named component, then call <code>callback(null)</code>. Knockout will then consult any other registered loaders in sequence, until one supplies a non-<code>null</code> value.</li> </ul> <h3 id=\"loadcomponentname-componentconfig-callback\"><code>loadComponent(name, componentConfig, callback)</code></h3> <p><em><strong>Define this if:</strong> you want to take control over how component configurations are interpreted, e.g., if you do not want to use the standard <code>viewModel</code>/<code>template</code> pair format.</em></p> <p>If declared, Knockout will call this function to convert a <code>componentConfig</code> object into a viewmodel/template pair. </p> <ul> <li> <p>To supply a viewmodel/template pair, call <code>callback(result)</code>, where <code>result</code> is an object with the following properties:</p> <ul> <li>\n<code>template</code> - <strong>Required.</strong> An array of DOM nodes</li> <li>\n<code>createViewModel(params, componentInfo)</code> - <strong>Optional.</strong> A function that will later be called to supply a viewmodel object for each instance of this component</li> </ul> </li> <li> <p>If you do not want your loader to supply a viewmodel/template pair for the given parameters, then call <code>callback(null)</code>. Knockout will then consult any other registered loaders in sequence, until one supplies a non-<code>null</code> value.</p> </li> </ul> <h3 id=\"loadtemplatename-templateconfig-callback\"><code>loadTemplate(name, templateConfig, callback)</code></h3> <p><em><strong>Define this if:</strong> you want to use custom logic to supply DOM nodes for a given template configuration (e.g., using an ajax request to fetch a template by URL).</em></p> <p>The default component loader will call this function on any registered loaders that declare it, to convert the <code>template</code> part of a component configuration into an array of DOM nodes. The nodes are then cached and cloned for each instance of the component.</p> <p>The <code>templateConfig</code> value is simply the <code>template</code> property from any <code>componentConfig</code> object. For example, it may contain <code>\"some markup\"</code> or <code>{ element: \"someId\" }</code> or a custom format such as <code>{ loadFromUrl: \"someUrl.html\" }</code>.</p> <ul> <li> <p>To supply an array of DOM nodes, call <code>callback(domNodeArray)</code>.</p> </li> <li> <p>If you do not want your loader to supply a template for the given parameters (e.g., because it does not recognize the configuration format), call <code>callback(null)</code>. Knockout will then consult any other registered loaders in sequence, until one supplies a non-<code>null</code> value.</p> </li> </ul> <h3 id=\"loadviewmodelname-templateconfig-callback\"><code>loadViewModel(name, templateConfig, callback)</code></h3> <p><em><strong>Define this if:</strong> you want to use custom logic to supply a viewmodel factory for a given viewmodel configuration (e.g., integrating with a third-party module loader or dependency injection system).</em></p> <p>The default component loader will call this function on any registered loaders that declare it, to convert the <code>viewModel</code> part of a component configuration into a <code>createViewModel</code> factory function. The function is then cached and called for each new instance of the component that needs a viewmodel.</p> <p>The <code>viewModelConfig</code> value is simply the <code>viewModel</code> property from any <code>componentConfig</code> object. For example, it may be a constructor function, or a custom format such as <code>{ myViewModelType: 'Something', options: {} }</code>.</p> <ul> <li> <p>To supply a <code>createViewModel</code> function, call <code>callback(yourCreateViewModelFunction)</code>. The <code>createViewModel</code> function must accept parameters <code>(params, componentInfo)</code> and must synchronously return a new viewmodel instance each time it is called.</p> </li> <li> <p>If you do not want your loader to supply a <code>createViewModel</code> function for the given parameters (e.g., because it does not recognize the configuration format), call <code>callback(null)</code>. Knockout will then consult any other registered loaders in sequence, until one supplies a non-<code>null</code> value.</p> </li> </ul> <h2 id=\"registering-custom-component-loaders\">Registering custom component loaders</h2> <p>Knockout allows you to use multiple component loaders simultaneously. This is useful so that, for example, you can plug in loaders that implement different mechanisms (e.g., one might fetch templates from a backend server according to a naming convention; another might set up viewmodels using a dependency injection system) and have them work together.</p> <p>So, <code>ko.components.loaders</code> is an array containing all the loaders currently enabled. By default, this array contains just one item: <code>ko.components.defaultLoader</code>. To add additional loaders, simply insert them into the <code>ko.components.loaders</code> array.</p> <h2 id=\"controlling-precedence\">Controlling precedence</h2> <p>If you want your custom loader to take precedence over the default loader (so it gets the first opportunity to supply configuration/values), then add it to the <em>beginning</em> of the array. If you want the default loader to take precedence (so your custom loader is only called for components not explicitly registered), then add it to the <em>end</em> of the array.</p> <p>Example:</p> <pre>// Adds myLowPriorityLoader to the end of the loaders array.\n// It runs after other loaders, only if none of them returned a value.\nko.components.loaders.push(myLowPriorityLoader);\n\n// Adds myHighPriorityLoader to the beginning of the loaders array.\n// It runs before other loaders, getting the first chance to return values.\nko.components.loaders.unshift(myHighPriorityLoader)\n</pre> <p>If required, you can remove <code>ko.components.defaultLoader</code> from the loaders array altogether.</p> <h2 id=\"sequence-of-calls\">Sequence of calls</h2> <p>The first time Knockout needs to construct a component with a given name, it:</p> <ul> <li>Calls each of the registered loaders’ <code>getConfig</code> functions in turn, until the first one supplies a non-null <code>componentConfig</code>.</li> <li>Then, with this <code>componentConfig</code> object, calls each of the registered loaders’ <code>loadComponent</code> functions in turn, until the first one supplies a non-null <code>template</code>/<code>createViewModel</code> pair.</li> </ul> <p>When the default loader’s <code>loadComponent</code> runs, it simultaneously:</p> <ul> <li>Calls each of the registered loaders’ <code>loadTemplate</code> functions in turn, until the first one supplies a non-null DOM array. <ul> <li>The default loader itself has a <code>loadTemplate</code> function that resolves a range of template configuration formats into DOM arrays.</li> </ul> </li> <li>Calls each of the registered loaders’ <code>loadViewModel</code> functions in turn, until the first one supplies a non-null <code>createViewModel</code> function. <ul> <li>The default loader itself has a <code>loadViewModel</code> function that resolves a range of viewmodel configuration formats into <code>createViewModel</code> functions.</li> </ul> </li> </ul> <p>Custom loaders can plug into any part of this process, so you can take control over supplying configurations, interpreting configurations, supplying DOM nodes, or supplying viewmodel factory functions. By putting custom loaders into a chosen order inside <code>ko.components.loaders</code>, you can control the priority order of different loading strategies.</p> <h2 id=\"example-1-a-component-loader-that-sets-up-naming-conventions\">Example 1: A component loader that sets up naming conventions</h2> <p>To implement a naming convention, your custom component loader only needs to implement <code>getConfig</code>. For example:</p> <pre>var namingConventionLoader = {\n    getConfig: function(name, callback) {\n        // 1. Viewmodels are classes corresponding to the component name.\n        //    e.g., my-component maps to MyApp.MyComponentViewModel\n        // 2. Templates are in elements whose ID is the component name\n        //    plus '-template'.    \n        var viewModelConfig = MyApp[toPascalCase(name) + 'ViewModel'],\n            templateConfig = { element: name + '-template' };\n\n        callback({ viewModel: viewModelConfig, template: templateConfig });\n    }\n};\n\nfunction toPascalCase(dasherized) {\n    return dasherized.replace(/(^|-)([a-z])/g, function (g, m1, m2) { return m2.toUpperCase(); });\n}\n\n// Register it. Make it take priority over the default loader.\nko.components.loaders.unshift(namingConventionLoader);\n</pre> <p>Now this is registered, you can reference components with any name (without preregistering them), e.g.:</p> <pre>&lt;div data-bind=\"component: 'my-component'\"&gt;&lt;/div&gt;\n\n&lt;!-- Declare template --&gt;\n&lt;template id='my-component-template'&gt;Hello World!&lt;/template&gt;\n\n&lt;script&gt;\n    // Declare viewmodel\n    window.MyApp = window.MyApp || {};\n    MyApp.MyComponentViewModel = function(params) {\n        // ...\n    }\n&lt;/script&gt;\n</pre> <h2 id=\"example-2-a-component-loader-that-loads-external-files-using-custom-code\">Example 2: A component loader that loads external files using custom code</h2> <p>If your custom loader implements <code>loadTemplate</code> and/or <code>loadViewModel</code>, then you can plug in custom code to the loading process. You can also use these functions to interpret custom configuration formats.</p> <p>For example, you might want to enable configuration formats like the following:</p> <pre>ko.components.register('my-component', {\n    template: { fromUrl: 'file.html', maxCacheAge: 1234 },\n    viewModel: { viaLoader: '/path/myvm.js' }\n});\n</pre> <p>… and you can do so using custom loaders.</p> <p>The following custom loader will take care of loading templates configured with a <code>fromUrl</code> value:</p> <pre>var templateFromUrlLoader = {\n    loadTemplate: function(name, templateConfig, callback) {\n        if (templateConfig.fromUrl) {\n            // Uses jQuery's ajax facility to load the markup from a file\n            var fullUrl = '/templates/' + templateConfig.fromUrl + '?cacheAge=' + templateConfig.maxCacheAge;\n            $.get(fullUrl, function(markupString) {\n                // We need an array of DOM nodes, not a string.\n                // We can use the default loader to convert to the\n                // required format.\n                ko.components.defaultLoader.loadTemplate(name, markupString, callback);\n            });\n        } else {\n            // Unrecognized config format. Let another loader handle it.\n            callback(null);\n        }\n    }\n};\n\n// Register it\nko.components.loaders.unshift(templateFromUrlLoader);\n</pre> <p>… and the following custom loader will take care of loading viewmodels configured with a <code>viaLoader</code> value:</p> <pre>var viewModelCustomLoader = {\n    loadViewModel: function(name, viewModelConfig, callback) {\n        if (viewModelConfig.viaLoader) {\n            // You could use arbitrary logic, e.g., a third-party\n            // code loader, to asynchronously supply the constructor.\n            // For this example, just use a hard-coded constructor function.\n            var viewModelConstructor = function(params) {\n                this.prop1 = 123;\n            };\n\n            // We need a createViewModel function, not a plain constructor.\n            // We can use the default loader to convert to the\n            // required format.\n            ko.components.defaultLoader.loadViewModel(name, viewModelConstructor, callback);\n        } else {\n            // Unrecognized config format. Let another loader handle it.\n            callback(null);\n        }\n    }\n};\n\n// Register it\nko.components.loaders.unshift(viewModelCustomLoader);\n</pre> <p>If you prefer, you could combine <code>templateFromUrlLoader</code> and <code>viewModelCustomLoader</code> into a single loader by putting the <code>loadTemplate</code> and <code>loadViewModel</code> functions on a single object. However it’s quite nice to separate out these concerns, since their implementations are quite independent.</p> <h2 id=\"note-custom-component-loaders-and-custom-elements\">Note: Custom component loaders and custom elements</h2> <p>If you are using a component loader to fetch components by a naming convention, and are <em>not</em> registering your components using <code>ko.components.register</code>, then those components will not automatically be usable as custom elements (because you haven’t told Knockout that they even exist).</p> <p>See: <a href=\"component-custom-elements#registering-custom-elements\">How to enable custom elements with names that don’t correspond to explicitly registered components</a></p> <h2 id=\"note-integrating-with-browserify\">Note: Integrating with browserify</h2> <p><a href=\"http://browserify.org/\">Browserify</a> is a popular library for referencing JavaScript libraries with a Node-style synchronous <code>require</code> syntax. It’s often considered as an alternative to an AMD loader such as require.js. However Browserify solves a rather different problem: synchronous build-time reference resolution, rather than asynchronous runtime reference resolution as handled by AMD.</p> <p>Since Browserify is a build-time tool, it doesn’t really need any special integration with KO components, and there’s no need to implement any kind of custom component loader to work with it. You can simply use Browserify’s <code>require</code> statements to grab instances of your component viewmodels, then explicitly register them, e.g.:</p> <pre>// Note that the following *only* works with Browserify - not with require.js,\n// since it relies on require() returning synchronously.\n\nko.components.register('my-browserify-component', {\n    viewModel: require('myViewModel'),\n    template: require('fs').readFileSync(__dirname + '/my-template.html', 'utf8')\n});\n</pre> <p>This uses the <a href=\"https://github.com/substack/brfs\">brfs Browserify plugin</a> to automatically inline the .html file, so you would need to build the script file using a command similar to:</p> <pre>npm install brfs\nbrowserify -t brfs main.js &gt; bundle.js\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/component-loaders.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/component-loaders.html</a>\n  </p>\n</div>\n","ratelimit-observable":"<h1>Rate-limiting observable notifications</h1> <p><em>Note: This rate-limit API was added in Knockout 3.1.0. For previous versions, the <a href=\"http://knockoutjs.com/documentation/throttle-extender.html\"><code>throttle</code> extender</a> provides similar functionality.</em></p> <p>Normally, an <a href=\"observables\">observable</a> that is changed notifies its subscribers immediately, so that any computed observables or bindings that depend on the observable are updated synchronously. The <code>rateLimit</code> extender, however, causes an observable to suppress and delay change notifications for a specified period of time. A rate-limited observable therefore updates dependencies asynchronously.</p> <p>The <code>rateLimit</code> extender can be applied to any type of observable, including <a href=\"observablearrays\">observable arrays</a> and <a href=\"computedobservables\">computed observables</a>. The main use cases for rate-limiting are:</p> <ul> <li>Making things respond after a certain delay</li> <li>Combining multiple changes into a single update</li> </ul> <p>If you only need to combine updates without adding a delay, <a href=\"deferred-updates\">deferred updates</a> provides a more efficient method.</p> <h3 id=\"applying-the-ratelimit-extender\">Applying the rateLimit extender</h3> <p><code>rateLimit</code> supports two parameter formats:</p> <pre>// Shorthand: Specify just a timeout in milliseconds\nsomeObservableOrComputed.extend({ rateLimit: 500 });\n\n// Longhand: Specify timeout and/or method\nsomeObservableOrComputed.extend({ rateLimit: { timeout: 500, method: \"notifyWhenChangesStop\" } });\n</pre> <p>The <code>method</code> option controls when notifications fire, and accepts the following values:</p> <ol> <li> <p><code>notifyAtFixedRate</code> — <strong>Default value if not otherwise specified</strong>. The notification happens after the specified period of time from the first change to the observable (either initially or since the previous notification).</p> </li> <li> <p><code>notifyWhenChangesStop</code> — The notification happens after no changes have occured to the observable for the specified period of time. Each time the observable changes, that timer is reset, so notifications cannot happen if the observable continuously changes more frequently than the timeout period.</p> </li> </ol> <h3 id=\"example-1-the-basics\">Example 1: The basics</h3> <p>Consider the observables in the following code:</p> <pre>var name = ko.observable('Bert');\n\nvar upperCaseName = ko.computed(function() {\n    return name().toUpperCase();\n});\n</pre> <p>Normally, if you change <code>name</code> as follows:</p> <pre>name('The New Bert');\n</pre> <p>… then <code>upperCaseName</code> will be recomputed immediately, before your next line of code runs. But if you instead define <code>name</code> using <code>rateLimit</code> as follows:</p> <pre>var name = ko.observable('Bert').extend({ rateLimit: 500 });\n</pre> <p>… then <code>upperCaseName</code> will not be recomputed immediately when <code>name</code> changes—instead, <code>name</code> will wait for 500 milliseconds (half a second) before notifying its new value to <code>upperCaseName</code>, which will then recompute its value. No matter how many times <code>name</code> is changed during those 500 ms, <code>upperCaseName</code> will only be updated once with the most recent value.</p> <h3 id=\"example-2-doing-something-when-the-user-stops-typing\">Example 2: Doing something when the user stops typing</h3> <p>In this live example, there’s an <code>instantaneousValue</code> observable that reacts immediately when you press a key. This is then wrapped inside a <code>delayedValue</code> computed observable that’s configured to notify only when changes stop for at least 400 milliseconds, using the <code>notifyWhenChangesStop</code> rate-limit method.</p> <p>Try it:</p> <div class=\"liveExample\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n&lt;p&gt;Type stuff here: &lt;input data-bind='textInput: instantaneousValue' /&gt;&lt;/p&gt;\n&lt;p&gt;Current delayed value: &lt;b data-bind='text: delayedValue'&gt; &lt;/b&gt;&lt;/p&gt;\n\n&lt;div data-bind=\"visible: loggedValues().length &gt; 0\"&gt;\n    &lt;h3&gt;Stuff you have typed:&lt;/h3&gt;\n    &lt;ul data-bind=\"foreach: loggedValues\"&gt;\n        &lt;li data-bind=\"text: $data\"&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\nfunction AppViewModel() {\n    this.instantaneousValue = ko.observable();\n    this.delayedValue = ko.pureComputed(this.instantaneousValue)\n        .extend({ rateLimit: { method: \"notifyWhenChangesStop\", timeout: 400 } });\n\n    // Keep a log of the throttled values\n    this.loggedValues = ko.observableArray([]);\n    this.delayedValue.subscribe(function (val) {\n        if (val !== '')\n            this.loggedValues.push(val);\n    }, this);\n}\n\nko.applyBindings(new AppViewModel());\n</pre> <h2 id=\"special-consideration-for-computed-observables\">Special consideration for computed observables</h2> <p>For a computed observable, the rate-limit timer is triggered when one of the computed observable’s dependencies change instead of when its value changes. The computed observable is not re-evaluated until its value is actually needed—after the timeout period when the change notification should happen, or when the computed observable value is accessed directly. If you need to access the value of the computed’s most recent evaluation, you can do so with the <code>peek</code> method.</p> <h2 id=\"forcing-rate-limited-observables-to-always-notify-subscribers\">Forcing rate-limited observables to always notify subscribers</h2> <p>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued rate-limited observables notify only when their value is actually different at the end of the timeout period. In other words, if a primitive-valued rate-limited observable is changed to a new value and then changed back to the original value before the timeout period ends, no notification will happen.</p> <p>If you want to ensure that the subscribers are always notified of an update, even if the value is the same, you would use the <code>notify</code> extender in addition to <code>rateLimit</code>:</p> <pre>myViewModel.fullName = ko.computed(function() {\n    return myViewModel.firstName() + \" \" + myViewModel.lastName();\n}).extend({ notify: 'always', rateLimit: 500 });\n</pre> <h2 id=\"comparison-with-deferred-updates\">Comparison with deferred updates</h2> <p>Knockout version 3.4.0 added support for <a href=\"deferred-updates\"><em>deferred updates</em></a>, which works similarly to rate-limiting by making notifications and updates asynchronous. But instead of using a timed delay, deferred updates are processed as soon as possible after the current task, before yielding for I/O, reflow, or redrawing. If you are upgrading to 3.4.0 and have code that uses a short rate-limit timeout (e.g., 0 milliseconds), you could modify it to use deferred updates instead:</p> <pre>ko.computed(function() {\n    // ....\n}).extend({ deferred: true });\n</pre> <h2 id=\"comparison-with-the-throttle-extender\">Comparison with the throttle extender</h2> <p>If you’d like to migrate code from using the deprecated <code>throttle</code> extender, you should note the following ways that the <code>rateLimit</code> extender is different from the <code>throttle</code> extender.</p> <p>When using <code>rateLimit</code>:</p> <ol> <li>\n<em>Writes</em> to observables are not delayed; the observable’s value is updated right away. For writable computed observables, this means that the write function is always run right away.</li> <li>All <code>change</code> notifications are delayed, including when calling <code>valueHasMutated</code> manually. This means you can’t use <code>valueHasMutated</code> to force a rate-limited observable to notify an un-changed value.</li> <li>The default rate-limit method is different from the <code>throttle</code> algorithm. To match the <code>throttle</code> behavior, use the <code>notifyWhenChangesStop</code> method.</li> <li>Evaluation of a rate-limited computed observable isn’t rate-limited; it will re-evaluate if you read its value.</li> </ol><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/rateLimit-observable.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/rateLimit-observable.html</a>\n  </p>\n</div>\n","unobtrusive-event-handling":"<h1>Using unobtrusive event handlers</h1> <p>In most cases, data-bind attributes provide a clean and succinct way to bind to a view model. However, event handling is one area that can often result in verbose data-bind attributes, as anonymous functions were typically the recommended techinique to pass arguments. For example:</p> <pre>&lt;a href=\"#\" data-bind=\"click: function() { viewModel.items.remove($data); }\"&gt;\n    remove\n&lt;/a&gt;\n</pre> <p>As an alternative, Knockout provides two helper functions that allow you to identify the data associated with a DOM element:</p> <ul> <li>\n<code>ko.dataFor(element)</code> - returns the data that was available for binding against the element</li> <li>\n<code>ko.contextFor(element)</code> - returns the entire <a href=\"binding-context\">binding context</a> that was available to the DOM element.</li> </ul> <p>These helper functions can be used in event handlers that are attached unobtrusively using something like jQuery’s <code>bind</code> or <code>click</code>. The above function could be attached to each link with a <code>remove</code> class like:</p> <pre>$(\".remove\").click(function () {\n    viewModel.items.remove(ko.dataFor(this));\n});\n</pre> <p>Better yet, this techinique could be used to support event delegation. jQuery’s <code>live/delegate/on</code> functions are an easy way to make this happen:</p> <pre>$(\".container\").on(\"click\", \".remove\", function() {\n    viewModel.items.remove(ko.dataFor(this));\n});\n</pre> <p>Now, a single event handler is attached at a higher level and handles clicks against any links with the <code>remove</code> class. This method has the added benefit of automatically handling additional links that are dynamically added to the document (perhaps as the result of an item being added to an observableArray).</p> <h3 id=\"live-example-nested-children\">Live example: nested children</h3> <p>This example shows “add” and “remove” links on multiple levels of parents and children with a single handler attached unobtrusively for each type of link. </p> <div class=\"liveExample\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n&lt;ul id=\"people\" data-bind='template: { name: \"personTmpl\", foreach: people }'&gt;\n&lt;/ul&gt;\n\n&lt;script id=\"personTmpl\" type=\"text/html\"&gt;\n    &lt;li&gt;\n        &lt;a class=\"remove\" href=\"#\"&gt; x &lt;/a&gt;\n        &lt;span data-bind='text: name'&gt;&lt;/span&gt;\n        &lt;a class=\"add\" href=\"#\"&gt; add child &lt;/a&gt;\n        &lt;ul data-bind='template: { name: \"personTmpl\", foreach: children }'&gt;&lt;/ul&gt;\n    &lt;/li&gt;\n&lt;/script&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\nvar Person = function(name, children) {\n    this.name = ko.observable(name);\n    this.children = ko.observableArray(children || []);\n};\n\nvar PeopleModel = function() {\n    this.people = ko.observableArray([\n        new Person(\"Bob\", [\n            new Person(\"Jan\"),\n            new Person(\"Don\", [\n                new Person(\"Ted\"),\n                new Person(\"Ben\", [\n                    new Person(\"Joe\", [\n                        new Person(\"Ali\"),\n                        new Person(\"Ken\")\n                    ])\n                ]),\n                new Person(\"Doug\")\n            ])\n        ]),\n        new Person(\"Ann\", [\n            new Person(\"Eve\"),\n            new Person(\"Hal\")\n        ])\n    ]);\n\n    this.addChild = function(name, parentArray) {\n        parentArray.push(new Person(name));\n    };\n};\n\nko.applyBindings(new PeopleModel());\n\n//attach event handlers\n$(\"#people\").on(\"click\", \".remove\", function() {\n    //retrieve the context\n    var context = ko.contextFor(this),\n        parentArray = context.$parent.people || context.$parent.children;\n\n    //remove the data (context.$data) from the appropriate array on its parent (context.$parent)\n    parentArray.remove(context.$data);\n\n    return false;\n});\n\n$(\"#people\").on(\"click\", \".add\", function() {\n    //retrieve the context\n    var context = ko.contextFor(this),\n        childName = context.$data.name() + \" child\",\n        parentArray = context.$data.people || context.$data.children;\n\n    //add a child to the appropriate parent, calling a method off of the main view model (context.$root)\n    context.$root.addChild(childName, parentArray);\n\n    return false;\n});\n\n</pre> <p>No matter how nested the links become, the handler is always able to identify and operate on the appropriate data. Using this techinique, we can avoid the overhead of attaching handlers to each individual link and can keep the markup clean and concise.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/unobtrusive-event-handling.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/unobtrusive-event-handling.html</a>\n  </p>\n</div>\n","fn":"<h1>Adding custom functions using \"fn\"</h1> <p>Occasionally, you may find opportunities to streamline your code by attaching new functionality to Knockout’s core value types. You can define custom functions on any of the following types:</p> <p><img src=\"http://knockoutjs.com/documentation/images/fn/type-hierarchy.png\" alt=\"\"></p> <p>Because of inheritance, if you attach a function to <code>ko.subscribable</code>, it will be available on all the others too. If you attach a function to <code>ko.observable</code>, it will be inherited by <code>ko.observableArray</code> but not by <code>ko.computed</code>.</p> <p>To attach a custom function, add it to one of the following extensibility points:</p> <ul> <li><code>ko.subscribable.fn</code></li> <li><code>ko.observable.fn</code></li> <li><code>ko.observableArray.fn</code></li> <li><code>ko.computed.fn</code></li> </ul> <p>Then, your custom function will become available on all values of that type created from that point onwards.</p> <p><strong><em>Note:</em></strong> It’s best to use this extensibility point only for custom functions that are truly applicable in a wide range of scenarios. You don’t need to add a custom function to these namespaces if you’re only planning to use it once. </p> <h3 id=\"example-a-filtered-view-of-an-observable-array\">Example: A filtered view of an observable array</h3> <p>Here’s a way to define a <code>filterByProperty</code> function that will become available on all subsequently-created <code>ko.observableArray</code> instances:</p> <pre>ko.observableArray.fn.filterByProperty = function(propName, matchValue) {\n    return ko.pureComputed(function() {\n        var allItems = this(), matchingItems = [];\n        for (var i = 0; i &lt; allItems.length; i++) {\n            var current = allItems[i];\n            if (ko.unwrap(current[propName]) === matchValue)\n                matchingItems.push(current);\n        }\n        return matchingItems;\n    }, this);\n}\n</pre> <p>This returns a new computed value that provides a filtered view of the array, while leaving the original array unchanged. Because the filtered array is a computed observable, it will be re-evaluated whenever the underlying array changes.</p> <p>The following live example shows how you could use this:</p>  <div class=\"liveExample\">Live examples are not available on DevDocs, sorry.</div> <h4>Source code: View</h4> <pre class=\"brush:html\">\n&lt;h3&gt;All tasks (&lt;span data-bind=\"text: tasks().length\"&gt; &lt;/span&gt;)&lt;/h3&gt;\n&lt;ul data-bind=\"foreach: tasks\"&gt;\n    &lt;li&gt;\n        &lt;label&gt;\n            &lt;input type=\"checkbox\" data-bind=\"checked: done\" /&gt;\n            &lt;span data-bind=\"text: title\"&gt; &lt;/span&gt;\n        &lt;/label&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h3&gt;Done tasks (&lt;span data-bind=\"text: doneTasks().length\"&gt; &lt;/span&gt;)&lt;/h3&gt;\n&lt;ul data-bind=\"foreach: doneTasks\"&gt;\n    &lt;li data-bind=\"text: title\"&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</pre> <h4>Source code: View model</h4> <pre class=\"brush:js\">\nfunction Task(title, done) {\n    this.title = ko.observable(title);\n    this.done = ko.observable(done);\n}\n\nfunction AppViewModel() {\n    this.tasks = ko.observableArray([\n        new Task('Find new desktop background', true),\n        new Task('Put shiny stickers on laptop', false),\n        new Task('Request more reggae music in the office', true)\n    ]);\n\n    // Here's where we use the custom function\n    this.doneTasks = this.tasks.filterByProperty(\"done\", true);\n}\n\nko.applyBindings(new AppViewModel());\n</pre> <h4 id=\"its-not-mandatory\">It’s not mandatory</h4> <p>If you tend to filter observable arrays a lot, adding a <code>filterByProperty</code> globally to all observable arrays might make your code tidier. But if you only need to filter occasionally, you could instead choose <em>not</em> to attach to <code>ko.observableArray.fn</code>, and instead just construct <code>doneTasks</code> by hand as follows:</p> <pre>this.doneTasks = ko.pureComputed(function() {\n    var all = this.tasks(), done = [];\n    for (var i = 0; i &lt; all.length; i++)\n        if (all[i].done())\n            done.push(all[i]);\n    return done;\n}, this);\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/fn.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/fn.html</a>\n  </p>\n</div>\n","microtasks":"<h1>Microtasks</h1> <p><em>Note: This documentation applies to Knockout 3.4.0 and later.</em></p> <h2 id=\"knockouts-microtask-queue\">Knockout’s microtask queue</h2> <p>Knockout’s microtask queue supports scheduling tasks to run as soon as possible while still being asynchronous, striving to schedule them to occur before yielding for I/O, reflow, or redrawing. It is used internally for <a href=\"component-overview\">Knockout components</a> to maintain asynchronous behavior, and for scheduling <a href=\"deferred-updates\">deferred updates</a> for observables.</p> <pre>ko.tasks.schedule(function () {\n    // ...\n});\n</pre> <p>This will add the provided callback function to the microtask queue. Knockout includes a fast task queue that runs tasks in FIFO order until the queue is empty. When the first task is scheduled, Knockout will schedule a flush event using the <a href=\"#implementation\">browser’s microtask</a> support if possible. This ensures that the first task and subsequent tasks behave similarly.</p> <p>Microtasks can be canceled using the <em>handle</em> value returned from <code>ko.tasks.schedule</code>. If the task has already run or was previously canceled, <code>cancel</code> does nothing.</p> <pre>var handle = ko.tasks.schedule(/* ... */);\nko.tasks.cancel(handle);\n</pre> <h3 id=\"error-handling\">Error handling</h3> <p>If a task throws an exception, it will not interrupt the task queue, which will continue until it is empty. The exception will instead be postponed to a later event and can be handled using <a href=\"asynchronous-error-handling\"><code>ko.onError</code></a> or <code>window.onerror</code>.</p> <h3 id=\"recursive-task-limit\">Recursive task limit</h3> <p>Since Knockout processes the microtask queue until it is empty, without yielding to external events, numerous or lengthy tasks could cause the browser page to become unresponsive. Knockout prevents infinite recursion by canceling all remaining tasks if it detects a high level of recursion. For example, the following will eventually stop and throw an error:</p> <pre>function loop() {\n    ko.tasks.schedule(loop);\n}\nloop();\n</pre> <h3 id=\"implementation\">Implementation</h3> <p>When the first task is scheduled (initially and after a previous flush event has finished), Knockout will schedule a flush event to process the microtask queue. If possible, it will try to use the browsers’s own microtask capabilities. In modern browsers, it will use a <a href=\"http://dom.spec.whatwg.org/#mutation-observers\">DOM mutation observer</a>, and in older versions of Internet Explorer, it will use a <code>&lt;script&gt; onreadystatechange</code> event. These methods allow it to start processing the queue before any reflow or redrawing. In other browsers, it will revert to using <code>setTimeout</code>.</p> <h3 id=\"advanced-queue-control\">Advanced queue control</h3> <p>Knockout provides some advanced methods to control when the microtask queue is processed. These are useful if you want to integrate Knockout’s microtask system with another library or add support for additional environments.</p> <ul> <li> <p><code>ko.tasks.runEarly()</code> — Call this method to process the current microtask queue on demand, immediately, until it is empty. Besides library integration, you might use this method if you have code that schedules a number of tasks, but then needs to deal with the effects of those tasks synchronously. </p> </li> <li> <p><code>ko.tasks.scheduler</code> — Override this method to redefine or augment how Knockout schedules the event to process and flush the queue. Knockout calls this method when the first task is scheduled, so it must schedule the event and return immediately. For example, if your application is running in Node.js, you might prefer to use <code>process.nextTick</code> for the flush event: <code>ko.tasks.scheduler = process.nextTick;</code>.</p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/microtasks.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/microtasks.html</a>\n  </p>\n</div>\n","plugins-mapping":"<h1>Mapping</h1> <p>Knockout is designed to allow you to use arbitrary JavaScript objects as view models. As long as some of your view model’s properties are <a href=\"observables\">observables</a>, you can use KO to bind to them to your UI, and the UI will be updated automatically whenever the observable properties change. </p> <p>Most applications need to fetch data from a backend server. Since the server doesn’t have any concept of observables, it will just supply a plain JavaScript object (usually serialized as JSON). The mapping plugin gives you a straightforward way to map that plain JavaScript object into a view model with the appropriate observables. This is an alternative to manually writing your own JavaScript code that constructs a view model based on some data you’ve fetched from the server.</p> <h3 id=\"download\">Download</h3> <ul> <li>\n<strong><a href=\"https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output\">Version 2.0</a></strong> (8.6kb minified)</li> </ul> <h3 id=\"example-manual-mapping-without-the-komapping-plugin\">Example: Manual mapping without the ko.mapping plugin</h3> <p>You want to display the current server-time and the number of users on your web page. You could represent this information using the following view model:</p> <pre>var viewModel = {\n\tserverTime: ko.observable(),\n\tnumUsers: ko.observable()\n}\n</pre> <p>You could bind this view model to some HTML elements as follows:</p> <pre>The time on the server is: &lt;span data-bind='text: serverTime'&gt;&lt;/span&gt;\nand &lt;span data-bind='text: numUsers'&gt;&lt;/span&gt; user(s) are connected.\n</pre> <p>Since the view model properties are observable, KO will automatically update the HTML elements whenever those properties change.</p> <p>Next, you want to fetch the latest data from the server. Every 5 seconds you might issue an Ajax request (e.g., using jQuery’s <code>$.getJSON</code> or <code>$.ajax</code> functions):</p> <pre>var data = getDataUsingAjax();\t\t\t// Gets the data from the server\n</pre> <p>The server might return JSON data similar to the following:</p> <pre>{\n\tserverTime: '2010-01-07',\n\tnumUsers: 3\n}\n</pre> <p>Finally, to update your view model using this data (without using the mapping plugin), you would write:</p> <pre>// Every time data is received from the server:\nviewModel.serverTime(data.serverTime);\nviewModel.numUsers(data.numUsers);\n</pre> <p>You would have to do this for every variable you want to display on your page. If your data structures become more complex (e.g. they contain children or contain arrays) this becomes very cumbersome to handle manually. What the mapping plugin allows you to do is create a mapping from the regular JavaScript object (or JSON structure) to an observable view model.</p> <h3 id=\"example-using-komapping\">Example: Using ko.mapping</h3> <p>To create a view model via the mapping plugin, replace the creation of <code>viewModel</code> in the code above with the <code>ko.mapping.fromJS</code> function:</p> <pre>var viewModel = ko.mapping.fromJS(data);\n</pre> <p>This automatically creates observable properties for each of the properties on <code>data</code>. Then, every time you receive new data from the server, you can update all the properties on <code>viewModel</code> in one step by calling the <code>ko.mapping.fromJS</code> function again:</p> <pre>// Every time data is received from the server:\nko.mapping.fromJS(data, viewModel);\n</pre> <h3 id=\"how-things-are-mapped\">How things are mapped</h3> <ul> <li>All properties of an object are converted into an observable. If an update would change the value, it will update the observable.</li> <li>Arrays are converted into <a href=\"observablearrays\">observable arrays</a>. If an update would change the number of items, it will perform the appropriate add/remove actions. It will also try to keep the order the same as the original JavaScript array.</li> </ul> <h3 id=\"unmapping\">Unmapping</h3> <p>If you want to convert your mapped object back to a regular JS object, use:</p> <pre>var unmapped = ko.mapping.toJS(viewModel);\n</pre> <p>This will create an unmapped object containing only the properties of the mapped object that were part of your original JS object. So in other words, any properties or functions that you manually added to your view model are ignored. By default, the only exception to this rule is the <code>_destroy</code> property which will also be mapped back, because it is a property that Knockout may generate when you destroy an item from an <code>ko.observableArray</code>. See the “Advanced Usage” section for more details on how to configure this.</p> <h3 id=\"working-with-json-strings\">Working with JSON strings</h3> <p>If your Ajax call returns a JSON string (and does not deserialize it into a JavaScript object), then you can use the function <code>ko.mapping.fromJSON</code> to create and update your view model instead. To unmap, you can use <code>ko.mapping.toJSON</code>.</p> <p>Apart from the fact that they work with JSON strings instead of JS objects these functions are completely identical to their <code>*JS</code> counterparts.</p> <h3 id=\"advanced-usage\">Advanced usage</h3> <p>Sometimes it may be necessary to have more control over how the mapping is performed. This is accomplished using <em>mapping options</em>. They can be specified during the <code>ko.mapping.fromJS</code> call. In subsequent calls you don’t need to specify them again.</p> <p>Here a few situations in which you might want to use these mapping options.</p> <h6 id=\"uniquely-identifying-objects-using-keys\">Uniquely identifying objects using “keys”</h6> <p>Let’s say you have a JavaScript object that looks like this:</p> <pre>var data = {\n\tname: 'Scot',\n\tchildren: [\n\t\t{ id : 1, name : 'Alicw' }\n\t]\n}\n</pre> <p>You can map this to a view model without any problems:</p> <pre>var viewModel = ko.mapping.fromJS(data);\n</pre> <p>Now, let’s say the data is updated to be without any typos:</p> <pre>var data = {\n\tname: 'Scott',\n\tchildren: [\n\t\t{ id : 1, name : 'Alice' }\n\t]\n}\n</pre> <p>Two things have happened here: <code>name</code> was changed from <code>Scot</code> to <code>Scott</code> and <code>children[0].name</code> was changed from <code>Alicw</code> to the typo-free <code>Alice</code>. You can update <code>viewModel</code> based on this new data:</p> <pre>ko.mapping.fromJS(data, viewModel);\n</pre> <p>And <code>name</code> would have changed as expected. However, in the <code>children</code> array, the child (Alicw) would have been completely removed and a new one (Alice) added. This is not completely what you would have expected. Instead, you would have expected that only the <code>name</code> property of the child was updated from <code>Alicw</code> to <code>Alice</code>, not that the entire child was replaced!</p> <p>This happens because, by default, the mapping plugin simply compares the two objects in the array. And since in JavaScript the object <code>{ id : 1, name : 'Alicw' }</code> does not equal <code>{ id : 1, name : 'Alice' }</code> it thinks that the <em>entire</em> child needs to be removed and replaced by a new one.</p> <p>To solve this, you can specify which <code>key</code> the mapping plugin should use to determine if an object is new or old. You would set it up like this:</p> <pre>var mapping = {\n\t'children': {\n\t\tkey: function(data) {\n\t\t\treturn ko.utils.unwrapObservable(data.id);\n\t\t}\n\t}\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\n</pre> <p>This way, every time the mapping plugin checks an item in the <code>children</code> array, it will only look at the <code>id</code> property to determine if an object was completely replaced or merely needs updating.</p> <h6 id=\"customizing-object-construction-using-create\">Customizing object construction using “create”</h6> <p>If you want to handle a part of the mapping yourself, you can also provide a <code>create</code> callback. If this callback is present, the mapping plugin will allow you to do this part of the mapping yourself.</p> <p>Let’s say you have a JavaScript object that looks like this:</p> <pre>var data = {\n\tname: 'Graham',\n\tchildren: [\n\t\t{ id : 1, name : 'Lisa' }\n\t]\n}\n</pre> <p>If you want to map the <code>children</code> array yourself, you can specify that like this:</p> <pre>var mapping = {\n\t'children': {\n\t\tcreate: function(options) {\n\t\t\treturn new myChildModel(options.data);\n\t\t}\n\t}\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\n</pre> <p>The <code>options</code> argument supplied to your <code>create</code> callback is a JavaScript object containing:</p> <ul> <li>\n<code>data</code>: The JavaScript object containing the data for this child</li> <li>\n<code>parent</code>: The parent object or array to which this child belongs</li> </ul> <p>Of course, inside the <code>create</code> callback you can do another call to <code>ko.mapping.fromJS</code> if you wish. A typical use-case might be if you want to augment the original JavaScript object with some additional <a href=\"computedobservables\">computed observables</a>:</p> <pre>var myChildModel = function(data) {\n\tko.mapping.fromJS(data, {}, this);\n\t\n\tthis.nameLength = ko.computed(function() {\n\t\treturn this.name().length;\n\t}, this);\n}\n</pre> <h6 id=\"customizing-object-updating-using-update\">Customizing object updating using “update”</h6> <p>You can also customize how an object is updated by specifying an <code>update</code> callback. It will receive the object it is trying to update and an <code>options</code> object which is identical to the one used by the <code>create</code> callback. You should <code>return</code> the updated value.</p> <p>The <code>options</code> argument supplied to your <code>update</code> callback is a JavaScript object containing: * <code>data</code>: The JavaScript object containing the data for this child * <code>parent</code>: The parent object or array to which this child belongs * <code>observable</code>: If the property is an observable, this will be set to the actual observable</p> <p>Here is an example of a configuration that will add some text to the incoming data before updating:</p> <pre>var data = {\n\tname: 'Graham',\n}\n\nvar mapping = {\n\t'name': {\n\t\tupdate: function(options) {\n\t\t\treturn options.data + 'foo!';\n\t\t}\n\t}\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\nalert(viewModel.name());\n</pre> <p>This will alert <code>Grahamfoo!</code>.</p> <h6 id=\"ignoring-certain-properties-using-ignore\">Ignoring certain properties using “ignore”</h6> <p>If you want the mapping plugin to ignore some properties of your JS object (i.e. to not map them), you can specify an array of propertynames to ignore:</p> <pre>var mapping = {\n\t'ignore': [\"propertyToIgnore\", \"alsoIgnoreThis\"]\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\n</pre> <p>The <code>ignore</code> array you specify in the mapping options is combined with the default <code>ignore</code> array. You can manipulate this default array like this:</p> <pre>var oldOptions = ko.mapping.defaultOptions().ignore;\nko.mapping.defaultOptions().ignore = [\"alwaysIgnoreThis\"];\n</pre> <h6 id=\"including-certain-properties-using-include\">Including certain properties using “include”</h6> <p>When converting your view model back to a JS object, by default the mapping plugin will only include properties that were part of your original view model, except it will also include the Knockout-generated <code>_destroy</code> property even if it was not part of your original object. However, you can choose to customize this array:</p> <pre>var mapping = {\n\t'include': [\"propertyToInclude\", \"alsoIncludeThis\"]\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\n</pre> <p>The <code>include</code> array you specify in the mapping options is combined with the default <code>include</code> array, which by default only contains <code>_destroy</code>. You can manipulate this default array like this:</p> <pre>var oldOptions = ko.mapping.defaultOptions().include;\nko.mapping.defaultOptions().include = [\"alwaysIncludeThis\"];\n</pre> <h6 id=\"copying-certain-properties-using-copy\">Copying certain properties using “copy”</h6> <p>When converting your view model back to a JS object, by default the mapping plugin will create observables based on the rules explained <a href=\"#how-things-are-mapped\">above</a>. If you want to force the mapping plugin to simply copy the property instead of making it observable, add its name to the “copy” array:</p> <pre>var mapping = {\n\t'copy': [\"propertyToCopy\"]\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\n</pre> <p>The <code>copy</code> array you specify in the mapping options is combined with the default <code>copy</code> array, which by default is empty. You can manipulate this default array like this:</p> <pre>var oldOptions = ko.mapping.defaultOptions().copy;\nko.mapping.defaultOptions().copy = [\"alwaysCopyThis\"];\n</pre> <h6 id=\"observing-only-certain-properties-using-observe\">Observing only certain properties using “observe”</h6> <p>If you want the mapping plugin to only create observables of some properties of your JS object and copy the rest, you can specify an array of propertynames to observe:</p> <pre>var mapping = {\n\t'observe': [\"propertyToObserve\"]\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\n</pre> <p>The <code>observe</code> array you specify in the mapping options is combined with the default <code>observe</code> array, which by default is empty. You can manipulate this default array like this:</p> <pre>var oldOptions = ko.mapping.defaultOptions().observe;\nko.mapping.defaultOptions().observe = [\"onlyObserveThis\"];\n</pre> <p>The arrays <code>ignore</code> and <code>include</code> still work as normal. The array <code>copy</code> can be used for efficiency to copy array or object properties including children. If an array or object property is not specified in <code>copy</code> or <code>observe</code> then it is recursively mapped:</p> <pre>var data = {\n\ta: \"a\",\n\tb: [{ b1: \"v1\" }, { b2: \"v2\" }] \n};\n\nvar result = ko.mapping.fromJS(data, { observe: \"a\" });\nvar result2 = ko.mapping.fromJS(data, { observe: \"a\", copy: \"b\" }); //will be faster to map.\n</pre> <p>Both <code>result</code> and <code>result2</code> will be:</p> <pre>{\n\ta: observable(\"a\"),\n\tb: [{ b1: \"v1\" }, { b2: \"v2\" }] \n}\n</pre> <p>Drilling down into arrays/objects works but copy and observe can conflict:</p> <pre>var data = {\n\ta: \"a\",\n\tb: [{ b1: \"v1\" }, { b2: \"v2\" }] \n};\nvar result = ko.mapping.fromJS(data, { observe: \"b[0].b1\"});\nvar result2 = ko.mapping.fromJS(data, { observe: \"b[0].b1\", copy: \"b\" });\n</pre> <p>The <code>result</code> will be:</p> <pre>{\n\ta: \"a\",\n\tb: [{ b1: observable(\"v1\") }, { b2: \"v2\" }] \n}\n</pre> <p>While <code>result2</code> will be:</p> <pre>{\n\ta: \"a\",\n\tb: [{ b1: \"v1\" }, { b2: \"v2\" }] \n}\n</pre> <h6 id=\"specifying-the-update-target\">Specifying the update target</h6> <p>If, like in the example above, you are performing the mapping inside of a class, you would like to have <code>this</code> as the target of your mapping operation. The third parameter to <code>ko.mapping.fromJS</code> indicates the target. For example,</p> <pre>ko.mapping.fromJS(data, {}, someObject); // overwrites properties on someObject\n</pre> <p>So, if you would like to map a JavaScript object to <code>this</code>, you can pass <code>this</code> as the third argument:</p> <pre>ko.mapping.fromJS(data, {}, this);\n</pre> <h5 id=\"mapping-from-multiple-sources\">Mapping from multiple sources</h5> <p>You can combine multiple JS objects in one viewmodel by applying multiple <code>ko.mapping.fromJS</code> calls, e.g.:</p> <pre>var viewModel = ko.mapping.fromJS(alice, aliceMappingOptions);\nko.mapping.fromJS(bob, bobMappingOptions, viewModel);\n</pre> <p>Mapping options that you specify in each call will be merged.</p> <h5 id=\"mapped-observable-array\">Mapped observable array</h5> <p>Observable arrays that are generated by the mapping plugin are augmented with a few functions that can make use of the <code>keys</code> mapping:</p> <ul> <li>mappedRemove</li> <li>mappedRemoveAll</li> <li>mappedDestroy</li> <li>mappedDestroyAll</li> <li>mappedIndexOf</li> </ul> <p>They are functionally equivalent to the regular <code>ko.observableArray</code> functions, but can do things based on the key of the object. For example, this would work:</p> <pre>var obj = [\n    { id : 1 },\n    { id : 2 }\n]\n\nvar result = ko.mapping.fromJS(obj, {\n    key: function(item) {\n        return ko.utils.unwrapObservable(item.id);\n    }\n});\n\nresult.mappedRemove({ id : 2 });\n</pre> <p>The mapped observable array also exposes a <code>mappedCreate</code> function:</p> <pre>var newItem = result.mappedCreate({ id : 3 });\n</pre> <p>It will first check if the key is already present and will throw an exception if it is. Next, it will invoke the create and update callbacks, if any, to create the new object. Finally, it will add this object to the array and return it.</p> <h3 id=\"download-1\">Download</h3> <ul> <li>\n<strong><a href=\"https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output\">Version 2.0</a></strong> (8.6kb minified)</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/plugins-mapping.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/plugins-mapping.html</a>\n  </p>\n</div>\n","amd-loading":"<h1>Asynchronous Module Definition (AMD) With RequireJs</h1> <h3 id=\"overview-of-amd\">Overview of AMD</h3> <p>Excerpt From <a href=\"http://addyosmani.com/writing-modular-js/\">Writing Modular JavaScript With AMD, CommonJs &amp; ES Harmony</a>:</p> <blockquote> <p>When we say an application is modular, we generally mean it’s composed of a set of highly decoupled, distinct pieces of functionality stored in modules. As you probably know, loose coupling facilitates easier maintainability of apps by removing dependencies where possible. When this is implemented efficiently, its quite easy to see how changes to one part of a system may affect another.</p> <p>Unlike some more traditional programming languages however, the current iteration of JavaScript (ECMA-262) doesn’t provide developers with the means to import such modules of code in a clean, organized manner. It’s one of the concerns with specifications that haven’t required great thought until more recent years where the need for more organized JavaScript applications became apparent.</p> <p>Instead, developers at present are left to fall back on variations of the module or object literal patterns. With many of these, module scripts are strung together in the DOM with namespaces being described by a single global object where it’s still possible to incur naming collisions in your architecture. There’s also no clean way to handle dependency management without some manual effort or third party tools.</p> <p>Whilst native solutions to these problems will be arriving in ES Harmony, the good news is that writing modular JavaScript has never been easier and you can start doing it today.</p> </blockquote> <h3 id=\"loading-knockoutjs-and-a-viewmodel-class-via-requirejs\">Loading Knockout.js and a ViewModel class via RequireJs</h3> <p>HTML</p> <pre>&lt;html&gt;\n    &lt;head&gt;\n        &lt;script type=\"text/javascript\" data-main=\"scripts/init.js\" src=\"scripts/require.js\"&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;p&gt;First name: &lt;input data-bind=\"value: firstName\" /&gt;&lt;/p&gt;\n        &lt;p&gt;First name capitalized: &lt;strong data-bind=\"text: firstNameCaps\"&gt;&lt;/strong&gt;&lt;/p&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</pre> <p>scripts/init.js</p> <pre>require(['knockout-x.y.z', 'appViewModel', 'domReady!'], function(ko, appViewModel) {\n    ko.applyBindings(new appViewModel());\n});\n</pre> <p>scripts/appViewModel.js</p> <pre>// Main viewmodel class\ndefine(['knockout-x.y.z'], function(ko) {\n    return function appViewModel() {\n        this.firstName = ko.observable('Bert');\n        this.firstNameCaps = ko.pureComputed(function() {\n            return this.firstName().toUpperCase();\n        }, this);\n    };\n});\n</pre> <p>Of course, <code>x.y.z</code> should be replaced with the version number of the Knockout script you are loading (e.g., <code>knockout-3.1.0</code>).</p> <h3 id=\"loading-knockoutjs-a-binding-handler-and-a-viewmodel-class-via-requirejs\">Loading Knockout.js, a Binding Handler, and a ViewModel class via RequireJs</h3> <p>Documentation on Binding Handlers in general can be found <a href=\"custom-bindings\">here</a>. This section is meant to demonstrate the power that AMD modules provide in maintaining your custom handlers. We will take the example of the <code>ko.bindingHandlers.hasFocus</code> example from the binding handlers documentation. By wrapping that handler in it’s own module you can restrict it’s use only to the pages that need it. The wrapped module becomes:</p> <pre>define(['knockout-x.y.z'], function(ko){\n    ko.bindingHandlers.hasFocus = {\n        init: function(element, valueAccessor) { ... },\n        update: function(element, valueAccessor) { ... }\n    }\n});\n</pre> <p>After you have defined the module update the input element from the HTML example above to be:</p> <pre>&lt;p&gt;First name: &lt;input data-bind=\"value: firstName, hasFocus: editingName\" /&gt;&lt;span data-bind=\"visible: editingName\"&gt; You're editing the name!&lt;/span&gt;&lt;/p&gt;\n</pre> <p>Include the module in the list of dependencies for your view model:</p> <pre>define(['knockout-x.y.z', 'customBindingHandlers/hasFocus'], function(ko) {\n    return function appViewModel(){\n        ...\n        // Add an editingName observable\n        this.editingName = ko.observable();\n    };\n});\n</pre> <p>Note that the custom binding handler module does not inject anything into our ViewModel module, that is because it does not return anything. It just appends additional behavior to the knockout module.</p> <h3 id=\"requirejs-download\">RequireJs Download</h3> <p>RequireJs can be downloaded from <a href=\"http://requirejs.org/docs/download.html\">http://requirejs.org/docs/download.html</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"http://knockoutjs.com/documentation/amd-loading.html\" class=\"_attribution-link\">http://knockoutjs.com/documentation/amd-loading.html</a>\n  </p>\n</div>\n"}