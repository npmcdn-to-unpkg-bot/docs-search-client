{"index":"<h1>Relay Documentation</h1>\n<p>To get started building Relay applications, you will need three things:</p>\n<ol>\n<li>\n<p><strong>A GraphQL Schema</strong></p>\n<p>A description of your data model with an associated set of resolve methods that know how to fetch any data your application could ever need.</p>\n<p>GraphQL is designed to support a wide range of data access patterns. In order to understand the structure of an application's data, Relay requires that you follow certain conventions when defining your schema. These are documented in the <a href=\"graphql-relay-specification#content\">GraphQL Relay Specification</a>.</p>\n<ul>\n<li>\n<p><strong><a href=\"https://github.com/graphql/graphql-js\">graphql-js</a></strong> on <a href=\"https://www.npmjs.com/package/graphql\">npm</a></p>\n<p>General-purpose tools for building a GraphQL schema using JavaScript</p>\n</li>\n<li>\n<p><strong><a href=\"https://github.com/graphql/graphql-relay-js\">graphql-relay-js</a></strong> on <a href=\"https://www.npmjs.com/package/graphql-relay\">npm</a></p>\n<p>JavaScript helpers for defining connections between data, and mutations, in a way that smoothly integrates with Relay.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>A GraphQL Server</strong></p>\n<p>Any server can be taught to load a schema and speak GraphQL. Our <a href=\"https://github.com/relayjs/relay-examples\">examples</a> use Express.</p>\n<ul><li>\n<strong><a href=\"https://github.com/graphql/express-graphql\">express-graphql</a></strong> on <a href=\"https://www.npmjs.com/package/express-graphql\">npm</a>\n</li></ul>\n</li>\n<li>\n<p><strong>Relay</strong></p>\n<p>Relay speaks to GraphQL servers through a network layer. The <a href=\"https://github.com/facebook/relay/tree/master/src/network-layer/default\">network layer</a> that ships with Relay is compatible with express-graphql out of the box, and will continue to evolve as we add new features to the transport.</p>\n</li>\n</ol>\n<p>The best way to get started right now is to take a look at how these three parts come together to form a working example. The tutorial on the next page will lead you through an example application, using the <a href=\"https://github.com/facebook/relay-starter-kit\">Relay Starter Kit</a>, to give you an idea of how you can start using Relay on yours.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/getting-started.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/getting-started.html</a>\n  </p>\n</div>\n","tutorial":"<h1>Tutorial</h1>\n<p>In this tutorial, we will build a game using GraphQL mutations. The goal of the game is to find a hidden treasure in a grid of 9 squares. We will give players three tries to find the treasure. This should give us an end-to-end look at Relay â€“ from the GraphQL schema on the server, to the React application on the client.</p>\n<h2 id=\"warm-up\">\nWarm up </h2>\n<p>Let's start a project using the <a href=\"https://github.com/relayjs/relay-starter-kit\">Relay Starter Kit</a> as a base.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngit clone https://github.com/relayjs/relay-starter-kit.git relay-treasurehunt\ncd relay-treasurehunt\nnpm install</pre>\n<h2 id=\"a-simple-database\">\nA simple database </h2>\n<p>We need a place to hide our treasure, a way to check hiding spots for treasure, and a way to track our turns remaining. For the purposes of this tutorial, we'll hide these data in memory.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n/**\n * ./data/database.js\n */\n\n// Model types\nexport class Game {}\nexport class HidingSpot {}\n\n// Mock data\nvar game = new Game();\ngame.id = '1';\n\nvar hidingSpots = [];\n(function() {\n  var hidingSpot;\n  var indexOfSpotWithTreasure = Math.floor(Math.random() * 9);\n  for (var i = 0; i &lt; 9; i++) {\n    hidingSpot = new HidingSpot();\n    hidingSpot.id = `${i}`;\n    hidingSpot.hasTreasure = (i === indexOfSpotWithTreasure);\n    hidingSpot.hasBeenChecked = false;\n    hidingSpots.push(hidingSpot);\n  }\n})();\n\nvar turnsRemaining = 3;\n\nexport function checkHidingSpotForTreasure(id) {\n  if (hidingSpots.some(hs =&gt; hs.hasTreasure &amp;&amp; hs.hasBeenChecked)) {\n    return;\n  }\n  turnsRemaining--;\n  var hidingSpot = getHidingSpot(id);\n  hidingSpot.hasBeenChecked = true;\n}\nexport function getHidingSpot(id) {\n  return hidingSpots.find(hs =&gt; hs.id === id);\n}\nexport function getGame() { return game; }\nexport function getHidingSpots() { return hidingSpots; }\nexport function getTurnsRemaining() { return turnsRemaining; }</pre>\n<p>What we have written here is a mock database interface. We can imagine hooking this up to a real database, but for now let's move on.</p>\n<h2 id=\"authoring-a-schema\">\nAuthoring a schema </h2>\n<p>A GraphQL schema describes your data model, and provides a GraphQL server with an associated set of resolve methods that know how to fetch data. We will use <a href=\"https://github.com/graphql/graphql-js\">graphql-js</a> and <a href=\"https://github.com/graphql/graphql-relay-js\">graphql-relay-js</a> to build our schema.</p>\n<p>Let's open up the starter kit's schema, and replace the database imports with the ones we just created:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n/**\n * ./data/schema.js\n */\n\n/* ... */\n\nimport {\n  Game,\n  HidingSpot,\n  checkHidingSpotForTreasure,\n  getGame,\n  getHidingSpot,\n  getHidingSpots,\n  getTurnsRemaining,\n} from './database';</pre>\n<p>At this point, you can delete everything up until <code>queryType</code> in <code>./data/schema.js</code>.</p>\n<p>Next, let's define a node interface and type. We need only provide a way for Relay to map from an object to the GraphQL type associated with that object, and from a global ID to the object it points to:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar {nodeInterface, nodeField} = nodeDefinitions(\n  (globalId) =&gt; {\n    var {type, id} = fromGlobalId(globalId);\n    if (type === 'Game') {\n      return getGame(id);\n    } else if (type === 'HidingSpot') {\n      return getHidingSpot(id);\n    } else {\n      return null;\n    }\n  },\n  (obj) =&gt; {\n    if (obj instanceof Game) {\n      return gameType;\n    } else if (obj instanceof HidingSpot)  {\n      return hidingSpotType;\n    } else {\n      return null;\n    }\n  }\n);</pre>\n<p>Next, let's define our game and hiding spot types, and the fields that are available on each.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar gameType = new GraphQLObjectType({\n  name: 'Game',\n  description: 'A treasure search game',\n  fields: () =&gt; ({\n    id: globalIdField('Game'),\n    hidingSpots: {\n      type: hidingSpotConnection,\n      description: 'Places where treasure might be hidden',\n      args: connectionArgs,\n      resolve: (game, args) =&gt; connectionFromArray(getHidingSpots(), args),\n    },\n    turnsRemaining: {\n      type: GraphQLInt,\n      description: 'The number of turns a player has left to find the treasure',\n      resolve: () =&gt; getTurnsRemaining(),\n    },\n  }),\n  interfaces: [nodeInterface],\n});\n\nvar hidingSpotType = new GraphQLObjectType({\n  name: 'HidingSpot',\n  description: 'A place where you might find treasure',\n  fields: () =&gt; ({\n    id: globalIdField('HidingSpot'),\n    hasBeenChecked: {\n      type: GraphQLBoolean,\n      description: 'True if this spot has already been checked for treasure',\n      resolve: (hidingSpot) =&gt; hidingSpot.hasBeenChecked,\n    },\n    hasTreasure: {\n      type: GraphQLBoolean,\n      description: 'True if this hiding spot holds treasure',\n      resolve: (hidingSpot) =&gt; {\n        if (hidingSpot.hasBeenChecked) {\n          return hidingSpot.hasTreasure;\n        } else {\n          return null;  // Shh... it's a secret!\n        }\n      },\n    },\n  }),\n  interfaces: [nodeInterface],\n});</pre>\n<p>Since one game can have many hiding spots, we need to create a connection that we can use to link them together.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar {connectionType: hidingSpotConnection} =\n  connectionDefinitions({name: 'HidingSpot', nodeType: hidingSpotType});</pre>\n<p>Now let's associate these types with the root query type.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar queryType = new GraphQLObjectType({\n  name: 'Query',\n  fields: () =&gt; ({\n    node: nodeField,\n    game: {\n      type: gameType,\n      resolve: () =&gt; getGame(),\n    },\n  }),\n});</pre>\n<p>With the queries out of the way, let's start in on our only mutation: the one that spends a turn by checking a spot for treasure. Here, we define the input to the mutation (the id of a spot to check for treasure) and a list of all of the possible fields that the client might want updates about after the mutation has taken place. Finally, we implement a method that performs the underlying mutation.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar CheckHidingSpotForTreasureMutation = mutationWithClientMutationId({\n  name: 'CheckHidingSpotForTreasure',\n  inputFields: {\n    id: { type: new GraphQLNonNull(GraphQLID) },\n  },\n  outputFields: {\n    hidingSpot: {\n      type: hidingSpotType,\n      resolve: ({localHidingSpotId}) =&gt; getHidingSpot(localHidingSpotId),\n    },\n    game: {\n      type: gameType,\n      resolve: () =&gt; getGame(),\n    },\n  },\n  mutateAndGetPayload: ({id}) =&gt; {\n    var localHidingSpotId = fromGlobalId(id).id;\n    checkHidingSpotForTreasure(localHidingSpotId);\n    return {localHidingSpotId};\n  },\n});</pre>\n<p>Let's associate the mutation we just created with the root mutation type:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar mutationType = new GraphQLObjectType({\n  name: 'Mutation',\n  fields: () =&gt; ({\n    checkHidingSpotForTreasure: CheckHidingSpotForTreasureMutation,\n  }),\n});</pre>\n<p>Finally, we construct our schema (whose starting query type is the query type we defined above) and export it.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nexport var Schema = new GraphQLSchema({\n  query: queryType,\n  mutation: mutationType\n});</pre>\n<h2 id=\"processing-the-schema\">\nProcessing the schema </h2>\n<p>Before going any further, we need to serialize our executable schema to JSON for use by the Relay.QL transpiler, then start up the server. From the command line:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nnpm run update-schema\nnpm start</pre>\n<h2 id=\"writing-the-game\">\nWriting the game </h2>\n<p>Let's tweak the file <code>./js/routes/AppHomeRoute.js</code> to anchor our game to the <code>game</code> root field of the schema:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nexport default class extends Relay.Route {\n  static path = '/';\n  static queries = {\n    game: () =&gt; Relay.QL`query { game }`,\n  };\n  static routeName = 'AppHomeRoute';\n}</pre>\n<p>Next, let's create a file in <code>./js/mutations/CheckHidingSpotForTreasureMutation.js</code> and create subclass of <code>Relay.Mutation</code> called <code>CheckHidingSpotForTreasureMutation</code> to hold our mutation implementation:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nimport Relay from 'react-relay';\n\nexport default class CheckHidingSpotForTreasureMutation extends Relay.Mutation {\n  static fragments = {\n    game: () =&gt; Relay.QL`\n      fragment on Game {\n        id,\n        turnsRemaining,\n      }\n    `,\n    hidingSpot: () =&gt; Relay.QL`\n      fragment on HidingSpot {\n        id,\n      }\n    `,\n  };\n  getMutation() {\n    return Relay.QL`mutation{checkHidingSpotForTreasure}`;\n  }\n  getCollisionKey() {\n    return `check_${this.props.game.id}`;\n  }\n  getFatQuery() {\n    return Relay.QL`\n      fragment on CheckHidingSpotForTreasurePayload {\n        hidingSpot {\n          hasBeenChecked,\n          hasTreasure,\n        },\n        game {\n          turnsRemaining,\n        },\n      }\n    `;\n  }\n  getConfigs() {\n    return [{\n      type: 'FIELDS_CHANGE',\n      fieldIDs: {\n        hidingSpot: this.props.hidingSpot.id,\n        game: this.props.game.id,\n      },\n    }];\n  }\n  getVariables() {\n    return {\n      id: this.props.hidingSpot.id,\n    };\n  }\n  getOptimisticResponse() {\n    return {\n      game: {\n        turnsRemaining: this.props.game.turnsRemaining - 1,\n      },\n      hidingSpot: {\n        id: this.props.hidingSpot.id,\n        hasBeenChecked: true,\n      },\n    };\n  }\n}</pre>\n<p>Finally, let's tie it all together in <code>./js/components/App.js</code>:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nimport CheckHidingSpotForTreasureMutation from '../mutations/CheckHidingSpotForTreasureMutation';\n\nclass App extends React.Component {\n  _getHidingSpotStyle(hidingSpot) {\n    var color;\n    if (this.props.relay.hasOptimisticUpdate(hidingSpot)) {\n      color = 'lightGrey';\n    } else if (hidingSpot.hasBeenChecked) {\n      if (hidingSpot.hasTreasure) {\n        color = 'blue';\n      } else {\n        color = 'red';\n      }\n    } else {\n      color = 'black';\n    }\n    return {\n      backgroundColor: color,\n      cursor: this._isGameOver() ? null : 'pointer',\n      display: 'inline-block',\n      height: 100,\n      marginRight: 10,\n      width: 100,\n    };\n  }\n  _handleHidingSpotClick(hidingSpot) {\n    if (this._isGameOver()) {\n      return;\n    }\n    this.props.relay.commitUpdate(\n      new CheckHidingSpotForTreasureMutation({\n        game: this.props.game,\n        hidingSpot,\n      })\n    );\n  }\n  _hasFoundTreasure() {\n    return (\n      this.props.game.hidingSpots.edges.some(edge =&gt; edge.node.hasTreasure)\n    );\n  }\n  _isGameOver() {\n    return !this.props.game.turnsRemaining || this._hasFoundTreasure();\n  }\n  renderGameBoard() {\n    return this.props.game.hidingSpots.edges.map(edge =&gt; {\n      return (\n        &lt;div\n          key={edge.node.id}\n          onClick={this._handleHidingSpotClick.bind(this, edge.node)}\n          style={this._getHidingSpotStyle(edge.node)}\n        /&gt;\n      );\n    });\n  }\n  render() {\n    var headerText;\n    if (this.props.relay.getPendingTransactions(this.props.game)) {\n      headerText = '\\u2026';\n    } else if (this._hasFoundTreasure()) {\n      headerText = 'You win!';\n    } else if (this._isGameOver()) {\n      headerText = 'Game over!';\n    } else {\n      headerText = 'Find the treasure!';\n    }\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;{headerText}&lt;/h1&gt;\n        {this.renderGameBoard()}\n        &lt;p&gt;Turns remaining: {this.props.game.turnsRemaining}&lt;/p&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default Relay.createContainer(App, {\n  fragments: {\n    game: () =&gt; Relay.QL`\n      fragment on Game {\n        turnsRemaining,\n        hidingSpots(first: 9) {\n          edges {\n            node {\n              hasBeenChecked,\n              hasTreasure,\n              id,\n              ${CheckHidingSpotForTreasureMutation.getFragment('hidingSpot')},\n            }\n          }\n        },\n        ${CheckHidingSpotForTreasureMutation.getFragment('game')},\n      }\n    `,\n  },\n});</pre>\n<p>A working copy of the treasure hunt can be found in the <a href=\"https://github.com/relayjs/relay-examples\">relay-examples</a> repository.</p>\n<p>Now that we've gone through this tutorial, let's dive into what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/tutorial.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/tutorial.html</a>\n  </p>\n</div>\n","graphql-relay-specification":"<h1>GraphQL Relay Specification</h1>\n<h1 id=\"getting-started\">\nGetting Started </h1>\n<p>The three core assumptions that Relay makes about a GraphQL server are that it provides:</p>\n<ol>\n<li>A mechanism for refetching an object.</li>\n<li>A description of how to page through connections.</li>\n<li>Structure around mutations to make them predictable.</li>\n</ol>\n<p>This example demonstrates all three of these assumptions.</p>\n<p>This example is not comprehensive, but it is designed to quickly introduce these core assumptions, to provide some context before diving into the more detailed specification or the library.</p>\n<p>The premise of the example is that we want to use GraphQL to query for information about ships and factions in the original Star Wars trilogy.</p>\n<p>It is assumed that the reader is already familiar with GraphQL; if not, the README for <a href=\"https://github.com/graphql/graphql-js\">GraphQL.js</a> is a good place to start.</p>\n<p>It is also assumed that the reader is already familiar with Star Wars; if not, the 1977 version of Star Wars is a good place to start, though the 1997 Special Edition will serve for the purposes of this document.</p>\n<h2 id=\"schema\">\nSchema </h2>\n<p>The schema described below will be used to demonstrate the functionality that a GraphQL server used by Relay should implement. The two core types are a faction and a ship in the Star Wars universe, where a faction has many ships associated with it. The schema below is the output of the GraphQL.js <a href=\"https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js\"><code>schemaPrinter</code></a>.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ninterface Node {\n  id: ID!\n}\n\ntype Faction : Node {\n  id: ID!\n  name: String\n  ships: ShipConnection\n}\n\ntype Ship : Node {\n  id: ID!\n  name: String\n}\n\ntype ShipConnection {\n  edges: [ShipEdge]\n  pageInfo: PageInfo!\n}\n\ntype ShipEdge {\n  cursor: String!\n  node: Ship\n}\n\ntype PageInfo {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n  endCursor: String\n}\n\ntype Query {\n  rebels: Faction\n  empire: Faction\n  node(id: ID!): Node\n}\n\ninput IntroduceShipInput {\n  factionId: String!\n  shipNamed: String!\n  clientMutationId: String!\n}\n\ntype IntroduceShipPayload {\n  faction: Faction\n  ship: Ship\n  clientMutationId: String!\n}\n\ntype Mutation {\n  introduceShip(input: IntroduceShipInput!): IntroduceShipPayload\n}</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/graphql-relay-specification.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/graphql-relay-specification.html</a>\n  </p>\n</div>\n","guides-routes":"<h1>Routes</h1>\n<p>Routes are responsible for defining the entry points into a Relay application. But in order to understand why routes are necessary, we must first understand the difference between GraphQL queries and fragments.</p>\n<blockquote>\n<p>Note</p>\n<p>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig. For more information around why Relay doesn't provide URL-routing features, and suggestions for such solutions, see <a href=\"https://medium.com/@cpojer/relay-and-routing-36b5439bad9\">this post</a>.</p>\n</blockquote>\n<h2 id=\"queries-vs-fragments\">\nQueries vs. Fragments </h2>\n<p>In GraphQL, <strong>queries</strong> declare fields that exist on the root query type. For example, the following query might fetch the name of the user with an <code>id</code> of <code>123</code>:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery UserQuery {\n  user(id: \"123\") {\n    name,\n  },\n}</pre>\n<p>On the other hand, GraphQL <strong>fragments</strong> declare fields that exist on any arbitrary type. For example, the following fragment fetches the profile picture URI for <em>some</em> <code>User</code>.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nfragment UserProfilePhoto on User {\n  profilePhoto(size: $size) {\n    uri,\n  },\n}</pre>\n<p>Fragments can be embedded within other fragments or queries. For example, the above fragment could be used to fetch user <code>123</code>'s profile photo:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery UserQuery {\n  user(id: \"123\") {\n    ...UserProfilePhoto,\n  },\n}</pre>\n<p>However, the fragment could also fetch each of user <code>123</code>'s friends' profile photos:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery UserQuery {\n  user(id: \"123\") {\n    friends(first: 10) {\n      edges {\n        node {\n          ...UserProfilePhoto,\n        },\n      },\n    },\n  },\n}</pre>\n<p>Since Relay containers define fragments and not queries, they can be easily embedded in multiple contexts. Like React components, Relay containers are highly reusable.</p>\n<h2 id=\"routes-and-queries\">\nRoutes and Queries </h2>\n<p>Routes are objects that define a set of root queries and input parameters. Here is a simple route that might be used to render user <code>123</code>'s profile:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar profileRoute = {\n  queries: {\n    // Routes declare queries using functions that return a query root. Relay\n    // will automatically compose the `user` fragment from the Relay container\n    // paired with this route on a Relay.RootContainer\n    user: () =&gt; Relay.QL`\n      # In Relay, the GraphQL query name can be optionally omitted.\n      query { user(id: $userID) }\n    `,\n  },\n  params: {\n    // This `userID` parameter will populate the `$userID` variable above.\n    userID: '123',\n  },\n  // Routes must also define a string name.\n  name: 'ProfileRoute',\n};</pre>\n<p>If we wanted to create an instance of this route for arbitrary users, we can subclass the <code>Relay.Route</code> abstract class. <code>Relay.Route</code> makes it easy to define a set of queries and required parameters to be re-used multiple times:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass ProfileRoute extends Relay.Route {\n  static queries = {\n    user: () =&gt; Relay.QL`\n      query { user(id: $userID) }\n    `,\n  };\n  static paramDefinitions = {\n    // By setting `required` to true, `ProfileRoute` will throw if a `userID`\n    // is not supplied when instantiated.\n    userID: {required: true},\n  };\n  static routeName = 'ProfileRoute';\n}</pre>\n<p>Now we can instantiate a <code>ProfileRoute</code> that fetches data for user <code>123</code>:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n// Equivalent to the object literal we created above.\nvar profileRoute = new ProfileRoute({userID: '123'});</pre>\n<p>But now, we can also create routes for arbitrary user IDs. For example, if we wanted to construct a route that fetched data for a user defined by the <code>userID</code> query parameter, we might use:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nwindow.addEventListener('popstate', () =&gt; {\n  var userID = getQueryParamFromURI('userID', document.location.href);\n  var profileRoute = new ProfileRoute({userID: userID});\n  ReactDOM.render(\n    &lt;Relay.RootContainer\n      Component={UserProfile}\n      route={profileRoute}\n    /&gt;,\n    document.getElementById('app')\n  );\n});</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/guides-routes.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/guides-routes.html</a>\n  </p>\n</div>\n","guides-root-container":"<h1>Root Container</h1>\n<p>So far, we've covered two pieces that each contribute to declaring data:</p>\n<ul>\n<li>\n<strong>Relay.Route</strong> lets us declare query roots.</li>\n<li>\n<strong>Relay.Container</strong> lets components declare fragments.</li>\n</ul>\n<p>To use these pieces to construct a full-fledged GraphQL query that we can send to the server to fetch data, we need to use the <strong>Relay.RootContainer</strong>.</p>\n<h2 id=\"component-and-route\">\nComponent and Route </h2>\n<p><strong>Relay.RootContainer</strong> is a React component that, given a <code>Component</code> and a <code>route</code>, attempts to fulfill the data required in order to render an instance of <code>Component</code>.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nReactDOM.render(\n  &lt;Relay.RootContainer\n    Component={ProfilePicture}\n    route={profileRoute}\n  /&gt;,\n  container\n);</pre>\n<p>When the <strong>Relay.RootContainer</strong> above is rendered, Relay will construct a query and send it to the GraphQL server. As soon as all required data has been fetched, <code>ProfilePicture</code> will be rendered. Props with fragments will contain data that was fetched from the server.</p>\n<p>If either <code>Component</code> or <code>route</code> ever changes, <strong>Relay.RootContainer</strong> will immediately start attempting to fulfill the new data requirements.</p>\n<h2 id=\"render-callbacks\">\nRender Callbacks </h2>\n<p><strong>Relay.RootContainer</strong> accepts three optional callbacks as props that give us more fine-grained control over the render behavior.</p>\n<h3 id=\"renderloading\">\n<code>renderLoading</code> </h3>\n<p><strong>Relay.RootContainer</strong> renders the loading state whenever it cannot immediately fulfill data needed to render. This often happens on the initial render, but it can also happen if either <code>Component</code> or <code>route</code> changes.</p>\n<p>By default, nothing is rendered while loading data for the initial render. If a previous set of <code>Component</code> and <code>route</code> were fulfilled and rendered, the default behavior is to continue rendering the previous view.</p>\n<p>We can change this behavior by supplying the <code>renderLoading</code> prop:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n&lt;Relay.RootContainer\n  Component={ProfilePicture}\n  route={profileRoute}\n  renderLoading={function() {\n    return &lt;div&gt;Loading...&lt;/div&gt;;\n  }}\n/&gt;</pre>\n<p>This snippet configures <strong>Relay.RootContainer</strong> to render the \"Loading...\" text whenever it needs to fetch data.</p>\n<p>A <code>renderLoading</code> callback can simulate the default behavior by returning <code>undefined</code>. Notice that this is different from a <code>renderLoading</code> callback that returns <code>null</code>, which would render nothing whenever data is loading, even if there was a previous view rendered.</p>\n<h3 id=\"renderfetched\">\n<code>renderFetched</code> </h3>\n<p>When all data necessary to render becomes available, <strong>Relay.RootContainer</strong> will render the supplied <code>Component</code> by default. However, we can change this behavior by supplying a callback to the <code>renderFetched</code> prop:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n&lt;Relay.RootContainer\n  Component={ProfilePicture}\n  route={profileRoute}\n  renderFetched={function(data) {\n    return (\n      &lt;ScrollView&gt;\n        &lt;ProfilePicture {...data} /&gt;\n      &lt;/ScrollView&gt;\n    );\n  }}\n/&gt;</pre>\n<p>This snippet configures <strong>Relay.RootContainer</strong> to render <code>ProfilePicture</code> within a <code>ScrollView</code> component as soon as data is ready.</p>\n<p>The <code>renderFetched</code> callback is always called with a <code>data</code> argument, which is an object mapping from <code>propName</code> to query data. It is expected that the <code>renderFetched</code> callback renders the supplied <code>Component</code> with them (e.g. using the <a href=\"https://facebook.github.io/react/docs/jsx-spread.html\">JSX spread attributes feature</a>).</p>\n<blockquote>\n<p>Note</p>\n<p>Even though we have access to the <code>data</code> object in <code>renderFetched</code>, the actual data is intentionally opaque. This prevents the <code>renderFetched</code> from creating an implicit dependency on the fragments declared by <code>Component</code>.</p>\n</blockquote>\n<h3 id=\"renderfailure\">\n<code>renderFailure</code> </h3>\n<p>If an error occurs that prevents <strong>Relay.RootContainer</strong> from fetching the data required for rendering <code>Component</code>, nothing will be rendered by default. Error handling behavior can be configured by supplying a callback to the <code>renderFailure</code> prop:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n&lt;Relay.RootContainer\n  Component={ProfilePicture}\n  route={profileRoute}\n  renderFailure={function(error, retry) {\n    return (\n      &lt;div&gt;\n        &lt;p&gt;{error.message}&lt;/p&gt;\n        &lt;p&gt;&lt;button onClick={retry}&gt;Retry?&lt;/button&gt;&lt;/p&gt;\n      &lt;/div&gt;\n    );\n  }}\n/&gt;</pre>\n<p>The <code>renderFailure</code> callback is called with two arguments: an <code>Error</code> object and a function to retry the request. If the error was the result of a server error communicated in the server's response, the response payload is available for inspection on <code>error.source</code>.</p>\n<h2 id=\"force-fetching\">\nForce Fetching </h2>\n<p>Like most of the Relay APIs, <strong>Relay.RootContainer</strong> attempts to resolve data using the client store before sending a request to the server. If we instead wanted to force a server request even if data is available on the client, we could use the <code>forceFetch</code> boolean prop.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n&lt;Relay.RootContainer\n  Component={ProfilePicture}\n  route={profileRoute}\n  forceFetch={true}\n/&gt;</pre>\n<p>When <code>forceFetch</code> is true, <strong>Relay.RootContainer</strong> will always send a request to the server. However, if all the data required to render is also available on the client, <code>renderFetched</code> may still be called before the server request completes.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n&lt;Relay.RootContainer\n  Component={ProfilePicture}\n  route={profileRoute}\n  forceFetch={true}\n  renderFetched={function(data, readyState) {\n    var isRefreshing = readyState.stale;\n    return (\n      &lt;ScrollView&gt;\n        &lt;Spinner style={{display: isRefreshing ? 'block' : 'none' }}\n        &lt;ProfilePicture {...data} /&gt;\n      &lt;/ScrollView&gt;\n    );\n  }}\n/&gt;</pre>\n<p>When <code>forceFetch</code> is true and <code>renderFetched</code> is called as a result of available client data, <code>renderFetched</code> is called with a second argument that has a <code>stale</code> boolean property. The <code>stale</code> property is true if <code>renderFetched</code> is called before the forced server request completes.</p>\n<h2 id=\"ready-state-change\">\nReady State Change </h2>\n<p><strong>Relay.RootContainer</strong> also supports the <code>onReadyStateChange</code> prop which lets us receive fine-grained events as they occur while fulfilling the data requirements.</p>\n<p>Learn how to use <code>onReadyStateChange</code> in our next guide, <a href=\"guides-ready-state\">Ready State</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/guides-root-container.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/guides-root-container.html</a>\n  </p>\n</div>\n","guides-ready-state":"<h1>Ready State</h1>\n<p>Whenever Relay is fulfilling data requirements, it can be useful to know when certain events occur. For example, we might want to record how long it takes for data to be available, or we might want to log errors to the server. These events are available on most Relay APIs via the <code>onReadyStateChange</code> callback.</p>\n<h2 id=\"onreadystatechange\">\n<code>onReadyStateChange</code> </h2>\n<p>When Relay fulfills data, the <code>onReadyStateChange</code> callback is called one or more times with an object that describes the current \"ready state\". This object has the following properties:</p>\n<ul>\n<li>\n<p><code>ready: boolean</code></p>\n<p>This is true when the subset of data required for rendering is ready.</p>\n</li>\n<li>\n<p><code>done: boolean</code></p>\n<p>This is true when <em>all</em> data requirements are ready for rendering.</p>\n</li>\n<li>\n<p><code>error: ?Error</code></p>\n<p>This is an instance of <code>Error</code> if there is a failure. Otherwise, this is <code>null</code>.</p>\n</li>\n<li>\n<p><code>events: Array&lt;ReadyStateEvent&gt;</code></p>\n<p>This is an array of events received so far (see <code>ReadyStateEvent</code> below).</p>\n</li>\n<li>\n<p><code>stale: boolean</code></p>\n<p>When \"force fetching\", this is true if <code>ready</code> is true as a result of data being available on the client before the server request has completed.</p>\n</li>\n<li>\n<p><code>aborted: boolean</code></p>\n<p>Whether the request was aborted.</p>\n</li>\n</ul>\n<h2 id=\"readystateevent\">\n<code>ReadyStateEvent</code> </h2>\n<ul>\n<li><code>ABORT</code></li>\n<li><code>CACHE_RESTORED_REQUIRED</code></li>\n<li><code>CACHE_RESTORE_FAILED</code></li>\n<li><code>CACHE_RESTORE_START</code></li>\n<li><code>NETWORK_QUERY_ERROR</code></li>\n<li><code>NETWORK_QUERY_RECEIVED_ALL</code></li>\n<li><code>NETWORK_QUERY_RECEIVED_REQUIRED</code></li>\n<li><code>NETWORK_QUERY_START</code></li>\n<li><code>STORE_FOUND_ALL</code></li>\n<li><code>STORE_FOUND_REQUIRED</code></li>\n</ul>\n<h2 id=\"examples\">\nExamples </h2>\n<h3 id=\"fetching-data-from-the-server\">\nFetching Data from the Server </h3>\n<p>If insufficient data on the client leads Relay to send a server request for more data, we can expect the following behavior:</p>\n<ol>\n<li>Once with <code>ready</code> set to false.</li>\n<li>Once with <code>ready</code> and <code>done</code> set to true.</li>\n</ol>\n<h3 id=\"resolving-data-from-the-client\">\nResolving Data from the Client </h3>\n<p>If sufficient data is available on the client such that Relay does not need to send a server request, we can expect the following behavior:</p>\n<ol><li>Once with <code>ready</code> and <code>done</code> set to true.</li></ol>\n<h3 id=\"server-error\">\nServer Error </h3>\n<p>If a server request results in a failure to load data, we can expect the following behavior:</p>\n<ol>\n<li>Once with <code>ready</code> set to false.</li>\n<li>Once with <code>error</code> set to an <code>Error</code> object.</li>\n</ol>\n<p>Note that <code>ready</code> and <code>done</code> will continue to be false.</p>\n<h3 id=\"force-fetching-with-data-from-the-client\">\nForce Fetching with Data from the Client </h3>\n<p>If a \"force fetch\" occurs and there is insufficient data on the client, the same behavior as <strong>Fetching Data from the Server</strong> can be expected. However, if a \"force fetch\" occurs and there <em>is</em> sufficient data on the client to render, we can expect the following behavior:</p>\n<ol>\n<li>Once with <code>ready</code>, <code>done</code>, and <code>stale</code> set to true.</li>\n<li>Once with <code>ready</code> and <code>done</code> set to true, but <code>stale</code> set to false.</li>\n</ol><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/guides-ready-state.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/guides-ready-state.html</a>\n  </p>\n</div>\n","guides-network-layer":"<h1>Network Layer</h1>\n<p>Relay has a network layer abstraction that separates mutations and queries from the actual machinery that sends requests to the GraphQL server. This gives us the flexibility to configure or even completely replace the default network layer via injection.</p>\n<h2 id=\"default-network-layer\">\nDefault Network Layer </h2>\n<p>Relay is pre-configured to use a default network layer that works with <a href=\"https://github.com/graphql/express-graphql\">express-graphql</a>. This default network layer is exposed via <code>Relay.DefaultNetworkLayer</code>.</p>\n<p>By default, Relay assumes that GraphQL is served at <code>/graphql</code> relative to the origin where our application is served. This can be re-configured by injecting a custom instantiation of the default network layer.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nRelay.injectNetworkLayer(\n  new Relay.DefaultNetworkLayer('http://example.com/graphql')\n);</pre>\n<p>Underneath the hood, the default network layer uses <code>fetch</code> (<a href=\"https://fetch.spec.whatwg.org\">Living Standard</a>). The constructor for <code>Relay.DefaultNetworkLayer</code> takes an optional second argument that accepts any valid initialization property that <code>fetch</code> accepts.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nRelay.injectNetworkLayer(\n  new Relay.DefaultNetworkLayer('http://example.com/graphql', {\n    credentials: 'same-origin',\n  })\n);</pre>\n<p>When it sends queries, it will automatically fail requests after a 15 second timeout. Also, failed requests are automatically retried twice, with a 1 second delay and a 3 second delay, respectively.</p>\n<p>Like the GraphQL URI, the timeout and retry behavior can be configured:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nRelay.injectNetworkLayer(\n  new Relay.DefaultNetworkLayer('http://example.com/graphql', {\n    fetchTimeout: 30000,   // Timeout after 30s.\n    retryDelays: [5000],   // Only retry once after a 5s delay.\n  })\n);</pre>\n<p>Unlike queries, failed requests for mutations are not automatically retried.</p>\n<p>Custom HTTP headers can be configured by providing a <code>headers</code> object:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nRelay.injectNetworkLayer(\n  new Relay.DefaultNetworkLayer('http://example.com/graphql', {\n    headers: {\n      Authorization: 'Basic SSdsbCBmaW5kIHNvbWV0aGluZyB0byBwdXQgaGVyZQ==',\n    },\n  })\n);</pre>\n<h2 id=\"custom-network-layers\">\nCustom Network Layers </h2>\n<p>Relay also lets us completely replace the default network layer.</p>\n<p>Custom network layers must conform to the following <a href=\"interfaces-relay-network-layer\">RelayNetworkLayer</a> interface. Although the default network layer is an instantiable class that accepts some configuration, this is not a requirement of an injected network layer.</p>\n<p>For example, a network layer can be a simple object that conforms to the interface:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar myNetworkLayer = {\n  sendMutation(mutationRequest) {\n    // ...\n  },\n  sendQueries(queryRequests) {\n    // ...\n  },\n  supports(...options) {\n    // ...\n  },\n};\n\nRelay.injectNetworkLayer(myNetworkLayer);</pre>\n<p>You can read more about the API <a href=\"interfaces-relay-network-layer\">RelayNetworkLayer</a> interface.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/guides-network-layer.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/guides-network-layer.html</a>\n  </p>\n</div>\n","api-reference-relay-renderer":"<h1>Relay.Renderer</h1>\n<p><strong>Relay.Renderer</strong> is a replacement for <code>Relay.RootContainer</code> that composes a <code>Relay.ReadyStateRenderer</code> and performs data fetching for a given <code>queryConfig</code>.</p>\n<h2 id=\"overview\">\nOverview </h2>\n<p><em>Props</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#container\"> <code>Container</code> Relay container that defines fragments and the view to render. </a> </li> <li> <a href=\"#forcefetch\"> <code>forceFetch</code> Whether to send a server request regardless of data available on the client. </a> </li> <li> <a href=\"#queryconfig\"> <code>queryConfig</code> `QueryConfig` or `Relay.Route` that defines the query roots. </a> </li> <li> <a href=\"#environment\"> <code>environment</code> An instance of `Relay.Environment` or any object that implements the `RelayEnvironment` interface. </a> </li> <li> <a href=\"#render\"> <code>render</code> Called to render when data requirements are being fulfilled. </a> </li> <li> <a href=\"#onreadystatechange\"> <code>onReadyStateChange</code> </a> </li> </ul> <h2 id=\"props\">\nProps </h2>\n<h3 id=\"container\">\nContainer </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nContainer: RelayContainer</pre>\n<p>Must be a valid <code>RelayContainer</code>. Relay will attempt to fulfill its data requirements before rendering it.</p>\n<h3 id=\"forcefetch\">\nforceFetch </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nforceFetch: boolean</pre>\n<p>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available already.</p>\n<h3 id=\"queryconfig\">\nQueryConfig </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nqueryConfig: RelayRoute</pre>\n<p>Either an instance of <code>Relay.Route</code> or an object with the <code>name</code>, <code>queries</code>, and optionally the <code>params</code> properties.</p>\n<h3 id=\"environment\">\nEnvironment </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nenvironment: RelayEnvironment</pre>\n<p>An object that conforms to the <code>Relay.Environment</code> interface, such as <code>Relay.Store</code>.</p>\n<h3 id=\"render\">\nrender </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nrender({\n  props: ?{[propName: string]: mixed},\n  done: boolean,\n  error: ?Error,\n  retry: ?Function,\n  stale: boolean\n}): ?React$Element</pre>\n<p>If the render callback is not supplied, the default behavior is to render the container if data is available, the existing view if one exists, or nothing.</p>\n<p>If the callback returns <code>undefined</code>, the previously rendered view (or nothing if there is no previous view) is rendered (e.g. when transitioning from one <code>queryConfig</code> to another).</p>\n<h4 id=\"render-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n// In this example, `ErrorComponent` and `LoadingComponent`\n// simply display a static error message / loading indicator.\n&lt;Relay.Renderer\n  Container={ProfilePicture}\n  queryConfig={profileRoute}\n  environment={Relay.Store}\n  render={({done, error, props, retry, stale}) =&gt; {\n        if (error) {\n          return &lt;ErrorComponent /&gt;;\n        } else if (props) {\n          return &lt;ProfilePicture {...props} /&gt;;\n        } else {\n          return &lt;LoadingComponent /&gt;;\n        }\n      }}\n/&gt;</pre>\n<h3 id=\"onreadystatechange\">\nonReadyStateChange </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nonReadyStateChange(\n  readyState: {\n    aborted: boolean;\n    done: boolean;\n    error: ?Error;\n    events: Array&lt;ReadyStateEvent&gt;;\n    ready: boolean;\n    stale: boolean;\n  }\n): void</pre>\n<p>This callback prop is called as the various events of data resolution occur.</p>\n<p>See also: <a href=\"guides-ready-state\">Ready State</a></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/api-reference-relay-renderer.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/api-reference-relay-renderer.html</a>\n  </p>\n</div>\n","graphql-object-identification":"<h1>Object Identification</h1>\n<p>Both <code>Faction</code> and <code>Ship</code> have identifiers that we can use to refetch them. We expose this capability to Relay through the <code>Node</code> interface and the <code>node</code> field on the root query type.</p>\n<p>The <code>Node</code> interface contains a single field, <code>id</code>, which is a <code>ID!</code>. The <code>node</code> root field takes a single argument, a <code>ID!</code>, and returns a <code>Node</code>. These two work in concert to allow refetching; if we pass the <code>id</code> returned in that field to the <code>node</code> field, we get the object back.</p>\n<p>Let's see this in action, and query for the ID of the rebels:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery RebelsQuery {\n  rebels {\n    id\n    name\n  }\n}</pre>\n<p>returns</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n{\n  \"rebels\": {\n    \"id\": \"RmFjdGlvbjox\",\n    \"name\": \"Alliance to Restore the Republic\"\n  }\n}</pre>\n<p>So now we know the ID of the Rebels in our system. We can now refetch them:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery RebelsRefetchQuery {\n  node(id: \"RmFjdGlvbjox\") {\n    id\n    ... on Faction {\n      name\n    }\n  }\n}</pre>\n<p>returns</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n{\n  \"node\": {\n    \"id\": \"RmFjdGlvbjox\",\n    \"name\": \"Alliance to Restore the Republic\"\n  }\n}</pre>\n<p>If we do the same thing with the Empire, we'll find that it returns a different ID, and we can refetch it as well:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery EmpireQuery {\n  empire {\n    id\n    name\n  }\n}</pre>\n<p>yields</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n{\n  \"empire\": {\n    \"id\": \"RmFjdGlvbjoy\",\n    \"name\": \"Galactic Empire\"\n  }\n}</pre>\n<p>and</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery EmpireRefetchQuery {\n  node(id: \"RmFjdGlvbjoy\") {\n    id\n    ... on Faction {\n      name\n    }\n  }\n}</pre>\n<p>yields</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n{\n  \"node\": {\n    \"id\": \"RmFjdGlvbjoy\",\n    \"name\": \"Galactic Empire\"\n  }\n}</pre>\n<p>The <code>Node</code> interface and <code>node</code> field assume globally unique IDs for this refetching. A system without globally unique IDs can usually synthesize them by combining the type with the type-specific ID, which is what was done in this example.</p>\n<p>The IDs we got back were base64 strings. IDs are designed to be opaque (the only thing that should be passed to the <code>id</code> argument on <code>node</code> is the unaltered result of querying <code>id</code> on some object in the system), and base64ing a string is a useful convention in GraphQL to remind viewers that the string is an opaque identifier.</p>\n<p>Complete details on how the server should behave are available in the <a href=\"https://facebook.github.io/relay/graphql/objectidentification.htm\">GraphQL Object Identification</a> spec.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/graphql-object-identification.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/graphql-object-identification.html</a>\n  </p>\n</div>\n","api-reference-relay-route":"<h1>Relay.Route</h1>\n<p>Relay uses routes to define entry points into a Relay application.</p>\n<blockquote>\n<p>Note</p>\n<p>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig.</p>\n</blockquote>\n<h2 id=\"overview\">\nOverview </h2>\n<p><em>Properties</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#paramdefinitions-static-property\"> <code>static paramDefinitions</code> Declare the expected parameters. </a> </li> <li> <a href=\"#prepareparams-static-property\"> <code>static prepareParams</code> Declare additional parameters or conversion for parameters. </a> </li> <li> <a href=\"#queries-static-property\"> <code>static queries</code> Declare the set of query roots. </a> </li> <li> <a href=\"#routename-static-property\"> <code>static routeName</code> Declare the name of this route class. </a> </li> </ul> <p><em>Methods</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#constructor\"> <code>constructor(initialParams)</code> </a> </li> </ul> <h2 id=\"properties\">\nProperties </h2>\n<h3 id=\"paramdefinitions-static-property\">\nparamDefinitions (static property) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nstatic paramDefinitions: {[param: string]: {required: boolean}}</pre>\n<p>Routes can declare a set of parameter names that it requires to be supplied to the constructor. This is also a convenient place to document the set of valid parameters.</p>\n<h4 id=\"paramdefinitions-static-property-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass ProfileRoute extends Relay.Route {\n  static paramDefinitions = {\n    userID: {required: true},\n  };\n  // ...\n}</pre>\n<h3 id=\"prepareparams-static-property\">\nprepareParams (static property) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nstatic prepareParams: ?(prevParams: {[prevParam: string]: mixed}) =&gt; {[param: string]: mixed};</pre>\n<p>Routes can use <code>prepareParams</code> to provide default parameters, or pass through, convert or suppress passed-in parameters.</p>\n<h4 id=\"prepareparams-static-property-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass ProfileRoute extends Relay.Route {\n  static queries = {\n    viewer: () =&gt; Relay.QL`query { viewer }`\n  };\n  static prepareParams = (prevParams) =&gt; {\n    return {\n      // Pass base set of supplied params through:\n      ...prevParams,\n      // Transform a param to meet internal requirements:\n      id: toGlobalId('Profile', prevParams.id),\n      // Provide a starting `limit` variable:\n      limit: 10,\n    }\n  }\n  // ...\n}</pre>\n<h3 id=\"queries-static-property\">\nqueries (static property) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nstatic queries: {\n  [queryName: string]: () =&gt; Relay.QL`query { ... }`\n};</pre>\n<p>Routes must declare a set of query roots using <code>Relay.QL</code>. These queries will automatically compose a matching fragment named <code>queryName</code> on the Relay container used with this route on a <strong>Relay.RootContainer</strong>.</p>\n<h4 id=\"queries-static-property-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass ProfileRoute extends Relay.Route {\n  static queries = {\n    user: () =&gt; Relay.QL`query { user(id: $userID) }`,\n  };\n  // ...\n}</pre>\n<p>In this example the Route should be initialized with a <code>userID</code> which gets passed on to the query. That <code>userID</code> variable will automatically be passed down to the top-level container and can be used there if needed. Further the top-level RelayContainer is expected to have a <code>user</code> fragment with the fields to be queried.</p>\n<h3 id=\"routename-static-property\">\nrouteName (static property) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nstatic routeName: string</pre>\n<p>Routes must define a string name.</p>\n<h2 id=\"methods\">\nMethods </h2>\n<h3 id=\"constructor\">\nconstructor </h3>\n<p>Create a route instance using the <code>new</code> keyword, optionally passing it some params.</p>\n<h4 id=\"constructor-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar profileRoute = new ProfileRoute({userID: '123'});</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/api-reference-relay-route.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/api-reference-relay-route.html</a>\n  </p>\n</div>\n","thinking-in-relay":"<h1>Thinking In Relay</h1>\n<p>Relay's approach to data-fetching is heavily inspired by our experience with React. In particular, React breaks complex interfaces into reusable <strong>components</strong>, allowing developers to reason about discrete units of an application in isolation, and reducing the coupling between disparate parts of an application. Even more important is that these components are <strong>declarative</strong>: they allow developers to specify <em>what</em> the UI should look like for a given state, and not have to worry about <em>how</em> to show that UI. Unlike previous approaches that used imperative commands to manipulate native views (e.g. the DOM), React uses a UI description to automatically determine the necessary commands.</p>\n<p>Let's look at some product use-cases to understand how we incorporated these ideas into Relay. We'll assume a basic familiarity with React.</p>\n<h2 id=\"fetching-data-for-a-view\">\nFetching Data For a View </h2>\n<p>In our experience, the overwhelming majority of products want one specific behavior: fetch <em>all</em> the data for a view hierarchy while displaying a loading indicator, and then render the <em>entire</em> view once the data is ready.</p>\n<p>One solution is to have a root component fetch the data for all its children. However, this would introduce coupling: every change to a component would require changing <em>any</em> root component that might render it, and often some components between it and the root. This coupling could mean a greater chance for bugs and slow the pace of development. Ultimately, this approach doesn't take advantage of React's component model. The natural place for specifying data-dependencies was in <em>components</em>.</p>\n<p>The next logical approach is to use <code>render()</code> as the means of initiating data-fetching. We could simply render the application once, see what data it needed, fetch that data, and render again. This sounds great, but the problem is that <em>components use data to figure out what to render!</em> In other words, this would force data-fetching to be staged: first render the root and see what data it needs, then render its children and see what they need, all the way down the tree. If each stage incurs network request, rendering would require slow, serial roundtrips. We needed a way to determine all the data needs up-front or <em>statically</em>.</p>\n<p>We ultimately settled on static methods; components would effectively return a query-tree, separate from the view-tree, describing their data dependencies. Relay could then use this query-tree to fetch all the information needed in a single stage and use it to render the components. The problem was finding an appropriate mechanism to describe the query-tree, and a way to efficiently fetch it from the server (i.e. in a single network request). This is the perfect use-case for GraphQL because it provides a syntax for <em>describing data-dependencies as data</em>, without dictating any particular API. Note that Promises and Observables are often suggested as alternatives, but they represent <em>opaque commands</em> and preclude various optimizations such as query batching.</p>\n<h2 id=\"data-components-aka-containers\">\nData Components aka Containers </h2>\n<p>Relay allows developers to annotate their React components with data dependencies by creating <strong>containers</strong>. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a <code>&lt;Story&gt;</code> component might implement a view for rendering any <code>Story</code> item. The actual story to render would be determined by the data passed to the component: <code>&lt;Story story={ ... } /&gt;</code>. The equivalent in GraphQL are <strong>fragments</strong>: named query snippets that specify what data to fetch <em>for an object of a given type</em>. We might describe the data needed by <code>&lt;Story&gt;</code> as follows:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nfragment on Story {\n  text,\n  author {\n    name,\n    photo\n  }\n}</pre>\n<p>And this fragment can then be used to define the Story container:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n// Plain React component.\n// Usage: `&lt;Story story={ ... } /&gt;`\nclass Story extends React.Component { ... }\n\n// \"Higher-order\" component that wraps `&lt;Story&gt;`\nvar StoryContainer = Relay.createContainer(Story, {\n  fragments: {\n    // Define a fragment with a name matching the `story` prop expected above\n    story: () =&gt; Relay.QL`\n      fragment on Story {\n        text,\n        author { ... }\n      }\n    `\n  }\n})</pre>\n<h2 id=\"rendering\">\nRendering </h2>\n<p>In React, rendering a view requires two inputs: the <em>component</em> to render, and a <em>root</em> DOM (UI) node to render into. Rendering Relay containers is similar: we need a <em>container</em> to render, and a <em>root</em> in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to <code>ReactDOM.render(component, domNode)</code>, Relay provides <code>&lt;Relay.Renderer Container={...} queryConfig={...}&gt;</code> for this purpose. The container is the item to render, and the queryConfig provides queries that specify <em>which</em> item to fetch. Here's how we might render <code>&lt;StoryContainer&gt;</code>:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nReactDOM.render(\n  &lt;Relay.Renderer\n    Container={StoryContainer}\n    queryConfig={{\n      queries: {\n        story: () =&gt; Relay.QL`\n          query {\n            node(id: \"123\") /* our `Story` fragment will be added here */\n          }\n        `\n      },\n    }}\n  /&gt;,\n  rootEl\n)</pre>\n<p><code>Relay.Renderer</code> can then orchestrate the fetching of the queries; diffing them against cached data, fetching any missing information, updating the cache, and finally rendering <code>StoryContainer</code> once the data is available. The default is to render nothing while data is fetching, but the loading view can be customized via the <code>render</code> prop. Just as React allows developers to render views without directly manipulating the underlying view, Relay and <code>Relay.Renderer</code> remove the need to directly communicate with the network.</p>\n<h2 id=\"data-masking\">\nData Masking </h2>\n<p>With typical approaches to data-fetching we found that it was common for two components to have <em>implicit dependencies</em>. For example <code>&lt;StoryHeader&gt;</code> might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as <code>&lt;Story&gt;</code>. Then when we changed <code>&lt;Story&gt;</code> and removed that data-fetching logic, <code>&lt;StoryHeader&gt;</code> would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.</p>\n<p>We've seen that Relay containers ensure that GraphQL fragments are fetched <em>before</em> the component is rendered. But containers also provide another benefit that isn't immediately obvious: <strong>data masking</strong>. Relay only allows components to access data they specifically ask for in <code>fragments</code> â€” nothing more. So if one component queries for a Story's <code>text</code>, and another for its <code>author</code>, each can see <em>only</em> the field that they asked for. In fact, components can't even see the data requested by their <em>children</em>: that would also break encapsulation.</p>\n<p>Relay also goes further: it uses opaque identifiers on <code>props</code> to validate that we've explicitly fetched the data for a component before rendering it. If <code>&lt;Story&gt;</code> renders <code>&lt;StoryHeader&gt;</code> but forgets to include its fragment, Relay will warn that the data for <code>&lt;StoryHeader&gt;</code> is missing. In fact, Relay will warn <em>even if</em> some other component happened to fetch the same data required by <code>&lt;StoryHeader&gt;</code>. This warning tells us that although things <em>might</em> work now they're highly likely to break later.</p>\n<h1 id=\"conclusion\">\nConclusion </h1>\n<p>GraphQL provides a powerful tool for building efficient, decoupled client applications. Relay builds on this functionality to provide a framework for <strong>declarative data-fetching</strong>. By separating <em>what</em> data to fetch from <em>how</em> it is fetched, Relay helps developers build applications that are robust, transparent, and performant by default. It's a great complement to the component-centric way of thinking championed by React. While each of these technologies â€” React, Relay, and GraphQL â€” are powerful on their own, the combination is a <strong>UI platform</strong> that allows us to <em>move fast</em> and <em>ship high-quality apps at scale</em>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/thinking-in-relay.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/thinking-in-relay.html</a>\n  </p>\n</div>\n","api-reference-relay-ql":"<h1>Relay.QL</h1>\n<p>Relay fragments, mutations, and queries must be specified using ES6 template literals tagged with <code>Relay.QL</code>. For example:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar fragment = Relay.QL`\n  fragment on User {\n    name\n  }\n`;</pre>\n<p>To execute this code, Relay needs access to the schema - which can be too large to bundle inside the application. Instead, these <code>Relay.QL</code> template expressions are transpiled into JavaScript descriptions via the <code>babel-relay-plugin</code>. This schema information allows Relay to understand things like the types of field arguments, which fields are connections or lists, and how to efficiently refetch records from the server.</p>\n<h2 id=\"related-apis\">\nRelated APIs </h2>\n<p><code>Relay.QL</code> objects are used by the following APIs:</p>\n<ul class=\"apiIndex\"> <li> <pre>() =&gt; Relay.QL`fragment on ...`</pre> Specify the data dependencies of a `Relay.Container` as GraphQL fragments. </li> <li> <pre>(Component) =&gt; Relay.QL`query ...`</pre> Specify the queries of a `Relay.Route`. </li> <li> <pre>Relay.QL`mutation { fieldName }`</pre> Specify the mutation field in a `Relay.Mutation`. </li> <li> <pre>var fragment = Relay.QL`fragment on ...`;</pre> Reusable fragments to compose within the above use cases. </li> </ul> <h2 id=\"fragment-composition\">\nFragment Composition </h2>\n<p>Fragments can be composed in one of two ways:</p>\n<ul>\n<li>Composing child component fragments in a parent fragment.</li>\n<li>Composing fragments defined as local variables.</li>\n</ul>\n<h3 id=\"container-getfragment\">\nContainer.getFragment() </h3>\n<p>Composing the fragments of child components is discussed in detail in the <a href=\"guides-containers\">Containers Guide</a>, but here's a quick example:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nRelay.createContainer(Foo, {\n  fragments: {\n    bar: () =&gt; Relay.QL`\n      fragment on Bar {\n        ${ChildComponent.getFragment('childFragmentName')},\n      }\n    `,\n  }\n});</pre>\n<h3 id=\"inline-fragments\">\nInline Fragments </h3>\n<p>Fragments may also compose other fragments that are assigned to local variables:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n// An inline fragment - useful in small quantities, but best not to share\n// between modules.\nvar userFragment = Relay.QL`\n  fragment on User {\n    name,\n  }\n`;\nRelay.createContainer(Story, {\n  fragments: {\n    bar: () =&gt; Relay.QL`\n      fragment on Story {\n        author {\n          # Fetch the same information about the story's author ...\n          ${userFragment},\n        },\n        comments {\n          edges {\n            node {\n              author {\n                # ... and the authors of the comments.\n                ${userFragment},\n              },\n            },\n          },\n        },\n      }\n    `,\n  }\n});</pre>\n<p>Note that it is <em>highly</em> recommended that <code>Relay.Container</code>s define their own fragments and avoid sharing inline <code>var fragment = Relay.QL...</code> values between containers or files. If you find yourself wanting to share inline fragments, it's likely a sign that it's time to refactor and introduce a new container.</p>\n<h3 id=\"conditional-fields\">\nConditional fields </h3>\n<p>You can conditionally include or skip a field based on the value of a boolean variable.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nRelay.createContainer(Story, {\n  initialVariables: {\n    numCommentsToShow: 10,\n    showComments: false,\n  },\n  fragments: {\n    story: (variables) =&gt; Relay.QL`\n      fragment on Story {\n        comments(first: $numCommentsToShow) @include(if: $showComments) {\n          edges {\n            node {\n              author { name },\n              id,\n              text,\n            },\n          },\n        },\n      }\n    `,\n  }\n});</pre>\n<p>Wherever the inverse grammar serves you better, you can use <code>@skip(if: ...)</code> instead of <code>@include(if: ...)</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/api-reference-relay-ql.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/api-reference-relay-ql.html</a>\n  </p>\n</div>\n","api-reference-relay":"<h1>Relay</h1>\n<p><code>Relay</code> is the entry point to the Relay library. If you're using one of the prebuilt packages it's available as a global; if you're using CommonJS modules you can <code>require()</code> it.</p>\n<blockquote>\n<p>Note</p>\n<p>The <code>react-relay</code> npm module includes <code>react</code> as a <em>peer dependency</em>. Your app should specify React as a dependency explicitly.</p>\n</blockquote>\n<p>The most-used function is <a href=\"#createcontainer-static-method\"><code>createContainer()</code></a> which wraps components with data declarations.</p>\n<h2 id=\"overview\">\nOverview </h2>\n<p><em>Properties</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"guides-network-layer\"> <code>static DefaultNetworkLayer â†’</code> </a> </li> <li> <a href=\"guides-mutations\"> <code>static Mutation â†’</code> </a> </li> <li> <a href=\"api-reference-relay-ql\"> <code>static QL â†’</code> </a> </li> <li> <a href=\"api-reference-relay-proptypes\"> <code>static PropTypes â†’</code> </a> </li> <li> <a href=\"guides-root-container\"> <code>static RootContainer â†’</code> </a> </li> <li> <a href=\"guides-routes\"> <code>static Route â†’</code> </a> </li> <li> <a href=\"api-reference-relay-store\"> <code>static Store â†’</code> </a> </li> </ul> <p><em>Methods</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#createcontainer-static-method\"> <code>static createContainer(Component, ContainerConfig)</code> Creates a Relay Container. </a> </li> <li> <a href=\"#injectnetworklayer-static-method\"> <code>static injectNetworkLayer(networkLayer)</code> Customize how queries and mutations are sent to the server. </a> </li> <li> <a href=\"#injecttaskscheduler-static-method\"> <code>static injectTaskScheduler(scheduler)</code> Configure when Relay processing occurs. </a> </li> <li> <a href=\"#iscontainer-static-method\"> <code>static isContainer(Component)</code> Determine if a given object is a Relay.Container. </a> </li> </ul> <h2 id=\"properties\">\nProperties </h2>\n<h3 id=\"defaultnetworklayer-static-property\">\nDefaultNetworkLayer (static property) </h3>\n<p>See the <a href=\"guides-network-layer\">Network Layer Guide</a>.</p>\n<h3 id=\"mutation\">\nMutation </h3>\n<p>See the <a href=\"guides-mutations\">Mutations Guide</a>.</p>\n<h3 id=\"ql\">\nQL </h3>\n<p>See the <a href=\"api-reference-relay-ql\">Relay.QL API reference</a>.</p>\n<h3 id=\"proptypes\">\nPropTypes </h3>\n<p>See the <a href=\"api-reference-relay-proptypes\">PropTypes API reference</a>.</p>\n<h3 id=\"rootcontainer\">\nRootContainer </h3>\n<p>See the <a href=\"guides-root-container\">RootContainer Guide</a>.</p>\n<h3 id=\"route\">\nRoute </h3>\n<p>See the <a href=\"guides-routes\">Routes Guide</a>.</p>\n<h3 id=\"store\">\nStore </h3>\n<p>See the <a href=\"api-reference-relay-store\">Store API reference</a>.</p>\n<h2 id=\"methods\">\nMethods </h2>\n<h3 id=\"createcontainer-static-method\">\ncreateContainer (static method) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar Container = Relay.createContainer(Component, {\n  initialVariables?: Object,\n  prepareVariables?: (variables: Object, route: string) =&gt; Object,\n  fragments: {[key: string]: Function}\n});</pre>\n<p>Creates a new Relay Container - see the <a href=\"guides-containers\">Container Guide</a> for more details and examples.</p>\n<h3 id=\"injectnetworklayer-static-method\">\ninjectNetworkLayer (static method) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nRelay.injectNetworkLayer(networkLayer: {\n  sendMutation: (mutation: RelayMutationRequest) =&gt; void;\n  sendQueries: (queries: Array&lt;RelayQueryRequest&gt;) =&gt; void;\n  supports: (...options: Array&lt;string&gt;): boolean;\n});</pre>\n<p>Overrides the <a href=\"#defaultnetworklayer-static-property\">DefaultNetworkLayer</a>.</p>\n<h4 id=\"injectnetworklayer-static-method-example\">\nExample </h4>\n<p>As an example, we can log each mutation that is sent to the server as follows:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar DefaultNetworkLayer = Relay.DefaultNetworkLayer;\n\nclass MutationLoggingNetworkLayer extends DefaultNetworkLayer {\n  sendMutation(mutation) {\n    // log the response or error (note that `mutation` is a promise)\n    mutation.then(\n      response =&gt; console.log(response),\n      error =&gt; console.error(error),\n    );\n    // Send the mutation using the default network implementation\n    return super.sendMutation(mutation);\n  }\n};\n\nRelay.injectNetworkLayer(new MutationLoggingNetworkLayer());</pre>\n<h3 id=\"injecttaskscheduler-static-method\">\ninjectTaskScheduler (static method) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nRelay.injectTaskScheduler(scheduler: Scheduler): void;\n\ntype Scheduler = (task: Function) =&gt; void;</pre>\n<p>Relay wraps its core processing functions inside lightweight tasks, which by default are executed immediately (i.e. synchronously). In order to customize <em>when</em> these tasks are run - for example to avoid interrupting an animation during a touch gesture - applications can provide a custom scheduling function.</p>\n<h4 id=\"injecttaskscheduler-static-method-examples\">\nExamples </h4>\n<p>The default implementation is as follows:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nRelay.injectTaskScheduler(task =&gt; task());</pre>\n<p>Notice that it immediately executes the next task. Relay manages the order of tasks to ensure a proper order of operations - the scheduler can't skip or reorder tasks, only decide when to execute the next one.</p>\n<p>In React Native, we can schedule Relay processing so as to avoid interrupting touch gestures as follows:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar {InteractionManager} = require('react-native');\n\nRelay.injectTaskScheduler(InteractionManager.runAfterInteractions);</pre>\n<p>You can read more about <code>InteractionManager</code> on the <a href=\"http://facebook.github.io/react-native/docs/interactionmanager.html\">React Native API docs</a>.</p>\n<h3 id=\"iscontainer-static-method\">\nisContainer (static method) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nRelay.isContainer(Component: Object): boolean;</pre>\n<h4 id=\"iscontainer-static-method-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar Component = require('...');\n\nif (Relay.isContainer(Component)) {\n  Component.getFragment('...');\n}</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/api-reference-relay.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/api-reference-relay.html</a>\n  </p>\n</div>\n","api-reference-relay-mutation":"<h1>Relay.Mutation</h1>\n<p>Relay makes use of GraphQL mutations; operations that enable us to mutate data on the client and server. To create a mutation for use in our app, we subclass <code>Relay.Mutation</code> and implement, at minimum, the four abstract methods listed below.</p>\n<h2 id=\"overview\">\nOverview </h2>\n<p><em>Properties</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#fragments-static-property\"> <code>static fragments</code> Declare this mutation's data dependencies here </a> </li> <li> <a href=\"#initialvariables-static-property\"> <code>static initialVariables</code> A default set of variables to make available to this mutation's fragment builders </a> </li> <li> <a href=\"#preparevariables-static-property\"> <code>static prepareVariables</code> A method to modify the variables based on the runtime environment, previous variables, or the meta route </a> </li> </ul> <p><em>Methods</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#constructor\"> <code>constructor(props)</code> </a> </li> <li> <a href=\"#getconfigs-abstract-method\"> <code>abstract getConfigs()</code> </a> </li> <li> <a href=\"#getfatquery-abstract-method\"> <code>abstract getFatQuery()</code> </a> </li> <li> <a href=\"#getmutation-abstract-method\"> <code>abstract getMutation()</code> </a> </li> <li> <a href=\"#getvariables-abstract-method\"> <code>abstract getVariables()</code> </a> </li> <li> <a href=\"#getfragment-static-method\"> <code>static getFragment(fragmentName[, variableMapping])</code> </a> </li> <li> <a href=\"#getcollisionkey\"> <code>getCollisionKey()</code> </a> </li> <li> <a href=\"#getfiles\"> <code>getFiles()</code> </a> </li> <li> <a href=\"#getoptimisticconfigs\"> <code>getOptimisticConfigs()</code> </a> </li> <li> <a href=\"#getoptimisticresponse\"> <code>getOptimisticResponse()</code> </a> </li> </ul> <h2 id=\"properties\">\nProperties </h2>\n<h3 id=\"fragments-static-property\">\nfragments (static property) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nstatic fragments: RelayMutationFragments&lt;$Keys&lt;Tp&gt;&gt;\n\n// Type of RelayMutationFragments\ntype RelayMutationFragments&lt;Tk&gt; = {\n  [key: Tk]: FragmentBuilder;\n};\n\n// Type of FragmentBuilder\ntype FragmentBuilder = (variables: Variables) =&gt; RelayConcreteNode;</pre>\n<p>We declare our mutations' data dependencies here, just as we would with a container. This is particularly useful to ensure that a set of fields we might want to use in this mutation's optimistic response have been fetched.</p>\n<h4 id=\"fragments-static-property-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass LikeStoryMutation extends Relay.Mutation {\n  static fragments = {\n    story: () =&gt; Relay.QL`\n      fragment on Story {\n        likers { count },\n        viewerDoesLike,\n      }\n    `,\n  };\n  getOptimisticResponse() {\n    // this.props.story.likers.count and this.props.story.viewerDoesLike\n    // are guaranteed to have been fetched since we've declared\n    // them to be part of this mutation's data dependencies above.\n    return { /* ... */ };\n  }\n}</pre>\n<p>See also: <a href=\"guides-mutations#fragment-variables\">Mutations &gt; Fragment variables</a> and <a href=\"guides-mutations#optimistic-updates\">Mutations &gt; Optimistic updates</a></p>\n<h3 id=\"initialvariables-static-property\">\ninitialVariables (static property) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nstatic initialVariables: {[name: string]: mixed};</pre>\n<p>The defaults we specify here will become available to our fragment builders:</p>\n<h4 id=\"initialvariables-static-property-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass ChangeTodoStatusMutation extends Relay.Mutation {\n  static initialVariables = {orderby: 'priority'};\n  static fragments = {\n    todos: () =&gt; Relay.QL`\n      # The variable defined above is available here as $orderby\n      fragment on User { todos(orderby: $orderby) { ... } }\n    `,\n  };\n  /* ... */\n}</pre>\n<p>See also: <a href=\"guides-mutations#fragment-variables\">Mutations &gt; Fragment variables</a></p>\n<h3 id=\"preparevariables-static-property\">\nprepareVariables (static property) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nstatic prepareVariables: ?(\n  prevVariables: {[name: string]: mixed},\n  route: RelayMetaRoute,\n) =&gt; {[name: string]: mixed}\n\n// Type of `route` argument\ntype RelayMetaRoute = {\n  name: string;\n}</pre>\n<p>If we provide to a mutation a method that conforms to the signature described above, it will be given the opportunity to modify the fragment builders' variables, based on the previous variables (or the <code>initialVariables</code> if no previous ones exist), the meta route, and the runtime environment. Whatever variables this method returns will become available to this mutation's fragment builders.</p>\n<h4 id=\"preparevariables-static-property-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass BuySongMutation extends Relay.Mutation {\n  static initialVariables = {format: 'mp3'};\n  static prepareVariables = (prevVariables) =&gt; {\n    var overrideVariables = {};\n    var formatPreference = localStorage.getItem('formatPreference');\n    if (formatPreference) {\n      overrideVariables.format = formatPreference;  // Lossless, hopefully\n    }\n    return {...prevVariables, overrideVariables};\n  };\n  /* ... */\n}</pre>\n<p>See also: <a href=\"guides-mutations#fragment-variables\">Mutations &gt; Fragment variables</a></p>\n<h2 id=\"methods\">\nMethods </h2>\n<h3 id=\"constructor\">\nconstructor </h3>\n<p>Create a mutation instance using the <code>new</code> keyword, optionally passing it some props. Note that <code>this.props</code> is <em>not</em> available inside the constructor function, but are set for all the methods mentioned below (<code>getCollisionKey</code>, <code>getOptimisticResponse</code>, etc). This restriction is due to the fact that mutation props may depend on data from the RelayEnvironment, which isn't known until the mutation is applied with <code>applyUpdate</code> or <code>commitUpdate</code>.</p>\n<h4 id=\"constructor-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar bookFlightMutation = new BuyPlaneTicketMutation({airport: 'yvr'});\nRelay.Store.commitUpdate(bookFlightMutation);</pre>\n<h3 id=\"getconfigs-abstract-method\">\ngetConfigs (abstract method) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nabstract getConfigs(): Array&lt;{[key: string]: mixed}&gt;</pre>\n<p>Implement this required method to give Relay instructions on how to use the response payload from each mutation to update the client-side store.</p>\n<h4 id=\"getconfigs-abstract-method-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass LikeStoryMutation extends Relay.Mutation {\n  getConfigs() {\n    return [{\n      type: 'FIELDS_CHANGE',\n      fieldIDs: {\n        story: this.props.story.id,\n      },\n    }];\n  }\n}</pre>\n<p>See also: <a href=\"guides-mutations#mutator-configuration\">Mutations &gt; Mutator configuration</a></p>\n<h3 id=\"getfatquery-abstract-method\">\ngetFatQuery (abstract method) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nabstract getFatQuery(): GraphQL.Fragment</pre>\n<p>Implement this required method to design a â€˜fat queryâ€™ â€“ one that represents every field in your data model that could change as a result of this mutation.</p>\n<h4 id=\"getfatquery-abstract-method-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass BuySongMutation extends Relay.Mutation {\n  getFatQuery() {\n    return Relay.QL`\n      fragment on BuySongPayload {\n        songs {\n          count,\n          edges,\n        },\n        totalRunTime,\n      }\n    `,\n  }\n}</pre>\n<p>See also: <a href=\"guides-mutations#the-fat-query\">Mutations &gt; The fat query</a></p>\n<h3 id=\"getmutation-abstract-method\">\ngetMutation (abstract method) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nabstract getMutation(): GraphQL.Mutation</pre>\n<p>Implement this required method to return a GraphQL mutation operation that represents the mutation to be performed.</p>\n<h4 id=\"getmutation-abstract-method-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass LikeStoryMutation extends Relay.Mutation {\n  getMutation() {\n    return this.props.story.viewerDoesLike\n      ? return Relay.QL`mutation {unlikeStory}`\n      : return Relay.QL`mutation {likeStory}`;\n  }\n}</pre>\n<h3 id=\"getvariables-abstract-method\">\ngetVariables (abstract method) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nabstract getVariables(): {[name: string]: mixed}</pre>\n<p>Implement this required method to prepare variables to be used as input to the mutation.</p>\n<h4 id=\"getvariables-abstract-method-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass DestroyShipMutation extends Relay.Mutation {\n  getVariables() {\n    return {\n      // Assume that the server exposes a `destroyShip` mutation\n      // that accepts a `shipIDToDestroy` variable as input:\n      shipIDToDestroy: this.props.ship.id,\n    };\n  }\n}</pre>\n<blockquote>\n<p>Warning</p>\n<p>The term â€˜variablesâ€™ here refers to the input to the server-side mutation, <strong>not</strong> to the variables made available to this mutation's fragment builders.</p>\n</blockquote>\n<h3 id=\"getfragment-static-method\">\ngetFragment (static method) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nstatic getFragment(\n  fragmentName: $Keys&lt;Tp&gt;,\n  variableMapping?: Variables\n): RelayFragmentReference\n\n// Type of the variableMapping argument\ntype Variables = {[name: string]: mixed};</pre>\n<p>Gets a fragment reference for use in a parent's query fragment.</p>\n<h4 id=\"getfragment-static-method-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass StoryComponent extends React.Component {\n  /* ... */\n  static fragments = {\n    story: () =&gt; Relay.QL`\n      fragment on Story {\n        id,\n        text,\n        ${LikeStoryMutation.getFragment('story')},\n      }\n    `,\n  };\n}</pre>\n<p>You can also pass variables to the mutation's fragment builder from the outer fragment that contains it.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass Movie extends React.Component {\n  /* ... */\n  static fragments = {\n    movie: () =&gt; Relay.QL`\n      fragment on Movie {\n        posterImage(lang: $lang) { url },\n        trailerVideo(format: $format, lang: $lang) { url },\n        ${RentMovieMutation.getFragment('movie', {\n          format: variables.format,\n          lang: variables.lang,\n        })},\n      }\n    `,\n  };\n}</pre>\n<blockquote>\n<p>Hint</p>\n<p>In that last example, think of <code>$format</code> and <code>variables.format</code> as the same value.</p>\n</blockquote>\n<h3 id=\"getcollisionkey\">\ngetCollisionKey </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetCollisionKey(): ?string</pre>\n<p>Implement this method to return a collision key. Relay will send any mutations having the same collision key to the server serially and in-order.</p>\n<h4 id=\"getcollisionkey-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass LikeStoryMutation extends Relay.Mutation {\n  getCollisionKey() {\n    // Give the same key to like mutations that affect the same story\n    return `like_${this.props.story.id}`;\n  }\n}</pre>\n<h3 id=\"getfiles\">\ngetFiles </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetFiles(): ?FileMap\n\n// Type of the FileMap object\ntype FileMap = {[key: string]: File};</pre>\n<p>Implement this method to return a map of <code>File</code> objects to upload as part of a mutation.</p>\n<h4 id=\"getfiles-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass AttachDocumentMutation extends Relay.Mutation {\n  getFiles() {\n    return {\n      file: this.props.file,\n    };\n  }\n}\nclass FileUploader extends React.Component {\n  handleSubmit() {\n    var fileToAttach = this.refs.fileInput.files.item(0);\n    Relay.Store.commitUpdate(\n      new AttachDocumentMutation({file: fileToAttach})\n    );\n  }\n}</pre>\n<h3 id=\"getoptimisticconfigs\">\ngetOptimisticConfigs </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetOptimisticConfigs(): Array&lt;{[key: string]: mixed}&gt;</pre>\n<p>Implement this method in cases where the mutator configuration needed to handle the optimistic response needs to be different than the one that handles the server response.</p>\n<p>See also: <a href=\"#getconfigs-abstract-method\">Relay.Mutation::getConfigs()</a></p>\n<h3 id=\"getoptimisticresponse\">\ngetOptimisticResponse </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetOptimisticResponse(): ?{[key: string]: mixed}</pre>\n<p>Implement this method to craft an optimistic response having the same shape as the server response payload. This optimistic response will be used to preemptively update the client cache before the server returns, giving the impression that the mutation completed instantaneously.</p>\n<h4 id=\"getoptimisticresponse-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass LikeStoryMutation extends Relay.Mutation {\n  getOptimisticResponse() {\n    return {\n      story: {\n        id: this.props.story.id,\n        likers: {\n          count: this.props.story.likers.count + 1,\n        },\n        viewerDoesLike: !this.props.story.viewerDoesLike,\n      },\n    };\n  }\n}</pre>\n<p>See also: <a href=\"guides-mutations#optimistic-updates\">Mutations &gt; Optimistic updates</a></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/api-reference-relay-mutation.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/api-reference-relay-mutation.html</a>\n  </p>\n</div>\n","guides-containers":"<h1>Containers</h1>\n<p>The primary way to declare data requirements is via <code>Relay.Container</code> â€” a higher-order React component that lets React components encode their data requirements.</p>\n<p>Similar to how a React component's <code>render</code> method does not directly modify native views, Relay containers do not directly fetch data. Instead, containers declare a <em>specification</em> of the data needed to render. Relay guarantees that this data is available <em>before</em> rendering.</p>\n<h2 id=\"a-complete-example\">\nA Complete Example </h2>\n<p>To start, let's build the plain React version of a <code>&lt;ProfilePicture&gt;</code> component that displays the user's profile photo and a slider to adjust the photo's size.</p>\n<h3 id=\"base-react-component\">\nBase React Component </h3>\n<p>Here's a basic implementation of <code>&lt;ProfilePicture&gt;</code> that ignores styling in order to highlight the functionality:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass ProfilePicture extends React.Component {\n  render() {\n    // Expects the `user` prop to have the following shape:\n    // {\n    //   profilePhoto: {\n    //     uri,\n    //   }\n    // }\n    var user = this.props.user;\n    return (\n      &lt;View&gt;\n        &lt;Image uri={user.profilePhoto.uri} width={...} /&gt;\n        &lt;Slider onChange={value =&gt; this.setSize(value)} /&gt;\n      &lt;/View&gt;\n    );\n  }\n\n  // Update the size of the photo\n  setSize(photoSize) {\n    // TODO: Fetch the profile photo URI for the given size...\n  }\n}</pre>\n<h3 id=\"data-dependencies-with-graphql\">\nData Dependencies With GraphQL </h3>\n<p>In Relay, data dependencies are described using <a href=\"https://github.com/facebook/graphql\">GraphQL</a>. For <code>&lt;ProfilePicture&gt;</code>, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the <code>user</code> prop.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nRelay.QL`\n  # This fragment only applies to objects of type `User`.\n  fragment on User {\n    # Set the `size` argument to a GraphQL variable named `$size` so that we can\n    # later change its value via the slider.\n    profilePhoto(size: $size) {\n      # Get the appropriate URI for the given size, for example on a CDN.\n      uri,\n    },\n  }\n`</pre>\n<h3 id=\"relay-containers\">\nRelay Containers </h3>\n<p>Given the plain React component and a GraphQL fragment, we can now define a <code>Container</code> to tell Relay about this component's data requirements. Let's look at the code first and then see what's happening:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass ProfilePicture extends React.Component {/* as above */}\n\n// Export a *new* React component that wraps the original `&lt;ProfilePicture&gt;`.\nmodule.exports = Relay.createContainer(ProfilePicture, {\n  // Specify the initial value of the `$size` variable.\n  initialVariables: {\n    size: 32\n  },\n  // For each of the props that depend on server data, we define a corresponding\n  // key in `fragments`. Here, the component expects server data to populate the\n  // `user` prop, so we'll specify the fragment from above as `fragments.user`.\n  fragments: {\n    user: () =&gt; Relay.QL`\n      fragment on User {\n        profilePhoto(size: $size) {\n          uri,\n        },\n      }\n    `,\n  },\n});</pre>\n<h2 id=\"containers-are-higher-order-components\">\nContainers are Higher-Order Components </h2>\n<p>Relay containers are higher-order components â€” <code>Relay.createContainer</code> is a function that takes a React component as input and returns a new component as output. This means that the container can manage data fetching and resolution logic without interfering with the <code>state</code> of the inner component.</p>\n<p>Here's what happens when the container is rendered:</p>\n<div class=\"diagram\"> <img src=\"https://facebook.github.io/relay/img/Guides-Containers-HOC-Relay.png\" title=\"Relay Containers\"> </div> <p>In the diagram above:</p>\n<ul>\n<li>A parent component will pass in a reference to some <code>User</code> \"record\".</li>\n<li>The container â€” named <code>Relay(ProfilePicture)</code> for debugging â€” will retrieve the response for each GraphQL fragment from the local store.</li>\n<li>The container passes the results of each fragment (along with the other props) to the <code>&lt;ProfilePicture&gt;</code> component.</li>\n<li>\n<code>&lt;ProfilePicture&gt;</code> receives a <code>user</code> prop with plain JavaScript data - objects, arrays, strings - and renders as usual.</li>\n</ul>\n<h2 id=\"requesting-different-data\">\nRequesting Different Data </h2>\n<p>One thing is left in the example above â€” implementing <code>setSize()</code>, which should change the photo's size when the slider values changes. In addition to passing the results of each query to the component, Relay also provides a <code>relay</code> prop that has Relay-specific methods and metadata. These include <code>variables</code> â€” the active variables used to fetch the current <code>props</code> â€” and <code>setVariables()</code> â€” a callback that can be used to request data for different variable values.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass ProfilePicture extends React.Component {\n  render() {\n    // Access the resolved data for the `user` fragment.\n    var user = this.props.user;\n    // Access the current `variables` that were used to fetch the `user`.\n    var variables = this.props.relay.variables;\n    return (\n      &lt;View&gt;\n        &lt;Image\n          uri={user.profilePhoto.uri}\n          width={variables.size}\n        /&gt;\n        &lt;Slider onChange={value =&gt; this.setSize(value)} /&gt;\n      &lt;/View&gt;\n    );\n  }\n\n  // Update the size of the photo.\n  setSize(photoSize) {\n    // `setVariables()` tells Relay that the component's data requirements have\n    // changed. The value of `props.relay.variables` and `props.user` will\n    // continue to reflect their previous values until the data for the new\n    // variables has been fetched from the server. As soon as data for the new\n    // variables becomes available, the component will re-render with an updated\n    // `user` prop and `variables.size`.\n    this.props.relay.setVariables({\n      size: photoSize,\n    });\n  }\n}</pre>\n<h2 id=\"container-composition\">\nContainer Composition </h2>\n<p>React and Relay support creating arbitrarily complex applications through <em>composition</em>. Larger components can be created by composing smaller components, helping us to create modular, robust applications. There are two aspects to composing components in Relay:</p>\n<ul>\n<li>Composing the view logic, and</li>\n<li>Composing the data descriptions.</li>\n</ul>\n<p>Let's explore how this works via a <code>&lt;Profile&gt;</code> component that composes the <code>&lt;ProfilePicture&gt;</code> from above.</p>\n<h3 id=\"composing-views-it-s-plain-react\">\nComposing Views - It's Plain React </h3>\n<p>View composition is <em>exactly</em> what you're used to â€” Relay containers are standard React components. Here's the <code>&lt;Profile&gt;</code> component:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass Profile extends React.Component {\n  render() {\n    // Expects a `user` with a string `name`, as well as the information\n    // for `&lt;ProfilePicture&gt;` (we'll get that next).\n    var user = this.props.user;\n    return (\n      &lt;View&gt;\n        {/* It works just like a React component, because it is one! */}\n        &lt;ProfilePicture user={user} /&gt;\n        &lt;Text&gt;{user.name}&lt;/Text&gt;\n      &lt;/View&gt;\n    );\n  }\n}</pre>\n<h3 id=\"composing-fragments\">\nComposing Fragments </h3>\n<p>Fragment composition works similarly â€” a parent container's fragment composes the fragment for each of its children. In this case, <code>&lt;Profile&gt;</code> needs to fetch information about the <code>User</code> that is required by <code>&lt;ProfilePicture&gt;</code>.</p>\n<p>Relay containers provide a static <code>getFragment()</code> method that returns a reference to that component's fragment:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass Profile extends React.Component {/* as above */}\n\nmodule.exports = Relay.createContainer(Profile, {\n  fragments: {\n    // This `user` fragment name corresponds to the prop named `user` that is\n    // expected to be populated with server data by the `&lt;Profile&gt;` component.\n    user: () =&gt; Relay.QL`\n      fragment on User {\n        # Specify any fields required by `&lt;Profile&gt;` itself.\n        name,\n\n        # Include a reference to the fragment from the child component. Here,\n        # the `user` is the name of the fragment specified on the child\n        # `&lt;ProfilePicture&gt;`'s `fragments` definition.\n        ${ProfilePicture.getFragment('user')},\n      }\n    `,\n  }\n});</pre>\n<p>The final data declaration is equivalent to the following plain GraphQL:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n`\n  fragment Profile on User {\n    name,\n    ...ProfilePhoto,\n  }\n\n  fragment ProfilePhoto on User {\n    profilePhoto(size: $size) {\n      uri,\n    },\n  }\n`</pre>\n<p>Note that when composing fragments, the type of the composed fragment must match the field on the parent in which it is embedded. For example, it wouldn't make sense to embed a fragment of type <code>Story</code> into a parent's field of type <code>User</code>. Relay and GraphQL will provide helpful error messages if you get this wrong (and if they aren't helpful, let us know!).</p>\n<h2 id=\"rendering-containers\">\nRendering Containers </h2>\n<p>As we've learned, Relay containers declare data requirements as GraphQL fragments. This means that, for example, <code>&lt;ProfilePicture&gt;</code> can be embedded not only in <code>&lt;Profile&gt;</code>, but any container that fetches a field of type <code>User</code>.</p>\n<p>We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the <code>&lt;Profile&gt;</code> fragment in a concrete node of type <code>User</code>.</p>\n<p>In Relay, the root of a query is defined by a <strong>Route</strong>. Continue to learn about Relay routes.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/guides-containers.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/guides-containers.html</a>\n  </p>\n</div>\n","graphql-connections":"<h1>Connection</h1>\n<p>A faction has many ships in the Star Wars universe. Relay contains functionality to make manipulating one-to-many relationships easy, using a standardized way of expressing these one-to-many relationships. This standard connection model offers ways of slicing and paginating through the connection.</p>\n<p>Let's take the rebels, and ask for their first ship:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery RebelsShipsQuery {\n  rebels {\n    name,\n    ships(first: 1) {\n      edges {\n        node {\n          name\n        }\n      }\n    }\n  }\n}</pre>\n<p>yields</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n{\n  \"rebels\": {\n    \"name\": \"Alliance to Restore the Republic\",\n    \"ships\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"name\": \"X-Wing\"\n          }\n        }\n      ]\n    }\n  }\n}</pre>\n<p>That used the <code>first</code> argument to <code>ships</code> to slice the result set down to the first one. But what if we wanted to paginate through it? On each edge, a cursor will be exposed that we can use to paginate. Let's ask for the first two this time, and get the cursor as well:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery MoreRebelShipsQuery {\n  rebels {\n    name,\n    ships(first: 2) {\n      edges {\n        cursor\n        node {\n          name\n        }\n      }\n    }\n  }\n}</pre>\n<p>and we get back</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n{\n  \"rebels\": {\n    \"name\": \"Alliance to Restore the Republic\",\n    \"ships\": {\n      \"edges\": [\n        {\n          \"cursor\": \"YXJyYXljb25uZWN0aW9uOjA=\",\n          \"node\": {\n            \"name\": \"X-Wing\"\n          }\n        },\n        {\n          \"cursor\": \"YXJyYXljb25uZWN0aW9uOjE=\",\n          \"node\": {\n            \"name\": \"Y-Wing\"\n          }\n        }\n      ]\n    }\n  }\n}</pre>\n<p>Notice that the cursor is a base64 string. That's the pattern from earlier: the server is reminding us that this is an opaque string. We can pass this string back to the server as the <code>after</code> argument to the <code>ships</code> field, which will let us ask for the next three ships after the last one in the previous result:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery EndOfRebelShipsQuery {\n  rebels {\n    name,\n    ships(first: 3 after: \"YXJyYXljb25uZWN0aW9uOjE=\") {\n      edges {\n        cursor,\n        node {\n          name\n        }\n      }\n    }\n  }\n}</pre>\n<p>gives us</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n\n{\n  \"rebels\": {\n    \"name\": \"Alliance to Restore the Republic\",\n    \"ships\": {\n      \"edges\": [\n        {\n          \"cursor\": \"YXJyYXljb25uZWN0aW9uOjI=\",\n          \"node\": {\n            \"name\": \"A-Wing\"\n          }\n        },\n        {\n          \"cursor\": \"YXJyYXljb25uZWN0aW9uOjM=\",\n          \"node\": {\n            \"name\": \"Millenium Falcon\"\n          }\n        },\n        {\n          \"cursor\": \"YXJyYXljb25uZWN0aW9uOjQ=\",\n          \"node\": {\n            \"name\": \"Home One\"\n          }\n        }\n      ]\n    }\n  }\n}</pre>\n<p>Sweet! Let's keep going and get the next four!</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery RebelsQuery {\n  rebels {\n    name,\n    ships(first: 4 after: \"YXJyYXljb25uZWN0aW9uOjQ=\") {\n      edges {\n        cursor,\n        node {\n          name\n        }\n      }\n    }\n  }\n}</pre>\n<p>yields</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n{\n  \"rebels\": {\n    \"name\": \"Alliance to Restore the Republic\",\n    \"ships\": {\n      \"edges\": []\n    }\n  }\n}</pre>\n<p>Hm. There were no more ships; guess there were only five in the system for the rebels. It would have been nice to know that we'd reached the end of the connection, without having to do another round trip in order to verify that. The connection model exposes this capability with a type called <code>PageInfo</code>. So let's issue the two queries that got us ships again, but this time ask for <code>hasNextPage</code>:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery EndOfRebelShipsQuery {\n  rebels {\n    name,\n    originalShips: ships(first: 2) {\n      edges {\n        node {\n          name\n        }\n      }\n      pageInfo {\n        hasNextPage\n      }\n    }\n    moreShips: ships(first: 3 after: \"YXJyYXljb25uZWN0aW9uOjE=\") {\n      edges {\n        node {\n          name\n        }\n      }\n      pageInfo {\n        hasNextPage\n      }\n    }\n  }\n}</pre>\n<p>and we get back</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n{\n  \"rebels\": {\n    \"name\": \"Alliance to Restore the Republic\",\n    \"originalShips\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"name\": \"X-Wing\"\n          }\n        },\n        {\n          \"node\": {\n            \"name\": \"Y-Wing\"\n          }\n        }\n      ],\n      \"pageInfo\": {\n        \"hasNextPage\": true\n      }\n    },\n    \"moreShips\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"name\": \"A-Wing\"\n          }\n        },\n        {\n          \"node\": {\n            \"name\": \"Millenium Falcon\"\n          }\n        },\n        {\n          \"node\": {\n            \"name\": \"Home One\"\n          }\n        }\n      ],\n      \"pageInfo\": {\n        \"hasNextPage\": false\n      }\n    }\n  }\n}</pre>\n<p>So on the first query for ships, GraphQL told us there was a next page, but on the next one, it told us we'd reached the end of the connection.</p>\n<p>Relay uses all of this functionality to build out abstractions around connections, to make these easy to work with efficiently without having to manually manage cursors on the client.</p>\n<p>Complete details on how the server should behave are available in the <a href=\"https://facebook.github.io/relay/graphql/connections.htm\">GraphQL Cursor Connections</a> spec.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/graphql-connections.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/graphql-connections.html</a>\n  </p>\n</div>\n","graphql-mutations":"<h1>Mutations</h1>\n<p>Relay uses a common pattern for mutations, where they are root fields on the mutation type with a single argument, <code>input</code>, and where the input and output both contain a client mutation identifier used to reconcile requests and responses.</p>\n<p>By convention, mutations are named as verbs, their inputs are the name with \"Input\" appended at the end, and they return an object that is the name with \"Payload\" appended.</p>\n<p>So for our <code>introduceShip</code> mutation, we create two types: <code>IntroduceShipInput</code> and <code>IntroduceShipPayload</code>:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ninput IntroduceShipInput {\n  factionId: ID!\n  shipName: String!\n  clientMutationId: String!\n}\n\ntype IntroduceShipPayload {\n  faction: Faction\n  ship: Ship\n  clientMutationId: String!\n}</pre>\n<p>With this input and payload, we can issue the following mutation:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nmutation AddBWingQuery($input: IntroduceShipInput!) {\n  introduceShip(input: $input) {\n    ship {\n      id\n      name\n    }\n    faction {\n      name\n    }\n    clientMutationId\n  }\n}</pre>\n<p>with these params:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n{\n  \"input\": {\n    \"shipName\": \"B-Wing\",\n    \"factionId\": \"1\",\n    \"clientMutationId\": \"abcde\"\n  }\n}</pre>\n<p>and we'll get this result:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n{\n  \"introduceShip\": {\n    \"ship\": {\n      \"id\": \"U2hpcDo5\",\n      \"name\": \"B-Wing\"\n    },\n    \"faction\": {\n      \"name\": \"Alliance to Restore the Republic\"\n    },\n    \"clientMutationId\": \"abcde\"\n  }\n}</pre>\n<p>Complete details on how the server should behave are available in the <a href=\"https://facebook.github.io/relay/graphql/mutations.htm\">GraphQL Input Object Mutations</a> spec.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/graphql-mutations.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/graphql-mutations.html</a>\n  </p>\n</div>\n","guides-babel-plugin":"<h1>Babel Relay Plugin</h1>\n<p>Relay uses a <strong>babel</strong> plugin to convert from <code>Relay.QL</code> string templates to JavaScript code that describes each query and includes data from the GraphQL schema.</p>\n<p>While you type queries as follows:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nRelay.QL`\n  fragment on User {\n    # ...\n  }\n`</pre>\n<p>This gets converted into an immediately-invoked function:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n(function() {\n  // Return a description of the query ...\n})();</pre>\n<h2 id=\"usage\">\nUsage </h2>\n<p>The easiest way to get started for now is with the <a href=\"https://github.com/relayjs/relay-starter-kit\">Relay Starter Kit</a> - this includes an example schema file and configures the <a href=\"https://www.npmjs.com/package/babel-relay-plugin\"><code>babel-relay-plugin</code></a> npm module to transpile queries.</p>\n<h3 id=\"react-native-configuration\">\nReact Native Configuration </h3>\n<p>The <code>babel-relay-plugin</code> must run before the <code>react-native</code> Babel preset. Thus, in <code>.babelrc</code> <code>\"react-native\"</code> must come after <code>babelRelayPlugin</code>.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n{\n  \"passPerPreset\": true,\n  \"presets\": [\n    {\"plugins\": [\"./plugins/babelRelayPlugin\"]},\n    \"react-native\"\n  ]\n}</pre>\n<p>The reasoning is that if <code>babel-relay-plugin</code> does not run before the <code>es2015-template-literals</code> transform, it will not transform the Relay.QL template literals correctly. Also in Babel 6, you canâ€™t control plugin order. So in React Native, where plugins in <code>.babelrc</code> are loaded before the projects <code>.babelrc</code>, itâ€™s impossible to use the Babel Relay Plugin without overriding the entire transform list.</p>\n<h2 id=\"advanced-usage\">\nAdvanced Usage </h2>\n<p>If you're not using the starter kit, you'll have to configure <code>babel</code> to use the <code>babel-relay-plugin</code>. The steps are as follows:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n// `babel-relay-plugin` returns a function for creating plugin instances\nconst getBabelRelayPlugin = require('babel-relay-plugin');\n\n// load previously saved schema data (see \"Schema JSON\" below)\nconst schemaData = require('schema.json');\n\n// create a plugin instance\nconst plugin = getBabelRelayPlugin(schemaData);\n\n// compile code with babel using the plugin\nreturn babel.transform(source, {\n  plugins: [plugin],\n});</pre>\n<h2 id=\"schema-json\">\nSchema JSON </h2>\n<p>The plugin needs to understand your schema - <code>schemaData</code> in the above snippet. There are two ways to get this information, depending on the GraphQL implementation.</p>\n<h3 id=\"using-graphql\">\nUsing <code>graphql</code> </h3>\n<p>Use <code>introspectionQuery</code> to generate a Schema JSON for the Babel Relay Plugin, and use <code>printSchema</code> to generate a user readable type system shorthand:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nimport fs from 'fs';\nimport path from 'path';\nimport {graphql}  from 'graphql';\nimport {introspectionQuery, printSchema} from 'graphql/utilities';\n\n// Assume your schema is in ../data/schema\nimport {schema} from '../data/schema';\nconst yourSchemaPath = path.join(__dirname, '../data/schema');\n\n// Save JSON of full schema introspection for Babel Relay Plugin to use\ngraphql(schema, introspectionQuery).then(result =&gt; {\n  fs.writeFileSync(\n    `${yourSchemaPath}.json`,\n    JSON.stringify(result, null, 2)\n  );\n});\n\n// Save user readable type system shorthand of schema\nfs.writeFileSync(\n  `${yourSchemaPath}.graphql`,\n  printSchema(schema)\n);</pre>\n<p>For a complete example of how to load a <code>schema.js</code> file, run the introspection query to get schema information, and save it to a JSON file, check out the <a href=\"https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js\">starter kit</a>.</p>\n<h3 id=\"using-other-graphql-implementations\">\nUsing Other GraphQL Implementations </h3>\n<p>If you're using a different GraphQL server implementation, we recommend adapting the above example to load the schema from your GraphQL server (e.g. via an HTTP request) and then save the result as JSON.</p>\n<p>An example using <code>fetch</code> looks like this:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nconst fetch = require('node-fetch');\nconst fs = require('fs');\nconst {\n  buildClientSchema,\n  introspectionQuery,\n  printSchema,\n} = require('graphql/utilities');\nconst path = require('path');\nconst schemaPath = path.join(__dirname, 'schema');\n\nconst SERVER = 'http://example.com/graphql';\n\n// Save JSON of full schema introspection for Babel Relay Plugin to use\nfetch(`${SERVER}`, {\n  method: 'POST',\n  headers: {\n    'Accept': 'application/json',\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({'query': introspectionQuery}),\n}).then(res =&gt; res.json()).then(schemaJSON =&gt; {\n  fs.writeFileSync(\n    `${schemaPath}.json`,\n    JSON.stringify(schemaJSON, null, 2)\n  );\n\n  // Save user readable type system shorthand of schema\n  const graphQLSchema = buildClientSchema(schemaJSON.data);\n  fs.writeFileSync(\n    `${schemaPath}.graphql`,\n    printSchema(graphQLSchema)\n  );\n});</pre>\n<h2 id=\"additional-options\">\nAdditional Options </h2>\n<p>By default, <code>babel-relay-plugin</code> catches GraphQL validation errors and logs them without exiting. The compiled code will also throw the same errors at runtime, making it obvious that something went wrong whether you're looking at your terminal or browser console.</p>\n<p>When compiling code for production deployment, the plugin can be configured to immediately throw upon encountering a validation problem. The plugin can be further customized for different environments with the following options:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nbabel.transform(source, {\n  plugins: [\n    [getBabelRelayPlugin(schemaData, {\n      // Only if `enforceSchema` is `false` and `debug` is `true`\n      // will validation errors be logged at build time.\n      debug: false,\n      // Suppresses all warnings that would be printed.\n      suppressWarnings: false,\n      // Can add a custom validator.\n      // Supplying one overrides the default one, skipping the default rules.\n      validator: (GraphQL) =&gt; {\n        return (schema, ast) =&gt; {\n          // Return an array of `Error` instances.\n          return [];\n        };\n      },\n    }), {\n    // Will throw an error when it validates the queries at build time.\n    enforceSchema: true,\n    }],\n  ],\n});</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/guides-babel-plugin.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/guides-babel-plugin.html</a>\n  </p>\n</div>\n","api-reference-relay-proptypes":"<h1>Relay.PropTypes</h1>\n<p>Relay introduces two new classes of objects: <code>RelayContainer</code> and <code>Relay.Route</code>. <code>Relay.PropTypes</code> provides prop validators used to assert that props are of these types.</p>\n<h2 id=\"overview\">\nOverview </h2>\n<p><em>Properties</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#example\"> <code>static Container: ReactPropTypeValidator</code> A prop type validator asserting that a prop is a valid Relay container. </a> </li> <li> <a href=\"#example\"> <code>static QueryConfig: ReactPropTypeValidator</code> A prop type validator asserting that a prop is a valid route. </a> </li> </ul> <h2 id=\"example\">\nExample </h2>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass MyApplication extends React.Component {\n  static propTypes = {\n    // Warns if `Component` is not a valid RelayContainer.\n    Component: Relay.PropTypes.Container.isRequired,\n    // Warns if `route` is not a valid route.\n    route: Relay.PropTypes.QueryConfig.isRequired,\n  };\n  render() {\n    return (\n      &lt;Relay.RootContainer\n        Component={this.props.Component}\n        route={this.props.route}\n      /&gt;\n    );\n  }\n}</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/api-reference-relay-proptypes.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/api-reference-relay-proptypes.html</a>\n  </p>\n</div>\n","thinking-in-graphql":"<h1>Thinking in GraphQL</h1>\n<p>GraphQL presents new ways for clients to fetch data by focusing on the needs of product developers and client applications. It provides a way for developers to specify the precise data needed for a view and enables a client to fetch that data in a single network request. Compared to traditional approaches such as REST, GraphQL helps applications to fetch data more efficiently (compared to resource-oriented REST approaches) and avoid duplication of server logic (which can occur with custom endpoints). Furthermore, GraphQL helps developers to decouple product code and server logic. For example, a product can fetch more or less information without requiring a change to every relevant server endpoint. It's a great way to fetch data.</p>\n<p>In this article we'll explore what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems. Along the way we'll look at the design decisions behind Relay and see that it's not just a GraphQL client but also a framework for <em>declarative data-fetching</em>. Let's start at the beginning and fetch some data!</p>\n<h2 id=\"fetching-data\">\nFetching Data </h2>\n<p>Imagine we have a simple application that fetches a list of stories, and some details about each one. Here's how that might look in resource-oriented REST:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n// Fetch the list of story IDs but not their details:\nrest.get('/stories').then(stories =&gt;\n  // This resolves to a list of items with linked resources:\n  // `[ { href: \"http://.../story/1\" }, ... ]`\n  Promise.all(stories.map(story =&gt;\n    rest.get(story.href) // Follow the links\n  ))\n).then(stories =&gt; {\n  // This resolves to a list of story items:\n  // `[ { id: \"...\", text: \"...\" } ]`\n  console.log(stories);\n});</pre>\n<p>Note that this approach requires <em>n+1</em> requests to the server: 1 to fetch the list, and <em>n</em> to fetch each item. With GraphQL we can fetch the same data in a single network request to the server (without creating a custom endpoint that we'd then have to maintain):</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngraphql.get(`query { stories { id, text } }`).then(\n  stories =&gt; {\n    // A list of story items:\n    // `[ { id: \"...\", text: \"...\" } ]`\n    console.log(stories);\n  }\n);</pre>\n<p>So far we're just using GraphQL as a more efficient version of typical REST approaches. Note two important benefits in the GraphQL version:</p>\n<ul>\n<li>All data is fetched in a single round trip.</li>\n<li>The client and server are decoupled: the client specifies the data needed instead of <em>relying on</em> the server endpoint to return the correct data.</li>\n</ul>\n<p>For a simple application that's already a nice improvement.</p>\n<h2 id=\"client-caching\">\nClient Caching </h2>\n<p>Repeatedly refetching information from the server can get quite slow. For example, navigating from the list of stories, to a list item, and back to the list of stories means we have to refetch the whole list. We'll solve this with the standard solution: <em>caching</em>.</p>\n<p>In a resource-oriented REST system, we can maintain a <strong>response cache</strong> based on URIs:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar _cache = new Map();\nrest.get = uri =&gt; {\n  if (!_cache.has(uri)) {\n    _cache.set(uri, fetch(uri));\n  }\n  return _cache.get(uri);\n};</pre>\n<p>Response-caching can also be applied to GraphQL. A basic approach would work similarly to the REST version. The text of the query itself can be used as a cache key:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar _cache = new Map();\ngraphql.get = queryText =&gt; {\n  if (!_cache.has(queryText)) {\n    _cache.set(queryText, fetchGraphQL(queryText));\n  }\n  return _cache.get(queryText);\n};</pre>\n<p>Now, requests for previously cached data can be answered immediately without making a network request. This is a practical approach to improving the perceived performance of an application. However, this method of caching can cause problems with data consistency.</p>\n<h2 id=\"cache-consistency\">\nCache Consistency </h2>\n<p>With GraphQL it is very common for the results of multiple queries to overlap. However, our response cache from the previous section doesn't account for this overlap â€” it caches based on distinct queries. For example, if we issue a query to fetch stories:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery { stories { id, text, likeCount } }</pre>\n<p>and then later refetch one of the stories whose <code>likeCount</code> has since been incremented:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery { story(id: \"123\") { id, text, likeCount } }</pre>\n<p>We'll now see different <code>likeCount</code>s depending on how the story is accessed. A view that uses the first query will see an outdated count, while a view using the second query will see the updated count.</p>\n<h3 id=\"caching-a-graph\">\nCaching A Graph </h3>\n<p>The solution to caching GraphQL is to normalize the hierarchical response into a flat collection of <strong>records</strong>. Relay implements this cache as a map from IDs to records. Each record is a map from field names to field values. Records may also link to other records (allowing it to describe a cyclic graph), and these links are stored as a special value type that references back into the top-level map. With this approach each server record is stored <em>once</em> regardless of how it is fetched.</p>\n<p>Here's an example query that fetches a story's text and its author's name:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery {\n  story(id: \"1\") {\n    text,\n    author {\n      name\n    }\n  }\n}</pre>\n<p>And here's a possible response:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery: {\n  story: {\n     text: \"Relay is open-source!\",\n     author: {\n       name: \"Jan\"\n     }\n  }\n}</pre>\n<p>Although the response is hierarchical, we'll cache it by flattening all the records. Here is an example of how Relay would cache this query response:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nMap {\n  // `story(id: \"1\")`\n  1: Map {\n    text: 'Relay is open-source!',\n    author: Link(2),\n  },\n  // `story.author`\n  2: Map {\n    name: 'Jan',\n  },\n};</pre>\n<p>This is only a simple example: in reality the cache must handle one-to-many associations and pagination (among other things).</p>\n<h3 id=\"using-the-cache\">\nUsing The Cache </h3>\n<p>So how do we use this cache? Let's look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to <code>_cache.has(key)</code> above, but for a graph).</p>\n<h3 id=\"populating-the-cache\">\nPopulating The Cache </h3>\n<p>Populating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records. At first it may seem that the response alone is sufficient to process the response, but in fact this is only true for very simple queries. Consider <code>user(id: \"456\") { photo(size: 32) { uri } }</code> â€” how should we store <code>photo</code>? Using <code>photo</code> as the field name in the cache won't work because a different query might fetch the same field but with different argument values (e.g. <code>photo(size: 64) {...}</code>). A similar issue occurs with pagination. If we fetch the 11th to 20th stories with <code>stories(first: 10, offset: 10)</code>, these new results should be <em>appended</em> to the existing list.</p>\n<p>Therefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel. For example, the <code>photo</code> field from above might be cached with a generated field name such as <code>photo_size(32)</code> in order to uniquely identify the field and its argument values.</p>\n<h3 id=\"reading-from-cache\">\nReading From Cache </h3>\n<p>To read from the cache we can walk a query and resolve each field. But wait: that sounds <em>exactly</em> like what a GraphQL server does when it processes a query. And it is! Reading from the cache is a special case of an executor where a) there's no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous â€” we either have the data cached or we don't.</p>\n<p>Relay implements several variations of <strong>query traversal</strong>: operations that walk a query alongside some other data such as the cache or a response payload. For example, when a query is fetched Relay performs a \"diff\" traversal to determine what fields are missing (much like React diffs virtual DOM trees). This can reduce the amount of data fetched in many common cases and even allow Relay to avoid network requests at all when queries are fully cached.</p>\n<h3 id=\"cache-updates\">\nCache Updates </h3>\n<p>Note that this normalized cache structure allows overlapping results to be cached without duplication. Each record is stored once regardless of how it is fetched. Let's return to the earlier example of inconsistent data and see how this cache helps in that scenario.</p>\n<p>The first query was for a list of stories:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery { stories { id, text, likeCount } }</pre>\n<p>With a normalized response cache, a record would be created for each story in the list. The <code>stories</code> field would store links to each of these records.</p>\n<p>The second query refetched the information for one of those stories:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery { story(id: \"123\") { id, text, likeCount } }</pre>\n<p>When this response is normalized, Relay can detect that this result overlaps with existing data based on its <code>id</code>. Rather than create a new record, Relay will update the existing <code>123</code> record. The new <code>likeCount</code> is therefore available to <em>both</em> queries, as well as any other query that might reference this story.</p>\n<h2 id=\"data-view-consistency\">\nData/View Consistency </h2>\n<p>A normalized cache ensures that the <em>cache</em> is consistent. But what about our views? Ideally, our React views would always reflect the current information from the cache.</p>\n<p>Consider rendering the text and comments of a story along with the corresponding author names and photos. Here's the GraphQL query:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nquery {\n  node(id: \"1\") {\n    text,\n    author { name, photo },\n    comments {\n      text,\n      author { name, photo }\n    }\n  }\n}</pre>\n<p>After initially fetching this story our cache might be as follows. Note that the story and comment both link to the same record as <code>author</code>:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n// Note: This is pseudo-code for `Map` initialization to make the structure\n// more obvious.\nMap {\n  // `story(id: \"1\")`\n  1: Map {\n    author: Link(2),\n    comments: [Link(3)],\n  },\n  // `story.author`\n  2: Map {\n    name: 'Yuzhi',\n    photo: 'http://.../photo1.jpg',\n  },\n  // `story.comments[0]`\n  3: Map {\n    author: Link(2),\n  },\n}</pre>\n<p>The author of this story also commented on it â€” quite common. Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI. Here's the <em>only</em> part of our cached data that changes:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nMap {\n  ...\n  2: Map {\n    ...\n    photo: 'http://.../photo2.jpg',\n  },\n}</pre>\n<p>The value of the <code>photo</code> field has changed; and therefore the record <code>2</code> has also changed. And that's it. Nothing else in the <em>cache</em> is affected. But clearly our <em>view</em> needs to reflect the update: both instances of the author in the UI (as story author and comment author) need to show the new photo.</p>\n<p>A standard response is to \"just use immutable data structures\" â€” but let's see what would happen if we did:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nImmutableMap {\n  1: ImmutableMap {/* same as before */}\n  2: ImmutableMap {\n    ... // other fields unchanged\n    photo: 'http://.../photo2.jpg',\n  },\n  3: ImmutableMap {/* same as before */}\n}</pre>\n<p>If we replace <code>2</code> with a new immutable record, we'll also get a new immutable instance of the cache object. However, records <code>1</code> and <code>3</code> are untouched. Because the data is normalized, we can't tell that <code>story</code>'s contents have changed just by looking at the <code>story</code> record alone.</p>\n<h3 id=\"achieving-view-consistency\">\nAchieving View Consistency </h3>\n<p>There are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (<code>1</code>), the author (<code>2</code>), and the comments (<code>3</code> and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies <em>only</em> the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default <code>shouldComponentUpdate</code>). Without this strategy, every view would re-render for even the tiniest change.</p>\n<p>Note that this solution will also work for <em>writes</em>: any update to the cache will notify the affected views, and writes are just another thing that updates the cache.</p>\n<h2 id=\"mutations\">\nMutations </h2>\n<p>So far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes. In GraphQL, writes are called <strong>mutations</strong>. We can think of them as queries with side effects. Here's an example of calling a mutation that might mark a given story as being liked by the current user:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n// Give a human-readable name and define the types of the inputs,\n// in this case the id of the story to mark as liked.\nmutation StoryLike($storyID: String) {\n   // Call the mutation field and trigger its side effects\n   storyLike(storyID: $storyID) {\n     // Define fields to re-fetch after the mutation completes\n     likeCount\n   }\n}</pre>\n<p>Notice that we're querying for data that <em>may</em> have changed as a result of the mutation. An obvious question is: why can't the server just tell us what changed? The answer is: it's complicated. GraphQL abstracts over <em>any</em> data storage layer (or an aggregation of multiple sources), and works with any programming language. Furthermore, the goal of GraphQL is to provide data in a form that is useful to product developers building a view.</p>\n<p>We've found that it's common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn't always a 1:1 correspondence between data changes in your underlying <em>data storage</em> (disk) and data changes in your <em>product-visible schema</em> (GraphQL). The perfect example of this is privacy: returning a user-facing field such as <code>age</code> might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to <em>see</em> that <code>age</code> (Are we friends? Is my age shared? Did I block you? etc.).</p>\n<p>Given these real-world constraints, the approach in GraphQL is for clients to query for things that may change after a mutation. But what exactly do we put in that query? During the development of Relay we explored several ideas â€” let's look at them briefly in order to understand why Relay uses the approach that it does:</p>\n<ul>\n<li><p>Option 1: Re-fetch everything that the app has ever queried. Even though only a small subset of this data will actually change, we'll still have to wait for the server to execute the <em>entire</em> query, wait to download the results, and wait to process them again. This is very inefficient.</p></li>\n<li><p>Option 2: Re-fetch only the queries required by actively rendered views. This is a slight improvement over option 1. However, cached data that <em>isn't</em> currently being viewed won't be updated. Unless this data is somehow marked as stale or evicted from the cache subsequent queries will read outdated information.</p></li>\n<li><p>Option 3: Re-fetch a fixed list of fields that <em>may</em> change after the mutation. We'll call this list a <strong>fat query</strong>. We found this to also be inefficient because typical applications only render a subset of the fat query, but this approach would require fetching all of those fields.</p></li>\n<li><p>Option 4 (Relay): Re-fetch the intersection of what may change (the fat query) and the data in the cache. In addition to the cache of data Relay also remembers the queries used to fetch each item. These are called <strong>tracked queries</strong>. By intersecting the tracked and fat queries, Relay can query exactly the set of information the application needs to update and nothing more.</p></li>\n</ul>\n<h2 id=\"data-fetching-apis\">\nData-Fetching APIs </h2>\n<p>So far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let's step back and look at some higher-level concerns that product developers often face around data-fetching:</p>\n<ul>\n<li>Fetching all the data for a view hierarchy.</li>\n<li>Managing asynchronous state transitions and coordinating concurrent requests.</li>\n<li>Managing errors.</li>\n<li>Retrying failed requests.</li>\n<li>Updating the local cache after receiving query/mutation responses.</li>\n<li>Queuing mutations to avoid race conditions.</li>\n<li>Optimistically updating the UI while waiting for the server to respond to mutations.</li>\n</ul>\n<p>We've found that typical approaches to data-fetching â€” with imperative APIs â€” force developers to deal with too much of this non-essential complexity. For example, consider <em>optimistic UI updates</em>. This is a way of giving the user feedback while waiting for a server response. The logic of <em>what</em> to do can be quite clear: when the user clicks \"like\", mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for data-fetching: specifying <em>what</em> data we need often dictates <em>how</em> and <em>when</em> it is fetched. Next, we'll explore our approach to solving these concerns with <strong>Relay</strong>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/thinking-in-graphql.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/thinking-in-graphql.html</a>\n  </p>\n</div>\n","interfaces-relay-mutation-request":"<h1>RelayMutationRequest</h1>\n<p><code>RelayMutationRequest</code> encapsulates a mutation that Relay needs to send to the server. They are made available to network layers via the <code>sendMutation</code> method.</p>\n<h2 id=\"overview\">\nOverview </h2>\n<p><em>Methods</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#getquerystring\"> <code>getQueryString()</code> </a> </li> <li> <a href=\"#getvariables\"> <code>getVariables()</code> </a> </li> <li> <a href=\"#getfiles\"> <code>getFiles()</code> </a> </li> <li> <a href=\"#getid\"> <code>getID()</code> </a> </li> <li> <a href=\"#getdebugname\"> <code>getDebugName()</code> </a> </li> </ul> <h2 id=\"methods\">\nMethods </h2>\n<h3 id=\"getquerystring\">\ngetQueryString </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetQueryString(): string</pre>\n<p>Gets a string representation of the GraphQL mutation.</p>\n<h3 id=\"getvariables\">\ngetVariables </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetVariables(): {[name: string]: mixed}</pre>\n<p>Gets the variables used by the mutation. These variables should be serialized and send in the GraphQL request.</p>\n<h3 id=\"getfiles\">\ngetFiles </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetFiles(): ?{[key: string]: File}</pre>\n<p>Gets an optional map from name to File objects.</p>\n<h3 id=\"getid\">\ngetID </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetID(): string</pre>\n<p>Gets a unique identifier for this mutation. These identifiers are useful for assigning response payloads to their corresponding mutations when sent in a single GraphQL request.</p>\n<h3 id=\"getdebugname\">\ngetDebugName </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetDebugName(): string</pre>\n<p>Gets a string name used to refer to this request for printing debug output.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/interfaces-relay-mutation-request.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/interfaces-relay-mutation-request.html</a>\n  </p>\n</div>\n","interfaces-relay-query-request":"<h1>RelayQueryRequest</h1>\n<p><code>RelayQueryRequest</code> encapsulates a query that Relay needs to send to the server. They are made available to network layers via the <code>sendQueries</code> method.</p>\n<h2 id=\"overview\">\nOverview </h2>\n<p><em>Methods</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#getquerystring\"> <code>getQueryString()</code> </a> </li> <li> <a href=\"#getvariables\"> <code>getVariables()</code> </a> </li> <li> <a href=\"#getid\"> <code>getID()</code> </a> </li> <li> <a href=\"#getdebugname\"> <code>getDebugName()</code> </a> </li> </ul> <h2 id=\"methods\">\nMethods </h2>\n<h3 id=\"getquerystring\">\ngetQueryString </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetQueryString(): string</pre>\n<p>Gets a string representation of the GraphQL query.</p>\n<h3 id=\"getvariables\">\ngetVariables </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetVariables(): {[name: string]: mixed}</pre>\n<p>Gets the variables used by the query. These variables should be serialized and sent in the GraphQL request.</p>\n<h3 id=\"getid\">\ngetID </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetID(): string</pre>\n<p>Gets a unique identifier for this query. These identifiers are useful for assigning response payloads to their corresponding queries when sent in a single GraphQL request.</p>\n<h3 id=\"getdebugname\">\ngetDebugName </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetDebugName(): string</pre>\n<p>Gets a string name used to refer to this request for printing debug output.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/interfaces-relay-query-request.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/interfaces-relay-query-request.html</a>\n  </p>\n</div>\n","api-reference-relay-store":"<h1>Relay.Store</h1>\n<p>The Relay <code>Store</code> provides an API for dispatching mutations to the server.</p>\n<h2 id=\"overview\">\nOverview </h2>\n<p><em>Methods</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#commitupdate-static-method\"> <code>static commitUpdate(mutation, callbacks)</code> Initiate processing of a mutation. </a> </li> <li> <a href=\"#applyupdate-static-method\"> <code>static applyUpdate(mutation, callbacks)</code> Adds a MutationTransaction to the queue without committing it. </a> </li> </ul> <p><strong>Note:</strong> Equivalent <code>applyUpdate</code> and <code>commitUpdate</code> methods are also provided on the <code>this.props.relay</code> prop that is passed to components by <code>Relay.Container</code>. These dispatch mutations in the context of the currently active <code>Relay.Environment</code>.</p>\n<h2 id=\"methods\">\nMethods </h2>\n<h3 id=\"commitupdate-static-method\">\ncommitUpdate (static method) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nstatic commitUpdate(mutation: RelayMutation, callbacks: {\n  onFailure?: (transaction: RelayMutationTransaction) =&gt; void;\n  onSuccess?: (response: Object) =&gt; void;\n}): RelayMutationTransaction\n\n// Argument to `onFailure` callback\ntype Transaction = {\n  getError(): ?Error;\n}</pre>\n<p>The <code>commitUpdate</code> method is analogous to dispatching an action in Flux. Relay processes the mutation as follows:</p>\n<ul>\n<li>If the mutation defines an optimistic payload - a set of data to apply locally while waiting for the server response - Relay applies this change and updates any affected React components (note that optimistic updates do not overwrite known server data in the cache).</li>\n<li>If the mutation would not 'collide' (overlap) with other pending mutations - as specified by its <code>getCollisionKey</code> implementation - it is sent to the server. If it would conflict, it is enqueued until conflicting mutations have completed.</li>\n<li>When the server response is received, one of the callbacks is invoked:<ul>\n<li>\n<code>onSuccess</code> is called if the mutation succeeded.</li>\n<li>\n<code>onFailure</code> is called if the mutation failed.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"commitupdate-static-method-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar onSuccess = () =&gt; {\n  console.log('Mutation successful!');\n};\nvar onFailure = (transaction) =&gt; {\n  var error = transaction.getError() || new Error('Mutation failed.');\n  console.error(error);\n};\nvar mutation = new MyMutation({...});\n\nRelay.Store.commitUpdate(mutation, {onFailure, onSuccess});</pre>\n<h3 id=\"applyupdate-static-method\">\napplyUpdate (static method) </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nstatic applyUpdate(mutation: RelayMutation, callbacks: {\n  onFailure?: (transaction: RelayMutationTransaction) =&gt; void;\n  onSuccess?: (response: Object) =&gt; void;\n}): RelayMutationTransaction</pre>\n<p>The <code>applyUpdate</code> adds a mutation just like <code>update</code>, but does not commit it. It returns a <code>RelayMutationTransaction</code> that can be committed or rollbacked.</p>\n<p>When the transaction is committed and the response is received from the server, one of the callbacks is invoked: - <code>onSuccess</code> is called if the mutation succeeded. - <code>onFailure</code> is called if the mutation failed.</p>\n<h4 id=\"applyupdate-static-method-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar onSuccess = () =&gt; {\n  console.log('Mutation successful!');\n};\nvar onFailure = (transaction) =&gt; {\n  var error = transaction.getError() || new Error('Mutation failed.');\n  console.error(error);\n};\nvar mutation = new MyMutation({...});\n\nvar transaction = Relay.Store.applyUpdate(mutation, {onFailure, onSuccess});\n\ntransaction.commit();</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/api-reference-relay-store.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/api-reference-relay-store.html</a>\n  </p>\n</div>\n","api-reference-relay-root-container":"<h1>Relay.RootContainer</h1>\n<p><strong>Relay.RootContainer</strong> is a React component that attempts to fulfill the data required in order to render an instance of <code>Component</code> for a given <code>route</code>.</p>\n<h2 id=\"overview\">\nOverview </h2>\n<p><em>Props</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#component\"> <code>Component</code> Relay container that defines fragments and the view to render. </a> </li> <li> <a href=\"#route\"> <code>route</code> Route that defines the query roots. </a> </li> <li> <a href=\"#forcefetch\"> <code>forceFetch</code> Whether to send a server request regardless of data available on the client. </a> </li> <li> <a href=\"#renderloading\"> <code>renderLoading</code> Called to render when data requirements are being fulfilled. </a> </li> <li> <a href=\"#renderfetched\"> <code>renderFetched</code> Called to render when data requirements are fulfilled. </a> </li> <li> <a href=\"#renderfailure\"> <code>renderFailure</code> Called to render when data failed to be fulfilled. </a> </li> <li> <a href=\"#onreadystatechange\"> <code>onReadyStateChange</code> </a> </li> </ul> <h2 id=\"props\">\nProps </h2>\n<h3 id=\"component\">\nComponent </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nComponent: RelayContainer</pre>\n<p>Must be a valid <code>RelayContainer</code>. Relay will attempt to fulfill its data requirements before rendering it.</p>\n<p>See also: <a href=\"guides-root-container#component-and-route\">Root Container &gt; Component and Route</a></p>\n<h3 id=\"route\">\nroute </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nroute: RelayRoute</pre>\n<p>Either an instance of <code>Relay.Route</code> or an object with the <code>name</code>, <code>queries</code>, and optionally the <code>params</code> properties.</p>\n<p>See also: <a href=\"guides-root-container#component-and-route\">Root Container &gt; Component and Route</a></p>\n<h3 id=\"forcefetch\">\nforceFetch </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nforceFetch: boolean</pre>\n<p>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available to immediately fulfill the data requirements.</p>\n<p>See also: <a href=\"guides-root-container#force-fetching\">Root Container &gt; Force Fetching</a></p>\n<h3 id=\"renderloading\">\nrenderLoading </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nrenderLoading(): ?ReactElement</pre>\n<p>When data requirements have yet to be fulfilled, <code>renderLoading</code> is called to render the view. If this returns <code>undefined</code>, the previously rendered view (or nothing if there is no previous view) is rendered.</p>\n<h4 id=\"renderloading-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n&lt;Relay.RootContainer\n  Component={ProfilePicture}\n  route={profileRoute}\n  renderLoading={function() {\n    return &lt;div&gt;Loading...&lt;/div&gt;;\n  }}\n/&gt;</pre>\n<p>See also: <a href=\"guides-root-container#renderloading\">Root Container &gt; renderLoading</a></p>\n<h3 id=\"renderfetched\">\nrenderFetched </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nrenderFetched(\n  data: {[propName: string]: $RelayData},\n  readyState: {stale: boolean}\n): ?ReactElement</pre>\n<p>When all data requirements are fulfilled, <code>renderFetched</code> is called to render the view. This callback is expected to spread <code>data</code> into the supplied <code>Container</code> when rendering it.</p>\n<h4 id=\"renderfetched-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n&lt;Relay.RootContainer\n  Component={ProfilePicture}\n  route={profileRoute}\n  renderFetched={function(data) {\n    return (\n      &lt;ScrollView&gt;\n        &lt;ProfilePicture {...data} /&gt;\n      &lt;/ScrollView&gt;\n    );\n  }}\n/&gt;</pre>\n<p>See also: <a href=\"guides-root-container#renderfetched\">Root Container &gt; renderFetched</a></p>\n<h3 id=\"renderfailure\">\nrenderFailure </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nrenderFailure(error: Error, retry: Function): ?ReactElement</pre>\n<p>When data requirements failed to be fulfilled, <code>renderFailure</code> is called to render the view.</p>\n<h4 id=\"renderfailure-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n&lt;Relay.RootContainer\n  Component={ProfilePicture}\n  route={profileRoute}\n  renderFailure={function(error, retry) {\n    return (\n      &lt;div&gt;\n        &lt;p&gt;{error.message}&lt;/p&gt;\n        &lt;p&gt;&lt;button onClick={retry}&gt;Retry?&lt;/button&gt;&lt;/p&gt;\n      &lt;/div&gt;\n    );\n  }}\n/&gt;</pre>\n<p>See also: <a href=\"guides-root-container#renderfailure\">Root Container &gt; renderFailure</a></p>\n<h3 id=\"onreadystatechange\">\nonReadyStateChange </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nonReadyStateChange(\n  readyState: {\n    aborted: boolean;\n    done: boolean;\n    error: ?Error;\n    events: Array&lt;ReadyStateEvent&gt;;\n    ready: boolean;\n    stale: boolean;\n  }\n): void</pre>\n<p>This callback prop is called as the various events of data resolution occurs.</p>\n<p>See also: <a href=\"guides-ready-state\">Ready State</a></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/api-reference-relay-root-container.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/api-reference-relay-root-container.html</a>\n  </p>\n</div>\n","interfaces-relay-network-layer":"<h1>RelayNetworkLayer</h1>\n<p>Custom network layers that must conform to the <code>RelayNetworkLayer</code> interface.</p>\n<h2 id=\"overview\">\nOverview </h2>\n<p><em>Methods</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#sendmutation\"> <code>sendMutation(mutationRequest)</code> </a> </li> <li> <a href=\"#sendqueries\"> <code>sendQueries(queryRequests)</code> </a> </li> <li> <a href=\"#supports\"> <code>supports(...options)</code> </a> </li> </ul> <h2 id=\"methods\">\nMethods </h2>\n<h3 id=\"sendmutation\">\nsendMutation </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nsendMutation(mutationRequest: RelayMutationRequest): ?Promise</pre>\n<p>Implement this method to send mutations to the server. When the server response is obtained, this method must either call <code>mutationRequest.resolve</code> with the response data, or <code>mutationRequest.reject</code> with an <code>Error</code> object.</p>\n<p>This method can optionally return a promise in order to facilitate proper error propagation.</p>\n<h4 id=\"sendmutation-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nsendMutation(mutationRequest) {\n  return fetch(...).then(result =&gt; {\n    if (result.errors) {\n      mutationRequest.reject(new Error(...))\n    } else {\n      mutationRequest.resolve({response: result.data});\n    }\n  });\n}</pre>\n<p>See <a href=\"interfaces-relay-mutation-request\">RelayMutationRequest</a> for methods available on the argument object.</p>\n<h3 id=\"sendqueries\">\nsendQueries </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nsendQueries(queryRequests: Array&lt;RelayQueryRequest&gt;): ?Promise</pre>\n<p>Implement this method to send queries to the server. For each query request, when the server response is received, this method must either call <code>resolve</code> with the response data, or <code>reject</code> with an <code>Error</code> object.</p>\n<p>This method receives an array of queries (instead of a single query) in order to facilitate batching queries to improve network efficiency.</p>\n<p>This method can optionally return a promise in order to facilitate proper error propagation.</p>\n<h4 id=\"sendqueries-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nsendQueries(queryRequests) {\n  return Promise.all(queryRequests.map(\n    queryRequest =&gt; fetch(...).then(result =&gt; {\n      if (result.errors) {\n        queryRequest.reject(new Error(...));\n      } else {\n        queryRequest.resolve({response: result.data});\n      }\n    })\n  ));\n}</pre>\n<p>See <a href=\"interfaces-relay-query-request\">RelayQueryRequest</a> for methods available on the argument objects.</p>\n<h3 id=\"supports\">\nsupports </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nsupports(...options: Array&lt;string&gt;): boolean</pre>\n<p>Implement this method to return true when the supplied options are supported by this network layer. This is used to declare which features the network layer supports.</p>\n<p>In the future, advanced capabilities in Relay may be dependent on the network layer being able to support certain features.</p>\n<h4 id=\"supports-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nsupports(...options) {\n  return options.every(option =&gt; {\n    if (option === 'future-feature') {\n      return true;\n    }\n    return false;\n  });\n}</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/interfaces-relay-network-layer.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/interfaces-relay-network-layer.html</a>\n  </p>\n</div>\n","api-reference-relay-container":"<h1>RelayContainer</h1>\n<p><code>RelayContainer</code> is a higher-order React component that lets a React component encode its data requirements.</p>\n<ul>\n<li>Relay ensures that this data is available before the component is rendered.</li>\n<li>Relay updates the component whenever the underlying data has changed.</li>\n</ul>\n<p>Relay containers are created using <code>Relay.createContainer</code>.</p>\n<h2 id=\"overview\">\nOverview </h2>\n<p><em>Container Specification</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#fragments\"> <code>fragments</code> Declare the component's data requirements using fragments. </a> </li> <li> <a href=\"#initialvariables\"> <code>initialVariables</code> The initial set of variable values available to this component's fragments. </a> </li> <li> <a href=\"#preparevariables\"> <code>prepareVariables</code> A method to modify the variables based on the runtime environment or previous variable values. </a> </li> <li> <a href=\"#shouldcomponentupdate\"> <code>shouldComponentUpdate</code> Optionally override RelayContainer's default implementation of `shouldComponentUpdate`. </a> </li> </ul> <p><em>Properties and Methods</em></p>\n<p>These are the methods and properties that the container will provide as <code>this.props.relay</code> in the plain React component.</p>\n<ul class=\"apiIndex\"> <li> <a href=\"#route\"> <code>route</code> </a> </li> <li> <a href=\"#pendingvariables\"> <code>pendingVariables </code> </a> </li> <li> <a href=\"#variables\"> <code>variables</code> </a> </li> <li> <a href=\"#setvariables\"> <code>setVariables([partialVariables[, onReadyStateChange]])</code> </a> </li> <li> <a href=\"#forcefetch\"> <code>forceFetch([partialVariables[, onReadyStateChange]]) </code> </a> </li> <li> <a href=\"#hasoptimisticupdate\"> <code>hasOptimisticUpdate(record)</code> </a> </li> <li> <a href=\"#getpendingtransactions\"> <code>getPendingTransactions(record) </code> </a> </li> </ul> <p><em>Static Methods</em></p>\n<ul class=\"apiIndex\"> <li> <a href=\"#getfragment\"> <code>getFragment(name[, vars])</code> Get a reference to a container fragment for inclusion in a parent fragment. </a> </li> </ul> <h2 id=\"container-specification\">\nContainer Specification </h2>\n<h3 id=\"fragments\">\nfragments </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nfragments: RelayQueryFragments&lt;Tk&gt; = {\n  [propName: string]: (\n    variables: {[name: string]: mixed}\n  ) =&gt; Relay.QL`fragment on ...`\n};</pre>\n<p>Containers declare data requirements on <code>fragments</code> using GraphQL fragments.</p>\n<p>Only fields specified by these fragments will be populated in <code>this.props</code> when the component is rendered. This ensures that there are no implicit dependencies from a component on its parent component or any child components.</p>\n<h4 id=\"fragments-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass StarWarsShip extends React.Component {\n  render() {\n    return &lt;div&gt;{this.props.ship.name}&lt;/div&gt;;\n  }\n}\n\nmodule.exports = Relay.createContainer(StarWarsShip, {\n  fragments: {\n    ship: () =&gt; Relay.QL`\n      fragment on Ship {\n        name\n      }\n    `,\n  },\n});</pre>\n<p>In this example, the fields associated with the <code>ship</code> fragment will be made available on <code>this.props.ship</code>.</p>\n<p>See also: <a href=\"guides-containers#relay-containers\">Containers &gt; Relay Containers</a></p>\n<h3 id=\"initialvariables\">\ninitialVariables </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ninitialVariables: {[name: string]: mixed};</pre>\n<p>The initial set of variable values available to this component's fragments.</p>\n<h4 id=\"initialvariables-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass ProfilePicture extends React.Component {...}\n\nmodule.exports = Relay.createContainer(ProfilePicture, {\n  initialVariables: {size: 50},\n  fragments: {\n    user: () =&gt; Relay.QL`\n      # The variable defined above is available here as `$size`.\n      # Any variable referenced here is required to have been defined in initialVariables above.\n      # An `undefined` variable value will throw an `Invariant Violation` exception.\n      # Use `null` to initialize unknown values.\n      fragment on User { profilePicture(size: $size) { ... } }\n    `,\n  },\n});</pre>\n<p>In this example, <code>profilePicture(size: 50)</code> will be fetched for the intial render.</p>\n<h3 id=\"preparevariables\">\nprepareVariables </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nprepareVariables: ?(\n  prevVariables: {[name: string]: mixed}\n) =&gt; {[name: string]: mixed}</pre>\n<p>Containers can define a <code>prepareVariables</code> method which provides the opportunity to modify the variables that are available to fragments. The new variables can be generated based on the previous variables (or the <code>initialVariables</code> if no previous ones exist) in addition to the runtime environment.</p>\n<p>This method is also called after the partial set of variables from <code>setVariables</code> has been applied. The variables returned are used to populate the fragments.</p>\n<h4 id=\"preparevariables-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nmodule.exports = Relay.createContainer(ProfilePicture, {\n  initialVariables: {size: 50},\n  prepareVariables: prevVariables =&gt; {\n    return {\n      ...prevVariables,\n      // If devicePixelRatio is `2`, the new size will be `100`.\n      size: prevVariables.size * window.devicePixelRatio,\n    };\n  },\n  // ...\n});</pre>\n<h3 id=\"shouldcomponentupdate\">\nshouldComponentUpdate </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nshouldComponentUpdate: () =&gt; boolean;</pre>\n<p>RelayContainer implements a conservative default <code>shouldComponentUpdate</code> that returns <code>false</code> if no fragment props have changed and all other props are equal scalar values. This may block updates to components that receive data via context. To ensure an update in this case override the default behavior by specifying a <code>shouldComponentUpdate</code> function.</p>\n<h4 id=\"shouldcomponentupdate-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nmodule.exports = Relay.createContainer(ProfilePicture, {\n  shouldComponentUpdate: () =&gt; true,\n  // ...\n});</pre>\n<h2 id=\"properties-and-methods\">\nProperties and Methods </h2>\n<p>The properties and methods listed below can be accessed on <code>this.props.relay</code> from the wrapped React component.</p>\n<h3 id=\"route\">\nroute </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nroute: RelayRoute</pre>\n<p>Route is useful in providing the context which a component is being rendered in. It includes information about the <code>name</code>, <code>params</code>, and <code>queries</code> of the current route.</p>\n<h4 id=\"route-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvar name = this.props.relay.route.name;\nif (name === 'SuperAwesomeRoute') {\n  // Do something super cool.\n}</pre>\n<p>See also: <a href=\"guides-routes\">Routes</a></p>\n<h3 id=\"variables\">\nvariables </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nvariables: {[name: string]: mixed}</pre>\n<p><code>variables</code> contains the set of variables that was used to fetch the current set of props.</p>\n<h4 id=\"variables-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass ProfilePicture extends React.Component {\n  render() {\n    var user = this.props.user;\n    return (\n      &lt;View&gt;\n        &lt;Image\n          uri={user.profilePicture.uri}\n          width={this.props.relay.variables.size}\n        /&gt;\n      &lt;/View&gt;\n    );\n  }\n}\nmodule.exports = Relay.createContainer(ProfilePicture, {\n  initialVariables: {size: 50},\n  fragments: {\n    user: () =&gt; Relay.QL`\n      fragment on User { profilePicture(size: $size) { ... } }\n    `,\n  },\n});</pre>\n<p>In this example, the <code>width</code> of the rendered image will always correspond to the <code>$size</code> variable used to fetch the current version of <code>profilePicture.uri</code>.</p>\n<blockquote>\n<p>Note</p>\n<p>Never mutate <code>this.props.relay.variables</code> directly as it will not trigger data to be fetched properly. Treat <code>this.props.relay.variables</code> as if it were immutable, just like props.</p>\n</blockquote>\n<h3 id=\"pendingvariables\">\npendingVariables </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\npendingVariables: ?{[name: string]: mixed}</pre>\n<p><code>pendingVariables</code> contains the set of variables that are being used to fetch the new props, i.e. when <code>this.props.relay.setVariables()</code> or <code>this.props.relay.forceFetch()</code> are called and the corresponding request is in flight.</p>\n<p>If no request is in flight pendingVariables is <code>null</code>.</p>\n<h4 id=\"pendingvariables-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass ProfilePicture extends React.Component {\n  requestRandomPictureSize = () =&gt; {\n    const randIntMin = 10;\n    const randIntMax = 200;\n    const size = (Math.floor(Math.random() * (randIntMax - randIntMin + 1)) + randIntMin);\n    this.props.relay.setVariables({size});\n  }\n\n  render() {\n    const {relay, user} = this.props;\n    const {pendingVariables} = relay;\n    if (pendingVariables &amp;&amp; 'size' in pendingVariables) {\n      // Profile picture with new size is loading\n      return (\n        &lt;View&gt;\n          &lt;LoadingSpinner /&gt;\n        &lt;/View&gt;\n      )\n    }\n\n    return (\n      &lt;View&gt;\n        &lt;Image\n          uri={user.profilePicture.uri}\n          width={relay.variables.size}\n        /&gt;\n        &lt;button onclick={this.requestRandomPictureSize}&gt;\n          Request random picture size\n        &lt;/button&gt;\n      &lt;/View&gt;\n    );\n  }\n}\nmodule.exports = Relay.createContainer(ProfilePicture, {\n  initialVariables: {size: 50},\n  fragments: {\n    user: () =&gt; Relay.QL`\n      fragment on User { profilePicture(size: $size) { ... } }\n    `,\n  },\n});</pre>\n<p>In this example, whenever a picture with a new size is being loaded a spinner is displayed instead of the picture.</p>\n<h3 id=\"setvariables\">\nsetVariables </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nsetVariables([partialVariables: Object, [onReadyStateChange: Function]]): void</pre>\n<p>Components can change their data requirements by using <code>setVariables</code> to request an update to the current set of <code>variables</code>.</p>\n<p><code>this.props.relay.setVariables</code> can be called to update a subset or all of the variables at the same time. In return, Relay will use the new variables to attempt to fulfill the new fragment. This may involve sending a request to the server if data is not already available on the client.</p>\n<p>An optional <code>onReadyStateChange</code> callback can be supplied to respond to the events involved with the data fulfillment.</p>\n<h4 id=\"setvariables-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass Feed extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        {this.props.viewer.feed.edges.map(\n          edge =&gt; &lt;Story story={edge.node} key={edge.node.id} /&gt;\n        )}\n      &lt;/div&gt;\n    );\n  }\n  _handleScrollLoad() {\n    // Increments the number of stories being rendered by 10.\n    this.props.relay.setVariables({\n      count: this.props.relay.variables.count + 10\n    });\n  }\n}\nmodule.exports = Relay.createContainer(Feed, {\n  initialVariables: {count: 10},\n  fragments: {\n    viewer: () =&gt; Relay.QL`\n      fragment on Viewer {\n        feed(first: $count) {\n          edges {\n            node {\n              id,\n              ${Story.getFragment('story')},\n            },\n          },\n        },\n      }\n    `,\n  },\n});</pre>\n<blockquote>\n<p>Note</p>\n<p><code>setVariables</code> does not immediately mutate <code>variables</code>, but creates a pending state transition. <code>variables</code> will continue returning the previous values until <code>this.props</code> has been populated with data that fulfills the new variable values.</p>\n</blockquote>\n<p>See also: <a href=\"guides-containers#requesting-different-data\">Containers &gt; Requesting Different Data</a>, <a href=\"guides-ready-state\">Ready State</a></p>\n<h3 id=\"forcefetch\">\nforceFetch </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nforceFetch([partialVariables: Object, [onReadyStateChange: Function]]): void</pre>\n<p><code>forceFetch</code> is similar to <code>setVariables</code> because it is also used to change the data requirements by altering <code>variables</code>.</p>\n<p>The two methods differ in that instead of sending a query that includes only fields missing from the client, <code>forceFetch</code> sends a request to refetch each and every fragment. This ensures that the props for the component are freshly fetched from the server.</p>\n<p>An optional <code>onReadyStateChange</code> callback can be supplied to respond to the events involved with the data fulfillment.</p>\n<blockquote>\n<p>Note</p>\n<p><code>forceFetch</code> can be called with an empty set of partial variables, meaning it can trigger a refresh of the currently rendered set of data.</p>\n</blockquote>\n<p>See also: <a href=\"guides-ready-state\">Ready State</a></p>\n<h3 id=\"hasoptimisticupdate\">\nhasOptimisticUpdate </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nhasOptimisticUpdate(record: Object): boolean</pre>\n<p>Calling <code>hasOptimisticUpdate</code> with a record from <code>this.props</code> will return whether that given record is affected by an optimistic mutation. It allows the component to render local optimistic changes differently from data that has successfully synchronized with the server.</p>\n<h4 id=\"hasoptimisticupdate-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass Feed extends React.Component {\n  render() {\n    var edges = this.props.viewer.feed.edges;\n    return (\n      &lt;div&gt;\n        {edges.map(edge =&gt; {\n          var node = edge.node;\n          if (this.props.relay.hasOptimisticUpdate(node)) {\n            // Render pending story that has not been stored\n            // on the server using a diffrent component.\n            return (\n              &lt;PendingStory\n                key={edge.node.id}\n                story={edge.node}\n              /&gt;\n            );\n          } else {\n            return (\n              &lt;Story\n                key={edge.node.id}\n                story={edge.node}\n              /&gt;\n            );\n          }\n        })}\n      &lt;/div&gt;\n    );\n  }\n}\n\nmodule.exports = Relay.createContainer(Feed, {\n  initialVariables: {count: 10},\n  fragments: {\n    viewer: () =&gt; Relay.QL`\n      fragment on Viewer {\n        feed(first: $count) {\n          edges {\n            node {\n              id,\n              ${Story.getFragment('story')},\n              ${PendingStory.getFragment('story')}\n            }\n          }\n        }\n      }\n    `,\n  },\n});</pre>\n<p>See also: <a href=\"guides-mutations#optimistic-updates\">Mutations &gt; Optimistic Updates</a></p>\n<h3 id=\"getpendingtransactions\">\ngetPendingTransactions </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetPendingTransactions(record: Object): ?Array&lt;RelayMutationTransaction&gt;</pre>\n<p>Components can inspect pending mutations on any record (i.e. data made available in props with a corresponding fragment). Calling <code>getPendingTransactions</code> with a record will return a list of the pending mutation transactions that affect that particular record.</p>\n<p>Each <code>RelayMutationTransaction</code> has methods to check the status of the mutation and provide ways to rollback or resend the mutation as needed.</p>\n<h4 id=\"getpendingtransactions-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass Story extends React.Component {\n  render() {\n    var story = this.props.story;\n    var transactions = this.props.relay.getPendingTransactions(story);\n    // For this example, assume there is only one transaction.\n    var transaction = transactions ? transactions[0] : null;\n    if (transaction) {\n      // Display an error message with a retry link if a mutation failed.\n      if (transaction.getStatus() === 'COMMIT_FAILED') {\n        return (\n          &lt;span&gt;\n            This story failed to post.\n            &lt;a onClick={transaction.recommit}&gt;Try Again.&lt;/a&gt;\n          &lt;/span&gt;\n        );\n      }\n    }\n    // Render story normally.\n  }\n}\n\nmodule.exports = Relay.createContainer(ProfilePicture, {\n  fragments: {\n    story: () =&gt; Relay.QL`\n      fragment on story {\n        # ...\n      }\n    `,\n  },\n});</pre>\n<p><code>RelayMutationTransaction.getStatus</code> can return one of the following strings:</p>\n<ul>\n<li>\n<code>UNCOMMITTED</code> â€” Transaction hasn't yet been sent to the server. Transaction can be committed or rolled back.</li>\n<li>\n<code>COMMIT_QUEUED</code> â€” Transaction was committed but another transaction with the same collision key is pending, so the transaction has been queued to send to the server.</li>\n<li>\n<code>COLLISION_COMMIT_FAILED</code> â€” Transaction was queued for commit but another transaction with the same collision key failed. All transactions in the collision queue, including this one, have been failed. Transaction can be recommitted or rolled back.</li>\n<li>\n<code>COMMITTING</code> â€” Transaction is waiting for the server to respond.</li>\n<li>\n<code>COMMIT_FAILED</code> â€” Transaction was sent to the server for comitting but failed.</li>\n</ul>\n<h2 id=\"static-methods\">\nStatic Methods </h2>\n<h3 id=\"getfragment\">\ngetFragment </h3>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\ngetFragment(\n  fragmentName: string, \n  variables?: {[name: string]: mixed}\n): RelayFragmentReference</pre>\n<p>Gets a reference to a child container's fragment for inclusion in a parent fragment.</p>\n<h4 id=\"getfragment-example\">\nExample </h4>\n<p>Fragment composition is achieved via ES6 template string interpolation and <code>getFragment</code>: </p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n// Parent.js\nRelay.createContainer(Parent, {\n  fragments: {\n    parentFragment: () =&gt; Relay.QL`\n      fragment on Foo {\n        id\n        ${Child.getFragment('childFragment')}\n      }\n    `,\n  }\n});\n// Child.js\nRelay.createContainer(Child, {\n  initialVariables: {\n    size: 64,\n  },\n  fragments: {\n    childFragment: () =&gt; Relay.QL`\n      fragment on Foo {\n        photo(size: $size) { uri }\n      }\n    `,\n  }\n});</pre>\n<p>In this example, whenever <code>Parent</code> is fetched, <code>Child</code>'s fragment will also be fetched. When rendering, <code>&lt;Parent&gt;</code> will only have access to the <code>props.foo.id</code> field; data from the child fragment will be <a href=\"http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking\"><em>masked</em></a>. By default, <code>childFragment</code> will use its corresponding initial variables. Relay will fetch <code>photo(size: 64)</code>. When <code>&lt;Child&gt;</code> is rendered it will also make the initial variables available as <code>props.relay.variables = {size: 64}</code>.</p>\n<h4 id=\"getfragment-overriding-fragment-variables\">\nOverriding Fragment Variables </h4>\n<p>Sometimes a parent needs to override the default variables of a child component. Imagine that we want to render <code>Child</code> above with a photo size of 128 instead of the default 64. To do this, we have to ensure that both the fragment <em>and</em> the container know about the custom variable. To set a custom variable in the <em>query</em>, use the second argument to <code>getFragment</code>:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\n// Parent.js\nRelay.createContainer(Parent, {\n  fragments: {\n    parentFragment: () =&gt; Relay.QL`\n      fragment on Foo {\n        id\n        ${Child.getFragment('childFragment', {size: 128})}\n      }\n    `,\n  }\n});</pre>\n<p>Now Relay will fetch the photo with size 128 - but the <code>Child</code> container won't magically know about this variable. We have to tell it by passing the variable value as a prop:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nconst Parent = (props) =&gt; {\n  return (\n    &lt;Child \n      childFragment={props.parentFragment} \n      size={128} \n    /&gt;;\n  );\n}</pre>\n<p>Now Relay will both fetch the larger photo size <em>and</em> <code>Child</code> will know to render it.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/api-reference-relay-container.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/api-reference-relay-container.html</a>\n  </p>\n</div>\n","guides-mutations":"<h1>Mutations</h1>\n<p>Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations â€“ operations that consist of writes to the data store followed by a fetch of any changed fields.</p>\n<h2 id=\"a-complete-example\">\nA complete example </h2>\n<p>Before taking a deep dive into the mutations API, let's look at a complete example. Here, we subclass <code>Relay.Mutation</code> to create a custom mutation that we can use to like a story.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass LikeStoryMutation extends Relay.Mutation {\n  // This method should return a GraphQL operation that represents\n  // the mutation to be performed. This presumes that the server\n  // implements a mutation type named â€˜likeStoryâ€™.\n  getMutation() {\n    return Relay.QL`mutation {likeStory}`;\n  }\n  // Use this method to prepare the variables that will be used as\n  // input to the mutation. Our â€˜likeStoryâ€™ mutation takes exactly\n  // one variable as input â€“ the ID of the story to like.\n  getVariables() {\n    return {storyID: this.props.story.id};\n  }\n  // Use this method to design a â€˜fat queryâ€™ â€“ one that represents every\n  // field in your data model that could change as a result of this mutation.\n  // Liking a story could affect the likers count, the sentence that\n  // summarizes who has liked a story, and the fact that the viewer likes the\n  // story or not. Relay will intersect this query with a â€˜tracked queryâ€™\n  // that represents the data that your application actually uses, and\n  // instruct the server to include only those fields in its response.\n  getFatQuery() {\n    return Relay.QL`\n      fragment on LikeStoryPayload {\n        story {\n          likers {\n            count,\n          },\n          likeSentence,\n          viewerDoesLike,\n        },\n      }\n    `;\n  }\n  // These configurations advise Relay on how to handle the LikeStoryPayload\n  // returned by the server. Here, we tell Relay to use the payload to\n  // change the fields of a record it already has in the store. The\n  // key-value pairs of â€˜fieldIDsâ€™ associate field names in the payload\n  // with the ID of the record that we want updated.\n  getConfigs() {\n    return [{\n      type: 'FIELDS_CHANGE',\n      fieldIDs: {\n        story: this.props.story.id,\n      },\n    }];\n  }\n  // This mutation has a hard dependency on the story's ID. We specify this\n  // dependency declaratively here as a GraphQL query fragment. Relay will\n  // use this fragment to ensure that the story's ID is available wherever\n  // this mutation is used.\n  static fragments = {\n    story: () =&gt; Relay.QL`\n      fragment on Story {\n        id,\n      }\n    `,\n  };\n}</pre>\n<p>Here's an example of this mutation in use by a <code>LikeButton</code> component:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass LikeButton extends React.Component {\n  _handleLike = () =&gt; {\n    // To perform a mutation, pass an instance of one to\n    // `this.props.relay.commitUpdate`\n    this.props.relay.commitUpdate(\n      new LikeStoryMutation({story: this.props.story})\n    );\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        {this.props.story.viewerDoesLike\n          ? 'You like this'\n          : &lt;button onClick={this._handleLike}&gt;Like this&lt;/button&gt;\n        }\n      &lt;/div&gt;\n    );\n  }\n}\n\nmodule.exports = Relay.createContainer(LikeButton, {\n  fragments: {\n    // You can compose a mutation's query fragments like you would those\n    // of any other RelayContainer. This ensures that the data depended\n    // upon by the mutation will be fetched and ready for use.\n    story: () =&gt; Relay.QL`\n      fragment on Story {\n        viewerDoesLike,\n        ${LikeStoryMutation.getFragment('story')},\n      }\n    `,\n  },\n});</pre>\n<p>In this particular example, the only field that the <code>LikeButton</code> cares about is <code>viewerDoesLike</code>. That field will form part of the tracked query that Relay will intersect with the fat query of <code>LikeStoryMutation</code> to determine what fields to request as part of the server's response payload for the mutation. Another component elsewhere in the application might be interested in the likers count, or the like sentence. Since those fields will automatically be added to Relay's tracked query, the <code>LikeButton</code> need not worry about requesting them explicitly.</p>\n<h2 id=\"mutation-props\">\nMutation props </h2>\n<p>Any props that we pass to the constructor of a mutation will become available to its instance methods as <code>this.props</code>. Like in components used within Relay containers, props for which a corresponding fragment has been defined will be populated by Relay with query data:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass LikeStoryMutation extends Relay.Mutation {\n  static fragments = {\n    story: () =&gt; Relay.QL`\n      fragment on Story {\n        id,\n        viewerDoesLike,\n      }\n    `,\n  };\n  getMutation() {\n    // Here, viewerDoesLike is guaranteed to be available.\n    // We can use it to make this mutation polymorphic.\n    return this.props.story.viewerDoesLike\n      ? Relay.QL`mutation {unlikeStory}`\n      : Relay.QL`mutation {likeStory}`;\n  }\n  /* ... */\n}</pre>\n<h2 id=\"fragment-variables\">\nFragment variables </h2>\n<p>Like it can be done with <a href=\"guides-containers\">Relay containers</a>, we can prepare variables for use by our mutation's fragment builders, based on the previous variables and the runtime environment.</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass RentMovieMutation extends Relay.Mutation {\n  static initialVariables = {\n    format: 'hd',\n    lang: 'en-CA',\n  };\n  static prepareVariables = (prevVariables) =&gt; {\n    var overrideVariables = {};\n    if (navigator.language) {\n      overrideVariables.lang = navigator.language;\n    }\n    var formatPreference = localStorage.getItem('formatPreference');\n    if (formatPreference) {\n      overrideVariables.format = formatPreference;\n    }\n    return {...prevVariables, ...overrideVariables};\n  };\n  static fragments = {\n    // Now we can use the variables we've prepared to fetch movies\n    // appropriate for the viewer's locale and preferences\n    movie: () =&gt; Relay.QL`\n      fragment on Movie {\n        posterImage(lang: $lang) { url },\n        trailerVideo(format: $format, lang: $lang) { url },\n      }\n    `,\n  };\n}</pre>\n<h2 id=\"the-fat-query\">\nThe fat query </h2>\n<p>Changing one thing in a system can have a ripple effect that causes other things to change in turn. Imagine a mutation that we can use to accept a friend request. This can have wide implications:</p>\n<ul>\n<li>both people's friend count will increment</li>\n<li>an edge representing the new friend will be added to the viewer's <code>friends</code> connection</li>\n<li>an edge representing the viewer will be added to the new friend's <code>friends</code> connection</li>\n<li>the viewer's friendship status with the requester will change</li>\n</ul>\n<p>Design a fat query that covers every possible field that could change:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass AcceptFriendRequestMutation extends Relay.Mutation {\n  getFatQuery() {\n    // This presumes that the server-side implementation of this mutation\n    // returns a payload of type `AcceptFriendRequestPayload` that exposes\n    // `friendEdge`, `friendRequester`, and `viewer` fields.\n    return Relay.QL`\n      fragment on AcceptFriendRequestPayload {\n        friendEdge,\n        friendRequester {\n          friends,\n          friendshipStatusWithViewer,\n        },\n        viewer {\n          friends,\n        },\n      }\n    `;\n  }\n}</pre>\n<p>This fat query looks like any other GraphQL query, with one important distinction. We know some of these fields to be non-scalar (like <code>friendEdge</code> and <code>friends</code>) but notice that we have not named any of their children by way of a subquery. In this way, we indicate to Relay that <em>anything</em> under those non-scalar fields may change as a result of this mutation.</p>\n<blockquote>\n<p>Note</p>\n<p>When designing a fat query, consider <em>all</em> of the data that might change as a result of the mutation â€“ not just the data currently in use by your application. We don't need to worry about overfetching; this query is never executed without first intersecting it with a â€˜tracked queryâ€™ of the data our application actually needs. If we omit fields in the fat query, we might observe data inconsistencies in the future when we add views with new data dependencies, or add new data dependencies to existing views.</p>\n</blockquote>\n<h2 id=\"mutator-configuration\">\nMutator configuration </h2>\n<p>We need to give Relay instructions on how to use the response payload from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</p>\n<h3 id=\"fields-change\">\n<code>FIELDS_CHANGE</code> </h3>\n<p>Any field in the payload that can be correlated by DataID with one or more records in the client-side store will be merged with the record(s) in the store.</p>\n<h4 id=\"fields-change-arguments\">\nArguments </h4>\n<ul><li>\n<p><code>fieldIDs: {[fieldName: string]: DataID | Array&lt;DataID&gt;}</code></p>\n<p>A map between a <code>fieldName</code> in the response and one or more DataIDs in the store.</p>\n</li></ul>\n<h4 id=\"fields-change-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass RenameDocumentMutation extends Relay.Mutation {\n  // This mutation declares a dependency on a document's ID\n  static fragments = {\n    document: () =&gt; Relay.QL`fragment on Document { id }`,\n  };\n  // We know that only the document's name can change as a result\n  // of this mutation, and specify it here in the fat query.\n  getFatQuery() {\n    return Relay.QL`\n      fragment on RenameDocumentMutationPayload { updatedDocument { name } }\n    `;\n  }\n  getVariables() {\n    return {id: this.props.document.id, newName: this.props.newName};\n  }\n  getConfigs() {\n    return [{\n      type: 'FIELDS_CHANGE',\n      // Correlate the `updatedDocument` field in the response\n      // with the DataID of the record we would like updated.\n      fieldIDs: {updatedDocument: this.props.document.id},\n    }];\n  }\n  /* ... */\n}</pre>\n<h3 id=\"node-delete\">\n<code>NODE_DELETE</code> </h3>\n<p>Given a parent, a connection, and one or more DataIDs in the response payload, Relay will remove the node(s) from the connection and delete the associated record(s) from the store.</p>\n<h4 id=\"node-delete-arguments\">\nArguments </h4>\n<ul>\n<li>\n<p><code>parentName: string</code></p>\n<p>The field name in the response that represents the parent of the connection</p>\n</li>\n<li>\n<p><code>parentID: string</code></p>\n<p>The DataID of the parent node that contains the connection</p>\n</li>\n<li>\n<p><code>connectionName: string</code></p>\n<p>The field name in the response that represents the connection</p>\n</li>\n<li>\n<p><code>deletedIDFieldName: string</code></p>\n<p>The field name in the response that contains the DataID of the deleted node</p>\n</li>\n</ul>\n<h4 id=\"node-delete-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass DestroyShipMutation extends Relay.Mutation {\n  // This mutation declares a dependency on an enemy ship's ID\n  // and the ID of the faction that ship belongs to.\n  static fragments = {\n    ship: () =&gt; Relay.QL`fragment on Ship { id, faction { id } }`,\n  };\n  // Destroying a ship will remove it from a faction's fleet, so we\n  // specify the faction's ships connection as part of the fat query.\n  getFatQuery() {\n    return Relay.QL`\n      fragment on DestroyShipMutationPayload {\n        destroyedShipID,\n        faction { ships },\n      }\n    `;\n  }\n  getConfigs() {\n    return [{\n      type: 'NODE_DELETE',\n      parentName: 'faction',\n      parentID: this.props.ship.faction.id,\n      connectionName: 'ships',\n      deletedIDFieldName: 'destroyedShipID',\n    }];\n  }\n  /* ... */\n}</pre>\n<h3 id=\"range-add\">\n<code>RANGE_ADD</code> </h3>\n<p>Given a parent, a connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior specified.</p>\n<h4 id=\"range-add-arguments\">\nArguments </h4>\n<ul>\n<li>\n<p><code>parentName: string</code></p>\n<p>The field name in the response that represents the parent of the connection</p>\n</li>\n<li>\n<p><code>parentID: string</code></p>\n<p>The DataID of the parent node that contains the connection</p>\n</li>\n<li>\n<p><code>connectionName: string</code></p>\n<p>The field name in the response that represents the connection</p>\n</li>\n<li>\n<p><code>edgeName: string</code></p>\n<p>The field name in the response that represents the newly created edge</p>\n</li>\n<li>\n<p><code>rangeBehaviors: {[call: string]: GraphQLMutatorConstants.RANGE_OPERATIONS} | (connectionArgs: {[argName: string]: string}) =&gt; $Enum&lt;GraphQLMutatorConstants.RANGE_OPERATIONS&gt;</code></p>\n<p>A map between printed, dot-separated GraphQL calls <em>in alphabetical order</em> and the behavior we want Relay to exhibit when adding the new edge to connections under the influence of those calls or a function accepting an array of connection arguments, returning that behavior.</p>\n</li>\n</ul>\n<p>For example, <code>rangeBehaviors</code> could be written this way:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nconst rangeBehaviors = {\n  // When the ships connection is not under the influence\n  // of any call, append the ship to the end of the connection\n  '': 'append',\n  // Prepend the ship, wherever the connection is sorted by age\n  'orderby(newest)': 'prepend',\n};</pre>\n<p>Or this way, with the same results:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nconst rangeBehaviors = ({orderby}) =&gt; {\n  if (orderby === 'newest') {\n    return 'prepend';\n  } else {\n    return 'append';\n  }\n};</pre>\n<p>Behaviors can be one of <code>'append'</code>, <code>'ignore'</code>, <code>'prepend'</code>, <code>'refetch'</code>, or <code>'remove'</code>.</p>\n<h4 id=\"range-add-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass IntroduceShipMutation extends Relay.Mutation {\n  // This mutation declares a dependency on the faction\n  // into which this ship is to be introduced.\n  static fragments = {\n    faction: () =&gt; Relay.QL`fragment on Faction { id }`,\n  };\n  // Introducing a ship will add it to a faction's fleet, so we\n  // specify the faction's ships connection as part of the fat query.\n  getFatQuery() {\n    return Relay.QL`\n      fragment on IntroduceShipPayload {\n        faction { ships },\n        newShipEdge,\n      }\n    `;\n  }\n  getConfigs() {\n    return [{\n      type: 'RANGE_ADD',\n      parentName: 'faction',\n      parentID: this.props.faction.id,\n      connectionName: 'ships',\n      edgeName: 'newShipEdge',\n      rangeBehaviors: {\n        // When the ships connection is not under the influence\n        // of any call, append the ship to the end of the connection\n        '': 'append',\n        // Prepend the ship, wherever the connection is sorted by age\n        'orderby(newest)': 'prepend',\n      },\n    }];\n  }\n  /* ... */\n}</pre>\n<h3 id=\"range-delete\">\n<code>RANGE_DELETE</code> </h3>\n<p>Given a parent, a connection, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</p>\n<h4 id=\"range-delete-arguments\">\nArguments </h4>\n<ul>\n<li>\n<p><code>parentName: string</code></p>\n<p>The field name in the response that represents the parent of the connection</p>\n</li>\n<li>\n<p><code>parentID?: string</code></p>\n<p>The DataID of the parent node that contains the connection. Omit if the parent node does not have an ID.</p>\n</li>\n<li>\n<p><code>connectionName: string</code></p>\n<p>The field name in the response that represents the connection</p>\n</li>\n<li>\n<p><code>deletedIDFieldName: string | Array&lt;string&gt;</code></p>\n<p>The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</p>\n</li>\n<li>\n<p><code>pathToConnection: Array&lt;string&gt;</code></p>\n<p>An array containing the field names between the parent and the connection, including the parent and the connection</p>\n</li>\n</ul>\n<h4 id=\"range-delete-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass RemoveTagMutation extends Relay.Mutation {\n  // This mutation declares a dependency on the\n  // todo from which this tag is being removed.\n  static fragments = {\n    todo: () =&gt; Relay.QL`fragment on Todo { id }`,\n  };\n  // Removing a tag from a todo will affect its tags connection\n  // so we specify it here as part of the fat query.\n  getFatQuery() {\n    return Relay.QL`\n      fragment on RemoveTagMutationPayload {\n        todo { tags },\n        removedTagIDs,\n      }\n    `;\n  }\n  getConfigs() {\n    return [{\n      type: 'RANGE_DELETE',\n      parentName: 'todo',\n      parentID: this.props.todo.id,\n      connectionName: 'tags',\n      deletedIDFieldName: 'removedTagIDs',\n    }];\n  }\n  /* ... */\n}</pre>\n<h3 id=\"required-children\">\n<code>REQUIRED_CHILDREN</code> </h3>\n<p>A <code>REQUIRED_CHILDREN</code> config is used to append additional children to the mutation query. You may need to use this, for example, to fetch fields on a new object created by the mutation (and which Relay would normally not attempt to fetch because it has not previously fetched anything for that object).</p>\n<p>Data fetched as a result of a <code>REQUIRED_CHILDREN</code> config is not written into the client store, but you can add code that processes it in the <code>onSuccess</code> callback that you pass into <code>commitUpdate()</code>:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nthis.props.relay.commitUpdate(\n  new CreateCouponMutation(),\n  {\n    onSuccess: response =&gt; this.setState({\n      couponCount: response.coupons.length,\n    }),\n  }\n);</pre>\n<h4 id=\"required-children-arguments\">\nArguments </h4>\n<ul><li><code>children: Array&lt;RelayQuery.Node&gt;</code></li></ul>\n<h4 id=\"required-children-example\">\nExample </h4>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass CreateCouponMutation extends Relay.Mutation&lt;Props&gt; {\n  getMutation() {\n    return Relay.QL`mutation {\n      create_coupon(data: $input)\n    }`;\n  }\n\n  getFatQuery() {\n    return Relay.QL`\n      // Note the use of `pattern: true` here to show that this\n      // connection field is to be used for pattern-matching only\n      // (to determine what to fetch) and that Relay shouldn't\n      // require the usual connection arguments like (`first` etc)\n      // to be present.\n      fragment on CouponCreatePayload @relay(pattern: true) {\n        coupons\n      }\n    `;\n  }\n\n  getConfigs() {\n    return [{\n      // If we haven't shown the coupons in the UI at the time the\n      // mutation runs, they've never been fetched and the `coupons`\n      // field in the fat query would normally be ignored.\n      // `REQUIRED_CHILDREN` forces it to be retrieved anyway.\n      type: RelayMutationType.REQUIRED_CHILDREN,\n      children: [\n        Relay.QL`\n          fragment on CouponCreatePayload {\n            coupons\n          }\n        `,\n      ],\n    }];\n  }\n}</pre>\n<h2 id=\"optimistic-updates\">\nOptimistic updates </h2>\n<p>All of the mutations we've performed so far have waited on a response from the server before updating the client-side store. Relay offers us a chance to craft an optimistic response of the same shape based on what we expect the server's response to be in the event of a successful mutation.</p>\n<p>Let's craft an optimistic response for the <code>LikeStoryMutation</code> example above:</p>\n<pre class=\"prism language-javascript\" data-language=\"javascript\">\nclass LikeStoryMutation extends Relay.Mutation {\n  /* ... */\n  // Here's the fat query from before\n  getFatQuery() {\n    return Relay.QL`\n      fragment on LikeStoryPayload {\n        story {\n          likers {\n            count,\n          },\n          likeSentence,\n          viewerDoesLike,\n        },\n      }\n    `;\n  }\n  // Let's craft an optimistic response that mimics the shape of the\n  // LikeStoryPayload, as well as the values we expect to receive.\n  getOptimisticResponse() {\n    return {\n      story: {\n        id: this.props.story.id,\n        likers: {\n          count: this.props.story.likers.count + (this.props.story.viewerDoesLike ? -1 : 1),\n        },\n        viewerDoesLike: !this.props.story.viewerDoesLike,\n      },\n    };\n  }\n  // To be able to increment the likers count, and flip the viewerDoesLike\n  // bit, we need to ensure that those pieces of data will be available to\n  // this mutation, in addition to the ID of the story.\n  static fragments = {\n    story: () =&gt; Relay.QL`\n      fragment on Story {\n        id,\n        likers { count },\n        viewerDoesLike,\n      }\n    `,\n  };\n  /* ... */\n}</pre>\n<p>You don't have to mimic the entire response payload. Here, we've punted on the like sentence, since it's difficult to localize on the client side. When the server responds, Relay will treat its payload as the source of truth, but in the meantime, the optimistic response will be applied right away, allowing the people who use our product to enjoy instant feedback after having taken an action.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the BSD License.<br>\n    <a href=\"https://facebook.github.io/relay/docs/guides-mutations.html\" class=\"_attribution-link\">https://facebook.github.io/relay/docs/guides-mutations.html</a>\n  </p>\n</div>\n"}